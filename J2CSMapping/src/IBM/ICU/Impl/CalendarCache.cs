/*
 *******************************************************************************
 * Copyright (C) 1996-2004, International Business Machines Corporation and    *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 */
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:47 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Impl {
	
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	
	/// <exclude/>
	public class CalendarCache {
	    /// <exclude/>
	    public CalendarCache() {
	        this.pIndex = 0;
	        this.size = 0;
	        this.arraySize = primes[pIndex];
	        this.threshold = (arraySize * 3) / 4;
	        this.keys = new long[arraySize];
	        this.values = new long[arraySize];
	        MakeArrays(arraySize);
	    }
	
	    private void MakeArrays(int newSize) {
	        keys = new long[newSize];
	        values = new long[newSize];
	
	        for (int i = 0; i < newSize; i++) {
	            values[i] = EMPTY;
	        }
	        arraySize = newSize;
	        threshold = (int) (arraySize * 0.75d);
	        size = 0;
	    }
	
	    /// <exclude/>
	    [MethodImpl(MethodImplOptions.Synchronized)]
	    public long Get(long key) {
	        return values[FindIndex(key)];
	    }
	
	    /// <exclude/>
	    [MethodImpl(MethodImplOptions.Synchronized)]
	    public void Put(long key, long value_ren) {
	        if (size >= threshold) {
	            Rehash();
	        }
	        int index = FindIndex(key);
	
	        keys[index] = key;
	        values[index] = value_ren;
	        size++;
	    }
	
	    private int FindIndex(long key) {
	        int index = Hash(key);
	        int delta = 0;
	
	        while (values[index] != EMPTY && keys[index] != key) {
	            if (delta == 0) {
	                delta = Hash2(key);
	            }
	            index = (index + delta) % arraySize;
	        }
	        return index;
	    }
	
	    private void Rehash() {
	        int oldSize = arraySize;
	        long[] oldKeys = keys;
	        long[] oldValues = values;
	
	        if (pIndex < primes.Length - 1) {
	            arraySize = primes[++pIndex];
	        } else {
	            arraySize = arraySize * 2 + 1;
	        }
	        size = 0;
	
	        MakeArrays(arraySize);
	        for (int i = 0; i < oldSize; i++) {
	            if (oldValues[i] != EMPTY) {
	                Put(oldKeys[i], oldValues[i]);
	            }
	        }
	        oldKeys = oldValues = null; // Help out the garbage collector
	    }
	
	    /// <summary>
	    /// Produce a uniformly-distributed hash value from an integer key. This is
	    /// essentially a linear congruential random number generator that uses the
	    /// key as its seed value.
	    /// </summary>
	    ///
	    private int Hash(long key) {
	        int h = (int) ((key * 15821 + 1) % arraySize);
	        if (h < 0) {
	            h += arraySize;
	        }
	        return h;
	    }
	
	    private int Hash2(long key) {
	        return arraySize - 2 - (int) (key % (arraySize - 2));
	    }
	
	    static private readonly int[] primes = { 61, 127, 509, 1021, 2039, 4093, 8191,
	            16381, 32749, 65521, 131071, 262139 };
	
	    private int pIndex;
	
	    private int size;
	
	    private int arraySize;
	
	    private int threshold;
	
	    private long[] keys;
	
	    private long[] values;
	
	    /// <exclude/>
	    static public long EMPTY = Int64.MinValue;
	}
}
