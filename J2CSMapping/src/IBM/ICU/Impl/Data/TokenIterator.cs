/*
 **********************************************************************
 * Copyright (c) 2004, International Business Machines
 * Corporation and others.  All Rights Reserved.
 **********************************************************************
 * Author: Alan Liu
 * Created: March 16 2004
 * Since: ICU 3.0
 **********************************************************************
 */
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/8/10 10:24 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Impl.Data {
	
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Text;
	
	/// <summary>
	/// An iterator class that returns successive string tokens from some source.
	/// String tokens are, in general, separated by rule white space in the source
	/// test. Furthermore, they may be delimited by either single or double quotes
	/// (opening and closing quotes must match). Escapes are processed using standard
	/// ICU unescaping.
	/// </summary>
	///
	public class TokenIterator {
	
	    private ResourceReader reader;
	
	    private String line;
	
	    private StringBuilder buf;
	
	    private bool done;
	
	    private int pos;
	
	    private int lastpos;
	
	    /// <summary>
	    /// Construct an iterator over the tokens returned by the given
	    /// ResourceReader, ignoring blank lines and comment lines (first non-blank
	    /// character is '#'). Note that trailing comments on a line, beginning with
	    /// the first unquoted '#', are recognized.
	    /// </summary>
	    ///
	    public TokenIterator(ResourceReader r) {
	        reader = r;
	        line = null;
	        done = false;
	        buf = new StringBuilder();
	        pos = lastpos = -1;
	    }
	
	    /// <summary>
	    /// Return the next token from this iterator, or null if the last token has
	    /// been returned.
	    /// </summary>
	    ///
	    public String Next() {
	        if (done) {
	            return null;
	        }
	        for (;;) {
	            if (line == null) {
	                line = reader.ReadLineSkippingComments();
	                if (line == null) {
	                    done = true;
	                    return null;
	                }
	                pos = 0;
	            }
	            buf.Length=0;
	            lastpos = pos;
	            pos = NextToken(pos);
	            if (pos < 0) {
	                line = null;
	                continue;
	            }
	            return buf.ToString();
	        }
	    }
	
	    /// <summary>
	    /// Return the one-based line number of the line of the last token returned
	    /// by next(). Should only be called after a call to next(); otherwise the
	    /// return value is undefined.
	    /// </summary>
	    ///
	    public int GetLineNumber() {
	        return reader.GetLineNumber();
	    }
	
	    /// <summary>
	    /// Return a string description of the position of the last line returned by
	    /// readLine() or readLineSkippingComments().
	    /// </summary>
	    ///
	    public String DescribePosition() {
	        return reader.DescribePosition() + ':' + (lastpos + 1);
	    }
	
	    /// <summary>
	    /// Read the next token from 'this.line' and append it to 'this.buf'. Tokens
	    /// are separated by rule white space. Tokens may also be delimited by double
	    /// or single quotes. The closing quote must match the opening quote. If a
	    /// '#' is encountered, the rest of the line is ignored, unless it is
	    /// backslash-escaped or within quotes.
	    /// </summary>
	    ///
	    /// <param name="pos_0">the offset into the string</param>
	    /// <returns>offset to the next character to read from line, or if the end of
	    /// the line is reached without scanning a valid token, -1</returns>
	    private int NextToken(int pos_0) {
	        pos_0 = IBM.ICU.Impl.Utility.SkipWhitespace(line, pos_0);
	        if (pos_0 == line.Length) {
	            return -1;
	        }
	        int startpos = pos_0;
	        char c = line[pos_0++];
	        char quote = (char) (0);
	        switch ((int) c) {
	        case '"':
	        case '\'':
	            quote = c;
	            break;
	        case '#':
	            return -1;
	        default:
	            buf.Append(c);
	            break;
	        }
	        int[] posref = null;
	        while (pos_0 < line.Length) {
	            c = line[pos_0]; // 16-bit ok
	            if (c == '\\') {
	                if (posref == null) {
	                    posref = new int[1];
	                }
	                posref[0] = pos_0 + 1;
	                int c32 = IBM.ICU.Impl.Utility.UnescapeAt(line, posref);
	                if (c32 < 0) {
	                    throw new Exception("Invalid escape at "
	                            + reader.DescribePosition() + ':' + pos_0);
	                }
	                IBM.ICU.Text.UTF16.Append(buf, c32);
	                pos_0 = posref[0];
	            } else if ((quote != 0 && c == quote)
	                    || (quote == 0 && IBM.ICU.Impl.UCharacterProperty.IsRuleWhiteSpace(c))) {
	                return ++pos_0;
	            } else if (quote == 0 && c == '#') {
	                return pos_0; // do NOT increment
	            } else {
	                buf.Append(c);
	                ++pos_0;
	            }
	        }
	        if (quote != 0) {
	            throw new Exception("Unterminated quote at "
	                    + reader.DescribePosition() + ':' + startpos);
	        }
	        return pos_0;
	    }
	}
}
