/*
 ******************************************************************************
 * Copyright (C) 1996-2006, International Business Machines Corporation and   *
 * others. All Rights Reserved.                                               *
 ******************************************************************************
 */

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:47 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Impl {
	
	using ILOG.J2CsMapping.IO;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	
	/// <summary>
	/// <p>
	/// A trie is a kind of compressed, serializable table of values associated with
	/// Unicode code points (0..0x10ffff).
	/// </p>
	/// <p>
	/// This class defines the basic structure of a trie and provides methods to
	/// <b>retrieve the offsets to the actual data</b>.
	/// </p>
	/// <p>
	/// Data will be the form of an array of basic types, char or int.
	/// </p>
	/// <p>
	/// The actual data format will have to be specified by the user in the inner
	/// static interface com.ibm.icu.impl.Trie.DataManipulate.
	/// </p>
	/// <p>
	/// This trie implementation is optimized for getting offset while walking
	/// forward through a UTF-16 string. Therefore, the simplest and fastest access
	/// macros are the fromLead() and fromOffsetTrail() methods. The fromBMP() method
	/// are a little more complicated; they get offsets even for lead surrogate
	/// codepoints, while the fromLead() method get special "folded" offsets for lead
	/// surrogate code units if there is relevant data associated with them. From
	/// such a folded offsets, an offset needs to be extracted to supply to the
	/// fromOffsetTrail() methods. To handle such supplementary codepoints, some
	/// offset information are kept in the data.
	/// </p>
	/// <p>
	/// Methods in com.ibm.icu.impl.Trie.DataManipulate are called to retrieve that
	/// offset from the folded value for the lead surrogate unit.
	/// </p>
	/// <p>
	/// For examples of use, see com.ibm.icu.impl.CharTrie or
	/// com.ibm.icu.impl.IntTrie.
	/// </p>
	/// </summary>
	///
	/// <seealso cref="T:IBM.ICU.Impl.CharTrie"/>
	/// <seealso cref="T:IBM.ICU.Impl.IntTrie"/>
	public abstract class Trie {
	    // public class declaration ----------------------------------------
	
	    /// <summary>
	    /// Character data in com.ibm.impl.Trie have different user-specified format
	    /// for different purposes. This interface specifies methods to be
	    /// implemented in order for com.ibm.impl.Trie, to surrogate offset
	    /// information encapsulated within the data.
	    /// </summary>
	    ///
	    /// @draft 2.1
	    public interface DataManipulate {
	        /// <summary>
	        /// Called by com.ibm.icu.impl.Trie to extract from a lead surrogate's
	        /// data the index array offset of the indexes for that lead surrogate.
	        /// </summary>
	        ///
	        /// <param name="value">data value for a surrogate from the trie, including thefolding offset</param>
	        /// <returns>data offset or 0 if there is no data for the lead surrogate</returns>
	        /// @draft 2.1
	        int GetFoldingOffset(int value_ren);
	    }
	
	    // default implementation
	    private class DefaultGetFoldingOffset : Trie.DataManipulate  {
	        public virtual int GetFoldingOffset(int value_ren) {
	            return value_ren;
	        }
	    }
	
	    // public methods --------------------------------------------------
	
	    /// <summary>
	    /// Determines if this trie has a linear latin 1 array
	    /// </summary>
	    ///
	    /// <returns>true if this trie has a linear latin 1 array, false otherwise</returns>
	    public bool IsLatin1Linear() {
	        return m_isLatin1Linear_;
	    }
	
	    /// <summary>
	    /// Checks if the argument Trie has the same data as this Trie. Attributes
	    /// are checked but not the index data.
	    /// </summary>
	    ///
	    /// <param name="other">Trie to check</param>
	    /// <returns>true if the argument Trie has the same data as this Trie, false
	    /// otherwise</returns>
	    // /CLOVER:OFF
	    public override bool Equals(Object other) {
	        if (other == (Object) this) {
	            return true;
	        }
	        if (!(other  is  Trie)) {
	            return false;
	        }
	        Trie othertrie = (Trie) other;
	        return m_isLatin1Linear_ == othertrie.m_isLatin1Linear_
	                && m_options_ == othertrie.m_options_
	                && m_dataLength_ == othertrie.m_dataLength_
	                && ILOG.J2CsMapping.Collections.Arrays.Equals(m_index_,othertrie.m_index_);
	    }
	
	    // /CLOVER:ON
	
	    /// <summary>
	    /// Gets the serialized data file size of the Trie. This is used during trie
	    /// data reading for size checking purposes.
	    /// </summary>
	    ///
	    /// <returns>size size of serialized trie data file in terms of the number of
	    /// bytes</returns>
	    public int GetSerializedDataSize() {
	        // includes signature, option, dataoffset and datalength output
	        int result = (4 << 2);
	        result += (m_dataOffset_ << 1);
	        if (IsCharTrie()) {
	            result += (m_dataLength_ << 1);
	        } else if (IsIntTrie()) {
	            result += (m_dataLength_ << 2);
	        }
	        return result;
	    }
	
	    // protected constructor -------------------------------------------
	
	    /// <summary>
	    /// Trie constructor for CharTrie use.
	    /// </summary>
	    ///
	    /// <param name="inputStream">ICU data file input stream which contains the trie</param>
	    /// <param name="dataManipulate">object containing the information to parse the trie data</param>
	    /// <exception cref="IOException">thrown when input stream does not have the right header.</exception>
	    /// @draft 2.1
        protected internal Trie(DataInputStream inputStream, Trie.DataManipulate dataManipulate)
        {
            DataInputStream input = inputStream; // new DataInputStream(inputStream);
	        // Magic number to authenticate the data.
	        int signature = input.ReadInt();
	        m_options_ = input.ReadInt();
	
	        if (!CheckHeader(signature)) {
	            throw new ArgumentException(
	                    "ICU data file error: Trie header authentication failed, please check if you have the most updated ICU data file");
	        }
	
	        if (dataManipulate != null) {
	            m_dataManipulate_ = dataManipulate;
	        } else {
	            m_dataManipulate_ = new Trie.DefaultGetFoldingOffset ();
	        }
	        m_isLatin1Linear_ = (m_options_ & HEADER_OPTIONS_LATIN1_IS_LINEAR_MASK_) != 0;
	        m_dataOffset_ = input.ReadInt();
	        m_dataLength_ = input.ReadInt();
	        Unserialize(inputStream);
	    }
	
	    /// <summary>
	    /// Trie constructor
	    /// </summary>
	    ///
	    /// <param name="index">array to be used for index</param>
	    /// <param name="options">used by the trie</param>
	    /// <param name="dataManipulate">object containing the information to parse the trie data</param>
	    /// @draft 2.2
	    protected internal Trie(char[] index, int options, Trie.DataManipulate  dataManipulate) {
	        m_options_ = options;
	        if (dataManipulate != null) {
	            m_dataManipulate_ = dataManipulate;
	        } else {
	            m_dataManipulate_ = new Trie.DefaultGetFoldingOffset ();
	        }
	        m_isLatin1Linear_ = (m_options_ & HEADER_OPTIONS_LATIN1_IS_LINEAR_MASK_) != 0;
	        m_index_ = index;
	        m_dataOffset_ = m_index_.Length;
	    }
	
	    // protected data members ------------------------------------------
	
	    /// <summary>
	    /// Lead surrogate code points' index displacement in the index array.
	    /// 0x10000-0xd800=0x2800 0x2800 >> INDEX_STAGE_1_SHIFT_
	    /// </summary>
	    ///
	    protected internal const int LEAD_INDEX_OFFSET_ = 0x2800 >> 5;
	
	    /// <summary>
	    /// Shift size for shifting right the input index. 1..9
	    /// </summary>
	    ///
	    /// @draft 2.1
	    protected internal const int INDEX_STAGE_1_SHIFT_ = 5;
	
	    /// <summary>
	    /// Shift size for shifting left the index array values. Increases possible
	    /// data size with 16-bit index values at the cost of compactability. This
	    /// requires blocks of stage 2 data to be aligned by DATA_GRANULARITY.
	    /// 0..INDEX_STAGE_1_SHIFT
	    /// </summary>
	    ///
	    /// @draft 2.1
	    protected internal const int INDEX_STAGE_2_SHIFT_ = 2;
	
	    /// <summary>
	    /// Number of data values in a stage 2 (data array) block.
	    /// </summary>
	    ///
	    protected internal const int DATA_BLOCK_LENGTH = 1 << INDEX_STAGE_1_SHIFT_;
	
	    /// <summary>
	    /// Mask for getting the lower bits from the input index. DATA_BLOCK_LENGTH -
	    /// 1.
	    /// </summary>
	    ///
	    /// @draft 2.1
	    protected internal const int INDEX_STAGE_3_MASK_ = DATA_BLOCK_LENGTH - 1;
	
	    /// <summary>
	    /// Number of bits of a trail surrogate that are used in index table lookups.
	    /// </summary>
	    ///
	    protected internal const int SURROGATE_BLOCK_BITS = 10 - INDEX_STAGE_1_SHIFT_;
	
	    /// <summary>
	    /// Number of index (stage 1) entries per lead surrogate. Same as number of
	    /// index entries for 1024 trail surrogates, ==0x400>>INDEX_STAGE_1_SHIFT_
	    /// </summary>
	    ///
	    protected internal const int SURROGATE_BLOCK_COUNT = (1 << SURROGATE_BLOCK_BITS);
	
	    /// <summary>
	    /// Length of the BMP portion of the index (stage 1) array. 
	    /// </summary>
	    ///
	    protected internal const int BMP_INDEX_LENGTH = 0x10000 >> INDEX_STAGE_1_SHIFT_;
	
	    /// <summary>
	    /// Surrogate mask to use when shifting offset to retrieve supplementary
	    /// values
	    /// </summary>
	    ///
	    /// @draft 2.1
	    protected internal const int SURROGATE_MASK_ = 0x3FF;
	
	    /// <summary>
	    /// Index or UTF16 characters
	    /// </summary>
	    ///
	    /// @draft  2.1
	    protected internal char[] m_index_;
	
	    /// <summary>
	    /// Internal TrieValue which handles the parsing of the data value. This
	    /// class is to be implemented by the user
	    /// </summary>
	    ///
	    /// @draft 2.1
	    protected internal Trie.DataManipulate  m_dataManipulate_;
	
	    /// <summary>
	    /// Start index of the data portion of the trie. CharTrie combines index and
	    /// data into a char array, so this is used to indicate the initial offset to
	    /// the data portion. Note this index always points to the initial value.
	    /// </summary>
	    ///
	    /// @draft 2.1
	    protected internal int m_dataOffset_;
	
	    /// <summary>
	    /// Length of the data array
	    /// </summary>
	    ///
	    protected internal int m_dataLength_;
	
	    // protected methods -----------------------------------------------
	
	    /// <summary>
	    /// Gets the offset to the data which the surrogate pair points to.
	    /// </summary>
	    ///
	    /// <param name="lead">lead surrogate</param>
	    /// <param name="trail">trailing surrogate</param>
	    /// <returns>offset to data</returns>
	    /// @draft 2.1
	    protected abstract internal int GetSurrogateOffset(char lead, char trail);
	
	    /// <summary>
	    /// Gets the value at the argument index
	    /// </summary>
	    ///
	    /// <param name="index">value at index will be retrieved</param>
	    /// <returns>32 bit value</returns>
	    /// @draft 2.1
	    protected abstract internal int GetValue(int index);
	
	    /// <summary>
	    /// Gets the default initial value
	    /// </summary>
	    ///
	    /// <returns>32 bit value</returns>
	    /// @draft 2.1
	    protected abstract internal int GetInitialValue();
	
	    /// <summary>
	    /// Gets the offset to the data which the index ch after variable offset
	    /// points to. Note for locating a non-supplementary character data offset,
	    /// calling
	    /// <p>
	    /// getRawOffset(0, ch);
	    /// </p>
	    /// will do. Otherwise if it is a supplementary character formed by
	    /// surrogates lead and trail. Then we would have to call getRawOffset() with
	    /// getFoldingIndexOffset(). See getSurrogateOffset().
	    /// </summary>
	    ///
	    /// <param name="offset">index offset which ch is to start from</param>
	    /// <param name="ch">index to be used after offset</param>
	    /// <returns>offset to the data</returns>
	    /// @draft 2.1
	    protected internal int GetRawOffset(int offset, char ch) {
	        return (m_index_[offset + (ch >> INDEX_STAGE_1_SHIFT_)] << INDEX_STAGE_2_SHIFT_)
	                + (ch & INDEX_STAGE_3_MASK_);
	    }
	
	    /// <summary>
	    /// Gets the offset to data which the BMP character points to Treats a lead
	    /// surrogate as a normal code point.
	    /// </summary>
	    ///
	    /// <param name="ch">BMP character</param>
	    /// <returns>offset to data</returns>
	    /// @draft 2.1
	    protected internal int GetBMPOffset(char ch) {
	        return (ch >= IBM.ICU.Text.UTF16.LEAD_SURROGATE_MIN_VALUE && ch <= IBM.ICU.Text.UTF16.LEAD_SURROGATE_MAX_VALUE) ? GetRawOffset(
	                LEAD_INDEX_OFFSET_, ch) : GetRawOffset(0, ch);
	        // using a getRawOffset(ch) makes no diff
	    }
	
	    /// <summary>
	    /// Gets the offset to the data which this lead surrogate character points
	    /// to. Data at the returned offset may contain folding offset information
	    /// for the next trailing surrogate character.
	    /// </summary>
	    ///
	    /// <param name="ch">lead surrogate character</param>
	    /// <returns>offset to data</returns>
	    /// @draft 2.1
	    protected internal int GetLeadOffset(char ch) {
	        return GetRawOffset(0, ch);
	    }
	
	    /// <summary>
	    /// Internal trie getter from a code point. Could be faster(?) but longer
	    /// with if((c32)<=0xd7ff) { (result)=_TRIE_GET_RAW(trie, data, 0, c32); }
	    /// Gets the offset to data which the codepoint points to
	    /// </summary>
	    ///
	    /// <param name="ch">codepoint</param>
	    /// <returns>offset to data</returns>
	    /// @draft 2.1
	    protected internal int GetCodePointOffset(int ch) {
	        // if ((ch >> 16) == 0) slower
	        if (ch < 0) {
	            return -1;
	        } else if (ch < IBM.ICU.Text.UTF16.LEAD_SURROGATE_MIN_VALUE) {
	            // fastpath for the part of the BMP below surrogates (D800) where
	            // getRawOffset() works
	            return GetRawOffset(0, (char) ch);
	        } else if (ch < IBM.ICU.Text.UTF16.SUPPLEMENTARY_MIN_VALUE) {
	            // BMP codepoint
	            return GetBMPOffset((char) ch);
	        } else if (ch <= IBM.ICU.Lang.UCharacter.MAX_VALUE) {
	            // look at the construction of supplementary characters
	            // trail forms the ends of it.
	            return GetSurrogateOffset(IBM.ICU.Text.UTF16.GetLeadSurrogate(ch),
	                    (char) (ch & SURROGATE_MASK_));
	        } else {
	            // return -1 if there is an error, in this case we return
	            return -1;
	        }
	    }
	
	    /// <summary>
	    /// <p>
	    /// Parses the inputstream and creates the trie index with it.
	    /// </p>
	    /// <p>
	    /// This is overwritten by the child classes.
	    /// </summary>
	    ///
	    /// <param name="inputStream">input stream containing the trie information</param>
	    /// <exception cref="IOException">thrown when data reading fails.</exception>
	    /// @draft 2.1
        protected internal virtual void Unserialize(DataInputStream inputStream)
        {
	        // indexLength is a multiple of 1024 >> INDEX_STAGE_2_SHIFT_
	        m_index_ = new char[m_dataOffset_];
            DataInputStream input = inputStream; // new DataInputStream(inputStream);
	        for (int i = 0; i < m_dataOffset_; i++) {
	            m_index_[i] = input.ReadChar();
	        }
	    }
	
	    /// <summary>
	    /// Determines if this is a 32 bit trie
	    /// </summary>
	    ///
	    /// <returns>true if options specifies this is a 32 bit trie</returns>
	    /// @draft 2.1
	    protected internal bool IsIntTrie() {
	        return (m_options_ & HEADER_OPTIONS_DATA_IS_32_BIT_) != 0;
	    }
	
	    /// <summary>
	    /// Determines if this is a 16 bit trie
	    /// </summary>
	    ///
	    /// <returns>true if this is a 16 bit trie</returns>
	    /// @draft 2.1
	    protected internal bool IsCharTrie() {
	        return (m_options_ & HEADER_OPTIONS_DATA_IS_32_BIT_) == 0;
	    }
	
	    // private data members --------------------------------------------
	
	    // struct UTrieHeader {
	    // int32_t signature;
	    // int32_t options (a bit field)
	    // int32_t indexLength
	    // int32_t dataLength
	
	    /// <summary>
	    /// Size of Trie header in bytes
	    /// </summary>
	    ///
	    protected internal const int HEADER_LENGTH_ = 4 * 4;
	
	    /// <summary>
	    /// Latin 1 option mask
	    /// </summary>
	    ///
	    protected internal const int HEADER_OPTIONS_LATIN1_IS_LINEAR_MASK_ = 0x200;
	
	    /// <summary>
	    /// Constant number to authenticate the byte block
	    /// </summary>
	    ///
	    protected internal const int HEADER_SIGNATURE_ = 0x54726965;
	
	    /// <summary>
	    /// Header option formatting
	    /// </summary>
	    ///
	    private const int HEADER_OPTIONS_SHIFT_MASK_ = 0xF;
	
	    protected internal const int HEADER_OPTIONS_INDEX_SHIFT_ = 4;
	
	    protected internal const int HEADER_OPTIONS_DATA_IS_32_BIT_ = 0x100;
	
	    /// <summary>
	    /// Flag indicator for Latin quick access data block
	    /// </summary>
	    ///
	    private bool m_isLatin1Linear_;
	
	    /// <summary>
	    /// <p>
	    /// Trie options field.
	    /// </p>
	    /// <p>
	    /// options bit field:<br>
	    /// 9 1 = Latin-1 data is stored linearly at data + DATA_BLOCK_LENGTH<br>
	    /// 8 0 = 16-bit data, 1=32-bit data<br>
	    /// 7..4 INDEX_STAGE_1_SHIFT // 0..INDEX_STAGE_2_SHIFT<br>
	    /// 3..0 INDEX_STAGE_2_SHIFT // 1..9<br>
	    /// </summary>
	    ///
	    private int m_options_;
	
	    // private methods ---------------------------------------------------
	
	    /// <summary>
	    /// Authenticates raw data header. Checking the header information, signature
	    /// and options.
	    /// </summary>
	    ///
	    /// <param name="signature">This contains the options and type of a Trie</param>
	    /// <returns>true if the header is authenticated valid</returns>
	    /// @draft 2.1
	    private bool CheckHeader(int signature) {
	        // check the signature
	        // Trie in big-endian US-ASCII (0x54726965).
	        // Magic number to authenticate the data.
	        if (signature != HEADER_SIGNATURE_) {
	            return false;
	        }
	
	        if ((m_options_ & HEADER_OPTIONS_SHIFT_MASK_) != INDEX_STAGE_1_SHIFT_
	                || ((m_options_ >> HEADER_OPTIONS_INDEX_SHIFT_) & HEADER_OPTIONS_SHIFT_MASK_) != INDEX_STAGE_2_SHIFT_) {
	            return false;
	        }
	        return true;
	    }
	}
}
