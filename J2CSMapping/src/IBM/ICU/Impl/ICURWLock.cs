// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:47 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2001-2006, International Business Machines Corporation and    
/// others. All Rights Reserved.                                                
/// </summary>
///
namespace IBM.ICU.Impl {
	
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Threading;
    using ILOG.J2CsMapping.Threading;
	
	// See Allan Holub's 1999 column in JavaWorld, and Doug Lea's code for RWLocks with writer preference.
	
	/// <summary>
	/// <p>
	/// A simple Reader/Writer lock. This assumes that there will be little writing
	/// contention. It also doesn't allow active readers to acquire and release a
	/// write lock, or deal with priority inversion issues.
	/// </p>
	/// <p>
	/// Access to the lock should be enclosed in a try/finally block in order to
	/// ensure that the lock is always released in case of exceptions:<br>
	/// <pre>
	/// try {
	/// lock.acquireRead();
	/// // use service protected by the lock
	/// } finally {
	/// lock.releaseRead();
	/// }
	/// </pre>
	/// </p>
	/// <p>
	/// The lock provides utility methods getStats and clearStats to return
	/// statistics on the use of the lock.
	/// </p>
	/// </summary>
	///
	public class ICURWLock {
	    public ICURWLock() {
	        this.writeLock = new Object();
	        this.readLock = new Object();
	        this.stats = new ICURWLock.Stats ();
	    }
	
	    private Object writeLock;
	
	    private Object readLock;
	
	    private int wwc; // waiting writers
	
	    private int rc; // active readers, -1 if there's an active writer
	
	    private int wrc; // waiting readers
	
	    private ICURWLock.Stats  stats; // maybe don't init to start...
	
	    /// <summary>
	    /// Internal class used to gather statistics on the RWLock.
	    /// </summary>
	    ///
	    public sealed class Stats {
	        /// <summary>
	        /// Number of times read access granted (read count).
	        /// </summary>
	        ///
	        public int _rc;
	
	        /// <summary>
	        /// Number of times concurrent read access granted (multiple read count).
	        /// </summary>
	        ///
	        public int _mrc;
	
	        /// <summary>
	        /// Number of times blocked for read (waiting reader count).
	        /// </summary>
	        ///
	        public int _wrc; // wait for read
	
	        /// <summary>
	        /// Number of times write access granted (writer count).
	        /// </summary>
	        ///
	        public int _wc;
	
	        /// <summary>
	        /// Number of times blocked for write (waiting writer count).
	        /// </summary>
	        ///
	        public int _wwc;
	
	        public Stats() {
	        }
	
	        public Stats(int rc_0, int mrc, int wrc_1, int wc, int wwc_2) {
	            this._rc = rc_0;
	            this._mrc = mrc;
	            this._wrc = wrc_1;
	            this._wc = wc;
	            this._wwc = wwc_2;
	        }
	
	        public Stats(ICURWLock.Stats  rhs) : this(rhs._rc, rhs._mrc, rhs._wrc, rhs._wc, rhs._wwc) {
	        }
	
	        /// <summary>
	        /// Return a string listing all the stats.
	        /// </summary>
	        ///
	        public override String ToString() {
	            return " rc: " + _rc + " mrc: " + _mrc + " wrc: " + _wrc + " wc: "
	                    + _wc + " wwc: " + _wwc;
	        }
	    }
	
	    /// <summary>
	    /// Reset the stats. Returns existing stats, if any.
	    /// </summary>
	    ///
	    [MethodImpl(MethodImplOptions.Synchronized)]
	    public ICURWLock.Stats  ResetStats() {
	        ICURWLock.Stats  result = stats;
	        stats = new ICURWLock.Stats ();
	        return result;
	    }
	
	    /// <summary>
	    /// Clear the stats (stop collecting stats). Returns existing stats, if any.
	    /// </summary>
	    ///
	    [MethodImpl(MethodImplOptions.Synchronized)]
	    public ICURWLock.Stats  ClearStats() {
	        ICURWLock.Stats  result = stats;
	        stats = null;
	        return result;
	    }
	
	    /// <summary>
	    /// Return a snapshot of the current stats. This does not reset the stats.
	    /// </summary>
	    ///
	    [MethodImpl(MethodImplOptions.Synchronized)]
	    public ICURWLock.Stats  GetStats() {
	        return (stats == null) ? null : new ICURWLock.Stats (stats);
	    }
	
	    // utilities
	
	    [MethodImpl(MethodImplOptions.Synchronized)]
	    private bool GotRead() {
	        ++rc;
	        if (stats != null) {
	            ++stats._rc;
	            if (rc > 1)
	                ++stats._mrc;
	        }
	        return true;
	    }
	
	    [MethodImpl(MethodImplOptions.Synchronized)]
	    private bool GetRead() {
	        if (rc >= 0 && wwc == 0) {
	            return GotRead();
	        }
	        ++wrc;
	        return false;
	    }
	
	    [MethodImpl(MethodImplOptions.Synchronized)]
	    private bool RetryRead() {
	        if (stats != null)
	            ++stats._wrc;
	        if (rc >= 0 && wwc == 0) {
	            --wrc;
	            return GotRead();
	        }
	        return false;
	    }
	
	    [MethodImpl(MethodImplOptions.Synchronized)]
	    private bool FinishRead() {
	        if (rc > 0) {
	            return (0 == --rc && wwc > 0);
	        }
	        throw new InvalidOperationException("no current reader to release");
	    }
	
	    [MethodImpl(MethodImplOptions.Synchronized)]
	    private bool GotWrite() {
	        rc = -1;
	        if (stats != null) {
	            ++stats._wc;
	        }
	        return true;
	    }
	
	    [MethodImpl(MethodImplOptions.Synchronized)]
	    private bool GetWrite() {
	        if (rc == 0) {
	            return GotWrite();
	        }
	        ++wwc;
	        return false;
	    }
	
	    [MethodImpl(MethodImplOptions.Synchronized)]
	    private bool RetryWrite() {
	        if (stats != null)
	            ++stats._wwc;
	        if (rc == 0) {
	            --wwc;
	            return GotWrite();
	        }
	        return false;
	    }
	
	    private const int NOTIFY_NONE = 0;
	
	    private const int NOTIFY_WRITERS = 1;
	
	    private const int NOTIFY_READERS = 2;
	
	    [MethodImpl(MethodImplOptions.Synchronized)]
	    private int FinishWrite() {
	        if (rc < 0) {
	            rc = 0;
	            if (wwc > 0) {
	                return NOTIFY_WRITERS;
	            } else if (wrc > 0) {
	                return NOTIFY_READERS;
	            } else {
	                return NOTIFY_NONE;
	            }
	        }
	        throw new InvalidOperationException("no current writer to release");
	    }
	
	    /// <summary>
	    /// <p>
	    /// Acquire a read lock, blocking until a read lock is available. Multiple
	    /// readers can concurrently hold the read lock.
	    /// </p>
	    /// <p>
	    /// If there's a writer, or a waiting writer, increment the waiting reader
	    /// count and block on this. Otherwise increment the active reader count and
	    /// return. Caller must call releaseRead when done (for example, in a finally
	    /// block).
	    /// </p>
	    /// </summary>
	    ///
	    public void AcquireRead() {
	        if (!GetRead()) {
	            for (;;) {
	                try {
	                     lock (readLock) {
	                                            ILOG.J2CsMapping.Threading.ThreadUtil.Wait(readLock);
	                                        }
	                    if (RetryRead()) {
	                        return;
	                    }
	                } catch (ThreadInterruptedException e) {
	                }
	            }
	        }
	    }
	
	    /// <summary>
	    /// <p>
	    /// Release a read lock and return. An error will be thrown if a read lock is
	    /// not currently held.
	    /// </p>
	    /// <p>
	    /// If this is the last active reader, notify the oldest waiting writer. Call
	    /// when finished with work controlled by acquireRead.
	    /// </p>
	    /// </summary>
	    ///
	    public void ReleaseRead() {
	        if (FinishRead()) {
	             lock (writeLock) {
                     // TODO:writeLock.Notify();
	                        }
	        }
	    }
	
	    /// <summary>
	    /// <p>
	    /// Acquire the write lock, blocking until the write lock is available. Only
	    /// one writer can acquire the write lock, and when held, no readers can
	    /// acquire the read lock.
	    /// </p>
	    /// <p>
	    /// If there are no readers and no waiting writers, mark as having an active
	    /// writer and return. Otherwise, add a lock to the end of the waiting writer
	    /// list, and block on it. Caller must call releaseWrite when done (for
	    /// example, in a finally block).
	    /// <p>
	    /// </summary>
	    ///
	    public void AcquireWrite() {
	        if (!GetWrite()) {
	            for (;;) {
	                try {
	                     lock (writeLock) {
	                                            ILOG.J2CsMapping.Threading.ThreadUtil.Wait(writeLock);
	                                        }
	                    if (RetryWrite()) {
	                        return;
	                    }
	                } catch (ThreadInterruptedException e) {
	                }
	            }
	        }
	    }
	
	    /// <summary>
	    /// <p>
	    /// Release the write lock and return. An error will be thrown if the write
	    /// lock is not currently held.
	    /// </p>
	    /// <p>
	    /// If there are waiting readers, make them all active and notify all of
	    /// them. Otherwise, notify the oldest waiting writer, if any. Call when
	    /// finished with work controlled by acquireWrite.
	    /// </p>
	    /// </summary>
	    ///
	    public void ReleaseWrite() {
	        switch (FinishWrite()) {
	        case NOTIFY_WRITERS:
	             lock (writeLock) {
	                            ThreadUtil.Notify(writeLock);
	                        }
	            break;
	        case NOTIFY_READERS:
	             lock (readLock) {
	                            ILOG.J2CsMapping.Threading.ThreadUtil.NotifyAll(readLock);
	                        }
	            break;
	        case NOTIFY_NONE:
	            break;
	        }
	    }
	}
}
