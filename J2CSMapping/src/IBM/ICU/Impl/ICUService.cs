// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:47 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2001-2007, International Business Machines Corporation and    
/// others. All Rights Reserved.                                                
/// </summary>
///
namespace IBM.ICU.Impl {
	
	using IBM.ICU.Util;
	using ILOG.J2CsMapping.Collections;
	using ILOG.J2CsMapping.Collections.Generics;
	using ILOG.J2CsMapping.Util;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Text;
	
	/// <summary>
	/// <p>
	/// A Service provides access to service objects that implement a particular
	/// service, e.g. transliterators. Users provide a String id (for example, a
	/// locale string) to the service, and get back an object for that id. Service
	/// objects can be any kind of object. The service object is cached and returned
	/// for later queries, so generally it should not be mutable, or the caller
	/// should clone the object before modifying it.
	/// </p>
	/// <p>
	/// Services 'canonicalize' the query id and use the canonical id to query for
	/// the service. The service also defines a mechanism to 'fallback' the id
	/// multiple times. Clients can optionally request the actual id that was matched
	/// by a query when they use an id to retrieve a service object.
	/// </p>
	/// <p>
	/// Service objects are instantiated by Factory objects registered with the
	/// service. The service queries each Factory in turn, from most recently
	/// registered to earliest registered, until one returns a service object. If
	/// none responds with a service object, a fallback id is generated, and the
	/// process repeats until a service object is returned or until the id has no
	/// further fallbacks.
	/// </p>
	/// <p>
	/// Factories can be dynamically registered and unregistered with the service.
	/// When registered, a Factory is installed at the head of the factory list, and
	/// so gets 'first crack' at any keys or fallback keys. When unregistered, it is
	/// removed from the service and can no longer be located through it. Service
	/// objects generated by this factory and held by the client are unaffected.
	/// </p>
	/// <p>
	/// ICUService uses Keys to query factories and perform fallback. The Key defines
	/// the canonical form of the id, and implements the fallback strategy. Custom
	/// Keys can be defined that parse complex IDs into components that Factories can
	/// more easily use. The Key can cache the results of this parsing to save
	/// repeated effort. ICUService provides convenience APIs that take Strings and
	/// generate default Keys for use in querying.
	/// </p>
	/// <p>
	/// ICUService provides API to get the list of ids publicly supported by the
	/// service (although queries aren't restricted to this list). This list contains
	/// only 'simple' IDs, and not fully unique ids. Factories are associated with
	/// each simple ID and the responsible factory can also return a human-readable
	/// localized version of the simple ID, for use in user interfaces. ICUService
	/// can also provide a sorted collection of the all the localized visible ids.
	/// </p>
	/// <p>
	/// ICUService implements ICUNotifier, so that clients can register to receive
	/// notification when factories are added or removed from the service. ICUService
	/// provides a default EventListener subinterface, ServiceListener, which can be
	/// registered with the service. When the service changes, the ServiceListener's
	/// serviceChanged method is called, with the service as the only argument.
	/// </p>
	/// <p>
	/// The ICUService API is both rich and generic, and it is expected that most
	/// implementations will statically 'wrap' ICUService to present a more
	/// appropriate API-- for example, to declare the type of the objects returned
	/// from get, to limit the factories that can be registered with the service, or
	/// to define their own listener interface with a custom callback method. They
	/// might also customize ICUService by overriding it, for example, to customize
	/// the Key and fallback strategy. ICULocaleService is a customized service that
	/// uses Locale names as ids and uses Keys that implement the standard resource
	/// bundle fallback strategy.
	/// <p>
	/// </summary>
	///
	public class ICUService : ICUNotifier {
	    /// <summary>
	    /// Name used for debugging.
	    /// </summary>
	    ///
	    protected internal readonly String name;
	
	    /// <summary>
	    /// Constructor.
	    /// </summary>
	    ///
	    public ICUService() {
	        this.factoryLock = new ICURWLock();
	        this.factories = new ArrayList();
	        this.defaultSize = 0;
	        name = "";
	    }
	
	    private static readonly bool DEBUG = IBM.ICU.Impl.ICUDebug.Enabled("service");
	
	    /// <summary>
	    /// Construct with a name (useful for debugging).
	    /// </summary>
	    ///
	    public ICUService(String name_0) {
	        this.factoryLock = new ICURWLock();
	        this.factories = new ArrayList();
	        this.defaultSize = 0;
	        this.name = name_0;
	    }
	
	    /// <summary>
	    /// Access to factories is protected by a read-write lock. This is to allow
	    /// multiple threads to read concurrently, but keep changes to the factory
	    /// list atomic with respect to all readers.
	    /// </summary>
	    ///
	    private readonly ICURWLock factoryLock;
	
	    /// <summary>
	    /// All the factories registered with this service.
	    /// </summary>
	    ///
	    private readonly IList factories;
	
	    /// <summary>
	    /// Record the default number of factories for this service. Can be set by
	    /// markDefault.
	    /// </summary>
	    ///
	    private int defaultSize;
	
	    /// <summary>
	    /// Keys are used to communicate with factories to generate an instance of
	    /// the service. Keys define how ids are canonicalized, provide both a
	    /// current id and a current descriptor to use in querying the cache and
	    /// factories, and determine the fallback strategy.</p>
	    /// <p>
	    /// Keys provide both a currentDescriptor and a currentID. The descriptor
	    /// contains an optional prefix, followed by '/' and the currentID. Factories
	    /// that handle complex keys, for example number format factories that
	    /// generate multiple kinds of formatters for the same locale, use the
	    /// descriptor to provide a fully unique identifier for the service object,
	    /// while using the currentID (in this case, the locale string), as the
	    /// visible IDs that can be localized.
	    /// <p>
	    /// The default implementation of Key has no fallbacks and has no custom
	    /// descriptors.
	    /// </p>
	    /// </summary>
	    ///
	    public class Key {
	        private readonly String id;
	
	        /// <summary>
	        /// Construct a key from an id.
	        /// </summary>
	        ///
	        public Key(String id_0) {
	            this.id = id_0;
	        }
	
	        /// <summary>
	        /// Return the original ID used to construct this key.
	        /// </summary>
	        ///
	        public String Id() {
	            return id;
	        }
	
	        /// <summary>
	        /// Return the canonical version of the original ID. This implementation
	        /// returns the original ID unchanged.
	        /// </summary>
	        ///
	        public virtual String CanonicalID() {
	            return id;
	        }
	
	        /// <summary>
	        /// Return the (canonical) current ID. This implementation returns the
	        /// canonical ID.
	        /// </summary>
	        ///
	        public virtual String CurrentID() {
	            return CanonicalID();
	        }
	
	        /// <summary>
	        /// Return the current descriptor. This implementation returns the
	        /// current ID. The current descriptor is used to fully identify an
	        /// instance of the service in the cache. A factory may handle all
	        /// descriptors for an ID, or just a particular descriptor. The factory
	        /// can either parse the descriptor or use custom API on the key in order
	        /// to instantiate the service.
	        /// </summary>
	        ///
	        public virtual String CurrentDescriptor() {
	            return "/" + CurrentID();
	        }
	
	        /// <summary>
	        /// If the key has a fallback, modify the key and return true, otherwise
	        /// return false. The current ID will change if there is a fallback. No
	        /// currentIDs should be repeated, and fallback must eventually return
	        /// false. This implmentation has no fallbacks and always returns false.
	        /// </summary>
	        ///
	        public virtual bool Fallback() {
	            return false;
	        }
	
	        /// <summary>
	        /// If a key created from id would eventually fallback to match the
	        /// canonical ID of this key, return true.
	        /// </summary>
	        ///
	        public virtual bool IsFallbackOf(String idToCheck) {
	            return CanonicalID().Equals(idToCheck);
	        }
	    }
	
	    /// <summary>
	    /// Factories generate the service objects maintained by the service. A
	    /// factory generates a service object from a key, updates id->factory
	    /// mappings, and returns the display name for a supported id.
	    /// </summary>
	    ///
	    public interface Factory {
	
	        /// <summary>
	        /// Create a service object from the key, if this factory supports the
	        /// key. Otherwise, return null.
	        /// <p>
	        /// If the factory supports the key, then it can call the service's
	        /// getKey(Key, String[], Factory) method passing itself as the factory
	        /// to get the object that the service would have created prior to the
	        /// factory's registration with the service. This can change the key, so
	        /// any information required from the key should be extracted before
	        /// making such a callback.
	        /// </summary>
	        ///
	        Object Create(ICUService.Key  key, ICUService service);
	
	        /// <summary>
	        /// Update the result IDs (not descriptors) to reflect the IDs this
	        /// factory handles. This function and getDisplayName are used to support
	        /// ICUService.getDisplayNames. Basically, the factory has to determine
	        /// which IDs it will permit to be available, and of those, which it will
	        /// provide localized display names for. In most cases this reflects the
	        /// IDs that the factory directly supports.
	        /// </summary>
	        ///
	        void UpdateVisibleIDs(IDictionary result);
	
	        /// <summary>
	        /// Return the display name for this id in the provided locale. This is
	        /// an localized id, not a descriptor. If the id is not visible or not
	        /// defined by the factory, return null. If locale is null, return id
	        /// unchanged.
	        /// </summary>
	        ///
	        String GetDisplayName(String id_0, ULocale locale);
	    }
	
	    /// <summary>
	    /// A default implementation of factory. This provides default
	    /// implementations for subclasses, and implements a singleton factory that
	    /// matches a single id and returns a single (possibly deferred-initialized)
	    /// instance. This implements updateVisibleIDs to add a mapping from its ID
	    /// to itself if visible is true, or to remove any existing mapping for its
	    /// ID if visible is false.
	    /// </summary>
	    ///
	    public class SimpleFactory : ICUService.Factory  {
	        protected internal Object instance;
	
	        protected internal String id;
	
	        protected internal bool visible;
	
	        /// <summary>
	        /// Convenience constructor that calls SimpleFactory(Object, String,
	        /// boolean) with visible true.
	        /// </summary>
	        ///
	        public SimpleFactory(Object instance_0, String id_1) : this(instance_0, id_1, true) {
	        }
	
	        /// <summary>
	        /// Construct a simple factory that maps a single id to a single service
	        /// instance. If visible is true, the id will be visible. Neither the
	        /// instance nor the id can be null.
	        /// </summary>
	        ///
	        public SimpleFactory(Object instance_0, String id_1, bool visible_2) {
	            if (instance_0 == null || id_1 == null) {
	                throw new ArgumentException("Instance or id is null");
	            }
	            this.instance = instance_0;
	            this.id = id_1;
	            this.visible = visible_2;
	        }
	
	        /// <summary>
	        /// Return the service instance if the factory's id is equal to the key's
	        /// currentID. Service is ignored.
	        /// </summary>
	        ///
	        public virtual Object Create(ICUService.Key  key, ICUService service) {
	            if (id.Equals(key.CurrentID())) {
	                return instance;
	            }
	            return null;
	        }
	
	        /// <summary>
	        /// If visible, adds a mapping from id -> this to the result, otherwise
	        /// removes id from result.
	        /// </summary>
	        ///
	        public virtual void UpdateVisibleIDs(IDictionary result) {
	            if (visible) {
	                ILOG.J2CsMapping.Collections.Collections.Put(result,id,this);
	            } else {
	                ILOG.J2CsMapping.Collections.Collections.Remove(result,id);
	            }
	        }
	
	        /// <summary>
	        /// If this.id equals id, returns id regardless of locale, otherwise
	        /// returns null. (This default implementation has no localized id
	        /// information.)
	        /// </summary>
	        ///
	        public virtual String GetDisplayName(String id_0, ULocale locale) {
	            return (visible && this.id.Equals(id_0)) ? id_0 : null;
	        }
	
	        /// <summary>
	        /// For debugging.
	        /// </summary>
	        ///
	        public override String ToString() {
	            StringBuilder buf = new StringBuilder(base.ToString());
	            buf.Append(", id: ");
	            buf.Append(id);
	            buf.Append(", visible: ");
	            buf.Append(visible);
	            return buf.ToString();
	        }
	    }
	
	    /// <summary>
	    /// Convenience override for get(String, String[]). This uses createKey to
	    /// create a key for the provided descriptor.
	    /// </summary>
	    ///
	    public Object Get(String descriptor) {
	        return GetKey(CreateKey(descriptor), null);
	    }
	
	    /// <summary>
	    /// Convenience override for get(Key, String[]). This uses createKey to
	    /// create a key from the provided descriptor.
	    /// </summary>
	    ///
	    public Object Get(String descriptor, String[] actualReturn) {
	        if (descriptor == null) {
	            throw new NullReferenceException("descriptor must not be null");
	        }
	        return GetKey(CreateKey(descriptor), actualReturn);
	    }
	
	    /// <summary>
	    /// Convenience override for get(Key, String[]).
	    /// </summary>
	    ///
	    public Object GetKey(ICUService.Key  key) {
	        return GetKey(key, null);
	    }
	
	    /// <summary>
	    /// <p>
	    /// Given a key, return a service object, and, if actualReturn is not null,
	    /// the descriptor with which it was found in the first element of
	    /// actualReturn. If no service object matches this key, return null, and
	    /// leave actualReturn unchanged.
	    /// </p>
	    /// <p>
	    /// This queries the cache using the key's descriptor, and if no object in
	    /// the cache matches it, tries the key on each registered factory, in order.
	    /// If none generates a service object for the key, repeats the process with
	    /// each fallback of the key, until either one returns a service object, or
	    /// the key has no fallback.
	    /// </p>
	    /// <p>
	    /// If key is null, just returns null.
	    /// </p>
	    /// </summary>
	    ///
	    public Object GetKey(ICUService.Key  key, String[] actualReturn) {
	        return GetKey(key, actualReturn, null);
	    }
	
	    // debugging
	    // Map hardRef;
	
	    public Object GetKey(ICUService.Key  key, String[] actualReturn, ICUService.Factory  factory) {
	        if (factories.Count == 0) {
	            return HandleDefault(key, actualReturn);
	        }
	
	        if (DEBUG)
	            System.Console.Out.WriteLine("Service: " + name + " key: "
	                    + key.CanonicalID());
	
	        ICUService.CacheEntry  result = null;
	        if (key != null) {
	            try {
	                // The factory list can't be modified until we're done,
	                // otherwise we might update the cache with an invalid result.
	                // The cache has to stay in synch with the factory list.
	                factoryLock.AcquireRead();
	
	                IDictionary cache = null;
	                WeakReference cref = cacheref; // copy so we don't need to sync
	                                               // on this
	                if (cref != null) {
	                    if (DEBUG)
	                        System.Console.Out.WriteLine("Service " + name + " ref exists");
	                    cache = (IDictionary) cref.Target;
	                }
	                if (cache == null) {
	                    if (DEBUG)
	                        System.Console.Out.WriteLine("Service " + name
	                                + " cache was empty");
	                    // synchronized since additions and queries on the cache
	                    // must be atomic
	                    // they can be interleaved, though
	                    cache = ILOG.J2CsMapping.Collections.Generics.Collections.SynchronizedMap(new Hashtable());
	                    // hardRef = cache; // debug
	                    cref = new WeakReference(cache);
	                }
	
	                String currentDescriptor = null;
	                ArrayList cacheDescriptorList = null;
	                bool putInCache = false;
	
	                int NDebug = 0;
	
	                int startIndex = 0;
	                int limit = factories.Count;
	                bool cacheResult = true;
	                if (factory != null) {
	                    for (int i = 0; i < limit; ++i) {
	                        if ((Object) factory == factories[i]) {
	                            startIndex = i + 1;
	                            break;
	                        }
	                    }
	                    if (startIndex == 0) {
	                        throw new InvalidOperationException("Factory " + factory
	                                + "not registered with service: " + this);
	                    }
	                    cacheResult = false;
	                }
	
	                outer: {
	                    do {
	                        currentDescriptor = key.CurrentDescriptor();
	                        if (DEBUG)
	                            System.Console.Out.WriteLine(name + "[" + NDebug++
	                                    + "] looking for: " + currentDescriptor);
	                        result = (ICUService.CacheEntry ) ILOG.J2CsMapping.Collections.Collections.Get(cache,currentDescriptor);
	                        if (result != null) {
	                            if (DEBUG)
	                                System.Console.Out.WriteLine(name
	                                        + " found with descriptor: "
	                                        + currentDescriptor);
	                            goto gotoouter;
	                        } else {
	                            if (DEBUG)
	                                System.Console.Out.WriteLine("did not find: "
	                                        + currentDescriptor + " in cache");
	                        }
	
	                        // first test of cache failed, so we'll have to update
	                        // the cache if we eventually succeed-- that is, if we're
	                        // going to update the cache at all.
	                        putInCache = cacheResult;
	
	                        // int n = 0;
	                        int index = startIndex;
	                        while (index < limit) {
	                            ICUService.Factory  f = (ICUService.Factory ) factories[index++];
	                            if (DEBUG)
	                                System.Console.Out.WriteLine("trying factory[" + (index - 1)
	                                        + "] " + f.ToString());
	                            Object service = f.Create(key, this);
	                            if (service != null) {
	                                result = new ICUService.CacheEntry (currentDescriptor, service);
	                                if (DEBUG)
	                                    System.Console.Out.WriteLine(name
	                                            + " factory supported: "
	                                            + currentDescriptor + ", caching");
	                                goto gotoouter;
	                            } else {
	                                if (DEBUG)
	                                    System.Console.Out.WriteLine("factory did not support: "
	                                            + currentDescriptor);
	                            }
	                        }
	
	                        // prepare to load the cache with all additional ids that
	                        // will resolve to result, assuming we'll succeed. We
	                        // don't want to keep querying on an id that's going to
	                        // fallback to the one that succeeded, we want to hit the
	                        // cache the first time next goaround.
	                        if (cacheDescriptorList == null) {
	                            cacheDescriptorList = new ArrayList(5);
	                        }
	                        ILOG.J2CsMapping.Collections.Generics.Collections.Add(cacheDescriptorList,currentDescriptor);
	
	                    } while (key.Fallback());
	                }
	                gotoouter:
	                ;
	
	                if (result != null) {
	                    if (putInCache) {
	                        if (DEBUG)
	                            System.Console.Out.WriteLine("caching '"
	                                    + result.actualDescriptor + "'");
	                        ILOG.J2CsMapping.Collections.Collections.Put(cache,result.actualDescriptor,result);
	                        if (cacheDescriptorList != null) {
	                            IIterator iter = new ILOG.J2CsMapping.Collections.IteratorAdapter(cacheDescriptorList.GetEnumerator());
	                            while (iter.HasNext()) {
	                                String desc = (String) iter.Next();
	                                if (DEBUG)
	                                    System.Console.Out.WriteLine(name
	                                            + " adding descriptor: '" + desc
	                                            + "' for actual: '"
	                                            + result.actualDescriptor + "'");
	
	                                ILOG.J2CsMapping.Collections.Collections.Put(cache,desc,result);
	                            }
	                        }
	                        // Atomic update. We held the read lock all this time
	                        // so we know our cache is consistent with the factory
	                        // list.
	                        // We might stomp over a cache that some other thread
	                        // rebuilt, but that's the breaks. They're both good.
	                        cacheref = cref;
	                    }
	
	                    if (actualReturn != null) {
	                        // strip null prefix
	                        if (result.actualDescriptor.IndexOf("/") == 0) {
	                            actualReturn[0] = result.actualDescriptor.Substring(1);
	                        } else {
	                            actualReturn[0] = result.actualDescriptor;
	                        }
	                    }
	
	                    if (DEBUG)
	                        System.Console.Out.WriteLine("found in service: " + name);
	
	                    return result.service;
	                }
	            } finally {
	                factoryLock.ReleaseRead();
	            }
	        }
	
	        if (DEBUG)
	            System.Console.Out.WriteLine("not found in service: " + name);
	
	        return HandleDefault(key, actualReturn);
	    }
	
	    private WeakReference cacheref;
	
	    // Record the actual id for this service in the cache, so we can return it
	    // even if we succeed later with a different id.
	    private sealed class CacheEntry {
	        internal readonly String actualDescriptor;
	
	        internal readonly Object service;
	
	        internal CacheEntry(String actualDescriptor_0, Object service_1) {
	            this.actualDescriptor = actualDescriptor_0;
	            this.service = service_1;
	        }
	    }
	
	    /// <summary>
	    /// Default handler for this service if no factory in the list handled the
	    /// key.
	    /// </summary>
	    ///
	    protected internal virtual Object HandleDefault(ICUService.Key  key, String[] actualIDReturn) {
	        return null;
	    }
	
	    /// <summary>
	    /// Convenience override for getVisibleIDs(String) that passes null as the
	    /// fallback, thus returning all visible IDs.
	    /// </summary>
	    ///
	    public ILOG.J2CsMapping.Collections.ISet GetVisibleIDs() {
	        return GetVisibleIDs(null);
	    }
	
	    /// <summary>
	    /// <p>
	    /// Return a snapshot of the visible IDs for this service. This set will not
	    /// change as Factories are added or removed, but the supported ids will, so
	    /// there is no guarantee that all and only the ids in the returned set are
	    /// visible and supported by the service in subsequent calls.
	    /// </p>
	    /// <p>
	    /// matchID is passed to createKey to create a key. If the key is not null,
	    /// it is used to filter out ids that don't have the key as a fallback.
	    /// </summary>
	    ///
	    public ILOG.J2CsMapping.Collections.ISet GetVisibleIDs(String matchID) {
	        ILOG.J2CsMapping.Collections.ISet result = new ILOG.J2CsMapping.Collections.ListSet(GetVisibleIDMap().Keys);
	
	        ICUService.Key  fallbackKey = CreateKey(matchID);
	
	        if (fallbackKey != null) {
	            ILOG.J2CsMapping.Collections.ISet temp = new HashedSet(result.Count);
	            IIterator iter = new ILOG.J2CsMapping.Collections.IteratorAdapter(result.GetEnumerator());
	            while (iter.HasNext()) {
	                String id_0 = (String) iter.Next();
	                if (fallbackKey.IsFallbackOf(id_0)) {
	                    ILOG.J2CsMapping.Collections.Generics.Collections.Add(temp,id_0);
	                }
	            }
	            result = temp;
	        }
	        return result;
	    }
	
	    /// <summary>
	    /// Return a map from visible ids to factories.
	    /// </summary>
	    ///
	    private IDictionary GetVisibleIDMap() {
	        IDictionary idcache = null;
	        WeakReference xref = idref;
	        if (xref != null) {
	            idcache = (IDictionary) xref.Target;
	        }
	        while (idcache == null) {
	             lock (this) { // or idref-only lock?
	                            if (xref == idref || idref == null) {
	                                // no other thread updated idref before we got the lock, so
	                                // grab the factory list and update it ourselves
	                                try {
	                                    factoryLock.AcquireRead();
	                                    idcache = new Hashtable();
	                                    IListIterator lIter = new ILOG.J2CsMapping.Collections.ArrayListIterator(factories,factories.Count);
	                                    while (lIter.HasPrevious()) {
	                                        ICUService.Factory  f = (ICUService.Factory ) lIter.Previous();
	                                        f.UpdateVisibleIDs(idcache);
	                                    }
	                                    idcache = ILOG.J2CsMapping.Collections.Collections.UnmodifiableMap(idcache);
	                                    idref = new WeakReference(idcache);
	                                } finally {
	                                    factoryLock.ReleaseRead();
	                                }
	                            } else {
	                                // another thread updated idref, but gc may have stepped
	                                // in and undone its work, leaving idcache null. If so,
	                                // retry.
	                                xref = idref;
	                                idcache = (IDictionary) xref.Target;
	                            }
	                        }
	        }
	
	        return idcache;
	    }
	
	    private WeakReference idref;
	
	    /// <summary>
	    /// Convenience override for getDisplayName(String, ULocale) that uses the
	    /// current default locale.
	    /// </summary>
	    ///
	    public String GetDisplayName(String id_0) {
	        return GetDisplayName(id_0, IBM.ICU.Util.ULocale.GetDefault());
	    }
	
	    /// <summary>
	    /// Given a visible id, return the display name in the requested locale. If
	    /// there is no directly supported id corresponding to this id, return null.
	    /// </summary>
	    ///
	    public String GetDisplayName(String id_0, ULocale locale) {
	        IDictionary m = GetVisibleIDMap();
	        ICUService.Factory  f = (ICUService.Factory ) ILOG.J2CsMapping.Collections.Collections.Get(m,id_0);
	        if (f != null) {
	            return f.GetDisplayName(id_0, locale);
	        }
	
	        ICUService.Key  key = CreateKey(id_0);
	        while (key.Fallback()) {
	            f = (ICUService.Factory ) ILOG.J2CsMapping.Collections.Collections.Get(m,key.CurrentID());
	            if (f != null) {
	                return f.GetDisplayName(id_0, locale);
	            }
	        }
	
	        return null;
	    }
	
	    /// <summary>
	    /// Convenience override of getDisplayNames(ULocale, Comparator, String) that
	    /// uses the current default Locale as the locale, null as the comparator,
	    /// and null for the matchID.
	    /// </summary>
	    ///
	    public SortedList GetDisplayNames() {
	        ULocale locale = IBM.ICU.Util.ULocale.GetDefault();
	        return GetDisplayNames(locale, null, null);
	    }
	
	    /// <summary>
	    /// Convenience override of getDisplayNames(ULocale, Comparator, String) that
	    /// uses null for the comparator, and null for the matchID.
	    /// </summary>
	    ///
	    public SortedList GetDisplayNames(ULocale locale) {
	        return GetDisplayNames(locale, null, null);
	    }
	
	    /// <summary>
	    /// Convenience override of getDisplayNames(ULocale, Comparator, String) that
	    /// uses null for the matchID, thus returning all display names.
	    /// </summary>
	    ///
	    public SortedList GetDisplayNames(ULocale locale, IComparer com) {
	        return GetDisplayNames(locale, com, null);
	    }
	
	    /// <summary>
	    /// Convenience override of getDisplayNames(ULocale, Comparator, String) that
	    /// uses null for the comparator.
	    /// </summary>
	    ///
	    public SortedList GetDisplayNames(ULocale locale, String matchID) {
	        return GetDisplayNames(locale, null, matchID);
	    }
	
	    /// <summary>
	    /// Return a snapshot of the mapping from display names to visible IDs for
	    /// this service. This set will not change as factories are added or removed,
	    /// but the supported ids will, so there is no guarantee that all and only
	    /// the ids in the returned map will be visible and supported by the service
	    /// in subsequent calls, nor is there any guarantee that the current display
	    /// names match those in the set. The display names are sorted based on the
	    /// comparator provided.
	    /// </summary>
	    ///
	    public SortedList GetDisplayNames(ULocale locale, IComparer com,
	            String matchID) {
	        SortedList dncache = null;
	        ICUService.LocaleRef  xref = dnref;
	
	        if (xref != null) {
	            dncache = xref.Get(locale, com);
	        }
	
	        while (dncache == null) {
	             lock (this) {
	                            if (xref == dnref || dnref == null) {
	                                dncache = new SortedList(com); // sorted
	            
	                                IDictionary m = GetVisibleIDMap();
	                                IIterator ei = new ILOG.J2CsMapping.Collections.IteratorAdapter(m.GetEnumerator());
	                                while (ei.HasNext()) {
	                                    DictionaryEntry e = (DictionaryEntry) ei.Next();
	                                    String id_0 = (String) ((DictionaryEntry) e).Key;
	                                    ICUService.Factory  f = (ICUService.Factory ) ((DictionaryEntry) e).Value;
	                                    ILOG.J2CsMapping.Collections.Collections.Put(dncache,f.GetDisplayName(id_0, locale),id_0);
	                                }
	            
	                                dncache = /*ILOG.J2CsMapping.Collections.Generics.Collections.UnmodifiableSortedMap(*/dncache/*)*/;
	                                dnref = new ICUService.LocaleRef (dncache, locale, com);
	                            } else {
	                                xref = dnref;
	                                dncache = xref.Get(locale, com);
	                            }
	                        }
	        }
	
	        ICUService.Key  matchKey = CreateKey(matchID);
	        if (matchKey == null) {
	            return dncache;
	        }
	
	        SortedList result = new SortedList(dncache);
	        IIterator iter = new ILOG.J2CsMapping.Collections.IteratorAdapter(result.GetEnumerator());
	        while (iter.HasNext()) {
	            DictionaryEntry e_1 = (DictionaryEntry) iter.Next();
	            if (!matchKey.IsFallbackOf((String) ((DictionaryEntry) e_1).Value)) {
	                iter.Remove();
	            }
	        }
	        return result;
	    }
	
	    // we define a class so we get atomic simultaneous access to the
	    // locale, comparator, and corresponding map.
	    private class LocaleRef {
	        private readonly ULocale locale;
	
	        private WeakReference xref;
	
	        private IComparer com;
	
	        internal LocaleRef(IDictionary dnCache, ULocale locale_0, IComparer com_1) {
	            this.locale = locale_0;
	            this.com = com_1;
	            this.xref = new WeakReference(dnCache);
	        }
	
	        internal SortedList Get(ULocale loc, IComparer comp) {
	            SortedList m = (SortedList) xref.Target;
	            if (m != null
	                    && this.locale.Equals(loc)
	                    && (this.com == comp || (this.com != null && this.com
	                            .Equals(comp)))) {
	
	                return m;
	            }
	            return null;
	        }
	    }
	
	    private ICUService.LocaleRef  dnref;
	
	    /// <summary>
	    /// Return a snapshot of the currently registered factories. There is no
	    /// guarantee that the list will still match the current factory list of the
	    /// service subsequent to this call.
	    /// </summary>
	    ///
	    public IList Factories() {
	        try {
	            factoryLock.AcquireRead();
	            return new ArrayList(factories);
	        } finally {
	            factoryLock.ReleaseRead();
	        }
	    }
	
	    /// <summary>
	    /// A convenience override of registerObject(Object, String, boolean) that
	    /// defaults visible to true.
	    /// </summary>
	    ///
	    public ICUService.Factory  RegisterObject(Object obj, String id_0) {
	        return RegisterObject(obj, id_0, true);
	    }
	
	    /// <summary>
	    /// Register an object with the provided id. The id will be canonicalized.
	    /// The canonicalized ID will be returned by getVisibleIDs if visible is
	    /// true.
	    /// </summary>
	    ///
	    public ICUService.Factory  RegisterObject(Object obj, String id_0, bool visible_1) {
	        String canonicalID = CreateKey(id_0).CanonicalID();
	        return RegisterFactory(new ICUService.SimpleFactory (obj, canonicalID, visible_1));
	    }
	
	    /// <summary>
	    /// Register a Factory. Returns the factory if the service accepts the
	    /// factory, otherwise returns null. The default implementation accepts all
	    /// factories.
	    /// </summary>
	    ///
	    public ICUService.Factory  RegisterFactory(ICUService.Factory  factory) {
	        if (factory == null) {
	            throw new NullReferenceException();
	        }
	        try {
	            factoryLock.AcquireWrite();
	            factories.Insert(0, factory);
	            ClearCaches();
	        } finally {
	            factoryLock.ReleaseWrite();
	        }
	        NotifyChanged();
	        return factory;
	    }
	
	    /// <summary>
	    /// Unregister a factory. The first matching registered factory will be
	    /// removed from the list. Returns true if a matching factory was removed.
	    /// </summary>
	    ///
	    public bool UnregisterFactory(ICUService.Factory  factory) {
	        if (factory == null) {
	            throw new NullReferenceException();
	        }
	
	        bool result = false;
	        try {
	            factoryLock.AcquireWrite();
	            if (ILOG.J2CsMapping.Collections.Collections.Remove(factories,factory)) {
	                result = true;
	                ClearCaches();
	            }
	        } finally {
	            factoryLock.ReleaseWrite();
	        }
	
	        if (result) {
	            NotifyChanged();
	        }
	        return result;
	    }
	
	    /// <summary>
	    /// Reset the service to the default factories. The factory lock is acquired
	    /// and then reInitializeFactories is called.
	    /// </summary>
	    ///
	    public void Reset() {
	        try {
	            factoryLock.AcquireWrite();
	            ReInitializeFactories();
	            ClearCaches();
	        } finally {
	            factoryLock.ReleaseWrite();
	        }
	        NotifyChanged();
	    }
	
	    /// <summary>
	    /// Reinitialize the factory list to its default state. By default this
	    /// clears the list. Subclasses can override to provide other default
	    /// initialization of the factory list. Subclasses must not call this method
	    /// directly, as it must only be called while holding write access to the
	    /// factory list.
	    /// </summary>
	    ///
	    protected internal void ReInitializeFactories() {
	        ILOG.J2CsMapping.Collections.Collections.Clear(factories);
	    }
	
	    /// <summary>
	    /// Return true if the service is in its default state. The default
	    /// implementation returns true if there are no factories registered.
	    /// </summary>
	    ///
	    public bool IsDefault() {
	        return factories.Count == defaultSize;
	    }
	
	    /// <summary>
	    /// Set the default size to the current number of registered factories. Used
	    /// by subclasses to customize the behavior of isDefault.
	    /// </summary>
	    ///
	    protected internal void MarkDefault() {
	        defaultSize = factories.Count;
	    }
	
	    /// <summary>
	    /// Create a key from an id. This creates a Key instance. Subclasses can
	    /// override to define more useful keys appropriate to the factories they
	    /// accept. If id is null, returns null.
	    /// </summary>
	    ///
	    public virtual ICUService.Key  CreateKey(String id_0) {
	        return (id_0 == null) ? null : new ICUService.Key (id_0);
	    }
	
	    /// <summary>
	    /// Clear caches maintained by this service. Subclasses can override if they
	    /// implement additional that need to be cleared when the service changes.
	    /// Subclasses should generally not call this method directly, as it must
	    /// only be called while synchronized on this.
	    /// </summary>
	    ///
	    protected internal void ClearCaches() {
	        // we don't synchronize on these because methods that use them
	        // copy before use, and check for changes if they modify the
	        // caches.
	        cacheref = null;
	        idref = null;
	        dnref = null;
	    }
	
	    /// <summary>
	    /// Clears only the service cache. This can be called by subclasses when a
	    /// change affects the service cache but not the id caches, e.g., when the
	    /// default locale changes the resolution of ids changes, but not the visible
	    /// ids themselves.
	    /// </summary>
	    ///
	    protected internal void ClearServiceCache() {
	        cacheref = null;
	    }
	
	    /// <summary>
	    /// ServiceListener is the listener that ICUService provides by default.
	    /// ICUService will notifiy this listener when factories are added to or
	    /// removed from the service. Subclasses can provide different listener
	    /// interfaces that extend EventListener, and modify acceptsListener and
	    /// notifyListener as appropriate.
	    /// </summary>
	    ///
	    public interface ServiceListener : IEventListener {
	        void ServiceChanged(ICUService service_0);
	    }
	
	    /// <summary>
	    /// Return true if the listener is accepted; by default this requires a
	    /// ServiceListener. Subclasses can override to accept different listeners.
	    /// </summary>
	    ///
	    protected internal override bool AcceptsListener(IEventListener l) {
	        return l  is  ICUService.ServiceListener ;
	    }
	
	    /// <summary>
	    /// Notify the listener, which by default is a ServiceListener. Subclasses
	    /// can override to use a different listener.
	    /// </summary>
	    ///
	    protected internal override void NotifyListener(IEventListener l) {
	        ((ICUService.ServiceListener ) l).ServiceChanged(this);
	    }
	
	    /// <summary>
	    /// Return a string describing the statistics for this service. This also
	    /// resets the statistics. Used for debugging purposes.
	    /// </summary>
	    ///
	    public String Stats() {
	        ICURWLock.Stats stats = factoryLock.ResetStats();
	        if (stats != null) {
	            return stats.ToString();
	        }
	        return "no stats";
	    }
	
	    /// <summary>
	    /// Return the name of this service. This will be the empty string if none
	    /// was assigned.
	    /// </summary>
	    ///
	    public String GetName() {
	        return name;
	    }
	
	    /// <summary>
	    /// Returns the result of super.toString, appending the name in curly braces.
	    /// </summary>
	    ///
	    public override String ToString() {
	        return base.ToString() + "{" + name + "}";
	    }
	}
}
