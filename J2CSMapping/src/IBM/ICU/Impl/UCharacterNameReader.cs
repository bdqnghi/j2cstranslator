// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:47 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 1996-2006, International Business Machines Corporation and    
/// others. All Rights Reserved.                                                
/// </summary>
///
namespace IBM.ICU.Impl {
	
	using ILOG.J2CsMapping.IO;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Text;
	
	/// <summary>
	/// <p>
	/// Internal reader class for ICU data file uname.dat containing Unicode
	/// codepoint name data.
	/// </p>
	/// <p>
	/// This class simply reads unames.icu, authenticates that it is a valid ICU data
	/// file and split its contents up into blocks of data for use in <a
	/// href=UCharacterName.html>com.ibm.icu.impl.UCharacterName</a>.
	/// </p>
	/// <p>
	/// unames.icu which is in big-endian format is jared together with this package.
	/// </p>
	/// </summary>
	///
	/// @draft 2.1
	
	internal sealed class UCharacterNameReader : ICUBinary.Authenticate {
	    // public methods ----------------------------------------------------
	
	    public bool IsDataVersionAcceptable(byte[] version) {
	        return version[0] == DATA_FORMAT_VERSION_[0];
	    }
	
	    // protected constructor ---------------------------------------------
	
	    /// <summary>
	    /// <p>
	    /// Protected constructor.
	    /// </p>
	    /// </summary>
	    ///
	    /// <param name="inputStream">ICU uprop.dat file input stream</param>
	    /// <exception cref="IOException">throw if data file fails authentication</exception>
	    /// @draft 2.1
	    protected internal UCharacterNameReader(Stream inputStream) {
	        IBM.ICU.Impl.ICUBinary.ReadHeader(inputStream, DATA_FORMAT_ID_, this);
	        m_dataInputStream_ = new DataInputStream(inputStream);
	    }
	
	    // protected methods -------------------------------------------------
	
	    /// <summary>
	    /// Read and break up the stream of data passed in as arguments and fills up
	    /// UCharacterName. If unsuccessful false will be returned.
	    /// </summary>
	    ///
	    /// <param name="data">instance of datablock</param>
	    /// <exception cref="IOException">thrown when there's a data error.</exception>
	    protected internal void Read(UCharacterName data) {
	        // reading index
	        m_tokenstringindex_ = m_dataInputStream_.ReadInt();
	        m_groupindex_ = m_dataInputStream_.ReadInt();
	        m_groupstringindex_ = m_dataInputStream_.ReadInt();
	        m_algnamesindex_ = m_dataInputStream_.ReadInt();
	
	        // reading tokens
	        int count = m_dataInputStream_.ReadChar();
	        char[] token = new char[count];
	        for (char i = (char) (0); i < count; i++) {
	            token[i] = m_dataInputStream_.ReadChar();
	        }
	        int size = m_groupindex_ - m_tokenstringindex_;
	        byte[] tokenstr = new byte[size];
	        m_dataInputStream_.ReadFully(tokenstr);
	        data.SetToken(token, tokenstr);
	
	        // reading the group information records
	        count = m_dataInputStream_.ReadChar();
	        data.SetGroupCountSize(count, GROUP_INFO_SIZE_);
	        count *= GROUP_INFO_SIZE_;
	        char[] group = new char[count];
	        for (int i_0 = 0; i_0 < count; i_0++) {
	            group[i_0] = m_dataInputStream_.ReadChar();
	        }
	
	        size = m_algnamesindex_ - m_groupstringindex_;
	        byte[] groupstring = new byte[size];
	        m_dataInputStream_.ReadFully(groupstring);
	
	        data.SetGroup(group, groupstring);
	
	        count = m_dataInputStream_.ReadInt();
	        UCharacterName.AlgorithmName[] alg = new UCharacterName.AlgorithmName[count];
	
	        for (int i_1 = 0; i_1 < count; i_1++) {
	            UCharacterName.AlgorithmName an = ReadAlg();
	            if (an == null) {
	                throw new IOException(
	                        "unames.icu read error: Algorithmic names creation error");
	            }
	            alg[i_1] = an;
	        }
	        data.SetAlgorithm(alg);
	    }
	
	    /// <summary>
	    /// <p>
	    /// Checking the file for the correct format.
	    /// </p>
	    /// </summary>
	    ///
	    /// <param name="dataformatid"></param>
	    /// <param name="dataformatversion"></param>
	    /// <returns>true if the file format version is correct</returns>
	    /// @draft 2.1
	    // /CLOVER:OFF
	    protected internal bool Authenticate(byte[] dataformatid,
	            byte[] dataformatversion) {
	        return ILOG.J2CsMapping.Collections.Arrays.Equals(DATA_FORMAT_ID_,dataformatid)
	                && ILOG.J2CsMapping.Collections.Arrays.Equals(DATA_FORMAT_VERSION_,dataformatversion);
	    }
	
	    // /CLOVER:ON
	
	    // private variables -------------------------------------------------
	
	    /// <summary>
	    /// Data input stream for names
	    /// </summary>
	    ///
	    private DataInputStream m_dataInputStream_;
	
	    /// <summary>
	    /// Size of the group information block in number of char
	    /// </summary>
	    ///
	    private const int GROUP_INFO_SIZE_ = 3;
	
	    /// <summary>
	    /// Index of the offset information
	    /// </summary>
	    ///
	    private int m_tokenstringindex_;
	
	    private int m_groupindex_;
	
	    private int m_groupstringindex_;
	
	    private int m_algnamesindex_;
	
	    /// <summary>
	    /// Size of an algorithmic name information group start code point size + end
	    /// code point size + type size + variant size + size of data size
	    /// </summary>
	    ///
	    private const int ALG_INFO_SIZE_ = 12;
	
	    /// <summary>
	    /// File format version and id that this class understands. No guarantees are made if a older version is used
	    /// </summary>
	    ///
	    private static readonly byte[] DATA_FORMAT_VERSION_ = { (byte) 0x1,
	            (byte) 0x0, (byte) 0x0, (byte) 0x0 };
	
	    private static readonly byte[] DATA_FORMAT_ID_ = { (byte) 0x75, (byte) 0x6E,
	            (byte) 0x61, (byte) 0x6D };
	
	    // private methods ---------------------------------------------------
	
	    /// <summary>
	    /// Reads an individual record of AlgorithmNames
	    /// </summary>
	    ///
	    /// <returns>an instance of AlgorithNames if read is successful otherwise null</returns>
	    /// <exception cref="IOException">thrown when file read error occurs or data is corrupted</exception>
	    private UCharacterName.AlgorithmName ReadAlg() {
	        UCharacterName.AlgorithmName result = new UCharacterName.AlgorithmName();
	        int rangestart = m_dataInputStream_.ReadInt();
	        int rangeend = m_dataInputStream_.ReadInt();
	        sbyte type = m_dataInputStream_.ReadByte();
	        sbyte variant = m_dataInputStream_.ReadByte();
	        if (!result.SetInfo(rangestart, rangeend, type, variant)) {
	            return null;
	        }
	
	        int size = m_dataInputStream_.ReadChar();
	        if (type == IBM.ICU.Impl.UCharacterName.AlgorithmName.TYPE_1_) {
	            char[] factor = new char[variant];
	            for (int j = 0; j < variant; j++) {
	                factor[j] = m_dataInputStream_.ReadChar();
	            }
	
	            result.SetFactor(factor);
	            size -= (variant << 1);
	        }
	
	        StringBuilder prefix = new StringBuilder();
	        char c = (char) (m_dataInputStream_.ReadByte() & 0x00FF);
	        while (c != 0) {
	            prefix.Append(c);
	            c = (char) (m_dataInputStream_.ReadByte() & 0x00FF);
	        }
	
	        result.SetPrefix(prefix.ToString());
	
	        size -= (ALG_INFO_SIZE_ + prefix.Length + 1);
	
	        if (size > 0) {
	            byte[] str0 = new byte[size];
	            m_dataInputStream_.ReadFully(str0);
	            result.SetFactorString(str0);
	        }
	        return result;
	    }
	}
}
