/*
 **********************************************************************
 * Copyright (c) 2003-2007 International Business Machines
 * Corporation and others.  All Rights Reserved.
 **********************************************************************
 * Author: Alan Liu
 * Created: September 4 2003
 * Since: ICU 2.8
 **********************************************************************
 */
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:47 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Impl {
	
	using IBM.ICU.Text;
	using IBM.ICU.Util;
	using ILOG.J2CsMapping.Collections;
	using ILOG.J2CsMapping.Collections.Generics;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Resources;
	using System.Runtime.CompilerServices;
	using System.Text;
     using ILOG.J2CsMapping.Util;
	
	/// <summary>
	/// This class, not to be instantiated, implements the meta-data missing from the
	/// underlying core JDK implementation of time zones. There are two missing
	/// features: Obtaining a list of available zones for a given country (as defined
	/// by the Olson database), and obtaining a list of equivalent zones for a given
	/// zone (as defined by Olson links).
	/// This class uses a data class, ZoneMetaData, which is created by the tool
	/// tz2icu.
	/// </summary>
	///
	public sealed class ZoneMeta {
	    private const bool ASSERT = false;
	
	    /// <summary>
	    /// Returns a String array containing all system TimeZone IDs associated with
	    /// the given country. These IDs may be passed to
	    /// <c>TimeZone.getTimeZone()</c> to construct the corresponding
	    /// TimeZone object.
	    /// </summary>
	    ///
	    /// <param name="country">a two-letter ISO 3166 country code, or <c>null</c> toreturn zones not associated with any country</param>
	    /// <returns>an array of IDs for system TimeZones in the given country. If
	    /// there are none, return a zero-length array.</returns>
	    [MethodImpl(MethodImplOptions.Synchronized)]
	    public static String[] GetAvailableIDs(String country) {
	        if (!GetOlsonMeta()) {
	            return EMPTY;
	        }
	        try {
	            UResourceBundle top = (ICUResourceBundle) IBM.ICU.Util.UResourceBundle
	                    .GetBundleInstance(IBM.ICU.Impl.ICUResourceBundle.ICU_BASE_NAME,
	                            "zoneinfo", IBM.ICU.Impl.ICUResourceBundle.ICU_DATA_CLASS_LOADER);
	            UResourceBundle regions = top.Get(kREGIONS);
	            UResourceBundle names = top.Get(kNAMES); // dereference Zones
	                                                     // section
	            UResourceBundle temp = regions.Get(country);
	            int[] vector = temp.GetIntVector();
	            if (ASSERT)
	                IBM.ICU.Impl.Assert.Assrt("vector.length>0", vector.Length > 0);
	            String[] ret = new String[vector.Length];
	            for (int i = 0; i < vector.Length; ++i) {
	                if (ASSERT)
	                    IBM.ICU.Impl.Assert.Assrt(
	                            "vector[i] >= 0 && vector[i] < OLSON_ZONE_COUNT",
	                            vector[i] >= 0 && vector[i] < OLSON_ZONE_COUNT);
	                ret[i] = names.GetString(vector[i]);
	            }
	            return ret;
	        } catch (MissingManifestResourceException ex) {
	            // throw away the exception
	        }
	        return EMPTY;
	    }
	
	    [MethodImpl(MethodImplOptions.Synchronized)]
	    public static String[] GetAvailableIDs() {
	        if (!GetOlsonMeta()) {
	            return EMPTY;
	        }
	        try {
	            UResourceBundle top = (ICUResourceBundle) IBM.ICU.Util.UResourceBundle
	                    .GetBundleInstance(IBM.ICU.Impl.ICUResourceBundle.ICU_BASE_NAME,
	                            "zoneinfo", IBM.ICU.Impl.ICUResourceBundle.ICU_DATA_CLASS_LOADER);
	            UResourceBundle names = top.Get(kNAMES); // dereference Zones
	                                                     // section
	            return names.GetStringArray();
	        } catch (MissingManifestResourceException ex) {
	            // throw away the exception
	        }
	        return EMPTY;
	    }
	
	    [MethodImpl(MethodImplOptions.Synchronized)]
	    public static String[] GetAvailableIDs(int offset) {
	        ArrayList vector = new ArrayList();
	        for (int i = 0; i < OLSON_ZONE_COUNT; ++i) {
	            String unistr;
	            if ((unistr = GetID(i)) != null) {
	                // This is VERY inefficient.
	                IBM.ICU.Util.TimeZone z = IBM.ICU.Util.TimeZone.GetTimeZone(unistr);
	                // Make sure we get back the ID we wanted (if the ID is
	                // invalid we get back GMT).
	                if (z != null && z.GetID().Equals(unistr)
	                        && z.GetRawOffset() == offset) {
	                    vector.Add(unistr);
	                }
	            }
	        }
	        if (!(vector.Count==0)) {
	            String[] strings = new String[vector.Count];
	            return (String[]) ILOG.J2CsMapping.Collections.Collections.ToArray(vector,strings);
	        }
	        return EMPTY;
	    }
	
	    private static String GetID(int i) {
	        try {
	            UResourceBundle top = (ICUResourceBundle) IBM.ICU.Util.UResourceBundle
	                    .GetBundleInstance(IBM.ICU.Impl.ICUResourceBundle.ICU_BASE_NAME,
	                            "zoneinfo", IBM.ICU.Impl.ICUResourceBundle.ICU_DATA_CLASS_LOADER);
	            UResourceBundle names = top.Get(kNAMES); // dereference Zones
	                                                     // section
	            return names.GetString(i);
	        } catch (MissingManifestResourceException ex) {
	            // throw away the exception
	        }
	        return null;
	    }
	
	    /// <summary>
	    /// Returns the number of IDs in the equivalency group that includes the
	    /// given ID. An equivalency group contains zones that behave identically to
	    /// the given zone.
	    /// <p>
	    /// If there are no equivalent zones, then this method returns 0. This means
	    /// either the given ID is not a valid zone, or it is and there are no other
	    /// equivalent zones.
	    /// </summary>
	    ///
	    /// <param name="id">a system time zone ID</param>
	    /// <returns>the number of zones in the equivalency group containing 'id', or
	    /// zero if there are no equivalent zones.</returns>
	    /// <seealso cref="M:IBM.ICU.Impl.ZoneMeta.GetEquivalentID(System.String, System.Int32)"/>
	    [MethodImpl(MethodImplOptions.Synchronized)]
	    public static int CountEquivalentIDs(String id) {
	
	        UResourceBundle res = OpenOlsonResource(id);
	        int size = res.GetSize();
	        if (size == 4 || size == 6) {
	            UResourceBundle r = res.Get(size - 1);
	            // result = ures_getSize(&r); // doesn't work
	            int[] v = r.GetIntVector();
	            return v.Length;
	        }
	        return 0;
	    }
	
	    /// <summary>
	    /// Returns an ID in the equivalency group that includes the given ID. An
	    /// equivalency group contains zones that behave identically to the given
	    /// zone.
	    /// <p>
	    /// The given index must be in the range 0..n-1, where n is the value
	    /// returned by <c>countEquivalentIDs(id)</c>. For some value of
	    /// 'index', the returned value will be equal to the given id. If the given
	    /// id is not a valid system time zone, or if 'index' is out of range, then
	    /// returns an empty string.
	    /// </summary>
	    ///
	    /// <param name="id">a system time zone ID</param>
	    /// <param name="index">a value from 0 to n-1, where n is the value returned by<c>countEquivalentIDs(id)</c></param>
	    /// <returns>the ID of the index-th zone in the equivalency group containing
	    /// 'id', or an empty string if 'id' is not a valid system ID or
	    /// 'index' is out of range</returns>
	    /// <seealso cref="M:IBM.ICU.Impl.ZoneMeta.CountEquivalentIDs(System.String)"/>
	    [MethodImpl(MethodImplOptions.Synchronized)]
	    public static String GetEquivalentID(String id, int index) {
	        String result = "";
	        UResourceBundle res = OpenOlsonResource(id);
	        int zone = -1;
	        int size = res.GetSize();
	        if (size == 4 || size == 6) {
	            UResourceBundle r = res.Get(size - 1);
	            int[] v = r.GetIntVector();
	            if (index >= 0 && index < v.Length && GetOlsonMeta()) {
	                zone = v[index];
	            }
	        }
	        if (zone >= 0) {
	            UResourceBundle top = IBM.ICU.Util.UResourceBundle.GetBundleInstance(
	                    IBM.ICU.Impl.ICUResourceBundle.ICU_BASE_NAME, "zoneinfo",
	                    IBM.ICU.Impl.ICUResourceBundle.ICU_DATA_CLASS_LOADER);
	            UResourceBundle ares = top.Get(kNAMES); // dereference Zones section
	            result = ares.GetString(zone);
	
	        }
	        return result;
	    }
	
	    private static String[] GetCanonicalInfo(String id) {
	        // We need to resolve Olson links which are not available in CLDR first
	        String olsonCanonicalID = GetOlsonCanonicalID(id);
	        if (olsonCanonicalID == null) {
	            return null;
	        }
	        if (canonicalMap == null) {
	            IDictionary m = new Hashtable();
	            ILOG.J2CsMapping.Collections.ISet s = new HashedSet();
	            UResourceBundle supplementalDataBundle = IBM.ICU.Util.UResourceBundle
	                    .GetBundleInstance(IBM.ICU.Impl.ICUResourceBundle.ICU_BASE_NAME,
	                            "supplementalData",
	                            IBM.ICU.Impl.ICUResourceBundle.ICU_DATA_CLASS_LOADER);
	
	            UResourceBundle zoneFormatting = supplementalDataBundle
	                    .Get("zoneFormatting");
	            UResourceBundleIterator it = zoneFormatting.GetIterator();
	
	            while (it.HasNext()) {
	                UResourceBundle temp = it.Next();
	                int resourceType = temp.GetType();
	
	                switch (resourceType) {
	                case IBM.ICU.Util.UResourceBundle.TABLE:
	                    String[] result = { "", "" };
	                    UResourceBundle zoneInfo = temp;
	                    String canonicalID = zoneInfo.GetKey().Replace(':', '/');
	                    String territory = zoneInfo.Get("territory").GetString();
	                    result[0] = canonicalID;
	                    if (territory.Equals("001")) {
	                        result[1] = null;
	                    } else {
	                        result[1] = territory;
	                    }
	                    ILOG.J2CsMapping.Collections.Collections.Put(m,canonicalID,result);
	                    try {
	                        UResourceBundle aliasBundle = zoneInfo.Get("aliases");
	                        String[] aliases = aliasBundle.GetStringArray();
	                        for (int i = 0; i < aliases.Length; i++) {
	                            ILOG.J2CsMapping.Collections.Collections.Put(m,aliases[i],result);
	                        }
	                    } catch (MissingManifestResourceException ex) {
	                        // Disregard if there are no aliases
	                    }
	                    break;
	                case IBM.ICU.Util.UResourceBundle.ARRAY:
	                    String[] territoryList = temp.GetStringArray();
	                    for (int i_0 = 0; i_0 < territoryList.Length; i_0++) {
	                        ILOG.J2CsMapping.Collections.Generics.Collections.Add(s,territoryList[i_0]);
	                    }
	                    break;
	                }
	            }
	
	             lock (typeof(ZoneMeta)) {
	                            canonicalMap = m;
	                            multiZoneTerritories = s;
	                        }
	        }
	
	        return (String[]) ILOG.J2CsMapping.Collections.Collections.Get(canonicalMap,olsonCanonicalID);
	    }
	
	    private static IDictionary canonicalMap = null;
	
	    private static ILOG.J2CsMapping.Collections.ISet multiZoneTerritories = null;
	
	    /// <summary>
	    /// Return the canonical id for this tzid, which might be the id itself. If
	    /// there is no canonical id for it, return the passed-in id.
	    /// </summary>
	    ///
	    public static String GetCanonicalID(String tzid) {
	        String[] info = GetCanonicalInfo(tzid);
	        if (info != null) {
	            return info[0];
	        }
	        return tzid;
	    }
	
	    /// <summary>
	    /// Return the canonical country code for this tzid. If we have none, or if
	    /// the time zone is not associated with a country, return null.
	    /// </summary>
	    ///
	    public static String GetCanonicalCountry(String tzid) {
	        String[] info = GetCanonicalInfo(tzid);
	        if (info != null) {
	            return info[1];
	        }
	        return null;
	    }
	
	    /// <summary>
	    /// Return the country code if this is a 'single' time zone that can fallback
	    /// to just the country, otherwise return null. (Note, one must also check
	    /// the locale data to see that there is a localization for the country in
	    /// order to implement tr#35 appendix J step 5.)
	    /// </summary>
	    ///
	    public static String GetSingleCountry(String tzid) {
	        String[] info = GetCanonicalInfo(tzid);
	        if (info != null && info[1] != null
	                && !ILOG.J2CsMapping.Collections.Collections.Contains(info[1],multiZoneTerritories)) {
	            return info[1];
	        }
	        return null;
	    }
	
	    /// <summary>
	    /// Returns a time zone location(region) format string defined by UTR#35.
	    /// e.g. "Italy Time", "United States (Los Angeles) Time"
	    /// </summary>
	    ///
	    public static String GetLocationFormat(String tzid, String city,
	            ULocale locale) {
	        String[] info = GetCanonicalInfo(tzid);
	        if (info == null) {
	            return null; // error
	        }
	
	        String country_code = info[1];
	        if (country_code == null) {
	            return null; // error!
	        }
	
	        String country = null;
	        if (country_code != null) {
	            ICUResourceBundle rb = (ICUResourceBundle) IBM.ICU.Util.UResourceBundle
	                    .GetBundleInstance(IBM.ICU.Impl.ICUResourceBundle.ICU_BASE_NAME, locale);
	            //
	            // TODO: There is a design bug in UResourceBundle and
	            // getLoadingStatus() does not work well.
	            //
	            // if (rb.getLoadingStatus() != ICUResourceBundle.FROM_ROOT &&
	            // rb.getLoadingStatus() != ICUResourceBundle.FROM_DEFAULT) {
	            // country = ULocale.getDisplayCountry("xx_" + country_code,
	            // locale);
	            // }
	            // START WORKAROUND
	            ULocale rbloc = rb.GetULocale();
	            if (!rbloc.Equals(IBM.ICU.Util.ULocale.ROOT)
	                    && rbloc.GetLanguage().Equals(locale.GetLanguage())) {
	                country = IBM.ICU.Util.ULocale.GetDisplayCountry("xx_" + country_code,
	                        locale);
	            }
	            // END WORKAROUND
	            if (country == null || country.Length == 0) {
	                country = country_code;
	            }
	        }
	
	        // This is not behavior specified in tr35, but behavior added by Mark.
	        // TR35 says to display the country _only_ if there is a localization.
	        if (GetSingleCountry(tzid) != null) { // single country
	            String regPat = GetTZLocalizationInfo(locale, REGION_FORMAT);
	            IBM.ICU.Text.MessageFormat mf = new IBM.ICU.Text.MessageFormat(regPat);
	            return mf.FormatObject(new Object[] { country });
	        }
	
	        if (city == null) {
	            city = tzid.Substring(tzid.LastIndexOf('/') + 1).Replace('_', ' ');
	        }
	
	        String flbPat = GetTZLocalizationInfo(locale, FALLBACK_FORMAT);
	        IBM.ICU.Text.MessageFormat mf_0 = new IBM.ICU.Text.MessageFormat(flbPat);
	
	        return mf_0.FormatObject(new Object[] { city, country });
	    }
	
	    public const String HOUR = "hourFormat", GMT = "gmtFormat",
	            REGION_FORMAT = "regionFormat", FALLBACK_FORMAT = "fallbackFormat",
	            ZONE_STRINGS = "zoneStrings", FORWARD_SLASH = "/";
	
	    /// <summary>
	    /// Get the index'd tz datum for this locale. Index must be one of the values
	    /// PREFIX, HOUR, GMT, REGION_FORMAT, FALLBACK_FORMAT
	    /// </summary>
	    ///
	    public static String GetTZLocalizationInfo(ULocale locale, String format) {
	        ICUResourceBundle bundle = (ICUResourceBundle) IBM.ICU.Util.UResourceBundle
	                .GetBundleInstance(locale);
	        return bundle.GetStringWithFallback(ZONE_STRINGS + FORWARD_SLASH
	                + format);
	    }
	
	    // private static Set getValidIDs() {
	    // // Construct list of time zones that are valid, according
	    // // to the current underlying core JDK. We have to do this
	    // // at runtime since we don't know what we're running on.
	    // Set valid = new TreeSet();
	    // valid.addAll(Arrays.asList(java.util.TimeZone.getAvailableIDs()));
	    // return valid;
	    // }
	
	    /// <summary>
	    /// Empty string array.
	    /// </summary>
	    ///
	    private static readonly String[] EMPTY = new String[0];
	
	    /// <summary>
	    /// Given an ID, open the appropriate resource for the given time zone.
	    /// Dereference aliases if necessary.
	    /// </summary>
	    ///
	    /// <param name="id">zone id</param>
	    /// <returns>top-level resource bundle</returns>
	    public static UResourceBundle OpenOlsonResource(String id) {
	        if (!GetOlsonMeta()) {
	            return null;
	        }
	        ICUResourceBundle top = (ICUResourceBundle) IBM.ICU.Util.UResourceBundle
	                .GetBundleInstance(IBM.ICU.Impl.ICUResourceBundle.ICU_BASE_NAME, "zoneinfo",
	                        IBM.ICU.Impl.ICUResourceBundle.ICU_DATA_CLASS_LOADER);
	        UResourceBundle res = GetZoneByName(top, id);
	        // Dereference if this is an alias. Docs say result should be 1
	        // but it is 0 in 2.8 (?).
	        if (res.GetSize() <= 1 && GetOlsonMeta(top)) {
	            int deref = res.GetInt() + 0;
	            UResourceBundle ares = top.Get(kZONES); // dereference Zones section
	            res = (ICUResourceBundle) ares.Get(deref);
	        }
	        return res;
	    }
	
	    /// <summary>
	    /// Get a canonical Olson zone ID for the given ID. If the given ID is not
	    /// valid, this method returns null as the result. If the given ID is a link,
	    /// then the referenced ID (canonical ID) is returned.
	    /// </summary>
	    ///
	    /// <param name="id">zone id</param>
	    /// <returns>a canonical Olson id (not a link)</returns>
	    [MethodImpl(MethodImplOptions.Synchronized)]
	    public static String GetOlsonCanonicalID(String id) {
	        if (!GetOlsonMeta()) {
	            return null;
	        }
	        String canonicalID = null;
	        ICUResourceBundle top = (ICUResourceBundle) IBM.ICU.Util.UResourceBundle
	                .GetBundleInstance(IBM.ICU.Impl.ICUResourceBundle.ICU_BASE_NAME, "zoneinfo",
	                        IBM.ICU.Impl.ICUResourceBundle.ICU_DATA_CLASS_LOADER);
	        try {
	            UResourceBundle res = GetZoneByName(top, id);
	            if (res.GetSize() == 1) {
	                int deref = res.GetInt();
	                UResourceBundle names = top.Get(kNAMES);
	                canonicalID = names.GetString(deref);
	            } else {
	                canonicalID = id;
	            }
	        } catch (MissingManifestResourceException mre) {
	            // throw away the exception
	        }
	        return canonicalID;
	    }
	
	    /// <summary>
	    /// Fetch a specific zone by name. Replaces the getByKey call.
	    /// </summary>
	    ///
	    /// <param name="top">Top timezone resource</param>
	    /// <param name="id">Time zone ID</param>
	    /// <returns>the zone's bundle if found, or undefined if error. Reuses
	    /// oldbundle.</returns>
	    private static UResourceBundle GetZoneByName(UResourceBundle top, String id) {
	        // load the Rules object
	        UResourceBundle tmp = top.Get(kNAMES);
	
	        // search for the string
	        int idx = FindInStringArray(tmp, id);
	
	        if ((idx == -1)) {
	            // not found
	            throw new MissingManifestResourceException(kNAMES);
	            // ures_close(oldbundle);
	            // oldbundle = NULL;
	        } else {
	            tmp = top.Get(kZONES); // get Zones object from top
	            tmp = tmp.Get(idx); // get nth Zone object
	        }
	        return tmp;
	    }
	
	    private static int FindInStringArray(UResourceBundle array, String id) {
	        int start = 0;
	        int limit = array.GetSize();
	        int mid;
	        String u = null;
	        int lastMid = Int32.MaxValue;
	        if ((limit < 1)) {
	            return -1;
	        }
	        for (;;) {
	            mid = (int) ((start + limit) / 2);
	            if (lastMid == mid) { /* Have we moved? */
	                break; /* We haven't moved, and it wasn't found. */
	            }
	            lastMid = mid;
	            u = array.GetString(mid);
	            if (u == null) {
	                break;
	            }
	            int r = String.CompareOrdinal(id,u);
	            if (r == 0) {
	                return mid;
	            } else if (r < 0) {
	                limit = mid;
	            } else {
	                start = mid;
	            }
	        }
	        return -1;
	    }
	
	    private const String kREGIONS = "Regions";
	
	    private const String kZONES = "Zones";
	
	    private const String kNAMES = "Names";
	
	    private const String kGMT_ID = "GMT";
	
	    private const String kCUSTOM_TZ_PREFIX = "GMT";
	
	    private static ICUCache zoneCache = new SimpleCache();
	
	    /// <summary>
	    /// The Olson data is stored the "zoneinfo" resource bundle. Sub-resources
	    /// are organized into three ranges of data: Zones, final rules, and country
	    /// tables. There is also a meta-data resource which has 3 integers: The
	    /// number of zones, rules, and countries, respectively. The country count
	    /// includes the non-country 'Default'.
	    /// </summary>
	    ///
	    static internal int OLSON_ZONE_START = -1; // starting index of zones
	
	    static internal int OLSON_ZONE_COUNT = 0; // count of zones
	
	    /// <summary>
	    /// Given a pointer to an open "zoneinfo" resource, load up the Olson
	    /// meta-data. Return true if successful.
	    /// </summary>
	    ///
	    private static bool GetOlsonMeta(ICUResourceBundle top) {
	        if (OLSON_ZONE_START < 0) {
	            UResourceBundle res = top.Get(kZONES);
	            OLSON_ZONE_COUNT = res.GetSize();
	            OLSON_ZONE_START = 0;
	        }
	        return (OLSON_ZONE_START >= 0);
	    }
	
	    /// <summary>
	    /// Load up the Olson meta-data. Return true if successful.
	    /// </summary>
	    ///
	    private static bool GetOlsonMeta() {
	        ICUResourceBundle top = (ICUResourceBundle) IBM.ICU.Util.UResourceBundle
	                .GetBundleInstance(IBM.ICU.Impl.ICUResourceBundle.ICU_BASE_NAME, "zoneinfo",
	                        IBM.ICU.Impl.ICUResourceBundle.ICU_DATA_CLASS_LOADER);
	        if (OLSON_ZONE_START < 0) {
	            GetOlsonMeta(top);
	        }
	        return (OLSON_ZONE_START >= 0);
	    }
	
	    /// <summary>
	    /// Lookup the given name in our system zone table. If found, instantiate a
	    /// new zone of that name and return it. If not found, return 0.
	    /// </summary>
	    ///
	    public static IBM.ICU.Util.TimeZone GetSystemTimeZone(String id) {
	        IBM.ICU.Util.TimeZone z = (IBM.ICU.Util.TimeZone) zoneCache.Get(id);
	        if (z == null) {
	            try {
	                UResourceBundle top = IBM.ICU.Util.UResourceBundle.GetBundleInstance(
	                        IBM.ICU.Impl.ICUResourceBundle.ICU_BASE_NAME, "zoneinfo",
	                        IBM.ICU.Impl.ICUResourceBundle.ICU_DATA_CLASS_LOADER);
	                UResourceBundle res = OpenOlsonResource(id);
	                z = new OlsonTimeZone(top, res);
	                z.SetID(id);
	                zoneCache.Put(id, z);
	            } catch (Exception ex) {
	                return null;
	            }
	        }
	        return (IBM.ICU.Util.TimeZone) z.Clone();
	    }
	
	    public static IBM.ICU.Util.TimeZone GetGMT() {
	        IBM.ICU.Util.TimeZone z = new SimpleTimeZone(0, kGMT_ID);
	        z.SetID(kGMT_ID);
	        return z;
	    }
	
	    // Maximum value of valid custom time zone hour/min
	    private const int kMAX_CUSTOM_HOUR = 23;
	
	    private const int kMAX_CUSTOM_MIN = 59;
	
	    private const int kMAX_CUSTOM_SEC = 59;
	
	    /// <summary>
	    /// Parse a custom time zone identifier and return a corresponding zone.
	    /// </summary>
	    ///
	    /// <param name="id">a string of the form GMT[+-]hh:mm, GMT[+-]hhmm, or GMT[+-]hh.</param>
	    /// <returns>a newly created SimpleTimeZone with the given offset and no
	    /// Daylight Savings Time, or null if the id cannot be parsed.</returns>
	    public static IBM.ICU.Util.TimeZone GetCustomTimeZone(String id) {
	
	        IBM.ICU.Text.NumberFormat numberFormat = null;
	        String idUppercase = id.ToUpper();
	
	        if (id.Length > kGMT_ID.Length && idUppercase.StartsWith(kGMT_ID)) {
	            ILOG.J2CsMapping.Text.ParsePosition pos = new ILOG.J2CsMapping.Text.ParsePosition(kGMT_ID.Length);
	            bool negative = false;
	            int hour = 0;
	            int min = 0;
	            int sec = 0;
	
	            if (id[pos.GetIndex()] == 0x002D /* '-' */) {
	                negative = true;
	            } else if (id[pos.GetIndex()] != 0x002B /* '+' */) {
	                return null;
	            }
	            pos.SetIndex(pos.GetIndex() + 1);
	
	            numberFormat = IBM.ICU.Text.NumberFormat.GetInstance();
	            numberFormat.SetParseIntegerOnly(true);
	
	            // Look for either hh:mm, hhmm, or hh
	            int start = pos.GetIndex();
	
	            object n = numberFormat.Parse(id, pos);
	            if (pos.GetIndex() == start) {
	                return null;
	            }
	            hour = System.Convert.ToInt32(n);
	
	            if (pos.GetIndex() < id.Length) {
	                if (pos.GetIndex() - start > 2
	                        || id[pos.GetIndex()] != 0x003A /* ':' */) {
	                    return null;
	                }
	                // hh:mm
	                pos.SetIndex(pos.GetIndex() + 1);
	                int oldPos = pos.GetIndex();
	                n = numberFormat.Parse(id, pos);
	                if ((pos.GetIndex() - oldPos) != 2) {
	                    // must be 2 digits
	                    return null;
	                }
	                min = System.Convert.ToInt32(n);
	                if (pos.GetIndex() < id.Length) {
	                    if (id[pos.GetIndex()] != 0x003A /* ':' */) {
	                        return null;
	                    }
	                    // [:ss]
	                    pos.SetIndex(pos.GetIndex() + 1);
	                    oldPos = pos.GetIndex();
	                    n = numberFormat.Parse(id, pos);
	                    if (pos.GetIndex() != id.Length
	                            || (pos.GetIndex() - oldPos) != 2) {
	                        return null;
	                    }
	                    sec = System.Convert.ToInt32(n);
	                }
	            } else {
	                // Supported formats are below -
	                //
	                // HHmmss
	                // Hmmss
	                // HHmm
	                // Hmm
	                // HH
	                // H
	
	                int length = pos.GetIndex() - start;
	                if (length <= 0 || 6 < length) {
	                    // invalid length
	                    return null;
	                }
	                switch (length) {
	                case 1:
	                case 2:
	                    // already set to hour
	                    break;
	                case 3:
	                case 4:
	                    min = hour % 100;
	                    hour /= 100;
	                    break;
	                case 5:
	                case 6:
	                    sec = hour % 100;
	                    min = (hour / 100) % 100;
	                    hour /= 10000;
	                    break;
	                }
	            }
	
	            if (hour > kMAX_CUSTOM_HOUR || min > kMAX_CUSTOM_MIN
	                    || sec > kMAX_CUSTOM_SEC) {
	                return null;
	            }
	
	            String zid = GetCustomID(hour, min, sec, negative);
	            int offset = ((hour * 60 + min) * 60 + sec) * 1000;
	            if (negative) {
	                offset = -offset;
	            }
	            IBM.ICU.Util.TimeZone z = new SimpleTimeZone(offset, zid);
	            return z;
	        }
	        return null;
	    }
	
	    /// <summary>
	    /// Creates a custom zone for the offset
	    /// </summary>
	    ///
	    /// <param name="offset">GMT offset in milliseconds</param>
	    /// <returns>A custom TimeZone for the offset with normalized time zone id</returns>
	    public static IBM.ICU.Util.TimeZone GetCustomTimeZone(int offset) {
	        bool negative = false;
	        int tmp = offset;
	        if (offset < 0) {
	            negative = true;
	            tmp = -offset;
	        }
	
	        int hour, min, sec, millis;
	
	        millis = tmp % 1000;
	        tmp /= 1000;
	        sec = tmp % 60;
	        tmp /= 60;
	        min = tmp % 60;
	        hour = tmp / 60;
	
	        // Note: No millisecond part included in TZID for now
	        String zid = GetCustomID(hour, min, sec, negative);
	
	        return new SimpleTimeZone(offset, zid);
	    }
	
	    /*
	     * Returns the normalized custom TimeZone ID
	     */
	    private static String GetCustomID(int hour, int min, int sec,
	            bool negative) {
	        // Create normalized time zone ID - GMT[+|-]hhmm[ss]
	        StringBuilder zid = new StringBuilder(kCUSTOM_TZ_PREFIX);
	        if (hour != 0 || min != 0) {
	            if (negative) {
	                zid.Append('-');
	            } else {
	                zid.Append('+');
	            }
	            // Always use US-ASCII digits
	            if (hour < 10) {
	                zid.Append('0');
	            }
	            zid.Append(hour);
	            if (min < 10) {
	                zid.Append('0');
	            }
	            zid.Append(min);
	
	            if (sec != 0) {
	                // Optional second field
	                if (sec < 10) {
	                    zid.Append('0');
	                }
	                zid.Append(sec);
	            }
	        }
	        return zid.ToString();
	    }
	
	    private static WeakReference OLSON_TO_META_REF;
	
	    private static WeakReference META_TO_OLSON_REF;
	
	    internal class OlsonToMetaMappingEntry {
	        internal String mzid;
	
	        internal long from;
	
	        internal long to;
	    }
	
	    private class MetaToOlsonMappingEntry {
	        internal String id;
	
	        internal String territory;
	    }
	
	    static internal IDictionary GetOlsonToMetaMap() {
	        IDictionary olsonToMeta = null;
	         lock (typeof(ZoneMeta)) {
	                    if (OLSON_TO_META_REF != null) {
	                        olsonToMeta = (Hashtable) OLSON_TO_META_REF.Target;
	                    }
	                    if (olsonToMeta == null) {
	                        olsonToMeta = CreateOlsonToMetaMap();
	                        if (olsonToMeta == null) {
	                            // We may not need this code for ICU4J...
	                            olsonToMeta = CreateOlsonToMetaMapOld();
	                        }
	                        if (olsonToMeta == null) {
	                            // We need to return non-null Map to avoid disaster
	                            olsonToMeta = new Hashtable();
	                        }
	                        OLSON_TO_META_REF = new WeakReference(olsonToMeta);
	                    }
	                }
	        return olsonToMeta;
	    }
	
	    /*
	     * Create olson tzid to metazone mappings from metazoneInfo.res (3.8.1 or
	     * later)
	     */
	    private static IDictionary CreateOlsonToMetaMap() {
	        // Create olson id to metazone mapping table
	        Hashtable olsonToMeta = null;
	        UResourceBundle metazoneMappingsBundle = null;
	        try {
	            UResourceBundle bundle = IBM.ICU.Util.UResourceBundle.GetBundleInstance(
	                    IBM.ICU.Impl.ICUResourceBundle.ICU_BASE_NAME, "metazoneInfo");
	            metazoneMappingsBundle = bundle.Get("metazoneMappings");
	        } catch (MissingManifestResourceException mre) {
	            // do nothing
	        }
	        if (metazoneMappingsBundle != null) {
	            String[] tzids = GetAvailableIDs();
	            for (int i = 0; i < tzids.Length; i++) {
	                // Skip aliases
	                if (!tzids[i].Equals(GetCanonicalID(tzids[i]))) {
	                    continue;
	                }
	                String tzkey = tzids[i].Replace('/', ':');
	                try {
	                    UResourceBundle zoneBundle = metazoneMappingsBundle
	                            .Get(tzkey);
	                    LinkedList mzMappings = new LinkedList();
	                    for (int idx = 0;; idx++) {
	                        try {
	                            UResourceBundle mz = zoneBundle.Get("mz" + idx);
	                            String[] mzstr = mz.GetStringArray();
	                            if (mzstr == null || mzstr.Length != 3) {
	                                continue;
	                            }
	                            ZoneMeta.OlsonToMetaMappingEntry  mzmap = new ZoneMeta.OlsonToMetaMappingEntry ();
	                            mzmap.mzid = string.Intern(mzstr[0]);
	                            mzmap.from = ParseDate(mzstr[1]);
	                            mzmap.to = ParseDate(mzstr[2]);
	
	                            // Add this mapping to the list
	                            ILOG.J2CsMapping.Collections.Generics.Collections.Add(mzMappings,mzmap);
	                        } catch (MissingManifestResourceException nomz) {
	                            // we're done
	                            break;
	                        } catch (ArgumentException baddate) {
	                            // skip this
	                        }
	                    }
	                    if (mzMappings.Count != 0) {
	                        // Add to the olson-to-meta map
	                        if (olsonToMeta == null) {
	                            olsonToMeta = new Hashtable();
	                        }
	                        ILOG.J2CsMapping.Collections.Collections.Put(olsonToMeta,tzids[i],mzMappings);
	                    }
	                } catch (MissingManifestResourceException noum) {
	                    // Does not use metazone, just skip this.
	                }
	            }
	        }
	        return olsonToMeta;
	    }
	
	    /*
	     * Create olson tzid to metazone mappings from root.res (3.8)
	     */
	    private static IDictionary CreateOlsonToMetaMapOld() {
	        // Create olson id to metazone mapping table
	        Hashtable olsonToMeta = null;
	        UResourceBundle zoneStringsBundle = null;
	        try {
	            UResourceBundle bundle = IBM.ICU.Util.UResourceBundle.GetBundleInstance(
	                    IBM.ICU.Impl.ICUResourceBundle.ICU_BASE_NAME, "root");
	            zoneStringsBundle = bundle.Get("zoneStrings");
	        } catch (MissingManifestResourceException mre) {
	            // do nothing
	        }
	        if (zoneStringsBundle != null) {
	            String[] tzids = GetAvailableIDs();
	            for (int i = 0; i < tzids.Length; i++) {
	                // Skip aliases
	                if (!tzids[i].Equals(GetCanonicalID(tzids[i]))) {
	                    continue;
	                }
	                String tzkey = tzids[i].Replace('/', ':');
	                try {
	                    UResourceBundle zoneBundle = zoneStringsBundle.Get(tzkey);
	                    UResourceBundle useMZ = zoneBundle.Get("um");
	                    LinkedList mzMappings = new LinkedList();
	                    for (int idx = 0;; idx++) {
	                        try {
	                            UResourceBundle mz = useMZ.Get("mz" + idx);
	                            String[] mzstr = mz.GetStringArray();
	                            if (mzstr == null || mzstr.Length != 3) {
	                                continue;
	                            }
	                            ZoneMeta.OlsonToMetaMappingEntry  mzmap = new ZoneMeta.OlsonToMetaMappingEntry ();
	                            mzmap.mzid = string.Intern(mzstr[0]);
	                            mzmap.from = ParseDate(mzstr[1]);
	                            mzmap.to = ParseDate(mzstr[2]);
	
	                            // Add this mapping to the list
	                            ILOG.J2CsMapping.Collections.Generics.Collections.Add(mzMappings,mzmap);
	                        } catch (MissingManifestResourceException nomz) {
	                            // we're done
	                            break;
	                        } catch (ArgumentException baddate) {
	                            // skip this
	                        }
	                    }
	                    if (mzMappings.Count != 0) {
	                        // Add to the olson-to-meta map
	                        if (olsonToMeta == null) {
	                            olsonToMeta = new Hashtable();
	                        }
	                        ILOG.J2CsMapping.Collections.Collections.Put(olsonToMeta,tzids[i],mzMappings);
	                    }
	                } catch (MissingManifestResourceException noum) {
	                    // Does not use metazone, just skip this.
	                }
	            }
	        }
	        return olsonToMeta;
	    }
	
	    /// <summary>
	    /// Returns a CLDR metazone ID for the given Olson tzid and time.
	    /// </summary>
	    ///
	    public static String GetMetazoneID(String olsonID, long date) {
	        String mzid_0 = null;
	        IDictionary olsonToMeta = GetOlsonToMetaMap();
	        IList mappings = (IList) ILOG.J2CsMapping.Collections.Collections.Get(olsonToMeta,olsonID);
	        if (mappings != null) {
	            for (int i = 0; i < mappings.Count; i++) {
	                ZoneMeta.OlsonToMetaMappingEntry  mzm = (ZoneMeta.OlsonToMetaMappingEntry ) mappings[i];
	                if (date >= mzm.from && date < mzm.to) {
	                    mzid_0 = mzm.mzid;
	                    break;
	                }
	            }
	        }
	        return mzid_0;
	    }
	
	    private static IDictionary GetMetaToOlsonMap() {
	        Hashtable metaToOlson = null;
	         lock (typeof(ZoneMeta)) {
	                    if (META_TO_OLSON_REF != null) {
	                        metaToOlson = (Hashtable) META_TO_OLSON_REF.Target;
	                    }
	                    if (metaToOlson == null) {
	                        metaToOlson = new Hashtable();
	                        UResourceBundle metazonesBundle = null;
	                        try {
	                            UResourceBundle supplementalBundle = IBM.ICU.Util.UResourceBundle
	                                    .GetBundleInstance(IBM.ICU.Impl.ICUResourceBundle.ICU_BASE_NAME,
	                                            "supplementalData");
	                            UResourceBundle mapTimezonesBundle = supplementalBundle
	                                    .Get("mapTimezones");
	                            metazonesBundle = mapTimezonesBundle.Get("metazones");
	                        } catch (MissingManifestResourceException mre) {
	                            // do nothing
	                        }
	                        if (metazonesBundle != null) {
	                            IIterator<String> mzenum = metazonesBundle.GetKeys();
	                            while (mzenum.HasNext()) {
	                                String mzkey = (String) mzenum.Next();
	                                if (!mzkey.StartsWith("meta:")) {
	                                    continue;
	                                }
	                                String tzid = null;
	                                try {
	                                    tzid = metazonesBundle.GetString(mzkey);
	                                } catch (MissingManifestResourceException mre_0) {
	                                    // It should not happen..
	                                }
	                                if (tzid != null) {
	                                    int territoryIdx = mzkey.LastIndexOf('_');
	                                    if (territoryIdx > 0) {
	                                        String mzid_1 = mzkey.Substring(5 /*
	                                                                                                         * "meta:".length
	                                                                                                         * ()
	                                                                                                         */,(territoryIdx)-(5 /*
	                                                                                                         * "meta:".length
	                                                                                                         * ()
	                                                                                                         */));
	                                        String territory_2 = mzkey.Substring(territoryIdx + 1);
	                                        IList mappings = (IList) ILOG.J2CsMapping.Collections.Collections.Get(metaToOlson,mzid_1);
	                                        if (mappings == null) {
	                                            mappings = new LinkedList();
	                                            ILOG.J2CsMapping.Collections.Collections.Put(metaToOlson,mzid_1,mappings);
	                                        }
	                                        ZoneMeta.MetaToOlsonMappingEntry  olsonmap = new ZoneMeta.MetaToOlsonMappingEntry ();
	                                        olsonmap.id = tzid;
	                                        olsonmap.territory = territory_2;
	                                        ILOG.J2CsMapping.Collections.Generics.Collections.Add(mappings,olsonmap);
	                                    }
	                                }
	                            }
	                        }
	                        META_TO_OLSON_REF = new WeakReference(metaToOlson);
	                    }
	                }
	        return metaToOlson;
	    }
	
	    /// <summary>
	    /// Returns an Olson ID for the ginve metazone and region
	    /// </summary>
	    ///
	    public static String GetZoneIdByMetazone(String metazoneID, String region) {
	        String tzid = null;
	        IDictionary metaToOlson = GetMetaToOlsonMap();
	        IList mappings = (IList) ILOG.J2CsMapping.Collections.Collections.Get(metaToOlson,metazoneID);
	        if (mappings != null) {
	            for (int i = 0; i < mappings.Count; i++) {
	                ZoneMeta.MetaToOlsonMappingEntry  olsonmap = (ZoneMeta.MetaToOlsonMappingEntry ) mappings[i];
	                if (olsonmap.territory.Equals(region)) {
	                    tzid = olsonmap.id;
	                    break;
	                } else if (olsonmap.territory.Equals("001")) {
	                    tzid = olsonmap.id;
	                }
	            }
	        }
	        return tzid;
	    }
	
	    // /**
	    // * Returns an Olson ID for the given metazone and locale
	    // */
	    // public static String getZoneIdByMetazone(String metazoneID, ULocale loc)
	    // {
	    // String region = loc.getCountry();
	    // if (region.length() == 0) {
	    // // Get likely region
	    // ULocale tmp = ULocale.addLikelySubtag(loc);
	    // region = tmp.getCountry();
	    // }
	    // return getZoneIdByMetazone(metazoneID, region);
	    // }
	
	    /*
	     * Convert a date string used by metazone mappings to long. The format used
	     * by CLDR metazone mapping is "yyyy-MM-dd HH:mm". We do not want to use
	     * SimpleDateFormat to parse the metazone mapping range strings in
	     * createOlsonToMeta, because it might be called from SimpleDateFormat
	     * initialization code.
	     */
	    static internal long ParseDate(String text) {
	        int year = 0, month = 0, day = 0, hour = 0, min = 0;
	        int idx;
	        int n;
	
	        // "yyyy" (0 - 3)
	        for (idx = 0; idx <= 3; idx++) {
	            n = text[idx] - '0';
	            if (n >= 0 && n < 10) {
	                year = 10 * year + n;
	            } else {
	                throw new ArgumentException("Bad year");
	            }
	        }
	        // "MM" (5 - 6)
	        for (idx = 5; idx <= 6; idx++) {
	            n = text[idx] - '0';
	            if (n >= 0 && n < 10) {
	                month = 10 * month + n;
	            } else {
	                throw new ArgumentException("Bad month");
	            }
	        }
	        // "dd" (8 - 9)
	        for (idx = 8; idx <= 9; idx++) {
	            n = text[idx] - '0';
	            if (n >= 0 && n < 10) {
	                day = 10 * day + n;
	            } else {
	                throw new ArgumentException("Bad day");
	            }
	        }
	        // "HH" (11 - 12)
	        for (idx = 11; idx <= 12; idx++) {
	            n = text[idx] - '0';
	            if (n >= 0 && n < 10) {
	                hour = 10 * hour + n;
	            } else {
	                throw new ArgumentException("Bad hour");
	            }
	        }
	        // "mm" (14 - 15)
	        for (idx = 14; idx <= 15; idx++) {
	            n = text[idx] - '0';
	            if (n >= 0 && n < 10) {
	                min = 10 * min + n;
	            } else {
	                throw new ArgumentException("Bad minute");
	            }
	        }
	
	        long date = IBM.ICU.Impl.Grego.FieldsToDay(year, month - 1, day)
	                * IBM.ICU.Impl.Grego.MILLIS_PER_DAY + hour * IBM.ICU.Impl.Grego.MILLIS_PER_HOUR + min
	                * IBM.ICU.Impl.Grego.MILLIS_PER_MINUTE;
	        return date;
	    }
	}
}
