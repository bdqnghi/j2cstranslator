/**
 *******************************************************************************
 * Copyright (C) 2001-2006, International Business Machines Corporation and    *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 */

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:48 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// A list resource bundle that does redirection
/// because otherwise some of our resource class files
/// are too big for the java runtime to handle.
/// </summary>
///
namespace IBM.ICU.Impl {
	
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.Globalization;
	using System.IO;
	using System.Resources;
	using System.Runtime.CompilerServices;
    using ILOG.J2CsMapping.Util;
    using ILOG.J2CsMapping.Util;
	
	public class ICUListResourceBundle : ListResourceBundle {
	    private const String ICUDATA = "ICUDATA";
	
	    private const String ICU_BUNDLE_NAME = "LocaleElements";
	
	    private const String ICU_PACKAGE_NAME = "com.ibm.icu.impl.data";
	
	    private const String ENCODING = "UTF-8";
	
	    /* package */internal Locale icuLocale;

        /* package */
        internal void SetParentX(ResourceBundle b)
        {
	        SetParent(b);
	    }
	
	    public override Locale GetLocale() {
	        return icuLocale;
	    }
	
	    protected internal ICUListResourceBundle() {
	        this.visited = new Hashtable();
	    }
	
	    private Hashtable visited;
	
	    /// <summary>
	    /// Subclassers must statically initialize this
	    /// </summary>
	    ///
	    protected internal Object[][] contents;
	
	    /// <summary>
	    /// This is our cache
	    /// </summary>
	    ///
	    private Object[][] realContents;
	
	    /// <summary>
	    /// See base class description
	    /// </summary>
	    ///
	    public override Object[][] GetContents() {
	        // we replace any redirected values with real values in a cloned array
	        if (realContents == null) {
	            realContents = contents;
	            for (int i = 0; i < contents.Length; ++i) {
	                Object newValue = GetRedirectedResource(
	                        (String) contents[i][0], contents[i][1], -1);
	                if (newValue != null) {
	                    if (realContents == contents) {
	                        realContents = (Object[][]) contents.Clone();
	                    }
	                    realContents[i] = new Object[] { contents[i][0], newValue };
	                }
	            }
	        }
	        return realContents;
	    }
	
	    /// <summary>
	    /// Return null if value is already in existing contents array, otherwise
	    /// fetch the real value and return it.
	    /// </summary>
	    ///
	    private Object GetRedirectedResource(String key, Object value_ren, int index) {
	
	        if (value_ren   is  Object[][]) {
	            Object[][] aValue = (Object[][]) value_ren;
	            int i = 0;
	            while (i < aValue.Length) {
	                int j = 0;
	                while (j < aValue[i].Length) {
	                    aValue[i][j] = GetRedirectedResource((String) aValue[i][0],
	                            aValue[i][j], i);
	                    j++;
	                }
	                i++;
	            }
	        } else if (value_ren   is  Object[]) {
	            Object[] aValue_0 = (Object[]) value_ren;
	            int i_1 = 0;
	            while (i_1 < aValue_0.Length) {
	                aValue_0[i_1] = GetRedirectedResource(key, aValue_0[i_1], i_1);
	                i_1++;
	            }
	        } else if (value_ren   is  ICUListResourceBundle.Alias ) {
	
	            String cName = this.GetType().FullName;
	            visited.Clear();
	            ILOG.J2CsMapping.Collections.Collections.Put(visited,cName + key,"");
	            return ((ICUListResourceBundle.Alias ) value_ren).GetResource(cName, key, index, visited);
	        } else if (value_ren   is  ICUListResourceBundle.RedirectedResource ) {
	            return ((ICUListResourceBundle.RedirectedResource ) value_ren).GetResource(this);
	        }
	
	        return value_ren;
	    }
	
	    private static byte[] ReadToEOS(Stream stream) {
	        // As of 3.0 this method reads streams of length 264..274008
	        // from the core data. We progressively double the buffer
	        // size to reduce the number of allocations required.
	        try {
	            ArrayList vec = new ArrayList();
	            int count = 0;
	            int length = 0x200; // smallest 2^n >= min stream len
	            int MAXLENGTH = 0x8000;
	            int pos = -1;
	            for (;;) {
	                byte[] buffer = new byte[length];
	                pos = 0;
	                do {
	                    int n = stream.Read(buffer, pos, length - pos);
	                    if (n == -1) {
	                        break;
	                    }
	                    pos += n;
	                } while (pos < length);
	                count += pos;
	                ILOG.J2CsMapping.Collections.Generics.Collections.Add(vec,buffer);
	                if (pos < length) {
	                    break;
	                }
	                if (length < MAXLENGTH) {
	                    length <<= 1;
	                }
	            }
	
	            // System.out.println("\ncount " + count + " bytes from " + stream);
	
	            byte[] data = new byte[count];
	            pos = 0;
	            for (int i = 0; i < vec.Count; ++i) {
	                byte[] buf = (byte[]) vec[i];
	                int len = Math.Min(buf.Length,count - pos);
	                System.Array.Copy((Array)(buf),0,(Array)(data),pos,len);
	                pos += len;
	            }
	            // assert pos==count;
	            return data;
	        } catch (IOException e) {
	            throw new MissingManifestResourceException(e.Message);
	        }
	    }
	
	    private static char[] ReadToEOS(StreamReader stream) {
	        // As of 3.0 this method reads streams of length 41990..41994
	        // from the core data. The IBM 1.4 UTF8 converter doesn't
	        // handle buffering reliably (it throws an exception) so we
	        // are forced to read everything in one chunk.
	        try {
	            int length = 0x10000; // smallest 2^n >= max stream len
	            int MAXLENGTH = 0x40000000;
	            int n;
	            char[] buffer;
	            for (;;) {
	                buffer = new char[length];
	                n = stream.Read(buffer, 0, length);
	                if (n >= 0 && n < length) {
	                    break;
	                }
	                if (length < MAXLENGTH) {
	                    // TODO: stream.Reset();
	                    length <<= 1;
	                } else {
	                    throw new InvalidOperationException(
	                            "maximum input stream length exceeded");
	                }
	            }
	
	            // System.out.println("\ncount " + n + " chars from " + stream);
	
	            char[] data = new char[n];
	            System.Array.Copy((Array)(buffer),0,(Array)(data),0,n);
	            return data;
	        } catch (IOException e) {
	            throw new MissingManifestResourceException(e.Message);
	        }
	    }
	
	    /*
	     * public static class CompressedString : RedirectedResource{
	     * private String expanded=null; private String compressed=null; public
	     * CompressedString(String str){ compressed=str; } public Object
	     * getResource(Object obj){ if(compressed==null){ return null; }
	     * if(expanded==null){ expanded= new
	     * String(Utility.RLEStringToCharArray(compressed)); } return expanded; } }
	     */
	    public class CompressedBinary : ICUListResourceBundle.RedirectedResource  {
	        private sbyte[] expanded;
	
	        private String compressed;
	
	        public CompressedBinary(String str) {
	            this.expanded = null;
	            this.compressed = null;
	            compressed = str;
	        }
	
	        public virtual Object GetResource(Object obj) {
	            if (compressed == null) {
	                return new byte[0];
	            }
	
	            if (expanded == null) {
	                expanded = IBM.ICU.Impl.Utility.RLEStringToByteArray(compressed);
	            }
	            return (expanded == null) ? new sbyte[0] : expanded;
	        }
	
	    }
	
	    private interface RedirectedResource {
	        Object GetResource(Object obj);
	    }
	
	    public class ResourceBinary : ICUListResourceBundle.RedirectedResource  {
	        private byte[] expanded;
	
	        private String resName;
	
	        public ResourceBinary(String name) {
	            this.expanded = null;
	            this.resName = null;
	            resName = "data/" + name;
	        }
	
	        public virtual Object GetResource(Object obj) {
	            if (expanded == null) {
	                Stream stream = IBM.ICU.Impl.ICUData.GetStream(resName);
	                if (stream != null) {
	                    // throw new
	                    // MissingResourceException("",obj.getClass().getName(),resName);
	                    expanded = IBM.ICU.Impl.ICUListResourceBundle.ReadToEOS(stream);
	                    return expanded;
	                }
	            }
	            return "";
	        }
	    }
	
	    public class ResourceString : ICUListResourceBundle.RedirectedResource  {
	        private char[] expanded;
	
	        private String resName;
	
	        public ResourceString(String name) {
	            this.expanded = null;
	            this.resName = null;
	            resName = "data/" + name;
	        }
	
	        public virtual Object GetResource(Object obj) {
	            if (expanded == null) {
	                // Resource strings are always UTF-8
	                Stream stream = IBM.ICU.Impl.ICUData.GetStream(resName);
	                if (stream != null) {
	                    // throw new
	                    // MissingResourceException("",obj.getClass().getName(),resName);
	
	                    try {
	                        StreamReader reader = new StreamReader(stream,System.Text.Encoding.GetEncoding(IBM.ICU.Impl.ICUListResourceBundle.ENCODING));
	                        expanded = IBM.ICU.Impl.ICUListResourceBundle.ReadToEOS(reader);
	                    } catch (IOException ex) {
	                        throw new Exception(
	                                "Could open converter for encoding: "
	                                        + IBM.ICU.Impl.ICUListResourceBundle.ENCODING);
	                    }
	                    return ILOG.J2CsMapping.Util.StringUtil.NewString(expanded);
	                }
	
	            }
	            return "";
	        }
	    }
	
	    private const char RES_PATH_SEP_CHAR = '/';
	
	    public class Alias {
	        public Alias(String path) {
	            pathToResource = path;
	        }
	
	        private String pathToResource;
	
	        public Object GetResource(String className, String parentKey,
	                int index, Hashtable visited_0) {
	            String packageName = null, bundleName = null, locale = null, keyPath = null;
	
	            if (pathToResource.IndexOf(IBM.ICU.Impl.ICUListResourceBundle.RES_PATH_SEP_CHAR) == 0) {
	                int i = pathToResource.IndexOf(IBM.ICU.Impl.ICUListResourceBundle.RES_PATH_SEP_CHAR, 1);
	                int j = pathToResource.IndexOf(IBM.ICU.Impl.ICUListResourceBundle.RES_PATH_SEP_CHAR, i + 1);
	                bundleName = pathToResource.Substring(1,(i)-(1));
	                locale = pathToResource.Substring(i + 1);
	                if (j != -1) {
	                    locale = pathToResource.Substring(i + 1,(j)-(i + 1));
	                    keyPath = pathToResource.Substring(j + 1,(pathToResource.Length)-(j + 1));
	                }
	                // there is a path included
	                if (bundleName.Equals(IBM.ICU.Impl.ICUListResourceBundle.ICUDATA)) {
	                    bundleName = IBM.ICU.Impl.ICUListResourceBundle.ICU_BUNDLE_NAME;
	                    packageName = IBM.ICU.Impl.ICUListResourceBundle.ICU_PACKAGE_NAME;
	                }
	
	            } else {
	                // no path start with locale
	                int i_1 = pathToResource.IndexOf(IBM.ICU.Impl.ICUListResourceBundle.RES_PATH_SEP_CHAR);
	                // If this is a bundle with locale name following it
	                // then it should be of type <bundle name>_<locale>
	                // if not we donot guarantee that this will work
	                int j_2 = className.LastIndexOf(".");
	                packageName = className.Substring(0,(j_2)-(0));
	                int underScoreIndex = className.IndexOf("_");
	                if (underScoreIndex >= 0) {
	                    bundleName = className.Substring(j_2 + 1,(className.IndexOf("_"))-(j_2 + 1));
	                } else {
	                    bundleName = className.Substring(j_2 + 1,(className.Length)-(j_2 + 1));
	                }
	                keyPath = pathToResource.Substring(i_1 + 1);
	
	                if (i_1 != -1) {
	                    locale = pathToResource.Substring(0,(i_1)-(0));
	                } else {
	                    locale = keyPath;
	                    keyPath = parentKey;
	                    if (locale == null || locale.Equals("root")) {
	                        className = packageName + "." + bundleName;
	                    } else {
	                        className = packageName + "." + bundleName + "_"
	                                + locale;
	                    }
	
	                }
	
	            }

                ResourceBundle bundle = null;
	            // getResourceBundle guarantees that the CLASSPATH will be searched
	            // for loading the resource with name
	            // <bundleName>_<localeName>.class
	            if (locale == null || locale.Equals("root")) {
	                bundle = IBM.ICU.Impl.ICULocaleData.GetResourceBundle(packageName,
	                        bundleName, "");
	            } else {
	                bundle = IBM.ICU.Impl.ICULocaleData.GetResourceBundle(packageName,
	                        bundleName, locale);
	            }
	
	            return FindResource(bundle, className, parentKey, index, keyPath,
	                    visited_0);
	
	        }
	
	        public Object FindResource(Object[][] contents_0, String key) {
	            for (int i = 0; i < contents_0.Length; ++i) {
	                // key must be non-null String, value must be non-null
	                String tempKey = (String) contents_0[i][0];
	                Object value_ren = contents_0[i][1];
	                if (tempKey == null || value_ren == null) {
	                    throw new NullReferenceException();
	                }
	                if (tempKey.Equals(key)) {
	                    return value_ren;
	                }
	            }
	            return null;
	        }
	
	        public Object FindResource(Object o, String[] keys, int start,
	                int index) {
	            Object obj = o;
	            if (start < keys.Length && keys[start] != null) {
	                if (obj  is  Object[][]) {
	                    obj = FindResource((Object[][]) obj, keys[start]);
	                } else if (obj  is  Object[] && IBM.ICU.Impl.ICUListResourceBundle.IsIndex(keys[start])) {
	                    obj = ((Object[]) obj)[IBM.ICU.Impl.ICUListResourceBundle.GetIndex(keys[start])];
	                }
	                if (start + 1 < keys.Length && keys[start + 1] != null) {
	                    obj = FindResource(obj, keys, start + 1, index);
	                }
	            } else {
	                // try to find the corresponding index resource
	                if (index >= 0) {
	                    if (obj  is  Object[][]) {
	                        obj = FindResource((Object[][]) obj,
	                                ILOG.J2CsMapping.Util.IlNumber.ToString(index));
	                    } else if (obj  is  Object[]) {
	                        obj = ((Object[]) obj)[index];
	                    }
	                }
	            }
	            return obj;
	        }

            public Object FindResource(ResourceBundle bundle, String className,
	                String requestedKey, int index, String aliasKey,
	                Hashtable visited_0) {
	
	            if (aliasKey != null && visited_0[className + aliasKey] != null) {
	                throw new MissingManifestResourceException("Circular Aliases in bundle.");
	            }
	            if (aliasKey == null) {
	                // currently we do an implicit key lookup
	                // return ((ICUListResourceBundle)bundle).getContents();
	                aliasKey = requestedKey;
	            }
	
	            ILOG.J2CsMapping.Collections.Collections.Put(visited_0,className + requestedKey,"");
	
	            String[] keys = IBM.ICU.Impl.ICUListResourceBundle.Split(aliasKey, IBM.ICU.Impl.ICUListResourceBundle.RES_PATH_SEP_CHAR);
	            Object o = null;
	            if (keys.Length > 0) {
	                o = bundle.GetObject(keys[0]);
	                o = FindResource(o, keys, 1, index);
	            }
	            o = ResolveAliases(o, className, aliasKey, visited_0);
	            return o;
	        }
	
	        public Object ResolveAliases(Object o, String className, String key,
	                Hashtable visited_0) {
	            if (o  is  Object[][]) {
	                o = ResolveAliases((Object[][]) o, className, key, visited_0);
	            } else if (o  is  Object[]) {
	                o = ResolveAliases((Object[]) o, className, key, visited_0);
	            } else if (o  is  ICUListResourceBundle.Alias ) {
	                return ((ICUListResourceBundle.Alias ) o).GetResource(className, key, -1, visited_0);
	            }
	            return o;
	        }
	
	        public Object ResolveAliases(Object[][] o, String className,
	                String key, Hashtable visited_0) {
	            int i = 0;
	            while (i < o.Length) {
	                o[i][1] = ResolveAliases(o[i][1], className, key, visited_0);
	                i++;
	            }
	            return o;
	        }
	
	        public Object ResolveAliases(Object[] o, String className, String key,
	                Hashtable visited_0) {
	            int i = 0;
	            while (i < o.Length) {
	                o[i] = ResolveAliases(o[i], className, key, visited_0);
	                i++;
	            }
	            return o;
	        }
	
	    }
	
	    private static String[] Split(String source, char delimiter) {
	
	        char[] src = source.ToCharArray();
	        int index = 0;
	        int numdelimit = 0;
	        // first count the number of delimiters
	        for (int i = 0; i < source.Length; i++) {
	            if (src[i] == delimiter) {
	                numdelimit++;
	            }
	        }
	        String[] values = null;
	        values = new String[numdelimit + 2];
	        // now split
	        int old = 0;
	        for (int j = 0; j < src.Length; j++) {
	            if (src[j] == delimiter) {
	                values[index++] = new String(src, old, j - old);
	                old = j + 1/* skip after the delimiter */;
	            }
	        }
	        if (old < src.Length)
	            values[index++] = new String(src, old, src.Length - old);
	        return values;
	    }
	
	    /// <summary>
	    /// This method performs multilevel fallback for fetching items from the
	    /// bundle e.g: If resource is in the form de__PHONEBOOK{ collations{
	    /// default{ "phonebook"} } } If the value of "default" key needs to be
	    /// accessed, then do: <code>
	    /// ResourceBundle bundle = new ResourceBundle(getLocaleFromString("de__PHONEBOOK"));
	    /// Object result = null;
	    /// if(bundle instanceof ICUListResourceBundle){
	    /// result = ((ICUListResourceBundle) bundle).getObjectWithFallback("collations/default");
	    /// }
	    /// </code>
	    /// </summary>
	    ///
	    /// <param name="path">The path to the required resource key</param>
	    /// <returns>Object represented by the key</returns>
	    /// <exception cref="MissingResourceException"></exception>
	    public Object GetObjectWithFallback(String path) {
	        String[] keys = Split(path, RES_PATH_SEP_CHAR);
	        Object result = null;
	        ICUListResourceBundle actualBundle = this;
	
	        // now recuse to pick up sub levels of the items
	        result = FindResourceWithFallback(keys, actualBundle);
	
	        if (result == null) {
	            throw new MissingManifestResourceException("Could not find the resource in ");
	        }
	        return result;
	    }
	
	    private Object FindResourceWithFallback(String[] keys,
	            ICUListResourceBundle actualBundle) {
	
	        Object obj = null;
	
	        while (actualBundle != null) {
	            // get the top level resource
	            // getObject is a method on the ResourceBundle class that
	            // performs the normal fallback
	            obj = actualBundle.GetObject(keys[0], actualBundle);
	
	            // now find the bundle from the actual bundle
	            // if this bundle does not contain the top level resource,
	            // then we can be sure that it does not contain the sub elements
	            obj = FindResourceWithFallback(obj, keys, 1, 0);
	            // did we get the contents? the break
	            if (obj != null) {
	                break;
	            }
	            // if not try the parent bundle
	            actualBundle = (ICUListResourceBundle) actualBundle.parent;
	
	        }
	
	        return obj;
	    }
	
	    private Object FindResourceWithFallback(Object o, String[] keys, int start,
	            int index) {
	        Object obj = o;
	
	        if (start < keys.Length && keys[start] != null) {
	            if (obj  is  Object[][]) {
	                obj = FindResourceWithFallback((Object[][]) obj, keys[start]);
	            } else if (obj  is  Object[] && IsIndex(keys[start])) {
	                obj = ((Object[]) obj)[GetIndex(keys[start])];
	            }
	            if (start + 1 < keys.Length && keys[start + 1] != null) {
	                obj = FindResourceWithFallback(obj, keys, start + 1, index);
	            }
	        } else {
	            // try to find the corresponding index resource
	            if (index >= 0) {
	                if (obj  is  Object[][]) {
	                    obj = FindResourceWithFallback((Object[][]) obj,
	                            ILOG.J2CsMapping.Util.IlNumber.ToString(index));
	                } else if (obj  is  Object[]) {
	                    obj = ((Object[]) obj)[index];
	                }
	            }
	        }
	
	        return obj;
	    }
	
	    private Object FindResourceWithFallback(Object[][] cnts, String key) {
	        Object obj = null;
	
	        for (int i = 0; i < cnts.Length; ++i) {
	            // key must be non-null String
	            String tempKey = (String) cnts[i][0];
	            obj = cnts[i][1];
	            if (tempKey != null && tempKey.Equals(key)) {
	                return obj;
	            }
	        }
	
	        return null;
	    }
	
	    private Object GetObject(String key,
	            ICUListResourceBundle actualBundle) {
	        Object obj = HandleGetObject(key);
	        if (obj == null) {
	            ICUListResourceBundle p = (ICUListResourceBundle) this.parent;
	            while (p != null) {
	                obj = p.HandleGetObject(key);
	                if (obj != null) {
	                    actualBundle = p;
	                    break;
	                }
	                p = (ICUListResourceBundle) p.parent;
	            }
	        }
	        return obj;
	    }
	
	    private static bool IsIndex(String s) {
	        if (s.Length == 1) {
	            char c = s[0];
	            return Char.IsDigit(c);
	        }
	        return false;
	    }
	
	    private static int GetIndex(String s) {
	        if (s.Length == 1) {
	            char c = s[0];
	            if (Char.IsDigit(c)) {
	                return ((Int32 )Int32.Parse(s));
	            }
	        }
	        return -1;
	    }
	}
}
