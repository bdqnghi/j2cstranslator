/*
 *******************************************************************************
 * Copyright (C) 1996-2004, International Business Machines Corporation and    *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 */
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:48 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Impl {
	
	using IBM.ICU.Text;
	using ILOG.J2CsMapping.Text;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	
	/// <summary>
	/// This class is a wrapper around CharacterIterator and implements the
	/// UCharacterIterator protocol
	/// </summary>
	///
	
	public class CharacterIteratorWrapper : UCharacterIterator {
	
	    private ICharacterIterator iterator;
	
	    public CharacterIteratorWrapper(ICharacterIterator iter) {
	        if (iter == null) {
	            throw new ArgumentException();
	        }
	        iterator = iter;
	    }
	
	    
	    /// <seealso cref="null"/>
	    public override int Current() {
	        int c = iterator.Current();
	        if (c == ILOG.J2CsMapping.Text.CharacterIterator.Done) {
	            return IBM.ICU.Text.UForwardCharacterIterator_Constants.DONE;
	        }
	        return c;
	    }
	
	    
	    /// <seealso cref="null"/>
	    public override int GetLength() {
	        return (iterator.GetEndIndex() - iterator.GetBeginIndex());
	    }
	
	    
	    /// <seealso cref="null"/>
	    public override int GetIndex() {
	        return iterator.GetIndex();
	    }
	
	    
	    /// <seealso cref="null"/>
	    public override int Next() {
	        int i = iterator.Current();
	        iterator.Next();
	        if (i == ILOG.J2CsMapping.Text.CharacterIterator.Done) {
	            return IBM.ICU.Text.UForwardCharacterIterator_Constants.DONE;
	        }
	        return i;
	    }
	
	    
	    /// <seealso cref="null"/>
	    public override int Previous() {
	        int i = iterator.Previous();
	        if (i == ILOG.J2CsMapping.Text.CharacterIterator.Done) {
	            return IBM.ICU.Text.UForwardCharacterIterator_Constants.DONE;
	        }
	        return i;
	    }
	
	    
	    /// <seealso cref="null"/>
	    public override void SetIndex(int index) {
	        try {
	            iterator.SetIndex(index);
	        } catch (ArgumentException e) {
	            throw new IndexOutOfRangeException();
	        }
	    }
	
	    
	    /// <seealso cref="null"/>
	    public override void SetToLimit() {
	        iterator.SetIndex(iterator.GetEndIndex());
	    }
	
	    
	    /// <seealso cref="null"/>
	    public override int GetText(char[] fillIn, int offset) {
	        int length = iterator.GetEndIndex() - iterator.GetBeginIndex();
	        int currentIndex = iterator.GetIndex();
	        if (offset < 0 || offset + length > fillIn.Length) {
	            throw new IndexOutOfRangeException(ILOG.J2CsMapping.Util.IlNumber.ToString(length).ToString());
	        }
	
	        for (char ch = iterator.First(); ch != ILOG.J2CsMapping.Text.CharacterIterator.Done; ch = iterator
	                .Next()) {
	            fillIn[offset++] = ch;
	        }
	        iterator.SetIndex(currentIndex);
	
	        return length;
	    }
	
	    /// <summary>
	    /// Creates a clone of this iterator. Clones the underlying character
	    /// iterator.
	    /// </summary>
	    ///
	    /// <seealso cref="null"/>
	    public override Object Clone() {
	        try {
	            CharacterIteratorWrapper result = (CharacterIteratorWrapper) base.Clone();
	            result.iterator = (ICharacterIterator) this.iterator;
	            return result;
	        } catch (Exception e) {
	            return null; // only invoked if bad underlying character iterator
	        }
	    }
	
	    public override int MoveIndex(int delta) {
	        int length = iterator.GetEndIndex() - iterator.GetBeginIndex();
	        int idx = iterator.GetIndex() + delta;
	
	        if (idx < 0) {
	            idx = 0;
	        } else if (idx > length) {
	            idx = length;
	        }
	        return iterator.SetIndex(idx);
	    }
	
	    
	    /// <seealso cref="null"/>
	    public override ICharacterIterator GetCharacterIterator() {
	        return (ICharacterIterator) iterator;
	    }
	}
}
