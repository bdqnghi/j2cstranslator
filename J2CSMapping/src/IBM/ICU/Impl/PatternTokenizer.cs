//##header J2SE15
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:47 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 //#if defined(FOUNDATION10) || defined(J2SE13)
//#else
/*
 *******************************************************************************
 * Copyright (C) 2006-2007, Google, International Business Machines Corporation *
 * and others. All Rights Reserved.                                            *
 *******************************************************************************
 */
namespace IBM.ICU.Impl {
	
	using IBM.ICU.Text;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Text;
	
	/// <summary>
	/// A simple parsing class for patterns and rules. Handles '...' quotations,
	/// \\uxxxx and \\Uxxxxxxxx, and symple syntax. The '' (two quotes) is treated as
	/// a single quote, inside or outside a quote
	/// <ul>
	/// <li>Any ignorable characters are ignored in parsing.</li>
	/// <li>Any syntax characters are broken into separate tokens</li>
	/// <li>Quote characters can be specified: '...', "...", and \x</li>
	/// <li>Other characters are treated as literals</li>
	/// </ul>
	/// </summary>
	///
	public class PatternTokenizer {
	    public PatternTokenizer() {
	        this.ignorableCharacters = new UnicodeSet();
	        this.syntaxCharacters = new UnicodeSet();
	        this.extraQuotingCharacters = new UnicodeSet();
	        this.escapeCharacters = new UnicodeSet();
	        this.usingSlash = false;
	        this.usingQuote = false;
	        this.needingQuoteCharacters = null;
	    }
	
	    // settings used in the interpretation of the pattern
	    private UnicodeSet ignorableCharacters;
	
	    private UnicodeSet syntaxCharacters;
	
	    private UnicodeSet extraQuotingCharacters;
	
	    private UnicodeSet escapeCharacters;
	
	    private bool usingSlash;
	
	    private bool usingQuote;
	
	    // transient data, set when needed. Null it out for any changes in the above
	    // fields.
	    private UnicodeSet needingQuoteCharacters;
	
	    // data about the current pattern being parsed. start gets moved as we go
	    // along.
	    private int start;
	
	    private int limit;
	
	    private String pattern;
	
	    public UnicodeSet GetIgnorableCharacters() {
	        return (UnicodeSet) ignorableCharacters.Clone();
	    }
	
	    /// <summary>
	    /// Sets the characters to be ignored in parsing, eg new
	    /// UnicodeSet("[:pattern_whitespace:]");
	    /// </summary>
	    ///
	    /// <param name="ignorableCharacters_0"></param>
	    /// <returns></returns>
	    public PatternTokenizer SetIgnorableCharacters(
	            UnicodeSet ignorableCharacters_0) {
	        this.ignorableCharacters = (UnicodeSet) ignorableCharacters_0.Clone();
	        needingQuoteCharacters = null;
	        return this;
	    }
	
	    public UnicodeSet GetSyntaxCharacters() {
	        return (UnicodeSet) syntaxCharacters.Clone();
	    }
	
	    public UnicodeSet GetExtraQuotingCharacters() {
	        return (UnicodeSet) extraQuotingCharacters.Clone();
	    }
	
	    /// <summary>
	    /// Sets the characters to be interpreted as syntax characters in parsing, eg
	    /// new UnicodeSet("[:pattern_syntax:]")
	    /// </summary>
	    ///
	    /// <param name="syntaxCharacters_0"></param>
	    /// <returns></returns>
	    public PatternTokenizer SetSyntaxCharacters(UnicodeSet syntaxCharacters_0) {
	        this.syntaxCharacters = (UnicodeSet) syntaxCharacters_0.Clone();
	        needingQuoteCharacters = null;
	        return this;
	    }
	
	    /// <summary>
	    /// Sets the extra characters to be quoted in literals
	    /// </summary>
	    ///
	    /// <param name="syntaxCharacters_0"></param>
	    /// <returns></returns>
	    public PatternTokenizer SetExtraQuotingCharacters(
	            UnicodeSet syntaxCharacters_0) {
	        this.extraQuotingCharacters = (UnicodeSet) syntaxCharacters_0.Clone();
	        needingQuoteCharacters = null;
	        return this;
	    }
	
	    public UnicodeSet GetEscapeCharacters() {
	        return (UnicodeSet) escapeCharacters.Clone();
	    }
	
	    /// <summary>
	    /// Set characters to be escaped in literals, in quoteLiteral and normalize,
	    /// eg new UnicodeSet("[^\\u0020-\\u007E]");
	    /// </summary>
	    ///
	    /// <param name="escapeCharacters_0"></param>
	    /// <returns></returns>
	    public PatternTokenizer SetEscapeCharacters(UnicodeSet escapeCharacters_0) {
	        this.escapeCharacters = (UnicodeSet) escapeCharacters_0.Clone();
	        return this;
	    }
	
	    public bool IsUsingQuote() {
	        return usingQuote;
	    }
	
	    public PatternTokenizer SetUsingQuote(bool usingQuote_0) {
	        this.usingQuote = usingQuote_0;
	        needingQuoteCharacters = null;
	        return this;
	    }
	
	    public bool IsUsingSlash() {
	        return usingSlash;
	    }
	
	    public PatternTokenizer SetUsingSlash(bool usingSlash_0) {
	        this.usingSlash = usingSlash_0;
	        needingQuoteCharacters = null;
	        return this;
	    }
	
	    // public UnicodeSet getQuoteCharacters() {
	    // return (UnicodeSet) quoteCharacters.clone();
	    // }
	    // public PatternTokenizer setQuoteCharacters(UnicodeSet quoteCharacters) {
	    // this.quoteCharacters = (UnicodeSet) quoteCharacters.clone();
	    // needingQuoteCharacters = null;
	    // return this;
	    // }
	    public int GetLimit() {
	        return limit;
	    }
	
	    public PatternTokenizer SetLimit(int limit_0) {
	        this.limit = limit_0;
	        return this;
	    }
	
	    public int GetStart() {
	        return start;
	    }
	
	    public PatternTokenizer SetStart(int start_0) {
	        this.start = start_0;
	        return this;
	    }
	
	    public PatternTokenizer SetPattern(String pattern_0) {
	        if (pattern_0 == null) {
	            throw new ArgumentException("Inconsistent arguments");
	        }
	        this.start = 0;
	        this.limit = pattern_0.Length;
	        this.pattern = pattern_0;
	        return this;
	    }
	
	    public const char SINGLE_QUOTE = '\'';
	
	    public const char BACK_SLASH = '\\';
	
	    private static int NO_QUOTE = -1, IN_QUOTE = -2;
	
	    /// <summary>
	    /// Quote a literal string, using the available settings. Thus syntax
	    /// characters, quote characters, and ignorable characters will be put into
	    /// quotes.
	    /// </summary>
	    ///
	    /// <param name="string"></param>
	    /// <returns></returns>
	    public String QuoteLiteral(String str0) {
	        if (needingQuoteCharacters == null) {
	            needingQuoteCharacters = new UnicodeSet().AddAll(syntaxCharacters)
	                    .AddAll(ignorableCharacters).AddAll(extraQuotingCharacters); // .addAll(quoteCharacters)
	            if (usingSlash)
	                needingQuoteCharacters.Add(BACK_SLASH);
	            if (usingQuote)
	                needingQuoteCharacters.Add(SINGLE_QUOTE);
	        }
	        StringBuilder result = new StringBuilder();
	        int quotedChar = NO_QUOTE;
	        int cp;
	        for (int i = 0; i < str0.Length; i += IBM.ICU.Text.UTF16.GetCharCount(cp)) {
	            cp = IBM.ICU.Text.UTF16.CharAt(str0, i);
	            if (escapeCharacters.Contains(cp)) {
	                // we may have to fix up previous characters
	                if (quotedChar == IN_QUOTE) {
	                    result.Append(SINGLE_QUOTE);
	                    quotedChar = NO_QUOTE;
	                }
	                AppendEscaped(result, cp);
	                continue;
	            }
	
	            if (needingQuoteCharacters.Contains(cp)) {
	                // if we have already started a quote
	                if (quotedChar == IN_QUOTE) {
	                    IBM.ICU.Text.UTF16.Append(result, cp);
	                    if (usingQuote && cp == SINGLE_QUOTE) { // double it
	                        result.Append(SINGLE_QUOTE);
	                    }
	                    continue;
	                }
	                // otherwise not already in quote
	                if (usingSlash) {
	                    result.Append(BACK_SLASH);
	                    IBM.ICU.Text.UTF16.Append(result, cp);
	                    continue;
	                }
	                if (usingQuote) {
	                    if (cp == SINGLE_QUOTE) { // double it and continue
	                        result.Append(SINGLE_QUOTE);
	                        result.Append(SINGLE_QUOTE);
	                        continue;
	                    }
	                    result.Append(SINGLE_QUOTE);
	                    IBM.ICU.Text.UTF16.Append(result, cp);
	                    quotedChar = IN_QUOTE;
	                    continue;
	                }
	                // we have no choice but to use \\u or \\U
	                AppendEscaped(result, cp);
	                continue;
	            }
	            // otherwise cp doesn't need quoting
	            // we may have to fix up previous characters
	            if (quotedChar == IN_QUOTE) {
	                result.Append(SINGLE_QUOTE);
	                quotedChar = NO_QUOTE;
	            }
	            IBM.ICU.Text.UTF16.Append(result, cp);
	        }
	        // all done.
	        // we may have to fix up previous characters
	        if (quotedChar == IN_QUOTE) {
	            result.Append(SINGLE_QUOTE);
	        }
	        return result.ToString();
	    }
	
	    private void AppendEscaped(StringBuilder result, int cp) {
	        if (cp <= 0xFFFF) {
	            result.Append("\\u").Append(IBM.ICU.Impl.Utility.Hex(cp, 4));
	        } else {
	            result.Append("\\U").Append(IBM.ICU.Impl.Utility.Hex(cp, 8));
	        }
	    }
	
	    public String Normalize() {
	        int oldStart = start;
	        StringBuilder result = new StringBuilder();
	        StringBuilder buffer = new StringBuilder();
	        while (true) {
	            buffer.Length=0;
	            int status = Next(buffer);
	            if (status == DONE) {
	                start = oldStart;
	                return result.ToString();
	            }
	            if (status != SYNTAX) {
	                result.Append(QuoteLiteral(buffer.ToString()));
	            } else {
	                result.Append(buffer);
	            }
	        }
	    }
	
	    public const int DONE = 0, SYNTAX = 1, LITERAL = 2,
	            BROKEN_QUOTE = 3, BROKEN_ESCAPE = 4, UNKNOWN = 5;
	
	    private const int AFTER_QUOTE = -1, NONE = 0, START_QUOTE = 1,
	            NORMAL_QUOTE = 2, SLASH_START = 3, HEX = 4;
	
	    public int Next(StringBuilder buffer) {
	        if (start >= limit)
	            return DONE;
	        int status = UNKNOWN;
	        int lastQuote = UNKNOWN;
	        int quoteStatus = NONE;
	        int hexCount = 0;
	        int hexValue = 0;
	        int cp;
	        main: {
	            for (int i = start; i < limit; i += IBM.ICU.Text.UTF16.GetCharCount(cp)) {
	                cp = IBM.ICU.Text.UTF16.CharAt(pattern, i);
	                // if we are in a quote, then handle it.
	                switch (quoteStatus) {
	                case SLASH_START:
	                    switch (cp) {
	                    case 'u':
	                        quoteStatus = HEX;
	                        hexCount = 4;
	                        hexValue = 0;
	                        goto main;
	                    case 'U':
	                        quoteStatus = HEX;
	                        hexCount = 8;
	                        hexValue = 0;
	                        goto main;
	                    default:
	                        if (usingSlash) {
	                            IBM.ICU.Text.UTF16.Append(buffer, cp);
	                            quoteStatus = NONE;
	                            goto main;
	                        } else {
	                            buffer.Append(BACK_SLASH);
	                            quoteStatus = NONE;
	                        }
	                        break;
	                    }
	                    break; // fall through to NONE
	                case HEX:
	                    hexValue <<= 4;
	                    hexValue += cp;
	                    switch (cp) {
	                    case '0':
	                    case '1':
	                    case '2':
	                    case '3':
	                    case '4':
	                    case '5':
	                    case '6':
	                    case '7':
	                    case '8':
	                    case '9':
	                        hexValue -= '0';
	                        break;
	                    case 'a':
	                    case 'b':
	                    case 'c':
	                    case 'd':
	                    case 'e':
	                    case 'f':
	                        hexValue -= 'a' - 10;
	                        break;
	                    case 'A':
	                    case 'B':
	                    case 'C':
	                    case 'D':
	                    case 'E':
	                    case 'F':
	                        hexValue -= 'A' - 10;
	                        break;
	                    default:
	                        start = i;
	                        return BROKEN_ESCAPE;
	                    }
	                    --hexCount;
	                    if (hexCount == 0) {
	                        quoteStatus = NONE;
	                        IBM.ICU.Text.UTF16.Append(buffer, hexValue);
	                    }
	                    goto main;
	                case AFTER_QUOTE:
	                    // see if we get another quote character
	                    // if we just ended a quote BUT the following character is the
	                    // lastQuote character, then we have a situation like
	                    // '...''...', so we restart the quote
	                    if (cp == lastQuote) {
	                        IBM.ICU.Text.UTF16.Append(buffer, cp);
	                        quoteStatus = NORMAL_QUOTE;
	                        goto main;
	                    }
	                    quoteStatus = NONE;
	                    break; // fall through to NONE
	                case START_QUOTE:
	                    // if we are at the very start of a quote, and we hit another
	                    // quote mark then we emit a literal quote character and end the
	                    // quote
	                    if (cp == lastQuote) {
	                        IBM.ICU.Text.UTF16.Append(buffer, cp);
	                        quoteStatus = NONE; // get out of quote, with no trace
	                                            // remaining
	                        continue;
	                    }
	                    // otherwise get into quote
	                    IBM.ICU.Text.UTF16.Append(buffer, cp);
	                    quoteStatus = NORMAL_QUOTE;
	                    goto main;
	                case NORMAL_QUOTE:
	                    if (cp == lastQuote) {
	                        quoteStatus = AFTER_QUOTE; // get out of quote
	                        goto main;
	                    }
	                    IBM.ICU.Text.UTF16.Append(buffer, cp);
	                    goto main;
	                }
	
	                if (ignorableCharacters.Contains(cp)) {
	                    continue;
	                }
	                // do syntax characters
	                if (syntaxCharacters.Contains(cp)) {
	                    if (status == UNKNOWN) {
	                        IBM.ICU.Text.UTF16.Append(buffer, cp);
	                        start = i + IBM.ICU.Text.UTF16.GetCharCount(cp);
	                        return SYNTAX;
	                    } else { // LITERAL, so back up and break
	                        start = i;
	                        return status;
	                    }
	                }
	                // otherwise it is a literal; keep on going
	                status = LITERAL;
	                if (cp == BACK_SLASH) {
	                    quoteStatus = SLASH_START;
	                    continue;
	                } else if (usingQuote && cp == SINGLE_QUOTE) {
	                    lastQuote = cp;
	                    quoteStatus = START_QUOTE;
	                    continue;
	                }
	                // normal literals
	                IBM.ICU.Text.UTF16.Append(buffer, cp);
	            }
	        }
	        gotomain:
	        ;
	        // handle final cleanup
	        start = limit;
	        switch (quoteStatus) {
	        case HEX:
	            status = BROKEN_ESCAPE;
	            break;
	        case SLASH_START:
	            if (usingSlash) {
	                status = BROKEN_ESCAPE;
	            } else {
	                buffer.Append(BACK_SLASH);
	            }
	            break;
	        case START_QUOTE:
	        case NORMAL_QUOTE:
	            status = BROKEN_QUOTE;
	            break;
	        }
	        return status;
	    }
	
	}
	// #endif
	// eof
}
