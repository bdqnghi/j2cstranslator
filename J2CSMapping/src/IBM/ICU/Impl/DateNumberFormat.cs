//##header J2SE15
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:48 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /*
 *******************************************************************************
 *   Copyright (C) 2007, International Business Machines
 *   Corporation and others.  All Rights Reserved.
 *******************************************************************************
 */
namespace IBM.ICU.Impl {
	
	using IBM.ICU.Math;
	using IBM.ICU.Text;
	using IBM.ICU.Util;
	using ILOG.J2CsMapping.IO;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Text;
    using ILOG.J2CsMapping.Util;
    using ILOG.J2CsMapping.Text;
	
	/*
	 * NumberFormat implementation dedicated/optimized for DateFormat,
	 * used by SimpleDateFormat implementation.
	 */
	[Serializable]
	public sealed class DateNumberFormat : IBM.ICU.Text.NumberFormat {
	
	    private const long serialVersionUID = -6315692826916346953L;
	
	    private char zeroDigit;
	
	    private char minusSign;
	
	    private bool positiveOnly;
	
	    private char[] decimalBuf; // 20 digits is good
	                                                        // enough to store
	                                                        // Long.MAX_VALUE
	
	    private static SimpleCache CACHE = new SimpleCache();
	
	    private int maxIntDigits;
	
	    private int minIntDigits;
	
	    public DateNumberFormat(ULocale loc) {
	        this.positiveOnly = false;
	        this.decimalBuf = new char[20];
	        Initialize(loc);
	    }
	
	    /*
	     * public DateNumberFormat(char zeroDigit, char minusSign) { this.zeroDigit
	     * = zeroDigit; this.minusSign = minusSign; }
	     */
	
	    private void Initialize(ULocale loc) {
	        char[] elems = (char[]) CACHE.Get(loc);
	        if (elems == null) {
	            // Missed cache
	            ICUResourceBundle rb = (ICUResourceBundle) IBM.ICU.Util.UResourceBundle
	                    .GetBundleInstance(IBM.ICU.Impl.ICUResourceBundle.ICU_BASE_NAME, loc);
	            String[] numberElements = rb.GetStringArray("NumberElements");
	            elems = new char[2];
	            elems[0] = numberElements[4][0];
	            elems[1] = numberElements[6][0];
	            CACHE.Put(loc, elems);
	        }
	        zeroDigit = elems[0];
	        minusSign = elems[1];
	    }
	
	    public override void SetMaximumIntegerDigits(int newValue) {
	        maxIntDigits = newValue;
	    }
	
	    public override int GetMaximumIntegerDigits() {
	        return maxIntDigits;
	    }
	
	    public override void SetMinimumIntegerDigits(int newValue) {
	        minIntDigits = newValue;
	    }
	
	    public override int GetMinimumIntegerDigits() {
	        return minIntDigits;
	    }
	
	    /* For supporting SimpleDateFormat.parseInt */
	    public void SetParsePositiveOnly(bool isPositiveOnly) {
	        positiveOnly = isPositiveOnly;
	    }
	
	    public char GetZeroDigit() {
	        return zeroDigit;
	    }
	
	    public override StringBuilder Format(double number, StringBuilder toAppendTo,
	            FieldPosition pos) {
	        throw new NotSupportedException(
	                "StringBuffer format(double, StringBuffer, FieldPostion) is not implemented");
	    }
	
	    public override StringBuilder Format(long numberL, StringBuilder toAppendTo,
	            FieldPosition pos) {
	
	        if (numberL < 0) {
	            // negative
	            toAppendTo.Append(minusSign);
	        }
	
	        // Note: NumberFormat used by DateFormat only uses int numbers.
	        // Remainder operation on 32bit platform using long is significantly
	        // slower
	        // than int. So, this method casts long number into int.
	        int number = (int) numberL;
	
	        int limit = (decimalBuf.Length < maxIntDigits) ? decimalBuf.Length
	                : maxIntDigits;
	        int index = limit - 1;
	        while (true) {
	            decimalBuf[index] = (char) ((number % 10) + zeroDigit);
	            number /= 10;
	            if (index == 0 || number == 0) {
	                break;
	            }
	            index--;
	        }
	        int padding = minIntDigits - (limit - index);
	        for (; padding > 0; padding--) {
	            decimalBuf[--index] = zeroDigit;
	        }
	        int length = limit - index;
	        toAppendTo.Append(decimalBuf, index, length);
	        pos.SetBeginIndex(0);
	        if (pos.GetField() == IBM.ICU.Text.NumberFormat.INTEGER_FIELD) {
	            pos.SetEndIndex(length);
	        } else {
	            pos.SetEndIndex(0);
	        }
	        return toAppendTo;
	    }
	
	    public override StringBuilder FormatObject(Int64 number, StringBuilder toAppendTo,
	            FieldPosition pos) {
	        throw new NotSupportedException(
	                "StringBuffer format(BigInteger, StringBuffer, FieldPostion) is not implemented");
	    }
	
	    // #if defined(FOUNDATION10) || defined(J2SE13)
	    // #else
	    public override StringBuilder Format(Decimal number,
	            StringBuilder toAppendTo, FieldPosition pos) {
	        throw new NotSupportedException(
	                "StringBuffer format(BigDecimal, StringBuffer, FieldPostion) is not implemented");
	    }
	
	    // #endif
	
	    public override StringBuilder Format(BigDecimal number, StringBuilder toAppendTo,
	            FieldPosition pos) {
	        throw new NotSupportedException(
	                "StringBuffer format(BigDecimal, StringBuffer, FieldPostion) is not implemented");
	    }
	
	    /*
	     * Note: This method only parse integer numbers which can be represented by
	     * long
	     */
	    public override object Parse(String text, ParsePosition parsePosition) {
	        long num = 0;
	        bool sawNumber = false;
	        bool negative = false;
	        int bs = parsePosition.GetIndex();
	        int offset = 0;
	        for (; bs + offset < text.Length; offset++) {
	            char ch = text[bs + offset];
	            if (offset == 0 && ch == minusSign) {
	                if (positiveOnly) {
	                    break;
	                }
	                negative = true;
	            } else {
	                int digit = ch - zeroDigit;
	                if (digit < 0 || 9 < digit) {
	                    digit = IBM.ICU.Lang.UCharacter.Digit(ch);
	                }
	                if (0 <= digit && digit <= 9) {
	                    sawNumber = true;
	                    num = num * 10 + digit;
	                } else {
	                    break;
	                }
	            }
	        }
	        object result = null;
	        if (sawNumber) {
	            num = (negative) ? num * (-1) : num;
	            result = (long)(num);
	            parsePosition.SetIndex(bs + offset);
	        }
	        return result;
	    }
	
	    public override bool Equals(Object obj) {
	        if (obj == null || !base.Equals(obj)
	                || !(obj  is  DateNumberFormat)) {
	            return false;
	        }
	        DateNumberFormat other = (DateNumberFormat) obj;
	        return (this.maxIntDigits == other.maxIntDigits
	                && this.minIntDigits == other.minIntDigits
	                && this.zeroDigit == other.zeroDigit
	                && this.minusSign == other.minusSign && this.positiveOnly == other.positiveOnly);
	    }
	
	    private void ReadObject(IlObjectInputStream stream) {
	        stream.DefaultReadObject();
	        // re-allocate the work buffer
	        decimalBuf = new char[20];
	    }
	}
	
	// eof
}
