/*
 *******************************************************************************
 *
 *   Copyright (C) 2004-2007, International Business Machines
 *   Corporation and others.  All Rights Reserved.
 *
 *******************************************************************************
 *   file name:  UBiDiProps.java
 *   encoding:   US-ASCII
 *   tab size:   8 (not used)
 *   indentation:4
 *
 *   created on: 2005jan16
 *   created by: Markus W. Scherer
 *
 *   Low-level Unicode bidi/shaping properties access.
 *   Java port of ubidi_props.h/.c.
 */

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:47 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Impl {
	
	using IBM.ICU.Text;
	using IBM.ICU.Util;
	using ILOG.J2CsMapping.IO;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	
	public sealed class UBiDiProps {
	    // constructors etc. --------------------------------------------------- ***
	
	    // port of ubidi_openProps()
	    public UBiDiProps() {
            Stream mask0 = IBM.ICU.Impl.ICUData.GetStream(IBM.ICU.Impl.ICUResourceBundle.ICU_DATA_PATH + IBM.ICU.Impl.ICUResourceBundle.ICU_BUNDLE + "/"
	                + DATA_FILE_NAME);
	        BufferedStream b = new BufferedStream(mask0,4096 /*
	                                                                          * data buffer
	                                                                          * size
	                                                                          */);
	        ReadData(b);
	        b.Close();
	        mask0.Close();
	
	    }
	
	    private void ReadData(Stream mask0) {
	        DataInputStream inputStream = new DataInputStream(mask0);
	
	        // read the header
	        IBM.ICU.Impl.ICUBinary.ReadHeader(inputStream, FMT, new UBiDiProps.IsAcceptable ());
	
	        // read indexes[]
	        int i, count;
	        count = inputStream.ReadInt();
	        if (count < IX_INDEX_TOP) {
	            throw new IOException("indexes[0] too small in " + DATA_FILE_NAME);
	        }
	        indexes = new int[count];
	
	        indexes[0] = count;
	        for (i = 1; i < count; ++i) {
	            indexes[i] = inputStream.ReadInt();
	        }
	
	        // read the trie
	        trie = new CharTrie(inputStream, null);
	
	        // read mirrors[]
	        count = indexes[IX_MIRROR_LENGTH];
	        if (count > 0) {
	            mirrors = new int[count];
	            for (i = 0; i < count; ++i) {
	                mirrors[i] = inputStream.ReadInt();
	            }
	        }
	
	        // read jgArray[]
	        count = indexes[IX_JG_LIMIT] - indexes[IX_JG_START];
	        jgArray = new sbyte[count];
	        for (i = 0; i < count; ++i) {
	            jgArray[i] = inputStream.ReadByte();
	        }
	    }
	
	    // implement ICUBinary.Authenticate
	    private sealed class IsAcceptable : ICUBinary.Authenticate {
	        public bool IsDataVersionAcceptable(byte[] version) {
	            return version[0] == 1 && version[2] == IBM.ICU.Impl.Trie.INDEX_STAGE_1_SHIFT_
	                    && version[3] == IBM.ICU.Impl.Trie.INDEX_STAGE_2_SHIFT_;
	        }
	    }
	
	    // UBiDiProps singleton
	    private static UBiDiProps gBdp = null;
	
	    // port of ubidi_getSingleton()
	    [MethodImpl(MethodImplOptions.Synchronized)]
	    public static UBiDiProps GetSingleton() {
	        if (gBdp == null) {
	            gBdp = new UBiDiProps();
	        }
	        return gBdp;
	    }
	
	    // UBiDiProps dummy singleton
	    private static UBiDiProps gBdpDummy = null;
	
	    private UBiDiProps(bool makeDummy) { // ignore makeDummy, only creates a
	                                            // unique signature
	        indexes = new int[IX_TOP];
	        indexes[0] = IX_TOP;
	        trie = new CharTrie(0, 0, null); // dummy trie, always returns 0
	    }
	
	    /// <summary>
	    /// Get a singleton dummy object, one that works with no real data. This can
	    /// be used when the real data is not available. Using the dummy can reduce
	    /// checks for available data after an initial failure. Port of
	    /// ucase_getDummy().
	    /// </summary>
	    ///
	    [MethodImpl(MethodImplOptions.Synchronized)]
	    public static UBiDiProps GetDummy() {
	        if (gBdpDummy == null) {
	            gBdpDummy = new UBiDiProps(true);
	        }
	        return gBdpDummy;
	    }
	
	    // set of property starts for UnicodeSet ------------------------------- ***
	
	    public void AddPropertyStarts(UnicodeSet set) {
	        int i, length;
	        int c, start, limit;
	
	        sbyte prev, jg;
	
	        /* add the start code point of each same-value range of the trie */
	        TrieIterator iter = new TrieIterator(trie);
	        RangeValueIterator_Constants.Element element = new RangeValueIterator_Constants.Element();
	
	        while (iter.Next(element)) {
	            set.Add(element.start);
	        }
	
	        /* add the code points from the bidi mirroring table */
	        length = indexes[IX_MIRROR_LENGTH];
	        for (i = 0; i < length; ++i) {
	            c = GetMirrorCodePoint(mirrors[i]);
	            set.Add(c, c + 1);
	        }
	
	        /*
	         * add the code points from the Joining_Group array where the value
	         * changes
	         */
	        start = indexes[IX_JG_START];
	        limit = indexes[IX_JG_LIMIT];
	        length = limit - start;
	        prev = 0;
	        for (i = 0; i < length; ++i) {
	            jg = jgArray[i];
	            if (jg != prev) {
	                set.Add(start);
	                prev = jg;
	            }
	            ++start;
	        }
	        if (prev != 0) {
	            /*
	             * add the limit code point if the last value was not 0 (it is now
	             * start==limit)
	             */
	            set.Add(limit);
	        }
	
	        /*
	         * add code points with hardcoded properties, plus the ones following
	         * them
	         */
	
	        /* (none right now) */
	    }
	
	    // property access functions ------------------------------------------- ***
	
	    public int GetMaxValue(int which) {
	        int max;
	
	        max = indexes[IX_MAX_VALUES];
	        switch (which) {
	        case IBM.ICU.Lang.UProperty_Constants.BIDI_CLASS:
	            return (max & CLASS_MASK);
            case IBM.ICU.Lang.UProperty_Constants.JOINING_GROUP:
	            return (max & MAX_JG_MASK) >> MAX_JG_SHIFT;
            case IBM.ICU.Lang.UProperty_Constants.JOINING_TYPE:
	            return (max & JT_MASK) >> JT_SHIFT;
	        default:
	            return -1; /* undefined */
	        }
	    }
	
	    public int GetClass(int c) {
	        return GetClassFromProps(trie.GetCodePointValue(c));
	    }
	
	    public bool IsMirrored(int c) {
	        return GetFlagFromProps(trie.GetCodePointValue(c), IS_MIRRORED_SHIFT);
	    }
	
	    public int GetMirror(int c) {
	        int props;
	        int delta;
	
	        props = trie.GetCodePointValue(c);
	        delta = ((short) props) >> MIRROR_DELTA_SHIFT;
	        if (delta != ESC_MIRROR_DELTA) {
	            return c + delta;
	        } else {
	            /* look for mirror code point in the mirrors[] table */
	            int m;
	            int i, length;
	            int c2;
	
	            length = indexes[IX_MIRROR_LENGTH];
	
	            /* linear search */
	            for (i = 0; i < length; ++i) {
	                m = mirrors[i];
	                c2 = GetMirrorCodePoint(m);
	                if (c == c2) {
	                    /*
	                     * found c, return its mirror code point using the index in
	                     * m
	                     */
	                    return GetMirrorCodePoint(mirrors[GetMirrorIndex(m)]);
	                } else if (c < c2) {
	                    break;
	                }
	            }
	
	            /* c not found, return it itself */
	            return c;
	        }
	    }
	
	    public bool IsBidiControl(int c) {
	        return GetFlagFromProps(trie.GetCodePointValue(c), BIDI_CONTROL_SHIFT);
	    }
	
	    public bool IsJoinControl(int c) {
	        return GetFlagFromProps(trie.GetCodePointValue(c), JOIN_CONTROL_SHIFT);
	    }
	
	    public int GetJoiningType(int c) {
	        return (trie.GetCodePointValue(c) & JT_MASK) >> JT_SHIFT;
	    }
	
	    public int GetJoiningGroup(int c) {
	        int start, limit;
	
	        start = indexes[IX_JG_START];
	        limit = indexes[IX_JG_LIMIT];
	        if (start <= c && c < limit) {
	            return (int) jgArray[c - start] & 0xff;
	        } else {
	            return IBM.ICU.Lang.UCharacter.JoiningGroup.NO_JOINING_GROUP;
	        }
	    }
	
	    private int[] indexes;
	
	    private int[] mirrors;
	
	    private sbyte[] jgArray;
	
	    private CharTrie trie;
	
	    // data format constants ----------------------------------------------- ***
	    private const String DATA_NAME = "ubidi";
	
	    private const String DATA_TYPE = "icu";
	
	    private const String DATA_FILE_NAME = DATA_NAME + "." + DATA_TYPE;
	
	    private static readonly byte[] FMT = { 0x42, 0x69, 0x44, 0x69 };
	
	    /* indexes into indexes[] */
	    private const int IX_INDEX_TOP = 0;
	
	    // private static final int IX_LENGTH=1;
	    // private static final int IX_TRIE_SIZE=2;
	    private const int IX_MIRROR_LENGTH = 3;
	
	    private const int IX_JG_START = 4;
	
	    private const int IX_JG_LIMIT = 5;
	
	    private const int IX_MAX_VALUES = 15;
	
	    private const int IX_TOP = 16;
	
	    // definitions for 16-bit bidi/shaping properties word ----------------- ***
	
	    /* CLASS_SHIFT=0, *//* bidi class: 5 bits (4..0) */
	    private const int JT_SHIFT = 5; /* joining type: 3 bits (7..5) */
	
	    /* private static final int _SHIFT=8, reserved: 2 bits (9..8) */
	
	    private const int JOIN_CONTROL_SHIFT = 10;
	
	    private const int BIDI_CONTROL_SHIFT = 11;
	
	    private const int IS_MIRRORED_SHIFT = 12; /* 'is mirrored' */
	
	    private const int MIRROR_DELTA_SHIFT = 13; /*
	                                                       * bidi mirroring delta: 3
	                                                       * bits (15..13)
	                                                       */
	
	    private const int MAX_JG_SHIFT = 16; /*
	                                                 * max JG value in
	                                                 * indexes[MAX_VALUES_INDEX]
	                                                 * bits 23..16
	                                                 */
	
	    private const int CLASS_MASK = 0x0000001f;
	
	    private const int JT_MASK = 0x000000e0;
	
	    private const int MAX_JG_MASK = 0x00ff0000;
	
	    private static int GetClassFromProps(int props) {
	        return props & CLASS_MASK;
	    }
	
	    private static bool GetFlagFromProps(int props, int shift) {
	        return ((props >> shift) & 1) != 0;
	    }
	
	    private const int ESC_MIRROR_DELTA = -4;
	
	    // private static final int MIN_MIRROR_DELTA=-3;
	    // private static final int MAX_MIRROR_DELTA=3;
	
	    // definitions for 32-bit mirror table entry --------------------------- ***
	
	    /* the source Unicode code point takes 21 bits (20..0) */
	    private const int MIRROR_INDEX_SHIFT = 21;
	
	    // private static final int MAX_MIRROR_INDEX=0x7ff;
	
	    private static int GetMirrorCodePoint(int m) {
	        return m & 0x1fffff;
	    }
	
	    private static int GetMirrorIndex(int m) {
	        return (int) (((uint) m) >> MIRROR_INDEX_SHIFT);
	    }
	}
}
