/*
 ******************************************************************************
 * Copyright (C) 2007, International Business Machines Corporation and   *
 * others. All Rights Reserved.                                               *
 ******************************************************************************
 */

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/8/10 10:24 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Impl.Duration {
	
	//using IBM.ICU.Impl.Duration.BasicPeriodFormatterFactory;
	using IBM.ICU.Impl.Duration.Impl;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Text;
	
	/// <summary>
	/// Core implementation class for PeriodFormatter.
	/// </summary>
	///
	internal class BasicPeriodFormatter : PeriodFormatter {
	    private BasicPeriodFormatterFactory factory;
	
	    private String localeName;
	
	    private PeriodFormatterData data;
	
	    private IBM.ICU.Impl.Duration.BasicPeriodFormatterFactory.Customizations  customs;
	
	    internal BasicPeriodFormatter(BasicPeriodFormatterFactory factory_0,
	            String localeName_1, PeriodFormatterData data_2, IBM.ICU.Impl.Duration.BasicPeriodFormatterFactory.Customizations  customs_3) {
	        this.factory = factory_0;
	        this.localeName = localeName_1;
	        this.data = data_2;
	        this.customs = customs_3;
	    }
	
	    public virtual String Format(Period period) {
	        if (!period.IsSet()) {
	            throw new ArgumentException("period is not set");
	        }
	        return Format(period.timeLimit, period.inFuture, period.counts);
	    }
	
	    public virtual PeriodFormatter WithLocale(String localeName_0) {
	        if (!this.localeName.Equals(localeName_0)) {
	            PeriodFormatterData newData = factory.GetData(localeName_0);
	            return new BasicPeriodFormatter(factory, localeName_0, newData,
	                    customs);
	        }
	        return this;
	    }
	
	    private String Format(int tl, bool inFuture, int[] counts) {
	        int mask = 0;
	        for (int i = 0; i < counts.Length; ++i) {
	            if (counts[i] > 0) {
	                mask |= 1 << i;
	            }
	        }
	
	        // if the data does not allow formatting of zero periods,
	        // remove these from consideration. If the result has no
	        // periods set, return null to indicate we could not format
	        // the duration.
	        if (!data.AllowZero()) {
	            for (int i_0 = 0, m = 1; i_0 < counts.Length; ++i_0, m <<= 1) {
	                if ((mask & m) != 0 && counts[i_0] == 1) {
	                    mask &= ~m;
	                }
	            }
	            if (mask == 0) {
	                return null;
	            }
	        }
	
	        // if the data does not allow milliseconds but milliseconds are
	        // set, merge them with seconds and force display of seconds to
	        // decimal with 3 places.
	        bool forceD3Seconds = false;
	        if (data.UseMilliseconds() != IBM.ICU.Impl.Duration.Impl.DataRecord.EMilliSupport.YES
	                && (mask & (1 << TimeUnit.MILLISECOND.ordinal)) != 0) {
	            int sx = TimeUnit.SECOND.ordinal;
	            int mx = TimeUnit.MILLISECOND.ordinal;
	            int sf = 1 << sx;
	            int mf = 1 << mx;
	            switch (data.UseMilliseconds()) {
	            case IBM.ICU.Impl.Duration.Impl.DataRecord.EMilliSupport.WITH_SECONDS: {
	                // if there are seconds, merge with seconds, otherwise leave
	                // alone
	                if ((mask & sf) != 0) {
	                    counts[sx] += (counts[mx] - 1) / 1000;
	                    mask &= ~mf;
	                    forceD3Seconds = true;
	                }
	            }
	                break;
	            case IBM.ICU.Impl.Duration.Impl.DataRecord.EMilliSupport.NO: {
	                // merge with seconds, reset seconds before use just in case
	                if ((mask & sf) == 0) {
	                    mask |= sf;
	                    counts[sx] = 1;
	                }
	                counts[sx] += (counts[mx] - 1) / 1000;
	                mask &= ~mf;
	                forceD3Seconds = true;
	            }
	                break;
	            }
	        }
	
	        // get the first and last units that are set.
	        int first = 0;
	        int last = counts.Length - 1;
	        while (first < counts.Length && (mask & (1 << first)) == 0)
	            ++first;
	        while (last > first && (mask & (1 << last)) == 0)
	            --last;
	
	        // determine if there is any non-zero unit
	        bool isZero = true;
	        for (int i_1 = first; i_1 <= last; ++i_1) {
	            if (((mask & (1 << i_1)) != 0) && counts[i_1] > 1) {
	                isZero = false;
	                break;
	            }
	        }
	
	        StringBuilder sb = new StringBuilder();
	
	        // if we've been requested to not display a limit, or there are
	        // no non-zero units, do not display the limit.
	        if (!customs.displayLimit || isZero) {
	            tl = IBM.ICU.Impl.Duration.Impl.DataRecord.ETimeLimit.NOLIMIT;
	        }
	
	        // if we've been requested to not display the direction, or there
	        // are no non-zero units, do not display the direction.
	        int td;
	        if (!customs.displayDirection || isZero) {
	            td = IBM.ICU.Impl.Duration.Impl.DataRecord.ETimeDirection.NODIRECTION;
	        } else {
	            td = (inFuture) ? IBM.ICU.Impl.Duration.Impl.DataRecord.ETimeDirection.FUTURE : IBM.ICU.Impl.Duration.Impl.DataRecord.ETimeDirection.PAST;
	        }
	
	        // format the initial portion of the string before the units.
	        // record whether we need to use a digit prefix (because the
	        // initial portion forces it)
	        bool useDigitPrefix = data.AppendPrefix(tl, td, sb);
	
	        // determine some formatting params and initial values
	        bool multiple = first != last;
	        bool wasSkipped = true; // no initial skip marker
	        bool skipped = false;
	        bool countSep = customs.separatorVariant != IBM.ICU.Impl.Duration.Impl.DataRecord.ESeparatorVariant.NONE;
	
	        // loop for formatting the units
	        for (int i_2 = first, j = i_2; i_2 <= last; i_2 = j) {
	            if (skipped) {
	                // we didn't format the previous unit
	                data.AppendSkippedUnit(sb);
	                skipped = false;
	                wasSkipped = true;
	            }
	
	            while (++j < last && (mask & (1 << j)) == 0) {
	                skipped = true; // skip
	            }
	
	            TimeUnit unit = IBM.ICU.Impl.Duration.TimeUnit.units[i_2];
	            int count = counts[i_2] - 1;
	
	            int cv = customs.countVariant;
	            if (i_2 == last) {
	                if (forceD3Seconds) {
	                    cv = IBM.ICU.Impl.Duration.Impl.DataRecord.ECountVariant.DECIMAL3;
	                }
	                // else leave unchanged
	            } else {
	                cv = IBM.ICU.Impl.Duration.Impl.DataRecord.ECountVariant.INTEGER;
	            }
	            bool isLast = i_2 == last;
	            bool mustSkip = data.AppendUnit(unit, count, cv,
	                    customs.unitVariant, countSep, useDigitPrefix, multiple,
	                    isLast, wasSkipped, sb);
	            skipped |= mustSkip;
	            wasSkipped = false;
	
	            if (customs.separatorVariant != IBM.ICU.Impl.Duration.Impl.DataRecord.ESeparatorVariant.NONE && j <= last) {
	                bool afterFirst = i_2 == first;
	                bool beforeLast = j == last;
	                bool fullSep = customs.separatorVariant == IBM.ICU.Impl.Duration.Impl.DataRecord.ESeparatorVariant.FULL;
	                useDigitPrefix = data.AppendUnitSeparator(unit, fullSep,
	                        afterFirst, beforeLast, sb);
	            } else {
	                useDigitPrefix = false;
	            }
	        }
	        data.AppendSuffix(tl, td, sb);
	
	        return sb.ToString();
	    }
	}
}
