/*
 ******************************************************************************
 * Copyright (C) 2007, International Business Machines Corporation and   *
 * others. All Rights Reserved.                                               *
 ******************************************************************************
 */

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/8/10 10:24 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Impl.Duration.Impl {
	
	using IBM.ICU.Impl.Duration;
	//using IBM.ICU.Impl.Duration.Impl.DataRecord;
	using ILOG.J2CsMapping.Threading;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Text;
	
	/// <summary>
	/// PeriodFormatterData provides locale-specific data used to format relative
	/// dates and times, and convenience api to access it.
	/// An instance of PeriodFormatterData is usually created by requesting data for
	/// a given locale from an PeriodFormatterDataService.
	/// </summary>
	///
	public class PeriodFormatterData {
	    internal readonly DataRecord dr;
	
	    internal String localeName;
	
	    // debug
	    public static bool trace = false;
	
	    public PeriodFormatterData(String localeName_0, DataRecord dr_1) {
	        this.dr = dr_1;
	        this.localeName = localeName_0;
	        if (localeName_0 == null) {
	            throw new NullReferenceException("localename is null");
	        }
	        // System.err.println("** localeName is " + localeName);
	        if (dr_1 == null) {
	            // Thread.dumpStack();
	            throw new NullReferenceException("data record is null");
	        }
	    }
	
	    // none - chinese (all forms the same)
	    // plural - english, special form for 1
	    // dual - special form for 1 and 2
	    // paucal - russian, special form for 1, for 2-4 and n > 20 && n % 10 == 2-4
	    // rpt_dual_few - slovenian, special form for 1, 2, 3-4 and n as above
	    // hebrew, dual plus singular form for years > 11
	    // arabic, dual, plus singular form for all terms > 10
	
	    /// <summary>
	    /// Return the pluralization format used by this locale.
	    /// </summary>
	    ///
	    /// <returns>the pluralization format</returns>
	    public int Pluralization() {
	        return dr.pl;
	    }
	
	    /// <summary>
	    /// Return true if zeros are allowed in the display.
	    /// </summary>
	    ///
	    /// <returns>true if zeros should be allowed</returns>
	    public bool AllowZero() {
	        return dr.allowZero;
	    }
	
	    public bool WeeksAloneOnly() {
	        return dr.weeksAloneOnly;
	    }
	
	    public int UseMilliseconds() {
	        return dr.useMilliseconds;
	    }
	
	    /// <summary>
	    /// Append the appropriate prefix to the string builder, depending on whether
	    /// and how a limit and direction are to be displayed.
	    /// </summary>
	    ///
	    /// <param name="tl">how and whether to display the time limit</param>
	    /// <param name="td">how and whether to display the time direction</param>
	    /// <param name="sb">the string builder to which to append the text</param>
	    /// <returns>true if a following digit will require a digit prefix</returns>
	    public bool AppendPrefix(int tl, int td, StringBuilder sb) {
	        if (dr.scopeData != null) {
	            int ix = tl * 3 + td;
	            IBM.ICU.Impl.Duration.Impl.DataRecord.ScopeData  sd = dr.scopeData[ix];
	            if (sd != null) {
	                String prefix = sd.prefix;
	                if (prefix != null) {
	                    sb.Append(prefix);
	                    return sd.requiresDigitPrefix;
	                }
	            }
	        }
	        return false;
	    }
	
	    /// <summary>
	    /// Append the appropriate suffix to the string builder, depending on whether
	    /// and how a limit and direction are to be displayed.
	    /// </summary>
	    ///
	    /// <param name="tl">how and whether to display the time limit</param>
	    /// <param name="td">how and whether to display the time direction</param>
	    /// <param name="sb">the string builder to which to append the text</param>
	    public void AppendSuffix(int tl, int td, StringBuilder sb) {
	        if (dr.scopeData != null) {
	            int ix = tl * 3 + td;
	            IBM.ICU.Impl.Duration.Impl.DataRecord.ScopeData  sd = dr.scopeData[ix];
	            if (sd != null) {
	                String suffix = sd.suffix;
	                if (suffix != null) {
	                    if (trace) {
	                        System.Console.Out.WriteLine("appendSuffix '" + suffix + "'");
	                    }
	                    sb.Append(suffix);
	                }
	            }
	        }
	    }
	
	    /// <summary>
	    /// Append the count and unit to the string builder.
	    /// </summary>
	    ///
	    /// <param name="unit">the unit to append</param>
	    /// <param name="count">the count of units, /// 1000</param>
	    /// <param name="cv">the format to use for displaying the count</param>
	    /// <param name="uv">the format to use for displaying the unit</param>
	    /// <param name="useCountSep">if false, force no separator between count and unit</param>
	    /// <param name="useDigitPrefix">if true, use the digit prefix</param>
	    /// <param name="multiple">true if there are multiple units in this string</param>
	    /// <param name="last">true if this is the last unit</param>
	    /// <param name="wasSkipped">true if the unit(s) before this were skipped</param>
	    /// <param name="sb">the string builder to which to append the text</param>
	    /// <param name=" return true if will require skip marker"></param>
	    public bool AppendUnit(TimeUnit unit, int count, int cv, int uv,
	            bool useCountSep, bool useDigitPrefix, bool multiple,
	            bool last, bool wasSkipped, StringBuilder sb) {
	        int px = unit.Ordinal();
	
	        bool willRequireSkipMarker = false;
	        if (dr.requiresSkipMarker != null && dr.requiresSkipMarker[px]
	                && dr.skippedUnitMarker != null) {
	            if (!wasSkipped && last) {
	                sb.Append(dr.skippedUnitMarker);
	            }
	            willRequireSkipMarker = true;
	        }
	
	        if (uv != IBM.ICU.Impl.Duration.Impl.DataRecord.EUnitVariant.PLURALIZED) {
	            bool useMedium = uv == IBM.ICU.Impl.Duration.Impl.DataRecord.EUnitVariant.MEDIUM;
	            String[] names = (useMedium) ? dr.mediumNames : dr.shortNames;
	            if (names == null || names[px] == null) {
	                names = (useMedium) ? dr.shortNames : dr.mediumNames;
	            }
	            if (names != null && names[px] != null) {
	                AppendCount(unit, false, false, count, cv, useCountSep,
	                        names[px], last, sb); // omit suffix, ok?
	                return false; // omit skip marker
	            }
	        }
	
	        // check cv
	        if (cv == IBM.ICU.Impl.Duration.Impl.DataRecord.ECountVariant.HALF_FRACTION && dr.halfSupport != null) {
	            switch (dr.halfSupport[px]) {
	            case IBM.ICU.Impl.Duration.Impl.DataRecord.EHalfSupport.YES:
	                break;
	            case IBM.ICU.Impl.Duration.Impl.DataRecord.EHalfSupport.ONE_PLUS:
	                if (count > 1000) {
	                    break;
	                }
	                {
	                    {
	                        count = (count / 500) * 500;
	                        cv = IBM.ICU.Impl.Duration.Impl.DataRecord.ECountVariant.DECIMAL1;
	                    }
	                    break;
	                }
	                break;
	            // else fall through to decimal
	            case IBM.ICU.Impl.Duration.Impl.DataRecord.EHalfSupport.NO: {
	                count = (count / 500) * 500; // round to 1/2
	                cv = IBM.ICU.Impl.Duration.Impl.DataRecord.ECountVariant.DECIMAL1;
	            }
	                break;
	            }
	        }
	
	        String name = null;
	        int form = ComputeForm(unit, count, cv, multiple && last);
	        if (form == FORM_SINGULAR_SPELLED) {
	            if (dr.singularNames == null) {
	                form = FORM_SINGULAR;
	                name = dr.pluralNames[px][form];
	            } else {
	                name = dr.singularNames[px];
	            }
	        } else if (form == FORM_SINGULAR_NO_OMIT) {
	            name = dr.pluralNames[px][FORM_SINGULAR];
	        } else if (form == FORM_HALF_SPELLED) {
	            name = dr.halfNames[px];
	        } else {
	            try {
	                name = dr.pluralNames[px][form];
	            } catch (NullReferenceException e) {
	                System.Console.Out.WriteLine("Null Pointer in PeriodFormatterData["
	                        + localeName + "].au px: " + px + " form: " + form
	                        + " pn: " + dr.pluralNames);
	                throw e;
	            }
	        }
	        if (name == null) {
	            form = FORM_PLURAL;
	            name = dr.pluralNames[px][form];
	        }
	
	        bool omitCount = (form == FORM_SINGULAR_SPELLED || form == FORM_HALF_SPELLED)
	                || (dr.omitSingularCount && form == FORM_SINGULAR)
	                || (dr.omitDualCount && form == FORM_DUAL);
	
	        int suffixIndex = AppendCount(unit, omitCount, useDigitPrefix, count,
	                cv, useCountSep, name, last, sb);
	        if (last && suffixIndex >= 0) {
	            String suffix = null;
	            if (dr.rqdSuffixes != null && suffixIndex < dr.rqdSuffixes.Length) {
	                suffix = dr.rqdSuffixes[suffixIndex];
	            }
	            if (suffix == null && dr.optSuffixes != null
	                    && suffixIndex < dr.optSuffixes.Length) {
	                suffix = dr.optSuffixes[suffixIndex];
	            }
	            if (suffix != null) {
	                sb.Append(suffix);
	            }
	        }
	        return willRequireSkipMarker;
	    }
	
	    /// <summary>
	    /// Append a count to the string builder.
	    /// </summary>
	    ///
	    /// <param name="unit">the unit</param>
	    /// <param name="count">the count</param>
	    /// <param name="cv">the format to use for displaying the count</param>
	    /// <param name="useSep">whether to use the count separator, if available</param>
	    /// <param name="name">the term name</param>
	    /// <param name="last">true if this is the last unit to be formatted</param>
	    /// <param name="sb">the string builder to which to append the text</param>
	    /// <returns>index to use if might have required or optional suffix, or -1 if
	    /// none required</returns>
	    public int AppendCount(TimeUnit unit, bool omitCount,
	            bool useDigitPrefix, int count, int cv, bool useSep,
	            String name, bool last, StringBuilder sb) {
	        if (cv == IBM.ICU.Impl.Duration.Impl.DataRecord.ECountVariant.HALF_FRACTION && dr.halves == null) {
	            cv = IBM.ICU.Impl.Duration.Impl.DataRecord.ECountVariant.INTEGER;
	        }
	
	        if (!omitCount && useDigitPrefix && dr.digitPrefix != null) {
	            sb.Append(dr.digitPrefix);
	        }
	
	        int index = unit.Ordinal();
	        switch (cv) {
	        case IBM.ICU.Impl.Duration.Impl.DataRecord.ECountVariant.INTEGER: {
	            if (!omitCount) {
	                AppendInteger(count / 1000, 1, 10, sb);
	            }
	        }
	            break;
	
	        case IBM.ICU.Impl.Duration.Impl.DataRecord.ECountVariant.INTEGER_CUSTOM: {
	            int val = count / 1000;
	            // only custom names we have for now
	            if (unit == IBM.ICU.Impl.Duration.TimeUnit.MINUTE
	                    && (dr.fiveMinutes != null || dr.fifteenMinutes != null)) {
	                if (val != 0 && val % 5 == 0) {
	                    if (dr.fifteenMinutes != null && (val == 15 || val == 45)) {
	                        val = (val == 15) ? 1 : 3;
	                        if (!omitCount)
	                            AppendInteger(val, 1, 10, sb);
	                        name = dr.fifteenMinutes;
	                        index = 8; // hack
	                        break;
	                    }
	                    if (dr.fiveMinutes != null) {
	                        val = val / 5;
	                        if (!omitCount)
	                            AppendInteger(val, 1, 10, sb);
	                        name = dr.fiveMinutes;
	                        index = 9; // hack
	                        break;
	                    }
	                }
	            }
	            if (!omitCount)
	                AppendInteger(val, 1, 10, sb);
	        }
	            break;
	
	        case IBM.ICU.Impl.Duration.Impl.DataRecord.ECountVariant.HALF_FRACTION: {
	            // 0, 1/2, 1, 1-1/2...
	            int v = count / 500;
	            if (v != 1) {
	                if (!omitCount)
	                    AppendCountValue(count, 1, 0, sb);
	            }
	            if ((v & 0x1) == 1) {
	                // hack, using half name
	                if (v == 1 && dr.halfNames != null
	                        && dr.halfNames[index] != null) {
	                    sb.Append(name);
	                    return (last) ? index : -1;
	                }
	
	                int solox = (v == 1) ? 0 : 1;
	                if (dr.genders != null && dr.halves.Length > 2) {
	                    if (dr.genders[index] == IBM.ICU.Impl.Duration.Impl.DataRecord.EGender.F) {
	                        solox += 2;
	                    }
	                }
	                int hp = (dr.halfPlacements == null) ? IBM.ICU.Impl.Duration.Impl.DataRecord.EHalfPlacement.PREFIX
	                        : dr.halfPlacements[solox & 0x1];
	                String half = dr.halves[solox];
	                String measure = (dr.measures == null) ? null
	                        : dr.measures[index];
	                switch (hp) {
	                case IBM.ICU.Impl.Duration.Impl.DataRecord.EHalfPlacement.PREFIX:
	                    sb.Append(half);
	                    break;
	                case IBM.ICU.Impl.Duration.Impl.DataRecord.EHalfPlacement.AFTER_FIRST: {
	                    if (measure != null) {
	                        sb.Append(measure);
	                        sb.Append(half);
	                        if (useSep && !omitCount) {
	                            sb.Append(dr.countSep);
	                        }
	                        sb.Append(name);
	                    } else { // ignore sep completely
	                        sb.Append(name);
	                        sb.Append(half);
	                        return (last) ? index : -1; // might use suffix
	                    }
	                }
	                    return -1; // exit early
	                case IBM.ICU.Impl.Duration.Impl.DataRecord.EHalfPlacement.LAST: {
	                    if (measure != null) {
	                        sb.Append(measure);
	                    }
	                    if (useSep && !omitCount) {
	                        sb.Append(dr.countSep);
	                    }
	                    sb.Append(name);
	                    sb.Append(half);
	                }
	                    return (last) ? index : -1; // might use suffix
	                }
	            }
	        }
	            break;
	        default: {
	            int decimals = 1;
	            switch (cv) {
	            case IBM.ICU.Impl.Duration.Impl.DataRecord.ECountVariant.DECIMAL2:
	                decimals = 2;
	                break;
	            case IBM.ICU.Impl.Duration.Impl.DataRecord.ECountVariant.DECIMAL3:
	                decimals = 3;
	                break;
	            default:
	                break;
	            }
	            if (!omitCount)
	                AppendCountValue(count, 1, decimals, sb);
	        }
	            break;
	        }
	        if (!omitCount && useSep) {
	            sb.Append(dr.countSep);
	        }
	        if (!omitCount && dr.measures != null && index < dr.measures.Length) {
	            String measure_0 = dr.measures[index];
	            if (measure_0 != null) {
	                sb.Append(measure_0);
	            }
	        }
	        sb.Append(name);
	        return (last) ? index : -1;
	    }
	
	    /// <summary>
	    /// Append a count value to the builder.
	    /// </summary>
	    ///
	    /// <param name="count">the count</param>
	    /// <param name="integralDigits">the number of integer digits to display</param>
	    /// <param name="decimalDigits">the number of decimal digits to display, <= 3</param>
	    /// <param name="sb">the string builder to which to append the text</param>
	    public void AppendCountValue(int count, int integralDigits,
	            int decimalDigits, StringBuilder sb) {
	        int ival = count / 1000;
	        if (decimalDigits == 0) {
	            AppendInteger(ival, integralDigits, 10, sb);
	            return;
	        }
	
	        if (dr.requiresDigitSeparator && sb.Length > 0) {
	            sb.Append(' ');
	        }
	        AppendDigits(ival, integralDigits, 10, sb);
	        int dval = count % 1000;
	        if (decimalDigits == 1) {
	            dval /= 100;
	        } else if (decimalDigits == 2) {
	            dval /= 10;
	        }
	        sb.Append(dr.decimalSep);
	        AppendDigits(dval, decimalDigits, decimalDigits, sb);
	        if (dr.requiresDigitSeparator) {
	            sb.Append(' ');
	        }
	    }
	
	    public void AppendInteger(int num, int mindigits, int maxdigits,
	            StringBuilder sb) {
	        if (dr.numberNames != null && num < dr.numberNames.Length) {
	            String name = dr.numberNames[num];
	            if (name != null) {
	                sb.Append(name);
	                return;
	            }
	        }
	
	        if (dr.requiresDigitSeparator && sb.Length > 0) {
	            sb.Append(' ');
	        }
	        switch (dr.numberSystem) {
	        case IBM.ICU.Impl.Duration.Impl.DataRecord.ENumberSystem.DEFAULT:
	            AppendDigits(num, mindigits, maxdigits, sb);
	            break;
	        case IBM.ICU.Impl.Duration.Impl.DataRecord.ENumberSystem.CHINESE_TRADITIONAL:
	            sb.Append(IBM.ICU.Impl.Duration.Impl.Utils.ChineseNumber(num, IBM.ICU.Impl.Duration.Impl.Utils.ChineseDigits.TRADITIONAL));
	            break;
	        case IBM.ICU.Impl.Duration.Impl.DataRecord.ENumberSystem.CHINESE_SIMPLIFIED:
	            sb.Append(IBM.ICU.Impl.Duration.Impl.Utils.ChineseNumber(num, IBM.ICU.Impl.Duration.Impl.Utils.ChineseDigits.SIMPLIFIED));
	            break;
	        case IBM.ICU.Impl.Duration.Impl.DataRecord.ENumberSystem.KOREAN:
	            sb.Append(IBM.ICU.Impl.Duration.Impl.Utils.ChineseNumber(num, IBM.ICU.Impl.Duration.Impl.Utils.ChineseDigits.KOREAN));
	            break;
	        }
	        if (dr.requiresDigitSeparator) {
	            sb.Append(' ');
	        }
	    }
	
	    /// <summary>
	    /// Append digits to the string builder, using this.zero for '0' etc.
	    /// </summary>
	    ///
	    /// <param name="num">the integer to append</param>
	    /// <param name="mindigits">the minimum number of digits to append</param>
	    /// <param name="maxdigits">the maximum number of digits to append</param>
	    /// <param name="sb">the string builder to which to append the text</param>
	    public void AppendDigits(long num, int mindigits, int maxdigits,
	            StringBuilder sb) {
	        char[] buf = new char[maxdigits];
	        int ix = maxdigits;
	        while (ix > 0 && num > 0) {
	            buf[--ix] = (char) (dr.zero + (num % 10));
	            num /= 10;
	        }
	        for (int e = maxdigits - mindigits; ix > e;) {
	            buf[--ix] = dr.zero;
	        }
	        sb.Append(buf, ix, maxdigits - ix);
	    }
	
	    /// <summary>
	    /// Append a marker for skipped units internal to a string.
	    /// </summary>
	    ///
	    /// <param name="sb">the string builder to which to append the text</param>
	    public void AppendSkippedUnit(StringBuilder sb) {
	        if (dr.skippedUnitMarker != null) {
	            sb.Append(dr.skippedUnitMarker);
	        }
	    }
	
	    /// <summary>
	    /// Append the appropriate separator between units
	    /// </summary>
	    ///
	    /// <param name="unit">the unit to which to append the separator</param>
	    /// <param name="afterFirst">true if this is the first unit formatted</param>
	    /// <param name="beforeLast">true if this is the next-to-last unit to be formatted</param>
	    /// <param name="sb">the string builder to which to append the text</param>
	    /// <returns>true if a prefix will be required before a following unit</returns>
	    public bool AppendUnitSeparator(TimeUnit unit, bool longSep,
	            bool afterFirst, bool beforeLast, StringBuilder sb) {
	        // long seps
	        // false, false "...b', '...d"
	        // false, true "...', and 'c"
	        // true, false - "a', '...c"
	        // true, true - "a' and 'b"
	        if ((longSep && dr.unitSep != null) || dr.shortUnitSep != null) {
	            if (longSep && dr.unitSep != null) {
	                int ix = ((afterFirst) ? 2 : 0) + ((beforeLast) ? 1 : 0);
	                sb.Append(dr.unitSep[ix]);
	                return dr.unitSepRequiresDP != null && dr.unitSepRequiresDP[ix];
	            }
	            sb.Append(dr.shortUnitSep); // todo: investigate whether DP is
	                                        // required
	        }
	        return false;
	    }
	
	    private const int FORM_PLURAL = 0, FORM_SINGULAR = 1, FORM_DUAL = 2,
	            FORM_PAUCAL = 3, FORM_SINGULAR_SPELLED = 4, // following are not in
	                                                        // the pluralization
	                                                        // list
	            FORM_SINGULAR_NO_OMIT = 5, // a hack
	            FORM_HALF_SPELLED = 6;
	
	    private int ComputeForm(TimeUnit unit, int count, int cv,
	            bool lastOfMultiple) {
	        // first check if a particular form is forced by the countvariant. if
	        // SO, just return that. otherwise convert the count to an integer
	        // and use pluralization rules to determine which form to use.
	        // careful, can't assume any forms but plural exist.
	
	        if (trace) {
	            System.Console.Error.WriteLine("pfd.cf unit: " + unit + " count: " + count
	                    + " cv: " + cv + " dr.pl: " + dr.pl);
	            ILOG.J2CsMapping.Threading.ThreadWrapper.DumpStack();
	        }
	        if (dr.pl == IBM.ICU.Impl.Duration.Impl.DataRecord.EPluralization.NONE) {
	            return FORM_PLURAL;
	        }
	        // otherwise, assume we have at least a singular and plural form
	
	        int val = count / 1000;
	
	        switch (cv) {
	        case IBM.ICU.Impl.Duration.Impl.DataRecord.ECountVariant.INTEGER:
	        case IBM.ICU.Impl.Duration.Impl.DataRecord.ECountVariant.INTEGER_CUSTOM: {
	            // do more analysis based on floor of count
	        }
	            break;
	        case IBM.ICU.Impl.Duration.Impl.DataRecord.ECountVariant.HALF_FRACTION: {
	            switch (dr.fractionHandling) {
	            case IBM.ICU.Impl.Duration.Impl.DataRecord.EFractionHandling.FPLURAL:
	                return FORM_PLURAL;
	
	            case IBM.ICU.Impl.Duration.Impl.DataRecord.EFractionHandling.FSINGULAR_PLURAL_ANDAHALF:
	            case IBM.ICU.Impl.Duration.Impl.DataRecord.EFractionHandling.FSINGULAR_PLURAL: {
	                // if half-floor is 1/2, use singular
	                // else if half-floor is not integral, use plural
	                // else do more analysis
	                int v = (int) (count / 500);
	                if (v == 1) {
	                    if (dr.halfNames != null
	                            && dr.halfNames[unit.Ordinal()] != null) {
	                        return FORM_HALF_SPELLED;
	                    }
	                    return FORM_SINGULAR_NO_OMIT;
	                }
	                if ((v & 0x1) == 1) {
	                    if (dr.pl == IBM.ICU.Impl.Duration.Impl.DataRecord.EPluralization.ARABIC && v > 21) { // hack
	                        return FORM_SINGULAR_NO_OMIT;
	                    }
	                    if (v == 3
	                            && dr.pl == IBM.ICU.Impl.Duration.Impl.DataRecord.EPluralization.PLURAL
	                            && dr.fractionHandling != IBM.ICU.Impl.Duration.Impl.DataRecord.EFractionHandling.FSINGULAR_PLURAL_ANDAHALF) {
	                        return FORM_PLURAL;
	                    }
	                }
	
	                // it will display like an integer, so do more analysis
	            }
	                break;
	
	            case IBM.ICU.Impl.Duration.Impl.DataRecord.EFractionHandling.FPAUCAL: {
	                int v_0 = (int) (count / 500);
	                if (v_0 == 1 || v_0 == 3) {
	                    return FORM_PAUCAL;
	                }
	                // else use integral form
	            }
	                break;
	
	            default:
	                throw new InvalidOperationException();
	            }
	        }
	            break;
	        default: { // for all decimals
	            switch (dr.decimalHandling) {
	            case IBM.ICU.Impl.Duration.Impl.DataRecord.EDecimalHandling.DPLURAL:
	                break;
	            case IBM.ICU.Impl.Duration.Impl.DataRecord.EDecimalHandling.DSINGULAR:
	                return FORM_SINGULAR_NO_OMIT;
	            case IBM.ICU.Impl.Duration.Impl.DataRecord.EDecimalHandling.DSINGULAR_SUBONE:
	                if (count < 1000) {
	                    return FORM_SINGULAR_NO_OMIT;
	                }
	                break;
	            case IBM.ICU.Impl.Duration.Impl.DataRecord.EDecimalHandling.DPAUCAL:
	                if (dr.pl == IBM.ICU.Impl.Duration.Impl.DataRecord.EPluralization.PAUCAL) {
	                    return FORM_PAUCAL;
	                }
	                break;
	            default:
	                break;
	            }
	            return FORM_PLURAL;
	        }
	        }
	
	        // select among pluralization forms
	        if (trace && count == 0) {
	            System.Console.Error.WriteLine("EZeroHandling = " + dr.zeroHandling);
	        }
	        if (count == 0 && dr.zeroHandling == IBM.ICU.Impl.Duration.Impl.DataRecord.EZeroHandling.ZSINGULAR) {
	            return FORM_SINGULAR_SPELLED;
	        }
	
	        int form = FORM_PLURAL;
	        switch (dr.pl) {
	        case IBM.ICU.Impl.Duration.Impl.DataRecord.EPluralization.NONE:
	            break; // never get here
	        case IBM.ICU.Impl.Duration.Impl.DataRecord.EPluralization.PLURAL: {
	            if (val == 1) {
	                form = FORM_SINGULAR_SPELLED; // defaults to form_singular if no
	                                              // spelled forms
	            }
	        }
	            break;
	        case IBM.ICU.Impl.Duration.Impl.DataRecord.EPluralization.DUAL: {
	            if (val == 2) {
	                form = FORM_DUAL;
	            } else if (val == 1) {
	                form = FORM_SINGULAR;
	            }
	        }
	            break;
	        case IBM.ICU.Impl.Duration.Impl.DataRecord.EPluralization.PAUCAL: {
	            int v_1 = val;
	            v_1 = v_1 % 100;
	            if (v_1 > 20) {
	                v_1 = v_1 % 10;
	            }
	            if (v_1 == 1) {
	                form = FORM_SINGULAR;
	            } else if (v_1 > 1 && v_1 < 5) {
	                form = FORM_PAUCAL;
	            }
	        }
	            break;
	        /*
	         * case EPluralization.RPT_DUAL_FEW: { int v = val; if (v > 20) { v = v
	         * % 10; } if (v == 1) { form = FORM_SINGULAR; } else if (v == 2) { form
	         * = FORM_DUAL; } else if (v > 2 && v < 5) { form = FORM_PAUCAL; } }
	         * break;
	         */
	        case IBM.ICU.Impl.Duration.Impl.DataRecord.EPluralization.HEBREW: {
	            if (val == 2) {
	                form = FORM_DUAL;
	            } else if (val == 1) {
	                if (lastOfMultiple) {
	                    form = FORM_SINGULAR_SPELLED;
	                } else {
	                    form = FORM_SINGULAR;
	                }
	            } else if (unit == IBM.ICU.Impl.Duration.TimeUnit.YEAR && val > 11) {
	                form = FORM_SINGULAR_NO_OMIT;
	            }
	        }
	            break;
	        case IBM.ICU.Impl.Duration.Impl.DataRecord.EPluralization.ARABIC: {
	            if (val == 2) {
	                form = FORM_DUAL;
	            } else if (val == 1) {
	                form = FORM_SINGULAR;
	            } else if (val > 10) {
	                form = FORM_SINGULAR_NO_OMIT;
	            }
	        }
	            break;
	        default:
	            System.Console.Error.WriteLine("dr.pl is " + dr.pl);
	            throw new InvalidOperationException();
	        }
	
	        return form;
	    }
	}
}
