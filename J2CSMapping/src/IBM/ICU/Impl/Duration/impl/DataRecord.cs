/*
 ******************************************************************************
 * Copyright (C) 2007, International Business Machines Corporation and   *
 * others. All Rights Reserved.                                               *
 ******************************************************************************
 */

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/8/10 10:24 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Impl.Duration.Impl {
	
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	
	/// <summary>
	/// DataRecord contains the data used by PeriodFormatterData. Fields are
	/// package-private for ease of access. This is a struct, it knows how to read
	/// and write itself to/from simple XML, that's all.
	/// </summary>
	///
	public class DataRecord {
	    internal sbyte pl;
	
	    internal String[][] pluralNames;
	
	    internal sbyte[] genders; // EGender
	
	    internal String[] singularNames;
	
	    internal String[] halfNames;
	
	    internal String[] numberNames;
	
	    internal String[] mediumNames;
	
	    internal String[] shortNames;
	
	    internal String[] measures;
	
	    internal String[] rqdSuffixes;
	
	    internal String[] optSuffixes;
	
	    internal String[] halves;
	
	    internal sbyte[] halfPlacements; // EHalfPlacement
	
	    internal sbyte[] halfSupport; // EHalfSupport
	
	    internal String fifteenMinutes;
	
	    internal String fiveMinutes;
	
	    internal bool requiresDigitSeparator;
	
	    internal String digitPrefix;
	
	    internal String countSep;
	
	    internal String shortUnitSep;
	
	    internal String[] unitSep;
	
	    internal bool[] unitSepRequiresDP;
	
	    internal bool[] requiresSkipMarker;
	
	    internal sbyte numberSystem; // ENumberSystem
	
	    internal char zero;
	
	    internal char decimalSep;
	
	    internal bool omitSingularCount;
	
	    internal bool omitDualCount;
	
	    internal sbyte zeroHandling; // EZeroHandling
	
	    internal sbyte decimalHandling; // EDecimalHandling
	
	    internal sbyte fractionHandling; // EFractionHandling
	
	    internal String skippedUnitMarker;
	
	    internal bool allowZero;
	
	    internal bool weeksAloneOnly;
	
	    internal sbyte useMilliseconds; // EMilliSupport
	
	    internal DataRecord.ScopeData [] scopeData;
	
	    public static DataRecord Read(String ln, RecordReader ins0) {
	        if (ins0.Open("DataRecord")) {
	            DataRecord record = new DataRecord();
	            record.pl = ins0.NamedIndex("pl", IBM.ICU.Impl.Duration.Impl.DataRecord.EPluralization.names);
	            record.pluralNames = ins0.StringTable("pluralName");
	            record.genders = ins0.NamedIndexArray("gender", IBM.ICU.Impl.Duration.Impl.DataRecord.EGender.names);
	            record.singularNames = ins0.StringArray("singularName");
	            record.halfNames = ins0.StringArray("halfName");
	            record.numberNames = ins0.StringArray("numberName");
	            record.mediumNames = ins0.StringArray("mediumName");
	            record.shortNames = ins0.StringArray("shortName");
	            record.measures = ins0.StringArray("measure");
	            record.rqdSuffixes = ins0.StringArray("rqdSuffix");
	            record.optSuffixes = ins0.StringArray("optSuffix");
	            record.halves = ins0.StringArray("halves");
	            record.halfPlacements = ins0.NamedIndexArray("halfPlacement",
	                    IBM.ICU.Impl.Duration.Impl.DataRecord.EHalfPlacement.names);
	            record.halfSupport = ins0.NamedIndexArray("halfSupport",
	                    IBM.ICU.Impl.Duration.Impl.DataRecord.EHalfSupport.names);
	            record.fifteenMinutes = ins0.String("fifteenMinutes");
	            record.fiveMinutes = ins0.String("fiveMinutes");
	            record.requiresDigitSeparator = ins0.Bool("requiresDigitSeparator");
	            record.digitPrefix = ins0.String("digitPrefix");
	            record.countSep = ins0.String("countSep");
	            record.shortUnitSep = ins0.String("shortUnitSep");
	            record.unitSep = ins0.StringArray("unitSep");
	            record.unitSepRequiresDP = ins0.BoolArray("unitSepRequiresDP");
	            record.requiresSkipMarker = ins0.BoolArray("requiresSkipMarker");
	            record.numberSystem = ins0.NamedIndex("numberSystem",
	                    IBM.ICU.Impl.Duration.Impl.DataRecord.ENumberSystem.names);
	            record.zero = ins0.Character("zero");
	            record.decimalSep = ins0.Character("decimalSep");
	            record.omitSingularCount = ins0.Bool("omitSingularCount");
	            record.omitDualCount = ins0.Bool("omitDualCount");
	            record.zeroHandling = ins0.NamedIndex("zeroHandling",
	                    IBM.ICU.Impl.Duration.Impl.DataRecord.EZeroHandling.names);
	            record.decimalHandling = ins0.NamedIndex("decimalHandling",
	                    IBM.ICU.Impl.Duration.Impl.DataRecord.EDecimalHandling.names);
	            record.fractionHandling = ins0.NamedIndex("fractionHandling",
	                    IBM.ICU.Impl.Duration.Impl.DataRecord.EFractionHandling.names);
	            record.skippedUnitMarker = ins0.String("skippedUnitMarker");
	            record.allowZero = ins0.Bool("allowZero");
	            record.weeksAloneOnly = ins0.Bool("weeksAloneOnly");
	            record.useMilliseconds = ins0.NamedIndex("useMilliseconds",
	                    IBM.ICU.Impl.Duration.Impl.DataRecord.EMilliSupport.names);
	            if (ins0.Open("ScopeDataList")) {
	                IList list = new ArrayList(); // of ScopeData
	                DataRecord.ScopeData  data;
	                while (null != (data = IBM.ICU.Impl.Duration.Impl.DataRecord.ScopeData.Read(ins0))) {
	                    ILOG.J2CsMapping.Collections.Generics.Collections.Add(list,data);
	                }
	                if (ins0.Close()) {
	                    record.scopeData = (DataRecord.ScopeData []) ILOG.J2CsMapping.Collections.Collections.ToArray(list,new DataRecord.ScopeData [list.Count]);
	                }
	            }
	
	            if (ins0.Close()) {
	                return record;
	            }
	        } else {
	            throw new Exception("did not find DataRecord while reading "
	                    + ln);
	        }
            throw new Exception("null data read while reading " + ln);
	        // Thread.dumpStack();
	        // return null;
	    }
	
	    public void Write(RecordWriter xout) {
	        xout.Open("DataRecord");
	        xout.NamedIndex("pl", IBM.ICU.Impl.Duration.Impl.DataRecord.EPluralization.names, pl);
	        xout.StringTable("pluralName", pluralNames);
	        xout.NamedIndexArray("gender", IBM.ICU.Impl.Duration.Impl.DataRecord.EGender.names, genders);
	        xout.StringArray("singularName", singularNames);
	        xout.StringArray("halfName", halfNames);
	        xout.StringArray("numberName", numberNames);
	        xout.StringArray("mediumName", mediumNames);
	        xout.StringArray("shortName", shortNames);
	        xout.StringArray("measure", measures);
	        xout.StringArray("rqdSuffix", rqdSuffixes);
	        xout.StringArray("optSuffix", optSuffixes);
	        xout.StringArray("halves", halves);
	        xout.NamedIndexArray("halfPlacement", IBM.ICU.Impl.Duration.Impl.DataRecord.EHalfPlacement.names,
	                halfPlacements);
	        xout.NamedIndexArray("halfSupport", IBM.ICU.Impl.Duration.Impl.DataRecord.EHalfSupport.names, halfSupport);
	        xout.String("fifteenMinutes", fifteenMinutes);
	        xout.String("fiveMinutes", fiveMinutes);
	        xout.Bool("requiresDigitSeparator", requiresDigitSeparator);
	        xout.String("digitPrefix", digitPrefix);
	        xout.String("countSep", countSep);
	        xout.String("shortUnitSep", shortUnitSep);
	        xout.StringArray("unitSep", unitSep);
	        xout.BoolArray("unitSepRequiresDP", unitSepRequiresDP);
	        xout.BoolArray("requiresSkipMarker", requiresSkipMarker);
	        xout.NamedIndex("numberSystem", IBM.ICU.Impl.Duration.Impl.DataRecord.ENumberSystem.names, numberSystem);
	        xout.Character("zero", zero);
	        xout.Character("decimalSep", decimalSep);
	        xout.Bool("omitSingularCount", omitSingularCount);
	        xout.Bool("omitDualCount", omitDualCount);
	        xout.NamedIndex("zeroHandling", IBM.ICU.Impl.Duration.Impl.DataRecord.EZeroHandling.names, zeroHandling);
	        xout.NamedIndex("decimalHandling", IBM.ICU.Impl.Duration.Impl.DataRecord.EDecimalHandling.names,
	                decimalHandling);
	        xout.NamedIndex("fractionHandling", IBM.ICU.Impl.Duration.Impl.DataRecord.EFractionHandling.names,
	                fractionHandling);
	        xout.String("skippedUnitMarker", skippedUnitMarker);
	        xout.Bool("allowZero", allowZero);
	        xout.Bool("weeksAloneOnly", weeksAloneOnly);
	        xout.NamedIndex("useMilliseconds", IBM.ICU.Impl.Duration.Impl.DataRecord.EMilliSupport.names, useMilliseconds);
	        if (scopeData != null) {
	            xout.Open("ScopeDataList");
	            for (int i = 0; i < scopeData.Length; ++i) {
	                scopeData[i].Write(xout);
	            }
	            xout.Close();
	        }
	        xout.Close();
	    }
	
	    public class ScopeData {
	        internal String prefix;
	
	        internal bool requiresDigitPrefix;
	
	        internal String suffix;
	
	        public void Write(RecordWriter xout) {
	            xout.Open("ScopeData");
	            xout.String("prefix", prefix);
	            xout.Bool("requiresDigitPrefix", requiresDigitPrefix);
	            xout.String("suffix", suffix);
	            xout.Close();
	        }
	
	        public static DataRecord.ScopeData  Read(RecordReader ins0) {
	            if (ins0.Open("ScopeData")) {
	                DataRecord.ScopeData  scope = new DataRecord.ScopeData ();
	                scope.prefix = ins0.String("prefix");
	                scope.requiresDigitPrefix = ins0.Bool("requiresDigitPrefix");
	                scope.suffix = ins0.String("suffix");
	                if (ins0.Close()) {
	                    return scope;
	                }
	            }
	            return null;
	        }
	    }
	
	    public class ETimeLimit {
	        public const byte NOLIMIT = 0;

            public const byte LT = 1;

            public const byte MT = 2;

            public static String[] names = { "NOLIMIT", "LT", "MT" };
	    }

        public class ETimeDirection
        {
            public const byte NODIRECTION = 0;

            public const byte PAST = 1;

            public const byte FUTURE = 2;

            public static String[] names = { "NODIRECTION", "PAST", "FUTURE" };
	    }

        public class EUnitVariant
        {
            public const byte PLURALIZED = 0;

            public const byte MEDIUM = 1;

            public const byte SHORT = 2;

            public static String[] names = { "PLURALIZED", "MEDIUM", "SHORT" };
	    }

        public class ECountVariant
        {
            public const byte INTEGER = 0;

            public const byte INTEGER_CUSTOM = 1;

            public const byte HALF_FRACTION = 2;

            public const byte DECIMAL1 = 3;

            public const byte DECIMAL2 = 4;

            public const byte DECIMAL3 = 5;

            public static String[] names = { "INTEGER", "INTEGER_CUSTOM",
	                "HALF_FRACTION", "DECIMAL1", "DECIMAL2", "DECIMAL3" };
	    }

        public class EPluralization
        {
            public const sbyte NONE = 0;

            public const sbyte PLURAL = 1;

            public const sbyte DUAL = 2;

            public const sbyte PAUCAL = 3;

            public const sbyte HEBREW = 4;

            public const sbyte ARABIC = 5;

            public static String[] names = { "NONE", "PLURAL", "DUAL",
	                "PAUCAL", "HEBREW", "ARABIC" };
	    }

        public class EHalfPlacement
        {
            public const sbyte PREFIX = 0;

            public const sbyte AFTER_FIRST = 1;

            public const sbyte LAST = 2;

            public static String[] names = { "PREFIX", "AFTER_FIRST", "LAST" };
	    }

        public class ENumberSystem
        {
            public const sbyte DEFAULT = 0;

            public const sbyte CHINESE_TRADITIONAL = 1;

            public const sbyte CHINESE_SIMPLIFIED = 2;

            public const sbyte KOREAN = 3;

            public static String[] names = { "DEFAULT",
	                "CHINESE_TRADITIONAL", "CHINESE_SIMPLIFIED", "KOREAN" };
	    }

        public class EZeroHandling
        {
            public const byte ZPLURAL = 0;

            public const byte ZSINGULAR = 1;

            public static String[] names = { "ZPLURAL", "ZSINGULAR" };
	    }

        public class EDecimalHandling
        {
            public const sbyte DPLURAL = 0;

            public const sbyte DSINGULAR = 1;

            public const sbyte DSINGULAR_SUBONE = 2;

            public const sbyte DPAUCAL = 3;

            public static String[] names = { "DPLURAL", "DSINGULAR",
	                "DSINGULAR_SUBONE", "DPAUCAL" };
	    }

        public class EFractionHandling
        {
            public const sbyte FPLURAL = 0;

            public const sbyte FSINGULAR_PLURAL = 1;

            public const sbyte FSINGULAR_PLURAL_ANDAHALF = 2;

            public const sbyte FPAUCAL = 3;

            public static String[] names = { "FPLURAL", "FSINGULAR_PLURAL",
	                "FSINGULAR_PLURAL_ANDAHALF", "FPAUCAL" };
	    }

        public class EHalfSupport
        {
	        public const sbyte YES = 0;

            public const sbyte NO = 1;

            public const sbyte ONE_PLUS = 2;

            public static String[] names = { "YES", "NO", "ONE_PLUS" };
	    }

        public class EMilliSupport
        {
            public const byte YES = 0;

            public const byte NO = 1;

            public const byte WITH_SECONDS = 2;

            public static String[] names = { "YES", "NO", "WITH_SECONDS" };
	    }

        public class ESeparatorVariant
        {
            public const byte NONE = 0;

            public const byte SHORT = 1;

            public const byte FULL = 2;

            public static String[] names = { "NONE", "SHORT", "FULL" };
	    }

        public class EGender
        {
            public const byte M = 0;

            public const byte F = 1;

            public const byte N = 2;

            public static String[] names = { "M", "F", "N" };
	    }
	}
}
