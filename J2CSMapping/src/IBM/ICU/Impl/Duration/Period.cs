/*
 ******************************************************************************
 * Copyright (C) 2007, International Business Machines Corporation and   *
 * others. All Rights Reserved.                                               *
 ******************************************************************************
 */

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/8/10 10:24 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Impl.Duration {
	
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	
	
	/// <summary>
	/// Represents an approximate duration in multiple TimeUnits. Each unit, if set,
	/// has a count (which can be fractional and must be non-negative). In addition
	/// Period can either represent the duration as being into the past or future,
	/// and as being more or less than the defined value.
	/// <p>
	/// Use a PeriodFormatter to convert a Period to a String.
	/// <p>
	/// Periods are immutable. Mutating operations return the new result leaving the
	/// original unchanged.
	/// <p>
	/// Example:
	/// <pre>
	/// Period p1 = Period.at(3, WEEK).and(2, DAY).inFuture();
	/// Period p2 = p1.and(12, HOUR);
	/// </pre>
	/// </summary>
	///
	public sealed class Period {
	    internal readonly byte timeLimit;
	
	    internal readonly bool inFuture;
	
	    internal readonly int[] counts;
	
	    /// <summary>
	    /// Constructs a Period representing a duration of count units extending into
	    /// the past.
	    /// </summary>
	    ///
	    /// <param name="count">the number of units, must be non-negative</param>
	    /// <param name="unit">the unit</param>
	    /// <returns>the new Period</returns>
	    public static Period At(float count, TimeUnit unit) {
	        CheckCount(count);
	        return new Period(IBM.ICU.Impl.Duration.Impl.DataRecord.ETimeLimit.NOLIMIT, false, count, unit);
	    }
	
	    /// <summary>
	    /// Constructs a Period representing a duration more than count units
	    /// extending into the past.
	    /// </summary>
	    ///
	    /// <param name="count">the number of units. must be non-negative</param>
	    /// <param name="unit">the unit</param>
	    /// <returns>the new Period</returns>
	    public static Period MoreThan(float count, TimeUnit unit) {
	        CheckCount(count);
	        return new Period(IBM.ICU.Impl.Duration.Impl.DataRecord.ETimeLimit.MT, false, count, unit);
	    }
	
	    /// <summary>
	    /// Constructs a Period representing a duration less than count units
	    /// extending into the past.
	    /// </summary>
	    ///
	    /// <param name="count">the number of units. must be non-negative</param>
	    /// <param name="unit">the unit</param>
	    /// <returns>the new Period</returns>
	    public static Period LessThan(float count, TimeUnit unit) {
	        CheckCount(count);
	        return new Period(IBM.ICU.Impl.Duration.Impl.DataRecord.ETimeLimit.LT, false, count, unit);
	    }
	
	    /// <summary>
	    /// Set the given unit to have the given count. Marks the unit as having been
	    /// set. This can be used to set multiple units, or to reset a unit to have a
	    /// new count. This does <b>not</b> add the count to an existing count for
	    /// this unit.
	    /// </summary>
	    ///
	    /// <param name="count">the number of units. must be non-negative</param>
	    /// <param name="unit">the unit</param>
	    /// <returns>the new Period</returns>
	    public Period And(float count, TimeUnit unit) {
	        CheckCount(count);
	        return SetTimeUnitValue(unit, count);
	    }
	
	    /// <summary>
	    /// Mark the given unit as not being set.
	    /// </summary>
	    ///
	    /// <param name="unit">the unit to unset</param>
	    /// <returns>the new Period</returns>
	    public Period Omit(TimeUnit unit) {
	        return SetTimeUnitInternalValue(unit, 0);
	    }
	
	    /// <summary>
	    /// Mark the duration as being at the defined duration.
	    /// </summary>
	    ///
	    /// <returns>the new Period</returns>
	    public Period At() {
	        return SetTimeLimit(IBM.ICU.Impl.Duration.Impl.DataRecord.ETimeLimit.NOLIMIT);
	    }
	
	    /// <summary>
	    /// Mark the duration as being more than the defined duration.
	    /// </summary>
	    ///
	    /// <returns>the new Period</returns>
	    public Period MoreThan() {
	        return SetTimeLimit(IBM.ICU.Impl.Duration.Impl.DataRecord.ETimeLimit.MT);
	    }
	
	    /// <summary>
	    /// Mark the duration as being less than the defined duration.
	    /// </summary>
	    ///
	    /// <returns>the new Period</returns>
	    public Period LessThan() {
	        return SetTimeLimit(IBM.ICU.Impl.Duration.Impl.DataRecord.ETimeLimit.LT);
	    }
	
	    /// <summary>
	    /// Mark the time as being in the future.
	    /// </summary>
	    ///
	    /// <returns>the new Period</returns>
	    public Period InFuture() {
	        return SetFuture(true);
	    }
	
	    /// <summary>
	    /// Mark the duration as extending into the past.
	    /// </summary>
	    ///
	    /// <returns>the new Period</returns>
	    public Period InPast() {
	        return SetFuture(false);
	    }
	
	    /// <summary>
	    /// Mark the duration as extending into the future if future is true, and
	    /// into the past otherwise.
	    /// </summary>
	    ///
	    /// <param name="future">true if the time is in the future</param>
	    /// <returns>the new Period</returns>
	    public Period InFuture(bool future) {
	        return SetFuture(future);
	    }
	
	    /// <summary>
	    /// Mark the duration as extending into the past if past is true, and into
	    /// the future otherwise.
	    /// </summary>
	    ///
	    /// <param name="past">true if the time is in the past</param>
	    /// <returns>the new Period</returns>
	    public Period InPast(bool past) {
	        return SetFuture(!past);
	    }
	
	    /// <summary>
	    /// Returns true if any unit is set.
	    /// </summary>
	    ///
	    /// <returns>true if any unit is set</returns>
	    public bool IsSet() {
	        for (int i = 0; i < counts.Length; ++i) {
	            if (counts[i] != 0) {
	                return true;
	            }
	        }
	        return false;
	    }
	
	    /// <summary>
	    /// Returns true if the given unit is set.
	    /// </summary>
	    ///
	    /// <param name="unit">the unit to test</param>
	    /// <returns>true if the given unit is set.</returns>
	    public bool IsSet(TimeUnit unit) {
	        return counts[unit.ordinal] > 0;
	    }
	
	    /// <summary>
	    /// Returns the count for the specified unit. If the unit is not set, returns
	    /// 0.
	    /// </summary>
	    ///
	    /// <param name="unit">the unit to test</param>
	    /// <returns>the count</returns>
	    public float GetCount(TimeUnit unit) {
	        int ord = unit.ordinal;
	        if (counts[ord] == 0) {
	            return 0;
	        }
	        return (counts[ord] - 1) / 1000f;
	    }
	
	    /// <summary>
	    /// Returns true if this represents a duration into the future.
	    /// </summary>
	    ///
	    /// <returns>true if this represents a duration into the future.</returns>
	    public bool IsInFuture() {
	        return inFuture;
	    }
	
	    /// <summary>
	    /// Returns true if this represents a duration into the past
	    /// </summary>
	    ///
	    /// <returns>true if this represents a duration into the past</returns>
	    public bool IsInPast() {
	        return !inFuture;
	    }
	
	    /// <summary>
	    /// Returns true if this represents a duration in excess of the defined
	    /// duration.
	    /// </summary>
	    ///
	    /// <returns>true if this represents a duration in excess of the defined
	    /// duration.</returns>
	    public bool IsMoreThan() {
	        return timeLimit == IBM.ICU.Impl.Duration.Impl.DataRecord.ETimeLimit.MT;
	    }
	
	    /// <summary>
	    /// Returns true if this represents a duration less than the defined
	    /// duration.
	    /// </summary>
	    ///
	    /// <returns>true if this represents a duration less than the defined
	    /// duration.</returns>
	    public bool IsLessThan() {
	        return timeLimit == IBM.ICU.Impl.Duration.Impl.DataRecord.ETimeLimit.LT;
	    }
	
	    /// <summary>
	    /// Returns true if rhs extends Period and the two Periods are equal.
	    /// </summary>
	    ///
	    /// <param name="rhs">the object to compare to</param>
	    /// <returns>true if rhs is a Period and is equal to this</returns>
	    public override bool Equals(Object rhs) {
	        try {
	            return Equals((Period) rhs);
	        } catch (InvalidCastException e) {
	            return false;
	        }
	    }
	
	    /// <summary>
	    /// Returns true if the same units are defined with the same counts, both
	    /// extend into the future or both into the past, and if the limits (at, more
	    /// than, less than) are the same. Note that this means that a period of
	    /// 1000ms and a period of 1sec will not compare equal.
	    /// </summary>
	    ///
	    /// <param name="rhs">the period to compare to</param>
	    /// <returns>true if the two periods are equal</returns>
	    public bool Equals(Period rhs) {
	        if (rhs != null && this.timeLimit == rhs.timeLimit
	                && this.inFuture == rhs.inFuture) {
	            for (int i = 0; i < counts.Length; ++i) {
	                if (counts[i] != rhs.counts[i]) {
	                    return false;
	                }
	            }
	            return true;
	        }
	        return false;
	    }
	
	    /// <summary>
	    /// Returns the hashCode.
	    /// </summary>
	    ///
	    /// <returns>the hashCode</returns>
	    public override int GetHashCode() {
	        int hc = (timeLimit << 1) | ((inFuture) ? 1 : 0);
	        for (int i = 0; i < counts.Length; ++i) {
	            hc = (hc << 2) ^ counts[i];
	        }
	        return hc;
	    }
	
	    /// <summary>
	    /// Private constructor used by static factory methods.
	    /// </summary>
	    ///
	    private Period(int limit, bool future, float count, TimeUnit unit) {
	        this.timeLimit = (byte) limit;
	        this.inFuture = future;
	        this.counts = new int[TimeUnit.units.Length];
	        this.counts[unit.ordinal] = (int) (count * 1000) + 1;
	    }
	
	    /// <summary>
	    /// Package private constructor used by setters and factory.
	    /// </summary>
	    ///
	    internal Period(int timeLimit_0, bool inFuture_1, int[] counts_2) {
	        this.timeLimit = (byte) timeLimit_0;
	        this.inFuture = inFuture_1;
	        this.counts = counts_2;
	    }
	
	    /// <summary>
	    /// Set the unit's internal value, converting from float to int.
	    /// </summary>
	    ///
	    private Period SetTimeUnitValue(TimeUnit unit, float value_ren) {
	        if (value_ren < 0) {
	            throw new ArgumentException("value: " + value_ren);
	        }
	        return SetTimeUnitInternalValue(unit, (int) (value_ren * 1000) + 1);
	    }
	
	    /// <summary>
	    /// Sets the period to have the provided value, 1/1000 of the unit plus 1.
	    /// Thus unset values are '0', 1' is the set value '0', 2 is the set value
	    /// '1/1000', 3 is the set value '2/1000' etc.
	    /// </summary>
	    ///
	    /// <param name="p">the period to change</param>
	    /// <param name="value">the int value as described above.</param>
	    /// @eturn the new Period object.
	    private Period SetTimeUnitInternalValue(TimeUnit unit, int value_ren) {
	        int ord = unit.ordinal;
	        if (counts[ord] != value_ren) {
	            int[] newCounts = new int[counts.Length];
	            for (int i = 0; i < counts.Length; ++i) {
	                newCounts[i] = counts[i];
	            }
	            newCounts[ord] = value_ren;
	            return new Period(timeLimit, inFuture, newCounts);
	        }
	        return this;
	    }
	
	    /// <summary>
	    /// Sets whether this defines a future time.
	    /// </summary>
	    ///
	    /// <param name="future">true if the time is in the future</param>
	    /// <returns>the new Period</returns>
	    private Period SetFuture(bool future) {
	        if (this.inFuture != future) {
	            return new Period(timeLimit, future, counts);
	        }
	        return this;
	    }
	
	    /// <summary>
	    /// Sets whether this is more than, less than, or 'about' the specified time.
	    /// </summary>
	    ///
	    /// <param name="limit">the kind of limit</param>
	    /// <returns>the new Period</returns>
	    private Period SetTimeLimit(byte limit) {
	        if (this.timeLimit != limit) {
	            return new Period(limit, inFuture, counts);
	
	        }
	        return this;
	    }
	
	    /// <summary>
	    /// Validate count.
	    /// </summary>
	    ///
	    private static void CheckCount(float count) {
	        if (count < 0) {
	            throw new ArgumentException("count (" + count
	                    + ") cannot be negative");
	        }
	    }
	}
}
