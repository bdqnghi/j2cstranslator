//##header J2SE15
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:47 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2004-2007, International Business Machines Corporation and    
/// others. All Rights Reserved.                                                
/// </summary>
///
namespace IBM.ICU.Impl {
	
	using IBM.ICU.Util;
	using ILOG.J2CsMapping.NIO;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Reflection;
	using System.Resources;
	using System.Runtime.CompilerServices;
	
	internal class ICUResourceBundleImpl {
	
	    internal sealed class ResourceArray : ICUResourceBundle {
	        protected internal override String[] HandleGetStringArray() {
	            String[] strings = new String[size];
	            UResourceBundleIterator iter = GetIterator();
	            int i = 0;
	            while (iter.HasNext()) {
	                strings[i++] = iter.Next().GetString();
	            }
	            return strings;
	        }
	
	        /// <exclude/>
	        public override String[] GetStringArray() {
	            return HandleGetStringArray();
	        }
	
	        protected internal override UResourceBundle HandleGet(String index, Hashtable table,
	                UResourceBundle requested) {
	            int val = IBM.ICU.Impl.ICUResourceBundle.GetIndex(index);
	            if (val > -1) {
	                return HandleGet(val, table, requested);
	            }
	            throw new UResourceTypeMismatchException(
	                    "Could not get the correct value for index: " + index);
	        }
	
	        protected internal override UResourceBundle HandleGet(int index, Hashtable table,
	                UResourceBundle requested) {
	            if (index > size) {
	                throw new IndexOutOfRangeException();
	            }
	            int offset = IBM.ICU.Impl.ICUResourceBundle.RES_GET_OFFSET(resource);
	            int itemOffset = offset + IBM.ICU.Impl.ICUResourceBundle.GetIntOffset(index + 1);
	            long itemResource = (IBM.ICU.Impl.ICUResourceBundle.UNSIGNED_INT_MASK)
	                    & IBM.ICU.Impl.ICUResourceBundle.GetInt(rawData, itemOffset);
	            String path = (isTopLevel == true) ? ILOG.J2CsMapping.Util.IlNumber.ToString(index)
	                    : resPath + "/" + index;
	            return CreateBundleObject(null, itemResource, path, table,
	                    requested, this);
	        }
	
	        public int CountItems() {
	            int offset = IBM.ICU.Impl.ICUResourceBundle.RES_GET_OFFSET(resource);
	            int value_ren = IBM.ICU.Impl.ICUResourceBundle.GetInt(rawData, offset);
	            return value_ren;
	        }
	
	        internal ResourceArray(String key, String resPath, long resource,
	                ICUResourceBundle bundle) {
	            IBM.ICU.Impl.ICUResourceBundle.Assign(this, bundle);
	            this.resource = resource;
	            this.key = key;
	            this.size = CountItems();
	            this.resPath = resPath;
	        }
	    }
	
	    internal sealed class ResourceBinary : ICUResourceBundle {
	        private sbyte[] value_ren;
	
	        public override ByteBuffer GetBinary() {
	            return ILOG.J2CsMapping.NIO.ByteBuffer.Wrap(value_ren);
	        }
	
	        public override sbyte[] GetBinary(sbyte[] ba) {
	            return value_ren;
	        }
	
	        public sbyte[] GetValue() {
	            int offset = IBM.ICU.Impl.ICUResourceBundle.RES_GET_OFFSET(resource);
	            int length = IBM.ICU.Impl.ICUResourceBundle.GetInt(rawData, offset);
	            int byteOffset = offset + IBM.ICU.Impl.ICUResourceBundle.GetIntOffset(1);
	            sbyte[] dst = new sbyte[length];
	            if (IBM.ICU.Impl.ICUResourceBundle.ASSERT)
	                IBM.ICU.Impl.Assert.Assrt("byteOffset+length < rawData.length", byteOffset
	                        + length < rawData.Length);
	            System.Array.Copy((Array)(rawData),byteOffset,(Array)(dst),0,length);
	            return dst;
	        }
	
	        internal ResourceBinary(String key, String resPath, long resource,
	                ICUResourceBundle bundle) {
	            IBM.ICU.Impl.ICUResourceBundle.Assign(this, bundle);
	            this.resource = resource;
	            this.key = key;
	            this.resPath = resPath;
	            value_ren = GetValue();
	
	        }
	    }
	
	    internal sealed class ResourceInt : ICUResourceBundle {
	        public override int GetInt() {
	            return IBM.ICU.Impl.ICUResourceBundle.RES_GET_INT(resource);
	        }
	
	        public override int GetUInt() {
	            long ret = IBM.ICU.Impl.ICUResourceBundle.RES_GET_UINT(resource);
	            return (int) ret;
	        }
	
	        internal ResourceInt(String key, String resPath, long resource,
	                ICUResourceBundle bundle) {
	            IBM.ICU.Impl.ICUResourceBundle.Assign(this, bundle);
	            this.key = key;
	            this.resource = resource;
	            this.resPath = resPath;
	        }
	    }
	
	    internal sealed class ResourceString : ICUResourceBundle {
	        private String value_ren;
	
	        public override String GetString() {
	            return value_ren;
	        }
	
	        internal ResourceString(String key, String resPath, long resource,
	                ICUResourceBundle bundle) {
	            IBM.ICU.Impl.ICUResourceBundle.Assign(this, bundle);
	            value_ren = GetStringValue(resource);
	            this.key = key;
	            this.resource = resource;
	            this.resPath = resPath;
	        }
	    }
	
	    internal sealed class ResourceIntVector : ICUResourceBundle {
	        private int[] value_ren;
	
	        public override int[] GetIntVector() {
	            return value_ren;
	        }
	
	        public int[] GetValue() {
	            int offset = IBM.ICU.Impl.ICUResourceBundle.RES_GET_OFFSET(resource);
	            int length = IBM.ICU.Impl.ICUResourceBundle.GetInt(rawData, offset);
	            int intOffset = offset + IBM.ICU.Impl.ICUResourceBundle.GetIntOffset(1);
	            int[] val = new int[length];
	            int byteLength = IBM.ICU.Impl.ICUResourceBundle.GetIntOffset(length);
	
	            if (IBM.ICU.Impl.ICUResourceBundle.ASSERT)
	                IBM.ICU.Impl.Assert.Assrt("(intOffset+byteLength)<rawData.length",
	                        (intOffset + byteLength) < rawData.Length);
	
	            for (int i = 0; i < length; i++) {
	                val[i] = IBM.ICU.Impl.ICUResourceBundle.GetInt(rawData, intOffset
	                        + IBM.ICU.Impl.ICUResourceBundle.GetIntOffset(i));
	            }
	            return val;
	        }
	
	        internal ResourceIntVector(String key, String resPath, long resource,
	                ICUResourceBundle bundle) {
	            IBM.ICU.Impl.ICUResourceBundle.Assign(this, bundle);
	            this.key = key;
	            this.resource = resource;
	            this.size = 1;
	            this.resPath = resPath;
	            value_ren = GetValue();
	        }
	    }
	
	    internal sealed class ResourceTable : ICUResourceBundle {
	
	        protected internal override UResourceBundle HandleGet(String key, Hashtable table,
	                UResourceBundle requested) {
	            if (size <= 0) {
	                return null;
	            }
                int offset = IBM.ICU.Impl.ICUResourceBundle.RES_GET_OFFSET(base.resource);
	            // offset+0 contains number of entries
	            // offset+1 contains the keyOffset
	            int currentOffset = (offset) + IBM.ICU.Impl.ICUResourceBundle.GetCharOffset(1);
	            // int keyOffset = rawData.getChar(currentOffset);
	            /* do a binary search for the key */
	            int foundOffset = FindKey(size, currentOffset, this, key);
	            if (foundOffset == -1) {
	                // throw new
	                // MissingResourceException(ICUResourceBundleReader.getFullName(baseName,
	                // localeID),
	                // localeID,
	                // key);
	                return null;
	            }
	            currentOffset += IBM.ICU.Impl.ICUResourceBundle.GetCharOffset(size + (~size & 1))
	                    + IBM.ICU.Impl.ICUResourceBundle.GetIntOffset(foundOffset);
	            long resource = (IBM.ICU.Impl.ICUResourceBundle.UNSIGNED_INT_MASK)
	                    & IBM.ICU.Impl.ICUResourceBundle.GetInt(rawData, currentOffset);
	            String path = (isTopLevel == true) ? key : resPath + "/" + key;
	            return CreateBundleObject(key, resource, path, table, requested,
	                    this);
	        }
	
	        public override String GetKey(int currentOffset, int index) {
	            int charOffset = currentOffset + IBM.ICU.Impl.ICUResourceBundle.GetCharOffset(index);
	            int keyOffset = IBM.ICU.Impl.ICUResourceBundle.GetChar(rawData, charOffset);
	            return IBM.ICU.Impl.ICUResourceBundle.RES_GET_KEY(rawData, keyOffset).ToString();
	        }
	
	        protected internal override UResourceBundle HandleGet(int index, Hashtable table,
	                UResourceBundle requested) {
	            if (index > size) {
	                throw new IndexOutOfRangeException();
	            }
                int offset = IBM.ICU.Impl.ICUResourceBundle.RES_GET_OFFSET(this.resource);
	            // offset+0 contains number of entries
	            // offset+1 contains the keyOffset
	            int currentOffset = (offset) + IBM.ICU.Impl.ICUResourceBundle.GetCharOffset(1);
	            String itemKey = GetKey(currentOffset, index);
	            currentOffset += IBM.ICU.Impl.ICUResourceBundle.GetCharOffset(size + (~size & 1))
	                    + IBM.ICU.Impl.ICUResourceBundle.GetIntOffset(index);
	            long resource = (IBM.ICU.Impl.ICUResourceBundle.UNSIGNED_INT_MASK)
	                    & IBM.ICU.Impl.ICUResourceBundle.GetInt(rawData, currentOffset);
	            String path = (isTopLevel == true) ? ILOG.J2CsMapping.Util.IlNumber.ToString(index)
	                    : resPath + "/" + index;
	            return CreateBundleObject(itemKey, resource, path, table,
	                    requested, this);
	        }
	
	        public int CountItems() {
	            int offset = IBM.ICU.Impl.ICUResourceBundle.RES_GET_OFFSET(resource);
	            int value_ren = IBM.ICU.Impl.ICUResourceBundle.GetChar(rawData, offset);
	            return value_ren;
	        }
	
	        internal ResourceTable(String key, String resPath, long resource,
	                ICUResourceBundle bundle) : this(key, resPath, resource, bundle, false) {
	        }
	
	        internal ResourceTable(ICUResourceBundleReader reader, String baseName,
	                String localeID, Assembly loader) {
	
	            this.rawData = reader.GetData();
	            this.rootResource = (IBM.ICU.Impl.ICUResourceBundle.UNSIGNED_INT_MASK) & reader.GetRootResource();
	            this.noFallback = reader.GetNoFallback();
	            this.baseName = baseName;
	            this.localeID = localeID;
	            this.ulocale = new ULocale(localeID);
	            this.loader = loader;
	            Initialize(null, "", rootResource, null, isTopLevel);
	        }
	
	        internal void Initialize(String key, String resPath, long resource,
	                ICUResourceBundle bundle, bool isTopLevel) {
	            if (bundle != null) {
	                IBM.ICU.Impl.ICUResourceBundle.Assign(this, bundle);
	            }
	            this.key = key;
	            this.resource = resource;
	            this.isTopLevel = isTopLevel;
	            this.size = CountItems();
	            this.resPath = resPath;
	        }
	
	        internal ResourceTable(String key, String resPath, long resource,
	                ICUResourceBundle bundle, bool isTopLevel) {
	            Initialize(key, resPath, resource, bundle, isTopLevel);
	        }
	    }
	
	    internal sealed class ResourceTable32 : ICUResourceBundle {
	
	        protected internal override UResourceBundle HandleGet(String key, Hashtable table,
	                UResourceBundle requested) {
                        int offset = IBM.ICU.Impl.ICUResourceBundle.RES_GET_OFFSET(base.resource);
	            // offset+0 contains number of entries
	            // offset+1 contains the keyOffset
	            int currentOffset = (offset) + IBM.ICU.Impl.ICUResourceBundle.GetIntOffset(1);
	            // int keyOffset = rawData.getChar(currentOffset);
	            /* do a binary search for the key */
	            int foundOffset = FindKey(size, currentOffset, this, key);
	            if (foundOffset == -1) {
	                throw new MissingManifestResourceException("Could not find resource ");
	            }
	            currentOffset += IBM.ICU.Impl.ICUResourceBundle.GetIntOffset(size) + IBM.ICU.Impl.ICUResourceBundle.GetIntOffset(foundOffset);
	            long resource = (IBM.ICU.Impl.ICUResourceBundle.UNSIGNED_INT_MASK)
	                    & IBM.ICU.Impl.ICUResourceBundle.GetInt(rawData, currentOffset);
	            String path = (isTopLevel == true) ? key : resPath + "/" + key;
	            return CreateBundleObject(key, resource, path, table, requested,
	                    this);
	        }
	
	        public override String GetKey(int currentOffset, int index) {
	            int charOffset = currentOffset + IBM.ICU.Impl.ICUResourceBundle.GetIntOffset(index);
	            int keyOffset = IBM.ICU.Impl.ICUResourceBundle.GetInt(rawData, charOffset);
	            return IBM.ICU.Impl.ICUResourceBundle.RES_GET_KEY(rawData, keyOffset).ToString();
	        }
	
	        protected internal override UResourceBundle HandleGet(int index, Hashtable table,
	                UResourceBundle requested) {
	            if (size <= 0) {
	                return null;
	            }
	            if (index > size) {
	                throw new IndexOutOfRangeException();
	            }
                int offset = IBM.ICU.Impl.ICUResourceBundle.RES_GET_OFFSET(base.resource);
	            // offset+0 contains number of entries
	            // offset+1 contains the keyOffset
	            int currentOffset = (offset) + IBM.ICU.Impl.ICUResourceBundle.GetIntOffset(1)
	                    + IBM.ICU.Impl.ICUResourceBundle.GetIntOffset(index);
	            String itemKey = GetKey(currentOffset, 0);
	            currentOffset += IBM.ICU.Impl.ICUResourceBundle.GetIntOffset(size);
	            long resource = (IBM.ICU.Impl.ICUResourceBundle.UNSIGNED_INT_MASK)
	                    & IBM.ICU.Impl.ICUResourceBundle.GetInt(rawData, currentOffset);
	            String path = (isTopLevel == true) ? ILOG.J2CsMapping.Util.IlNumber.ToString(index)
	                    : resPath + "/" + index;
	            return CreateBundleObject(itemKey, resource, path, table,
	                    requested, this);
	        }
	
	        public int CountItems() {
	            int offset = IBM.ICU.Impl.ICUResourceBundle.RES_GET_OFFSET(resource);
	            int value_ren = IBM.ICU.Impl.ICUResourceBundle.GetInt(rawData, offset);
	            return value_ren;
	        }
	
	        internal ResourceTable32(String key, String resPath, long resource,
	                ICUResourceBundle bundle) : this(key, resPath, resource, bundle, false) {
	        }
	
	        internal ResourceTable32(ICUResourceBundleReader reader, String baseName,
	                String localeID, Assembly loader) {
	
	            this.rawData = reader.GetData();
	            this.rootResource = (IBM.ICU.Impl.ICUResourceBundle.UNSIGNED_INT_MASK) & reader.GetRootResource();
	            this.noFallback = reader.GetNoFallback();
	            this.baseName = baseName;
	            this.localeID = localeID;
	            this.ulocale = new ULocale(localeID);
	            this.loader = loader;
	            Initialize(null, "", rootResource, null, isTopLevel);
	        }
	
	        internal void Initialize(String key, String resPath, long resource,
	                ICUResourceBundle bundle, bool isTopLevel) {
	            if (bundle != null) {
	                IBM.ICU.Impl.ICUResourceBundle.Assign(this, bundle);
	            }
	            this.key = key;
	            this.resource = resource;
	            this.isTopLevel = isTopLevel;
	            this.size = CountItems();
	            this.resPath = resPath;
	
	        }
	
	        internal ResourceTable32(String key, String resPath, long resource,
	                ICUResourceBundle bundle, bool isTopLevel) {
	            Initialize(key, resPath, resource, bundle, isTopLevel);
	        }
	    }
	}
}
