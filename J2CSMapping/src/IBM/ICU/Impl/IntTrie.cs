/*
 ******************************************************************************
 * Copyright (C) 1996-2006, International Business Machines Corporation and   *
 * others. All Rights Reserved.                                               *
 ******************************************************************************
 */

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:47 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Impl {
	
	using ILOG.J2CsMapping.IO;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	
	/// <summary>
	/// Trie implementation which stores data in int, 32 bits.
	/// </summary>
	///
	/// <seealso cref="T:IBM.ICU.Impl.Trie"/>
	public class IntTrie : Trie {
	    // public constructors ---------------------------------------------
	
	    /// <summary>
	    /// <p>
	    /// Creates a new Trie with the settings for the trie data.
	    /// </p>
	    /// <p>
	    /// Unserialize the 32-bit-aligned input stream and use the data for the
	    /// trie.
	    /// </p>
	    /// </summary>
	    ///
	    /// <param name="inputStream">file input stream to a ICU data file, containing the trie</param>
	    /// <param name="dataManipulate">object which provides methods to parse the char data</param>
	    /// <exception cref="IOException">thrown when data reading fails</exception>
	    /// @draft 2.1
	    public IntTrie(DataInputStream inputStream, Trie.DataManipulate  dataManipulate) : base(inputStream, dataManipulate) {
	        if (!IsIntTrie()) {
	            throw new ArgumentException(
	                    "Data given does not belong to a int trie.");
	        }
	    }
	
	    /// <summary>
	    /// Make a dummy IntTrie. A dummy trie is an empty runtime trie, used when a
	    /// real data trie cannot be loaded.
	    /// The trie always returns the initialValue, or the leadUnitValue for lead
	    /// surrogate code points. The Latin-1 part is always set up to be linear.
	    /// </summary>
	    ///
	    /// <param name="initialValue">the initial value that is set for all code points</param>
	    /// <param name="leadUnitValue">the value for lead surrogate code _units_ that do not haveassociated supplementary data</param>
	    /// <param name="dataManipulate">object which provides methods to parse the char data</param>
	    public IntTrie(int initialValue, int leadUnitValue,
	            Trie.DataManipulate  dataManipulate) : base(new char[IBM.ICU.Impl.Trie.BMP_INDEX_LENGTH + IBM.ICU.Impl.Trie.SURROGATE_BLOCK_COUNT], IBM.ICU.Impl.Trie.HEADER_OPTIONS_LATIN1_IS_LINEAR_MASK_, dataManipulate) {
	        int dataLength, latin1Length, i, limit;
	        char block;
	
	        /* calculate the actual size of the dummy trie data */
	
	        /* max(Latin-1, block 0) */
	        dataLength = latin1Length = (IBM.ICU.Impl.Trie.INDEX_STAGE_1_SHIFT_ <= 8) ? 256
	                : IBM.ICU.Impl.Trie.DATA_BLOCK_LENGTH;
	        if (leadUnitValue != initialValue) {
	            dataLength += IBM.ICU.Impl.Trie.DATA_BLOCK_LENGTH;
	        }
	        m_data_ = new int[dataLength];
	        m_dataLength_ = dataLength;
	
	        m_initialValue_ = initialValue;
	
	        /* fill the index and data arrays */
	
	        /* indexes are preset to 0 (block 0) */
	
	        /* Latin-1 data */
	        for (i = 0; i < latin1Length; ++i) {
	            m_data_[i] = initialValue;
	        }
	
	        if (leadUnitValue != initialValue) {
	            /* indexes for lead surrogate code units to the block after Latin-1 */
	            block = (char) (latin1Length >> IBM.ICU.Impl.Trie.INDEX_STAGE_2_SHIFT_);
	            i = 0xd800 >> IBM.ICU.Impl.Trie.INDEX_STAGE_1_SHIFT_;
	            limit = 0xdc00 >> IBM.ICU.Impl.Trie.INDEX_STAGE_1_SHIFT_;
	            for (; i < limit; ++i) {
	                m_index_[i] = block;
	            }
	
	            /* data for lead surrogate code units */
	            limit = latin1Length + IBM.ICU.Impl.Trie.DATA_BLOCK_LENGTH;
	            for (i = latin1Length; i < limit; ++i) {
	                m_data_[i] = leadUnitValue;
	            }
	        }
	    }
	
	    // public methods --------------------------------------------------
	
	    /// <summary>
	    /// Gets the value associated with the codepoint. If no value is associated
	    /// with the codepoint, a default value will be returned.
	    /// </summary>
	    ///
	    /// <param name="ch">codepoint</param>
	    /// <returns>offset to data</returns>
	    /// @draft 2.1
	    public int GetCodePointValue(int ch) {
	        int offset;
	
	        // fastpath for U+0000..U+D7FF
	        if (0 <= ch && ch < IBM.ICU.Text.UTF16.LEAD_SURROGATE_MIN_VALUE) {
	            // copy of getRawOffset()
	            offset = (m_index_[ch >> IBM.ICU.Impl.Trie.INDEX_STAGE_1_SHIFT_] << IBM.ICU.Impl.Trie.INDEX_STAGE_2_SHIFT_)
	                    + (ch & IBM.ICU.Impl.Trie.INDEX_STAGE_3_MASK_);
	            return m_data_[offset];
	        }
	
	        // handle U+D800..U+10FFFF
	        offset = GetCodePointOffset(ch);
	        return (offset >= 0) ? m_data_[offset] : m_initialValue_;
	    }
	
	    /// <summary>
	    /// Gets the value to the data which this lead surrogate character points to.
	    /// Returned data may contain folding offset information for the next
	    /// trailing surrogate character. This method does not guarantee correct
	    /// results for trail surrogates.
	    /// </summary>
	    ///
	    /// <param name="ch">lead surrogate character</param>
	    /// <returns>data value</returns>
	    /// @draft 2.1
	    public int GetLeadValue(char ch) {
	        return m_data_[GetLeadOffset(ch)];
	    }
	
	    /// <summary>
	    /// Get the value associated with the BMP code point. Lead surrogate code
	    /// points are treated as normal code points, with unfolded values that may
	    /// differ from getLeadValue() results.
	    /// </summary>
	    ///
	    /// <param name="ch">the input BMP code point</param>
	    /// <returns>trie data value associated with the BMP codepoint</returns>
	    /// @draft 2.1
	    public int GetBMPValue(char ch) {
	        return m_data_[GetBMPOffset(ch)];
	    }
	
	    /// <summary>
	    /// Get the value associated with a pair of surrogates.
	    /// </summary>
	    ///
	    /// <param name="lead">a lead surrogate</param>
	    /// <param name="trail">a trail surrogate</param>
	    /// @draft 2.1
	    public int GetSurrogateValue(char lead, char trail) {
	        if (!IBM.ICU.Text.UTF16.IsLeadSurrogate(lead) || !IBM.ICU.Text.UTF16.IsTrailSurrogate(trail)) {
	            throw new ArgumentException(
	                    "Argument characters do not form a supplementary character");
	        }
	        // get fold position for the next trail surrogate
	        int offset = GetSurrogateOffset(lead, trail);
	
	        // get the real data from the folded lead/trail units
	        if (offset > 0) {
	            return m_data_[offset];
	        }
	
	        // return m_initialValue_ if there is an error
	        return m_initialValue_;
	    }
	
	    /// <summary>
	    /// Get a value from a folding offset (from the value of a lead surrogate)
	    /// and a trail surrogate.
	    /// </summary>
	    ///
	    /// <param name="leadvalue">the value of a lead surrogate that contains the folding offset</param>
	    /// <param name="trail">surrogate</param>
	    /// <returns>trie data value associated with the trail character</returns>
	    /// @draft 2.1
	    public int GetTrailValue(int leadvalue, char trail) {
	        if (m_dataManipulate_ == null) {
	            throw new NullReferenceException(
	                    "The field DataManipulate in this Trie is null");
	        }
	        int offset = m_dataManipulate_.GetFoldingOffset(leadvalue);
	        if (offset > 0) {
	            return m_data_[GetRawOffset(offset,
	                    (char) (trail & IBM.ICU.Impl.Trie.SURROGATE_MASK_))];
	        }
	        return m_initialValue_;
	    }
	
	    /// <summary>
	    /// <p>
	    /// Gets the latin 1 fast path value.
	    /// </p>
	    /// <p>
	    /// Note this only works if latin 1 characters have their own linear array.
	    /// </p>
	    /// </summary>
	    ///
	    /// <param name="ch">latin 1 characters</param>
	    /// <returns>value associated with latin character</returns>
	    public int GetLatin1LinearValue(char ch) {
	        return m_data_[IBM.ICU.Impl.Trie.INDEX_STAGE_3_MASK_ + 1 + ch];
	    }
	
	    /// <summary>
	    /// Checks if the argument Trie has the same data as this Trie
	    /// </summary>
	    ///
	    /// <param name="other">Trie to check</param>
	    /// <returns>true if the argument Trie has the same data as this Trie, false
	    /// otherwise</returns>
	    // /CLOVER:OFF
	    public override bool Equals(Object other) {
	        bool result = base.Equals(other);
	        if (result && other  is  IntTrie) {
	            IntTrie othertrie = (IntTrie) other;
	            if (m_initialValue_ != othertrie.m_initialValue_
	                    || !ILOG.J2CsMapping.Collections.Arrays.Equals(m_data_,othertrie.m_data_)) {
	                return false;
	            }
	            return true;
	        }
	        return false;
	    }
	
	    // /CLOVER:ON
	
	    // protected methods -----------------------------------------------
	
	    /// <summary>
	    /// <p>
	    /// Parses the input stream and stores its trie content into a index and data
	    /// array
	    /// </p>
	    /// </summary>
	    ///
	    /// <param name="inputStream">data input stream containing trie data</param>
	    /// <exception cref="IOException">thrown when data reading fails</exception>
        protected internal override void Unserialize(DataInputStream inputStream)
        {
	        base.Unserialize(inputStream);
	        // one used for initial value
	        m_data_ = new int[m_dataLength_];
            DataInputStream input = inputStream; // new DataInputStream(inputStream);
	        for (int i = 0; i < m_dataLength_; i++) {
	            m_data_[i] = input.ReadInt();
	        }
	        m_initialValue_ = m_data_[0];
	    }
	
	    /// <summary>
	    /// Gets the offset to the data which the surrogate pair points to.
	    /// </summary>
	    ///
	    /// <param name="lead">lead surrogate</param>
	    /// <param name="trail">trailing surrogate</param>
	    /// <returns>offset to data</returns>
	    /// @draft 2.1
	    protected internal override int GetSurrogateOffset(char lead, char trail) {
	        if (m_dataManipulate_ == null) {
	            throw new NullReferenceException(
	                    "The field DataManipulate in this Trie is null");
	        }
	        // get fold position for the next trail surrogate
	        int offset = m_dataManipulate_.GetFoldingOffset(GetLeadValue(lead));
	
	        // get the real data from the folded lead/trail units
	        if (offset > 0) {
	            return GetRawOffset(offset, (char) (trail & IBM.ICU.Impl.Trie.SURROGATE_MASK_));
	        }
	
	        // return -1 if there is an error, in this case we return the default
	        // value: m_initialValue_
	        return -1;
	    }
	
	    /// <summary>
	    /// Gets the value at the argument index. For use internally in TrieIterator
	    /// </summary>
	    ///
	    /// <param name="index">value at index will be retrieved</param>
	    /// <returns>32 bit value</returns>
	    /// <seealso cref="T:IBM.ICU.Impl.TrieIterator"/>
	    /// @draft 2.1
	    protected internal override int GetValue(int index) {
	        return m_data_[index];
	    }
	
	    /// <summary>
	    /// Gets the default initial value
	    /// </summary>
	    ///
	    /// <returns>32 bit value</returns>
	    /// @draft 2.1
	    protected internal override int GetInitialValue() {
	        return m_initialValue_;
	    }
	
	    // package private methods -----------------------------------------
	
	    /// <summary>
	    /// Internal constructor for builder use
	    /// </summary>
	    ///
	    /// <param name="index">the index array to be slotted into this trie</param>
	    /// <param name="data">the data array to be slotted into this trie</param>
	    /// <param name="initialvalue">the initial value for this trie</param>
	    /// <param name="options">trie options to use</param>
	    /// <param name="datamanipulate">folding implementation</param>
	    internal IntTrie(char[] index, int[] data, int initialvalue, int options,
	            Trie.DataManipulate  datamanipulate) : base(index, options, datamanipulate) {
	        m_data_ = data;
	        m_dataLength_ = m_data_.Length;
	        m_initialValue_ = initialvalue;
	    }
	
	    // private data members --------------------------------------------
	
	    /// <summary>
	    /// Default value
	    /// </summary>
	    ///
	    private int m_initialValue_;
	
	    /// <summary>
	    /// Array of char data
	    /// </summary>
	    ///
	    private int[] m_data_;
	}
}
