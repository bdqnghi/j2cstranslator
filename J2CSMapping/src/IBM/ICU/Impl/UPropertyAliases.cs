/*
 **********************************************************************
 * Copyright (c) 2002-2007, International Business Machines
 * Corporation and others.  All Rights Reserved.
 **********************************************************************
 * Author: Alan Liu
 * Created: November 5 2002
 * Since: ICU 2.4
 **********************************************************************
 */

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:47 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Impl {
	
	using ILOG.J2CsMapping.IO;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Text;
	
	/// <summary>
	/// Wrapper for the pnames.icu binary data file. This data file is imported from
	/// icu4c. It contains property and property value aliases from the UCD files
	/// PropertyAliases.txt and PropertyValueAliases.txt. The file is built by the
	/// icu4c tool genpname. It must be built on an ASCII big-endian platform to be
	/// usable in icu4j.
	/// This class performs two functions.
	/// (1) It can import the flat binary data into a tree of usable objects.
	/// (2) It provides an API to access the tree of objects.
	/// Needless to say, this class is tightly coupled to the binary format of
	/// icu4c's pnames.icu file.
	/// Each time a UPropertyAliases is constructed, the pnames.icu file is read,
	/// parsed, and a data tree assembled. Clients should create one singleton
	/// instance and cache it.
	/// </summary>
	///
	public sealed class UPropertyAliases : ICUBinary.Authenticate {
	
	    // ----------------------------------------------------------------
	    // Runtime data. This is an unflattened representation of the
	    // data in pnames.icu.
	
	    /// <summary>
	    /// Map from property enum value to nameGroupPool[] index
	    /// </summary>
	    ///
	    private UPropertyAliases.NonContiguousEnumToShort  enumToName;
	
	    /// <summary>
	    /// Map from property alias to property enum value
	    /// </summary>
	    ///
	    private UPropertyAliases.NameToEnum  nameToEnum;
	
	    /// <summary>
	    /// Map from property enum value to valueMapArray[] index
	    /// </summary>
	    ///
	    private UPropertyAliases.NonContiguousEnumToShort  enumToValue;
	
	    /// <summary>
	    /// Each entry represents a binary or enumerated property
	    /// </summary>
	    ///
	    private UPropertyAliases.ValueMap [] valueMapArray;
	
	    /// <summary>
	    /// Pool of concatenated integer runs. Each run contains one or more entries. The last entry of the run is negative. A zero entry indicates "n/a" in the Property///Aliases.txt. Each entry is a stringPool[] index.
	    /// </summary>
	    ///
	    private short[] nameGroupPool;
	
	    /// <summary>
	    /// Pool of strings.
	    /// </summary>
	    ///
	    internal String[] stringPool;
	
	    // ----------------------------------------------------------------
	    // Constants
	
	    /// <summary>
	    /// Debug flag (not really constant)
	    /// </summary>
	    ///
	    private static bool DEBUG = IBM.ICU.Impl.ICUDebug.Enabled("pnames");
	
	    /// <summary>
	    /// File format that this class understands. See icu4c/src/common/propname.h.
	    /// </summary>
	    ///
        private static readonly byte[] DATA_FORMAT_ID = { (byte)'p', (byte)'n', (byte)'a', (byte)'m' };
	
	    /// <summary>
	    /// File version that this class understands. See
	    /// icu4c/src/common/propname.h.
	    /// </summary>
	    ///
	    private const byte DATA_FORMAT_VERSION = 1;
	
	    /// <summary>
	    /// Name of the datafile
	    /// </summary>
	    ///
        private const String DATA_FILE_NAME = IBM.ICU.Impl.ICUResourceBundle.ICU_DATA_PATH + IBM.ICU.Impl.ICUResourceBundle.ICU_BUNDLE
	            + "/pnames.icu";
	
	    /// <summary>
	    /// Buffer size of datafile. The whole file is < 16k.
	    /// </summary>
	    ///
	    private const int DATA_BUFFER_SIZE = 8192;
	
	    // ----------------------------------------------------------------
	    // Constructor
	
	    /// <summary>
	    /// Constructs a UPropertyAliases object. The binary file DATA_FILE_NAME is
	    /// read from the jar/classpath and unflattened into member variables of this
	    /// object.
	    /// </summary>
	    ///
	    public UPropertyAliases() {
	
	        // Open the .icu file from the jar/classpath
	         Stream 
	                mask0 = IBM.ICU.Impl.ICUData.GetRequiredStream(DATA_FILE_NAME);
	        BufferedStream b = new BufferedStream(mask0,DATA_BUFFER_SIZE);
	        // Read and discard Unicode version...
	        /* byte unicodeVersion[] = */
            IBM.ICU.Impl.ICUBinary.ReadHeader(b, DATA_FORMAT_ID,
	                this);
	        DataInputStream d = new DataInputStream(b);
	
	        // Record the origin position of the file. Keep enough around
	        // to seek back to the start of the header.
	        d.Mark(256);
	
	        short enumToName_offset = d.ReadShort();
	        short nameToEnum_offset = d.ReadShort();
	        short enumToValue_offset = d.ReadShort();
	        short total_size = d.ReadShort();
	        short valueMap_offset = d.ReadShort();
	        short valueMap_count = d.ReadShort();
	        short nameGroupPool_offset = d.ReadShort();
	        short nameGroupPool_count = d.ReadShort();
	        short stringPool_offset = d.ReadShort();
	        short stringPool_count = d.ReadShort();
	
	        if (DEBUG) {
	            System.Console.Out.WriteLine("enumToName_offset=" + enumToName_offset + "\n"
	                    + "nameToEnum_offset=" + nameToEnum_offset + "\n"
	                    + "enumToValue_offset=" + enumToValue_offset + "\n"
	                    + "total_size=" + total_size + "\n" + "valueMap_offset="
	                    + valueMap_offset + "\n" + "valueMap_count="
	                    + valueMap_count + "\n" + "nameGroupPool_offset="
	                    + nameGroupPool_offset + "\n" + "nameGroupPool_count="
	                    + nameGroupPool_count + "\n" + "stringPool_offset="
	                    + stringPool_offset + "\n" + "stringPool_count="
	                    + stringPool_count);
	        }
	
	        byte[] raw = new byte[total_size];
	        d.Reset();
	        d.ReadFully(raw);
	        d.Close();
	
	        UPropertyAliases.Builder  builder = new UPropertyAliases.Builder (raw);
	
	        stringPool = builder
	                .ReadStringPool(stringPool_offset, stringPool_count);
	
	        nameGroupPool = builder.ReadNameGroupPool(nameGroupPool_offset,
	                nameGroupPool_count);
	
	        builder.SetupValueMap_map(valueMap_offset, valueMap_count);
	
	        // Some of the following data structures have to be set up
	        // here, _not_ in Builder. That's because they are instances
	        // of non-static inner classes, and they contain implicit
	        // references to this.
	
	        builder.Seek(enumToName_offset);
	        enumToName = new UPropertyAliases.NonContiguousEnumToShort (builder);
	        builder.NameGroupOffsetToIndex(enumToName.offsetArray);
	
	        builder.Seek(nameToEnum_offset);
	        nameToEnum = new UPropertyAliases.NameToEnum (this, builder);
	
	        builder.Seek(enumToValue_offset);
	        enumToValue = new UPropertyAliases.NonContiguousEnumToShort (builder);
	        builder.ValueMapOffsetToIndex(enumToValue.offsetArray);
	
	        valueMapArray = new UPropertyAliases.ValueMap [valueMap_count];
	        for (int i = 0; i < valueMap_count; ++i) {
	            // Must seek to the start of each entry.
	            builder.Seek(builder.valueMap_map[i]);
	            valueMapArray[i] = new UPropertyAliases.ValueMap (this, builder);
	        }
	
	        builder.Close();
	    }
	
	    // ----------------------------------------------------------------
	    // Public API
	
	    /// <summary>
	    /// Return a property name given a property enum. Multiple names may be
	    /// available for each property; the nameChoice selects among them.
	    /// </summary>
	    ///
	    public String GetPropertyName(int property, int nameChoice) {
	        short nameGroupIndex = enumToName.GetShort(property);
	        return ChooseNameInGroup(nameGroupIndex, nameChoice);
	    }
	
	    /// <summary>
	    /// Return a property enum given one of its property names.
	    /// </summary>
	    ///
	    public int GetPropertyEnum(String propertyAlias) {
	        return nameToEnum.GetEnum(propertyAlias);
	    }
	
	    /// <summary>
	    /// Return a value name given a property enum and a value enum. Multiple
	    /// names may be available for each value; the nameChoice selects among them.
	    /// </summary>
	    ///
	    public String GetPropertyValueName(int property, int value_ren, int nameChoice) {
	        UPropertyAliases.ValueMap  vm = GetValueMap(property);
	        short nameGroupIndex = vm.enumToName.GetShort(value_ren);
	        return ChooseNameInGroup(nameGroupIndex, nameChoice);
	    }
	
	    /// <summary>
	    /// Return a value enum given one of its value names and the corresponding
	    /// property alias.
	    /// </summary>
	    ///
	    public int GetPropertyValueEnum(int property, String valueAlias) {
	        UPropertyAliases.ValueMap  vm = GetValueMap(property);
	        return vm.nameToEnum.GetEnum(valueAlias);
	    }
	
	    // ----------------------------------------------------------------
	    // Data structures
	
	    /// <summary>
	    /// A map for the legal values of a binary or enumerated properties.
	    /// </summary>
	    ///
	        internal class ValueMap {
	    
	            private UPropertyAliases outer_UPropertyAliases;
	    
	            /// <summary>
	            /// Maps value enum to index into the nameGroupPool[]
	            /// </summary>
	            ///
	            internal UPropertyAliases.EnumToShort  enumToName; // polymorphic
	    
	            /// <summary>
	            /// Maps value name to value enum.
	            /// </summary>
	            ///
	            internal UPropertyAliases.NameToEnum  nameToEnum;
	    
	            internal ValueMap(UPropertyAliases aliases, UPropertyAliases.Builder  b) {
	                outer_UPropertyAliases = aliases;
	                short enumToName_offset = b.ReadShort();
	                short ncEnumToName_offset = b.ReadShort();
	                short nameToEnum_offset = b.ReadShort();
	                if (enumToName_offset != 0) {
	                    b.Seek(enumToName_offset);
	                    UPropertyAliases.ContiguousEnumToShort  x = new UPropertyAliases.ContiguousEnumToShort(b);
	                    b.NameGroupOffsetToIndex(x.offsetArray);
	                    enumToName = x;
	                } else {
	                    b.Seek(ncEnumToName_offset);
	                    UPropertyAliases.NonContiguousEnumToShort  x_0 = new UPropertyAliases.NonContiguousEnumToShort(b);
	                    b.NameGroupOffsetToIndex(x_0.offsetArray);
	                    enumToName = x_0;
	                }
	                b.Seek(nameToEnum_offset);
	                nameToEnum = new  IBM.ICU.Impl.UPropertyAliases.NameToEnum (outer_UPropertyAliases, b);
	            }
	        }
	
	    /// <summary>
	    /// Abstract map from enum values to integers.
	    /// </summary>
	    ///
	    public interface EnumToShort {
	        short GetShort(int enumProbe);
	    }
	
	    /// <summary>
	    /// Generic map from enum values to offsets. Enum values are contiguous.
	    /// </summary>
	    ///
	    internal class ContiguousEnumToShort : UPropertyAliases.EnumToShort  {
	        internal int enumStart;
	
	        internal int enumLimit;
	
	        internal short[] offsetArray;
	
	        public virtual short GetShort(int enumProbe) {
	            if (enumProbe < enumStart || enumProbe >= enumLimit) {
	                throw new ArgumentException("Invalid enum. enumStart = "
	                        + enumStart + " enumLimit = " + enumLimit
	                        + " enumProbe = " + enumProbe);
	            }
	            return offsetArray[enumProbe - enumStart];
	        }
	
	        internal ContiguousEnumToShort(ICUBinaryStream s) {
	            enumStart = s.ReadInt();
	            enumLimit = s.ReadInt();
	            int count = enumLimit - enumStart;
	            offsetArray = new short[count];
	            for (int i = 0; i < count; ++i) {
	                offsetArray[i] = s.ReadShort();
	            }
	        }
	    }
	
	    /// <summary>
	    /// Generic map from enum values to offsets. Enum values need not be
	    /// contiguous.
	    /// </summary>
	    ///
	    internal class NonContiguousEnumToShort : UPropertyAliases.EnumToShort  {
	        internal int[] enumArray;
	
	        internal short[] offsetArray;
	
	        public virtual short GetShort(int enumProbe) {
	            for (int i = 0; i < enumArray.Length; ++i) {
	                if (enumArray[i] < enumProbe)
	                    continue;
	                if (enumArray[i] > enumProbe)
	                    break;
	                return offsetArray[i];
	            }
	            throw new ArgumentException("Invalid enum");
	        }
	
	        internal NonContiguousEnumToShort(ICUBinaryStream s) {
	            int i;
	            int count = s.ReadInt();
	            enumArray = new int[count];
	            offsetArray = new short[count];
	            for (i = 0; i < count; ++i) {
	                enumArray[i] = s.ReadInt();
	            }
	            for (i = 0; i < count; ++i) {
	                offsetArray[i] = s.ReadShort();
	            }
	        }
	    }
	
	    /// <summary>
	    /// Map from names to enum values.
	    /// </summary>
	    ///
	        public class NameToEnum {
	            private UPropertyAliases outer_UPropertyAliases;
	    
	            internal int[] enumArray;
	    
	            internal short[] nameArray;
	    
	            internal int GetEnum(String nameProbe) {
	                for (int i = 0; i < nameArray.Length; ++i) {
	                    int c = IBM.ICU.Impl.UPropertyAliases.Compare(nameProbe,
	                            outer_UPropertyAliases.stringPool[nameArray[i]]);
	                    if (c > 0)
	                        continue;
	                    if (c < 0)
	                        break;
	                    return enumArray[i];
	                }
	                throw new ArgumentException("Invalid name: " + nameProbe);
	            }
	    
	            internal NameToEnum(UPropertyAliases aliases, UPropertyAliases.Builder  b) {
	                outer_UPropertyAliases = aliases;
	                int i;
	                int count = b.ReadInt();
	                enumArray = new int[count];
	                nameArray = new short[count];
	                for (i = 0; i < count; ++i) {
	                    enumArray[i] = b.ReadInt();
	                }
	                for (i = 0; i < count; ++i) {
	                    nameArray[i] = b.StringOffsetToIndex(b.ReadShort());
	                }
	            }
	        }
	
	    // ----------------------------------------------------------------
	    // Runtime implementation
	
	    /// <summary>
	    /// Compare two property names, returning <0, 0, or >0. The comparison is
	    /// that described as "loose" matching in the Property///Aliases.txt files.
	    /// </summary>
	    ///
	    public static int Compare(String stra, String strb) {
	        // Note: This implementation is a literal copy of
	        // uprv_comparePropertyNames. It can probably be improved.
	        int istra = 0, istrb = 0, rc;
	        int cstra = 0, cstrb = 0;
	        for (;;) {
	            /* Ignore delimiters '-', '_', and ASCII White_Space */
	            while (istra < stra.Length) {
	                cstra = stra[istra];
	                switch (cstra) {
	                case '-':
	                case '_':
	                case ' ':
	                case '\t':
	                case '\n':
	                case 0xb/* \v */:
	                case '\f':
	                case '\r':
	                    ++istra;
	                    continue;
	                }
	                break;
	            }
	
	            while (istrb < strb.Length) {
	                cstrb = strb[istrb];
	                switch (cstrb) {
	                case '-':
	                case '_':
	                case ' ':
	                case '\t':
	                case '\n':
	                case 0xb/* \v */:
	                case '\f':
	                case '\r':
	                    ++istrb;
	                    continue;
	                }
	                break;
	            }
	
	            /* If we reach the ends of both strings then they match */
	            bool endstra = istra == stra.Length;
	            bool endstrb = istrb == strb.Length;
	            if (endstra) {
	                if (endstrb)
	                    return 0;
	                cstra = 0;
	            } else if (endstrb) {
	                cstrb = 0;
	            }
	
	            rc = IBM.ICU.Lang.UCharacter.ToLowerCase(cstra) - IBM.ICU.Lang.UCharacter.ToLowerCase(cstrb);
	            if (rc != 0) {
	                return rc;
	            }
	
	            ++istra;
	            ++istrb;
	        }
	    }
	
	    /// <summary>
	    /// Given an index to a run within the nameGroupPool[], and a nameChoice
	    /// (0,1,...), select the nameChoice-th entry of the run.
	    /// </summary>
	    ///
	    private String ChooseNameInGroup(short nameGroupIndex, int nameChoice) {
	        if (nameChoice < 0) {
	            throw new ArgumentException("Invalid name choice");
	        }
	        while (nameChoice-- > 0) {
	            if (nameGroupPool[nameGroupIndex++] < 0) {
	                throw new ArgumentException("Invalid name choice");
	            }
	        }
	        short a = nameGroupPool[nameGroupIndex];
	        return stringPool[(a < 0) ? (int) (-a) : (int) (a)];
	    }
	
	    /// <summary>
	    /// Return the valueMap[] entry for a given property.
	    /// </summary>
	    ///
	    private UPropertyAliases.ValueMap  GetValueMap(int property) {
	        int valueMapIndex = enumToValue.GetShort(property);
	        return valueMapArray[valueMapIndex];
	    }
	
	    // ----------------------------------------------------------------
	    // ICUBinary API
	
	    /// <summary>
	    /// Return true if the given data version can be used.
	    /// </summary>
	    ///
	    public bool IsDataVersionAcceptable(byte[] version) {
	        return version[0] == DATA_FORMAT_VERSION;
	    }
	
	    // ----------------------------------------------------------------
	    // Builder
	
	    /// <summary>
	    /// A specialized ICUBinaryStream that can map between offsets and index
	    /// values into various arrays (stringPool, nameGroupPool, and valueMap). It
	    /// also knows how to read various structures.
	    /// </summary>
	    ///
	    internal class Builder : ICUBinaryStream {
	
	        // map[i] = offset of object i. We need maps for all of our
	        // arrays. The arrays are indexed by offset in the raw binary
	        // file; we need to translate that to index.

            public short[] stringPool_map;
	
	        public short[] valueMap_map;

            public short[] nameGroup_map;
	
	        public Builder(byte[] raw) : base(raw) {
	        }
	
	        /// <summary>
	        /// The valueMap_map[] must be setup in advance. This method does that.
	        /// </summary>
	        ///
	        public void SetupValueMap_map(short offset, short count) {
	            valueMap_map = new short[count];
	            for (int i = 0; i < count; ++i) {
	                // Start of each entry. Each entry is 6 bytes long.
	                valueMap_map[i] = (short) (offset + i * 6);
	            }
	        }
	
	        /// <summary>
	        /// Read stringPool[]. Build up translation table from offsets to string
	        /// indices (stringPool_map[]).
	        /// </summary>
	        ///
	        public String[] ReadStringPool(short offset, short count) {
	            Seek(offset);
	            String[] stringPool_0 = new String[count + 1];
	            stringPool_map = new short[count + 1];
	            short pos = offset;
	            StringBuilder buf = new StringBuilder();
	            stringPool_map[0] = 0;
	            for (int i = 1; i <= count; ++i) {
	                buf.Length=0;
	                for (;;) {
	                    // This works because the name is invariant-ASCII
	                    char c = (char) ReadUnsignedByte();
	                    if (c == 0)
	                        break;
	                    buf.Append(c);
	                }
	                stringPool_map[i] = pos;
	                stringPool_0[i] = buf.ToString();
	                pos += (short) ((stringPool_0[i].Length) + 1);
	            }
	            if (IBM.ICU.Impl.UPropertyAliases.DEBUG) {
	                System.Console.Out.WriteLine("read stringPool x " + count + ": "
	                        + stringPool_0[1] + ", " + stringPool_0[2] + ", "
	                        + stringPool_0[3] + ",...");
	            }
	            return stringPool_0;
	        }
	
	        /// <summary>
	        /// Read the nameGroupPool[], and build up the offset->index map
	        /// (nameGroupPool_map[]).
	        /// </summary>
	        ///
	        public short[] ReadNameGroupPool(short offset, short count) {
	            // Read nameGroupPool[]. This contains offsets from start of
	            // header. We translate these into indices into stringPool[]
	            // on the fly. The offset 0, which indicates "no entry", we
	            // translate into index 0, which contains a null String
	            // pointer.
	            Seek(offset);
	            short pos = offset;
	            short[] nameGroupPool_0 = new short[count];
	            nameGroup_map = new short[count];
	            for (int i = 0; i < count; ++i) {
	                nameGroup_map[i] = pos;
	                nameGroupPool_0[i] = StringOffsetToIndex(ReadShort());
	                pos += 2;
	            }
	            if (IBM.ICU.Impl.UPropertyAliases.DEBUG) {
	                System.Console.Out.WriteLine("read nameGroupPool x " + count + ": "
	                        + nameGroupPool_0[0] + ", " + nameGroupPool_0[1] + ", "
	                        + nameGroupPool_0[2] + ",...");
	            }
	            return nameGroupPool_0;
	        }
	
	        /// <summary>
	        /// Convert an offset into the string pool into a stringPool[] index.
	        /// </summary>
	        ///
	        internal short StringOffsetToIndex(short offset) {
	            int probe = offset;
	            if (probe < 0)
	                probe = -probe;
	            for (int i = 0; i < stringPool_map.Length; ++i) {
	                if (stringPool_map[i] == probe) {
	                    return (short) ((offset < 0) ? -i : i);
	                }
	            }
	            throw new InvalidOperationException("Can't map string pool offset "
	                    + offset + " to index");
	        }
	
	        /**
	         * Convert an array of offsets into the string pool into an array of
	         * stringPool[] indices. MODIFIES THE ARRAY IN PLACE.
	         */
	        /*
	         * private void stringOffsetToIndex(short array[]) { for (int i=0;
	         * i<array.length; ++i) { array[i] = stringOffsetToIndex(array[i]); } }
	         */
	
	        /// <summary>
	        /// Convert an offset into the value map into a valueMap[] index.
	        /// </summary>
	        ///
	        public short ValueMapOffsetToIndex(short offset) {
	            for (short i = 0; i < valueMap_map.Length; ++i) {
	                if (valueMap_map[i] == offset) {
	                    return i;
	                }
	            }
	            throw new InvalidOperationException("Can't map value map offset "
	                    + offset + " to index");
	        }
	
	        /// <summary>
	        /// Convert an array of offsets into the value map array into an array of
	        /// valueMap[] indices. MODIFIES THE ARRAY IN PLACE.
	        /// </summary>
	        ///
	        public void ValueMapOffsetToIndex(short[] array) {
	            for (int i = 0; i < array.Length; ++i) {
	                array[i] = ValueMapOffsetToIndex(array[i]);
	            }
	        }
	
	        /// <summary>
	        /// Convert an offset into the name group pool into a nameGroupPool[]
	        /// index.
	        /// </summary>
	        ///
	        public short NameGroupOffsetToIndex(short offset) {
	            for (short i = 0; i < nameGroup_map.Length; ++i) {
	                if (nameGroup_map[i] == offset) {
	                    return i;
	                }
	            }
	            throw new Exception("Can't map name group offset " + offset
	                    + " to index");
	        }
	
	        /// <summary>
	        /// Convert an array of offsets into the name group pool into an array of
	        /// nameGroupPool[] indices. MODIFIES THE ARRAY IN PLACE.
	        /// </summary>
	        ///
	        internal void NameGroupOffsetToIndex(short[] array) {
	            for (int i = 0; i < array.Length; ++i) {
	                array[i] = NameGroupOffsetToIndex(array[i]);
	            }
	        }
	    }
	}
}
