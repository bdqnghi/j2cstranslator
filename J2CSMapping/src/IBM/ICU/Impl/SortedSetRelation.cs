/*
 **********************************************************************
 * Copyright (c) 2002-2004, International Business Machines
 * Corporation and others.  All Rights Reserved.
 **********************************************************************
 * Author: M. Davis
 * Created: December 2002 (moved from UnicodeSet)
 * Since: ICU 2.4
 **********************************************************************
 */
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:47 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Impl {
	
	using ILOG.J2CsMapping.Collections;
	using ILOG.J2CsMapping.Collections.Generics;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	
	/// <summary>
	/// Computationally efficient determination of the relationship between two
	/// SortedSets.
	/// </summary>
	///
	public class SortedSetRelation {
	
	    /// <summary>
	    /// The relationship between two sets A and B can be determined by looking
	    /// at: A - B A & B (intersection) B - A These are represented by a set of
	    /// bits. Bit 2 is true if A - B is not empty Bit 1 is true if A & B is not
	    /// empty BIT 0 is true if B - A is not empty
	    /// </summary>
	    ///
	    public const int A_NOT_B = 4, A_AND_B = 2, B_NOT_A = 1;
	
	    /// <summary>
	    /// There are 8 combinations of the relationship bits. These correspond to
	    /// the filters (combinations of allowed bits) in hasRelation. They also
	    /// correspond to the modification functions, listed in comments.
	    /// </summary>
	    ///
	    public const int ANY = A_NOT_B | A_AND_B | B_NOT_A, // union, addAll
	            CONTAINS = A_NOT_B | A_AND_B, // A (unnecessary)
	            DISJOINT = A_NOT_B | B_NOT_A, // A xor B, missing Java function
	            ISCONTAINED = A_AND_B | B_NOT_A, // B (unnecessary)
	            NO_B = A_NOT_B, // A setDiff B, removeAll
	            EQUALS = A_AND_B, // A intersect B, retainAll
	            NO_A = B_NOT_A, // B setDiff A, removeAll
	            NONE = 0, // null (unnecessary)
	
	            ADDALL = ANY, // union, addAll
	            A = CONTAINS, // A (unnecessary)
	            COMPLEMENTALL = DISJOINT, // A xor B, missing Java function
	            B = ISCONTAINED, // B (unnecessary)
	            REMOVEALL = NO_B, // A setDiff B, removeAll
	            RETAINALL = EQUALS, // A intersect B, retainAll
	            B_REMOVEALL = NO_A; // B setDiff A, removeAll
	
	    /// <summary>
	    /// Utility that could be on SortedSet. Faster implementation than what is in
	    /// Java for doing contains, equals, etc.
	    /// </summary>
	    ///
	    /// <param name="a">first set</param>
	    /// <param name="allow">filter, using ANY, CONTAINS, etc.</param>
	    /// <param name="b">second set</param>
	    /// <returns>whether the filter relationship is true or not.</returns>
	    public static bool HasRelation(SortedSet a, int allow, SortedSet b) {
	        if (allow < NONE || allow > ANY) {
	            throw new ArgumentException("Relation " + allow
	                    + " out of range");
	        }
	
	        // extract filter conditions
	        // these are the ALLOWED conditions Set
	
	        bool anb = (allow & A_NOT_B) != 0;
	        bool ab = (allow & A_AND_B) != 0;
	        bool bna = (allow & B_NOT_A) != 0;
	
	        // quick check on sizes
	        switch (allow) {
	        case CONTAINS:
	            if (a.Count < b.Count)
	                return false;
	            break;
	        case ISCONTAINED:
	            if (a.Count > b.Count)
	                return false;
	            break;
	        case EQUALS:
	            if (a.Count != b.Count)
	                return false;
	            break;
	        }
	
	        // check for null sets
	        if (a.Count == 0) {
	            if (b.Count == 0)
	                return true;
	            return bna;
	        } else if (b.Count == 0) {
	            return anb;
	        }
	
	        // pick up first strings, and start comparing
	        IIterator ait = new ILOG.J2CsMapping.Collections.IteratorAdapter(a.GetEnumerator());
	        IIterator bit = new ILOG.J2CsMapping.Collections.IteratorAdapter(b.GetEnumerator());
	
	        IComparable aa = (IComparable) ait.Next();
	        IComparable bb = (IComparable) bit.Next();
	
	        while (true) {
	            int comp = aa.CompareTo(bb);
	            if (comp == 0) {
	                if (!ab)
	                    return false;
	                if (!ait.HasNext()) {
	                    if (!bit.HasNext())
	                        return true;
	                    return bna;
	                } else if (!bit.HasNext()) {
	                    return anb;
	                }
	                aa = (IComparable) ait.Next();
	                bb = (IComparable) bit.Next();
	            } else if (comp < 0) {
	                if (!anb)
	                    return false;
	                if (!ait.HasNext()) {
	                    return bna;
	                }
	                aa = (IComparable) ait.Next();
	            } else {
	                if (!bna)
	                    return false;
	                if (!bit.HasNext()) {
	                    return anb;
	                }
	                bb = (IComparable) bit.Next();
	            }
	        }
	    }
	
	    /// <summary>
	    /// Utility that could be on SortedSet. Allows faster implementation than
	    /// what is in Java for doing addAll, removeAll, retainAll, (complementAll).
	    /// </summary>
	    ///
	    /// <param name="a">first set</param>
	    /// <param name="relation">the relation filter, using ANY, CONTAINS, etc.</param>
	    /// <param name="b">second set</param>
	    /// <returns>the new set</returns>
	    public static SortedSet DoOperation(SortedSet a, int relation, SortedSet b) {
	        // TODO: optimize this as above
	        SortedSet temp;
	        switch (relation) {
	        case ADDALL:
	            ILOG.J2CsMapping.Collections.Generics.Collections.AddAll(b,a);
	            return a;
	        case A:
	            return a; // no action
	        case B:
	            ILOG.J2CsMapping.Collections.Collections.Clear(a);
	            ILOG.J2CsMapping.Collections.Generics.Collections.AddAll(b,a);
	            return a;
	        case REMOVEALL:
	            a.RemoveAll(b);
	            return a;
	        case RETAINALL:
	            a.RetainAll(b);
	            return a;
	            // the following is the only case not really supported by Java
	            // although all could be optimized
	        case COMPLEMENTALL:
	            temp = new SortedSet(b);
	            temp.RemoveAll(a);
	            a.RemoveAll(b);
	            ILOG.J2CsMapping.Collections.Generics.Collections.AddAll(temp,a);
	            return a;
	        case B_REMOVEALL:
	            temp = new SortedSet(b);
	            temp.RemoveAll(a);
	            ILOG.J2CsMapping.Collections.Collections.Clear(a);
	            ILOG.J2CsMapping.Collections.Generics.Collections.AddAll(temp,a);
	            return a;
	        case NONE:
	            ILOG.J2CsMapping.Collections.Collections.Clear(a);
	            return a;
	        default:
	            throw new ArgumentException("Relation " + relation
	                    + " out of range");
	        }
	    }
	}
}
