/*
 **********************************************************************
 *   Copyright (c) 2001-2007, International Business Machines
 *   Corporation and others.  All Rights Reserved.
 **********************************************************************
 */
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:30 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Text {
	
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Text;
     using ILOG.J2CsMapping.Util;
     using ILOG.J2CsMapping.Text;
	
	internal class TransliteratorParser {
	
	    // ----------------------------------------------------------------------
	    // Data members
	    // ----------------------------------------------------------------------
	
	    /// <summary>
	    /// PUBLIC data member. A Vector of RuleBasedTransliterator.Data objects, one
	    /// for each discrete group of rules in the rule set
	    /// </summary>
	    ///
	    public ArrayList dataVector;
	
	    /// <summary>
	    /// PUBLIC data member. A Vector of Strings containing all of the ID blocks
	    /// in the rule set
	    /// </summary>
	    ///
	    public ArrayList idBlockVector;
	
	    /// <summary>
	    /// The current data object for which we are parsing rules
	    /// </summary>
	    ///
	    internal RuleBasedTransliterator.Data curData;
	
	    /// <summary>
	    /// PUBLIC data member containing the parsed compound filter, if any.
	    /// </summary>
	    ///
	    public UnicodeSet compoundFilter;
	
	    private int direction;
	
	    /// <summary>
	    /// Temporary symbol table used during parsing.
	    /// </summary>
	    ///
	    private TransliteratorParser.ParseData  parseData;
	
	    /// <summary>
	    /// Temporary vector of set variables. When parsing is complete, this is
	    /// copied into the array data.variables. As with data.variables, element 0
	    /// corresponds to character data.variablesBase.
	    /// </summary>
	    ///
	    internal ArrayList variablesVector;
	
	    /// <summary>
	    /// Temporary table of variable names. When parsing is complete, this is
	    /// copied into data.variableNames.
	    /// </summary>
	    ///
	    internal Hashtable variableNames;
	
	    /// <summary>
	    /// String of standins for segments. Used during the parsing of a single
	    /// rule. segmentStandins.charAt(0) is the standin for "$1" and corresponds
	    /// to StringMatcher object segmentObjects.elementAt(0), etc.
	    /// </summary>
	    ///
	    private StringBuilder segmentStandins;
	
	    /// <summary>
	    /// Vector of StringMatcher objects for segments. Used during the parsing of
	    /// a single rule. segmentStandins.charAt(0) is the standin for "$1" and
	    /// corresponds to StringMatcher object segmentObjects.elementAt(0), etc.
	    /// </summary>
	    ///
	    private ArrayList segmentObjects;
	
	    /// <summary>
	    /// The next available stand-in for variables. This starts at some point in
	    /// the private use area (discovered dynamically) and increments up toward
	    /// <c>variableLimit</c>. At any point during parsing, available
	    /// variables are <c>variableNext..variableLimit-1</c>.
	    /// </summary>
	    ///
	    private char variableNext;
	
	    /// <summary>
	    /// The last available stand-in for variables. This is discovered
	    /// dynamically. At any point during parsing, available variables are
	    /// <c>variableNext..variableLimit-1</c>. During variable definition we
	    /// use the special value variableLimit-1 as a placeholder.
	    /// </summary>
	    ///
	    private char variableLimit;
	
	    /// <summary>
	    /// When we encounter an undefined variable, we do not immediately signal an
	    /// error, in case we are defining this variable, e.g., "$a = [a-z];".
	    /// Instead, we save the name of the undefined variable, and substitute in
	    /// the placeholder char variableLimit - 1, and decrement variableLimit.
	    /// </summary>
	    ///
	    private String undefinedVariableName;
	
	    /// <summary>
	    /// The stand-in character for the 'dot' set, represented by '.' in patterns.
	    /// This is allocated the first time it is needed, and reused thereafter.
	    /// </summary>
	    ///
	    private int dotStandIn;
	
	    // ----------------------------------------------------------------------
	    // Constants
	    // ----------------------------------------------------------------------
	
	    // Indicator for ID blocks
	    private static readonly String ID_TOKEN = "::";
	
	    private const int ID_TOKEN_LEN = 2;
	
	    /*
	     * (reserved for future expansion) // markers for beginning and end of rule
	     * groups private static final String BEGIN_TOKEN = "BEGIN"; private static
	     * final String END_TOKEN = "END";
	     */
	
	    // Operators
	    private const char VARIABLE_DEF_OP = '=';
	
	    private const char FORWARD_RULE_OP = '>';
	
	    private const char REVERSE_RULE_OP = '<';
	
	    private const char FWDREV_RULE_OP = '~'; // internal rep of <> op
	
	    private static readonly String OPERATORS = "=><\u2190\u2192\u2194";
	
	    private static readonly String HALF_ENDERS = "=><\u2190\u2192\u2194;";
	
	    // Other special characters
	    private const char QUOTE = '\'';
	
	    private const char ESCAPE = '\\';
	
	    private const char END_OF_RULE = ';';
	
	    private const char RULE_COMMENT_CHAR = '#';
	
	    private const char CONTEXT_ANTE = '{'; // ante{key
	
	    private const char CONTEXT_POST = '}'; // key}post
	
	    private const char CURSOR_POS = '|';
	
	    private const char CURSOR_OFFSET = '@';
	
	    private const char ANCHOR_START = '^';
	
	    private const char KLEENE_STAR = '*';
	
	    private const char ONE_OR_MORE = '+';
	
	    private const char ZERO_OR_ONE = '?';
	
	    private const char DOT = '.';
	
	    private static readonly String DOT_SET = "[^[:Zp:][:Zl:]\\r\\n$]";
	
	    // By definition, the ANCHOR_END special character is a
	    // trailing SymbolTable.SYMBOL_REF character.
	    // private static final char ANCHOR_END = '$';
	
	    // Segments of the input string are delimited by "(" and ")". In the
	    // output string these segments are referenced as "$1", "$2", etc.
	    private const char SEGMENT_OPEN = '(';
	
	    private const char SEGMENT_CLOSE = ')';
	
	    // A function is denoted &Source-Target/Variant(text)
	    private const char FUNCTION = '&';
	
	    // Aliases for some of the syntax characters. These are provided so
	    // transliteration rules can be expressed in XML without clashing with
	    // XML syntax characters '<', '>', and '&'.
	    private const char ALT_REVERSE_RULE_OP = '\u2190'; // Left Arrow
	
	    private const char ALT_FORWARD_RULE_OP = '\u2192'; // Right Arrow
	
	    private const char ALT_FWDREV_RULE_OP = '\u2194'; // Left Right Arrow
	
	    private const char ALT_FUNCTION = '\u2206'; // Increment (~Greek
	                                                       // Capital Delta)
	
	    // Special characters disallowed at the top level
	    private static UnicodeSet ILLEGAL_TOP = new UnicodeSet("[\\)]");
	
	    // Special characters disallowed within a segment
	    private static UnicodeSet ILLEGAL_SEG = new UnicodeSet("[\\{\\}\\|\\@]");
	
	    // Special characters disallowed within a function argument
	    private static UnicodeSet ILLEGAL_FUNC = new UnicodeSet(
	            "[\\^\\(\\.\\*\\+\\?\\{\\}\\|\\@]");
	
	    // ----------------------------------------------------------------------
	    // class ParseData
	    // ----------------------------------------------------------------------
	
	    /// <summary>
	    /// This class implements the SymbolTable interface. It is used during
	    /// parsing to give UnicodeSet access to variables that have been defined so
	    /// far. Note that it uses variablesVector, _not_ data.variables.
	    /// </summary>
	    ///
	        internal class ParseData : SymbolTable {
	    
	            private TransliteratorParser outer_TransliteratorParser;
	    
	            
	            /// <param name="parser"></param>
	            public ParseData(TransliteratorParser parser) {
	                outer_TransliteratorParser = parser;
	            }
	    
	            /// <summary>
	            /// Implement SymbolTable API.
	            /// </summary>
	            ///
	            public virtual char[] Lookup(String name) {
	                return (char[]) outer_TransliteratorParser.variableNames[name];
	            }
	    
	            /// <summary>
	            /// Implement SymbolTable API.
	            /// </summary>
	            ///
	            public virtual UnicodeMatcher LookupMatcher(int ch) {
	                // Note that we cannot use data.lookup() because the
	                // set array has not been constructed yet.
	                int i = ch - outer_TransliteratorParser.curData.variablesBase;
	                if (i >= 0 && i < outer_TransliteratorParser.variablesVector.Count) {
	                    return (UnicodeMatcher) outer_TransliteratorParser.variablesVector[i];
	                }
	                return null;
	            }
	    
	            /// <summary>
	            /// Implement SymbolTable API. Parse out a symbol reference name.
	            /// </summary>
	            ///
	            public virtual String ParseReference(String text, ParsePosition pos, int limit) {
	                int start = pos.GetIndex();
	                int i = start;
	                while (i < limit) {
	                    char c = text[i];
	                    if ((i == start && !Character.IsUnicodeIdentifierStart(c))
                                || !Character.IsUnicodeIdentifierPart(c))
                        {
	                        break;
	                    }
	                    ++i;
	                }
	                if (i == start) { // No valid name chars
	                    return null;
	                }
	                pos.SetIndex(i);
	                return text.Substring(start,(i)-(start));
	            }
	    
	            /// <summary>
	            /// Return true if the given character is a matcher standin or a plain
	            /// character (non standin).
	            /// </summary>
	            ///
	            public bool IsMatcher(int ch) {
	                // Note that we cannot use data.lookup() because the
	                // set array has not been constructed yet.
	                int i = ch - outer_TransliteratorParser.curData.variablesBase;
	                if (i >= 0 && i < outer_TransliteratorParser.variablesVector.Count) {
	                    return outer_TransliteratorParser.variablesVector[i]   is  UnicodeMatcher;
	                }
	                return true;
	            }
	    
	            /// <summary>
	            /// Return true if the given character is a replacer standin or a plain
	            /// character (non standin).
	            /// </summary>
	            ///
	            public bool IsReplacer(int ch) {
	                // Note that we cannot use data.lookup() because the
	                // set array has not been constructed yet.
	                int i = ch - outer_TransliteratorParser.curData.variablesBase;
	                if (i >= 0 && i < outer_TransliteratorParser.variablesVector.Count) {
	                    return outer_TransliteratorParser.variablesVector[i]   is  UnicodeReplacer;
	                }
	                return true;
	            }
	        }
	
	    // ----------------------------------------------------------------------
	    // classes RuleBody, RuleArray, and RuleReader
	    // ----------------------------------------------------------------------
	
	    /// <summary>
	    /// A private abstract class representing the interface to rule source code
	    /// that is broken up into lines. Handles the folding of lines terminated by
	    /// a backslash. This folding is limited; it does not account for comments,
	    /// quotes, or escapes, so its use to be limited.
	    /// </summary>
	    ///
	    public abstract class RuleBody {
	
	        /// <summary>
	        /// Retrieve the next line of the source, or return null if none. Folds
	        /// lines terminated by a backslash into the next line, without regard
	        /// for comments, quotes, or escapes.
	        /// </summary>
	        ///
	        internal String NextLine() {
	            String s = HandleNextLine();
	            if (s != null && s.Length > 0 && s[s.Length - 1] == '\\') {
	
	                StringBuilder b = new StringBuilder(s);
	                do {
	                    b.Remove(b.Length - 1,1);
	                    s = HandleNextLine();
	                    if (s == null) {
	                        break;
	                    }
	                    b.Append(s);
	                } while (s.Length > 0 && s[s.Length - 1] == '\\');
	
	                s = b.ToString();
	            }
	            return s;
	        }
	
	        /// <summary>
	        /// Reset to the first line of the source.
	        /// </summary>
	        ///
	        abstract internal void Reset();
	
	        /// <summary>
	        /// Subclass method to return the next line of the source.
	        /// </summary>
	        ///
	        abstract internal String HandleNextLine();
	    }
	
	    /// <summary>
	    /// RuleBody subclass for a String[] array.
	    /// </summary>
	    ///
	    private class RuleArray : TransliteratorParser.RuleBody  {
	        internal String[] array;
	
	        internal int i;
	
	        public RuleArray(String[] array_0) {
	            this.array = array_0;
	            i = 0;
	        }
	
	        internal override String HandleNextLine() {
	            return (i < array.Length) ? array[i++] : null;
	        }
	
	        internal override void Reset() {
	            i = 0;
	        }
	    }
	
	    /*
	     * RuleBody subclass for a ResourceReader.
	     */
	    /*
	     * private static class RuleReader : RuleBody { ResourceReader reader;
	     * public RuleReader(ResourceReader reader) { this.reader = reader; } public
	     * String handleNextLine() { try { return reader.readLine(); } catch
	     * (java.io.IOException e) {} return null; } public void reset() {
	     * reader.reset(); } }
	     */
	
	    // ----------------------------------------------------------------------
	    // class RuleHalf
	    // ----------------------------------------------------------------------
	
	    /// <summary>
	    /// A class representing one side of a rule. This class knows how to parse
	    /// half of a rule. It is tightly coupled to the method
	    /// TransliteratorParser.parseRule().
	    /// </summary>
	    ///
	    private class RuleHalf {
	
	        public RuleHalf() {
	            this.cursor = -1;
	            this.ante = -1;
	            this.post = -1;
	            this.cursorOffset = 0;
	            this.cursorOffsetPos = 0;
	            this.anchorStart = false;
	            this.anchorEnd = false;
	            this.nextSegmentNumber = 1;
	        }
	
	        public String text;
	
	        public int cursor; // position of cursor in text
	
	        public int ante; // position of ante context marker '{' in text
	
	        public int post; // position of post context marker '}' in text
	
	        // Record the offset to the cursor either to the left or to the
	        // right of the key. This is indicated by characters on the output
	        // side that allow the cursor to be positioned arbitrarily within
	        // the matching text. For example, abc{def} > | @@@ xyz; changes
	        // def to xyz and moves the cursor to before abc. Offset characters
	        // must be at the start or end, and they cannot move the cursor past
	        // the ante- or postcontext text. Placeholders are only valid in
	        // output text. The length of the ante and post context is
	        // determined at runtime, because of supplementals and quantifiers.
	        public int cursorOffset; // only nonzero on output side
	
	        // Position of first CURSOR_OFFSET on _right_. This will be -1
	        // for |@, -2 for |@@, etc., and 1 for @|, 2 for @@|, etc.
	        private int cursorOffsetPos;
	
	        public bool anchorStart;
	
	        public bool anchorEnd;
	
	        /// <summary>
	        /// The segment number from 1..n of the next '(' we see during parsing;
	        /// 1-based.
	        /// </summary>
	        ///
	        private int nextSegmentNumber;
	
	        /// <summary>
	        /// Parse one side of a rule, stopping at either the limit, the
	        /// END_OF_RULE character, or an operator.
	        /// </summary>
	        ///
	        /// <returns>the index after the terminating character, or if limit was
	        /// reached, limit</returns>
	        public int Parse(String rule, int pos, int limit,
	                TransliteratorParser parser) {
	            int start = pos;
	            StringBuilder buf = new StringBuilder();
	            pos = ParseSection(rule, pos, limit, parser, buf, IBM.ICU.Text.TransliteratorParser.ILLEGAL_TOP,
	                    false);
	            text = buf.ToString();
	
	            if (cursorOffset > 0 && cursor != cursorOffsetPos) {
	                IBM.ICU.Text.TransliteratorParser.SyntaxError("Misplaced " + IBM.ICU.Text.TransliteratorParser.CURSOR_POS, rule, start);
	            }
	
	            return pos;
	        }
	
	        /// <summary>
	        /// Parse a section of one side of a rule, stopping at either the limit,
	        /// the END_OF_RULE character, an operator, or a segment close character.
	        /// This method parses both a top-level rule half and a segment within
	        /// such a rule half. It calls itself recursively to parse segments and
	        /// nested segments.
	        /// </summary>
	        ///
	        /// <param name="buf">buffer into which to accumulate the rule patterncharacters, either literal characters from the rule orstandins for UnicodeMatcher objects including segments.</param>
	        /// <param name="illegal">the set of special characters that is illegal during thisparse.</param>
	        /// <param name="isSegment">if true, then we've already seen a '(' and pos on entrypoints right after it. Accumulate everything up to theclosing ')', put it in a segment matcher object, generatea standin for it, and add the standin to buf. As a sideeffect, update the segments vector with a reference to thesegment matcher. This works recursively for nestedsegments. If isSegment is false, just accumulatecharacters into buf.</param>
	        /// <returns>the index after the terminating character, or if limit was
	        /// reached, limit</returns>
	        public int ParseSection(String rule, int pos, int limit,
	                TransliteratorParser parser, StringBuilder buf,
	                UnicodeSet illegal, bool isSegment) {
	            int start = pos;
	            ParsePosition pp = null;
	            int quoteStart = -1; // Most recent 'single quoted string'
	            int quoteLimit = -1;
	            int varStart = -1; // Most recent $variableReference
	            int varLimit = -1;
	            int[] iref = new int[1];
	            int bufStart = buf.Length;
	
	            main: {
	                while (pos < limit) {
	                    // Since all syntax characters are in the BMP, fetching
	                    // 16-bit code units suffices here.
	                    char c = rule[pos++];
	                    if (IBM.ICU.Impl.UCharacterProperty.IsRuleWhiteSpace(c)) {
	                        continue;
	                    }
	                    // HALF_ENDERS is all chars that end a rule half: "<>=;"
	                    if (IBM.ICU.Text.TransliteratorParser.HALF_ENDERS.IndexOf(c) >= 0) {
	                        if (isSegment) {
	                            IBM.ICU.Text.TransliteratorParser.SyntaxError("Unclosed segment", rule, start);
	                        }
	                        goto gotomain;
	                    }
	                    if (anchorEnd) {
	                        // Text after a presumed end anchor is a syntax err
	                        IBM.ICU.Text.TransliteratorParser.SyntaxError("Malformed variable reference", rule, start);
	                    }
	                    if (IBM.ICU.Text.UnicodeSet.ResemblesPattern(rule, pos - 1)) {
	                        if (pp == null) {
	                            pp = new ParsePosition(0);
	                        }
	                        pp.SetIndex(pos - 1); // Backup to opening '['
	                        buf.Append(parser.ParseSet(rule, pp));
	                        pos = pp.GetIndex();
	                        continue;
	                    }
	                    // Handle escapes
	                    if (c == IBM.ICU.Text.TransliteratorParser.ESCAPE) {
	                        if (pos == limit) {
	                            IBM.ICU.Text.TransliteratorParser.SyntaxError("Trailing backslash", rule, start);
	                        }
	                        iref[0] = pos;
	                        int escaped = IBM.ICU.Impl.Utility.UnescapeAt(rule, iref);
	                        pos = iref[0];
	                        if (escaped == -1) {
	                            IBM.ICU.Text.TransliteratorParser.SyntaxError("Malformed escape", rule, start);
	                        }
	                        parser.CheckVariableRange(escaped, rule, start);
	                        IBM.ICU.Text.UTF16.Append(buf, escaped);
	                        continue;
	                    }
	                    // Handle quoted matter
	                    if (c == IBM.ICU.Text.TransliteratorParser.QUOTE) {
	                        int iq = rule.IndexOf(IBM.ICU.Text.TransliteratorParser.QUOTE, pos);
	                        if (iq == pos) {
	                            buf.Append(c); // Parse [''] outside quotes as [']
	                            ++pos;
	                        } else {
	                            /*
	                             * This loop picks up a run of quoted text of the form
	                             * 'aaaa' each time through. If this run hasn't really
	                             * ended ('aaaa''bbbb') then it keeps looping, each time
	                             * adding on a new run. When it reaches the final quote
	                             * it breaks.
	                             */
	                            quoteStart = buf.Length;
	                            for (;;) {
	                                if (iq < 0) {
	                                    IBM.ICU.Text.TransliteratorParser.SyntaxError("Unterminated quote", rule, start);
	                                }
	                                buf.Append(rule.Substring(pos,(iq)-(pos)));
	                                pos = iq + 1;
	                                if (pos < limit && rule[pos] == IBM.ICU.Text.TransliteratorParser.QUOTE) {
	                                    // Parse [''] inside quotes as [']
	                                    iq = rule.IndexOf(IBM.ICU.Text.TransliteratorParser.QUOTE, pos + 1);
	                                    // Continue looping
	                                } else {
	                                    break;
	                                }
	                            }
	                            quoteLimit = buf.Length;
	
	                            for (iq = quoteStart; iq < quoteLimit; ++iq) {
	                                parser.CheckVariableRange(buf[iq], rule,
	                                        start);
	                            }
	                        }
	                        continue;
	                    }
	
	                    parser.CheckVariableRange(c, rule, start);
	
	                    if (illegal.Contains(c)) {
	                        IBM.ICU.Text.TransliteratorParser.SyntaxError("Illegal character '" + c + '\'', rule, start);
	                    }
	
	                    switch ((int) c) {
	
	                    // ------------------------------------------------------
	                    // Elements allowed within and out of segments
	                    // ------------------------------------------------------
	                    case IBM.ICU.Text.TransliteratorParser.ANCHOR_START:
	                        if (buf.Length == 0 && !anchorStart) {
	                            anchorStart = true;
	                        } else {
	                            IBM.ICU.Text.TransliteratorParser.SyntaxError("Misplaced anchor start", rule, start);
	                        }
	                        break;
	                    case IBM.ICU.Text.TransliteratorParser.SEGMENT_OPEN: {
	                        // bufSegStart is the offset in buf to the first
	                        // character of the segment we are parsing.
	                        int bufSegStart = buf.Length;
	
	                        // Record segment number now, since nextSegmentNumber
	                        // will be incremented during the call to parseSection
	                        // if there are nested segments.
	                        int segmentNumber = nextSegmentNumber++; // 1-based
	
	                        // Parse the segment
	                        pos = ParseSection(rule, pos, limit, parser, buf,
	                                IBM.ICU.Text.TransliteratorParser.ILLEGAL_SEG, true);
	
	                        // After parsing a segment, the relevant characters are
	                        // in buf, starting at offset bufSegStart. Extract them
	                        // into a string matcher, and replace them with a
	                        // standin for that matcher.
	                        StringMatcher m = new StringMatcher(
	                                buf.ToString(bufSegStart,buf.Length-bufSegStart), segmentNumber,
	                                parser.curData);
	
	                        // Record and associate object and segment number
	                        parser.SetSegmentObject(segmentNumber, m);
	                        buf.Length=bufSegStart;
	                        buf.Append(parser.GetSegmentStandin(segmentNumber));
	                    }
	                        break;
	                    case IBM.ICU.Text.TransliteratorParser.FUNCTION:
	                    case IBM.ICU.Text.TransliteratorParser.ALT_FUNCTION: {
	                        iref[0] = pos;
	                        TransliteratorIDParser.SingleID single = IBM.ICU.Text.TransliteratorIDParser
	                                .ParseFilterID(rule, iref);
	                        // The next character MUST be a segment open
	                        if (single == null
	                                || !IBM.ICU.Impl.Utility.ParseChar(rule, iref, IBM.ICU.Text.TransliteratorParser.SEGMENT_OPEN)) {
	                            IBM.ICU.Text.TransliteratorParser.SyntaxError("Invalid function", rule, start);
	                        }
	
	                        Transliterator t = single.GetInstance();
	                        if (t == null) {
	                            IBM.ICU.Text.TransliteratorParser.SyntaxError("Invalid function ID", rule, start);
	                        }
	
	                        // bufSegStart is the offset in buf to the first
	                        // character of the segment we are parsing.
	                        int bufSegStart_0 = buf.Length;
	
	                        // Parse the segment
	                        pos = ParseSection(rule, iref[0], limit, parser, buf,
	                                IBM.ICU.Text.TransliteratorParser.ILLEGAL_FUNC, true);
	
	                        // After parsing a segment, the relevant characters are
	                        // in buf, starting at offset bufSegStart.
	                        FunctionReplacer r = new FunctionReplacer(t,
	                                new StringReplacer(buf.ToString(bufSegStart_0,buf.Length-bufSegStart_0),
	                                        parser.curData));
	
	                        // Replace the buffer contents with a stand-in
	                        buf.Length=bufSegStart_0;
	                        buf.Append(parser.GenerateStandInFor(r));
	                    }
	                        break;
	                    case IBM.ICU.Text.SymbolTable_Constants.SYMBOL_REF:
	                        // Handle variable references and segment references "$1" ..
	                        // "$9"
	                    {
	                        // A variable reference must be followed immediately
	                        // by a Unicode identifier start and zero or more
	                        // Unicode identifier part characters, or by a digit
	                        // 1..9 if it is a segment reference.
	                        if (pos == limit) {
	                            // A variable ref character at the end acts as
	                            // an anchor to the context limit, as in perl.
	                            anchorEnd = true;
	                            break;
	                        }
	                        // Parse "$1" "$2" .. "$9" .. (no upper limit)
	                        c = rule[pos];
	                        int r_1 = IBM.ICU.Lang.UCharacter.Digit(c, 10);
	                        if (r_1 >= 1 && r_1 <= 9) {
	                            iref[0] = pos;
	                            r_1 = IBM.ICU.Impl.Utility.ParseNumber(rule, iref, 10);
	                            if (r_1 < 0) {
	                                IBM.ICU.Text.TransliteratorParser.SyntaxError("Undefined segment reference", rule,
	                                        start);
	                            }
	                            pos = iref[0];
	                            buf.Append(parser.GetSegmentStandin(r_1));
	                        } else {
	                            if (pp == null) { // Lazy create
	                                pp = new ParsePosition(0);
	                            }
	                            pp.SetIndex(pos);
	                            String name = parser.parseData.ParseReference(rule, pp,
	                                    limit);
	                            if (name == null) {
	                                // This means the '$' was not followed by a
	                                // valid name. Try to interpret it as an
	                                // end anchor then. If this also doesn't work
	                                // (if we see a following character) then signal
	                                // an error.
	                                anchorEnd = true;
	                                break;
	                            }
	                            pos = pp.GetIndex();
	                            // If this is a variable definition statement,
	                            // then the LHS variable will be undefined. In
	                            // that case appendVariableDef() will append the
	                            // special placeholder char variableLimit-1.
	                            varStart = buf.Length;
	                            parser.AppendVariableDef(name, buf);
	                            varLimit = buf.Length;
	                        }
	                    }
	                        break;
	                    case IBM.ICU.Text.TransliteratorParser.DOT:
	                        buf.Append(parser.GetDotStandIn());
	                        break;
	                    case IBM.ICU.Text.TransliteratorParser.KLEENE_STAR:
	                    case IBM.ICU.Text.TransliteratorParser.ONE_OR_MORE:
	                    case IBM.ICU.Text.TransliteratorParser.ZERO_OR_ONE:
	                        // Quantifiers. We handle single characters, quoted strings,
	                        // variable references, and segments.
	                        // a+ matches aaa
	                        // 'foo'+ matches foofoofoo
	                        // $v+ matches xyxyxy if $v == xy
	                        // (seg)+ matches segsegseg
	                    {
	                        if (isSegment && buf.Length == bufStart) {
	                            // The */+ immediately follows '('
	                            IBM.ICU.Text.TransliteratorParser.SyntaxError("Misplaced quantifier", rule, start);
	                            break;
	                        }
	
	                        int qstart, qlimit;
	                        // The */+ follows an isolated character or quote
	                        // or variable reference
	                        if (buf.Length == quoteLimit) {
	                            // The */+ follows a 'quoted string'
	                            qstart = quoteStart;
	                            qlimit = quoteLimit;
	                        } else if (buf.Length == varLimit) {
	                            // The */+ follows a $variableReference
	                            qstart = varStart;
	                            qlimit = varLimit;
	                        } else {
	                            // The */+ follows a single character, possibly
	                            // a segment standin
	                            qstart = buf.Length - 1;
	                            qlimit = qstart + 1;
	                        }
	
	                        UnicodeMatcher m_2;
	                        try {
	                            m_2 = new StringMatcher(buf.ToString(), qstart, qlimit,
	                                    0, parser.curData);
	                        } catch (Exception e) {
	                            throw new ArgumentException("Failure in rule: "
	                                    + rule.Substring(pos,(limit)-(pos)));
	                        }
	                        int min = 0;
	                        int max = IBM.ICU.Text.Quantifier.MAX;
	                        switch ((int) c) {
	                        case IBM.ICU.Text.TransliteratorParser.ONE_OR_MORE:
	                            min = 1;
	                            break;
	                        case IBM.ICU.Text.TransliteratorParser.ZERO_OR_ONE:
	                            min = 0;
	                            max = 1;
	                            break;
	                        // case KLEENE_STAR:
	                        // do nothing -- min, max already set
	                        }
	                        m_2 = new Quantifier(m_2, min, max);
	                        buf.Length=qstart;
	                        buf.Append(parser.GenerateStandInFor(m_2));
	                    }
	                        break;
	
	                    // ------------------------------------------------------
	                    // Elements allowed ONLY WITHIN segments
	                    // ------------------------------------------------------
	                    case IBM.ICU.Text.TransliteratorParser.SEGMENT_CLOSE:
	                        goto gotomain;
	
	                    // ------------------------------------------------------
	                    // Elements allowed ONLY OUTSIDE segments
	                    // ------------------------------------------------------
	                    case IBM.ICU.Text.TransliteratorParser.CONTEXT_ANTE:
	                        if (ante >= 0) {
	                            IBM.ICU.Text.TransliteratorParser.SyntaxError("Multiple ante contexts", rule, start);
	                        }
	                        ante = buf.Length;
	                        break;
	                    case IBM.ICU.Text.TransliteratorParser.CONTEXT_POST:
	                        if (post >= 0) {
	                            IBM.ICU.Text.TransliteratorParser.SyntaxError("Multiple post contexts", rule, start);
	                        }
	                        post = buf.Length;
	                        break;
	                    case IBM.ICU.Text.TransliteratorParser.CURSOR_POS:
	                        if (cursor >= 0) {
	                            IBM.ICU.Text.TransliteratorParser.SyntaxError("Multiple cursors", rule, start);
	                        }
	                        cursor = buf.Length;
	                        break;
	                    case IBM.ICU.Text.TransliteratorParser.CURSOR_OFFSET:
	                        if (cursorOffset < 0) {
	                            if (buf.Length > 0) {
	                                IBM.ICU.Text.TransliteratorParser.SyntaxError("Misplaced " + c, rule, start);
	                            }
	                            --cursorOffset;
	                        } else if (cursorOffset > 0) {
	                            if (buf.Length != cursorOffsetPos || cursor >= 0) {
	                                IBM.ICU.Text.TransliteratorParser.SyntaxError("Misplaced " + c, rule, start);
	                            }
	                            ++cursorOffset;
	                        } else {
	                            if (cursor == 0 && buf.Length == 0) {
	                                cursorOffset = -1;
	                            } else if (cursor < 0) {
	                                cursorOffsetPos = buf.Length;
	                                cursorOffset = 1;
	                            } else {
	                                IBM.ICU.Text.TransliteratorParser.SyntaxError("Misplaced " + c, rule, start);
	                            }
	                        }
	                        break;
	
	                    // ------------------------------------------------------
	                    // Non-special characters
	                    // ------------------------------------------------------
	                    default:
	                        // Disallow unquoted characters other than [0-9A-Za-z]
	                        // in the printable ASCII range. These characters are
	                        // reserved for possible future use.
	                        if (c >= 0x0021
	                                && c <= 0x007E
	                                && !((c >= '0' && c <= '9')
	                                        || (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'))) {
	                            IBM.ICU.Text.TransliteratorParser.SyntaxError("Unquoted " + c, rule, start);
	                        }
	                        buf.Append(c);
	                        break;
	                    }
	                }
	            }
	            gotomain:
	            ;
	            return pos;
	        }
	
	        /// <summary>
	        /// Remove context.
	        /// </summary>
	        ///
	        internal void RemoveContext() {
	            text = text.Substring((ante < 0) ? 0 : ante,((post < 0) ? text.Length
	                                : post)-((ante < 0) ? 0 : ante));
	            ante = post = -1;
	            anchorStart = anchorEnd = false;
	        }
	
	        /// <summary>
	        /// Return true if this half looks like valid output, that is, does not
	        /// contain quantifiers or other special input-only elements.
	        /// </summary>
	        ///
	        public bool IsValidOutput(TransliteratorParser parser) {
	            for (int i_0 = 0; i_0 < text.Length;) {
	                int c = IBM.ICU.Text.UTF16.CharAt(text, i_0);
	                i_0 += IBM.ICU.Text.UTF16.GetCharCount(c);
	                if (!parser.parseData.IsReplacer(c)) {
	                    return false;
	                }
	            }
	            return true;
	        }
	
	        /// <summary>
	        /// Return true if this half looks like valid input, that is, does not
	        /// contain functions or other special output-only elements.
	        /// </summary>
	        ///
	        public bool IsValidInput(TransliteratorParser parser) {
	            for (int i_0 = 0; i_0 < text.Length;) {
	                int c = IBM.ICU.Text.UTF16.CharAt(text, i_0);
	                i_0 += IBM.ICU.Text.UTF16.GetCharCount(c);
	                if (!parser.parseData.IsMatcher(c)) {
	                    return false;
	                }
	            }
	            return true;
	        }
	    }
	
	    // ----------------------------------------------------------------------
	    // PUBLIC methods
	    // ----------------------------------------------------------------------
	
	    /// <summary>
	    /// Constructor.
	    /// </summary>
	    ///
	    public TransliteratorParser() {
	        this.dotStandIn = -1;
	    }
	
	    /// <summary>
	    /// Parse a set of rules. After the parse completes, examine the public data
	    /// members for results.
	    /// </summary>
	    ///
	    public void Parse(String rules, int direction_0) {
	        ParseRules(new TransliteratorParser.RuleArray (new String[] { rules }), direction_0);
	    }
	
	    /*
	     * Parse a set of rules. After the parse completes, examine the public data
	     * members for results.
	     */
	    /*
	     * public void parse(ResourceReader rules, int direction) { parseRules(new
	     * RuleReader(rules), direction); }
	     */
	
	    // ----------------------------------------------------------------------
	    // PRIVATE methods
	    // ----------------------------------------------------------------------
	
	    /// <summary>
	    /// Parse an array of zero or more rules. The strings in the array are
	    /// treated as if they were concatenated together, with rule terminators
	    /// inserted between array elements if not present already.
	    /// Any previous rules are discarded. Typically this method is called exactly
	    /// once, during construction.
	    /// The member this.data will be set to null if there are no rules.
	    /// </summary>
	    ///
	    /// <exception cref="IllegalArgumentException">if there is a syntax error in the rules</exception>
	    internal void ParseRules(TransliteratorParser.RuleBody  ruleArray, int dir) {
	        bool parsingIDs = true;
	        int ruleCount = 0;
	
	        dataVector = new ArrayList();
	        idBlockVector = new ArrayList();
	        curData = null;
	        direction = dir;
	        compoundFilter = null;
	        variablesVector = new ArrayList();
	        variableNames = new Hashtable();
	        parseData = new TransliteratorParser.ParseData (this);
	
	        StringBuilder errors = null;
	        int errorCount = 0;
	
	        ruleArray.Reset();
	
	        StringBuilder idBlockResult = new StringBuilder();
	
	        // The compound filter offset is an index into idBlockResult.
	        // If it is 0, then the compound filter occurred at the start,
	        // and it is the offset to the _start_ of the compound filter
	        // pattern. Otherwise it is the offset to the _limit_ of the
	        // compound filter pattern within idBlockResult.
	        this.compoundFilter = null;
	        int compoundFilterOffset = -1;
	
	        main: {
	            for (;;) {
	                String rule = ruleArray.NextLine();
	                if (rule == null) {
	                    break;
	                }
	                int pos = 0;
	                int limit = rule.Length;
	                while (pos < limit) {
	                    char c = rule[pos++];
	                    if (IBM.ICU.Impl.UCharacterProperty.IsRuleWhiteSpace(c)) {
	                        continue;
	                    }
	                    // Skip lines starting with the comment character
	                    if (c == RULE_COMMENT_CHAR) {
	                        pos = ILOG.J2CsMapping.Util.StringUtil.IndexOf(rule,"\n",pos) + 1;
	                        if (pos == 0) {
	                            break; // No "\n" found; rest of rule is a commnet
	                        }
	                        continue; // Either fall out or restart with next line
	                    }
	
	                    // skip empty rules
	                    if (c == END_OF_RULE)
	                        continue;
	
	                    // Often a rule file contains multiple errors. It's
	                    // convenient to the rule author if these are all reported
	                    // at once. We keep parsing rules even after a failure, up
	                    // to a specified limit, and report all errors at once.
	                    try {
	                        ++ruleCount;
	
	                        // We've found the start of a rule or ID. c is its first
	                        // character, and pos points past c.
	                        --pos;
	                        // Look for an ID token. Must have at least ID_TOKEN_LEN + 1
	                        // chars left.
	                        if ((pos + ID_TOKEN_LEN + 1) <= limit
	                                && StringUtil.RegionMatches( rule, pos, ID_TOKEN, 0,
	                                        ID_TOKEN_LEN)) {
	                            pos += ID_TOKEN_LEN;
	                            c = rule[pos];
	                            while (IBM.ICU.Impl.UCharacterProperty.IsRuleWhiteSpace(c)
	                                    && pos < limit) {
	                                ++pos;
	                                c = rule[pos];
	                            }
	                            int[] p = new int[] { pos };
	
	                            if (!parsingIDs) {
	                                if (curData != null) {
	                                    if (direction == IBM.ICU.Text.Transliterator.FORWARD)
	                                        dataVector.Add(curData);
	                                    else
	                                        dataVector.Insert(0,curData);
	                                    curData = null;
	                                }
	                                parsingIDs = true;
	                            }
	
	                            TransliteratorIDParser.SingleID id = IBM.ICU.Text.TransliteratorIDParser
	                                    .ParseSingleID(rule, p, direction);
	                            if (p[0] != pos
	                                    && IBM.ICU.Impl.Utility.ParseChar(rule, p, END_OF_RULE)) {
	                                // Successful ::ID parse.
	
	                                if (direction == IBM.ICU.Text.Transliterator.FORWARD) {
	                                    idBlockResult.Append(id.canonID).Append(
	                                            END_OF_RULE);
	                                } else {
	                                    idBlockResult.Insert(0, id.canonID
	                                            + END_OF_RULE);
	                                }
	
	                            } else {
	                                // Couldn't parse an ID. Try to parse a global
	                                // filter
	                                int[] withParens = new int[] { -1 };
	                                UnicodeSet f = IBM.ICU.Text.TransliteratorIDParser
	                                        .ParseGlobalFilter(rule, p, direction,
	                                                withParens, null);
	                                if (f != null
	                                        && IBM.ICU.Impl.Utility.ParseChar(rule, p, END_OF_RULE)) {
	                                    if ((direction == IBM.ICU.Text.Transliterator.FORWARD) == (withParens[0] == 0)) {
	                                        if (compoundFilter != null) {
	                                            // Multiple compound filters
	                                            SyntaxError("Multiple global filters",
	                                                    rule, pos);
	                                        }
	                                        compoundFilter = f;
	                                        compoundFilterOffset = ruleCount;
	                                    }
	                                } else {
	                                    // Invalid ::id
	                                    // Can be parsed as neither an ID nor a global
	                                    // filter
	                                    SyntaxError("Invalid ::ID", rule, pos);
	                                }
	                            }
	
	                            pos = p[0];
	                        } else {
	                            if (parsingIDs) {
	                                if (direction == IBM.ICU.Text.Transliterator.FORWARD)
	                                    idBlockVector.Add(idBlockResult.ToString());
	                                else
	                                    idBlockVector.Insert(0,idBlockResult.ToString());
	                                idBlockResult.Remove(0,idBlockResult.Length-(0));
	                                parsingIDs = false;
	                                curData = new RuleBasedTransliterator.Data();
	
	                                // By default, rules use part of the private use
	                                // area
	                                // E000..F8FF for variables and other stand-ins.
	                                // Currently
	                                // the range F000..F8FF is typically sufficient. The
	                                // 'use
	                                // variable range' pragma allows rule sets to modify
	                                // this.
	                                SetVariableRange(0xF000, 0xF8FF);
	                            }
	
	                            if (ResemblesPragma(rule, pos, limit)) {
	                                int ppp = ParsePragma(rule, pos, limit);
	                                if (ppp < 0) {
	                                    SyntaxError("Unrecognized pragma", rule, pos);
	                                }
	                                pos = ppp;
	                                // Parse a rule
	                            } else {
	                                pos = ParseRule(rule, pos, limit);
	                            }
	                        }
	                    } catch (ArgumentException e) {
	                        if (errorCount == 30) {
	                            errors.Append("\nMore than 30 errors; further messages squelched");
	                            goto gotomain;
	                        }
	                        if (errors == null) {
	                            errors = new StringBuilder(e.Message);
	                        } else {
	                            errors.Append("\n" + e.Message);
	                        }
	                        ++errorCount;
	                        pos = RuleEnd(rule, pos, limit) + 1; // +1 advances past ';'
	                    }
	                }
	            }
	        }
	        gotomain:
	        ;
	        if (parsingIDs && idBlockResult.Length > 0) {
	            if (direction == IBM.ICU.Text.Transliterator.FORWARD)
	                idBlockVector.Add(idBlockResult.ToString());
	            else
	                idBlockVector.Insert(0,idBlockResult.ToString());
	        } else if (!parsingIDs && curData != null) {
	            if (direction == IBM.ICU.Text.Transliterator.FORWARD)
	                dataVector.Add(curData);
	            else
	                dataVector.Insert(0,curData);
	        }
	
	        // Convert the set vector to an array
	        for (int i_0 = 0; i_0 < dataVector.Count; i_0++) {
	            RuleBasedTransliterator.Data data = (RuleBasedTransliterator.Data) dataVector[i_0];
	            data.variables = new Object[variablesVector.Count];
	            variablesVector.CopyTo(data.variables);
	            data.variableNames = new Hashtable();
	            ILOG.J2CsMapping.Collections.Collections.PutAll(data.variableNames,variableNames);
	        }
	        variablesVector = null;
	
	        // Do more syntax checking and index the rules
	        try {
	            if (compoundFilter != null) {
	                if ((direction == IBM.ICU.Text.Transliterator.FORWARD && compoundFilterOffset != 1)
	                        || (direction == IBM.ICU.Text.Transliterator.REVERSE && compoundFilterOffset != ruleCount)) {
	                    throw new ArgumentException(
	                            "Compound filters misplaced");
	                }
	            }
	
	            for (int i_1 = 0; i_1 < dataVector.Count; i_1++) {
	                RuleBasedTransliterator.Data data_2 = (RuleBasedTransliterator.Data) dataVector[i_1];
	                data_2.ruleSet.Freeze();
	            }
	
	            if (idBlockVector.Count == 1
	                    && ((String) idBlockVector[0]).Length == 0)
	                ILOG.J2CsMapping.Collections.Collections.RemoveAt(idBlockVector,0);
	
	        } catch (ArgumentException e_3) {
	            if (errors == null) {
	                errors = new StringBuilder(e_3.Message);
	            } else {
	                errors.Append("\n").Append(e_3.Message);
	            }
	        }
	
	        if (errors != null) {
	            throw new ArgumentException(errors.ToString());
	        }
	    }
	
	    /// <summary>
	    /// MAIN PARSER. Parse the next rule in the given rule string, starting at
	    /// pos. Return the index after the last character parsed. Do not parse
	    /// characters at or after limit.
	    /// Important: The character at pos must be a non-whitespace character that
	    /// is not the comment character.
	    /// This method handles quoting, escaping, and whitespace removal. It parses
	    /// the end-of-rule character. It recognizes context and cursor indicators.
	    /// Once it does a lexical breakdown of the rule at pos, it creates a rule
	    /// object and adds it to our rule list.
	    /// This method is tightly coupled to the inner class RuleHalf.
	    /// </summary>
	    ///
	    private int ParseRule(String rule, int pos, int limit) {
	        // Locate the left side, operator, and right side
	        int start = pos;
	        char operat = (char) (0);
	
	        // Set up segments data
	        segmentStandins = new StringBuilder();
	        segmentObjects = new ArrayList();
	
	        TransliteratorParser.RuleHalf  left = new TransliteratorParser.RuleHalf ();
	        TransliteratorParser.RuleHalf  right = new TransliteratorParser.RuleHalf ();
	
	        undefinedVariableName = null;
	        pos = left.Parse(rule, pos, limit, this);
	
	        if (pos == limit
	                || OPERATORS.IndexOf(operat = rule[--pos]) < 0) {
	            SyntaxError("No operator pos=" + pos, rule, start);
	        }
	        ++pos;
	
	        // Found an operator char. Check for forward-reverse operator.
	        if (operat == REVERSE_RULE_OP
	                && (pos < limit && rule[pos] == FORWARD_RULE_OP)) {
	            ++pos;
	            operat = FWDREV_RULE_OP;
	        }
	
	        // Translate alternate op characters.
	        switch ((int) operat) {
	        case ALT_FORWARD_RULE_OP:
	            operat = FORWARD_RULE_OP;
	            break;
	        case ALT_REVERSE_RULE_OP:
	            operat = REVERSE_RULE_OP;
	            break;
	        case ALT_FWDREV_RULE_OP:
	            operat = FWDREV_RULE_OP;
	            break;
	        }
	
	        pos = right.Parse(rule, pos, limit, this);
	
	        if (pos < limit) {
	            if (rule[--pos] == END_OF_RULE) {
	                ++pos;
	            } else {
	                // RuleHalf parser must have terminated at an operator
	                SyntaxError("Unquoted operator", rule, start);
	            }
	        }
	
	        if (operat == VARIABLE_DEF_OP) {
	            // LHS is the name. RHS is a single character, either a literal
	            // or a set (already parsed). If RHS is longer than one
	            // character, it is either a multi-character string, or multiple
	            // sets, or a mixture of chars and sets -- syntax error.
	
	            // We expect to see a single undefined variable (the one being
	            // defined).
	            if (undefinedVariableName == null) {
	                SyntaxError("Missing '$' or duplicate definition", rule, start);
	            }
	            if (left.text.Length != 1 || left.text[0] != variableLimit) {
	                SyntaxError("Malformed LHS", rule, start);
	            }
	            if (left.anchorStart || left.anchorEnd || right.anchorStart
	                    || right.anchorEnd) {
	                SyntaxError("Malformed variable def", rule, start);
	            }
	            // We allow anything on the right, including an empty string.
	            int n = right.text.Length;
	            char[] value_ren = new char[n];
	            right.text.CopyTo(0,value_ren,0,n-0);
	            ILOG.J2CsMapping.Collections.Collections.Put(variableNames,undefinedVariableName,value_ren);
	
	            ++variableLimit;
	            return pos;
	        }
	
	        // If this is not a variable definition rule, we shouldn't have
	        // any undefined variable names.
	        if (undefinedVariableName != null) {
	            SyntaxError("Undefined variable $" + undefinedVariableName, rule,
	                    start);
	        }
	
	        // Verify segments
	        if (segmentStandins.Length > segmentObjects.Count) {
	            SyntaxError("Undefined segment reference", rule, start);
	        }
	        for (int i_0 = 0; i_0 < segmentStandins.Length; ++i_0) {
	            if (segmentStandins[i_0] == 0) {
	                SyntaxError("Internal error", rule, start); // will never happen
	            }
	        }
	        for (int i_1 = 0; i_1 < segmentObjects.Count; ++i_1) {
	            if (segmentObjects[i_1] == null) {
	                SyntaxError("Internal error", rule, start); // will never happen
	            }
	        }
	
	        // If the direction we want doesn't match the rule
	        // direction, do nothing.
	        if (operat != FWDREV_RULE_OP
	                && ((direction == IBM.ICU.Text.Transliterator.FORWARD) != (operat == FORWARD_RULE_OP))) {
	            return pos;
	        }
	
	        // Transform the rule into a forward rule by swapping the
	        // sides if necessary.
	        if (direction == IBM.ICU.Text.Transliterator.REVERSE) {
	            TransliteratorParser.RuleHalf  temp = left;
	            left = right;
	            right = temp;
	        }
	
	        // Remove non-applicable elements in forward-reverse
	        // rules. Bidirectional rules ignore elements that do not
	        // apply.
	        if (operat == FWDREV_RULE_OP) {
	            right.RemoveContext();
	            left.cursor = -1;
	            left.cursorOffset = 0;
	        }
	
	        // Normalize context
	        if (left.ante < 0) {
	            left.ante = 0;
	        }
	        if (left.post < 0) {
	            left.post = left.text.Length;
	        }
	
	        // Context is only allowed on the input side. Cursors are only
	        // allowed on the output side. Segment delimiters can only appear
	        // on the left, and references on the right. Cursor offset
	        // cannot appear without an explicit cursor. Cursor offset
	        // cannot place the cursor outside the limits of the context.
	        // Anchors are only allowed on the input side.
	        if (right.ante >= 0
	                || right.post >= 0
	                || left.cursor >= 0
	                || (right.cursorOffset != 0 && right.cursor < 0)
	                ||
	                // - The following two checks were used to ensure that the
	                // - the cursor offset stayed within the ante- or postcontext.
	                // - However, with the addition of quantifiers, we have to
	                // - allow arbitrary cursor offsets and do runtime checking.
	                // (right.cursorOffset > (left.text.length() - left.post)) ||
	                // (-right.cursorOffset > left.ante) ||
	                right.anchorStart || right.anchorEnd
	                || !left.IsValidInput(this) || !right.IsValidOutput(this)
	                || left.ante > left.post) {
	            SyntaxError("Malformed rule", rule, start);
	        }
	
	        // Flatten segment objects vector to an array
	        UnicodeMatcher[] segmentsArray = null;
	        if (segmentObjects.Count > 0) {
	            segmentsArray = new UnicodeMatcher[segmentObjects.Count];
	            ILOG.J2CsMapping.Collections.Collections.ToArray(segmentObjects,segmentsArray);
	        }
	
	        curData.ruleSet.AddRule(new TransliterationRule(left.text, left.ante,
	                left.post, right.text, right.cursor, right.cursorOffset,
	                segmentsArray, left.anchorStart, left.anchorEnd, curData));
	
	        return pos;
	    }
	
	    /// <summary>
	    /// Set the variable range to [start, end] (inclusive).
	    /// </summary>
	    ///
	    private void SetVariableRange(int start, int end) {
	        if (start > end || start < 0 || end > 0xFFFF) {
	            throw new ArgumentException("Invalid variable range "
	                    + start + ", " + end);
	        }
	
	        curData.variablesBase = (char) start; // first private use
	
	        if (dataVector.Count == 0) {
	            variableNext = (char) start;
	            variableLimit = (char) (end + 1);
	        }
	    }
	
	    /// <summary>
	    /// Assert that the given character is NOT within the variable range. If it
	    /// is, signal an error. This is neccesary to ensure that the variable range
	    /// does not overlap characters used in a rule.
	    /// </summary>
	    ///
	    private void CheckVariableRange(int ch, String rule, int start) {
	        if (ch >= curData.variablesBase && ch < variableLimit) {
	            SyntaxError("Variable range character in rule", rule, start);
	        }
	    }
	
	    // (The following method is part of an unimplemented feature.
	    // Remove this clover pragma after the feature is implemented.
	    // 2003-06-11 ICU 2.6 Alan)
	    // /CLOVER:OFF
	    /// <summary>
	    /// Set the maximum backup to 'backup', in response to a pragma statement.
	    /// </summary>
	    ///
	    private void PragmaMaximumBackup(int backup) {
	        // TODO Finish
	        throw new ArgumentException(
	                "use maximum backup pragma not implemented yet");
	    }
	
	    // /CLOVER:ON
	
	    // (The following method is part of an unimplemented feature.
	    // Remove this clover pragma after the feature is implemented.
	    // 2003-06-11 ICU 2.6 Alan)
	    // /CLOVER:OFF
	    /// <summary>
	    /// Begin normalizing all rules using the given mode, in response to a pragma
	    /// statement.
	    /// </summary>
	    ///
	    private void PragmaNormalizeRules(Normalizer.Mode mode) {
	        // TODO Finish
	        throw new ArgumentException(
	                "use normalize rules pragma not implemented yet");
	    }
	
	    // /CLOVER:ON
	
	    /// <summary>
	    /// Return true if the given rule looks like a pragma.
	    /// </summary>
	    ///
	    /// <param name="pos">offset to the first non-whitespace character of the rule.</param>
	    /// <param name="limit">pointer past the last character of the rule.</param>
	    static internal bool ResemblesPragma(String rule, int pos, int limit) {
	        // Must start with /use\s/i
	        return IBM.ICU.Impl.Utility.ParsePattern(rule, pos, limit, "use ", null) >= 0;
	    }
	
	    /// <summary>
	    /// Parse a pragma. This method assumes resemblesPragma() has already
	    /// returned true.
	    /// </summary>
	    ///
	    /// <param name="pos">offset to the first non-whitespace character of the rule.</param>
	    /// <param name="limit">pointer past the last character of the rule.</param>
	    /// <returns>the position index after the final ';' of the pragma, or -1 on
	    /// failure.</returns>
	    private int ParsePragma(String rule, int pos, int limit) {
	        int[] array_0 = new int[2];
	
	        // resemblesPragma() has already returned true, so we
	        // know that pos points to /use\s/i; we can skip 4 characters
	        // immediately
	        pos += 4;
	
	        // Here are the pragmas we recognize:
	        // use variable range 0xE000 0xEFFF;
	        // use maximum backup 16;
	        // use nfd rules;
	        int p = IBM.ICU.Impl.Utility.ParsePattern(rule, pos, limit, "~variable range # #~;",
	                array_0);
	        if (p >= 0) {
	            SetVariableRange(array_0[0], array_0[1]);
	            return p;
	        }
	
	        p = IBM.ICU.Impl.Utility
	                .ParsePattern(rule, pos, limit, "~maximum backup #~;", array_0);
	        if (p >= 0) {
	            PragmaMaximumBackup(array_0[0]);
	            return p;
	        }
	
	        p = IBM.ICU.Impl.Utility.ParsePattern(rule, pos, limit, "~nfd rules~;", null);
	        if (p >= 0) {
	            PragmaNormalizeRules(IBM.ICU.Text.Normalizer.NFD);
	            return p;
	        }
	
	        p = IBM.ICU.Impl.Utility.ParsePattern(rule, pos, limit, "~nfc rules~;", null);
	        if (p >= 0) {
	            PragmaNormalizeRules(IBM.ICU.Text.Normalizer.NFC);
	            return p;
	        }
	
	        // Syntax error: unable to parse pragma
	        return -1;
	    }
	
	    /// <summary>
	    /// Throw an exception indicating a syntax error. Search the rule string for
	    /// the probable end of the rule. Of course, if the error is that the end of
	    /// rule marker is missing, then the rule end will not be found. In any case
	    /// the rule start will be correctly reported.
	    /// </summary>
	    ///
	    /// <param name="msg">error description</param>
	    /// <param name="rule">pattern string</param>
	    /// <param name="start">position of first character of current rule</param>
	    static internal void SyntaxError(String msg, String rule, int start) {
	        int end = RuleEnd(rule, start, rule.Length);
	        throw new ArgumentException(msg + " in \""
	                + IBM.ICU.Impl.Utility.Escape(rule.Substring(start,(end)-(start))) + '"');
	    }
	
	    static internal int RuleEnd(String rule, int start, int limit) {
	        int end = IBM.ICU.Impl.Utility.QuotedIndexOf(rule, start, limit, ";");
	        if (end < 0) {
	            end = limit;
	        }
	        return end;
	    }
	
	    /// <summary>
	    /// Parse a UnicodeSet out, store it, and return the stand-in character used
	    /// to represent it.
	    /// </summary>
	    ///
	    private char ParseSet(String rule, ParsePosition pos) {
	        UnicodeSet set = new UnicodeSet(rule, pos, parseData);
	        if (variableNext >= variableLimit) {
	            throw new Exception("Private use variables exhausted");
	        }
	        set.Compact();
	        return GenerateStandInFor(set);
	    }
	
	    /// <summary>
	    /// Generate and return a stand-in for a new UnicodeMatcher or
	    /// UnicodeReplacer. Store the object.
	    /// </summary>
	    ///
	    internal char GenerateStandInFor(Object obj) {
	        // assert(obj != null);
	
	        // Look up previous stand-in, if any. This is a short list
	        // (typical n is 0, 1, or 2); linear search is optimal.
	        for (int i_0 = 0; i_0 < variablesVector.Count; ++i_0) {
	            if (variablesVector[i_0] == obj) { // [sic] pointer
	                                                       // comparison
	                return (char) (curData.variablesBase + i_0);
	            }
	        }
	
	        if (variableNext >= variableLimit) {
	            throw new Exception("Variable range exhausted");
	        }
	        variablesVector.Add(obj);
	        return variableNext++;
	    }
	
	    /// <summary>
	    /// Return the standin for segment seg (1-based).
	    /// </summary>
	    ///
	    public char GetSegmentStandin(int seg) {
	        if (segmentStandins.Length < seg) {
	            segmentStandins.Length=seg;
	        }
	        char c = segmentStandins[seg - 1];
	        if (c == 0) {
	            if (variableNext >= variableLimit) {
	                throw new Exception("Variable range exhausted");
	            }
	            c = variableNext++;
	            // Set a placeholder in the master variables vector that will be
	            // filled in later by setSegmentObject(). We know that we will get
	            // called first because setSegmentObject() will call us.
	            variablesVector.Add(null);
	            segmentStandins[seg - 1]=c;
	        }
	        return c;
	    }
	
	    /// <summary>
	    /// Set the object for segment seg (1-based).
	    /// </summary>
	    ///
	    public void SetSegmentObject(int seg, StringMatcher obj) {
	        // Since we call parseSection() recursively, nested
	        // segments will result in segment i+1 getting parsed
	        // and stored before segment i; be careful with the
	        // vector handling here.
	        if (segmentObjects.Count < seg) {
	            segmentObjects.RemoveRange(seg,segmentObjects.Count-seg);
	        }
	        int index = GetSegmentStandin(seg) - curData.variablesBase;
	        if (segmentObjects[seg - 1] != null
	                || variablesVector[index] != null) {
	            throw new Exception(); // should never happen
	        }
	        segmentObjects[seg - 1]=obj;
	        variablesVector[index]=obj;
	    }
	
	    /// <summary>
	    /// Return the stand-in for the dot set. It is allocated the first time and
	    /// reused thereafter.
	    /// </summary>
	    ///
	    internal char GetDotStandIn() {
	        if (dotStandIn == -1) {
	            dotStandIn = GenerateStandInFor(new UnicodeSet(DOT_SET));
	        }
	        return (char) dotStandIn;
	    }
	
	    /// <summary>
	    /// Append the value of the given variable name to the given StringBuffer.
	    /// </summary>
	    ///
	    /// <exception cref="IllegalArgumentException">if the name is unknown.</exception>
	    private void AppendVariableDef(String name, StringBuilder buf) {
	        char[] ch = (char[]) variableNames[name];
	        if (ch == null) {
	            // We allow one undefined variable so that variable definition
	            // statements work. For the first undefined variable we return
	            // the special placeholder variableLimit-1, and save the variable
	            // name.
	            if (undefinedVariableName == null) {
	                undefinedVariableName = name;
	                if (variableNext >= variableLimit) {
	                    throw new Exception(
	                            "Private use variables exhausted");
	                }
	                buf.Append((char) --variableLimit);
	            } else {
	                throw new ArgumentException("Undefined variable $"
	                        + name);
	            }
	        } else {
	            buf.Append(ch);
	        }
	    }
	}
	
	// eof
}
