//##header J2SE15
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:30 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 1996-2007, International Business Machines Corporation and    
/// others. All Rights Reserved.                                                
/// </summary>
///
namespace IBM.ICU.Text {
	
	using IBM.ICU.Impl;
	using IBM.ICU.Util;
	using ILOG.J2CsMapping.NIO;
	using ILOG.J2CsMapping.Text;
	using ILOG.J2CsMapping.Util;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Resources;
	using System.Runtime.CompilerServices;
	using System.Text;
	
	/// <summary>
	/// <p>
	/// RuleBasedCollator is a concrete subclass of Collator. It allows customization
	/// of the Collator via user-specified rule sets. RuleBasedCollator is designed
	/// to be fully compliant to the <a
	/// href="http://www.unicode.org/unicode/reports/tr10/">Unicode Collation
	/// Algorithm (UCA)</a> and conforms to ISO 14651.
	/// </p>
	/// <p>
	/// Users are strongly encouraged to read <a
	/// href="http://www.icu-project.org/userguide/Collate_Intro.html"> the users
	/// guide</a> for more information about the collation service before using this
	/// class.
	/// </p>
	/// <p>
	/// Create a RuleBasedCollator from a locale by calling the getInstance(Locale)
	/// factory method in the base class Collator. Collator.getInstance(Locale)
	/// creates a RuleBasedCollator object based on the collation rules defined by
	/// the argument locale. If a customized collation ordering ar attributes is
	/// required, use the RuleBasedCollator(String) constructor with the appropriate
	/// rules. The customized RuleBasedCollator will base its ordering on UCA, while
	/// re-adjusting the attributes and orders of the characters in the specified
	/// rule accordingly.
	/// </p>
	/// <p>
	/// RuleBasedCollator provides correct collation orders for most locales
	/// supported in ICU. If specific data for a locale is not available, the orders
	/// eventually falls back to the <a
	/// href="http://www.unicode.org/unicode/reports/tr10/">UCA collation order </a>.
	/// </p>
	/// <p>
	/// For information about the collation rule syntax and details about
	/// customization, please refer to the <a
	/// href="http://www.icu-project.org/userguide/Collate_Customization.html">
	/// Collation customization</a> section of the user's guide.
	/// </p>
	/// <p>
	/// <strong>Note</strong> that there are some differences between the Collation
	/// rule syntax used in Java and ICU4J:
	/// <ul>
	/// <li>According to the JDK documentation: <i>
	/// <p>
	/// Modifier '!' : Turns on Thai/Lao vowel-consonant swapping. If this rule is in
	/// force when a Thai vowel of the range &#92;U0E40-&#92;U0E44 precedes a Thai
	/// consonant of the range &#92;U0E01-&#92;U0E2E OR a Lao vowel of the range
	/// &#92;U0EC0-&#92;U0EC4 precedes a Lao consonant of the range
	/// &#92;U0E81-&#92;U0EAE then the vowel is placed after the consonant for
	/// collation purposes.
	/// </p>
	/// <p>
	/// If a rule is without the modifier '!', the Thai/Lao vowel-consonant swapping
	/// is not turned on.
	/// </p>
	/// </i>
	/// <p>
	/// ICU4J's RuleBasedCollator does not support turning off the Thai/Lao
	/// vowel-consonant swapping, since the UCA clearly states that it has to be
	/// supported to ensure a correct sorting order. If a '!' is encountered, it is
	/// ignored.
	/// </p>
	/// <li>As mentioned in the documentation of the base class Collator,
	/// compatibility decomposition mode is not supported.
	/// </ul>
	/// <p>
	/// <strong>Examples</strong>
	/// </p>
	/// <p>
	/// Creating Customized RuleBasedCollators: <blockquote>
	/// <pre>
	/// String simple = &quot;&amp; a &lt; b &lt; c &lt; d&quot;;
	/// RuleBasedCollator simpleCollator = new RuleBasedCollator(simple);
	/// String norwegian = &quot;&amp; a , A &lt; b , B &lt; c , C &lt; d , D &lt; e , E &quot;
	/// + &quot;&lt; f , F &lt; g , G &lt; h , H &lt; i , I &lt; j , &quot;
	/// + &quot;J &lt; k , K &lt; l , L &lt; m , M &lt; n , N &lt; &quot;
	/// + &quot;o , O &lt; p , P &lt; q , Q &amp;lt r , R &amp;lt s , S &lt; &quot;
	/// + &quot;t , T &lt; u , U &lt; v , V &lt; w , W &lt; x , X &quot;
	/// + &quot;&lt; y , Y &lt; z , Z &lt; \u00E5 = a\u030A &quot;
	/// + &quot;, \u00C5 = A\u030A ; aa , AA &lt; \u00E6 &quot;
	/// + &quot;, \u00C6 &lt; \u00F8 , \u00D8&quot;;
	/// RuleBasedCollator norwegianCollator = new RuleBasedCollator(norwegian);
	/// </pre>
	/// </blockquote>
	/// Concatenating rules to combine <c>Collator</c>s: <blockquote>
	/// <pre>
	/// // Create an en_US Collator object
	/// RuleBasedCollator en_USCollator = (RuleBasedCollator) Collator
	/// .getInstance(new Locale(&quot;en&quot;, &quot;US&quot;, &quot;&quot;));
	/// // Create a da_DK Collator object
	/// RuleBasedCollator da_DKCollator = (RuleBasedCollator) Collator
	/// .getInstance(new Locale(&quot;da&quot;, &quot;DK&quot;, &quot;&quot;));
	/// // Combine the two
	/// // First, get the collation rules from en_USCollator
	/// String en_USRules = en_USCollator.getRules();
	/// // Second, get the collation rules from da_DKCollator
	/// String da_DKRules = da_DKCollator.getRules();
	/// RuleBasedCollator newCollator = new RuleBasedCollator(en_USRules + da_DKRules);
	/// // newCollator has the combined rules
	/// </pre>
	/// </blockquote>
	/// Making changes to an existing RuleBasedCollator to create a new
	/// <c>Collator</c> object, by appending changes to the existing rule:
	/// <blockquote>
	/// <pre>
	/// // Create a new Collator object with additional rules
	/// String addRules = &quot;&amp; C &lt; ch, cH, Ch, CH&quot;;
	/// RuleBasedCollator myCollator = new RuleBasedCollator(en_USCollator.getRules()
	/// + addRules);
	/// // myCollator contains the new rules
	/// </pre>
	/// </blockquote>
	/// How to change the order of non-spacing accents: <blockquote>
	/// <pre>
	/// // old rule with main accents
	/// String oldRules = &quot;= \u0301 ; \u0300 ; \u0302 ; \u0308 &quot;
	/// + &quot;; \u0327 ; \u0303 ; \u0304 ; \u0305 &quot;
	/// + &quot;; \u0306 ; \u0307 ; \u0309 ; \u030A &quot;
	/// + &quot;; \u030B ; \u030C ; \u030D ; \u030E &quot;
	/// + &quot;; \u030F ; \u0310 ; \u0311 ; \u0312 &quot;
	/// + &quot;&lt; a , A ; ae, AE ; \u00e6 , \u00c6 &quot;
	/// + &quot;&lt; b , B &lt; c, C &lt; e, E &amp; C &lt; d , D&quot;;
	/// // change the order of accent characters
	/// String addOn = &quot;&amp; \u0300 ; \u0308 ; \u0302&quot;;
	/// RuleBasedCollator myCollator = new RuleBasedCollator(oldRules + addOn);
	/// </pre>
	/// </blockquote>
	/// Putting in a new primary ordering before the default setting, e.g. sort
	/// English characters before or after Japanese characters in the Japanese
	/// <c>Collator</c>: <blockquote>
	/// <pre>
	/// // get en_US Collator rules
	/// RuleBasedCollator en_USCollator = (RuleBasedCollator) Collator
	/// .getInstance(Locale.US);
	/// // add a few Japanese characters to sort before English characters
	/// // suppose the last character before the first base letter 'a' in
	/// // the English collation rule is \u2212
	/// String jaString = &quot;&amp; \u2212 &amp;lt \u3041, \u3042 &amp;lt \u3043, &quot; + &quot;\u3044&quot;;
	/// RuleBasedCollator myJapaneseCollator = new RuleBasedCollator(
	/// en_USCollator.getRules() + jaString);
	/// </pre>
	/// </blockquote>
	/// </p>
	/// <p>
	/// This class is not subclassable
	/// </p>
	/// </summary>
	///
	/// @stable ICU 2.8
	public sealed class RuleBasedCollator : Collator {
	    // public constructors ---------------------------------------------------
	
	    /// <summary>
	    /// <p>
	    /// Constructor that takes the argument rules for customization. The collator
	    /// will be based on UCA, with the attributes and re-ordering of the
	    /// characters specified in the argument rules.
	    /// </p>
	    /// <p>
	    /// See the user guide's section on <a
	    /// href="http://www.icu-project.org/userguide/Collate_Customization.html">
	    /// Collation Customization</a> for details on the rule syntax.
	    /// </p>
	    /// </summary>
	    ///
	    /// <param name="rules">the collation rules to build the collation table from.</param>
	    /// <exception cref="ParseException">and IOException thrown. ParseException thrown whenargument rules have an invalid syntax. IOException thrownwhen an error occured while reading internal data.</exception>
	    /// @stable ICU 2.8
	    public RuleBasedCollator(String rules) {
	        this.latinOneUse_ = false;
	        this.latinOneRegenTable_ = false;
	        this.latinOneFailed_ = false;
	        this.latinOneTableLen_ = 0;
	        this.latinOneCEs_ = null;
	        CheckUCA();
	        if (rules == null) {
	            throw new ArgumentException(
	                    "Collation rules can not be null");
	        }
	        Init(rules);
	    }
	
	    // public methods --------------------------------------------------------
	
	    /// <summary>
	    /// Clones the RuleBasedCollator
	    /// </summary>
	    ///
	    /// <returns>a new instance of this RuleBasedCollator object</returns>
	    /// @stable ICU 2.8
	    public override Object Clone() {
	        RuleBasedCollator result = (RuleBasedCollator) base.Clone();
	        if (latinOneCEs_ != null) {
	            result.m_reallocLatinOneCEs_ = true;
	            result.m_ContInfo_ = new RuleBasedCollator.ContractionInfo ();
	        }
	
	        // since all collation data in the RuleBasedCollator do not change
	        // we can safely assign the result.fields to this collator
	        result.InitUtility(false); // let the new clone have their own util
	                                   // iterators
	        return result;
	    }
	
	    /// <summary>
	    /// Return a CollationElementIterator for the given String.
	    /// </summary>
	    ///
	    /// <seealso cref="T:IBM.ICU.Text.CollationElementIterator"/>
	    /// @stable ICU 2.8
	    public CollationElementIterator GetCollationElementIterator(String source) {
	        return new CollationElementIterator(source, this);
	    }
	
	    /// <summary>
	    /// Return a CollationElementIterator for the given CharacterIterator. The
	    /// source iterator's integrity will be preserved since a new copy will be
	    /// created for use.
	    /// </summary>
	    ///
	    /// <seealso cref="T:IBM.ICU.Text.CollationElementIterator"/>
	    /// @stable ICU 2.8
	    public CollationElementIterator GetCollationElementIterator(
	            ICharacterIterator source) {
	        ICharacterIterator newsource = (ICharacterIterator) source;
	        return new CollationElementIterator(newsource, this);
	    }
	
	    /// <summary>
	    /// Return a CollationElementIterator for the given UCharacterIterator. The
	    /// source iterator's integrity will be preserved since a new copy will be
	    /// created for use.
	    /// </summary>
	    ///
	    /// <seealso cref="T:IBM.ICU.Text.CollationElementIterator"/>
	    /// @stable ICU 2.8
	    public CollationElementIterator GetCollationElementIterator(
	            UCharacterIterator source) {
	        return new CollationElementIterator(source, this);
	    }
	
	    // public setters --------------------------------------------------------
	
	    /// <summary>
	    /// Sets the Hiragana Quaternary mode to be on or off. When the Hiragana
	    /// Quaternary mode is turned on, the collator positions Hiragana characters
	    /// before all non-ignorable characters in QUATERNARY strength. This is to
	    /// produce a correct JIS collation order, distinguishing between Katakana
	    /// and Hiragana characters.
	    /// </summary>
	    ///
	    /// <param name="flag">true if Hiragana Quaternary mode is to be on, false otherwise</param>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.SetHiraganaQuaternaryDefault"/>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.IsHiraganaQuaternary"/>
	    /// @stable ICU 2.8
	    public void SetHiraganaQuaternary(bool flag) {
	        m_isHiragana4_ = flag;
	        UpdateInternalState();
	    }
	
	    /// <summary>
	    /// Sets the Hiragana Quaternary mode to the initial mode set during
	    /// construction of the RuleBasedCollator. See setHiraganaQuaternary(boolean)
	    /// for more details.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.SetHiraganaQuaternary(System.Boolean)"/>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.IsHiraganaQuaternary"/>
	    /// @stable ICU 2.8
	    public void SetHiraganaQuaternaryDefault() {
	        m_isHiragana4_ = m_defaultIsHiragana4_;
	        UpdateInternalState();
	    }
	
	    /// <summary>
	    /// Sets whether uppercase characters sort before lowercase characters or
	    /// vice versa, in strength TERTIARY. The default mode is false, and so
	    /// lowercase characters sort before uppercase characters. If true, sort
	    /// upper case characters first.
	    /// </summary>
	    ///
	    /// <param name="upperfirst">true to sort uppercase characters before lowercase characters,false to sort lowercase characters before uppercase characters</param>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.IsLowerCaseFirst"/>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.IsUpperCaseFirst"/>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.SetLowerCaseFirst(System.Boolean)"/>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.SetCaseFirstDefault"/>
	    /// @stable ICU 2.8
	    public void SetUpperCaseFirst(bool upperfirst) {
	        if (upperfirst) {
	            if (m_caseFirst_ != IBM.ICU.Text.RuleBasedCollator.AttributeValue.UPPER_FIRST_) {
	                latinOneRegenTable_ = true;
	            }
	            m_caseFirst_ = IBM.ICU.Text.RuleBasedCollator.AttributeValue.UPPER_FIRST_;
	        } else {
	            if (m_caseFirst_ != IBM.ICU.Text.RuleBasedCollator.AttributeValue.OFF_) {
	                latinOneRegenTable_ = true;
	            }
	            m_caseFirst_ = IBM.ICU.Text.RuleBasedCollator.AttributeValue.OFF_;
	        }
	        UpdateInternalState();
	    }
	
	    /// <summary>
	    /// Sets the orders of lower cased characters to sort before upper cased
	    /// characters, in strength TERTIARY. The default mode is false. If true is
	    /// set, the RuleBasedCollator will sort lower cased characters before the
	    /// upper cased ones. Otherwise, if false is set, the RuleBasedCollator will
	    /// ignore case preferences.
	    /// </summary>
	    ///
	    /// <param name="lowerfirst">true for sorting lower cased characters before upper casedcharacters, false to ignore case preferences.</param>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.IsLowerCaseFirst"/>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.IsUpperCaseFirst"/>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.SetUpperCaseFirst(System.Boolean)"/>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.SetCaseFirstDefault"/>
	    /// @stable ICU 2.8
	    public void SetLowerCaseFirst(bool lowerfirst) {
	        if (lowerfirst) {
	            if (m_caseFirst_ != IBM.ICU.Text.RuleBasedCollator.AttributeValue.LOWER_FIRST_) {
	                latinOneRegenTable_ = true;
	            }
	            m_caseFirst_ = IBM.ICU.Text.RuleBasedCollator.AttributeValue.LOWER_FIRST_;
	        } else {
	            if (m_caseFirst_ != IBM.ICU.Text.RuleBasedCollator.AttributeValue.OFF_) {
	                latinOneRegenTable_ = true;
	            }
	            m_caseFirst_ = IBM.ICU.Text.RuleBasedCollator.AttributeValue.OFF_;
	        }
	        UpdateInternalState();
	    }
	
	    /// <summary>
	    /// Sets the case first mode to the initial mode set during construction of
	    /// the RuleBasedCollator. See setUpperCaseFirst(boolean) and
	    /// setLowerCaseFirst(boolean) for more details.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.IsLowerCaseFirst"/>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.IsUpperCaseFirst"/>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.SetLowerCaseFirst(System.Boolean)"/>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.SetUpperCaseFirst(System.Boolean)"/>
	    /// @stable ICU 2.8
	    public void SetCaseFirstDefault() {
	        if (m_caseFirst_ != m_defaultCaseFirst_) {
	            latinOneRegenTable_ = true;
	        }
	        m_caseFirst_ = m_defaultCaseFirst_;
	        UpdateInternalState();
	    }
	
	    /// <summary>
	    /// Sets the alternate handling mode to the initial mode set during
	    /// construction of the RuleBasedCollator. See setAlternateHandling(boolean)
	    /// for more details.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.SetAlternateHandlingShifted(System.Boolean)"/>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.IsAlternateHandlingShifted"/>
	    /// @stable ICU 2.8
	    public void SetAlternateHandlingDefault() {
	        m_isAlternateHandlingShifted_ = m_defaultIsAlternateHandlingShifted_;
	        UpdateInternalState();
	    }
	
	    /// <summary>
	    /// Sets the case level mode to the initial mode set during construction of
	    /// the RuleBasedCollator. See setCaseLevel(boolean) for more details.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.SetCaseLevel(System.Boolean)"/>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.IsCaseLevel"/>
	    /// @stable ICU 2.8
	    public void SetCaseLevelDefault() {
	        m_isCaseLevel_ = m_defaultIsCaseLevel_;
	        UpdateInternalState();
	    }
	
	    /// <summary>
	    /// Sets the decomposition mode to the initial mode set during construction
	    /// of the RuleBasedCollator. See setDecomposition(int) for more details.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.GetDecomposition"/>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.SetDecomposition(System.Int32)"/>
	    /// @stable ICU 2.8
	    public void SetDecompositionDefault() {
	        SetDecomposition(m_defaultDecomposition_);
	        UpdateInternalState();
	    }
	
	    /// <summary>
	    /// Sets the French collation mode to the initial mode set during
	    /// construction of the RuleBasedCollator. See setFrenchCollation(boolean)
	    /// for more details.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.IsFrenchCollation"/>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.SetFrenchCollation(System.Boolean)"/>
	    /// @stable ICU 2.8
	    public void SetFrenchCollationDefault() {
	        if (m_isFrenchCollation_ != m_defaultIsFrenchCollation_) {
	            latinOneRegenTable_ = true;
	        }
	        m_isFrenchCollation_ = m_defaultIsFrenchCollation_;
	        UpdateInternalState();
	    }
	
	    /// <summary>
	    /// Sets the collation strength to the initial mode set during the
	    /// construction of the RuleBasedCollator. See setStrength(int) for more
	    /// details.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.SetStrength(System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.GetStrength"/>
	    /// @stable ICU 2.8
	    public void SetStrengthDefault() {
	        SetStrength(m_defaultStrength_);
	        UpdateInternalState();
	    }
	
	    /// <summary>
	    /// Method to set numeric collation to its default value. When numeric
	    /// collation is turned on, this Collator generates a collation key for the
	    /// numeric value of substrings of digits. This is a way to get '100' to sort
	    /// AFTER '2'
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.GetNumericCollation"/>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.SetNumericCollation(System.Boolean)"/>
	    /// @stable ICU 2.8
	    public void SetNumericCollationDefault() {
	        SetNumericCollation(m_defaultIsNumericCollation_);
	        UpdateInternalState();
	    }
	
	    /// <summary>
	    /// Sets the mode for the direction of SECONDARY weights to be used in French
	    /// collation. The default value is false, which treats SECONDARY weights in
	    /// the order they appear. If set to true, the SECONDARY weights will be
	    /// sorted backwards. See the section on <a href=
	    /// "http://www.icu-project.org/userguide/Collate_ServiceArchitecture.html">
	    /// French collation</a> for more information.
	    /// </summary>
	    ///
	    /// <param name="flag">true to set the French collation on, false to set it off</param>
	    /// @stable ICU 2.8
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.IsFrenchCollation"/>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.SetFrenchCollationDefault"/>
	    public void SetFrenchCollation(bool flag) {
	        if (m_isFrenchCollation_ != flag) {
	            latinOneRegenTable_ = true;
	        }
	        m_isFrenchCollation_ = flag;
	        UpdateInternalState();
	    }
	
	    /// <summary>
	    /// Sets the alternate handling for QUATERNARY strength to be either shifted
	    /// or non-ignorable. See the UCA definition on <a
	    /// href="http://www.unicode.org/unicode/reports/tr10/#Variable_Weighting">
	    /// Alternate Weighting</a>. This attribute will only be effective when
	    /// QUATERNARY strength is set. The default value for this mode is false,
	    /// corresponding to the NON_IGNORABLE mode in UCA. In the NON-IGNORABLE
	    /// mode, the RuleBasedCollator will treats all the codepoints with
	    /// non-ignorable primary weights in the same way. If the mode is set to
	    /// true, the behaviour corresponds to SHIFTED defined in UCA, this causes
	    /// codepoints with PRIMARY orders that are equal or below the variable top
	    /// value to be ignored in PRIMARY order and moved to the QUATERNARY order.
	    /// </summary>
	    ///
	    /// <param name="shifted">true if SHIFTED behaviour for alternate handling is desired,false for the NON_IGNORABLE behaviour.</param>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.IsAlternateHandlingShifted"/>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.SetAlternateHandlingDefault"/>
	    /// @stable ICU 2.8
	    public void SetAlternateHandlingShifted(bool shifted) {
	        m_isAlternateHandlingShifted_ = shifted;
	        UpdateInternalState();
	    }
	
	    /// <summary>
	    /// <p>
	    /// When case level is set to true, an additional weight is formed between
	    /// the SECONDARY and TERTIARY weight, known as the case level. The case
	    /// level is used to distinguish large and small Japanese Kana characters.
	    /// Case level could also be used in other situations. For example to
	    /// distinguish certain Pinyin characters. The default value is false, which
	    /// means the case level is not generated. The contents of the case level are
	    /// affected by the case first mode. A simple way to ignore accent
	    /// differences in a string is to set the strength to PRIMARY and enable case
	    /// level.
	    /// </p>
	    /// <p>
	    /// See the section on <a href=
	    /// "http://www.icu-project.org/userguide/Collate_ServiceArchitecture.html">
	    /// case level</a> for more information.
	    /// </p>
	    /// </summary>
	    ///
	    /// <param name="flag">true if case level sorting is required, false otherwise</param>
	    /// @stable ICU 2.8
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.SetCaseLevelDefault"/>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.IsCaseLevel"/>
	    public void SetCaseLevel(bool flag) {
	        m_isCaseLevel_ = flag;
	        UpdateInternalState();
	    }
	
	    /// <summary>
	    /// <p>
	    /// Sets this Collator's strength property. The strength property determines
	    /// the minimum level of difference considered significant during comparison.
	    /// </p>
	    /// <p>
	    /// See the Collator class description for an example of use.
	    /// </p>
	    /// </summary>
	    ///
	    /// <param name="newStrength">the new strength value.</param>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.GetStrength"/>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.SetStrengthDefault"/>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.PRIMARY"/>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.SECONDARY"/>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.TERTIARY"/>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.QUATERNARY"/>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.IDENTICAL"/>
	    /// <exception cref="IllegalArgumentException">If the new strength value is not one of PRIMARY,SECONDARY, TERTIARY, QUATERNARY or IDENTICAL.</exception>
	    /// @stable ICU 2.8
	    public override void SetStrength(int newStrength) {
	        base.SetStrength(newStrength);
	        UpdateInternalState();
	    }
	
	    /// <summary>
	    /// <p>
	    /// Variable top is a two byte primary value which causes all the codepoints
	    /// with primary values that are less or equal than the variable top to be
	    /// shifted when alternate handling is set to SHIFTED.
	    /// </p>
	    /// <p>
	    /// Sets the variable top to a collation element value of a string supplied.
	    /// </p>
	    /// </summary>
	    ///
	    /// <param name="varTop">one or more (if contraction) characters to which the variabletop should be set</param>
	    /// <returns>a int value containing the value of the variable top in upper 16
	    /// bits. Lower 16 bits are undefined.</returns>
	    /// <exception cref="IllegalArgumentException">is thrown if varTop argument is not a valid variable topelement. A variable top element is invalid when<ul><li>it is a contraction that does not exist in theCollation order<li>when the PRIMARY strength collation element for thevariable top has more than two bytes<li>when the varTop argument is null or zero in length.</ul></exception>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.GetVariableTop"/>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.SetAlternateHandlingShifted(System.Boolean)"/>
	    /// @stable ICU 2.6
	    public override int SetVariableTop(String varTop) {
	        if (varTop == null || varTop.Length == 0) {
	            throw new ArgumentException(
	                    "Variable top argument string can not be null or zero in length.");
	        }
	        if (m_srcUtilIter_ == null) {
	            InitUtility(true);
	        }
	
	        m_srcUtilColEIter_.SetText(varTop);
	        int ce = m_srcUtilColEIter_.Next();
	
	        // here we check if we have consumed all characters
	        // you can put in either one character or a contraction
	        // you shouldn't put more...
	        if (m_srcUtilColEIter_.GetOffset() != varTop.Length
	                || ce == IBM.ICU.Text.CollationElementIterator.NULLORDER) {
	            throw new ArgumentException(
	                    "Variable top argument string is a contraction that does not exist "
	                            + "in the Collation order");
	        }
	
	        int nextCE = m_srcUtilColEIter_.Next();
	
	        if ((nextCE != IBM.ICU.Text.CollationElementIterator.NULLORDER)
	                && (!IsContinuation(nextCE) || (nextCE & CE_PRIMARY_MASK_) != 0)) {
	            throw new ArgumentException(
	                    "Variable top argument string can only have a single collation "
	                            + "element that has less than or equal to two PRIMARY strength "
	                            + "bytes");
	        }
	
	        m_variableTopValue_ = (ce & CE_PRIMARY_MASK_) >> 16;
	
	        return ce & CE_PRIMARY_MASK_;
	    }
	
	    /// <summary>
	    /// Sets the variable top to a collation element value supplied. Variable top
	    /// is set to the upper 16 bits. Lower 16 bits are ignored.
	    /// </summary>
	    ///
	    /// <param name="varTop">Collation element value, as returned by setVariableTop orgetVariableTop</param>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.GetVariableTop"/>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.SetVariableTop(System.String)"/>
	    /// @stable ICU 2.6
	    public override void SetVariableTop(int varTop) {
	        m_variableTopValue_ = (varTop & CE_PRIMARY_MASK_) >> 16;
	    }
	
	    /// <summary>
	    /// When numeric collation is turned on, this Collator generates a collation
	    /// key for the numeric value of substrings of digits. This is a way to get
	    /// '100' to sort AFTER '2'
	    /// </summary>
	    ///
	    /// <param name="flag">true to turn numeric collation on and false to turn it off</param>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.GetNumericCollation"/>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.SetNumericCollationDefault"/>
	    /// @stable ICU 2.8
	    public void SetNumericCollation(bool flag) {
	        // sort substrings of digits as numbers
	        m_isNumericCollation_ = flag;
	        UpdateInternalState();
	    }
	
	    // public getters --------------------------------------------------------
	
	    /// <summary>
	    /// Gets the collation rules for this RuleBasedCollator. Equivalent to String
	    /// getRules(RuleOption.FULL_RULES).
	    /// </summary>
	    ///
	    /// <returns>returns the collation rules</returns>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.GetRules(System.Boolean)"/>
	    /// @stable ICU 2.8
	    public String GetRules() {
	        return m_rules_;
	    }
	
	    /// <summary>
	    /// Returns current rules. The argument defines whether full rules (UCA +
	    /// tailored) rules are returned or just the tailoring.
	    /// </summary>
	    ///
	    /// <param name="fullrules">true if the rules that defines the full set of collation orderis required, otherwise false for returning only the tailoredrules</param>
	    /// <returns>the current rules that defines this Collator.</returns>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.GetRules"/>
	    /// @stable ICU 2.6
	    public String GetRules(bool fullrules) {
	        if (!fullrules) {
	            return m_rules_;
	        }
	        // take the UCA rules and append real rules at the end
	        return String.Concat(UCA_.m_rules_,m_rules_);
	    }
	
	    /// <summary>
	    /// Get an UnicodeSet that contains all the characters and sequences tailored
	    /// in this collator.
	    /// </summary>
	    ///
	    /// <returns>a pointer to a UnicodeSet object containing all the code points
	    /// and sequences that may sort differently than in the UCA.</returns>
	    /// <exception cref="ParseException">thrown when argument rules have an invalid syntax.IOException</exception>
	    /// @stable ICU 2.4
	    public override UnicodeSet GetTailoredSet() {
	        try {
	            CollationRuleParser src = new CollationRuleParser(GetRules());
	            return src.GetTailoredSet();
	        } catch (Exception e) {
	            throw new InvalidOperationException("A tailoring rule should not "
	                    + "have errors. Something is quite wrong!");
	        }
	    }
	
	    private class contContext {
	        internal RuleBasedCollator coll;
	
	        internal UnicodeSet contractions;
	
	        internal UnicodeSet expansions;
	
	        internal UnicodeSet removedContractions;
	
	        internal bool addPrefixes;
	
	        internal contContext(RuleBasedCollator coll_0, UnicodeSet contractions_1,
	                UnicodeSet expansions_2, UnicodeSet removedContractions_3,
	                bool addPrefixes_4) {
	            this.coll = coll_0;
	            this.contractions = contractions_1;
	            this.expansions = expansions_2;
	            this.removedContractions = removedContractions_3;
	            this.addPrefixes = addPrefixes_4;
	        }
	    }
	
	    private void AddSpecial(RuleBasedCollator.contContext  c, StringBuilder buffer, int CE) {
	        StringBuilder b = new StringBuilder();
	        int offset = (CE & 0xFFFFFF) - c.coll.m_contractionOffset_;
	        int newCE = c.coll.m_contractionCE_[offset];
	        // we might have a contraction that ends from previous level
	        if (newCE != IBM.ICU.Text.CollationElementIterator.CE_NOT_FOUND_) {
	            if (IsSpecial(CE)
	                    && GetTag(CE) == IBM.ICU.Text.CollationElementIterator.CE_CONTRACTION_TAG_
	                    && IsSpecial(newCE)
	                    && GetTag(newCE) == IBM.ICU.Text.CollationElementIterator.CE_SPEC_PROC_TAG_
	                    && c.addPrefixes) {
	                AddSpecial(c, buffer, newCE);
	            }
	            if (buffer.Length > 1) {
	                if (c.contractions != null) {
	                    c.contractions.Add(buffer.ToString());
	                }
	                if (c.expansions != null
	                        && IsSpecial(CE)
	                        && GetTag(CE) == IBM.ICU.Text.CollationElementIterator.CE_EXPANSION_TAG_) {
	                    c.expansions.Add(buffer.ToString());
	                }
	            }
	        }
	
	        offset++;
	        // check whether we're doing contraction or prefix
	        if (GetTag(CE) == IBM.ICU.Text.CollationElementIterator.CE_SPEC_PROC_TAG_
	                && c.addPrefixes) {
	            while (c.coll.m_contractionIndex_[offset] != 0xFFFF) {
	                b.Remove(0,b.Length-(0));
	                b.Append(buffer);
	                newCE = c.coll.m_contractionCE_[offset];
	                b.Insert(0, c.coll.m_contractionIndex_[offset]);
	                if (IsSpecial(newCE)
	                        && (GetTag(newCE) == IBM.ICU.Text.CollationElementIterator.CE_CONTRACTION_TAG_ || GetTag(newCE) == IBM.ICU.Text.CollationElementIterator.CE_SPEC_PROC_TAG_)) {
	                    AddSpecial(c, b, newCE);
	                } else {
	                    if (c.contractions != null) {
	                        c.contractions.Add(b.ToString());
	                    }
	                    if (c.expansions != null
	                            && IsSpecial(newCE)
	                            && GetTag(newCE) == IBM.ICU.Text.CollationElementIterator.CE_EXPANSION_TAG_) {
	                        c.expansions.Add(b.ToString());
	                    }
	                }
	                offset++;
	            }
	        } else if (GetTag(CE) == IBM.ICU.Text.CollationElementIterator.CE_CONTRACTION_TAG_) {
	            while (c.coll.m_contractionIndex_[offset] != 0xFFFF) {
	                b.Remove(0,b.Length-(0));
	                b.Append(buffer);
	                newCE = c.coll.m_contractionCE_[offset];
	                b.Append(c.coll.m_contractionIndex_[offset]);
	                if (IsSpecial(newCE)
	                        && (GetTag(newCE) == IBM.ICU.Text.CollationElementIterator.CE_CONTRACTION_TAG_ || GetTag(newCE) == IBM.ICU.Text.CollationElementIterator.CE_SPEC_PROC_TAG_)) {
	                    AddSpecial(c, b, newCE);
	                } else {
	                    if (c.contractions != null) {
	                        c.contractions.Add(b.ToString());
	                    }
	                    if (c.expansions != null
	                            && IsSpecial(newCE)
	                            && GetTag(newCE) == IBM.ICU.Text.CollationElementIterator.CE_EXPANSION_TAG_) {
	                        c.expansions.Add(b.ToString());
	                    }
	                }
	                offset++;
	            }
	        }
	    }
	
	    private void ProcessSpecials(RuleBasedCollator.contContext  c) {
	        int internalBufferSize = 512;
	        TrieIterator trieiterator = new TrieIterator(c.coll.m_trie_);
	        RangeValueIterator_Constants.Element element = new RangeValueIterator_Constants.Element();
	        while (trieiterator.Next(element)) {
	            int start = element.start;
	            int limit = element.limit;
	            int CE = element.value_ren;
	            StringBuilder contraction = new StringBuilder(internalBufferSize);
	
	            if (IsSpecial(CE)) {
	                if (((GetTag(CE) == IBM.ICU.Text.CollationElementIterator.CE_SPEC_PROC_TAG_ && c.addPrefixes) || GetTag(CE) == IBM.ICU.Text.CollationElementIterator.CE_CONTRACTION_TAG_)) {
	                    while (start < limit) {
	                        // if there are suppressed contractions, we don't
	                        // want to add them.
	                        if (c.removedContractions != null
	                                && c.removedContractions.Contains(start)) {
	                            start++;
	                            continue;
	                        }
	                        // we start our contraction from middle, since we don't
	                        // know if it
	                        // will grow toward right or left
	                        contraction.Append((char) start);
	                        AddSpecial(c, contraction, CE);
	                        start++;
	                    }
	                } else if (c.expansions != null
	                        && GetTag(CE) == IBM.ICU.Text.CollationElementIterator.CE_EXPANSION_TAG_) {
	                    while (start < limit) {
	                        c.expansions.Add(start++);
	                    }
	                }
	            }
	        }
	    }
	
	    /// <summary>
	    /// Gets unicode sets containing contractions and/or expansions of a collator
	    /// </summary>
	    ///
	    /// <param name="contractions_0">if not null, set to contain contractions</param>
	    /// <param name="expansions_1">if not null, set to contain expansions</param>
	    /// <param name="addPrefixes_2">add the prefix contextual elements to contractions</param>
	    /// <exception cref="Exception"></exception>
	    /// @stable ICU 3.4
	    public void GetContractionsAndExpansions(UnicodeSet contractions_0,
	            UnicodeSet expansions_1, bool addPrefixes_2) {
	        if (contractions_0 != null) {
	            contractions_0.Clear();
	        }
	        if (expansions_1 != null) {
	            expansions_1.Clear();
	        }
	        String rules = GetRules();
	        try {
	            CollationRuleParser src = new CollationRuleParser(rules);
	            RuleBasedCollator.contContext  c = new RuleBasedCollator.contContext (RuleBasedCollator.UCA_,
	                    contractions_0, expansions_1, src.m_removeSet_, addPrefixes_2);
	
	            // Add the UCA contractions
	            ProcessSpecials(c);
	            // This is collator specific. Add contractions from a collator
	            c.coll = this;
	            c.removedContractions = null;
	            ProcessSpecials(c);
	        } catch (Exception e) {
	            throw e;
	        }
	    }
	
	    /// <summary>
	    /// <p>
	    /// Get a Collation key for the argument String source from this
	    /// RuleBasedCollator.
	    /// </p>
	    /// <p>
	    /// General recommendation: <br>
	    /// If comparison are to be done to the same String multiple times, it would
	    /// be more efficient to generate CollationKeys for the Strings and use
	    /// CollationKey.compareTo(CollationKey) for the comparisons. If the each
	    /// Strings are compared to only once, using the method
	    /// RuleBasedCollator.compare(String, String) will have a better performance.
	    /// </p>
	    /// <p>
	    /// See the class documentation for an explanation about CollationKeys.
	    /// </p>
	    /// </summary>
	    ///
	    /// <param name="source">the text String to be transformed into a collation key.</param>
	    /// <returns>the CollationKey for the given String based on this
	    /// RuleBasedCollator's collation rules. If the source String is
	    /// null, a null CollationKey is returned.</returns>
	    /// <seealso cref="T:IBM.ICU.Text.CollationKey"/>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.Compare(System.String, System.String)"/>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.GetRawCollationKey(System.String, IBM.ICU.Text.RawCollationKey)"/>
	    /// @stable ICU 2.8
	    public override CollationKey GetCollationKey(String source) {
	        if (source == null) {
	            return null;
	        }
	        m_utilRawCollationKey_ = GetRawCollationKey(source,
	                m_utilRawCollationKey_);
	        return new CollationKey(source, m_utilRawCollationKey_);
	    }
	
	    /// <summary>
	    /// Gets the simpler form of a CollationKey for the String source following
	    /// the rules of this Collator and stores the result into the user provided
	    /// argument key. If key has a internal byte array of length that's too small
	    /// for the result, the internal byte array will be grown to the exact
	    /// required size.
	    /// </summary>
	    ///
	    /// <param name="source">the text String to be transformed into a RawCollationKey</param>
	    /// <param name="key">output RawCollationKey to store results</param>
	    /// <returns>If key is null, a new instance of RawCollationKey will be created
	    /// and returned, otherwise the user provided key will be returned.</returns>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.GetCollationKey(System.String)"/>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.Compare(System.String, System.String)"/>
	    /// <seealso cref="T:IBM.ICU.Text.RawCollationKey"/>
	    /// @stable ICU 2.8
	    public override RawCollationKey GetRawCollationKey(String source, RawCollationKey key) {
	        if (source == null) {
	            return null;
	        }
	        int strength = GetStrength();
	        m_utilCompare0_ = m_isCaseLevel_;
	        // m_utilCompare1_ = true;
	        m_utilCompare2_ = strength >= IBM.ICU.Text.Collator.SECONDARY;
	        m_utilCompare3_ = strength >= IBM.ICU.Text.Collator.TERTIARY;
	        m_utilCompare4_ = strength >= IBM.ICU.Text.Collator.QUATERNARY;
	        m_utilCompare5_ = strength == IBM.ICU.Text.Collator.IDENTICAL;
	
	        m_utilBytesCount0_ = 0;
	        m_utilBytesCount1_ = 0;
	        m_utilBytesCount2_ = 0;
	        m_utilBytesCount3_ = 0;
	        m_utilBytesCount4_ = 0;
	        // m_utilBytesCount5_ = 0;
	        // m_utilCount0_ = 0;
	        // m_utilCount1_ = 0;
	        m_utilCount2_ = 0;
	        m_utilCount3_ = 0;
	        m_utilCount4_ = 0;
	        // m_utilCount5_ = 0;
	        bool doFrench = m_isFrenchCollation_ && m_utilCompare2_;
	        // TODO: UCOL_COMMON_BOT4 should be a function of qShifted.
	        // If we have no qShifted, we don't need to set UCOL_COMMON_BOT4 so
	        // high.
	        int commonBottom4 = (((int) (((uint) m_variableTopValue_) >> 8)) + 1) & LAST_BYTE_MASK_;
	        byte hiragana4 = 0;
	        if (m_isHiragana4_ && m_utilCompare4_) {
	            // allocate one more space for hiragana, value for hiragana
	            hiragana4 = (byte) commonBottom4;
	            commonBottom4++;
	        }
	
	        int bottomCount4 = 0xFF - commonBottom4;
	        // If we need to normalize, we'll do it all at once at the beginning!
	        if (m_utilCompare5_
	                && IBM.ICU.Text.Normalizer.QuickCheck(source, IBM.ICU.Text.Normalizer.NFD, 0) != IBM.ICU.Text.Normalizer.YES) {
	            // if it is identical strength, we have to normalize the string to
	            // NFD so that it will be appended correctly to the end of the sort
	            // key
	            source = IBM.ICU.Text.Normalizer.Decompose(source, false);
	        } else if (GetDecomposition() != IBM.ICU.Text.Collator.NO_DECOMPOSITION
	                && IBM.ICU.Text.Normalizer.QuickCheck(source, IBM.ICU.Text.Normalizer.FCD, 0) != IBM.ICU.Text.Normalizer.YES) {
	            // for the rest of the strength, if decomposition is on, FCD is
	            // enough for us to work on.
	            source = IBM.ICU.Text.Normalizer.Normalize(source, IBM.ICU.Text.Normalizer.FCD);
	        }
	        GetSortKeyBytes(source, doFrench, hiragana4, commonBottom4,
	                bottomCount4);
	        if (key == null) {
	            key = new RawCollationKey();
	        }
	        GetSortKey(source, doFrench, commonBottom4, bottomCount4, key);
	        return key;
	    }
	
	    /// <summary>
	    /// Return true if an uppercase character is sorted before the corresponding
	    /// lowercase character. See setCaseFirst(boolean) for details.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.SetUpperCaseFirst(System.Boolean)"/>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.SetLowerCaseFirst(System.Boolean)"/>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.IsLowerCaseFirst"/>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.SetCaseFirstDefault"/>
	    /// <returns>true if upper cased characters are sorted before lower cased
	    /// characters, false otherwise</returns>
	    /// @stable ICU 2.8
	    public bool IsUpperCaseFirst() {
	        return (m_caseFirst_ == IBM.ICU.Text.RuleBasedCollator.AttributeValue.UPPER_FIRST_);
	    }
	
	    /// <summary>
	    /// Return true if a lowercase character is sorted before the corresponding
	    /// uppercase character. See setCaseFirst(boolean) for details.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.SetUpperCaseFirst(System.Boolean)"/>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.SetLowerCaseFirst(System.Boolean)"/>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.IsUpperCaseFirst"/>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.SetCaseFirstDefault"/>
	    /// <returns>true lower cased characters are sorted before upper cased
	    /// characters, false otherwise</returns>
	    /// @stable ICU 2.8
	    public bool IsLowerCaseFirst() {
	        return (m_caseFirst_ == IBM.ICU.Text.RuleBasedCollator.AttributeValue.LOWER_FIRST_);
	    }
	
	    /// <summary>
	    /// Checks if the alternate handling behaviour is the UCA defined SHIFTED or
	    /// NON_IGNORABLE. If return value is true, then the alternate handling
	    /// attribute for the Collator is SHIFTED. Otherwise if return value is
	    /// false, then the alternate handling attribute for the Collator is
	    /// NON_IGNORABLE See setAlternateHandlingShifted(boolean) for more details.
	    /// </summary>
	    ///
	    /// <returns>true or false</returns>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.SetAlternateHandlingShifted(System.Boolean)"/>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.SetAlternateHandlingDefault"/>
	    /// @stable ICU 2.8
	    public bool IsAlternateHandlingShifted() {
	        return m_isAlternateHandlingShifted_;
	    }
	
	    /// <summary>
	    /// Checks if case level is set to true. See setCaseLevel(boolean) for
	    /// details.
	    /// </summary>
	    ///
	    /// <returns>the case level mode</returns>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.SetCaseLevelDefault"/>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.IsCaseLevel"/>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.SetCaseLevel(System.Boolean)"/>
	    /// @stable ICU 2.8
	    public bool IsCaseLevel() {
	        return m_isCaseLevel_;
	    }
	
	    /// <summary>
	    /// Checks if French Collation is set to true. See
	    /// setFrenchCollation(boolean) for details.
	    /// </summary>
	    ///
	    /// <returns>true if French Collation is set to true, false otherwise</returns>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.SetFrenchCollation(System.Boolean)"/>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.SetFrenchCollationDefault"/>
	    /// @stable ICU 2.8
	    public bool IsFrenchCollation() {
	        return m_isFrenchCollation_;
	    }
	
	    /// <summary>
	    /// Checks if the Hiragana Quaternary mode is set on. See
	    /// setHiraganaQuaternary(boolean) for more details.
	    /// </summary>
	    ///
	    /// <returns>flag true if Hiragana Quaternary mode is on, false otherwise</returns>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.SetHiraganaQuaternaryDefault"/>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.SetHiraganaQuaternary(System.Boolean)"/>
	    /// @stable ICU 2.8
	    public bool IsHiraganaQuaternary() {
	        return m_isHiragana4_;
	    }
	
	    /// <summary>
	    /// Gets the variable top value of a Collator. Lower 16 bits are undefined
	    /// and should be ignored.
	    /// </summary>
	    ///
	    /// <returns>the variable top value of a Collator.</returns>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.SetVariableTop(System.String)"/>
	    /// @stable ICU 2.6
	    public override int GetVariableTop() {
	        return m_variableTopValue_ << 16;
	    }
	
	    /// <summary>
	    /// Method to retrieve the numeric collation value. When numeric collation is
	    /// turned on, this Collator generates a collation key for the numeric value
	    /// of substrings of digits. This is a way to get '100' to sort AFTER '2'
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.SetNumericCollation(System.Boolean)"/>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.SetNumericCollationDefault"/>
	    /// <returns>true if numeric collation is turned on, false otherwise</returns>
	    /// @stable ICU 2.8
	    public bool GetNumericCollation() {
	        return m_isNumericCollation_;
	    }
	
	    // public other methods -------------------------------------------------
	
	    /// <summary>
	    /// Compares the equality of two RuleBasedCollator objects. RuleBasedCollator
	    /// objects are equal if they have the same collation rules and the same
	    /// attributes.
	    /// </summary>
	    ///
	    /// <param name="obj">the RuleBasedCollator to be compared to.</param>
	    /// <returns>true if this RuleBasedCollator has exactly the same collation
	    /// behaviour as obj, false otherwise.</returns>
	    /// @stable ICU 2.8
	    public override bool Equals(Object obj) {
	        if (obj == null) {
	            return false; // super does class check
	        }
	        if ((Object) this == obj) {
	            return true;
	        }
	        if ((Object) GetType() != (Object) obj.GetType()) {
	            return false;
	        }
	        RuleBasedCollator other = (RuleBasedCollator) obj;
	        // all other non-transient information is also contained in rules.
	        if (GetStrength() != other.GetStrength()
	                || GetDecomposition() != other.GetDecomposition()
	                || other.m_caseFirst_ != m_caseFirst_
	                || other.m_caseSwitch_ != m_caseSwitch_
	                || other.m_isAlternateHandlingShifted_ != m_isAlternateHandlingShifted_
	                || other.m_isCaseLevel_ != m_isCaseLevel_
	                || other.m_isFrenchCollation_ != m_isFrenchCollation_
	                || other.m_isHiragana4_ != m_isHiragana4_) {
	            return false;
	        }
	        bool rules = m_rules_ == other.m_rules_;
	        if (!rules && (m_rules_ != null && other.m_rules_ != null)) {
	            rules = m_rules_.Equals(other.m_rules_);
	        }
	        if (!rules || !IBM.ICU.Impl.ICUDebug.Enabled("collation")) {
	            return rules;
	        }
	        if (m_addition3_ != other.m_addition3_
	                || m_bottom3_ != other.m_bottom3_
	                || m_bottomCount3_ != other.m_bottomCount3_
	                || m_common3_ != other.m_common3_
	                || m_isSimple3_ != other.m_isSimple3_
	                || m_mask3_ != other.m_mask3_
	                || m_minContractionEnd_ != other.m_minContractionEnd_
	                || m_minUnsafe_ != other.m_minUnsafe_
	                || m_top3_ != other.m_top3_
	                || m_topCount3_ != other.m_topCount3_
	                || !ILOG.J2CsMapping.Collections.Arrays.Equals(m_unsafe_,other.m_unsafe_)) {
	            return false;
	        }
	        if (!m_trie_.Equals(other.m_trie_)) {
	            // we should use the trie iterator here, but then this part is
	            // only used in the test.
	            for (int i = IBM.ICU.Lang.UCharacter.MAX_VALUE; i >= IBM.ICU.Lang.UCharacter.MIN_VALUE; i--) {
	                int v = m_trie_.GetCodePointValue(i);
	                int otherv = other.m_trie_.GetCodePointValue(i);
	                if (v != otherv) {
	                    int mask = v & (CE_TAG_MASK_ | CE_SPECIAL_FLAG_);
	                    if (mask == (otherv & -16777216)) {
	                        v &= 0xffffff;
	                        otherv &= 0xffffff;
	                        if (mask == -251658240) {
	                            v -= (m_expansionOffset_ << 4);
	                            otherv -= (other.m_expansionOffset_ << 4);
	                        } else if (mask == -234881024) {
	                            v -= m_contractionOffset_;
	                            otherv -= other.m_contractionOffset_;
	                        }
	                        if (v == otherv) {
	                            continue;
	                        }
	                    }
	                    return false;
	                }
	            }
	        }
	        if (ILOG.J2CsMapping.Collections.Arrays.Equals(m_contractionCE_,other.m_contractionCE_)
	                && ILOG.J2CsMapping.Collections.Arrays.Equals(m_contractionEnd_,other.m_contractionEnd_)
	                && ILOG.J2CsMapping.Collections.Arrays.Equals(m_contractionIndex_,other.m_contractionIndex_)
	                && ILOG.J2CsMapping.Collections.Arrays.Equals(m_expansion_,other.m_expansion_)
	                && ILOG.J2CsMapping.Collections.Arrays.Equals(m_expansionEndCE_,other.m_expansionEndCE_)) {
	            // not comparing paddings
	            for (int i_0 = 0; i_0 < m_expansionEndCE_.Length; i_0++) {
	                if (m_expansionEndCEMaxSize_[i_0] != other.m_expansionEndCEMaxSize_[i_0]) {
	                    return false;
	                }
	                return true;
	            }
	        }
	        return false;
	    }
	
	    /// <summary>
	    /// Generates a unique hash code for this RuleBasedCollator.
	    /// </summary>
	    ///
	    /// <returns>the unique hash code for this Collator</returns>
	    /// @stable ICU 2.8
	    public override int GetHashCode() {
	        String rules = GetRules();
	        if (rules == null) {
	            rules = "";
	        }
	        return rules.GetHashCode();
	    }
	
	    /// <summary>
	    /// Compares the source text String to the target text String according to
	    /// the collation rules, strength and decomposition mode for this
	    /// RuleBasedCollator. Returns an integer less than, equal to or greater than
	    /// zero depending on whether the source String is less than, equal to or
	    /// greater than the target String. See the Collator class description for an
	    /// example of use. </p>
	    /// <p>
	    /// General recommendation: <br>
	    /// If comparison are to be done to the same String multiple times, it would
	    /// be more efficient to generate CollationKeys for the Strings and use
	    /// CollationKey.compareTo(CollationKey) for the comparisons. If speed
	    /// performance is critical and object instantiation is to be reduced,
	    /// further optimization may be achieved by generating a simpler key of the
	    /// form RawCollationKey and reusing this RawCollationKey object with the
	    /// method RuleBasedCollator.getRawCollationKey. Internal byte representation
	    /// can be directly accessed via RawCollationKey and stored for future use.
	    /// Like CollationKey, RawCollationKey provides a method
	    /// RawCollationKey.compareTo for key comparisons. If the each Strings are
	    /// compared to only once, using the method RuleBasedCollator.compare(String,
	    /// String) will have a better performance.
	    /// </p>
	    /// </summary>
	    ///
	    /// <param name="source">the source text String.</param>
	    /// <param name="target">the target text String.</param>
	    /// <returns>Returns an integer value. Value is less than zero if source is
	    /// less than target, value is zero if source and target are equal,
	    /// value is greater than zero if source is greater than target.</returns>
	    /// <seealso cref="T:IBM.ICU.Text.CollationKey"/>
	    /// <seealso cref="M:IBM.ICU.Text.RuleBasedCollator.GetCollationKey(System.String)"/>
	    /// @stable ICU 2.8
	    public override int Compare(String source, String target) {
	        if (source == target) {
	            return 0;
	        }
	
	        // Find the length of any leading portion that is equal
	        int offset = GetFirstUnmatchedOffset(source, target);
	        // return compareRegular(source, target, offset);
	        if (latinOneUse_) {
	            if ((offset < source.Length && source[offset] > ENDOFLATINONERANGE_)
	                    || (offset < target.Length && target[offset] > ENDOFLATINONERANGE_)) {
	                // source or target start with non-latin-1
	                return CompareRegular(source, target, offset);
	            } else {
	                return CompareUseLatin1(source, target, offset);
	            }
	        } else {
	            return CompareRegular(source, target, offset);
	        }
	    }
	
	    // package private inner interfaces --------------------------------------
	
	    /// <summary>
	    /// Attribute values to be used when setting the Collator options
	    /// </summary>
	    ///
	    public class AttributeValue {
	        /// <summary>
	        /// Indicates that the default attribute value will be used. See
	        /// individual attribute for details on its default value.
	        /// </summary>
	        ///
            public static int DEFAULT_ = -1;
	
	        /// <summary>
	        /// Primary collation strength
	        /// </summary>
	        ///
            public static int PRIMARY_ = IBM.ICU.Text.Collator.PRIMARY;
	
	        /// <summary>
	        /// Secondary collation strength
	        /// </summary>
	        ///
            public static int SECONDARY_ = IBM.ICU.Text.Collator.SECONDARY;
	
	        /// <summary>
	        /// Tertiary collation strength
	        /// </summary>
	        ///
            public static int TERTIARY_ = IBM.ICU.Text.Collator.TERTIARY;
	
	        /// <summary>
	        /// Default collation strength
	        /// </summary>
	        ///
            public static int DEFAULT_STRENGTH_ = IBM.ICU.Text.Collator.TERTIARY;
	
	        /// <summary>
	        /// Internal use for strength checks in Collation elements
	        /// </summary>
	        ///
            public static int CE_STRENGTH_LIMIT_ = IBM.ICU.Text.Collator.TERTIARY + 1;
	
	        /// <summary>
	        /// Quaternary collation strength
	        /// </summary>
	        ///
            public static int QUATERNARY_ = 3;
	
	        /// <summary>
	        /// Identical collation strength
	        /// </summary>
	        ///
            public static int IDENTICAL_ = IBM.ICU.Text.Collator.IDENTICAL;
	
	        /// <summary>
	        /// Internal use for strength checks
	        /// </summary>
	        ///
            public static int STRENGTH_LIMIT_ = IBM.ICU.Text.Collator.IDENTICAL + 1;
	
	        /// <summary>
	        /// Turn the feature off - works for FRENCH_COLLATION, CASE_LEVEL,
	        /// HIRAGANA_QUATERNARY_MODE and DECOMPOSITION_MODE
	        /// </summary>
	        ///
            public static int OFF_ = 16;
	
	        /// <summary>
	        /// Turn the feature on - works for FRENCH_COLLATION, CASE_LEVEL,
	        /// HIRAGANA_QUATERNARY_MODE and DECOMPOSITION_MODE
	        /// </summary>
	        ///
            public static int ON_ = 17;
	
	        /// <summary>
	        /// Valid for ALTERNATE_HANDLING. Alternate handling will be shifted
	        /// </summary>
	        ///
            public static int SHIFTED_ = 20;
	
	        /// <summary>
	        /// Valid for ALTERNATE_HANDLING. Alternate handling will be non
	        /// ignorable
	        /// </summary>
	        ///
            public static int NON_IGNORABLE_ = 21;
	
	        /// <summary>
	        /// Valid for CASE_FIRST - lower case sorts before upper case
	        /// </summary>
	        ///
            public static int LOWER_FIRST_ = 24;
	
	        /// <summary>
	        /// Upper case sorts before lower case
	        /// </summary>
	        ///
            public static int UPPER_FIRST_ = 25;
	
	        /// <summary>
	        /// Number of attribute values
	        /// </summary>
	        ///
            public static int LIMIT_ = 29;
	    }
	
	    /// <summary>
	    /// Attributes that collation service understands. All the attributes can
	    /// take DEFAULT value, as well as the values specific to each one.
	    /// </summary>
	    ///
	    public class Attribute {
	        /// <summary>
	        /// Attribute for direction of secondary weights - used in French.
	        /// Acceptable values are ON, which results in secondary weights being
	        /// considered backwards and OFF which treats secondary weights in the
	        /// order they appear.
	        /// </summary>
	        ///
            public const int FRENCH_COLLATION_ = 0;
	
	        /// <summary>
	        /// Attribute for handling variable elements. Acceptable values are
	        /// NON_IGNORABLE (default) which treats all the codepoints with
	        /// non-ignorable primary weights in the same way, and SHIFTED which
	        /// causes codepoints with primary weights that are equal or below the
	        /// variable top value to be ignored on primary level and moved to the
	        /// quaternary level.
	        /// </summary>
	        ///
            public const int ALTERNATE_HANDLING_ = 1;
	
	        /// <summary>
	        /// Controls the ordering of upper and lower case letters. Acceptable
	        /// values are OFF (default), which orders upper and lower case letters
	        /// in accordance to their tertiary weights, UPPER_FIRST which forces
	        /// upper case letters to sort before lower case letters, and LOWER_FIRST
	        /// which does the opposite.
	        /// </summary>
	        ///
            public const int CASE_FIRST_ = 2;
	
	        /// <summary>
	        /// Controls whether an extra case level (positioned before the third
	        /// level) is generated or not. Acceptable values are OFF (default), when
	        /// case level is not generated, and ON which causes the case level to be
	        /// generated. Contents of the case level are affected by the value of
	        /// CASE_FIRST attribute. A simple way to ignore accent differences in a
	        /// string is to set the strength to PRIMARY and enable case level.
	        /// </summary>
	        ///
            public const int CASE_LEVEL_ = 3;
	
	        /// <summary>
	        /// Controls whether the normalization check and necessary normalizations
	        /// are performed. When set to OFF (default) no normalization check is
	        /// performed. The correctness of the result is guaranteed only if the
	        /// input data is in so-called FCD form (see users manual for more info).
	        /// When set to ON, an incremental check is performed to see whether the
	        /// input data is in the FCD form. If the data is not in the FCD form,
	        /// incremental NFD normalization is performed.
	        /// </summary>
	        ///
            public const int NORMALIZATION_MODE_ = 4;
	
	        /// <summary>
	        /// The strength attribute. Can be either PRIMARY, SECONDARY, TERTIARY,
	        /// QUATERNARY or IDENTICAL. The usual strength for most locales (except
	        /// Japanese) is tertiary. Quaternary strength is useful when combined
	        /// with shifted setting for alternate handling attribute and for JIS x
	        /// 4061 collation, when it is used to distinguish between Katakana and
	        /// Hiragana (this is achieved by setting the HIRAGANA_QUATERNARY mode to
	        /// on. Otherwise, quaternary level is affected only by the number of non
	        /// ignorable code points in the string. Identical strength is rarely
	        /// useful, as it amounts to codepoints of the NFD form of the string.
	        /// </summary>
	        ///
            public const int STRENGTH_ = 5;
	
	        /// <summary>
	        /// When turned on, this attribute positions Hiragana before all
	        /// non-ignorables on quaternary level. This is a sneaky way to produce
	        /// JIS sort order.
	        /// </summary>
	        ///
            public const int HIRAGANA_QUATERNARY_MODE_ = 6;
	
	        /// <summary>
	        /// Attribute count
	        /// </summary>
	        ///
            public const int LIMIT_ = 7;
	    }
	
	    /// <summary>
	    /// DataManipulate singleton
	    /// </summary>
	    ///
	    internal class DataManipulate : Trie.DataManipulate {
	        // public methods ----------------------------------------------------
	
	        /// <summary>
	        /// Internal method called to parse a lead surrogate's ce for the offset
	        /// to the next trail surrogate data.
	        /// </summary>
	        ///
	        /// <param name="ce">collation element of the lead surrogate</param>
	        /// <returns>data offset or 0 for the next trail surrogate</returns>
	        /// @stable ICU 2.8
	        public int GetFoldingOffset(int ce) {
	            if (IBM.ICU.Text.RuleBasedCollator.IsSpecial(ce) && IBM.ICU.Text.RuleBasedCollator.GetTag(ce) == IBM.ICU.Text.RuleBasedCollator.CE_SURROGATE_TAG_) {
	                return (ce & 0xFFFFFF);
	            }
	            return 0;
	        }
	
	        /// <summary>
	        /// Get singleton object
	        /// </summary>
	        ///
	        public static RuleBasedCollator.DataManipulate  GetInstance() {
	            if (m_instance_ == null) {
	                m_instance_ = new RuleBasedCollator.DataManipulate ();
	            }
	            return m_instance_;
	        }
	
	        // private data member ----------------------------------------------
	
	        /// <summary>
	        /// Singleton instance
	        /// </summary>
	        ///
	        private static RuleBasedCollator.DataManipulate  m_instance_;
	
	        // private constructor ----------------------------------------------
	
	        /// <summary>
	        /// private to prevent initialization
	        /// </summary>
	        ///
	        public DataManipulate() {
	        }
	    }
	
	    /// <summary>
	    /// UCAConstants
	    /// </summary>
	    ///
	    internal sealed class UCAConstants {
	        public UCAConstants() {
	            this.FIRST_TERTIARY_IGNORABLE_ = new int[2];
	            this.LAST_TERTIARY_IGNORABLE_ = new int[2];
	            this.FIRST_PRIMARY_IGNORABLE_ = new int[2];
	            this.FIRST_SECONDARY_IGNORABLE_ = new int[2];
	            this.LAST_SECONDARY_IGNORABLE_ = new int[2];
	            this.LAST_PRIMARY_IGNORABLE_ = new int[2];
	            this.FIRST_VARIABLE_ = new int[2];
	            this.LAST_VARIABLE_ = new int[2];
	            this.FIRST_NON_VARIABLE_ = new int[2];
	            this.LAST_NON_VARIABLE_ = new int[2];
	            this.RESET_TOP_VALUE_ = new int[2];
	            this.FIRST_IMPLICIT_ = new int[2];
	            this.LAST_IMPLICIT_ = new int[2];
	            this.FIRST_TRAILING_ = new int[2];
	            this.LAST_TRAILING_ = new int[2];
	        }
	
	        internal int[] FIRST_TERTIARY_IGNORABLE_;
	
	        internal int[] LAST_TERTIARY_IGNORABLE_;
	
	        internal int[] FIRST_PRIMARY_IGNORABLE_;
	
	        internal int[] FIRST_SECONDARY_IGNORABLE_;
	
	        internal int[] LAST_SECONDARY_IGNORABLE_;
	
	        internal int[] LAST_PRIMARY_IGNORABLE_;
	
	        internal int[] FIRST_VARIABLE_;
	
	        internal int[] LAST_VARIABLE_;
	
	        internal int[] FIRST_NON_VARIABLE_;
	
	        internal int[] LAST_NON_VARIABLE_;
	
	        internal int[] RESET_TOP_VALUE_;
	
	        internal int[] FIRST_IMPLICIT_;
	
	        internal int[] LAST_IMPLICIT_;
	
	        internal int[] FIRST_TRAILING_;
	
	        internal int[] LAST_TRAILING_;
	
	        internal int PRIMARY_TOP_MIN_;
	
	        internal int PRIMARY_IMPLICIT_MIN_; // 0xE8000000
	
	        internal int PRIMARY_IMPLICIT_MAX_; // 0xF0000000
	
	        internal int PRIMARY_TRAILING_MIN_; // 0xE8000000
	
	        internal int PRIMARY_TRAILING_MAX_; // 0xF0000000
	
	        internal int PRIMARY_SPECIAL_MIN_; // 0xE8000000
	
	        internal int PRIMARY_SPECIAL_MAX_; // 0xF0000000
	    }
	
	    // package private data member -------------------------------------------
	
	    internal const byte BYTE_FIRST_TAILORED_ = (byte) 0x04;
	
	    internal const byte BYTE_COMMON_ = (byte) 0x05;
	
	    internal const int COMMON_TOP_2_ = 0x86; // int for unsigness
	
	    internal const int COMMON_BOTTOM_2_ = BYTE_COMMON_;
	
	    /// <summary>
	    /// Case strength mask
	    /// </summary>
	    ///
	    internal const int CE_CASE_BIT_MASK_ = 0xC0;
	
	    internal const int CE_TAG_SHIFT_ = 24;
	
	    internal const int CE_TAG_MASK_ = 0x0F000000;
	
	    internal const int CE_SPECIAL_FLAG_ = -268435456;
	
	    /// <summary>
	    /// Lead surrogate that is tailored and doesn't start a contraction
	    /// </summary>
	    ///
	    internal const int CE_SURROGATE_TAG_ = 5;
	
	    /// <summary>
	    /// Mask to get the primary strength of the collation element
	    /// </summary>
	    ///
	    internal const int CE_PRIMARY_MASK_ = -65536;
	
	    /// <summary>
	    /// Mask to get the secondary strength of the collation element
	    /// </summary>
	    ///
	    internal const int CE_SECONDARY_MASK_ = 0xFF00;
	
	    /// <summary>
	    /// Mask to get the tertiary strength of the collation element
	    /// </summary>
	    ///
	    internal const int CE_TERTIARY_MASK_ = 0xFF;
	
	    /// <summary>
	    /// Primary strength shift
	    /// </summary>
	    ///
	    internal const int CE_PRIMARY_SHIFT_ = 16;
	
	    /// <summary>
	    /// Secondary strength shift
	    /// </summary>
	    ///
	    internal const int CE_SECONDARY_SHIFT_ = 8;
	
	    /// <summary>
	    /// Continuation marker
	    /// </summary>
	    ///
	    internal const int CE_CONTINUATION_MARKER_ = 0xC0;
	
	    /// <summary>
	    /// Size of collator raw data headers and options before the expansion data.
	    /// This is used when expansion ces are to be retrieved. ICU4C uses the
	    /// expansion offset starting from UCollator.UColHeader, hence ICU4J will
	    /// have to minus that off to get the right expansion ce offset. In number of
	    /// ints.
	    /// </summary>
	    ///
	    internal int m_expansionOffset_;
	
	    /// <summary>
	    /// Size of collator raw data headers, options and expansions before
	    /// contraction data. This is used when contraction ces are to be retrieved.
	    /// ICU4C uses contraction offset starting from UCollator.UColHeader, hence
	    /// ICU4J will have to minus that off to get the right contraction ce offset.
	    /// In number of chars.
	    /// </summary>
	    ///
	    internal int m_contractionOffset_;
	
	    /// <summary>
	    /// Flag indicator if Jamo is special
	    /// </summary>
	    ///
	    internal bool m_isJamoSpecial_;
	
	    // Collator options ------------------------------------------------------
	
	    internal int m_defaultVariableTopValue_;
	
	    internal bool m_defaultIsFrenchCollation_;
	
	    internal bool m_defaultIsAlternateHandlingShifted_;
	
	    internal int m_defaultCaseFirst_;
	
	    internal bool m_defaultIsCaseLevel_;
	
	    internal int m_defaultDecomposition_;
	
	    internal int m_defaultStrength_;
	
	    internal bool m_defaultIsHiragana4_;
	
	    internal bool m_defaultIsNumericCollation_;
	
	    /// <summary>
	    /// Value of the variable top
	    /// </summary>
	    ///
	    internal int m_variableTopValue_;
	
	    /// <summary>
	    /// Attribute for special Hiragana
	    /// </summary>
	    ///
	    internal bool m_isHiragana4_;
	
	    /// <summary>
	    /// Case sorting customization
	    /// </summary>
	    ///
	    internal int m_caseFirst_;
	
	    /// <summary>
	    /// Numeric collation option
	    /// </summary>
	    ///
	    internal bool m_isNumericCollation_;
	
	    // end Collator options --------------------------------------------------
	
	    /// <summary>
	    /// Expansion table
	    /// </summary>
	    ///
	    internal int[] m_expansion_;
	
	    /// <summary>
	    /// Contraction index table
	    /// </summary>
	    ///
	    internal char[] m_contractionIndex_;
	
	    /// <summary>
	    /// Contraction CE table
	    /// </summary>
	    ///
	    internal int[] m_contractionCE_;
	
	    /// <summary>
	    /// Data trie
	    /// </summary>
	    ///
	    internal IntTrie m_trie_;
	
	    /// <summary>
	    /// Table to store all collation elements that are the last element of an expansion. This is for use in StringSearch.
	    /// </summary>
	    ///
	    internal int[] m_expansionEndCE_;
	
	    /// <summary>
	    /// Table to store the maximum size of any expansions that end with the corresponding collation element in m_expansionEndCE_. For use in StringSearch too
	    /// </summary>
	    ///
	    internal sbyte[] m_expansionEndCEMaxSize_;
	
	    /// <summary>
	    /// Heuristic table to store information on whether a char character is considered "unsafe". "Unsafe" character are combining marks or those belonging to some contraction sequence from the offset 1 onwards. E.g. if "ABC" is the only contraction, then 'B' and 'C' are considered unsafe. If we have another contraction "ZA" with the one above, then 'A', 'B', 'C' are "unsafe" but 'Z' is not.
	    /// </summary>
	    ///
	    internal sbyte[] m_unsafe_;
	
	    /// <summary>
	    /// Table to store information on whether a codepoint can occur as the last character in a contraction
	    /// </summary>
	    ///
	    internal sbyte[] m_contractionEnd_;
	
	    /// <summary>
	    /// Original collation rules
	    /// </summary>
	    ///
	    internal String m_rules_;
	
	    /// <summary>
	    /// The smallest "unsafe" codepoint
	    /// </summary>
	    ///
	    internal char m_minUnsafe_;
	
	    /// <summary>
	    /// The smallest codepoint that could be the end of a contraction
	    /// </summary>
	    ///
	    internal char m_minContractionEnd_;
	
	    /// <summary>
	    /// General version of the collator
	    /// </summary>
	    ///
	    internal VersionInfo m_version_;
	
	    /// <summary>
	    /// UCA version
	    /// </summary>
	    ///
	    internal VersionInfo m_UCA_version_;
	
	    /// <summary>
	    /// UCD version
	    /// </summary>
	    ///
	    internal VersionInfo m_UCD_version_;
	
	    /// <summary>
	    /// UnicodeData.txt property object
	    /// </summary>
	    ///
	    static internal readonly RuleBasedCollator UCA_;
	
	    /// <summary>
	    /// UCA Constants
	    /// </summary>
	    ///
	    static internal readonly RuleBasedCollator.UCAConstants  UCA_CONSTANTS_;
	
	    /// <summary>
	    /// Table for UCA and builder use
	    /// </summary>
	    ///
	    static internal readonly char[] UCA_CONTRACTIONS_;
	
	    private static bool UCA_INIT_COMPLETE;
	
	    /// <summary>
	    /// Implicit generator
	    /// </summary>
	    ///
	    static internal readonly ImplicitCEGenerator impCEGen_;
	
	    // /**
	    // * Implicit constants
	    // */
	    // static final int IMPLICIT_BASE_BYTE_;
	    // static final int IMPLICIT_LIMIT_BYTE_;
	    // static final int IMPLICIT_4BYTE_BOUNDARY_;
	    // static final int LAST_MULTIPLIER_;
	    // static final int LAST2_MULTIPLIER_;
	    // static final int IMPLICIT_BASE_3BYTE_;
	    // static final int IMPLICIT_BASE_4BYTE_;
	    // static final int BYTES_TO_AVOID_ = 3;
	    // static final int OTHER_COUNT_ = 256 - BYTES_TO_AVOID_;
	    // static final int LAST_COUNT_ = OTHER_COUNT_ / 2;
	    // /**
	    // * Room for intervening, without expanding to 5 bytes
	    // */
	    // static final int LAST_COUNT2_ = OTHER_COUNT_ / 21;
	    // static final int IMPLICIT_3BYTE_COUNT_ = 1;
	    //
	    internal const byte SORT_LEVEL_TERMINATOR_ = 1;
	
	    // These are values from UCA required for
	    // implicit generation and supressing sort key compression
	    // they should regularly be in the UCA, but if one
	    // is running without UCA, it could be a problem
	    internal const int maxRegularPrimary = 0xA0;
	
	    internal const int minImplicitPrimary = 0xE0;
	
	    internal const int maxImplicitPrimary = 0xE4;
	
	    private static void CheckUCA() {
	        if (UCA_INIT_COMPLETE && UCA_ == null) {
	            throw new MissingManifestResourceException("Collator UCA data unavailable");
	        }
	    }
	
	    // package private constructors ------------------------------------------
	
	    /// <summary>
	    /// <p>
	    /// Private contructor for use by subclasses. Public access to creating
	    /// Collators is handled by the API Collator.getInstance() or
	    /// RuleBasedCollator(String rules).
	    /// </p>
	    /// <p>
	    /// This constructor constructs the UCA collator internally
	    /// </p>
	    /// </summary>
	    ///
	    internal RuleBasedCollator() {
	        this.latinOneUse_ = false;
	        this.latinOneRegenTable_ = false;
	        this.latinOneFailed_ = false;
	        this.latinOneTableLen_ = 0;
	        this.latinOneCEs_ = null;
	        CheckUCA();
	        InitUtility(false);
	    }
	
	    /// <summary>
	    /// Constructors a RuleBasedCollator from the argument locale. If no resource
	    /// bundle is associated with the locale, UCA is used instead.
	    /// </summary>
	    ///
	    /// <param name="locale"></param>
	    internal RuleBasedCollator(ULocale locale) {
	        this.latinOneUse_ = false;
	        this.latinOneRegenTable_ = false;
	        this.latinOneFailed_ = false;
	        this.latinOneTableLen_ = 0;
	        this.latinOneCEs_ = null;
	        CheckUCA();
	        ICUResourceBundle rb = (ICUResourceBundle) IBM.ICU.Util.UResourceBundle
	                .GetBundleInstance(IBM.ICU.Impl.ICUResourceBundle.ICU_COLLATION_BASE_NAME,
	                        locale);
	        InitUtility(false);
	        if (rb != null) {
	            try {
	                // Use keywords, if supplied for lookup
	                String collkey = locale.GetKeywordValue("collation");
	                if (collkey == null) {
	                    collkey = rb.GetStringWithFallback("collations/default");
	                }
	
	                // collations/default will always give a string back
	                // keyword for the real collation data
	                // if "collations/collkey" will return null if collkey == null
	                ICUResourceBundle elements = rb.GetWithFallback("collations/"
	                        + collkey);
	                if (elements != null) {
	                    // TODO: Determine actual & valid locale correctly
	                    ULocale uloc = rb.GetULocale();
	                    SetLocale(uloc, uloc);
	
	                    m_rules_ = elements.GetString("Sequence");
	                    ByteBuffer buf = elements.Get("%%CollationBin").GetBinary();
	                    // %%CollationBin
	                    if (buf != null) {
	                        byte[] map = buf.GetBytes();
	                        IBM.ICU.Text.CollatorReader.InitRBC(this, map);
	                        /*
	                         * BufferedInputStream input = new BufferedInputStream(
	                         * new ByteArrayInputStream(map)); /* CollatorReader
	                         * reader = new CollatorReader(input, false); if
	                         * (map.length > MIN_BINARY_DATA_SIZE_) {
	                         * reader.read(this, null); } else {
	                         * reader.readHeader(this); reader.readOptions(this); //
	                         * duplicating UCA_'s data setWithUCATables(); }
	                         */
	                        // at this point, we have read in the collator
	                        // now we need to check whether the binary image has
	                        // the right UCA and other versions
	                        if (!m_UCA_version_.Equals(UCA_.m_UCA_version_)
	                                || !m_UCD_version_.Equals(UCA_.m_UCD_version_)) {
	                            Init(m_rules_);
	                            return;
	                        }
	                        Init();
	                        return;
	                    } else {
	                        // due to resource redirection ICUListResourceBundle
	                        // does not
	                        // raise missing resource error
	                        // throw new
	                        // MissingResourceException("Could not get resource for constructing RuleBasedCollator","com.ibm.icu.impl.data.LocaleElements_"+locale.toString(),
	                        // "%%CollationBin");
	
	                        Init(m_rules_);
	                        return;
	                    }
	                }
	            } catch (Exception e) {
	                // e.printStackTrace();
	                // if failed use UCA.
	            }
	        }
	        SetWithUCAData();
	    }
	
	    // package private methods -----------------------------------------------
	
	    /// <summary>
	    /// Sets this collator to use the tables in UCA. Note options not taken care
	    /// of here.
	    /// </summary>
	    ///
	    internal void SetWithUCATables() {
	        m_contractionOffset_ = UCA_.m_contractionOffset_;
	        m_expansionOffset_ = UCA_.m_expansionOffset_;
	        m_expansion_ = UCA_.m_expansion_;
	        m_contractionIndex_ = UCA_.m_contractionIndex_;
	        m_contractionCE_ = UCA_.m_contractionCE_;
	        m_trie_ = UCA_.m_trie_;
	        m_expansionEndCE_ = UCA_.m_expansionEndCE_;
	        m_expansionEndCEMaxSize_ = UCA_.m_expansionEndCEMaxSize_;
	        m_unsafe_ = UCA_.m_unsafe_;
	        m_contractionEnd_ = UCA_.m_contractionEnd_;
	        m_minUnsafe_ = UCA_.m_minUnsafe_;
	        m_minContractionEnd_ = UCA_.m_minContractionEnd_;
	    }
	
	    /// <summary>
	    /// Sets this collator to use the all options and tables in UCA.
	    /// </summary>
	    ///
	    internal void SetWithUCAData() {
	        latinOneFailed_ = true;
	
	        m_addition3_ = UCA_.m_addition3_;
	        m_bottom3_ = UCA_.m_bottom3_;
	        m_bottomCount3_ = UCA_.m_bottomCount3_;
	        m_caseFirst_ = UCA_.m_caseFirst_;
	        m_caseSwitch_ = UCA_.m_caseSwitch_;
	        m_common3_ = UCA_.m_common3_;
	        m_contractionOffset_ = UCA_.m_contractionOffset_;
	        SetDecomposition(UCA_.GetDecomposition());
	        m_defaultCaseFirst_ = UCA_.m_defaultCaseFirst_;
	        m_defaultDecomposition_ = UCA_.m_defaultDecomposition_;
	        m_defaultIsAlternateHandlingShifted_ = UCA_.m_defaultIsAlternateHandlingShifted_;
	        m_defaultIsCaseLevel_ = UCA_.m_defaultIsCaseLevel_;
	        m_defaultIsFrenchCollation_ = UCA_.m_defaultIsFrenchCollation_;
	        m_defaultIsHiragana4_ = UCA_.m_defaultIsHiragana4_;
	        m_defaultStrength_ = UCA_.m_defaultStrength_;
	        m_defaultVariableTopValue_ = UCA_.m_defaultVariableTopValue_;
	        m_defaultIsNumericCollation_ = UCA_.m_defaultIsNumericCollation_;
	        m_expansionOffset_ = UCA_.m_expansionOffset_;
	        m_isAlternateHandlingShifted_ = UCA_.m_isAlternateHandlingShifted_;
	        m_isCaseLevel_ = UCA_.m_isCaseLevel_;
	        m_isFrenchCollation_ = UCA_.m_isFrenchCollation_;
	        m_isHiragana4_ = UCA_.m_isHiragana4_;
	        m_isJamoSpecial_ = UCA_.m_isJamoSpecial_;
	        m_isSimple3_ = UCA_.m_isSimple3_;
	        m_mask3_ = UCA_.m_mask3_;
	        m_minContractionEnd_ = UCA_.m_minContractionEnd_;
	        m_minUnsafe_ = UCA_.m_minUnsafe_;
	        m_rules_ = UCA_.m_rules_;
	        SetStrength(UCA_.GetStrength());
	        m_top3_ = UCA_.m_top3_;
	        m_topCount3_ = UCA_.m_topCount3_;
	        m_variableTopValue_ = UCA_.m_variableTopValue_;
	        m_isNumericCollation_ = UCA_.m_isNumericCollation_;
	        SetWithUCATables();
	        latinOneFailed_ = false;
	    }
	
	    /// <summary>
	    /// Test whether a char character is potentially "unsafe" for use as a
	    /// collation starting point. "Unsafe" characters are combining marks or
	    /// those belonging to some contraction sequence from the offset 1 onwards.
	    /// E.g. if "ABC" is the only contraction, then 'B' and 'C' are considered
	    /// unsafe. If we have another contraction "ZA" with the one above, then 'A',
	    /// 'B', 'C' are "unsafe" but 'Z' is not.
	    /// </summary>
	    ///
	    /// <param name="ch">character to determin</param>
	    /// <returns>true if ch is unsafe, false otherwise</returns>
	    internal bool IsUnsafe(char ch) {
	        if (ch < m_minUnsafe_) {
	            return false;
	        }
	
	        if (ch >= (HEURISTIC_SIZE_ << HEURISTIC_SHIFT_)) {
	            if (IBM.ICU.Text.UTF16.IsLeadSurrogate(ch) || IBM.ICU.Text.UTF16.IsTrailSurrogate(ch)) {
	                // Trail surrogate are always considered unsafe.
	                return true;
	            }
	            ch &= HEURISTIC_OVERFLOW_MASK_;
	            ch += HEURISTIC_OVERFLOW_OFFSET_;
	        }
	        int value_ren = m_unsafe_[ch >> HEURISTIC_SHIFT_];
	        return ((value_ren >> (ch & HEURISTIC_MASK_)) & 1) != 0;
	    }
	
	    /// <summary>
	    /// Approximate determination if a char character is at a contraction end.
	    /// Guaranteed to be true if a character is at the end of a contraction,
	    /// otherwise it is not deterministic.
	    /// </summary>
	    ///
	    /// <param name="ch">character to be determined</param>
	    internal bool IsContractionEnd(char ch) {
	        if (IBM.ICU.Text.UTF16.IsTrailSurrogate(ch)) {
	            return true;
	        }
	
	        if (ch < m_minContractionEnd_) {
	            return false;
	        }
	
	        if (ch >= (HEURISTIC_SIZE_ << HEURISTIC_SHIFT_)) {
	            ch &= HEURISTIC_OVERFLOW_MASK_;
	            ch += HEURISTIC_OVERFLOW_OFFSET_;
	        }
	        int value_ren = m_contractionEnd_[ch >> HEURISTIC_SHIFT_];
	        return ((value_ren >> (ch & HEURISTIC_MASK_)) & 1) != 0;
	    }
	
	    /// <summary>
	    /// Retrieve the tag of a special ce
	    /// </summary>
	    ///
	    /// <param name="ce">ce to test</param>
	    /// <returns>tag of ce</returns>
	    static internal int GetTag(int ce) {
	        return (ce & CE_TAG_MASK_) >> CE_TAG_SHIFT_;
	    }
	
	    /// <summary>
	    /// Checking if ce is special
	    /// </summary>
	    ///
	    /// <param name="ce">to check</param>
	    /// <returns>true if ce is special</returns>
	    static internal bool IsSpecial(int ce) {
	        return (ce & CE_SPECIAL_FLAG_) == CE_SPECIAL_FLAG_;
	    }
	
	    /// <summary>
	    /// Checks if the argument ce is a continuation
	    /// </summary>
	    ///
	    /// <param name="ce">collation element to test</param>
	    /// <returns>true if ce is a continuation</returns>
	    static internal bool IsContinuation(int ce) {
	        return ce != IBM.ICU.Text.CollationElementIterator.NULLORDER
	                && (ce & CE_CONTINUATION_TAG_) == CE_CONTINUATION_TAG_;
	    }
	
	    // private inner classes ------------------------------------------------
	
	    // private variables -----------------------------------------------------
	
	    /// <summary>
	    /// The smallest natural unsafe or contraction end char character before
	    /// tailoring. This is a combining mark.
	    /// </summary>
	    ///
	    private const int DEFAULT_MIN_HEURISTIC_ = 0x300;
	
	    /// <summary>
	    /// Heuristic table table size. Size is 32 bytes, 1 bit for each latin 1
	    /// char, and some power of two for hashing the rest of the chars. Size in
	    /// bytes.
	    /// </summary>
	    ///
	    private const char HEURISTIC_SIZE_ = (char) (1056);
	
	    /// <summary>
	    /// Mask value down to "some power of two" - 1, number of bits, not num of
	    /// bytes.
	    /// </summary>
	    ///
	    private const char HEURISTIC_OVERFLOW_MASK_ = (char) (0x1fff);
	
	    /// <summary>
	    /// Unsafe character shift
	    /// </summary>
	    ///
	    private const int HEURISTIC_SHIFT_ = 3;
	
	    /// <summary>
	    /// Unsafe character addition for character too large, it has to be folded
	    /// then incremented.
	    /// </summary>
	    ///
	    private const char HEURISTIC_OVERFLOW_OFFSET_ = (char) (256);
	
	    /// <summary>
	    /// Mask value to get offset in heuristic table.
	    /// </summary>
	    ///
	    private const char HEURISTIC_MASK_ = (char) (7);
	
	    private int m_caseSwitch_;
	
	    private int m_common3_;
	
	    private int m_mask3_;
	
	    /// <summary>
	    /// When switching case, we need to add or subtract different values.
	    /// </summary>
	    ///
	    private int m_addition3_;
	
	    /// <summary>
	    /// Upper range when compressing
	    /// </summary>
	    ///
	    private int m_top3_;
	
	    /// <summary>
	    /// Upper range when compressing
	    /// </summary>
	    ///
	    private int m_bottom3_;
	
	    private int m_topCount3_;
	
	    private int m_bottomCount3_;
	
	    /// <summary>
	    /// Case first constants
	    /// </summary>
	    ///
	    private const int CASE_SWITCH_ = 0xC0;
	
	    private const int NO_CASE_SWITCH_ = 0;
	
	    /// <summary>
	    /// Case level constants
	    /// </summary>
	    ///
	    private const int CE_REMOVE_CASE_ = 0x3F;
	
	    private const int CE_KEEP_CASE_ = 0xFF;
	
	    /// <summary>
	    /// Case strength mask
	    /// </summary>
	    ///
	    private const int CE_CASE_MASK_3_ = 0xFF;
	
	    /// <summary>
	    /// Sortkey size factor. Values can be changed.
	    /// </summary>
	    ///
	    private const double PROPORTION_2_ = 0.5d;
	
	    private const double PROPORTION_3_ = 0.667d;
	
	    // These values come from the UCA ----------------------------------------
	
	    /// <summary>
	    /// This is an enum that lists magic special byte values from the fractional
	    /// UCA
	    /// </summary>
	    ///
	    // private static final byte BYTE_ZERO_ = 0x0;
	    // private static final byte BYTE_LEVEL_SEPARATOR_ = (byte)0x01;
	    // private static final byte BYTE_SORTKEY_GLUE_ = (byte)0x02;
	    private const byte BYTE_SHIFT_PREFIX_ = (byte) 0x03;
	
	    /* private */internal const byte BYTE_UNSHIFTED_MIN_ = BYTE_SHIFT_PREFIX_;
	
	    // private static final byte BYTE_FIRST_UCA_ = BYTE_COMMON_;
	    internal const byte CODAN_PLACEHOLDER = 0x24;
	
	    // private static final byte BYTE_LAST_LATIN_PRIMARY_ = (byte)0x4C;
	    private const byte BYTE_FIRST_NON_LATIN_PRIMARY_ = (byte) 0x4D;
	
	    private const byte BYTE_UNSHIFTED_MAX_ = (byte) 0xFF;
	
	    private const int TOTAL_2_ = COMMON_TOP_2_ - COMMON_BOTTOM_2_ - 1;
	
	    private const int FLAG_BIT_MASK_CASE_SWITCH_OFF_ = 0x80;
	
	    private const int FLAG_BIT_MASK_CASE_SWITCH_ON_ = 0x40;
	
	    private const int COMMON_TOP_CASE_SWITCH_OFF_3_ = 0x85;
	
	    private const int COMMON_TOP_CASE_SWITCH_LOWER_3_ = 0x45;
	
	    private const int COMMON_TOP_CASE_SWITCH_UPPER_3_ = 0xC5;
	
	    private const int COMMON_BOTTOM_3_ = 0x05;
	
	    private const int COMMON_BOTTOM_CASE_SWITCH_UPPER_3_ = 0x86;
	
	    private const int COMMON_BOTTOM_CASE_SWITCH_LOWER_3_ = COMMON_BOTTOM_3_;
	
	    private const int TOP_COUNT_2_ = (int) (PROPORTION_2_ * TOTAL_2_);
	
	    private const int BOTTOM_COUNT_2_ = TOTAL_2_ - TOP_COUNT_2_;
	
	    private const int COMMON_2_ = COMMON_BOTTOM_2_;
	
	    private const int COMMON_UPPER_FIRST_3_ = 0xC5;
	
	    private const int COMMON_NORMAL_3_ = COMMON_BOTTOM_3_;
	
	    // private static final int COMMON_4_ = (byte)0xFF;
	
	    /*
	     * Minimum size required for the binary collation data in bytes. Size of UCA
	     * header + size of options to 4 bytes
	     */
	    // private static final int MIN_BINARY_DATA_SIZE_ = (42 + 25) << 2;
	
	    /// <summary>
	    /// If this collator is to generate only simple tertiaries for fast path
	    /// </summary>
	    ///
	    private bool m_isSimple3_;
	
	    /// <summary>
	    /// French collation sorting flag
	    /// </summary>
	    ///
	    private bool m_isFrenchCollation_;
	
	    /// <summary>
	    /// Flag indicating if shifted is requested for Quaternary alternate
	    /// handling. If this is not true, the default for alternate handling will be
	    /// non-ignorable.
	    /// </summary>
	    ///
	    private bool m_isAlternateHandlingShifted_;
	
	    /// <summary>
	    /// Extra case level for sorting
	    /// </summary>
	    ///
	    private bool m_isCaseLevel_;
	
	    private const int SORT_BUFFER_INIT_SIZE_ = 128;
	
	    private const int SORT_BUFFER_INIT_SIZE_1_ = SORT_BUFFER_INIT_SIZE_ << 3;
	
	    private const int SORT_BUFFER_INIT_SIZE_2_ = SORT_BUFFER_INIT_SIZE_;
	
	    private const int SORT_BUFFER_INIT_SIZE_3_ = SORT_BUFFER_INIT_SIZE_;
	
	    private const int SORT_BUFFER_INIT_SIZE_CASE_ = SORT_BUFFER_INIT_SIZE_ >> 2;
	
	    private const int SORT_BUFFER_INIT_SIZE_4_ = SORT_BUFFER_INIT_SIZE_;
	
	    private const int CE_CONTINUATION_TAG_ = 0xC0;
	
	    private const int CE_REMOVE_CONTINUATION_MASK_ = -193;
	
	    private const int LAST_BYTE_MASK_ = 0xFF;
	
	    // private static final int CE_RESET_TOP_VALUE_ = 0x9F000303;
	    // private static final int CE_NEXT_TOP_VALUE_ = 0xE8960303;
	
	    private const byte SORT_CASE_BYTE_START_ = (byte) 0x80;
	
	    private const byte SORT_CASE_SHIFT_START_ = (byte) 7;
	
	    /// <summary>
	    /// CE buffer size
	    /// </summary>
	    ///
	    private const int CE_BUFFER_SIZE_ = 512;
	
	    // variables for Latin-1 processing
	    internal bool latinOneUse_;
	
	    internal bool latinOneRegenTable_;
	
	    internal bool latinOneFailed_;
	
	    internal int latinOneTableLen_;
	
	    internal int[] latinOneCEs_;
	
	    /// <summary>
	    /// Bunch of utility iterators
	    /// </summary>
	    ///
	    private StringUCharacterIterator m_srcUtilIter_;
	
	    private CollationElementIterator m_srcUtilColEIter_;
	
	    private StringUCharacterIterator m_tgtUtilIter_;
	
	    private CollationElementIterator m_tgtUtilColEIter_;
	
	    /// <summary>
	    /// Utility comparison flags
	    /// </summary>
	    ///
	    private bool m_utilCompare0_;
	
	    // private boolean m_utilCompare1_;
	    private bool m_utilCompare2_;
	
	    private bool m_utilCompare3_;
	
	    private bool m_utilCompare4_;
	
	    private bool m_utilCompare5_;
	
	    /// <summary>
	    /// Utility byte buffer
	    /// </summary>
	    ///
	    private byte[] m_utilBytes0_;
	
	    private byte[] m_utilBytes1_;
	
	    private byte[] m_utilBytes2_;
	
	    private byte[] m_utilBytes3_;
	
	    private byte[] m_utilBytes4_;
	
	    // private byte m_utilBytes5_[];
	    private RawCollationKey m_utilRawCollationKey_;
	
	    private int m_utilBytesCount0_;
	
	    private int m_utilBytesCount1_;
	
	    private int m_utilBytesCount2_;
	
	    private int m_utilBytesCount3_;
	
	    private int m_utilBytesCount4_;
	
	    // private int m_utilBytesCount5_;
	    // private int m_utilCount0_;
	    // private int m_utilCount1_;
	    private int m_utilCount2_;
	
	    private int m_utilCount3_;
	
	    private int m_utilCount4_;
	
	    // private int m_utilCount5_;
	
	    private int m_utilFrenchStart_;
	
	    private int m_utilFrenchEnd_;
	
	    /// <summary>
	    /// Preparing the CE buffers. will be filled during the primary phase
	    /// </summary>
	    ///
	    private int[] m_srcUtilCEBuffer_;
	
	    private int[] m_tgtUtilCEBuffer_;
	
	    private int m_srcUtilCEBufferSize_;
	
	    private int m_tgtUtilCEBufferSize_;
	
	    private int m_srcUtilContOffset_;
	
	    private int m_tgtUtilContOffset_;
	
	    private int m_srcUtilOffset_;
	
	    private int m_tgtUtilOffset_;
	
	    // private methods -------------------------------------------------------
	
	    private void Init(String rules) {
	        SetWithUCAData();
	        CollationParsedRuleBuilder builder = new CollationParsedRuleBuilder(
	                rules);
	        builder.SetRules(this);
	        m_rules_ = rules;
	        Init();
	        InitUtility(false);
	    }
	
	    private int CompareRegular(String source, String target, int offset) {
	        if (m_srcUtilIter_ == null) {
	            InitUtility(true);
	        }
	        int strength = GetStrength();
	        // setting up the collator parameters
	        m_utilCompare0_ = m_isCaseLevel_;
	        // m_utilCompare1_ = true;
	        m_utilCompare2_ = strength >= IBM.ICU.Text.Collator.SECONDARY;
	        m_utilCompare3_ = strength >= IBM.ICU.Text.Collator.TERTIARY;
	        m_utilCompare4_ = strength >= IBM.ICU.Text.Collator.QUATERNARY;
	        m_utilCompare5_ = strength == IBM.ICU.Text.Collator.IDENTICAL;
	        bool doFrench = m_isFrenchCollation_ && m_utilCompare2_;
	        bool doShift4 = m_isAlternateHandlingShifted_ && m_utilCompare4_;
	        bool doHiragana4 = m_isHiragana4_ && m_utilCompare4_;
	
	        if (doHiragana4 && doShift4) {
	            String sourcesub = source.Substring(offset);
	            String targetsub = target.Substring(offset);
	            return CompareBySortKeys(sourcesub, targetsub);
	        }
	
	        // This is the lowest primary value that will not be ignored if shifted
	        int lowestpvalue = (m_isAlternateHandlingShifted_) ? m_variableTopValue_ << 16
	                : 0;
	        m_srcUtilCEBufferSize_ = 0;
	        m_tgtUtilCEBufferSize_ = 0;
	        int result = DoPrimaryCompare(doHiragana4, lowestpvalue, source,
	                target, offset);
	        if (m_srcUtilCEBufferSize_ == -1 && m_tgtUtilCEBufferSize_ == -1) {
	            // since the cebuffer is cleared when we have determined that
	            // either source is greater than target or vice versa, the return
	            // result is the comparison result and not the hiragana result
	            return result;
	        }
	
	        int hiraganaresult = result;
	
	        if (m_utilCompare2_) {
	            result = DoSecondaryCompare(doFrench);
	            if (result != 0) {
	                return result;
	            }
	        }
	        // doing the case bit
	        if (m_utilCompare0_) {
	            result = DoCaseCompare();
	            if (result != 0) {
	                return result;
	            }
	        }
	        // Tertiary level
	        if (m_utilCompare3_) {
	            result = DoTertiaryCompare();
	            if (result != 0) {
	                return result;
	            }
	        }
	
	        if (doShift4) { // checkQuad
	            result = DoQuaternaryCompare(lowestpvalue);
	            if (result != 0) {
	                return result;
	            }
	        } else if (doHiragana4 && hiraganaresult != 0) {
	            // If we're fine on quaternaries, we might be different
	            // on Hiragana. This, however, might fail us in shifted.
	            return hiraganaresult;
	        }
	
	        // For IDENTICAL comparisons, we use a bitwise character comparison
	        // as a tiebreaker if all else is equal.
	        // Getting here should be quite rare - strings are not identical -
	        // that is checked first, but compared == through all other checks.
	        if (m_utilCompare5_) {
	            return DoIdenticalCompare(source, target, offset, true);
	        }
	        return 0;
	    }
	
	    /// <summary>
	    /// Gets the 2 bytes of primary order and adds it to the primary byte array
	    /// </summary>
	    ///
	    /// <param name="ce">current ce</param>
	    /// <param name="notIsContinuation">flag indicating if the current bytes belong to a continuationce</param>
	    /// <param name="doShift">flag indicating if ce is to be shifted</param>
	    /// <param name="leadPrimary">lead primary used for compression</param>
	    /// <param name="commonBottom4">common byte value for Quaternary</param>
	    /// <param name="bottomCount4">smallest byte value for Quaternary</param>
	    /// <returns>the new lead primary for compression</returns>
	    private int DoPrimaryBytes(int ce, bool notIsContinuation,
	            bool doShift, int leadPrimary, int commonBottom4,
	            int bottomCount4) {
	
	        int p2 = (ce >>= 16) & LAST_BYTE_MASK_; // in ints for unsigned
	        int p1 = (int) (((uint) ce) >> 8); // comparison
	        if (doShift) {
	            if (m_utilCount4_ > 0) {
	                while (m_utilCount4_ > bottomCount4) {
	                    m_utilBytes4_ = Append(m_utilBytes4_, m_utilBytesCount4_,
	                            (byte) (commonBottom4 + bottomCount4));
	                    m_utilBytesCount4_++;
	                    m_utilCount4_ -= bottomCount4;
	                }
	                m_utilBytes4_ = Append(m_utilBytes4_, m_utilBytesCount4_,
	                        (byte) (commonBottom4 + (m_utilCount4_ - 1)));
	                m_utilBytesCount4_++;
	                m_utilCount4_ = 0;
	            }
	            // dealing with a variable and we're treating them as shifted
	            // This is a shifted ignorable
	            if (p1 != 0) {
	                // we need to check this since we could be in continuation
	                m_utilBytes4_ = Append(m_utilBytes4_, m_utilBytesCount4_,
	                        (byte) p1);
	                m_utilBytesCount4_++;
	            }
	            if (p2 != 0) {
	                m_utilBytes4_ = Append(m_utilBytes4_, m_utilBytesCount4_,
	                        (byte) p2);
	                m_utilBytesCount4_++;
	            }
	        } else {
	            // Note: This code assumes that the table is well built
	            // i.e. not having 0 bytes where they are not supposed to be.
	            // Usually, we'll have non-zero primary1 & primary2, except
	            // in cases of LatinOne and friends, when primary2 will be
	            // regular and simple sortkey calc
	            if (p1 != IBM.ICU.Text.CollationElementIterator.IGNORABLE) {
	                if (notIsContinuation) {
	                    if (leadPrimary == p1) {
	                        m_utilBytes1_ = Append(m_utilBytes1_,
	                                m_utilBytesCount1_, (byte) p2);
	                        m_utilBytesCount1_++;
	                    } else {
	                        if (leadPrimary != 0) {
	                            m_utilBytes1_ = Append(m_utilBytes1_,
	                                    m_utilBytesCount1_,
	                                    ((p1 > leadPrimary) ? BYTE_UNSHIFTED_MAX_
	                                            : BYTE_UNSHIFTED_MIN_));
	                            m_utilBytesCount1_++;
	                        }
	                        if (p2 == IBM.ICU.Text.CollationElementIterator.IGNORABLE) {
	                            // one byter, not compressed
	                            m_utilBytes1_ = Append(m_utilBytes1_,
	                                    m_utilBytesCount1_, (byte) p1);
	                            m_utilBytesCount1_++;
	                            leadPrimary = 0;
	                        } else if (p1 < BYTE_FIRST_NON_LATIN_PRIMARY_
	                                || (p1 > maxRegularPrimary
	                                // >
	                                // (RuleBasedCollator.UCA_CONSTANTS_.LAST_NON_VARIABLE_[0]
	                                // >>> 24)
	                                && p1 < minImplicitPrimary
	                                // <
	                                // (RuleBasedCollator.UCA_CONSTANTS_.FIRST_IMPLICIT_[0]
	                                // >>> 24)
	                                )) {
	                            // not compressible
	                            leadPrimary = 0;
	                            m_utilBytes1_ = Append(m_utilBytes1_,
	                                    m_utilBytesCount1_, (byte) p1);
	                            m_utilBytesCount1_++;
	                            m_utilBytes1_ = Append(m_utilBytes1_,
	                                    m_utilBytesCount1_, (byte) p2);
	                            m_utilBytesCount1_++;
	                        } else { // compress
	                            leadPrimary = p1;
	                            m_utilBytes1_ = Append(m_utilBytes1_,
	                                    m_utilBytesCount1_, (byte) p1);
	                            m_utilBytesCount1_++;
	                            m_utilBytes1_ = Append(m_utilBytes1_,
	                                    m_utilBytesCount1_, (byte) p2);
	                            m_utilBytesCount1_++;
	                        }
	                    }
	                } else {
	                    // continuation, add primary to the key, no compression
	                    m_utilBytes1_ = Append(m_utilBytes1_, m_utilBytesCount1_,
	                            (byte) p1);
	                    m_utilBytesCount1_++;
	                    if (p2 != IBM.ICU.Text.CollationElementIterator.IGNORABLE) {
	                        m_utilBytes1_ = Append(m_utilBytes1_,
	                                m_utilBytesCount1_, (byte) p2);
	                        // second part
	                        m_utilBytesCount1_++;
	                    }
	                }
	            }
	        }
	        return leadPrimary;
	    }
	
	    /// <summary>
	    /// Gets the secondary byte and adds it to the secondary byte array
	    /// </summary>
	    ///
	    /// <param name="ce">current ce</param>
	    /// <param name="notIsContinuation">flag indicating if the current bytes belong to a continuationce</param>
	    /// <param name="doFrench">flag indicator if french sort is to be performed</param>
	    private void DoSecondaryBytes(int ce, bool notIsContinuation,
	            bool doFrench) {
	        int s = (ce >>= 8) & LAST_BYTE_MASK_; // int for comparison
	        if (s != 0) {
	            if (!doFrench) {
	                // This is compression code.
	                if (s == COMMON_2_ && notIsContinuation) {
	                    m_utilCount2_++;
	                } else {
	                    if (m_utilCount2_ > 0) {
	                        if (s > COMMON_2_) { // not necessary for 4th level.
	                            while (m_utilCount2_ > TOP_COUNT_2_) {
	                                m_utilBytes2_ = Append(m_utilBytes2_,
	                                        m_utilBytesCount2_,
	                                        (byte) (COMMON_TOP_2_ - TOP_COUNT_2_));
	                                m_utilBytesCount2_++;
	                                m_utilCount2_ -= TOP_COUNT_2_;
	                            }
	                            m_utilBytes2_ = Append(
	                                    m_utilBytes2_,
	                                    m_utilBytesCount2_,
	                                    (byte) (COMMON_TOP_2_ - (m_utilCount2_ - 1)));
	                            m_utilBytesCount2_++;
	                        } else {
	                            while (m_utilCount2_ > BOTTOM_COUNT_2_) {
	                                m_utilBytes2_ = Append(
	                                        m_utilBytes2_,
	                                        m_utilBytesCount2_,
	                                        (byte) (COMMON_BOTTOM_2_ + BOTTOM_COUNT_2_));
	                                m_utilBytesCount2_++;
	                                m_utilCount2_ -= BOTTOM_COUNT_2_;
	                            }
	                            m_utilBytes2_ = Append(
	                                    m_utilBytes2_,
	                                    m_utilBytesCount2_,
	                                    (byte) (COMMON_BOTTOM_2_ + (m_utilCount2_ - 1)));
	                            m_utilBytesCount2_++;
	                        }
	                        m_utilCount2_ = 0;
	                    }
	                    m_utilBytes2_ = Append(m_utilBytes2_, m_utilBytesCount2_,
	                            (byte) s);
	                    m_utilBytesCount2_++;
	                }
	            } else {
	                m_utilBytes2_ = Append(m_utilBytes2_, m_utilBytesCount2_,
	                        (byte) s);
	                m_utilBytesCount2_++;
	                // Do the special handling for French secondaries
	                // We need to get continuation elements and do intermediate
	                // restore
	                // abc1c2c3de with french secondaries need to be edc1c2c3ba
	                // NOT edc3c2c1ba
	                if (notIsContinuation) {
	                    if (m_utilFrenchStart_ != -1) {
	                        // reverse secondaries from frenchStartPtr up to
	                        // frenchEndPtr
	                        ReverseBuffer(m_utilBytes2_);
	                        m_utilFrenchStart_ = -1;
	                    }
	                } else {
	                    if (m_utilFrenchStart_ == -1) {
	                        m_utilFrenchStart_ = m_utilBytesCount2_ - 2;
	                    }
	                    m_utilFrenchEnd_ = m_utilBytesCount2_ - 1;
	                }
	            }
	        }
	    }
	
	    /// <summary>
	    /// Reverse the argument buffer
	    /// </summary>
	    ///
	    /// <param name="buffer">to reverse</param>
	    private void ReverseBuffer(byte[] buffer) {
	        int start = m_utilFrenchStart_;
	        int end = m_utilFrenchEnd_;
	        while (start < end) {
	            byte b = buffer[start];
	            buffer[start++] = buffer[end];
	            buffer[end--] = b;
	        }
	    }
	
	    /// <summary>
	    /// Insert the case shifting byte if required
	    /// </summary>
	    ///
	    /// <param name="caseshift">value</param>
	    /// <returns>new caseshift value</returns>
	    private int DoCaseShift(int caseshift) {
	        if (caseshift == 0) {
	            m_utilBytes0_ = Append(m_utilBytes0_, m_utilBytesCount0_,
	                    SORT_CASE_BYTE_START_);
	            m_utilBytesCount0_++;
	            caseshift = SORT_CASE_SHIFT_START_;
	        }
	        return caseshift;
	    }
	
	    /// <summary>
	    /// Performs the casing sort
	    /// </summary>
	    ///
	    /// <param name="tertiary">byte in ints for easy comparison</param>
	    /// <param name="notIsContinuation">flag indicating if the current bytes belong to a continuationce</param>
	    /// <param name="caseshift"></param>
	    /// <returns>the new value of case shift</returns>
	    private int DoCaseBytes(int tertiary, bool notIsContinuation,
	            int caseshift) {
	        caseshift = DoCaseShift(caseshift);
	
	        if (notIsContinuation && tertiary != 0) {
	            byte casebits = (byte) (tertiary & 0xC0);
	            if (m_caseFirst_ == IBM.ICU.Text.RuleBasedCollator.AttributeValue.UPPER_FIRST_) {
	                if (casebits == 0) {
	                    m_utilBytes0_[m_utilBytesCount0_ - 1] |= (byte) (1 << (--caseshift));
	                } else {
	                    // second bit
	                    caseshift = DoCaseShift(caseshift - 1);
                        m_utilBytes0_[m_utilBytesCount0_ - 1] |= (byte) (((casebits >> 6) & 1) << (--caseshift));
	                }
	            } else {
	                if (casebits != 0) {
                        m_utilBytes0_[m_utilBytesCount0_ - 1] |= (byte) (1 << (--caseshift));
	                    // second bit
	                    caseshift = DoCaseShift(caseshift);
                        m_utilBytes0_[m_utilBytesCount0_ - 1] |= (byte) (((casebits >> 7) & 1) << (--caseshift));
	                } else {
	                    caseshift--;
	                }
	            }
	        }
	
	        return caseshift;
	    }
	
	    /// <summary>
	    /// Gets the tertiary byte and adds it to the tertiary byte array
	    /// </summary>
	    ///
	    /// <param name="tertiary">byte in int for easy comparison</param>
	    /// <param name="notIsContinuation">flag indicating if the current bytes belong to a continuationce</param>
	    private void DoTertiaryBytes(int tertiary, bool notIsContinuation) {
	        if (tertiary != 0) {
	            // This is compression code.
	            // sequence size check is included in the if clause
	            if (tertiary == m_common3_ && notIsContinuation) {
	                m_utilCount3_++;
	            } else {
	                int common3 = m_common3_ & LAST_BYTE_MASK_;
	                if (tertiary > common3 && m_common3_ == COMMON_NORMAL_3_) {
	                    tertiary += m_addition3_;
	                } else if (tertiary <= common3
	                        && m_common3_ == COMMON_UPPER_FIRST_3_) {
	                    tertiary -= m_addition3_;
	                }
	                if (m_utilCount3_ > 0) {
	                    if (tertiary > common3) {
	                        while (m_utilCount3_ > m_topCount3_) {
	                            m_utilBytes3_ = Append(m_utilBytes3_,
	                                    m_utilBytesCount3_,
	                                    (byte) (m_top3_ - m_topCount3_));
	                            m_utilBytesCount3_++;
	                            m_utilCount3_ -= m_topCount3_;
	                        }
	                        m_utilBytes3_ = Append(m_utilBytes3_,
	                                m_utilBytesCount3_,
	                                (byte) (m_top3_ - (m_utilCount3_ - 1)));
	                        m_utilBytesCount3_++;
	                    } else {
	                        while (m_utilCount3_ > m_bottomCount3_) {
	                            m_utilBytes3_ = Append(m_utilBytes3_,
	                                    m_utilBytesCount3_,
	                                    (byte) (m_bottom3_ + m_bottomCount3_));
	                            m_utilBytesCount3_++;
	                            m_utilCount3_ -= m_bottomCount3_;
	                        }
	                        m_utilBytes3_ = Append(m_utilBytes3_,
	                                m_utilBytesCount3_,
	                                (byte) (m_bottom3_ + (m_utilCount3_ - 1)));
	                        m_utilBytesCount3_++;
	                    }
	                    m_utilCount3_ = 0;
	                }
	                m_utilBytes3_ = Append(m_utilBytes3_, m_utilBytesCount3_,
	                        (byte) tertiary);
	                m_utilBytesCount3_++;
	            }
	        }
	    }
	
	    /// <summary>
	    /// Gets the Quaternary byte and adds it to the Quaternary byte array
	    /// </summary>
	    ///
	    /// <param name="isCodePointHiragana">flag indicator if the previous codepoint we dealt with wasHiragana</param>
	    /// <param name="commonBottom4">smallest common Quaternary byte</param>
	    /// <param name="bottomCount4">smallest Quaternary byte</param>
	    /// <param name="hiragana4">hiragana Quaternary byte</param>
	    private void DoQuaternaryBytes(bool isCodePointHiragana,
	            int commonBottom4, int bottomCount4, byte hiragana4) {
	        if (isCodePointHiragana) { // This was Hiragana, need to note it
	            if (m_utilCount4_ > 0) { // Close this part
	                while (m_utilCount4_ > bottomCount4) {
	                    m_utilBytes4_ = Append(m_utilBytes4_, m_utilBytesCount4_,
	                            (byte) (commonBottom4 + bottomCount4));
	                    m_utilBytesCount4_++;
	                    m_utilCount4_ -= bottomCount4;
	                }
	                m_utilBytes4_ = Append(m_utilBytes4_, m_utilBytesCount4_,
	                        (byte) (commonBottom4 + (m_utilCount4_ - 1)));
	                m_utilBytesCount4_++;
	                m_utilCount4_ = 0;
	            }
	            m_utilBytes4_ = Append(m_utilBytes4_, m_utilBytesCount4_, hiragana4); // Add
	                                                                                  // the
	                                                                                  // Hiragana
	            m_utilBytesCount4_++;
	        } else { // This wasn't Hiragana, so we can continue adding stuff
	            m_utilCount4_++;
	        }
	    }
	
	    /// <summary>
	    /// Iterates through the argument string for all ces. Split the ces into
	    /// their relevant primaries, secondaries etc.
	    /// </summary>
	    ///
	    /// <param name="source">normalized string</param>
	    /// <param name="doFrench">flag indicator if special handling of French has to be done</param>
	    /// <param name="hiragana4">offset for Hiragana quaternary</param>
	    /// <param name="commonBottom4">smallest common quaternary byte</param>
	    /// <param name="bottomCount4">smallest quaternary byte</param>
	    private void GetSortKeyBytes(String source, bool doFrench,
	            byte hiragana4, int commonBottom4, int bottomCount4)
	
	    {
	        if (m_srcUtilIter_ == null) {
	            InitUtility(true);
	        }
	        int backupDecomposition = GetDecomposition();
	        SetDecomposition(IBM.ICU.Text.Collator.NO_DECOMPOSITION); // have to revert to backup later
	        m_srcUtilIter_.SetText(source);
	        m_srcUtilColEIter_.SetText(m_srcUtilIter_);
	        m_utilFrenchStart_ = -1;
	        m_utilFrenchEnd_ = -1;
	
	        // scriptorder not implemented yet
	        // const uint8_t *scriptOrder = coll->scriptOrder;
	
	        bool doShift = false;
	        bool notIsContinuation = false;
	
	        int leadPrimary = 0; // int for easier comparison
	        int caseShift = 0;
	
	        while (true) {
	            int ce = m_srcUtilColEIter_.Next();
	            if (ce == IBM.ICU.Text.CollationElementIterator.NULLORDER) {
	                break;
	            }
	
	            if (ce == IBM.ICU.Text.CollationElementIterator.IGNORABLE) {
	                continue;
	            }
	
	            notIsContinuation = !IsContinuation(ce);
	
	            /*
	             * if (notIsContinuation) { if (scriptOrder != NULL) { primary1 =
	             * scriptOrder[primary1]; } }
	             */
	            bool isPrimaryByteIgnorable = (ce & CE_PRIMARY_MASK_) == 0;
	            // actually we can just check that the first byte is 0
	            // generation stuffs the order left first
	            bool isSmallerThanVariableTop = ((int) (((uint) ce) >> CE_PRIMARY_SHIFT_)) <= m_variableTopValue_;
	            doShift = (m_isAlternateHandlingShifted_
	                    && ((notIsContinuation && isSmallerThanVariableTop && !isPrimaryByteIgnorable) // primary
	                                                                                                   // byte
	                                                                                                   // not
	                                                                                                   // 0
	                    || (!notIsContinuation && doShift)) || (doShift && isPrimaryByteIgnorable));
	            if (doShift && isPrimaryByteIgnorable) {
	                // amendment to the UCA says that primary ignorables and other
	                // ignorables should be removed if following a shifted code
	                // point
	                // if we were shifted and we got an ignorable code point
	                // we should just completely ignore it
	                continue;
	            }
	            leadPrimary = DoPrimaryBytes(ce, notIsContinuation, doShift,
	                    leadPrimary, commonBottom4, bottomCount4);
	            if (doShift) {
	                continue;
	            }
	            if (m_utilCompare2_) {
	                DoSecondaryBytes(ce, notIsContinuation, doFrench);
	            }
	
	            int t = ce & LAST_BYTE_MASK_;
	            if (!notIsContinuation) {
	                t = ce & CE_REMOVE_CONTINUATION_MASK_;
	            }
	
	            if (m_utilCompare0_ && (!isPrimaryByteIgnorable || m_utilCompare2_)) {
	                // do the case level if we need to do it. We don't want to
	                // calculate
	                // case level for primary ignorables if we have only primary
	                // strength and case level
	                // otherwise we would break well formedness of CEs
	                caseShift = DoCaseBytes(t, notIsContinuation, caseShift);
	            } else if (notIsContinuation) {
	                t ^= m_caseSwitch_;
	            }
	
	            t &= m_mask3_;
	
	            if (m_utilCompare3_) {
	                DoTertiaryBytes(t, notIsContinuation);
	            }
	
	            if (m_utilCompare4_ && notIsContinuation) { // compare quad
	                DoQuaternaryBytes(m_srcUtilColEIter_.m_isCodePointHiragana_,
	                        commonBottom4, bottomCount4, hiragana4);
	            }
	        }
	        SetDecomposition(backupDecomposition); // reverts to original
	        if (m_utilFrenchStart_ != -1) {
	            // one last round of checks
	            ReverseBuffer(m_utilBytes2_);
	        }
	    }
	
	    /// <summary>
	    /// From the individual strength byte results the final compact sortkey will
	    /// be calculated.
	    /// </summary>
	    ///
	    /// <param name="source">text string</param>
	    /// <param name="doFrench">flag indicating that special handling of French has to be done</param>
	    /// <param name="commonBottom4">smallest common quaternary byte</param>
	    /// <param name="bottomCount4">smallest quaternary byte</param>
	    /// <param name="key">output RawCollationKey to store results, key cannot be null</param>
	    private void GetSortKey(String source, bool doFrench,
	            int commonBottom4, int bottomCount4, RawCollationKey key) {
	        // we have done all the CE's, now let's put them together to form
	        // a key
	        if (m_utilCompare2_) {
	            DoSecondary(doFrench);
	        }
	        // adding case level should be independent of secondary level
	        if (m_utilCompare0_) {
	            DoCase();
	        }
	        if (m_utilCompare3_) {
	            DoTertiary();
	            if (m_utilCompare4_) {
	                DoQuaternary(commonBottom4, bottomCount4);
	                if (m_utilCompare5_) {
	                    DoIdentical(source);
	                }
	
	            }
	        }
	        m_utilBytes1_ = Append(m_utilBytes1_, m_utilBytesCount1_, (byte) 0);
	        m_utilBytesCount1_++;
	
	        key.Set(m_utilBytes1_, 0, m_utilBytesCount1_);
	    }
	
	    /// <summary>
	    /// Packs the French bytes
	    /// </summary>
	    ///
	    private void DoFrench() {
	        for (int i = 0; i < m_utilBytesCount2_; i++) {
	            byte s = m_utilBytes2_[m_utilBytesCount2_ - i - 1];
	            // This is compression code.
	            if (s == COMMON_2_) {
	                ++m_utilCount2_;
	            } else {
	                if (m_utilCount2_ > 0) {
	                    // getting the unsigned value
	                    if ((s & LAST_BYTE_MASK_) > COMMON_2_) {
	                        // not necessary for 4th level.
	                        while (m_utilCount2_ > TOP_COUNT_2_) {
	                            m_utilBytes1_ = Append(m_utilBytes1_,
	                                    m_utilBytesCount1_,
	                                    (byte) (COMMON_TOP_2_ - TOP_COUNT_2_));
	                            m_utilBytesCount1_++;
	                            m_utilCount2_ -= TOP_COUNT_2_;
	                        }
	                        m_utilBytes1_ = Append(m_utilBytes1_,
	                                m_utilBytesCount1_,
	                                (byte) (COMMON_TOP_2_ - (m_utilCount2_ - 1)));
	                        m_utilBytesCount1_++;
	                    } else {
	                        while (m_utilCount2_ > BOTTOM_COUNT_2_) {
	                            m_utilBytes1_ = Append(m_utilBytes1_,
	                                    m_utilBytesCount1_,
	                                    (byte) (COMMON_BOTTOM_2_ + BOTTOM_COUNT_2_));
	                            m_utilBytesCount1_++;
	                            m_utilCount2_ -= BOTTOM_COUNT_2_;
	                        }
	                        m_utilBytes1_ = Append(m_utilBytes1_,
	                                m_utilBytesCount1_,
	                                (byte) (COMMON_BOTTOM_2_ + (m_utilCount2_ - 1)));
	                        m_utilBytesCount1_++;
	                    }
	                    m_utilCount2_ = 0;
	                }
	                m_utilBytes1_ = Append(m_utilBytes1_, m_utilBytesCount1_, s);
	                m_utilBytesCount1_++;
	            }
	        }
	        if (m_utilCount2_ > 0) {
	            while (m_utilCount2_ > BOTTOM_COUNT_2_) {
	                m_utilBytes1_ = Append(m_utilBytes1_, m_utilBytesCount1_,
	                        (byte) (COMMON_BOTTOM_2_ + BOTTOM_COUNT_2_));
	                m_utilBytesCount1_++;
	                m_utilCount2_ -= BOTTOM_COUNT_2_;
	            }
	            m_utilBytes1_ = Append(m_utilBytes1_, m_utilBytesCount1_,
	                    (byte) (COMMON_BOTTOM_2_ + (m_utilCount2_ - 1)));
	            m_utilBytesCount1_++;
	        }
	    }
	
	    /// <summary>
	    /// Compacts the secondary bytes and stores them into the primary array
	    /// </summary>
	    ///
	    /// <param name="doFrench">flag indicator that French has to be handled specially</param>
	    private void DoSecondary(bool doFrench) {
	        if (m_utilCount2_ > 0) {
	            while (m_utilCount2_ > BOTTOM_COUNT_2_) {
	                m_utilBytes2_ = Append(m_utilBytes2_, m_utilBytesCount2_,
	                        (byte) (COMMON_BOTTOM_2_ + BOTTOM_COUNT_2_));
	                m_utilBytesCount2_++;
	                m_utilCount2_ -= BOTTOM_COUNT_2_;
	            }
	            m_utilBytes2_ = Append(m_utilBytes2_, m_utilBytesCount2_,
	                    (byte) (COMMON_BOTTOM_2_ + (m_utilCount2_ - 1)));
	            m_utilBytesCount2_++;
	        }
	
	        m_utilBytes1_ = Append(m_utilBytes1_, m_utilBytesCount1_,
	                SORT_LEVEL_TERMINATOR_);
	        m_utilBytesCount1_++;
	
	        if (doFrench) { // do the reverse copy
	            DoFrench();
	        } else {
	            if (m_utilBytes1_.Length <= m_utilBytesCount1_ + m_utilBytesCount2_) {
	                m_utilBytes1_ = Increase(m_utilBytes1_, m_utilBytesCount1_,
	                        m_utilBytesCount2_);
	            }
	            System.Array.Copy((Array)(m_utilBytes2_),0,(Array)(m_utilBytes1_),m_utilBytesCount1_,m_utilBytesCount2_);
	            m_utilBytesCount1_ += m_utilBytesCount2_;
	        }
	    }
	
	    /// <summary>
	    /// Increase buffer size
	    /// </summary>
	    ///
	    /// <param name="buffer">array of bytes</param>
	    /// <param name="size">of the byte array</param>
	    /// <param name="incrementsize">size to increase</param>
	    /// <returns>the new buffer</returns>
	    private static byte[] Increase(byte[] buffer, int size,
	            int incrementsize) {
	        byte[] result = new byte[buffer.Length + incrementsize];
	        System.Array.Copy((Array)(buffer),0,(Array)(result),0,size);
	        return result;
	    }
	
	    /// <summary>
	    /// Increase buffer size
	    /// </summary>
	    ///
	    /// <param name="buffer">array of ints</param>
	    /// <param name="size">of the byte array</param>
	    /// <param name="incrementsize">size to increase</param>
	    /// <returns>the new buffer</returns>
	    private static int[] Increase(int[] buffer, int size,
	            int incrementsize) {
	        int[] result = new int[buffer.Length + incrementsize];
	        System.Array.Copy((Array)(buffer),0,(Array)(result),0,size);
	        return result;
	    }
	
	    /// <summary>
	    /// Compacts the case bytes and stores them into the primary array
	    /// </summary>
	    ///
	    private void DoCase() {
	        m_utilBytes1_ = Append(m_utilBytes1_, m_utilBytesCount1_,
	                SORT_LEVEL_TERMINATOR_);
	        m_utilBytesCount1_++;
	        if (m_utilBytes1_.Length <= m_utilBytesCount1_ + m_utilBytesCount0_) {
	            m_utilBytes1_ = Increase(m_utilBytes1_, m_utilBytesCount1_,
	                    m_utilBytesCount0_);
	        }
	        System.Array.Copy((Array)(m_utilBytes0_),0,(Array)(m_utilBytes1_),m_utilBytesCount1_,m_utilBytesCount0_);
	        m_utilBytesCount1_ += m_utilBytesCount0_;
	    }
	
	    /// <summary>
	    /// Compacts the tertiary bytes and stores them into the primary array
	    /// </summary>
	    ///
	    private void DoTertiary() {
	        if (m_utilCount3_ > 0) {
	            if (m_common3_ != COMMON_BOTTOM_3_) {
	                while (m_utilCount3_ >= m_topCount3_) {
	                    m_utilBytes3_ = Append(m_utilBytes3_, m_utilBytesCount3_,
	                            (byte) (m_top3_ - m_topCount3_));
	                    m_utilBytesCount3_++;
	                    m_utilCount3_ -= m_topCount3_;
	                }
	                m_utilBytes3_ = Append(m_utilBytes3_, m_utilBytesCount3_,
	                        (byte) (m_top3_ - m_utilCount3_));
	                m_utilBytesCount3_++;
	            } else {
	                while (m_utilCount3_ > m_bottomCount3_) {
	                    m_utilBytes3_ = Append(m_utilBytes3_, m_utilBytesCount3_,
	                            (byte) (m_bottom3_ + m_bottomCount3_));
	                    m_utilBytesCount3_++;
	                    m_utilCount3_ -= m_bottomCount3_;
	                }
	                m_utilBytes3_ = Append(m_utilBytes3_, m_utilBytesCount3_,
	                        (byte) (m_bottom3_ + (m_utilCount3_ - 1)));
	                m_utilBytesCount3_++;
	            }
	        }
	        m_utilBytes1_ = Append(m_utilBytes1_, m_utilBytesCount1_,
	                SORT_LEVEL_TERMINATOR_);
	        m_utilBytesCount1_++;
	        if (m_utilBytes1_.Length <= m_utilBytesCount1_ + m_utilBytesCount3_) {
	            m_utilBytes1_ = Increase(m_utilBytes1_, m_utilBytesCount1_,
	                    m_utilBytesCount3_);
	        }
	        System.Array.Copy((Array)(m_utilBytes3_),0,(Array)(m_utilBytes1_),m_utilBytesCount1_,m_utilBytesCount3_);
	        m_utilBytesCount1_ += m_utilBytesCount3_;
	    }
	
	    /// <summary>
	    /// Compacts the quaternary bytes and stores them into the primary array
	    /// </summary>
	    ///
	    private void DoQuaternary(int commonbottom4, int bottomcount4) {
	        if (m_utilCount4_ > 0) {
	            while (m_utilCount4_ > bottomcount4) {
	                m_utilBytes4_ = Append(m_utilBytes4_, m_utilBytesCount4_,
	                        (byte) (commonbottom4 + bottomcount4));
	                m_utilBytesCount4_++;
	                m_utilCount4_ -= bottomcount4;
	            }
	            m_utilBytes4_ = Append(m_utilBytes4_, m_utilBytesCount4_,
	                    (byte) (commonbottom4 + (m_utilCount4_ - 1)));
	            m_utilBytesCount4_++;
	        }
	        m_utilBytes1_ = Append(m_utilBytes1_, m_utilBytesCount1_,
	                SORT_LEVEL_TERMINATOR_);
	        m_utilBytesCount1_++;
	        if (m_utilBytes1_.Length <= m_utilBytesCount1_ + m_utilBytesCount4_) {
	            m_utilBytes1_ = Increase(m_utilBytes1_, m_utilBytesCount1_,
	                    m_utilBytesCount4_);
	        }
	        System.Array.Copy((Array)(m_utilBytes4_),0,(Array)(m_utilBytes1_),m_utilBytesCount1_,m_utilBytesCount4_);
	        m_utilBytesCount1_ += m_utilBytesCount4_;
	    }
	
	    /// <summary>
	    /// Deals with the identical sort. Appends the BOCSU version of the source
	    /// string to the ends of the byte buffer.
	    /// </summary>
	    ///
	    /// <param name="source">text string</param>
	    private void DoIdentical(String source) {
	        int isize = IBM.ICU.Impl.BOCU.GetCompressionLength(source);
	        m_utilBytes1_ = Append(m_utilBytes1_, m_utilBytesCount1_,
	                SORT_LEVEL_TERMINATOR_);
	        m_utilBytesCount1_++;
	        if (m_utilBytes1_.Length <= m_utilBytesCount1_ + isize) {
	            m_utilBytes1_ = Increase(m_utilBytes1_, m_utilBytesCount1_,
	                    1 + isize);
	        }
	        m_utilBytesCount1_ = IBM.ICU.Impl.BOCU.Compress(source, m_utilBytes1_,
	                m_utilBytesCount1_);
	    }
	
	    /// <summary>
	    /// Gets the offset of the first unmatched characters in source and target.
	    /// This method returns the offset of the start of a contraction or a
	    /// combining sequence, if the first difference is in the middle of such a
	    /// sequence.
	    /// </summary>
	    ///
	    /// <param name="source">string</param>
	    /// <param name="target">string</param>
	    /// <returns>offset of the first unmatched characters in source and target.</returns>
	    private int GetFirstUnmatchedOffset(String source, String target) {
	        int result = 0;
	        int slength = source.Length;
	        int tlength = target.Length;
	        int minlength = slength;
	        if (minlength > tlength) {
	            minlength = tlength;
	        }
	        while (result < minlength
	                && source[result] == target[result]) {
	            result++;
	        }
	        if (result > 0) {
	            // There is an identical portion at the beginning of the two
	            // strings. If the identical portion ends within a contraction or a
	            // combining character sequence, back up to the start of that
	            // sequence.
	            char schar = (char) (0);
	            char tchar = (char) (0);
	            if (result < minlength) {
	                schar = source[result]; // first differing chars
	                tchar = target[result];
	            } else {
	                schar = source[minlength - 1];
	                if (IsUnsafe(schar)) {
	                    tchar = schar;
	                } else if (slength == tlength) {
	                    return result;
	                } else if (slength < tlength) {
	                    tchar = target[result];
	                } else {
	                    schar = source[result];
	                }
	            }
	            if (IsUnsafe(schar) || IsUnsafe(tchar)) {
	                // We are stopped in the middle of a contraction or combining
	                // sequence.
	                // Look backwards for the part of the string for the start of
	                // the sequence
	                // It doesn't matter which string we scan, since they are the
	                // same in this region.
	                do {
	                    result--;
	                } while (result > 0 && IsUnsafe(source[result]));
	            }
	        }
	        return result;
	    }
	
	    /// <summary>
	    /// Appending an byte to an array of bytes and increases it if we run out of
	    /// space
	    /// </summary>
	    ///
	    /// <param name="array">of byte arrays</param>
	    /// <param name="appendindex">index in the byte array to append</param>
	    /// <param name="value">to append</param>
	    /// <returns>array if array size can accomodate the new value, otherwise a
	    /// bigger array will be created and returned</returns>
	    private static byte[] Append(byte[] array, int appendindex, byte value_ren) {
	        try {
	            array[appendindex] = value_ren;
	        } catch (IndexOutOfRangeException e) {
	            array = Increase(array, appendindex, SORT_BUFFER_INIT_SIZE_);
	            array[appendindex] = value_ren;
	        }
	        return array;
	    }
	
	    /// <summary>
	    /// This is a trick string compare function that goes in and uses sortkeys to
	    /// compare. It is used when compare gets in trouble and needs to bail out.
	    /// </summary>
	    ///
	    /// <param name="source">text string</param>
	    /// <param name="target">text string</param>
	    private int CompareBySortKeys(String source, String target)
	
	    {
	        m_utilRawCollationKey_ = GetRawCollationKey(source,
	                m_utilRawCollationKey_);
	        // this method is very seldom called
	        RawCollationKey targetkey = GetRawCollationKey(target, null);
	        return m_utilRawCollationKey_.CompareTo(targetkey);
	    }
	
	    /// <summary>
	    /// Performs the primary comparisons, and fills up the CE buffer at the same
	    /// time. The return value toggles between the comparison result and the
	    /// hiragana result. If either the source is greater than target or vice
	    /// versa, the return result is the comparison result, ie 1 or -1,
	    /// furthermore the cebuffers will be cleared when that happens. If the
	    /// primary comparisons are equal, we'll have to continue with secondary
	    /// comparison. In this case the cebuffer will not be cleared and the return
	    /// result will be the hiragana result.
	    /// </summary>
	    ///
	    /// <param name="doHiragana4">flag indicator that Hiragana Quaternary has to be observed</param>
	    /// <param name="lowestpvalue">the lowest primary value that will not be ignored if alternatehandling is shifted</param>
	    /// <param name="source">text string</param>
	    /// <param name="target">text string</param>
	    /// <param name="textoffset">offset in text to start the comparison</param>
	    /// <returns>comparion result if a primary difference is found, otherwise
	    /// hiragana result</returns>
	    private int DoPrimaryCompare(bool doHiragana4, int lowestpvalue,
	            String source, String target, int textoffset)
	
	    {
	        // Preparing the context objects for iterating over strings
	        m_srcUtilIter_.SetText(source);
	        m_srcUtilColEIter_.SetText(m_srcUtilIter_, textoffset);
	        m_tgtUtilIter_.SetText(target);
	        m_tgtUtilColEIter_.SetText(m_tgtUtilIter_, textoffset);
	
	        // Non shifted primary processing is quite simple
	        if (!m_isAlternateHandlingShifted_) {
	            int hiraganaresult = 0;
	            while (true) {
	                int sorder = 0;
	                // We fetch CEs until we hit a non ignorable primary or end.
	                do {
	                    sorder = m_srcUtilColEIter_.Next();
	                    m_srcUtilCEBuffer_ = Append(m_srcUtilCEBuffer_,
	                            m_srcUtilCEBufferSize_, sorder);
	                    m_srcUtilCEBufferSize_++;
	                    sorder &= CE_PRIMARY_MASK_;
	                } while (sorder == IBM.ICU.Text.CollationElementIterator.IGNORABLE);
	
	                int torder = 0;
	                do {
	                    torder = m_tgtUtilColEIter_.Next();
	                    m_tgtUtilCEBuffer_ = Append(m_tgtUtilCEBuffer_,
	                            m_tgtUtilCEBufferSize_, torder);
	                    m_tgtUtilCEBufferSize_++;
	                    torder &= CE_PRIMARY_MASK_;
	                } while (torder == IBM.ICU.Text.CollationElementIterator.IGNORABLE);
	
	                // if both primaries are the same
	                if (sorder == torder) {
	                    // and there are no more CEs, we advance to the next level
	                    // see if we are at the end of either string
	                    if (m_srcUtilCEBuffer_[m_srcUtilCEBufferSize_ - 1] == IBM.ICU.Text.CollationElementIterator.NULLORDER) {
	                        if (m_tgtUtilCEBuffer_[m_tgtUtilCEBufferSize_ - 1] != IBM.ICU.Text.CollationElementIterator.NULLORDER) {
	                            return -1;
	                        }
	                        break;
	                    } else if (m_tgtUtilCEBuffer_[m_tgtUtilCEBufferSize_ - 1] == IBM.ICU.Text.CollationElementIterator.NULLORDER) {
	                        return 1;
	                    }
	                    if (doHiragana4
	                            && hiraganaresult == 0
	                            && m_srcUtilColEIter_.m_isCodePointHiragana_ != m_tgtUtilColEIter_.m_isCodePointHiragana_) {
	                        if (m_srcUtilColEIter_.m_isCodePointHiragana_) {
	                            hiraganaresult = -1;
	                        } else {
	                            hiraganaresult = 1;
	                        }
	                    }
	                } else {
	                    // if two primaries are different, we are done
	                    return EndPrimaryCompare(sorder, torder);
	                }
	            }
	            // no primary difference... do the rest from the buffers
	            return hiraganaresult;
	        } else { // shifted - do a slightly more complicated processing :)
	            while (true) {
	                int sorder_0 = GetPrimaryShiftedCompareCE(m_srcUtilColEIter_,
	                        lowestpvalue, true);
	                int torder_1 = GetPrimaryShiftedCompareCE(m_tgtUtilColEIter_,
	                        lowestpvalue, false);
	                if (sorder_0 == torder_1) {
	                    if (m_srcUtilCEBuffer_[m_srcUtilCEBufferSize_ - 1] == IBM.ICU.Text.CollationElementIterator.NULLORDER) {
	                        break;
	                    } else {
	                        continue;
	                    }
	                } else {
	                    return EndPrimaryCompare(sorder_0, torder_1);
	                }
	            } // no primary difference... do the rest from the buffers
	        }
	        return 0;
	    }
	
	    /// <summary>
	    /// This is used only for primary strength when we know that sorder is
	    /// already different from torder. Compares sorder and torder, returns -1 if
	    /// sorder is less than torder. Clears the cebuffer at the same time.
	    /// </summary>
	    ///
	    /// <param name="sorder">source strength order</param>
	    /// <param name="torder">target strength order</param>
	    /// <returns>the comparison result of sorder and torder</returns>
	    private int EndPrimaryCompare(int sorder, int torder) {
	        // if we reach here, the ce offset accessed is the last ce
	        // appended to the buffer
	        bool isSourceNullOrder = (m_srcUtilCEBuffer_[m_srcUtilCEBufferSize_ - 1] == IBM.ICU.Text.CollationElementIterator.NULLORDER);
	        bool isTargetNullOrder = (m_tgtUtilCEBuffer_[m_tgtUtilCEBufferSize_ - 1] == IBM.ICU.Text.CollationElementIterator.NULLORDER);
	        m_srcUtilCEBufferSize_ = -1;
	        m_tgtUtilCEBufferSize_ = -1;
	        if (isSourceNullOrder) {
	            return -1;
	        }
	        if (isTargetNullOrder) {
	            return 1;
	        }
	        // getting rid of the sign
	        sorder = (int) (((uint) sorder) >> CE_PRIMARY_SHIFT_);
	        torder = (int) (((uint) torder) >> CE_PRIMARY_SHIFT_);
	        if (sorder < torder) {
	            return -1;
	        }
	        return 1;
	    }
	
	    /// <summary>
	    /// Calculates the next primary shifted value and fills up cebuffer with the
	    /// next non-ignorable ce.
	    /// </summary>
	    ///
	    /// <param name="coleiter">collation element iterator</param>
	    /// <param name="doHiragana4">flag indicator if hiragana quaternary is to be handled</param>
	    /// <param name="lowestpvalue">lowest primary shifted value that will not be ignored</param>
	    /// <returns>result next modified ce</returns>
	    private int GetPrimaryShiftedCompareCE(
	            CollationElementIterator coleiter, int lowestpvalue, bool isSrc)
	
	    {
	        bool shifted = false;
	        int result = IBM.ICU.Text.CollationElementIterator.IGNORABLE;
	        int[] cebuffer = m_srcUtilCEBuffer_;
	        int cebuffersize = m_srcUtilCEBufferSize_;
	        if (!isSrc) {
	            cebuffer = m_tgtUtilCEBuffer_;
	            cebuffersize = m_tgtUtilCEBufferSize_;
	        }
	        while (true) {
	            result = coleiter.Next();
	            if (result == IBM.ICU.Text.CollationElementIterator.NULLORDER) {
	                cebuffer = Append(cebuffer, cebuffersize, result);
	                cebuffersize++;
	                break;
	            } else if (result == IBM.ICU.Text.CollationElementIterator.IGNORABLE
	                    || (shifted && (result & CE_PRIMARY_MASK_) == IBM.ICU.Text.CollationElementIterator.IGNORABLE)) {
	                // UCA amendment - ignore ignorables that follow shifted code
	                // points
	                continue;
	            } else if (IsContinuation(result)) {
	                if ((result & CE_PRIMARY_MASK_) != IBM.ICU.Text.CollationElementIterator.IGNORABLE) {
	                    // There is primary value
	                    if (shifted) {
	                        result = (result & CE_PRIMARY_MASK_)
	                                | CE_CONTINUATION_MARKER_;
	                        // preserve interesting continuation
	                        cebuffer = Append(cebuffer, cebuffersize, result);
	                        cebuffersize++;
	                        continue;
	                    } else {
	                        cebuffer = Append(cebuffer, cebuffersize, result);
	                        cebuffersize++;
	                        break;
	                    }
	                } else { // Just lower level values
	                    if (!shifted) {
	                        cebuffer = Append(cebuffer, cebuffersize, result);
	                        cebuffersize++;
	                    }
	                }
	            } else { // regular
	                if (IBM.ICU.Impl.Utility.CompareUnsigned(result & CE_PRIMARY_MASK_,
	                        lowestpvalue) > 0) {
	                    cebuffer = Append(cebuffer, cebuffersize, result);
	                    cebuffersize++;
	                    break;
	                } else {
	                    if ((result & CE_PRIMARY_MASK_) != 0) {
	                        shifted = true;
	                        result &= CE_PRIMARY_MASK_;
	                        cebuffer = Append(cebuffer, cebuffersize, result);
	                        cebuffersize++;
	                        continue;
	                    } else {
	                        cebuffer = Append(cebuffer, cebuffersize, result);
	                        cebuffersize++;
	                        shifted = false;
	                        continue;
	                    }
	                }
	            }
	        }
	        if (isSrc) {
	            m_srcUtilCEBuffer_ = cebuffer;
	            m_srcUtilCEBufferSize_ = cebuffersize;
	        } else {
	            m_tgtUtilCEBuffer_ = cebuffer;
	            m_tgtUtilCEBufferSize_ = cebuffersize;
	        }
	        result &= CE_PRIMARY_MASK_;
	        return result;
	    }
	
	    /// <summary>
	    /// Appending an int to an array of ints and increases it if we run out of
	    /// space
	    /// </summary>
	    ///
	    /// <param name="array">of int arrays</param>
	    /// <param name="appendindex">index at which value will be appended</param>
	    /// <param name="value">to append</param>
	    /// <returns>array if size is not increased, otherwise a new array will be
	    /// returned</returns>
	    private static int[] Append(int[] array, int appendindex, int value_ren) {
	        if (appendindex + 1 >= array.Length) {
	            array = Increase(array, appendindex, CE_BUFFER_SIZE_);
	        }
	        array[appendindex] = value_ren;
	        return array;
	    }
	
	    /// <summary>
	    /// Does secondary strength comparison based on the collected ces.
	    /// </summary>
	    ///
	    /// <param name="doFrench">flag indicates if French ordering is to be done</param>
	    /// <returns>the secondary strength comparison result</returns>
	    private int DoSecondaryCompare(bool doFrench) {
	        // now, we're gonna reexamine collected CEs
	        if (!doFrench) { // normal
	            int soffset = 0;
	            int toffset = 0;
	            while (true) {
	                int sorder = IBM.ICU.Text.CollationElementIterator.IGNORABLE;
	                while (sorder == IBM.ICU.Text.CollationElementIterator.IGNORABLE) {
	                    sorder = m_srcUtilCEBuffer_[soffset++] & CE_SECONDARY_MASK_;
	                }
	                int torder = IBM.ICU.Text.CollationElementIterator.IGNORABLE;
	                while (torder == IBM.ICU.Text.CollationElementIterator.IGNORABLE) {
	                    torder = m_tgtUtilCEBuffer_[toffset++] & CE_SECONDARY_MASK_;
	                }
	
	                if (sorder == torder) {
	                    if (m_srcUtilCEBuffer_[soffset - 1] == IBM.ICU.Text.CollationElementIterator.NULLORDER) {
	                        if (m_tgtUtilCEBuffer_[toffset - 1] != IBM.ICU.Text.CollationElementIterator.NULLORDER) {
	                            return -1;
	                        }
	                        break;
	                    } else if (m_tgtUtilCEBuffer_[toffset - 1] == IBM.ICU.Text.CollationElementIterator.NULLORDER) {
	                        return 1;
	                    }
	                } else {
	                    if (m_srcUtilCEBuffer_[soffset - 1] == IBM.ICU.Text.CollationElementIterator.NULLORDER) {
	                        return -1;
	                    }
	                    if (m_tgtUtilCEBuffer_[toffset - 1] == IBM.ICU.Text.CollationElementIterator.NULLORDER) {
	                        return 1;
	                    }
	                    return (sorder < torder) ? -1 : 1;
	                }
	            }
	        } else { // do the French
	            m_srcUtilContOffset_ = 0;
	            m_tgtUtilContOffset_ = 0;
	            m_srcUtilOffset_ = m_srcUtilCEBufferSize_ - 2;
	            m_tgtUtilOffset_ = m_tgtUtilCEBufferSize_ - 2;
	            while (true) {
	                int sorder_0 = GetSecondaryFrenchCE(true);
	                int torder_1 = GetSecondaryFrenchCE(false);
	                if (sorder_0 == torder_1) {
	                    if ((m_srcUtilOffset_ < 0 && m_tgtUtilOffset_ < 0)
	                            || (m_srcUtilOffset_ >= 0 && m_srcUtilCEBuffer_[m_srcUtilOffset_] == IBM.ICU.Text.CollationElementIterator.NULLORDER)) {
	                        break;
	                    }
	                } else {
	                    return (sorder_0 < torder_1) ? -1 : 1;
	                }
	            }
	        }
	        return 0;
	    }
	
	    /// <summary>
	    /// Calculates the next secondary french CE.
	    /// </summary>
	    ///
	    /// <param name="isSrc">flag indicator if we are calculating the src ces</param>
	    /// <returns>result next modified ce</returns>
	    private int GetSecondaryFrenchCE(bool isSrc) {
	        int result = IBM.ICU.Text.CollationElementIterator.IGNORABLE;
	        int offset = m_srcUtilOffset_;
	        int continuationoffset = m_srcUtilContOffset_;
	        int[] cebuffer = m_srcUtilCEBuffer_;
	        if (!isSrc) {
	            offset = m_tgtUtilOffset_;
	            continuationoffset = m_tgtUtilContOffset_;
	            cebuffer = m_tgtUtilCEBuffer_;
	        }
	
	        while (result == IBM.ICU.Text.CollationElementIterator.IGNORABLE && offset >= 0) {
	            if (continuationoffset == 0) {
	                result = cebuffer[offset];
	                while (IsContinuation(cebuffer[offset--])) {
	                }
	                // after this, sorder is at the start of continuation,
	                // and offset points before that
	                if (IsContinuation(cebuffer[offset + 1])) {
	                    // save offset for later
	                    continuationoffset = offset;
	                    offset += 2;
	                }
	            } else {
	                result = cebuffer[offset++];
	                if (!IsContinuation(result)) {
	                    // we have finished with this continuation
	                    offset = continuationoffset;
	                    // reset the pointer to before continuation
	                    continuationoffset = 0;
	                    continue;
	                }
	            }
	            result &= CE_SECONDARY_MASK_; // remove continuation bit
	        }
	        if (isSrc) {
	            m_srcUtilOffset_ = offset;
	            m_srcUtilContOffset_ = continuationoffset;
	        } else {
	            m_tgtUtilOffset_ = offset;
	            m_tgtUtilContOffset_ = continuationoffset;
	        }
	        return result;
	    }
	
	    /// <summary>
	    /// Does case strength comparison based on the collected ces.
	    /// </summary>
	    ///
	    /// <returns>the case strength comparison result</returns>
	    private int DoCaseCompare() {
	        int soffset = 0;
	        int toffset = 0;
	        while (true) {
	            int sorder = IBM.ICU.Text.CollationElementIterator.IGNORABLE;
	            int torder = IBM.ICU.Text.CollationElementIterator.IGNORABLE;
	            while ((sorder & CE_REMOVE_CASE_) == IBM.ICU.Text.CollationElementIterator.IGNORABLE) {
	                sorder = m_srcUtilCEBuffer_[soffset++];
	                if (!IsContinuation(sorder)
	                        && ((sorder & CE_PRIMARY_MASK_) != 0 || m_utilCompare2_ == true)) {
	                    // primary ignorables should not be considered on the case
	                    // level when the strength is primary
	                    // otherwise, the CEs stop being well-formed
	                    sorder &= CE_CASE_MASK_3_;
	                    sorder ^= m_caseSwitch_;
	                } else {
	                    sorder = IBM.ICU.Text.CollationElementIterator.IGNORABLE;
	                }
	            }
	
	            while ((torder & CE_REMOVE_CASE_) == IBM.ICU.Text.CollationElementIterator.IGNORABLE) {
	                torder = m_tgtUtilCEBuffer_[toffset++];
	                if (!IsContinuation(torder)
	                        && ((torder & CE_PRIMARY_MASK_) != 0 || m_utilCompare2_ == true)) {
	                    // primary ignorables should not be considered on the case
	                    // level when the strength is primary
	                    // otherwise, the CEs stop being well-formed
	                    torder &= CE_CASE_MASK_3_;
	                    torder ^= m_caseSwitch_;
	                } else {
	                    torder = IBM.ICU.Text.CollationElementIterator.IGNORABLE;
	                }
	            }
	
	            sorder &= CE_CASE_BIT_MASK_;
	            torder &= CE_CASE_BIT_MASK_;
	            if (sorder == torder) {
	                // checking end of strings
	                if (m_srcUtilCEBuffer_[soffset - 1] == IBM.ICU.Text.CollationElementIterator.NULLORDER) {
	                    if (m_tgtUtilCEBuffer_[toffset - 1] != IBM.ICU.Text.CollationElementIterator.NULLORDER) {
	                        return -1;
	                    }
	                    break;
	                } else if (m_tgtUtilCEBuffer_[toffset - 1] == IBM.ICU.Text.CollationElementIterator.NULLORDER) {
	                    return 1;
	                }
	            } else {
	                if (m_srcUtilCEBuffer_[soffset - 1] == IBM.ICU.Text.CollationElementIterator.NULLORDER) {
	                    return -1;
	                }
	                if (m_tgtUtilCEBuffer_[soffset - 1] == IBM.ICU.Text.CollationElementIterator.NULLORDER) {
	                    return 1;
	                }
	                return (sorder < torder) ? -1 : 1;
	            }
	        }
	        return 0;
	    }
	
	    /// <summary>
	    /// Does tertiary strength comparison based on the collected ces.
	    /// </summary>
	    ///
	    /// <returns>the tertiary strength comparison result</returns>
	    private int DoTertiaryCompare() {
	        int soffset = 0;
	        int toffset = 0;
	        while (true) {
	            int sorder = IBM.ICU.Text.CollationElementIterator.IGNORABLE;
	            int torder = IBM.ICU.Text.CollationElementIterator.IGNORABLE;
	            while ((sorder & CE_REMOVE_CASE_) == IBM.ICU.Text.CollationElementIterator.IGNORABLE) {
	                sorder = m_srcUtilCEBuffer_[soffset++] & m_mask3_;
	                if (!IsContinuation(sorder)) {
	                    sorder ^= m_caseSwitch_;
	                } else {
	                    sorder &= CE_REMOVE_CASE_;
	                }
	            }
	
	            while ((torder & CE_REMOVE_CASE_) == IBM.ICU.Text.CollationElementIterator.IGNORABLE) {
	                torder = m_tgtUtilCEBuffer_[toffset++] & m_mask3_;
	                if (!IsContinuation(torder)) {
	                    torder ^= m_caseSwitch_;
	                } else {
	                    torder &= CE_REMOVE_CASE_;
	                }
	            }
	
	            if (sorder == torder) {
	                if (m_srcUtilCEBuffer_[soffset - 1] == IBM.ICU.Text.CollationElementIterator.NULLORDER) {
	                    if (m_tgtUtilCEBuffer_[toffset - 1] != IBM.ICU.Text.CollationElementIterator.NULLORDER) {
	                        return -1;
	                    }
	                    break;
	                } else if (m_tgtUtilCEBuffer_[toffset - 1] == IBM.ICU.Text.CollationElementIterator.NULLORDER) {
	                    return 1;
	                }
	            } else {
	                if (m_srcUtilCEBuffer_[soffset - 1] == IBM.ICU.Text.CollationElementIterator.NULLORDER) {
	                    return -1;
	                }
	                if (m_tgtUtilCEBuffer_[toffset - 1] == IBM.ICU.Text.CollationElementIterator.NULLORDER) {
	                    return 1;
	                }
	                return (sorder < torder) ? -1 : 1;
	            }
	        }
	        return 0;
	    }
	
	    /// <summary>
	    /// Does quaternary strength comparison based on the collected ces.
	    /// </summary>
	    ///
	    /// <param name="lowestpvalue">the lowest primary value that will not be ignored if alternatehandling is shifted</param>
	    /// <returns>the quaternary strength comparison result</returns>
	    private int DoQuaternaryCompare(int lowestpvalue) {
	        bool sShifted = true;
	        bool tShifted = true;
	        int soffset = 0;
	        int toffset = 0;
	        while (true) {
	            int sorder = IBM.ICU.Text.CollationElementIterator.IGNORABLE;
	            int torder = IBM.ICU.Text.CollationElementIterator.IGNORABLE;
	            while (sorder == IBM.ICU.Text.CollationElementIterator.IGNORABLE
	                    || (IsContinuation(sorder) && !sShifted)) {
	                sorder = m_srcUtilCEBuffer_[soffset++];
	                if (IsContinuation(sorder)) {
	                    if (!sShifted) {
	                        continue;
	                    }
	                } else if (IBM.ICU.Impl.Utility.CompareUnsigned(sorder, lowestpvalue) > 0
	                        || (sorder & CE_PRIMARY_MASK_) == IBM.ICU.Text.CollationElementIterator.IGNORABLE) {
	                    // non continuation
	                    sorder = CE_PRIMARY_MASK_;
	                    sShifted = false;
	                } else {
	                    sShifted = true;
	                }
	            }
	            sorder = (int) (((uint) sorder) >> CE_PRIMARY_SHIFT_);
	            while (torder == IBM.ICU.Text.CollationElementIterator.IGNORABLE
	                    || (IsContinuation(torder) && !tShifted)) {
	                torder = m_tgtUtilCEBuffer_[toffset++];
	                if (IsContinuation(torder)) {
	                    if (!tShifted) {
	                        continue;
	                    }
	                } else if (IBM.ICU.Impl.Utility.CompareUnsigned(torder, lowestpvalue) > 0
	                        || (torder & CE_PRIMARY_MASK_) == IBM.ICU.Text.CollationElementIterator.IGNORABLE) {
	                    // non continuation
	                    torder = CE_PRIMARY_MASK_;
	                    tShifted = false;
	                } else {
	                    tShifted = true;
	                }
	            }
	            torder = (int) (((uint) torder) >> CE_PRIMARY_SHIFT_);
	
	            if (sorder == torder) {
	                if (m_srcUtilCEBuffer_[soffset - 1] == IBM.ICU.Text.CollationElementIterator.NULLORDER) {
	                    if (m_tgtUtilCEBuffer_[toffset - 1] != IBM.ICU.Text.CollationElementIterator.NULLORDER) {
	                        return -1;
	                    }
	                    break;
	                } else if (m_tgtUtilCEBuffer_[toffset - 1] == IBM.ICU.Text.CollationElementIterator.NULLORDER) {
	                    return 1;
	                }
	            } else {
	                if (m_srcUtilCEBuffer_[soffset - 1] == IBM.ICU.Text.CollationElementIterator.NULLORDER) {
	                    return -1;
	                }
	                if (m_tgtUtilCEBuffer_[toffset - 1] == IBM.ICU.Text.CollationElementIterator.NULLORDER) {
	                    return 1;
	                }
	                return (sorder < torder) ? -1 : 1;
	            }
	        }
	        return 0;
	    }
	
	    /// <summary>
	    /// Internal function. Does byte level string compare. Used by strcoll if
	    /// strength == identical and strings are otherwise equal. This is a rare
	    /// case. Comparison must be done on NFD normalized strings. FCD is not good
	    /// enough.
	    /// </summary>
	    ///
	    /// <param name="source">text</param>
	    /// <param name="target">text</param>
	    /// <param name="offset">of the first difference in the text strings</param>
	    /// <param name="normalize">flag indicating if we are to normalize the text beforecomparison</param>
	    /// <returns>1 if source is greater than target, -1 less than and 0 if equals</returns>
	    private static int DoIdenticalCompare(String source, String target,
	            int offset, bool normalize)
	
	    {
	        if (normalize) {
	            if (IBM.ICU.Text.Normalizer.QuickCheck(source, IBM.ICU.Text.Normalizer.NFD, 0) != IBM.ICU.Text.Normalizer.YES) {
	                source = IBM.ICU.Text.Normalizer.Decompose(source, false);
	            }
	
	            if (IBM.ICU.Text.Normalizer.QuickCheck(target, IBM.ICU.Text.Normalizer.NFD, 0) != IBM.ICU.Text.Normalizer.YES) {
	                target = IBM.ICU.Text.Normalizer.Decompose(target, false);
	            }
	            offset = 0;
	        }
	
	        return DoStringCompare(source, target, offset);
	    }
	
	    /// <summary>
	    /// Compares string for their codepoint order. This comparison handles
	    /// surrogate characters and place them after the all non surrogate
	    /// characters.
	    /// </summary>
	    ///
	    /// <param name="source">text</param>
	    /// <param name="target">text</param>
	    /// <param name="offset">start offset for comparison</param>
	    /// <returns>1 if source is greater than target, -1 less than and 0 if equals</returns>
	    private static int DoStringCompare(String source, String target,
	            int offset) {
	        // compare identical prefixes - they do not need to be fixed up
	        char schar = (char) (0);
	        char tchar = (char) (0);
	        int slength = source.Length;
	        int tlength = target.Length;
	        int minlength = Math.Min(slength,tlength);
	        while (offset < minlength) {
	            schar = source[offset];
	            tchar = target[offset++];
	            if (schar != tchar) {
	                break;
	            }
	        }
	
	        if (schar == tchar && offset == minlength) {
	            if (slength > minlength) {
	                return 1;
	            }
	            if (tlength > minlength) {
	                return -1;
	            }
	            return 0;
	        }
	
	        // if both values are in or above the surrogate range, Fix them up.
	        if (schar >= IBM.ICU.Text.UTF16.LEAD_SURROGATE_MIN_VALUE
	                && tchar >= IBM.ICU.Text.UTF16.LEAD_SURROGATE_MIN_VALUE) {
	            schar = FixupUTF16(schar);
	            tchar = FixupUTF16(tchar);
	        }
	
	        // now c1 and c2 are in UTF-32-compatible order
	        return (schar < tchar) ? -1 : 1; // schar and tchar has to be different
	    }
	
	    /// <summary>
	    /// Rotate surrogates to the top to get code point order
	    /// </summary>
	    ///
	    private static char FixupUTF16(char ch) {
	        if (ch >= 0xe000) {
	            ch -= ((Char)0x800);
	        } else {
	            ch += ((Char)0x2000);
	        }
	        return ch;
	    }
	
	    /// <summary>
	    /// Resets the internal case data members and compression values.
	    /// </summary>
	    ///
	    private void UpdateInternalState() {
	        if (m_caseFirst_ == IBM.ICU.Text.RuleBasedCollator.AttributeValue.UPPER_FIRST_) {
	            m_caseSwitch_ = CASE_SWITCH_;
	        } else {
	            m_caseSwitch_ = NO_CASE_SWITCH_;
	        }
	
	        if (m_isCaseLevel_ || m_caseFirst_ == IBM.ICU.Text.RuleBasedCollator.AttributeValue.OFF_) {
	            m_mask3_ = CE_REMOVE_CASE_;
	            m_common3_ = COMMON_NORMAL_3_;
	            m_addition3_ = FLAG_BIT_MASK_CASE_SWITCH_OFF_;
	            m_top3_ = COMMON_TOP_CASE_SWITCH_OFF_3_;
	            m_bottom3_ = COMMON_BOTTOM_3_;
	        } else {
	            m_mask3_ = CE_KEEP_CASE_;
	            m_addition3_ = FLAG_BIT_MASK_CASE_SWITCH_ON_;
	            if (m_caseFirst_ == IBM.ICU.Text.RuleBasedCollator.AttributeValue.UPPER_FIRST_) {
	                m_common3_ = COMMON_UPPER_FIRST_3_;
	                m_top3_ = COMMON_TOP_CASE_SWITCH_UPPER_3_;
	                m_bottom3_ = COMMON_BOTTOM_CASE_SWITCH_UPPER_3_;
	            } else {
	                m_common3_ = COMMON_NORMAL_3_;
	                m_top3_ = COMMON_TOP_CASE_SWITCH_LOWER_3_;
	                m_bottom3_ = COMMON_BOTTOM_CASE_SWITCH_LOWER_3_;
	            }
	        }
	
	        // Set the compression values
	        int total3 = m_top3_ - COMMON_BOTTOM_3_ - 1;
	        // we multilply double with int, but need only int
	        m_topCount3_ = (int) (PROPORTION_3_ * total3);
	        m_bottomCount3_ = total3 - m_topCount3_;
	
	        if (!m_isCaseLevel_ && GetStrength() == IBM.ICU.Text.RuleBasedCollator.AttributeValue.TERTIARY_
	                && !m_isFrenchCollation_ && !m_isAlternateHandlingShifted_) {
	            m_isSimple3_ = true;
	        } else {
	            m_isSimple3_ = false;
	        }
	        if (!m_isCaseLevel_ && GetStrength() <= IBM.ICU.Text.RuleBasedCollator.AttributeValue.TERTIARY_
	                && !m_isNumericCollation_ && !m_isAlternateHandlingShifted_
	                && !latinOneFailed_) {
	            if (latinOneCEs_ == null || latinOneRegenTable_) {
	                if (SetUpLatinOne()) { // if we succeed in building latin1
	                                       // table, we'll use it
	                    latinOneUse_ = true;
	                } else {
	                    latinOneUse_ = false;
	                    latinOneFailed_ = true;
	                }
	                latinOneRegenTable_ = false;
	            } else { // latin1Table exists and it doesn't need to be
	                     // regenerated, just use it
	                latinOneUse_ = true;
	            }
	        } else {
	            latinOneUse_ = false;
	        }
	
	    }
	
	    /// <summary>
	    /// Initializes the RuleBasedCollator
	    /// </summary>
	    ///
	    private void Init() {
	        for (m_minUnsafe_ = ((Char)0); m_minUnsafe_ < DEFAULT_MIN_HEURISTIC_; m_minUnsafe_++) {
	            // Find the smallest unsafe char.
	            if (IsUnsafe(m_minUnsafe_)) {
	                break;
	            }
	        }
	
	        for (m_minContractionEnd_ = ((Char)0); m_minContractionEnd_ < DEFAULT_MIN_HEURISTIC_; m_minContractionEnd_++) {
	            // Find the smallest contraction-ending char.
	            if (IsContractionEnd(m_minContractionEnd_)) {
	                break;
	            }
	        }
	        latinOneFailed_ = true;
	        SetStrength(m_defaultStrength_);
	        SetDecomposition(m_defaultDecomposition_);
	        m_variableTopValue_ = m_defaultVariableTopValue_;
	        m_isFrenchCollation_ = m_defaultIsFrenchCollation_;
	        m_isAlternateHandlingShifted_ = m_defaultIsAlternateHandlingShifted_;
	        m_isCaseLevel_ = m_defaultIsCaseLevel_;
	        m_caseFirst_ = m_defaultCaseFirst_;
	        m_isHiragana4_ = m_defaultIsHiragana4_;
	        m_isNumericCollation_ = m_defaultIsNumericCollation_;
	        latinOneFailed_ = false;
	        UpdateInternalState();
	    }
	
	    /// <summary>
	    /// Initializes utility iterators and byte buffer used by compare
	    /// </summary>
	    ///
	    private void InitUtility(bool allocate) {
	        if (allocate) {
	            if (m_srcUtilIter_ == null) {
	                m_srcUtilIter_ = new StringUCharacterIterator();
	                m_srcUtilColEIter_ = new CollationElementIterator(
	                        m_srcUtilIter_, this);
	                m_tgtUtilIter_ = new StringUCharacterIterator();
	                m_tgtUtilColEIter_ = new CollationElementIterator(
	                        m_tgtUtilIter_, this);
	                m_utilBytes0_ = new byte[SORT_BUFFER_INIT_SIZE_CASE_]; // case
	                m_utilBytes1_ = new byte[SORT_BUFFER_INIT_SIZE_1_]; // primary
	                m_utilBytes2_ = new byte[SORT_BUFFER_INIT_SIZE_2_]; // secondary
	                m_utilBytes3_ = new byte[SORT_BUFFER_INIT_SIZE_3_]; // tertiary
	                m_utilBytes4_ = new byte[SORT_BUFFER_INIT_SIZE_4_]; // Quaternary
	                m_srcUtilCEBuffer_ = new int[CE_BUFFER_SIZE_];
	                m_tgtUtilCEBuffer_ = new int[CE_BUFFER_SIZE_];
	            }
	        } else {
	            m_srcUtilIter_ = null;
	            m_srcUtilColEIter_ = null;
	            m_tgtUtilIter_ = null;
	            m_tgtUtilColEIter_ = null;
	            m_utilBytes0_ = null;
	            m_utilBytes1_ = null;
	            m_utilBytes2_ = null;
	            m_utilBytes3_ = null;
	            m_utilBytes4_ = null;
	            m_srcUtilCEBuffer_ = null;
	            m_tgtUtilCEBuffer_ = null;
	        }
	    }
	
	    // Consts for Latin-1 special processing
	    private const int ENDOFLATINONERANGE_ = 0xFF;
	
	    private const int LATINONETABLELEN_ = (ENDOFLATINONERANGE_ + 50);
	
	    private const int BAIL_OUT_CE_ = -16777216;
	
	    /// <summary>
	    /// Generate latin-1 tables
	    /// </summary>
	    ///
	
	    private class shiftValues {
	        public shiftValues() {
	            this.primShift = 24;
	            this.secShift = 24;
	            this.terShift = 24;
	        }
	
	        internal int primShift;
	
	        internal int secShift;
	
	        internal int terShift;
	    }
	
	    private void AddLatinOneEntry(char ch, int CE, RuleBasedCollator.shiftValues  sh) {
	        int primary1 = 0, primary2 = 0, secondary = 0, tertiary = 0;
	        bool reverseSecondary = false;
	        if (!IsContinuation(CE)) {
	            tertiary = ((CE & m_mask3_));
	            tertiary ^= m_caseSwitch_;
	            reverseSecondary = true;
	        } else {
	            tertiary = (byte) ((CE & CE_REMOVE_CONTINUATION_MASK_));
	            tertiary &= CE_REMOVE_CASE_;
	            reverseSecondary = false;
	        }
	
	        secondary = ((CE = (int) (((uint) CE) >> 8)) & LAST_BYTE_MASK_);
	        primary2 = ((CE = (int) (((uint) CE) >> 8)) & LAST_BYTE_MASK_);
	        primary1 = ((int) (((uint) CE) >> 8));
	
	        if (primary1 != 0) {
	            latinOneCEs_[ch] |= (primary1 << sh.primShift);
	            sh.primShift -= 8;
	        }
	        if (primary2 != 0) {
	            if (sh.primShift < 0) {
	                latinOneCEs_[ch] = BAIL_OUT_CE_;
	                latinOneCEs_[latinOneTableLen_ + ch] = BAIL_OUT_CE_;
	                latinOneCEs_[2 * latinOneTableLen_ + ch] = BAIL_OUT_CE_;
	                return;
	            }
	            latinOneCEs_[ch] |= (primary2 << sh.primShift);
	            sh.primShift -= 8;
	        }
	        if (secondary != 0) {
	            if (reverseSecondary && m_isFrenchCollation_) { // reverse secondary
	                latinOneCEs_[latinOneTableLen_ + ch] = (int) (((uint) latinOneCEs_[latinOneTableLen_ + ch]) >> 8); // make space for
	                                                             // secondary
	                latinOneCEs_[latinOneTableLen_ + ch] |= (secondary << 24);
	            } else { // normal case
	                latinOneCEs_[latinOneTableLen_ + ch] |= (secondary << sh.secShift);
	            }
	            sh.secShift -= 8;
	        }
	        if (tertiary != 0) {
	            latinOneCEs_[2 * latinOneTableLen_ + ch] |= (tertiary << sh.terShift);
	            sh.terShift -= 8;
	        }
	    }
	
	    private void ResizeLatinOneTable(int newSize) {
	        int[] newTable = new int[3 * newSize];
	        int sizeToCopy = ((newSize < latinOneTableLen_) ? newSize
	                : latinOneTableLen_);
	        // uprv_memset(newTable, 0, newSize*sizeof(uint32_t)*3); //
	        // automatically cleared.
	        System.Array.Copy((Array)(latinOneCEs_),0,(Array)(newTable),0,sizeToCopy);
	        System.Array.Copy((Array)(latinOneCEs_),latinOneTableLen_,(Array)(newTable),newSize,sizeToCopy);
	        System.Array.Copy((Array)(latinOneCEs_),2 * latinOneTableLen_,(Array)(newTable),2 * newSize,sizeToCopy);
	        latinOneTableLen_ = newSize;
	        latinOneCEs_ = newTable;
	    }
	
	    private bool SetUpLatinOne() {
	        if (latinOneCEs_ == null || m_reallocLatinOneCEs_) {
	            latinOneCEs_ = new int[3 * LATINONETABLELEN_];
	            latinOneTableLen_ = LATINONETABLELEN_;
	            m_reallocLatinOneCEs_ = false;
	        } else {
	            ILOG.J2CsMapping.Collections.Arrays.Fill(latinOneCEs_,0);
	        }
	        if (m_ContInfo_ == null) {
	            m_ContInfo_ = new RuleBasedCollator.ContractionInfo ();
	        }
	        char ch = (char) (0);
	        // StringBuffer sCh = new StringBuffer();
	        // CollationElementIterator it =
	        // getCollationElementIterator(sCh.toString());
	        CollationElementIterator it = GetCollationElementIterator("");
	
	        RuleBasedCollator.shiftValues  s = new RuleBasedCollator.shiftValues ();
	        int CE = 0;
	        char contractionOffset = (char) (ENDOFLATINONERANGE_ + 1);
	
	        for (ch = ((Char)0); ch <= ENDOFLATINONERANGE_; ch++) {
	            s.primShift = 24;
	            s.secShift = 24;
	            s.terShift = 24;
	            if (ch < 0x100) {
	                CE = m_trie_.GetLatin1LinearValue(ch);
	            } else {
	                CE = m_trie_.GetLeadValue(ch);
	                if (CE == IBM.ICU.Text.CollationElementIterator.CE_NOT_FOUND_) {
	                    CE = UCA_.m_trie_.GetLeadValue(ch);
	                }
	            }
	            if (!IsSpecial(CE)) {
	                AddLatinOneEntry(ch, CE, s);
	            } else {
	                switch (RuleBasedCollator.GetTag(CE)) {
	                case IBM.ICU.Text.CollationElementIterator.CE_EXPANSION_TAG_:
	                case IBM.ICU.Text.CollationElementIterator.CE_DIGIT_TAG_:
	                    // sCh.delete(0, sCh.length());
	                    // sCh.append(ch);
	                    // it.setText(sCh.toString());
	                    it.SetText(IBM.ICU.Lang.UCharacter.ToString(ch));
	                    while ((CE = it.Next()) != IBM.ICU.Text.CollationElementIterator.NULLORDER) {
	                        if (s.primShift < 0 || s.secShift < 0 || s.terShift < 0) {
	                            latinOneCEs_[ch] = BAIL_OUT_CE_;
	                            latinOneCEs_[latinOneTableLen_ + ch] = BAIL_OUT_CE_;
	                            latinOneCEs_[2 * latinOneTableLen_ + ch] = BAIL_OUT_CE_;
	                            break;
	                        }
	                        AddLatinOneEntry(ch, CE, s);
	                    }
	                    break;
	                case IBM.ICU.Text.CollationElementIterator.CE_CONTRACTION_TAG_:
	                    // here is the trick
	                    // F2 is contraction. We do something very similar to
	                    // contractions
	                    // but have two indices, one in the real contraction table
	                    // and the
	                    // other to where we stuffed things. This hopes that we
	                    // don't have
	                    // many contractions (this should work for latin-1 tables).
	                {
	                    if ((CE & 0x00FFF000) != 0) {
	                        latinOneFailed_ = true;
	                        return false;
	                    }
	
	                    int UCharOffset = (CE & 0xFFFFFF) - m_contractionOffset_; // getContractionOffset(CE)]
	
	                    CE |= (contractionOffset & 0xFFF) << 12; // insert the
	                                                             // offset in
	                                                             // latin-1 table
	
	                    latinOneCEs_[ch] = CE;
	                    latinOneCEs_[latinOneTableLen_ + ch] = CE;
	                    latinOneCEs_[2 * latinOneTableLen_ + ch] = CE;
	
	                    // We're going to jump into contraction table, pick the
	                    // elements
	                    // and use them
	                    do {
	                        // CE = *(contractionCEs + (UCharOffset -
	                        // contractionIndex));
	                        CE = m_contractionCE_[UCharOffset];
	                        if (IsSpecial(CE)
	                                && GetTag(CE) == IBM.ICU.Text.CollationElementIterator.CE_EXPANSION_TAG_) {
	                            int i; /* general counter */
	                            // uint32_t *CEOffset = (uint32_t
	                            // *)image+getExpansionOffset(CE); /* find the
	                            // offset to expansion table */
	                            int offset = ((CE & 0xFFFFF0) >> 4)
	                                    - m_expansionOffset_; // it.getExpansionOffset(this,
	                                                          // CE);
	                            int size = CE & 0xF; // getExpansionCount(CE);
	                            // CE = *CEOffset++;
	                            if (size != 0) { /*
	                                              * if there are less than 16
	                                              * elements in expansion, we don't
	                                              * terminate
	                                              */
	                                for (i = 0; i < size; i++) {
	                                    if (s.primShift < 0 || s.secShift < 0
	                                            || s.terShift < 0) {
	                                        latinOneCEs_[contractionOffset] = BAIL_OUT_CE_;
	                                        latinOneCEs_[latinOneTableLen_
	                                                + contractionOffset] = BAIL_OUT_CE_;
	                                        latinOneCEs_[2 * latinOneTableLen_
	                                                + contractionOffset] = BAIL_OUT_CE_;
	                                        break;
	                                    }
	                                    AddLatinOneEntry(contractionOffset,
	                                            m_expansion_[offset + i], s);
	                                }
	                            } else { /* else, we do */
	                                while (m_expansion_[offset] != 0) {
	                                    if (s.primShift < 0 || s.secShift < 0
	                                            || s.terShift < 0) {
	                                        latinOneCEs_[contractionOffset] = BAIL_OUT_CE_;
	                                        latinOneCEs_[latinOneTableLen_
	                                                + contractionOffset] = BAIL_OUT_CE_;
	                                        latinOneCEs_[2 * latinOneTableLen_
	                                                + contractionOffset] = BAIL_OUT_CE_;
	                                        break;
	                                    }
	                                    AddLatinOneEntry(contractionOffset,
	                                            m_expansion_[offset++], s);
	                                }
	                            }
	                            contractionOffset++;
	                        } else if (!IsSpecial(CE)) {
	                            AddLatinOneEntry(contractionOffset++, CE, s);
	                        } else {
	                            latinOneCEs_[contractionOffset] = BAIL_OUT_CE_;
	                            latinOneCEs_[latinOneTableLen_ + contractionOffset] = BAIL_OUT_CE_;
	                            latinOneCEs_[2 * latinOneTableLen_
	                                    + contractionOffset] = BAIL_OUT_CE_;
	                            contractionOffset++;
	                        }
	                        UCharOffset++;
	                        s.primShift = 24;
	                        s.secShift = 24;
	                        s.terShift = 24;
	                        if (contractionOffset == latinOneTableLen_) { // we need
	                                                                      // to
	                                                                      // reallocate
	                            ResizeLatinOneTable(2 * latinOneTableLen_);
	                        }
	                    } while (m_contractionIndex_[UCharOffset] != 0xFFFF);
	                }
	                    break;
	                default:
	                    latinOneFailed_ = true;
	                    return false;
	                }
	            }
	        }
	        // compact table
	        if (contractionOffset < latinOneTableLen_) {
	            ResizeLatinOneTable(contractionOffset);
	        }
	        return true;
	    }
	
	    public class ContractionInfo {
	        internal int index;
	    }
	
	    internal RuleBasedCollator.ContractionInfo  m_ContInfo_;
	
	    private int GetLatinOneContraction(int strength, int CE, String s) {
	        // int strength, int CE, String s, Integer ind) {
	        int len = s.Length;
	        // const UChar *UCharOffset = (UChar
	        // *)coll->image+getContractOffset(CE&0xFFF);
	        int UCharOffset = (CE & 0xFFF) - m_contractionOffset_;
	        int offset = 1;
	        int latinOneOffset = (int) (((uint) (CE & 0x00FFF000)) >> 12);
	        char schar = (char) (0), tchar = (char) (0);
	
	        for (;;) {
	            /*
	             * if(len == -1) { if(s[*index] == 0) { // end of string
	             * return(coll-
	             * >latinOneCEs[strength*coll->latinOneTableLen+latinOneOffset]); }
	             * else { schar = s[*index]; } } else {
	             */
	            if (m_ContInfo_.index == len) {
	                return (latinOneCEs_[strength * latinOneTableLen_
	                        + latinOneOffset]);
	            } else {
	                schar = s[m_ContInfo_.index];
	            }
	            // }
	
	            while (schar > (tchar = m_contractionIndex_[UCharOffset + offset]/**
	             * 
	             * (UCharOffset+offset)
	             */
	            )) { /*
	                  * since the contraction codepoints should be ordered, we skip
	                  * all that are smaller
	                  */
	                offset++;
	            }
	
	            if (schar == tchar) {
	                m_ContInfo_.index++;
	                return (latinOneCEs_[strength * latinOneTableLen_
	                        + latinOneOffset + offset]);
	            } else {
	                if (schar > ENDOFLATINONERANGE_ /* & 0xFF00 */) {
	                    return BAIL_OUT_CE_;
	                }
	                // skip completely ignorables
	                int isZeroCE = m_trie_.GetLeadValue(schar); // UTRIE_GET32_FROM_LEAD(coll->mapping,
	                                                            // schar);
	                if (isZeroCE == 0) { // we have to ignore completely ignorables
	                    m_ContInfo_.index++;
	                    continue;
	                }
	
	                return (latinOneCEs_[strength * latinOneTableLen_
	                        + latinOneOffset]);
	            }
	        }
	    }
	
	    /// <summary>
	    /// This is a fast strcoll, geared towards text in Latin-1. It supports
	    /// contractions of size two, French secondaries and case switching. You can
	    /// use it with strengths primary to tertiary. It does not support shifted
	    /// and case level. It relies on the table build by setupLatin1Table. If it
	    /// doesn't understand something, it will go to the regular strcoll.
	    /// </summary>
	    ///
	    private int CompareUseLatin1(String source, String target,
	            int startOffset) {
	        int sLen = source.Length;
	        int tLen = target.Length;
	
	        int strength = GetStrength();
	
	        int sIndex = startOffset, tIndex = startOffset;
	        char sChar = (char) (0), tChar = (char) (0);
	        int sOrder = 0, tOrder = 0;
	
	        bool endOfSource = false;
	
	        // uint32_t *elements = coll->latinOneCEs;
	
	        bool haveContractions = false; // if we have contractions in our
	                                          // string
	                                          // we cannot do French secondary
	
	        int offset = latinOneTableLen_;
	
	        // Do the primary level
	        primLoop: {
	            for (;;) {
	                while (sOrder == 0) { // this loop skips primary ignorables
	                    // sOrder=getNextlatinOneCE(source);
	                    if (sIndex == sLen) {
	                        endOfSource = true;
	                        break;
	                    }
	                    sChar = source[sIndex++]; // [sIndex++];
	                    // }
	                    if (sChar > ENDOFLATINONERANGE_) { // if we encounter
	                                                       // non-latin-1, we bail out
	                        // fprintf(stderr, "R");
	                        return CompareRegular(source, target, startOffset);
	                    }
	                    sOrder = latinOneCEs_[sChar];
	                    if (IsSpecial(sOrder)) { // if we got a special
	                        // specials can basically be either contractions or bail-out
	                        // signs. If we get anything
	                        // else, we'll bail out anywasy
	                        if (GetTag(sOrder) == IBM.ICU.Text.CollationElementIterator.CE_CONTRACTION_TAG_) {
	                            m_ContInfo_.index = sIndex;
	                            sOrder = GetLatinOneContraction(0, sOrder, source);
	                            sIndex = m_ContInfo_.index;
	                            haveContractions = true; // if there are contractions,
	                                                     // we cannot do French
	                                                     // secondary
	                            // However, if there are contractions in the table, but
	                            // we always use just one char,
	                            // we might be able to do French. This should be checked
	                            // out.
	                        }
	                        if (IsSpecial(sOrder) /* == UCOL_BAIL_OUT_CE */) {
	                            // fprintf(stderr, "S");
	                            return CompareRegular(source, target, startOffset);
	                        }
	                    }
	                }
	
	                while (tOrder == 0) { // this loop skips primary ignorables
	                    // tOrder=getNextlatinOneCE(target);
	                    if (tIndex == tLen) {
	                        if (endOfSource) {
	                            goto gotoprimLoop;
	                        } else {
	                            return 1;
	                        }
	                    }
	                    tChar = target[tIndex++]; // [tIndex++];
	                    if (tChar > ENDOFLATINONERANGE_) { // if we encounter
	                                                       // non-latin-1, we bail out
	                        // fprintf(stderr, "R");
	                        return CompareRegular(source, target, startOffset);
	                    }
	                    tOrder = latinOneCEs_[tChar];
	                    if (IsSpecial(tOrder)) {
	                        // Handling specials, see the comments for source
	                        if (GetTag(tOrder) == IBM.ICU.Text.CollationElementIterator.CE_CONTRACTION_TAG_) {
	                            m_ContInfo_.index = tIndex;
	                            tOrder = GetLatinOneContraction(0, tOrder, target);
	                            tIndex = m_ContInfo_.index;
	                            haveContractions = true;
	                        }
	                        if (IsSpecial(tOrder)/* == UCOL_BAIL_OUT_CE */) {
	                            // fprintf(stderr, "S");
	                            return CompareRegular(source, target, startOffset);
	                        }
	                    }
	                }
	                if (endOfSource) { // source is finished, but target is not, say the
	                                   // result.
	                    return -1;
	                }
	
	                if (sOrder == tOrder) { // if we have same CEs, we continue the loop
	                    sOrder = 0;
	                    tOrder = 0;
	                    continue;
	                } else {
	                    // compare current top bytes
	                    if (((sOrder ^ tOrder) & -16777216) != 0) {
	                        // top bytes differ, return difference
	                        if ((int) (((uint) sOrder) >> 8) < (int) (((uint) tOrder) >> 8)) {
	                            return -1;
	                        } else {
	                            return 1;
	                        }
	                        // instead of return
	                        // (int32_t)(sOrder>>24)-(int32_t)(tOrder>>24);
	                        // since we must return enum value
	                    }
	
	                    // top bytes match, continue with following bytes
	                    sOrder <<= 8;
	                    tOrder <<= 8;
	                }
	            }
	        }
	        gotoprimLoop:
	        ;
	
	        // after primary loop, we definitely know the sizes of strings,
	        // so we set it and use simpler loop for secondaries and tertiaries
	        // sLen = sIndex; tLen = tIndex;
	        if (strength >= IBM.ICU.Text.Collator.SECONDARY) {
	            // adjust the table beggining
	            // latinOneCEs_ += coll->latinOneTableLen;
	            endOfSource = false;
	
	            if (!m_isFrenchCollation_) { // non French
	                // This loop is a simplified copy of primary loop
	                // at this point we know that whole strings are latin-1, so we
	                // don't
	                // check for that. We also know that we only have contractions
	                // as
	                // specials.
	                // sIndex = 0; tIndex = 0;
	                sIndex = startOffset;
	                tIndex = startOffset;
	                secLoop: {
	                    for (;;) {
	                        while (sOrder == 0) {
	                            if (sIndex == sLen) {
	                                endOfSource = true;
	                                break;
	                            }
	                            sChar = source[sIndex++]; // [sIndex++];
	                            sOrder = latinOneCEs_[offset + sChar];
	                            if (IsSpecial(sOrder)) {
	                                m_ContInfo_.index = sIndex;
	                                sOrder = GetLatinOneContraction(1, sOrder, source);
	                                sIndex = m_ContInfo_.index;
	                            }
	                        }
	
	                        while (tOrder == 0) {
	                            if (tIndex == tLen) {
	                                if (endOfSource) {
	                                    goto gotosecLoop;
	                                } else {
	                                    return 1;
	                                }
	                            }
	                            tChar = target[tIndex++]; // [tIndex++];
	                            tOrder = latinOneCEs_[offset + tChar];
	                            if (IsSpecial(tOrder)) {
	                                m_ContInfo_.index = tIndex;
	                                tOrder = GetLatinOneContraction(1, tOrder, target);
	                                tIndex = m_ContInfo_.index;
	                            }
	                        }
	                        if (endOfSource) {
	                            return -1;
	                        }
	
	                        if (sOrder == tOrder) {
	                            sOrder = 0;
	                            tOrder = 0;
	                            continue;
	                        } else {
	                            // see primary loop for comments on this
	                            if (((sOrder ^ tOrder) & -16777216) != 0) {
	                                if ((int) (((uint) sOrder) >> 8) < (int) (((uint) tOrder) >> 8)) {
	                                    return -1;
	                                } else {
	                                    return 1;
	                                }
	                            }
	                            sOrder <<= 8;
	                            tOrder <<= 8;
	                        }
	                    }
	                }
	                gotosecLoop:
	                ;
	            } else { // French
	                if (haveContractions) { // if we have contractions, we have to
	                                        // bail out
	                    // since we don't really know how to handle them here
	                    return CompareRegular(source, target, startOffset);
	                }
	                // For French, we go backwards
	                sIndex = sLen;
	                tIndex = tLen;
	                secFLoop: {
	                    for (;;) {
	                        while (sOrder == 0) {
	                            if (sIndex == startOffset) {
	                                endOfSource = true;
	                                break;
	                            }
	                            sChar = source[--sIndex]; // [--sIndex];
	                            sOrder = latinOneCEs_[offset + sChar];
	                            // don't even look for contractions
	                        }
	
	                        while (tOrder == 0) {
	                            if (tIndex == startOffset) {
	                                if (endOfSource) {
	                                    goto gotosecFLoop;
	                                } else {
	                                    return 1;
	                                }
	                            }
	                            tChar = target[--tIndex]; // [--tIndex];
	                            tOrder = latinOneCEs_[offset + tChar];
	                            // don't even look for contractions
	                        }
	                        if (endOfSource) {
	                            return -1;
	                        }
	
	                        if (sOrder == tOrder) {
	                            sOrder = 0;
	                            tOrder = 0;
	                            continue;
	                        } else {
	                            // see the primary loop for comments
	                            if (((sOrder ^ tOrder) & -16777216) != 0) {
	                                if ((int) (((uint) sOrder) >> 8) < (int) (((uint) tOrder) >> 8)) {
	                                    return -1;
	                                } else {
	                                    return 1;
	                                }
	                            }
	                            sOrder <<= 8;
	                            tOrder <<= 8;
	                        }
	                    }
	                }
	                gotosecFLoop:
	                ;
	            }
	        }
	
	        if (strength >= IBM.ICU.Text.Collator.TERTIARY) {
	            // tertiary loop is the same as secondary (except no French)
	            offset += latinOneTableLen_;
	            // sIndex = 0; tIndex = 0;
	            sIndex = startOffset;
	            tIndex = startOffset;
	            endOfSource = false;
	            for (;;) {
	                while (sOrder == 0) {
	                    if (sIndex == sLen) {
	                        endOfSource = true;
	                        break;
	                    }
	                    sChar = source[sIndex++]; // [sIndex++];
	                    sOrder = latinOneCEs_[offset + sChar];
	                    if (IsSpecial(sOrder)) {
	                        m_ContInfo_.index = sIndex;
	                        sOrder = GetLatinOneContraction(2, sOrder, source);
	                        sIndex = m_ContInfo_.index;
	                    }
	                }
	                while (tOrder == 0) {
	                    if (tIndex == tLen) {
	                        if (endOfSource) {
	                            return 0; // if both strings are at the end, they
	                                      // are equal
	                        } else {
	                            return 1;
	                        }
	                    }
	                    tChar = target[tIndex++]; // [tIndex++];
	                    tOrder = latinOneCEs_[offset + tChar];
	                    if (IsSpecial(tOrder)) {
	                        m_ContInfo_.index = tIndex;
	                        tOrder = GetLatinOneContraction(2, tOrder, target);
	                        tIndex = m_ContInfo_.index;
	                    }
	                }
	                if (endOfSource) {
	                    return -1;
	                }
	                if (sOrder == tOrder) {
	                    sOrder = 0;
	                    tOrder = 0;
	                    continue;
	                } else {
	                    if (((sOrder ^ tOrder) & -16777216) != 0) {
	                        if ((int) (((uint) sOrder) >> 8) < (int) (((uint) tOrder) >> 8)) {
	                            return -1;
	                        } else {
	                            return 1;
	                        }
	                    }
	                    sOrder <<= 8;
	                    tOrder <<= 8;
	                }
	            }
	        }
	        return 0;
	    }
	
	    /// <summary>
	    /// Get the version of this collator object.
	    /// </summary>
	    ///
	    /// <returns>the version object associated with this collator</returns>
	    /// @stable ICU 2.8
	    public override VersionInfo GetVersion() {
	        /* RunTime version */
	        int rtVersion = IBM.ICU.Util.VersionInfo.UCOL_RUNTIME_VERSION.GetMajor();
	        /* Builder version */
	        int bdVersion = m_version_.GetMajor();
	
	        /*
	         * Charset Version. Need to get the version from cnv files makeconv
	         * should populate cnv files with version and an api has to be provided
	         * in ucnv.h to obtain this version
	         */
	        int csVersion = 0;
	
	        /* combine the version info */
	        int cmbVersion = ((rtVersion << 11) | (bdVersion << 6) | (csVersion)) & 0xFFFF;
	
	        /* Tailoring rules */
	        return IBM.ICU.Util.VersionInfo.GetInstance(cmbVersion >> 8, cmbVersion & 0xFF,
	                m_version_.GetMinor(), UCA_.m_UCA_version_.GetMajor());
	
	        // versionInfo[0] = (uint8_t)(cmbVersion>>8);
	        // versionInfo[1] = (uint8_t)cmbVersion;
	        // versionInfo[2] = coll->image->version[1];
	        // versionInfo[3] = coll->UCA->image->UCAVersion[0];
	    }
	
	    /// <summary>
	    /// Get the UCA version of this collator object.
	    /// </summary>
	    ///
	    /// <returns>the version object associated with this collator</returns>
	    /// @stable ICU 2.8
	    public override VersionInfo GetUCAVersion() {
	        return UCA_.m_UCA_version_;
	    }
	
	    private bool m_reallocLatinOneCEs_;
	
	    static RuleBasedCollator() {
	            RuleBasedCollator iUCA_ = null;
	            RuleBasedCollator.UCAConstants  iUCA_CONSTANTS_ = null;
	            char[] iUCA_CONTRACTIONS_ = null;
	            ImplicitCEGenerator iimpCEGen_ = null;
	            try {
	                iUCA_ = new RuleBasedCollator();
	                iUCA_CONSTANTS_ = new RuleBasedCollator.UCAConstants ();
	                iUCA_CONTRACTIONS_ = IBM.ICU.Text.CollatorReader.Read(iUCA_,
	                        iUCA_CONSTANTS_);
	                iimpCEGen_ = new ImplicitCEGenerator(minImplicitPrimary,
	                        maxImplicitPrimary);
	                iUCA_.Init();
	                ICUResourceBundle rb = (ICUResourceBundle) IBM.ICU.Util.UResourceBundle
	                        .GetBundleInstance(
	                                IBM.ICU.Impl.ICUResourceBundle.ICU_COLLATION_BASE_NAME,
	                                IBM.ICU.Util.ULocale.ENGLISH);
	                iUCA_.m_rules_ = (String) rb.GetObject("UCARules");
	            } catch (MissingManifestResourceException ex) {
	            } catch (IOException e) {
	            }
	            UCA_ = iUCA_;
	            UCA_CONSTANTS_ = iUCA_CONSTANTS_;
	            UCA_CONTRACTIONS_ = iUCA_CONTRACTIONS_;
	            impCEGen_ = iimpCEGen_;
	            UCA_INIT_COMPLETE = true;
	        }
	}
}
