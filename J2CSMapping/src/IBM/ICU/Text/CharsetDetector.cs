// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:30 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2005-2007, International Business Machines Corporation and    
/// others. All Rights Reserved.                                                
/// </summary>
///
namespace IBM.ICU.Text {
	
	using ILOG.J2CsMapping.Collections.Generics;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	
	/// <summary>
	/// <c>CharsetDetector</c> provides a facility for detecting the charset or
	/// encoding of character data in an unknown format. The input data can either be
	/// from an input stream or an array of bytes. The result of the detection
	/// operation is a list of possibly matching charsets, or, for simple use, you
	/// can just ask for a Java Reader that will will work over the input data.
	/// <p/>
	/// Character set detection is at best an imprecise operation. The detection
	/// process will attempt to identify the charset that best matches the
	/// characteristics of the byte data, but the process is partly statistical in
	/// nature, and the results can not be guaranteed to always be correct.
	/// <p/>
	/// For best accuracy in charset detection, the input data should be primarily in
	/// a single language, and a minimum of a few hundred bytes worth of plain text
	/// in the language are needed. The detection process will attempt to ignore html
	/// or xml style markup that could otherwise obscure the content.
	/// <p/>
	/// </summary>
	///
	/// @stable ICU 3.4
	public class CharsetDetector {
	
	    // Question: Should we have getters corresponding to the setters for inut
	    // text
	    // and declared encoding?
	
	    // A thought: If we were to create our own type of Java Reader, we could
	    // defer
	    // figuring out an actual charset for data that starts out with too much
	    // English
	    // only ASCII until the user actually read through to something that didn't
	    // look
	    // like 7 bit English. If nothing else ever appeared, we would never need to
	    // actually choose the "real" charset. All assuming that the application
	    // just
	    // wants the data, and doesn't care about a char set name.
	
	    /// <summary>
	    /// Constructor
	    /// </summary>
	    ///
	    /// @stable ICU 3.4
	    public CharsetDetector() {
	        this.fInputBytes = new byte[kBufSize];
	        this.fByteStats = new short[256];
	        this.fC1Bytes = // input;
	        false;
	        this.fStripTags = false;
	    }
	
	    /// <summary>
	    /// Set the declared encoding for charset detection. The declared encoding of
	    /// an input text is an encoding obtained from an http header or xml
	    /// declaration or similar source that can be provided as additional
	    /// information to the charset detector. A match between a declared encoding
	    /// and a possible detected encoding will raise the quality of that detected
	    /// encoding by a small delta, and will also appear as a "reason" for the
	    /// match.
	    /// <p/>
	    /// A declared encoding that is incompatible with the input data being
	    /// analyzed will not be added to the list of possible encodings.
	    /// </summary>
	    ///
	    /// <param name="encoding">The declared encoding</param>
	    /// @stable ICU 3.4
	    public CharsetDetector SetDeclaredEncoding(String encoding) {
	        fDeclaredEncoding = encoding;
	        return this;
	    }
	
	    /// <summary>
	    /// Set the input text (byte) data whose charset is to be detected.
	    /// </summary>
	    ///
	    /// <param name="in">the input text of unknown encoding</param>
	    /// <returns>This CharsetDetector</returns>
	    /// @stable ICU 3.4
	    public CharsetDetector SetText(byte[] ins0) {
	        fRawInput = ins0;
	        fRawLength = ins0.Length;
	
	        MungeInput();
	
	        return this;
	    }
	
	    private const int kBufSize = 8000;
	
	    /// <summary>
	    /// Set the input text (byte) data whose charset is to be detected.
	    /// <p/>
	    /// The input stream that supplies the character data must have
	    /// markSupported() == true; the charset detection process will read a small
	    /// amount of data, then return the stream to its original position via the
	    /// InputStream.reset() operation. The exact amount that will be read depends
	    /// on the characteristics of the data itself.
	    /// </summary>
	    ///
	    /// <param name="in">the input text of unknown encoding</param>
	    /// <returns>This CharsetDetector</returns>
	    /// @stable ICU 3.4
	
	    public CharsetDetector SetText(Stream ins0) {
	        fInputStream = ins0;
	        // TODO: fInputStream.Mark(kBufSize);
            throw new NotImplementedException();
	        fRawInput = new byte[kBufSize]; // Always make a new buffer because the
	                                        // previous one may have come from the
	                                        // caller,
	                                        // in which case we can't touch it.
	        fRawLength = 0;
	        int remainingLength = kBufSize;
	        while (remainingLength > 0) {
	            // read() may give data in smallish chunks, esp. for remote sources.
	            // Hence, this loop.
	            int bytesRead = fInputStream.Read(fRawInput, fRawLength,
	                    remainingLength);
	            if (bytesRead <= 0) {
	                break;
	            }
	            fRawLength += bytesRead;
	            remainingLength -= bytesRead;
	        }
	        // TODO: fInputStream.Reset();
            throw new NotImplementedException();
	
	        MungeInput(); // Strip html markup, collect byte stats.
	        return this;
	    }
	
	    /// <summary>
	    /// Return the charset that best matches the supplied input data.
	    /// Note though, that because the detection only looks at the start of the
	    /// input data, there is a possibility that the returned charset will fail to
	    /// handle the full set of input data.
	    /// <p/>
	    /// Raise an exception if
	    /// <ul>
	    /// <li>no charset appears to match the data.</li>
	    /// <li>no input text has been provided</li>
	    /// </ul>
	    /// </summary>
	    ///
	    /// <returns>a CharsetMatch object representing the best matching charset, or
	    /// <c>null</c> if there are no matches.</returns>
	    /// @stable ICU 3.4
	    public CharsetMatch Detect() {
	        CharsetMatch[] matches = DetectAll();
	
	        if (matches == null || matches.Length == 0) {
	            return null;
	        }
	
	        return matches[0];
	    }
	
	    /// <summary>
	    /// Return an array of all charsets that appear to be plausible matches with
	    /// the input data. The array is ordered with the best quality match first.
	    /// <p/>
	    /// Raise an exception if
	    /// <ul>
	    /// <li>no charsets appear to match the input data.</li>
	    /// <li>no input text has been provided</li>
	    /// </ul>
	    /// </summary>
	    ///
	    /// <returns>An array of CharsetMatch objects representing possibly matching
	    /// charsets.</returns>
	    /// @stable ICU 3.4
	    public CharsetMatch[] DetectAll() {
	        CharsetRecognizer csr;
	        int i;
	        int detectResults;
	        int confidence;
	        ArrayList matches = new ArrayList();
	
	        // Iterate over all possible charsets, remember all that
	        // give a match quality > 0.
	        for (i = 0; i < fCSRecognizers.Count; i++) {
	            csr = (CharsetRecognizer) fCSRecognizers[i];
	            detectResults = csr.Match(this);
	            confidence = detectResults & 0x000000ff;
	            if (confidence > 0) {
	                CharsetMatch m = new CharsetMatch(this, csr, confidence);
	                ILOG.J2CsMapping.Collections.Generics.Collections.Add(matches,m);
	            }
	        }
	        ILOG.J2CsMapping.Collections.Collections.Sort(matches); // CharsetMatch compares on confidence
	        ILOG.J2CsMapping.Collections.Generics.Collections.Reverse(matches); // Put best match first.
	        CharsetMatch[] resultArray = new CharsetMatch[matches.Count];
	        resultArray = (CharsetMatch[]) ILOG.J2CsMapping.Collections.Generics.Collections.ToArray(matches,resultArray);
	        return resultArray;
	    }
	
	    /// <summary>
	    /// Autodetect the charset of an inputStream, and return a Java Reader to
	    /// access the converted input data.
	    /// <p/>
	    /// This is a convenience method that is equivalent to
	    /// <c>this.setDeclaredEncoding(declaredEncoding).setText(in).detect().getReader();</c>
	    /// <p/>
	    /// For the input stream that supplies the character data, markSupported()
	    /// must be true; the charset detection will read a small amount of data,
	    /// then return the stream to its original position via the
	    /// InputStream.reset() operation. The exact amount that will be read depends
	    /// on the characteristics of the data itself.
	    /// <p/>
	    /// Raise an exception if no charsets appear to match the input data.
	    /// </summary>
	    ///
	    /// <param name="in">The source of the byte data in the unknown charset.</param>
	    /// <param name="declaredEncoding">A declared encoding for the data, if available, or null or anempty string if none is available.</param>
	    /// @stable ICU 3.4
	    public TextReader GetReader(Stream ins0, String declaredEncoding) {
	        fDeclaredEncoding = declaredEncoding;
	
	        try {
	            SetText(ins0);
	
	            CharsetMatch match = Detect();
	
	            if (match == null) {
	                return null;
	            }
	
	            return match.GetReader();
	        } catch (IOException e) {
	            return null;
	        }
	    }
	
	    /// <summary>
	    /// Autodetect the charset of an inputStream, and return a String containing
	    /// the converted input data.
	    /// <p/>
	    /// This is a convenience method that is equivalent to
	    /// <c>this.setDeclaredEncoding(declaredEncoding).setText(in).detect().getString();</c>
	    /// <p/>
	    /// Raise an exception if no charsets appear to match the input data.
	    /// </summary>
	    ///
	    /// <param name="in">The source of the byte data in the unknown charset.</param>
	    /// <param name="declaredEncoding">A declared encoding for the data, if available, or null or anempty string if none is available.</param>
	    /// @stable ICU 3.4
	    public String GetString(byte[] ins0, String declaredEncoding) {
	        fDeclaredEncoding = declaredEncoding;
	
	        try {
	            SetText(ins0);
	
	            CharsetMatch match = Detect();
	
	            if (match == null) {
	                return null;
	            }
	
	            return match.GetString(-1);
	        } catch (IOException e) {
	            return null;
	        }
	    }
	
	    /// <summary>
	    /// Get the names of all char sets that can be recognized by the char set
	    /// detector.
	    /// </summary>
	    ///
	    /// <returns>an array of the names of all charsets that can be recognized by
	    /// the charset detector.</returns>
	    /// @stable ICU 3.4
	    public static String[] GetAllDetectableCharsets() {
	        return fCharsetNames;
	    }
	
	    /// <summary>
	    /// Test whether or not input filtering is enabled.
	    /// </summary>
	    ///
	    /// <returns><c>true</c> if input text will be filtered.</returns>
	    /// <seealso cref="M:IBM.ICU.Text.CharsetDetector.EnableInputFilter(System.Boolean)"/>
	    /// @stable ICU 3.4
	    public bool InputFilterEnabled() {
	        return fStripTags;
	    }
	
	    /// <summary>
	    /// Enable filtering of input text. If filtering is enabled, text within
	    /// angle brackets ("<" and ">") will be removed before detection.
	    /// </summary>
	    ///
	    /// <param name="filter"><c>true</c> to enable input text filtering.</param>
	    /// <returns>The previous setting.</returns>
	    /// @stable ICU 3.4
	    public bool EnableInputFilter(bool filter) {
	        bool previous = fStripTags;
	
	        fStripTags = filter;
	
	        return previous;
	    }
	
	    /*
	     * MungeInput - after getting a set of raw input data to be analyzed,
	     * preprocess it by removing what appears to be html markup.
	     */
	    private void MungeInput() {
	        int srci = 0;
	        int dsti = 0;
	        byte b;
	        bool inMarkup = false;
	        int openTags = 0;
	        int badTags = 0;
	
	        //
	        // html / xml markup stripping.
	        // quick and dirty, not 100% accurate, but hopefully good enough,
	        // statistically.
	        // discard everything within < brackets >
	        // Count how many total '<' and illegal (nested) '<' occur, so we can
	        // make some
	        // guess as to whether the input was actually marked up at all.
	        if (fStripTags) {
	            for (srci = 0; srci < fRawLength && dsti < fInputBytes.Length; srci++) {
	                b = fRawInput[srci];
	                if (b == (byte) '<') {
	                    if (inMarkup) {
	                        badTags++;
	                    }
	                    inMarkup = true;
	                    openTags++;
	                }
	
	                if (!inMarkup) {
	                    fInputBytes[dsti++] = b;
	                }
	
	                if (b == (byte) '>') {
	                    inMarkup = false;
	                }
	            }
	
	            fInputLen = dsti;
	        }
	
	        //
	        // If it looks like this input wasn't marked up, or if it looks like
	        // it's
	        // essentially nothing but markup abandon the markup stripping.
	        // Detection will have to work on the unstripped input.
	        //
	        if (openTags < 5 || openTags / 5 < badTags
	                || (fInputLen < 100 && fRawLength > 600)) {
	            int limit = fRawLength;
	
	            if (limit > kBufSize) {
	                limit = kBufSize;
	            }
	
	            for (srci = 0; srci < limit; srci++) {
	                fInputBytes[srci] = fRawInput[srci];
	            }
	            fInputLen = srci;
	        }
	
	        //
	        // Tally up the byte occurence statistics.
	        // These are available for use by the various detectors.
	        //
	        ILOG.J2CsMapping.Collections.Arrays.Fill(fByteStats,(short) 0);
	        for (srci = 0; srci < fInputLen; srci++) {
	            int val = fInputBytes[srci] & 0x00ff;
	            fByteStats[val]++;
	        }
	
	        fC1Bytes = false;
	        for (int i = 0x80; i <= 0x9F; i += 1) {
	            if (fByteStats[i] != 0) {
	                fC1Bytes = true;
	                break;
	            }
	        }
	    }
	
	    /*
	     * The following items are accessed by individual CharsetRecongizers during
	     * the recognition process
	     */
	    internal byte[] fInputBytes; // removed if appropriate.
	
	    internal int fInputLen; // Length of the byte data in fInputText.
	
	    internal short[] fByteStats;
	
	    internal bool fC1Bytes;
	
	    internal String fDeclaredEncoding;
	
	    //
	    // Stuff private to CharsetDetector
	    //
	    internal byte[] fRawInput; // Original, untouched input bytes.
	                      // If user gave us a byte array, this is it.
	                      // If user gave us a stream, it's read to a
	                      // buffer here.
	
	    internal int fRawLength; // Length of data in fRawInput array.
	
	    internal Stream fInputStream; // User's input stream, or null if the user
	                              // gave us a byte array.
	
	    internal bool fStripTags;
	
	    /*
	     * List of recognizers for all charsets known to the implementation.
	     */
	    private static ArrayList fCSRecognizers = CreateRecognizers();
	
	    private static String[] fCharsetNames;
	
	    /*
	     * Create the singleton instances of the CharsetRecognizer classes
	     */
	    private static ArrayList CreateRecognizers() {
	        ArrayList recognizers = new ArrayList();
	
	        ILOG.J2CsMapping.Collections.Generics.Collections.Add(recognizers,new CharsetRecog_UTF8());
	
	        ILOG.J2CsMapping.Collections.Generics.Collections.Add(recognizers,new CharsetRecog_Unicode.CharsetRecog_UTF_16_BE());
	        ILOG.J2CsMapping.Collections.Generics.Collections.Add(recognizers,new CharsetRecog_Unicode.CharsetRecog_UTF_16_LE());
	        ILOG.J2CsMapping.Collections.Generics.Collections.Add(recognizers,new CharsetRecog_Unicode.CharsetRecog_UTF_32_BE());
	        ILOG.J2CsMapping.Collections.Generics.Collections.Add(recognizers,new CharsetRecog_Unicode.CharsetRecog_UTF_32_LE());
	
	        ILOG.J2CsMapping.Collections.Generics.Collections.Add(recognizers,new CharsetRecog_mbcs.CharsetRecog_sjis());
	        ILOG.J2CsMapping.Collections.Generics.Collections.Add(recognizers,new CharsetRecog_2022.CharsetRecog_2022JP());
	        ILOG.J2CsMapping.Collections.Generics.Collections.Add(recognizers,new CharsetRecog_2022.CharsetRecog_2022CN());
	        ILOG.J2CsMapping.Collections.Generics.Collections.Add(recognizers,new CharsetRecog_2022.CharsetRecog_2022KR());
	        ILOG.J2CsMapping.Collections.Generics.Collections.Add(recognizers,new CharsetRecog_mbcs.CharsetRecog_euc.CharsetRecog_gb_18030());
	        // TODO: ILOG.J2CsMapping.Collections.Generics.Collections.Add(recognizers,new CharsetRecog_mbcs.CharsetRecog_euc.CharsetRecog_euc_jp(outer_CharsetRecog_euc));
	        // TODO: ILOG.J2CsMapping.Collections.Generics.Collections.Add(recognizers,new CharsetRecog_mbcs.CharsetRecog_euc.CharsetRecog_euc_kr());
	        ILOG.J2CsMapping.Collections.Generics.Collections.Add(recognizers,new CharsetRecog_mbcs.CharsetRecog_big5());
	
	        ILOG.J2CsMapping.Collections.Generics.Collections.Add(recognizers,new CharsetRecog_sbcs.CharsetRecog_8859_1_da());
	        ILOG.J2CsMapping.Collections.Generics.Collections.Add(recognizers,new CharsetRecog_sbcs.CharsetRecog_8859_1_de());
	        ILOG.J2CsMapping.Collections.Generics.Collections.Add(recognizers,new CharsetRecog_sbcs.CharsetRecog_8859_1_en());
	        ILOG.J2CsMapping.Collections.Generics.Collections.Add(recognizers,new CharsetRecog_sbcs.CharsetRecog_8859_1_es());
	        ILOG.J2CsMapping.Collections.Generics.Collections.Add(recognizers,new CharsetRecog_sbcs.CharsetRecog_8859_1_fr());
	        ILOG.J2CsMapping.Collections.Generics.Collections.Add(recognizers,new CharsetRecog_sbcs.CharsetRecog_8859_1_it());
	        ILOG.J2CsMapping.Collections.Generics.Collections.Add(recognizers,new CharsetRecog_sbcs.CharsetRecog_8859_1_nl());
	        ILOG.J2CsMapping.Collections.Generics.Collections.Add(recognizers,new CharsetRecog_sbcs.CharsetRecog_8859_1_no());
	        ILOG.J2CsMapping.Collections.Generics.Collections.Add(recognizers,new CharsetRecog_sbcs.CharsetRecog_8859_1_pt());
	        ILOG.J2CsMapping.Collections.Generics.Collections.Add(recognizers,new CharsetRecog_sbcs.CharsetRecog_8859_1_sv());
	        ILOG.J2CsMapping.Collections.Generics.Collections.Add(recognizers,new CharsetRecog_sbcs.CharsetRecog_8859_2_cs());
	        ILOG.J2CsMapping.Collections.Generics.Collections.Add(recognizers,new CharsetRecog_sbcs.CharsetRecog_8859_2_hu());
	        ILOG.J2CsMapping.Collections.Generics.Collections.Add(recognizers,new CharsetRecog_sbcs.CharsetRecog_8859_2_pl());
	        ILOG.J2CsMapping.Collections.Generics.Collections.Add(recognizers,new CharsetRecog_sbcs.CharsetRecog_8859_2_ro());
	        ILOG.J2CsMapping.Collections.Generics.Collections.Add(recognizers,new CharsetRecog_sbcs.CharsetRecog_8859_5_ru());
	        ILOG.J2CsMapping.Collections.Generics.Collections.Add(recognizers,new CharsetRecog_sbcs.CharsetRecog_8859_6_ar());
	        ILOG.J2CsMapping.Collections.Generics.Collections.Add(recognizers,new CharsetRecog_sbcs.CharsetRecog_8859_7_el());
	        ILOG.J2CsMapping.Collections.Generics.Collections.Add(recognizers,new CharsetRecog_sbcs.CharsetRecog_8859_8_I_he());
	        ILOG.J2CsMapping.Collections.Generics.Collections.Add(recognizers,new CharsetRecog_sbcs.CharsetRecog_8859_8_he());
	        ILOG.J2CsMapping.Collections.Generics.Collections.Add(recognizers,new CharsetRecog_sbcs.CharsetRecog_windows_1251());
	        ILOG.J2CsMapping.Collections.Generics.Collections.Add(recognizers,new CharsetRecog_sbcs.CharsetRecog_windows_1256());
	        ILOG.J2CsMapping.Collections.Generics.Collections.Add(recognizers,new CharsetRecog_sbcs.CharsetRecog_KOI8_R());
	        ILOG.J2CsMapping.Collections.Generics.Collections.Add(recognizers,new CharsetRecog_sbcs.CharsetRecog_8859_9_tr());
	
	        // Create an array of all charset names, as a side effect.
	        // Needed for the getAllDetectableCharsets() API.
	        String[] charsetNames = new String[recognizers.Count];
	        int xout = 0;
	
	        for (int i = 0; i < recognizers.Count; i++) {
	            String name = ((CharsetRecognizer) recognizers[i]).GetName();
	
	            if (xout == 0 || !name.Equals(charsetNames[xout - 1])) {
	                charsetNames[xout++] = name;
	            }
	        }
	
	        fCharsetNames = new String[xout];
	        System.Array.Copy((Array)(charsetNames),0,(Array)(fCharsetNames),0,xout);
	
	        return recognizers;
	    }
	}
}
