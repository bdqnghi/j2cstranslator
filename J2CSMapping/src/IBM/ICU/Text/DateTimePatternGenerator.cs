//##header J2SE15
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:30 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 //#if defined(FOUNDATION10) || defined(J2SE13)
//#else
/*
 *******************************************************************************
 * Copyright (C) 2006-2007, Google, International Business Machines Corporation *
 * and others. All Rights Reserved.                                            *
 *******************************************************************************
 */
namespace IBM.ICU.Text {
	
	using IBM.ICU.Impl;
	using IBM.ICU.Util;
	using ILOG.J2CsMapping.Collections;
	using ILOG.J2CsMapping.Collections.Generics;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Text;
	
	/// <summary>
	/// This class provides flexible generation of date format patterns, like
	/// "yy-MM-dd". The user can build up the generator by adding successive
	/// patterns. Once that is done, a query can be made using a "skeleton", which is
	/// a pattern which just includes the desired fields and lengths. The generator
	/// will return the "best fit" pattern corresponding to that skeleton.
	/// <p>
	/// The main method people will use is getBestPattern(String skeleton), since
	/// normally this class is pre-built with data from a particular locale. However,
	/// generators can be built directly from other data as well.
	/// <pre>
	/// // some simple use cases
	/// Date sampleDate = new Date(99, 9, 13, 23, 58, 59);
	/// ULocale locale = ULocale.GERMANY;
	/// TimeZone zone = TimeZone.getTimeZone(&quot;Europe/Paris&quot;);
	/// // make from locale
	/// DateTimePatternGenerator gen = DateTimePatternGenerator.getInstance(locale);
	/// SimpleDateFormat format = new SimpleDateFormat(gen.getBestPattern(&quot;MMMddHmm&quot;),
	/// locale);
	/// format.setTimeZone(zone);
	/// assertEquals(&quot;simple format: MMMddHmm&quot;, &quot;8:58 14. Okt&quot;,
	/// format.format(sampleDate));
	/// // (a generator can be built from scratch, but that is not a typical use case)
	/// // modify the generator by adding patterns
	/// DateTimePatternGenerator.PatternInfo returnInfo = new DateTimePatternGenerator.PatternInfo();
	/// gen.add(&quot;d'. von' MMMM&quot;, true, returnInfo);
	/// // the returnInfo is mostly useful for debugging problem cases
	/// format.applyPattern(gen.getBestPattern(&quot;MMMMddHmm&quot;));
	/// assertEquals(&quot;modified format: MMMddHmm&quot;, &quot;8:58 14. von Oktober&quot;,
	/// format.format(sampleDate));
	/// // get a pattern and modify it
	/// format = (SimpleDateFormat) DateFormat.getDateTimeInstance(DateFormat.FULL,
	/// DateFormat.FULL, locale);
	/// format.setTimeZone(zone);
	/// String pattern = format.toPattern();
	/// assertEquals(&quot;full-date&quot;, &quot;Donnerstag, 14. Oktober 1999 8:58 Uhr GMT+02:00&quot;,
	/// format.format(sampleDate));
	/// // modify it to change the zone.
	/// String newPattern = gen.replaceFieldTypes(pattern, &quot;vvvv&quot;);
	/// format.applyPattern(newPattern);
	/// assertEquals(&quot;full-date, modified zone&quot;,
	/// &quot;Donnerstag, 14. Oktober 1999 8:58 Uhr Frankreich&quot;,
	/// format.format(sampleDate));
	/// </pre>
	/// </summary>
	///
	/// @draft ICU 3.6
	/// @provisional This API might change or be removed in a future release.
	public class DateTimePatternGenerator : Freezable, ICloneable {
	    // debugging flags
	    // static boolean SHOW_DISTANCE = false;
	    // TODO add hack to fix months for CJK, as per bug ticket 1099
	
	    /// <summary>
	    /// Create empty generator, to be constructed with add(...) etc.
	    /// </summary>
	    ///
	    /// @draft ICU 3.6
	    /// @provisional This API might change or be removed in a future release.
	    public static DateTimePatternGenerator GetEmptyInstance() {
	        return new DateTimePatternGenerator();
	    }
	
	    /// <summary>
	    /// Only for use by subclasses
	    /// </summary>
	    ///
	    /// @draft ICU 3.6
	    /// @provisional This API might change or be removed in a future release.
	    protected internal DateTimePatternGenerator() {
	        Complete();
	        for (int i = 0; i < TYPE_LIMIT; ++i) {
	            appendItemFormats[i] = "{0} \u251C{2}: {1}\u2524";
	            appendItemNames[i] = "F" + i;
	        }
	        this.skeleton2pattern = new SortedList();
	        this.basePattern_pattern = new SortedList();
	        this.decimal_ = "?";
	        this.dateTimeFormat = "{0} {1}";
	        this.appendItemFormats = new String[TYPE_LIMIT];
	        this.appendItemNames = new String[TYPE_LIMIT];
	        this.current = new DateTimePatternGenerator.DateTimeMatcher ();
	        this.fp = new DateTimePatternGenerator.FormatParser ();
	        this._distanceInfo = new DateTimePatternGenerator.DistanceInfo ();
	        this.isComplete = false;
	        this.skipMatcher = null;
	        this.frozen = false;
	        this.chineseMonthHack = false;
	        this.cldrAvailableFormatKeys = new HashedSet(20);
	    }
	
	    /// <summary>
	    /// Construct a flexible generator according to data for a given locale.
	    /// </summary>
	    ///
	    /// @draft ICU 3.6
	    /// @provisional This API might change or be removed in a future release.
	    public static DateTimePatternGenerator GetInstance() {
	        return GetInstance(IBM.ICU.Util.ULocale.GetDefault());
	    }
	
	    /// <summary>
	    /// Construct a flexible generator according to data for a given locale.
	    /// </summary>
	    ///
	    /// <param name="uLocale"></param>
	    /// @draft ICU 3.6
	    /// @provisional This API might change or be removed in a future release.
	    public static DateTimePatternGenerator GetInstance(ULocale uLocale) {
	        DateTimePatternGenerator result = new DateTimePatternGenerator();
	        String lang = uLocale.GetLanguage();
	        if (lang.Equals("zh") || lang.Equals("ko") || lang.Equals("ja")) {
	            result.chineseMonthHack = true;
	        }
	        DateTimePatternGenerator.PatternInfo  returnInfo = new DateTimePatternGenerator.PatternInfo ();
	        String hackPattern = null;
	        // first load with the ICU patterns
	        for (int i = IBM.ICU.Text.DateFormat.FULL; i <= IBM.ICU.Text.DateFormat.SHORT; ++i) {
	            SimpleDateFormat df = (SimpleDateFormat) IBM.ICU.Text.DateFormat
	                    .GetDateInstance(i, uLocale);
	            result.AddPattern(df.ToPattern(), false, returnInfo);
	            df = (SimpleDateFormat) IBM.ICU.Text.DateFormat.GetTimeInstance(i, uLocale);
	            result.AddPattern(df.ToPattern(), false, returnInfo);
	            // HACK for hh:ss
	            if (i == IBM.ICU.Text.DateFormat.MEDIUM) {
	                hackPattern = df.ToPattern();
	            }
	        }
	
	        ICUResourceBundle rb = (ICUResourceBundle) IBM.ICU.Util.UResourceBundle
	                .GetBundleInstance(IBM.ICU.Impl.ICUResourceBundle.ICU_BASE_NAME, uLocale);
	        rb = rb.GetWithFallback("calendar");
	        ICUResourceBundle gregorianBundle = rb.GetWithFallback("gregorian");
	        // CLDR item formats
	
	        ICUResourceBundle itemBundle = gregorianBundle
	                .GetWithFallback("appendItems");
	        for (int i_0 = 0; i_0 < itemBundle.GetSize(); ++i_0) {
	            ICUResourceBundle formatBundle = (ICUResourceBundle) itemBundle
	                    .Get(i_0);
	            String formatName = itemBundle.Get(i_0).GetKey();
	            String value_ren = formatBundle.GetString();
	            result.SetAppendItemFormat(GetAppendFormatNumber(formatName), value_ren);
	        }
	
	        // CLDR item names
	        itemBundle = gregorianBundle.GetWithFallback("fields");
	        ICUResourceBundle fieldBundle, dnBundle;
	        for (int i_1 = 0; i_1 < TYPE_LIMIT; ++i_1) {
	            if (IsCLDRFieldName(i_1)) {
	                fieldBundle = itemBundle.GetWithFallback(CLDR_FIELD_NAME[i_1]);
	                dnBundle = fieldBundle.GetWithFallback("dn");
	                String value_2 = dnBundle.GetString();
	                // System.out.println("Field name:"+value);
	                result.SetAppendItemName(i_1, value_2);
	            }
	        }
	
	        // set the AvailableFormat in CLDR
	        try {
	            ICUResourceBundle formatBundle_3 = gregorianBundle
	                    .GetWithFallback("availableFormats");
	            // System.out.println("available format from current locale:"+uLocale.getName());
	            for (int i_4 = 0; i_4 < formatBundle_3.GetSize(); ++i_4) {
	                String formatKey = formatBundle_3.Get(i_4).GetKey();
	                String formatValue = formatBundle_3.Get(i_4).GetString();
	                // System.out.println(" availableFormat:"+formatValue);
	                result.SetAvailableFormat(formatKey);
	                result.AddPattern(formatValue, false, returnInfo);
	            }
	        } catch (Exception e) {
	        }
	
	        ULocale parentLocale = uLocale;
	        while ((parentLocale = parentLocale.GetFallback()) != null) {
	            ICUResourceBundle prb = (ICUResourceBundle) IBM.ICU.Util.UResourceBundle
	                    .GetBundleInstance(IBM.ICU.Impl.ICUResourceBundle.ICU_BASE_NAME,
	                            parentLocale);
	            prb = prb.GetWithFallback("calendar");
	            ICUResourceBundle pGregorianBundle = prb
	                    .GetWithFallback("gregorian");
	            try {
	                ICUResourceBundle formatBundle_5 = pGregorianBundle
	                        .GetWithFallback("availableFormats");
	                // System.out.println("available format from parent locale:"+parentLocale.getName());
	                for (int i_6 = 0; i_6 < formatBundle_5.GetSize(); ++i_6) {
	                    String formatKey_7 = formatBundle_5.Get(i_6).GetKey();
	                    String formatValue_8 = formatBundle_5.Get(i_6).GetString();
	                    // System.out.println(" availableFormat:"+formatValue);
	                    if (!result.IsAvailableFormatSet(formatKey_7)) {
	                        result.SetAvailableFormat(formatKey_7);
	                        result.AddPattern(formatValue_8, false, returnInfo);
	                        // System.out.println(" availableFormat:"+formatValue);
	                    }
	                }
	
	            } catch (Exception e_9) {
	            }
	
	        }
	
	        // assume it is always big endian (ok for CLDR right now)
	        // some languages didn't add mm:ss or HH:mm, so put in a hack to compute
	        // that from the short time.
	        if (hackPattern != null) {
	            HackTimes(result, returnInfo, hackPattern);
	        }
	
	        // set the datetime pattern. This is ugly code -- there should be a
	        // public interface for this
	        Calendar cal = IBM.ICU.Util.Calendar.GetInstance(uLocale);
	        CalendarData calData = new CalendarData(uLocale, cal.GetType());
	        String[] patterns = calData.Get("DateTimePatterns").GetStringArray();
	        result.SetDateTimeFormat(patterns[8]);
	
	        // decimal point for seconds
	        DecimalFormatSymbols dfs = new DecimalFormatSymbols(uLocale);
	        result.SetDecimal(dfs.GetDecimalSeparator().ToString());
	        return result;
	    }
	
	    private static void HackTimes(DateTimePatternGenerator result,
	            DateTimePatternGenerator.PatternInfo  returnInfo, String hackPattern) {
	        result.fp.Set(hackPattern);
	        String mmss = String.Empty;
	        // to get mm:ss, we strip all but mm literal ss
	        bool gotMm = false;
	        for (int i = 0; i < result.fp.items.Count; ++i) {
	            Object item = result.fp.items[i];
	            if (item  is  String) {
	                if (gotMm) {
	                    mmss += result.fp.QuoteLiteral(item.ToString());
	                }
	            } else {
	                char ch = item.ToString()[0];
	                if (ch == 'm') {
	                    gotMm = true;
	                    mmss += item;
	                } else if (ch == 's') {
	                    if (!gotMm) {
	                        break; // failed
	                    }
	                    mmss += item;
	                    result.AddPattern(mmss, false, returnInfo);
	                    break;
	                } else if (gotMm || ch == 'z' || ch == 'Z' || ch == 'v'
	                        || ch == 'V') {
	                    break; // failed
	                }
	            }
	        }
	        // to get hh:mm, we strip (literal ss) and (literal S)
	        // the easiest way to do this is to mark the stuff we want to nuke, then
	        // remove it in a second pass.
	        BitSet variables = new BitSet();
	        BitSet nuke = new BitSet();
	        for (int i_0 = 0; i_0 < result.fp.items.Count; ++i_0) {
	            Object item_1 = result.fp.items[i_0];
	            if (item_1  is  DateTimePatternGenerator.VariableField ) {
	                variables.Set(i_0);
	                char ch_2 = item_1.ToString()[0];
	                if (ch_2 == 's' || ch_2 == 'S') {
	                    nuke.Set(i_0);
	                    for (int j = i_0 - 1; j >= 0; ++j) {
	                        if (variables.Get(j))
	                            break;
	                        nuke.Set(i_0);
	                    }
	                }
	            }
	        }
	        String hhmm = GetFilteredPattern(result.fp, nuke);
	        result.AddPattern(hhmm, false, returnInfo);
	    }
	
	    private static String GetFilteredPattern(DateTimePatternGenerator.FormatParser  fp, BitSet nuke) {
	        String result = String.Empty;
	        for (int i = 0; i < fp.items.Count; ++i) {
	            if (nuke.Get(i))
	                continue;
	            Object item = fp.items[i];
	            if (item  is  String) {
	                result += fp.QuoteLiteral(item.ToString());
	            } else {
	                result += item.ToString();
	            }
	        }
	        return result;
	    }
	
	    /*
	     * private static int getAppendNameNumber(String string) { for (int i = 0; i
	     * < CLDR_FIELD_NAME.length; ++i) { if (CLDR_FIELD_NAME[i].equals(string))
	     * return i; } return -1; }
	     */
	
	    private static int GetAppendFormatNumber(String str0) {
	        for (int i = 0; i < CLDR_FIELD_APPEND.Length; ++i) {
	            if (CLDR_FIELD_APPEND[i].Equals(str0))
	                return i;
	        }
	        return -1;
	
	    }
	
	    private static bool IsCLDRFieldName(int index) {
	        if ((index < 0) && (index >= TYPE_LIMIT)) {
	            return false;
	        }
	        if (CLDR_FIELD_NAME[index][0] == '*') {
	            return false;
	        } else {
	            return true;
	        }
	    }
	
	    /// <summary>
	    /// Return the best pattern matching the input skeleton. It is guaranteed to
	    /// have all of the fields in the skeleton.
	    /// </summary>
	    ///
	    /// <param name="skeleton">The skeleton is a pattern containing only the variable fields.For example, "MMMdd" and "mmhh" are skeletons.</param>
	    /// @draft ICU 3.6
	    /// @provisional This API might change or be removed in a future release.
	    public String GetBestPattern(String skeleton) {
	        if (chineseMonthHack) {
	            skeleton = skeleton.Replace("MMM+", "MM");
	        }
	        // if (!isComplete) complete();
	        current.Set(skeleton, fp);
	        String best = GetBestRaw(current, -1, _distanceInfo);
	        if (_distanceInfo.missingFieldMask == 0
	                && _distanceInfo.extraFieldMask == 0) {
	            // we have a good item. Adjust the field types
	            return AdjustFieldTypes(best, current, false);
	        }
	        int neededFields = current.GetFieldMask();
	        // otherwise break up by date and time.
	        String datePattern = GetBestAppending(neededFields & DATE_MASK);
	        String timePattern = GetBestAppending(neededFields & TIME_MASK);
	
	        if (datePattern == null)
	            return (timePattern == null) ? "" : timePattern;
	        if (timePattern == null)
	            return datePattern;
	        return IBM.ICU.Text.MessageFormat.Format(GetDateTimeFormat(), new Object[] {
	                datePattern, timePattern });
	    }
	
	    /// <summary>
	    /// PatternInfo supplies output parameters for add(...). It is used because
	    /// Java doesn't have real output parameters. It is treated like a struct (eg
	    /// Point), so all fields are public.
	    /// </summary>
	    ///
	    /// @draft ICU 3.6
	    /// @provisional This API might change or be removed in a future release.
	    public sealed class PatternInfo { // struct for return information
	        
	        /// @draft ICU 3.6
	        /// @provisional This API might change or be removed in a future release.
	        public const int OK = 0;
	
	        
	        /// @draft ICU 3.6
	        /// @provisional This API might change or be removed in a future release.
	        public const int BASE_CONFLICT = 1;
	
	        
	        /// @draft ICU 3.6
	        /// @provisional This API might change or be removed in a future release.
	        public const int CONFLICT = 2;
	
	        
	        /// @draft ICU 3.6
	        /// @provisional This API might change or be removed in a future release.
	        public int status;
	
	        
	        /// @draft ICU 3.6
	        /// @provisional This API might change or be removed in a future release.
	        public String conflictingPattern;
	
	        /// <summary>
	        /// Simple constructor, since this is treated like a struct.
	        /// </summary>
	        ///
	        /// @draft ICU 3.6
	        /// @provisional This API might change or be removed in a future release.
	        public PatternInfo() {
	        }
	    }
	
	    /// <summary>
	    /// Adds a pattern to the generator. If the pattern has the same skeleton as
	    /// an existing pattern, and the override parameter is set, then the previous
	    /// value is overriden. Otherwise, the previous value is retained. In either
	    /// case, the conflicting information is returned in PatternInfo.
	    /// <p>
	    /// Note that single-field patterns (like "MMM") are automatically added, and
	    /// don't need to be added explicitly!
	    /// </summary>
	    ///
	    /// <param name="override">when existing values are to be overridden use true, otherwiseuse false.</param>
	    /// @draft ICU 3.6
	    /// @provisional This API might change or be removed in a future release.
	    public DateTimePatternGenerator AddPattern(String pattern,
	            bool overriden, DateTimePatternGenerator.PatternInfo  returnInfo) {
	        CheckFrozen();
	        DateTimePatternGenerator.DateTimeMatcher  matcher = new DateTimePatternGenerator.DateTimeMatcher ().Set(pattern, fp);
	        String basePattern = matcher.GetBasePattern();
	        String previousPatternWithSameBase = (String) basePattern_pattern[basePattern];
	        if (previousPatternWithSameBase != null) {
	            returnInfo.status = IBM.ICU.Text.DateTimePatternGenerator.PatternInfo.BASE_CONFLICT;
	            returnInfo.conflictingPattern = previousPatternWithSameBase;
	            if (!overriden)
	                return this;
	        }
	        String previousValue = (String) skeleton2pattern[matcher];
	        if (previousValue != null) {
	            returnInfo.status = IBM.ICU.Text.DateTimePatternGenerator.PatternInfo.CONFLICT;
	            returnInfo.conflictingPattern = previousValue;
	            if (!overriden)
	                return this;
	        }
	        returnInfo.status = IBM.ICU.Text.DateTimePatternGenerator.PatternInfo.OK;
	        returnInfo.conflictingPattern = "";
	        ILOG.J2CsMapping.Collections.Collections.Put(skeleton2pattern,matcher,pattern);
	        ILOG.J2CsMapping.Collections.Collections.Put(basePattern_pattern,basePattern,pattern);
	        return this;
	    }
	
	    /// <summary>
	    /// Utility to return a unique skeleton from a given pattern. For example,
	    /// both "MMM-dd" and "dd/MMM" produce the skeleton "MMMdd".
	    /// </summary>
	    ///
	    /// <param name="pattern">Input pattern, such as "dd/MMM"</param>
	    /// <returns>skeleton, such as "MMMdd"</returns>
	    /// @draft ICU 3.6
	    /// @provisional This API might change or be removed in a future release.
	    public String GetSkeleton(String pattern) {
	         lock (this) { // synchronized since a getter must be thread-safe
	                    current.Set(pattern, fp);
	                    return current.ToString();
	                }
	    }
	
	    /// <summary>
	    /// Utility to return a unique base skeleton from a given pattern. This is
	    /// the same as the skeleton, except that differences in length are minimized
	    /// so as to only preserve the difference between string and numeric form. So
	    /// for example, both "MMM-dd" and "d/MMM" produce the skeleton "MMMd"
	    /// (notice the single d).
	    /// </summary>
	    ///
	    /// <param name="pattern">Input pattern, such as "dd/MMM"</param>
	    /// <returns>skeleton, such as "MMMdd"</returns>
	    /// @draft ICU 3.6
	    /// @provisional This API might change or be removed in a future release.
	    public String GetBaseSkeleton(String pattern) {
	         lock (this) { // synchronized since a getter must be thread-safe
	                    current.Set(pattern, fp);
	                    return current.GetBasePattern();
	                }
	    }
	
	    /// <summary>
	    /// Return a list of all the skeletons (in canonical form) from this class,
	    /// and the patterns that they map to.
	    /// </summary>
	    ///
	    /// <param name="result">an output Map in which to place the mapping from skeleton topattern. If you want to see the internal order being used,supply a LinkedHashMap. If the input value is null, then aLinkedHashMap is allocated.<p><i>Issue: an alternate API would be to just return a list ofthe skeletons, and then have a separate routine to get fromskeleton to pattern.</i></param>
	    /// <returns>the input Map containing the values.</returns>
	    /// @draft ICU 3.6
	    /// @provisional This API might change or be removed in a future release.
	    public IDictionary GetSkeletons(IDictionary result) {
	        if (result == null)
	            result = new Hashtable();
	        for (IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(new ILOG.J2CsMapping.Collections.ListSet(skeleton2pattern.Keys).GetEnumerator()); it.HasNext();) {
	            DateTimePatternGenerator.DateTimeMatcher  item = (DateTimePatternGenerator.DateTimeMatcher ) it.Next();
	            String pattern = (String) skeleton2pattern[item];
	            if (ILOG.J2CsMapping.Collections.Collections.Contains(pattern,CANONICAL_SET))
	                continue;
	            ILOG.J2CsMapping.Collections.Collections.Put(result,item.ToString(),pattern);
	        }
	        return result;
	    }
	
	    /// <summary>
	    /// Return a list of all the base skeletons (in canonical form) from this
	    /// class
	    /// </summary>
	    ///
	    /// @draft ICU 3.6
	    /// @provisional This API might change or be removed in a future release.
	    public ILOG.J2CsMapping.Collections.ISet GetBaseSkeletons(ILOG.J2CsMapping.Collections.ISet result) {
	        if (result == null)
	            result = new HashedSet();
	        ILOG.J2CsMapping.Collections.Generics.Collections.AddAll(new ILOG.J2CsMapping.Collections.ListSet(basePattern_pattern.Keys),result);
	        return result;
	    }
	
	    /// <summary>
	    /// Adjusts the field types (width and subtype) of a pattern to match what is
	    /// in a skeleton. That is, if you supply a pattern like "d-M H:m", and a
	    /// skeleton of "MMMMddhhmm", then the input pattern is adjusted to be
	    /// "dd-MMMM hh:mm". This is used internally to get the best match for the
	    /// input skeleton, but can also be used externally.
	    /// </summary>
	    ///
	    /// <param name="pattern">input pattern</param>
	    /// <param name="skeleton"></param>
	    /// <returns>pattern adjusted to match the skeleton fields widths and
	    /// subtypes.</returns>
	    /// @draft ICU 3.6
	    /// @provisional This API might change or be removed in a future release.
	    public String ReplaceFieldTypes(String pattern, String skeleton) {
	         lock (this) { // synchronized since a getter must be thread-safe
	                    return AdjustFieldTypes(pattern, current.Set(skeleton, fp), false);
	                }
	    }
	
	    /// <summary>
	    /// The date time format is a message format pattern used to compose date and
	    /// time patterns. The default value is "{0} {1}", where {0} will be replaced
	    /// by the date pattern and {1} will be replaced by the time pattern.
	    /// <p>
	    /// This is used when the input skeleton contains both date and time fields,
	    /// but there is not a close match among the added patterns. For example,
	    /// suppose that this object was created by adding "dd-MMM" and "hh:mm", and
	    /// its datetimeFormat is the default "{0} {1}". Then if the input skeleton
	    /// is "MMMdhmm", there is not an exact match, so the input skeleton is
	    /// broken up into two components "MMMd" and "hmm". There are close matches
	    /// for those two skeletons, so the result is put together with this pattern,
	    /// resulting in "d-MMM h:mm".
	    /// </summary>
	    ///
	    /// <param name="dateTimeFormat">message format pattern, here {0} will be replaced by the datepattern and {1} will be replaced by the time pattern.</param>
	    /// @draft ICU 3.6
	    /// @provisional This API might change or be removed in a future release.
	    public void SetDateTimeFormat(String dateTimeFormat) {
	        CheckFrozen();
	        this.dateTimeFormat = dateTimeFormat;
	    }
	
	    /// <summary>
	    /// Getter corresponding to setDateTimeFormat.
	    /// </summary>
	    ///
	    /// <returns>pattern</returns>
	    /// @draft ICU 3.6
	    /// @provisional This API might change or be removed in a future release.
	    public String GetDateTimeFormat() {
	        return dateTimeFormat;
	    }
	
	    /// <summary>
	    /// The decimal value is used in formatting fractions of seconds. If the
	    /// skeleton contains fractional seconds, then this is used with the
	    /// fractional seconds. For example, suppose that the input pattern is
	    /// "hhmmssSSSS", and the best matching pattern internally is "H:mm:ss", and
	    /// the decimal string is ",". Then the resulting pattern is modified to be
	    /// "H:mm:ss,SSSS"
	    /// </summary>
	    ///
	    /// <param name="decimal"></param>
	    /// @draft ICU 3.6
	    /// @provisional This API might change or be removed in a future release.
	    public void SetDecimal(String dec) {
	        CheckFrozen();
	        this.decimal_ = dec;
	    }
	
	    /// <summary>
	    /// Getter corresponding to setDecimal.
	    /// </summary>
	    ///
	    /// <returns>string corresponding to the decimal point</returns>
	    /// @draft ICU 3.6
	    /// @provisional This API might change or be removed in a future release.
	    public String GetDecimal() {
	        return decimal_;
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Redundant patterns are those which if removed, make no difference in the
	    /// resulting getBestPattern values. This method returns a list of them, to
	    /// help check the consistency of the patterns used to build this generator.
	    /// </summary>
	    ///
	    /// <param name="output">stores the redundant patterns that are removed. To get thesein internal order, supply a LinkedHashSet. If null, acollection is allocated.</param>
	    /// <returns>the collection with added elements.</returns>
	    public ICollection GetRedundants(ICollection output) {
	         lock (this) { // synchronized since a getter must be thread-safe
	                    if (output == null)
	                        output = new HashedSet(); // TODO: was LinkedHashSet
	                    for (IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(new ILOG.J2CsMapping.Collections.ListSet(skeleton2pattern.Keys).GetEnumerator()); it
	                            .HasNext();) {
	                        DateTimePatternGenerator.DateTimeMatcher  current = (DateTimePatternGenerator.DateTimeMatcher ) it.Next();
	                        String pattern = (String) skeleton2pattern[current];
	                        if (ILOG.J2CsMapping.Collections.Collections.Contains(pattern,CANONICAL_SET))
	                            continue;
	                        skipMatcher = current;
	                        String trial = GetBestPattern(current.ToString());
	                        if (trial.Equals(pattern)) {
	                            ILOG.J2CsMapping.Collections.Collections.Add(output,pattern);
	                        }
	                    }
	                    if (false) { // ordered
	                        DateTimePatternGenerator results = new DateTimePatternGenerator();
	                        DateTimePatternGenerator.PatternInfo  pinfo = new DateTimePatternGenerator.PatternInfo ();
	                        for (IIterator it_0 = new ILOG.J2CsMapping.Collections.IteratorAdapter(new ILOG.J2CsMapping.Collections.ListSet(skeleton2pattern.Keys).GetEnumerator()); it_0
	                                .HasNext();) {
	                            DateTimePatternGenerator.DateTimeMatcher  current_1 = (DateTimePatternGenerator.DateTimeMatcher ) it_0.Next();
	                            String pattern_2 = (String) skeleton2pattern[current_1];
	                            if (ILOG.J2CsMapping.Collections.Collections.Contains(pattern_2,CANONICAL_SET))
	                                continue;
	                            // skipMatcher = current;
	                            String trial_3 = results.GetBestPattern(current_1.ToString());
	                            if (trial_3.Equals(pattern_2)) {
	                                ILOG.J2CsMapping.Collections.Collections.Add(output,pattern_2);
	                            } else {
	                                results.AddPattern(pattern_2, false, pinfo);
	                            }
	                        }
	                    }
	                    return output;
	                }
	    }
	
	    // Field numbers, used for AppendItem functions
	
	    
	    /// @draft ICU 3.6
	    /// @provisional This API might change or be removed in a future release.
	    public const int ERA = 0;
	
	    
	    /// @draft ICU 3.6
	    /// @provisional This API might change or be removed in a future release.
	    public const int YEAR = 1;
	
	    
	    /// @draft ICU 3.6
	    /// @provisional This API might change or be removed in a future release.
	    public const int QUARTER = 2;
	
	    
	    /// @draft ICU 3.6
	    /// @provisional This API might change or be removed in a future release.
	    public const int MONTH = 3;
	
	    
	    /// @draft ICU 3.6
	    /// @provisional This API might change or be removed in a future release.
	    public const int WEEK_OF_YEAR = 4;
	
	    
	    /// @draft ICU 3.6
	    /// @provisional This API might change or be removed in a future release.
	    public const int WEEK_OF_MONTH = 5;
	
	    
	    /// @draft ICU 3.6
	    /// @provisional This API might change or be removed in a future release.
	    public const int WEEKDAY = 6;
	
	    
	    /// @draft ICU 3.6
	    /// @provisional This API might change or be removed in a future release.
	    public const int DAY = 7;
	
	    
	    /// @draft ICU 3.6
	    /// @provisional This API might change or be removed in a future release.
	    public const int DAY_OF_YEAR = 8;
	
	    
	    /// @draft ICU 3.6
	    /// @provisional This API might change or be removed in a future release.
	    public const int DAY_OF_WEEK_IN_MONTH = 9;
	
	    
	    /// @draft ICU 3.6
	    /// @provisional This API might change or be removed in a future release.
	    public const int DAYPERIOD = 10;
	
	    
	    /// @draft ICU 3.6
	    /// @provisional This API might change or be removed in a future release.
	    public const int HOUR = 11;
	
	    
	    /// @draft ICU 3.6
	    /// @provisional This API might change or be removed in a future release.
	    public const int MINUTE = 12;
	
	    
	    /// @draft ICU 3.6
	    /// @provisional This API might change or be removed in a future release.
	    public const int SECOND = 13;
	
	    
	    /// @draft ICU 3.6
	    /// @provisional This API might change or be removed in a future release.
	    public const int FRACTIONAL_SECOND = 14;
	
	    
	    /// @draft ICU 3.6
	    /// @provisional This API might change or be removed in a future release.
	    public const int ZONE = 15;
	
	    
	    /// @draft ICU 3.6
	    /// @provisional This API might change or be removed in a future release.
	    public const int TYPE_LIMIT = 16;
	
	    /// <summary>
	    /// An AppendItem format is a pattern used to append a field if there is no
	    /// good match. For example, suppose that the input skeleton is "GyyyyMMMd",
	    /// and there is no matching pattern internally, but there is a pattern
	    /// matching "yyyyMMMd", say "d-MM-yyyy". Then that pattern is used, plus the
	    /// G. The way these two are conjoined is by using the AppendItemFormat for G
	    /// (era). So if that value is, say "{0}, {1}" then the final resulting
	    /// pattern is "d-MM-yyyy, G".
	    /// <p>
	    /// There are actually three available variables: {0} is the pattern so far,
	    /// {1} is the element we are adding, and {2} is the name of the element.
	    /// <p>
	    /// This reflects the way that the CLDR data is organized.
	    /// </summary>
	    ///
	    /// <param name="field">such as ERA</param>
	    /// <param name="value">pattern, such as "{0}, {1}"</param>
	    /// @draft ICU 3.6
	    /// @provisional This API might change or be removed in a future release.
	    public void SetAppendItemFormat(int field, String value_ren) {
	        CheckFrozen();
	        appendItemFormats[field] = value_ren;
	    }
	
	    /// <summary>
	    /// Getter corresponding to setAppendItemFormats. Values below 0 or at or
	    /// above TYPE_LIMIT are illegal arguments.
	    /// </summary>
	    ///
	    /// <param name="field"></param>
	    /// <returns>append pattern for field</returns>
	    /// @draft ICU 3.6
	    /// @provisional This API might change or be removed in a future release.
	    public String GetAppendItemFormat(int field) {
	        return appendItemFormats[field];
	    }
	
	    /// <summary>
	    /// Sets the names of fields, eg "era" in English for ERA. These are only
	    /// used if the corresponding AppendItemFormat is used, and if it contains a
	    /// {2} variable.
	    /// <p>
	    /// This reflects the way that the CLDR data is organized.
	    /// </summary>
	    ///
	    /// <param name="field"></param>
	    /// <param name="value"></param>
	    /// @draft ICU 3.6
	    /// @provisional This API might change or be removed in a future release.
	    public void SetAppendItemName(int field, String value_ren) {
	        CheckFrozen();
	        appendItemNames[field] = value_ren;
	    }
	
	    /// <summary>
	    /// Getter corresponding to setAppendItemNames. Values below 0 or at or above
	    /// TYPE_LIMIT are illegal arguments.
	    /// </summary>
	    ///
	    /// <param name="field"></param>
	    /// <returns>name for field</returns>
	    /// @draft ICU 3.6
	    /// @provisional This API might change or be removed in a future release.
	    public String GetAppendItemName(int field) {
	        return appendItemNames[field];
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Determines whether a skeleton contains a single field
	    /// </summary>
	    ///
	    /// <param name="skeleton"></param>
	    /// <returns>true or not</returns>
	    public static bool IsSingleField(String skeleton) {
	        char first = skeleton[0];
	        for (int i = 1; i < skeleton.Length; ++i) {
	            if (skeleton[i] != first)
	                return false;
	        }
	        return true;
	    }
	
	    /// <summary>
	    /// Add key to HashSet cldrAvailableFormatKeys.
	    /// </summary>
	    ///
	    /// <param name="key">of the availableFormats in CLDR</param>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    private void SetAvailableFormat(String key) {
	        CheckFrozen();
	        ILOG.J2CsMapping.Collections.Generics.Collections.Add(cldrAvailableFormatKeys,key);
	    }
	
	    /// <summary>
	    /// This function checks the corresponding slot of CLDR_AVAIL_FORMAT_KEY[]
	    /// has been added to DateTimePatternGenerator. The function is to avoid the
	    /// duplicate availableFomats added to the pattern map from parent locales.
	    /// </summary>
	    ///
	    /// <param name="key">of the availableFormatMask in CLDR</param>
	    /// <returns>TRUE if the corresponding slot of CLDR_AVAIL_FORMAT_KEY[] has
	    /// been added to DateTimePatternGenerator.</returns>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    private bool IsAvailableFormatSet(String key) {
	        return ILOG.J2CsMapping.Collections.Collections.Contains(key,cldrAvailableFormatKeys);
	    }
	
	    /// <summary>
	    /// Boilerplate for Freezable
	    /// </summary>
	    ///
	    /// @draft ICU 3.6
	    /// @provisional This API might change or be removed in a future release.
	    public virtual bool IsFrozen() {
	        return frozen;
	    }
	
	    /// <summary>
	    /// Boilerplate for Freezable
	    /// </summary>
	    ///
	    /// @draft ICU 3.6
	    /// @provisional This API might change or be removed in a future release.
	    public virtual Object Freeze() {
	        frozen = true;
	        return this;
	    }
	
	    /// <summary>
	    /// Boilerplate for Freezable
	    /// </summary>
	    ///
	    /// @draft ICU 3.6
	    /// @provisional This API might change or be removed in a future release.
	    public virtual Object CloneAsThawed() {
	        DateTimePatternGenerator result = (DateTimePatternGenerator) (this
	                .Clone());
	        frozen = false;
	        return result;
	    }
	
	    /// <summary>
	    /// Boilerplate
	    /// </summary>
	    ///
	    /// @draft ICU 3.6
	    /// @provisional This API might change or be removed in a future release.
	    public virtual Object Clone() {
	        try {
	            DateTimePatternGenerator result = (DateTimePatternGenerator) (base.MemberwiseClone());
	            result.skeleton2pattern = (SortedList) skeleton2pattern.Clone();
	            result.basePattern_pattern = (SortedList) basePattern_pattern.Clone();
	            result.appendItemFormats = (String[]) appendItemFormats.Clone();
	            result.appendItemNames = (String[]) appendItemNames.Clone();
	            result.current = new DateTimePatternGenerator.DateTimeMatcher ();
	            result.fp = new DateTimePatternGenerator.FormatParser ();
	            result._distanceInfo = new DateTimePatternGenerator.DistanceInfo ();
	
	            result.frozen = false;
	            return result;
	        } catch (Exception e) {
	            throw new ArgumentException("Internal Error");
	        }
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Utility class for FormatParser. Immutable class.
	    /// </summary>
	    ///
	    public class VariableField {
	        internal String str0;
	
	        /// <exclude/>
	        /// <summary>
	        /// Create a variable field
	        /// </summary>
	        ///
	        /// <param name="string"></param>
	        public VariableField(String str0) {
	            this.str0 = str0;
	        }
	
	        /// <exclude/>
	        /// <summary>
	        /// Get the internal results
	        /// </summary>
	        ///
	        public override String ToString() {
	            return str0;
	        }
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Class providing date formatting
	    /// </summary>
	    ///
	    public class FormatParser {
	        private PatternTokenizer tokenizer;
	
	        public IList items;
	
	        /// <exclude/>
	        /// <summary>
	        /// Set the string to parse
	        /// </summary>
	        ///
	        /// <param name="string"></param>
	        /// <returns>this, for chaining</returns>
	        public DateTimePatternGenerator.FormatParser  Set(String str0) {
	            ILOG.J2CsMapping.Collections.Collections.Clear(items);
	            if (str0.Length == 0)
	                return this;
	            tokenizer.SetPattern(str0);
	            StringBuilder buffer = new StringBuilder();
	            StringBuilder variable = new StringBuilder();
	            while (true) {
	                buffer.Length=0;
	                int status_0 = tokenizer.Next(buffer);
	                if (status_0 == IBM.ICU.Impl.PatternTokenizer.DONE)
	                    break;
	                if (status_0 == IBM.ICU.Impl.PatternTokenizer.SYNTAX) {
	                    if (variable.Length != 0
	                            && buffer[0] != variable[0]) {
	                        AddVariable(variable);
	                    }
	                    variable.Append(buffer);
	                } else {
	                    AddVariable(variable);
	                    ILOG.J2CsMapping.Collections.Generics.Collections.Add(items,buffer.ToString());
	                }
	            }
	            AddVariable(variable);
	            return this;
	        }
	
	        public void AddVariable(StringBuilder variable) {
	            if (variable.Length != 0) {
	                ILOG.J2CsMapping.Collections.Generics.Collections.Add(items,new DateTimePatternGenerator.VariableField (variable.ToString()));
	                variable.Length=0;
	            }
	        }
	
	        /// <summary>
	        /// Return a collection of fields. These will be a mixture of Strings and
	        /// VariableFields. Any "a" variable field is removed.
	        /// </summary>
	        ///
	        /// <param name="output">List to append the items to. If null, is allocated as anArrayList.</param>
	        /// <returns>list</returns>
	        public IList GetVariableFields(IList output) {
	            if (output == null)
	                output = new ArrayList();
	            main: {
	                for (IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(items.GetEnumerator()); it.HasNext();) {
	                    Object item = it.Next();
	                    if (item  is  DateTimePatternGenerator.VariableField ) {
	                        String s = item.ToString();
	                        switch ((int) s[0]) {
	                        // case 'Q': continue main; // HACK
	                        case 'a':
	                            goto main;
	                        }
	                        ILOG.J2CsMapping.Collections.Generics.Collections.Add(output,s);
	                    }
	                }
	            }
	            gotomain:
	            ;
	            // System.out.println(output);
	            return output;
	        }
	
	        /// <exclude/>
	        /// <returns>a string which is a concatenation of all the variable fields</returns>
	        public String GetVariableFieldString() {
	            IList list = GetVariableFields(null);
	            StringBuilder result = new StringBuilder();
	            for (IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(list.GetEnumerator()); it.HasNext();) {
	                String item = (String) it.Next();
	                result.Append(item);
	            }
	            return result.ToString();
	        }
	
	        /// <exclude/>
	        /// <summary>
	        /// Returns modifiable list which is a mixture of Strings and
	        /// VariableFields, in the order found during parsing.
	        /// </summary>
	        ///
	        /// <returns>modifiable list of items.</returns>
	        public IList GetItems() {
	            return items;
	        }
	
	        /// <exclude/>
	        /// <summary>
	        /// Provide display form of formatted input
	        /// </summary>
	        ///
	        /// <returns>printable output string</returns>
	        public override String ToString() {
	            return ToString(0, items.Count);
	        }
	
	        /// <exclude/>
	        /// <summary>
	        /// Provide display form of formatted input
	        /// </summary>
	        ///
	        /// <param name="start">item to start from</param>
	        /// <param name="limit">last item +1</param>
	        /// <returns>printable output string</returns>
	        public String ToString(int start, int limit) {
	            StringBuilder result = new StringBuilder();
	            for (int i = start; i < limit; ++i) {
	                Object item = items[i];
	                if (item  is  String) {
	                    String itemString = (String) item;
	                    result.Append(tokenizer.QuoteLiteral(itemString));
	                } else {
	                    result.Append(items[i].ToString());
	                }
	            }
	            return result.ToString();
	        }
	
	        /// <exclude/>
	        /// <summary>
	        /// Internal method
	        /// <p>
	        /// Returns true if it has a mixture of date and time fields
	        /// </summary>
	        ///
	        /// <returns>true or false</returns>
	        public bool HasDateAndTimeFields() {
	            int foundMask = 0;
	            for (IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(items.GetEnumerator()); it.HasNext();) {
	                Object item = it.Next();
	                if (item  is  DateTimePatternGenerator.VariableField ) {
	                    int type = GetType(item);
	                    foundMask |= 1 << type;
	                }
	            }
	            bool isDate = (foundMask & IBM.ICU.Text.DateTimePatternGenerator.DATE_MASK) != 0;
	            bool isTime = (foundMask & IBM.ICU.Text.DateTimePatternGenerator.TIME_MASK) != 0;
	            return isDate && isTime;
	        }
	
	        /// <exclude/>
	        /// <summary>
	        /// Internal routine
	        /// </summary>
	        ///
	        /// <param name="value"></param>
	        /// <param name="result"></param>
	        /// <returns>list</returns>
	        public IList GetAutoPatterns(String value_ren, IList result) {
	            if (result == null)
	                result = new ArrayList();
	            int fieldCount = 0;
	            int minField = Int32.MaxValue;
	            int maxField = Int32.MinValue;
	            for (IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(items.GetEnumerator()); it.HasNext();) {
	                Object item = it.Next();
	                if (item  is  DateTimePatternGenerator.VariableField ) {
	                    try {
	                        int type = GetType(item);
	                        if (minField > type)
	                            minField = type;
	                        if (maxField < type)
	                            maxField = type;
	                        if (type == IBM.ICU.Text.DateTimePatternGenerator.ZONE || type == IBM.ICU.Text.DateTimePatternGenerator.DAYPERIOD
	                                || type == IBM.ICU.Text.DateTimePatternGenerator.WEEKDAY)
	                            return result; // skip anything with zones
	                        fieldCount++;
	                    } catch (Exception e) {
	                        return result; // if there are any funny fields, return
	                    }
	                }
	            }
	            if (fieldCount < 3)
	                return result; // skip
	            // trim from start
	            // trim first field IF there are no letters around it
	            // and it is either the min or the max field
	            // first field is either 0 or 1
	            for (int i = 0; i < items.Count; ++i) {
	                Object item_0 = items[i];
	                if (item_0  is  DateTimePatternGenerator.VariableField ) {
	                    int type_1 = GetType(item_0);
	                    if (type_1 != minField && type_1 != maxField)
	                        break;
	
	                    if (i > 0) {
	                        Object previousItem = items[0];
	                        if (alpha.ContainsSome(previousItem.ToString()))
	                            break;
	                    }
	                    int start = i + 1;
	                    if (start < items.Count) {
	                        Object nextItem = items[start];
	                        if (nextItem  is  String) {
	                            if (alpha.ContainsSome(nextItem.ToString()))
	                                break;
	                            start++; // otherwise skip over string
	                        }
	                    }
	                    ILOG.J2CsMapping.Collections.Generics.Collections.Add(result,ToString(start, items.Count));
	                    break;
	                }
	            }
	            // now trim from end
	            for (int i_2 = items.Count - 1; i_2 >= 0; --i_2) {
	                Object item_3 = items[i_2];
	                if (item_3  is  DateTimePatternGenerator.VariableField ) {
	                    int type_4 = GetType(item_3);
	                    if (type_4 != minField && type_4 != maxField)
	                        break;
	                    if (i_2 < items.Count - 1) {
	                        Object previousItem_5 = items[items.Count - 1];
	                        if (alpha.ContainsSome(previousItem_5.ToString()))
	                            break;
	                    }
	                    int end = i_2 - 1;
	                    if (end > 0) {
	                        Object nextItem_6 = items[end];
	                        if (nextItem_6  is  String) {
	                            if (alpha.ContainsSome(nextItem_6.ToString()))
	                                break;
	                            end--; // otherwise skip over string
	                        }
	                    }
	                    ILOG.J2CsMapping.Collections.Generics.Collections.Add(result,ToString(0, end + 1));
	                    break;
	                }
	            }
	
	            return result;
	        }
	
	        private static UnicodeSet alpha = new UnicodeSet("[:alphabetic:]");
	
	        public int GetType(Object item) {
	            String s = item.ToString();
	            int canonicalIndex = IBM.ICU.Text.DateTimePatternGenerator.GetCanonicalIndex(s);
	            if (canonicalIndex < 0) {
	                throw new ArgumentException("Illegal field:\t" + s);
	            }
	            int type = IBM.ICU.Text.DateTimePatternGenerator.types[canonicalIndex][1];
	            return type;
	        }
	
	        /// <exclude/>
	        /// <summary>
	        /// produce a quoted literal
	        /// </summary>
	        ///
	        /// <param name="string"></param>
	        /// <returns>string with quoted literals</returns>
	        public Object QuoteLiteral(String str0) {
	            return tokenizer.QuoteLiteral(str0);
	        }
	
	        /// <exclude/>
	        /// <summary>
	        /// Simple constructor, since this is treated like a struct.
	        /// </summary>
	        ///
	        public FormatParser() : base() {
	            // TODO Auto-generated constructor stub
	            this.tokenizer = new PatternTokenizer()
	                    .SetSyntaxCharacters(new UnicodeSet("[a-zA-Z]"))
	                    .SetExtraQuotingCharacters(
	                            new UnicodeSet(
	                                    "[[[:script=Latn:][:script=Cyrl:]]&[[:L:][:M:]]]"))
	                    // .setEscapeCharacters(new UnicodeSet("[^\\u0020-\\u007E]")) //
	                    // WARNING: DateFormat doesn't accept \\uXXXX
	                    .SetUsingQuote(true);
	            this.items = new ArrayList();
	        }
	    }
	
	    // ========= PRIVATES ============
	
	    private SortedList skeleton2pattern; // items are in priority
	                                                      // order
	
	    private SortedList basePattern_pattern; // items are in
	                                                         // priority order
	
	    private String decimal_;
	
	    private String dateTimeFormat;
	
	    private String[] appendItemFormats;
	
	    private String[] appendItemNames;
	    private DateTimePatternGenerator.DateTimeMatcher  current;
	
	    private DateTimePatternGenerator.FormatParser  fp;
	
	    private DateTimePatternGenerator.DistanceInfo  _distanceInfo;
	
	    private bool isComplete;
	
	    private DateTimePatternGenerator.DateTimeMatcher  skipMatcher; // only used
	                                                          // temporarily, for
	                                                          // internal purposes
	
	    private bool frozen;
	
	    private bool chineseMonthHack;
	
	    private const int FRACTIONAL_MASK = 1 << FRACTIONAL_SECOND;
	
	    private const int SECOND_AND_FRACTIONAL_MASK = (1 << SECOND)
	            | (1 << FRACTIONAL_SECOND);
	
	    private void CheckFrozen() {
	        if (IsFrozen()) {
	            throw new NotSupportedException(
	                    "Attempt to modify frozen object");
	        }
	    }
	
	    /// <summary>
	    /// We only get called here if we failed to find an exact skeleton. We have
	    /// broken it into date + time, and look for the pieces. If we fail to find a
	    /// complete skeleton, we compose in a loop until we have all the fields.
	    /// </summary>
	    ///
	    private String GetBestAppending(int missingFields) {
	        String resultPattern = null;
	        if (missingFields != 0) {
	            resultPattern = GetBestRaw(current, missingFields, _distanceInfo);
	            resultPattern = AdjustFieldTypes(resultPattern, current, false);
	
	            while (_distanceInfo.missingFieldMask != 0) { // precondition: EVERY
	                                                          // single field must
	                                                          // work!
	
	                // special hack for SSS. If we are missing SSS, and we had ss
	                // but found it, replace the s field according to the
	                // number separator
	                if ((_distanceInfo.missingFieldMask & SECOND_AND_FRACTIONAL_MASK) == FRACTIONAL_MASK
	                        && (missingFields & SECOND_AND_FRACTIONAL_MASK) == SECOND_AND_FRACTIONAL_MASK) {
	                    resultPattern = AdjustFieldTypes(resultPattern, current,
	                            true);
	                    _distanceInfo.missingFieldMask &= ~FRACTIONAL_MASK; // remove
	                                                                        // bit
	                    continue;
	                }
	
	                int startingMask = _distanceInfo.missingFieldMask;
	                String temp = GetBestRaw(current,
	                        _distanceInfo.missingFieldMask, _distanceInfo);
	                temp = AdjustFieldTypes(temp, current, false);
	                int foundMask = startingMask & ~_distanceInfo.missingFieldMask;
	                int topField = GetTopBitNumber(foundMask);
	                resultPattern = IBM.ICU.Text.MessageFormat.Format(GetAppendFormat(topField),
	                        new Object[] { resultPattern, temp,
	                                GetAppendName(topField) });
	            }
	        }
	        return resultPattern;
	    }
	
	    private String GetAppendName(int foundMask) {
	        return "'" + appendItemNames[foundMask] + "'";
	    }
	
	    private String GetAppendFormat(int foundMask) {
	        return appendItemFormats[foundMask];
	    }
	
	    // /**
	    // * @param current2
	    // * @return
	    // */
	    // private String adjustSeconds(DateTimeMatcher current2) {
	    // // TODO Auto-generated method stub
	    // return null;
	    // }
	
	    
	    /// <param name="foundMask"></param>
	    /// <returns></returns>
	    private int GetTopBitNumber(int foundMask) {
	        int i = 0;
	        while (foundMask != 0) {
	            foundMask = (int) (((uint) foundMask) >> 1);
	            ++i;
	        }
	        return i - 1;
	    }
	
	    private void Complete() {
	        DateTimePatternGenerator.PatternInfo  patternInfo = new DateTimePatternGenerator.PatternInfo ();
	        // make sure that every valid field occurs once, with a "default" length
	        for (int i = 0; i < CANONICAL_ITEMS.Length; ++i) {
	            // char c = (char)types[i][0];
	            AddPattern(CANONICAL_ITEMS[i].ToString(), false, patternInfo);
	        }
	        isComplete = true;
	    }
	
	    private String GetBestRaw(DateTimePatternGenerator.DateTimeMatcher  source, int includeMask,
	            DateTimePatternGenerator.DistanceInfo  missingFields) {
	        // if (SHOW_DISTANCE) System.out.println("Searching for: " +
	        // source.pattern
	        // + ", mask: " + showMask(includeMask));
	        int bestDistance = Int32.MaxValue;
	        String bestPattern = "";
	        DateTimePatternGenerator.DistanceInfo  tempInfo = new DateTimePatternGenerator.DistanceInfo ();
	        for (IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(new ILOG.J2CsMapping.Collections.ListSet(skeleton2pattern.Keys).GetEnumerator()); it.HasNext();) {
	            DateTimePatternGenerator.DateTimeMatcher  trial = (DateTimePatternGenerator.DateTimeMatcher ) it.Next();
	            if (trial.Equals(skipMatcher))
	                continue;
	            int distance = source.GetDistance(trial, includeMask, tempInfo);
	            // if (SHOW_DISTANCE) System.out.println("\tDistance: " +
	            // trial.pattern + ":\t"
	            // + distance + ",\tmissing fields: " + tempInfo);
	            if (distance < bestDistance) {
	                bestDistance = distance;
	                bestPattern = (String) skeleton2pattern[trial];
	                missingFields.SetTo(tempInfo);
	                if (distance == 0)
	                    break;
	            }
	        }
	        return bestPattern;
	    }
	
	    
	    /// <param name="fixFractionalSeconds">TODO</param>
	    private String AdjustFieldTypes(String pattern,
	            DateTimePatternGenerator.DateTimeMatcher  inputRequest, bool fixFractionalSeconds) {
	        fp.Set(pattern);
	        StringBuilder newPattern = new StringBuilder();
	        for (IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(fp.GetItems().GetEnumerator()); it.HasNext();) {
	            Object item = it.Next();
	            if (item  is  String) {
	                newPattern.Append(fp.QuoteLiteral((String) item));
	            } else {
	                String field = ((DateTimePatternGenerator.VariableField ) item).str0;
	                int canonicalIndex = GetCanonicalIndex(field);
	                if (canonicalIndex < 0) {
	                    continue; // don't adjust
	                }
	                int type = types[canonicalIndex][1];
	                if (fixFractionalSeconds && type == SECOND) {
	                    String newField = inputRequest.original[FRACTIONAL_SECOND];
	                    field = field + decimal_ + newField;
	                } else if (inputRequest.type[type] != 0) {
	                    String newField_0 = inputRequest.original[type];
	                    // normally we just replace the field. However HOUR is
	                    // special; we only change the length
	                    if (type != HOUR) {
	                        field = newField_0;
	                    } else if (field.Length != newField_0.Length) {
	                        char c = field[0];
	                        field = "";
	                        for (int i = newField_0.Length; i > 0; --i)
	                            field += c;
	                    }
	                }
	                newPattern.Append(field);
	            }
	        }
	        // if (SHOW_DISTANCE) System.out.println("\tRaw: " + pattern);
	        return newPattern.ToString();
	    }
	
	    // public static String repeat(String s, int count) {
	    // StringBuffer result = new StringBuffer();
	    // for (int i = 0; i < count; ++i) {
	    // result.append(s);
	    // }
	    // return result.toString();
	    // }
	
	    /// <exclude/>
	    /// <summary>
	    /// internal routine
	    /// </summary>
	    ///
	    /// <param name="pattern"></param>
	    /// <returns>field value</returns>
	    public String GetFields(String pattern) {
	        fp.Set(pattern);
	        StringBuilder newPattern = new StringBuilder();
	        for (IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(fp.GetItems().GetEnumerator()); it.HasNext();) {
	            Object item = it.Next();
	            if (item  is  String) {
	                newPattern.Append(fp.QuoteLiteral((String) item));
	            } else {
	                newPattern.Append("{" + GetName(item.ToString()) + "}");
	            }
	        }
	        return newPattern.ToString();
	    }
	
	    private static String ShowMask(int mask) {
	        String result = "";
	        for (int i = 0; i < TYPE_LIMIT; ++i) {
	            if ((mask & (1 << i)) == 0)
	                continue;
	            if (result.Length != 0)
	                result += " | ";
	            result += FIELD_NAME[i] + " ";
	        }
	        return result;
	    }
	
	    static private String[] CLDR_FIELD_APPEND = { "Era", "Year", "Quarter",
	            "Month", "Week", "*", "Day-Of-Week", "Day", "*", "*", "*", "Hour",
	            "Minute", "Second", "*", "Timezone" };
	
	    static private String[] CLDR_FIELD_NAME = { "era", "year", "*", "month",
	            "week", "*", "weekday", "day", "*", "*", "dayperiod", "hour",
	            "minute", "second", "*", "zone" };
	
	    static private String[] FIELD_NAME = { "Era", "Year", "Quarter", "Month",
	            "Week_in_Year", "Week_in_Month", "Weekday", "Day", "Day_Of_Year",
	            "Day_of_Week_in_Month", "Dayperiod", "Hour", "Minute", "Second",
	            "Fractional_Second", "Zone" };
	
	    static private String[] CANONICAL_ITEMS = { "G", "y", "Q", "M", "w", "W",
	            "e", "d", "D", "F", "H", "m", "s", "S", "v" };
	
	    static private ILOG.J2CsMapping.Collections.ISet CANONICAL_SET = new HashedSet(
	            ILOG.J2CsMapping.Collections.Arrays.AsList(CANONICAL_ITEMS));
	
	    private ILOG.J2CsMapping.Collections.ISet cldrAvailableFormatKeys;
	
	    private const int DATE_MASK = (1 << DAYPERIOD) - 1,
	            TIME_MASK = (1 << TYPE_LIMIT) - 1 - DATE_MASK;
	
	    private const int // numbers are chosen to express 'distance'
	            DELTA = 0x10,
	            NUMERIC = 0x100, NONE = 0, NARROW = -0x100,
	            SHORT = -0x101,
	            LONG = -0x102, EXTRA_FIELD = 0x10000, MISSING_FIELD = 0x1000;
	
	    static private String GetName(String s) {
	        int i = GetCanonicalIndex(s);
	        String name = FIELD_NAME[types[i][1]];
	        int subtype = types[i][2];
	        bool str0 = subtype < 0;
	        if (str0)
	            subtype = -subtype;
	        if (subtype < 0)
	            name += ":S";
	        else
	            name += ":N";
	        return name;
	    }
	
	    static private int GetCanonicalIndex(String s) {
	        int len = s.Length;
	        int ch = s[0];
	        for (int i = 0; i < types.Length; ++i) {
	            int[] row = types[i];
	            if (row[0] != ch)
	                continue;
	            if (row[3] > len)
	                continue;
	            if (row[row.Length - 1] < len)
	                continue;
	            return i;
	        }
	        return -1;
	    }
	
	    static private int[][] types = { new int[] { 'G', ERA, SHORT, 1, 3 }, new int[] { 'G', ERA, LONG, 4 },
	            new int[] { 'y', YEAR, NUMERIC, 1, 20 },
	            new int[] { 'Y', YEAR, NUMERIC + DELTA, 1, 20 },
	            new int[] { 'u', YEAR, NUMERIC + 2 * DELTA, 1, 20 },
	            new int[] { 'Q', QUARTER, NUMERIC, 1, 2 },
	            new int[] { 'Q', QUARTER, SHORT, 3 },
	            new int[] { 'Q', QUARTER, LONG, 4 },
	            new int[] { 'M', MONTH, NUMERIC, 1, 2 },
	            new int[] { 'M', MONTH, SHORT, 3 },
	            new int[] { 'M', MONTH, LONG, 4 },
	            new int[] { 'M', MONTH, NARROW, 5 },
	            new int[] { 'L', MONTH, NUMERIC + DELTA, 1, 2 },
	            new int[] { 'L', MONTH, SHORT - DELTA, 3 },
	            new int[] { 'L', MONTH, LONG - DELTA, 4 },
	            new int[] { 'L', MONTH, NARROW - DELTA, 5 },
	            new int[] { 'w', WEEK_OF_YEAR, NUMERIC, 1, 2 },
	            new int[] { 'W', WEEK_OF_MONTH, NUMERIC + DELTA, 1 },
	            new int[] { 'e', WEEKDAY, NUMERIC + DELTA, 1, 2 },
	            new int[] { 'e', WEEKDAY, SHORT - DELTA, 3 },
	            new int[] { 'e', WEEKDAY, LONG - DELTA, 4 },
	            new int[] { 'e', WEEKDAY, NARROW - DELTA, 5 },
	            new int[] { 'E', WEEKDAY, SHORT, 1, 3 },
	            new int[] { 'E', WEEKDAY, LONG, 4 },
	            new int[] { 'E', WEEKDAY, NARROW, 5 },
	            new int[] { 'c', WEEKDAY, NUMERIC + 2 * DELTA, 1, 2 },
	            new int[] { 'c', WEEKDAY, SHORT - 2 * DELTA, 3 },
	            new int[] { 'c', WEEKDAY, LONG - 2 * DELTA, 4 },
	            new int[] { 'c', WEEKDAY, NARROW - 2 * DELTA, 5 },
	            new int[] { 'd', DAY, NUMERIC, 1, 2 },
	            new int[] { 'D', DAY_OF_YEAR, NUMERIC + DELTA, 1, 3 },
	            new int[] { 'F', DAY_OF_WEEK_IN_MONTH, NUMERIC + 2 * DELTA, 1 },
	            new int[] { 'g', DAY, NUMERIC + 3 * DELTA, 1, 20 },
	            new int[] { 'a', DAYPERIOD, SHORT, 1 },
	            new int[] { 'H', HOUR, NUMERIC + 10 * DELTA, 1, 2 },
	            new int[] { 'k', HOUR, NUMERIC + 11 * DELTA, 1, 2 },
	            new int[] { 'h', HOUR, NUMERIC, 1, 2 },
	            new int[] { 'K', HOUR, NUMERIC + DELTA, 1, 2 },
	            new int[] { 'm', MINUTE, NUMERIC, 1, 2 },
	            new int[] { 's', SECOND, NUMERIC, 1, 2 },
	            new int[] { 'S', FRACTIONAL_SECOND, NUMERIC + DELTA, 1, 1000 },
	            new int[] { 'A', SECOND, NUMERIC + 2 * DELTA, 1, 1000 },
	            new int[] { 'v', ZONE, SHORT - 2 * DELTA, 1 },
	            new int[] { 'v', ZONE, LONG - 2 * DELTA, 4 },
	            new int[] { 'z', ZONE, SHORT, 1, 3 },
	            new int[] { 'z', ZONE, LONG, 4 },
	            new int[] { 'Z', ZONE, SHORT - DELTA, 1, 3 },
	            new int[] { 'Z', ZONE, LONG - DELTA, 4 } };
	
	    private class DateTimeMatcher : IComparable {
	        public DateTimeMatcher() {
	            this.type = new int[IBM.ICU.Text.DateTimePatternGenerator.TYPE_LIMIT];
	            this.original = new String[IBM.ICU.Text.DateTimePatternGenerator.TYPE_LIMIT];
	            this.baseOriginal = new String[IBM.ICU.Text.DateTimePatternGenerator.TYPE_LIMIT];
	        }
	
	        // private String pattern = null;
            internal int[] type;
	
	        internal String[] original;
	
	        private String[] baseOriginal;
	
	        // just for testing; fix to make multi-threaded later
	        // private static FormatParser fp = new FormatParser();
	
	        public override String ToString() {
	            StringBuilder result = new StringBuilder();
	            for (int i = 0; i < IBM.ICU.Text.DateTimePatternGenerator.TYPE_LIMIT; ++i) {
	                if (original[i].Length != 0)
	                    result.Append(original[i]);
	            }
	            return result.ToString();
	        }
	
	        internal String GetBasePattern() {
	            StringBuilder result = new StringBuilder();
	            for (int i = 0; i < IBM.ICU.Text.DateTimePatternGenerator.TYPE_LIMIT; ++i) {
	                if (baseOriginal[i].Length != 0)
	                    result.Append(baseOriginal[i]);
	            }
	            return result.ToString();
	        }
	
	        internal DateTimePatternGenerator.DateTimeMatcher  Set(String pattern, DateTimePatternGenerator.FormatParser  fp_0) {
	            for (int i = 0; i < IBM.ICU.Text.DateTimePatternGenerator.TYPE_LIMIT; ++i) {
	                type[i] = IBM.ICU.Text.DateTimePatternGenerator.NONE;
	                original[i] = "";
	                baseOriginal[i] = "";
	            }
	            fp_0.Set(pattern);
	            for (IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(fp_0.GetVariableFields(new ArrayList()).GetEnumerator()); it
	                    .HasNext();) {
	                String field = (String) it.Next();
	                if (field[0] == 'a')
	                    continue; // skip day period, special cass
	                int canonicalIndex = IBM.ICU.Text.DateTimePatternGenerator.GetCanonicalIndex(field);
	                if (canonicalIndex < 0) {
	                    throw new ArgumentException("Illegal field:\t"
	                            + field + "\t in " + pattern);
	                }
	                int[] row = IBM.ICU.Text.DateTimePatternGenerator.types[canonicalIndex];
	                int typeValue = row[1];
	                if (original[typeValue].Length != 0) {
	                    throw new ArgumentException("Conflicting fields:\t"
	                            + original[typeValue] + ", " + field + "\t in "
	                            + pattern);
	                }
	                original[typeValue] = field;
	                char repeatChar = (char) row[0];
	                int repeatCount = row[3];
	                if (repeatCount > 3)
	                    repeatCount = 3; // hack to discard differences
	                if ("GEzvQ".IndexOf(repeatChar) >= 0)
	                    repeatCount = 1;
	                baseOriginal[typeValue] = IBM.ICU.Impl.Utility.Repeat(
	                        repeatChar.ToString(), repeatCount);
	                int subTypeValue = row[2];
	                if (subTypeValue > 0)
	                    subTypeValue += field.Length;
	                type[typeValue] = (byte) subTypeValue;
	            }
	            return this;
	        }
	
	        internal int GetFieldMask() {
	            int result = 0;
	            for (int i = 0; i < type.Length; ++i) {
	                if (type[i] != 0)
	                    result |= (1 << i);
	            }
	            return result;
	        }
	
	        internal void ExtractFrom(DateTimePatternGenerator.DateTimeMatcher  source, int fieldMask) {
	            for (int i = 0; i < type.Length; ++i) {
	                if ((fieldMask & (1 << i)) != 0) {
	                    type[i] = source.type[i];
	                    original[i] = source.original[i];
	                } else {
	                    type[i] = IBM.ICU.Text.DateTimePatternGenerator.NONE;
	                    original[i] = "";
	                }
	            }
	        }
	
	        internal int GetDistance(DateTimePatternGenerator.DateTimeMatcher  other, int includeMask,
	                DateTimePatternGenerator.DistanceInfo  distanceInfo) {
	            int result = 0;
	            distanceInfo.Clear();
	            for (int i = 0; i < type.Length; ++i) {
	                int myType = ((includeMask & (1 << i)) == 0) ? 0 : type[i];
	                int otherType = other.type[i];
	                if (myType == otherType)
	                    continue; // identical (maybe both zero) add 0
	                if (myType == 0) { // and other is not
	                    result += IBM.ICU.Text.DateTimePatternGenerator.EXTRA_FIELD;
	                    distanceInfo.AddExtra(i);
	                } else if (otherType == 0) { // and mine is not
	                    result += IBM.ICU.Text.DateTimePatternGenerator.MISSING_FIELD;
	                    distanceInfo.AddMissing(i);
	                } else {
	                    result += Math.Abs(myType - otherType); // square of
	                                                            // mismatch
	                }
	            }
	            return result;
	        }
	
	        public virtual int CompareTo(Object o) {
	            DateTimePatternGenerator.DateTimeMatcher  that = (DateTimePatternGenerator.DateTimeMatcher ) o;
	            for (int i = 0; i < original.Length; ++i) {
	                int comp = String.CompareOrdinal(original[i],that.original[i]);
	                if (comp != 0)
	                    return -comp;
	            }
	            return 0;
	        }
	
	        public override bool Equals(Object other) {
	            if (other == null)
	                return false;
	            DateTimePatternGenerator.DateTimeMatcher  that = (DateTimePatternGenerator.DateTimeMatcher ) other;
	            for (int i = 0; i < original.Length; ++i) {
	                if (!original[i].Equals(that.original[i]))
	                    return false;
	            }
	            return true;
	        }
	
	        public override int GetHashCode() {
	            int result = 0;
	            for (int i = 0; i < original.Length; ++i) {
	                result ^= original[i].GetHashCode();
	            }
	            return result;
	        }
	    }
	
	    private class DistanceInfo {
	        internal int missingFieldMask;
	
	        internal int extraFieldMask;
	
	        internal void Clear() {
	            missingFieldMask = extraFieldMask = 0;
	        }
	
	        internal void SetTo(DateTimePatternGenerator.DistanceInfo  other) {
	            missingFieldMask = other.missingFieldMask;
	            extraFieldMask = other.extraFieldMask;
	        }
	
	        internal void AddMissing(int field) {
	            missingFieldMask |= (1 << field);
	        }
	
	        internal void AddExtra(int field) {
	            extraFieldMask |= (1 << field);
	        }
	
	        public override String ToString() {
	            return "missingFieldMask: "
	                    + IBM.ICU.Text.DateTimePatternGenerator.ShowMask(missingFieldMask)
	                    + ", extraFieldMask: "
	                    + IBM.ICU.Text.DateTimePatternGenerator.ShowMask(extraFieldMask);
	        }
	    }
	}
	// #endif
	// eof
}
