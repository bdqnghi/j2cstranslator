/*
 *******************************************************************************
 * Copyright (C) 1996-2007, International Business Machines Corporation and    *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 */
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:30 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Text {
	
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	
	
	/// <summary>
	/// <tt>ComposedCharIter</tt> is an iterator class that returns all of the
	/// precomposed characters defined in the Unicode standard, along with their
	/// decomposed forms. This is often useful when building data tables (<i>e.g.</i>
	/// collation tables) which need to treat composed and decomposed characters
	/// equivalently.
	/// <p>
	/// For example, imagine that you have built a collation table with ordering
	/// rules for the <see cref="M:IBM.ICU.Text.Normalizer.DECOMP canonically decomposed"/> forms of all
	/// characters used in a particular language. When you process input text using
	/// this table, the text must first be decomposed so that it matches the form
	/// used in the table. This can impose a performance penalty that may be
	/// unacceptable in some situations.
	/// <p>
	/// You can avoid this problem by ensuring that the collation table contains
	/// rules for both the decomposed <i>and</i> composed versions of each character.
	/// To do so, use a <tt>ComposedCharIter</tt> to iterate through all of the
	/// composed characters in Unicode. If the decomposition for that character
	/// consists solely of characters that are listed in your ruleset, you can add a
	/// new rule for the composed character that makes it equivalent to its
	/// decomposition sequence.
	/// <p>
	/// Note that <tt>ComposedCharIter</tt> iterates over a <em>static</em> table of
	/// the composed characters in Unicode. If you want to iterate over the composed
	/// characters in a particular string, use <see cref="T:IBM.ICU.Text.Normalizer"/> instead.
	/// <p>
	/// When constructing a <tt>ComposedCharIter</tt> there is one optional feature
	/// that you can enable or disable:
	/// <ul>
	/// <li><see cref="M:IBM.ICU.Text.Normalizer.IGNORE_HANGUL"/> - Do not iterate over the Hangul
	/// characters and their corresponding Jamo decompositions. This option is off by
	/// default (<i>i.e.</i> Hangul processing is enabled) since the Unicode standard
	/// specifies that Hangul to Jamo is a canonical decomposition.
	/// </ul>
	/// <p>
	/// <tt>ComposedCharIter</tt> is currently based on version 2.1.8 of the <a
	/// href="http://www.unicode.org" target="unicode">Unicode Standard</a>. It will
	/// be updated as later versions of Unicode are released.
	/// </summary>
	///
	// /CLOVER:OFF
	public sealed class ComposedCharIter {
	
	    /// <summary>
	    /// Constant that indicates the iteration has completed. <see cref="M:IBM.ICU.Text.ComposedCharIter.Next"/>returns this value when there are no more composed characters over which
	    /// to iterate.
	    /// </summary>
	    ///
	    public static readonly int DONE = (int) IBM.ICU.Text.Normalizer.DONE;
	
	    /// <summary>
	    /// Construct a new <tt>ComposedCharIter</tt>. The iterator will return all
	    /// Unicode characters with canonical decompositions, including Korean Hangul
	    /// characters.
	    /// </summary>
	    ///
	    public ComposedCharIter() {
	        this.decompBuf = new char[100];
	        this.bufLen = 0;
	        this.curChar = 0;
	        this.nextChar = IBM.ICU.Text.Normalizer.DONE;
	        compat = false;
	        // options =0;
	    }
	
	    /// <summary>
	    /// Constructs a non-default <tt>ComposedCharIter</tt> with optional
	    /// behavior.
	    /// <p>
	    /// </summary>
	    ///
	    /// <param name="compat"><tt>false</tt> for canonical decompositions only;<tt>true</tt> for both canonical and compatibilitydecompositions.</param>
	    /// <param name="options">Optional decomposition features. Currently, the only supportedoption is <see cref="M:IBM.ICU.Text.Normalizer.IGNORE_HANGUL"/>, which causes this<tt>ComposedCharIter</tt> not to iterate over the Hangulcharacters and their corresponding Jamo decompositions.</param>
	    public ComposedCharIter(bool compat, int options) {
	        this.decompBuf = new char[100];
	        this.bufLen = 0;
	        this.curChar = 0;
	        this.nextChar = IBM.ICU.Text.Normalizer.DONE;
	        this.compat = compat;
	        // this.options = options;
	    }
	
	    /// <summary>
	    /// Determines whether there any precomposed Unicode characters not yet
	    /// returned by <see cref="M:IBM.ICU.Text.ComposedCharIter.Next"/>.
	    /// </summary>
	    ///
	    public bool HasNext() {
	        if (nextChar == IBM.ICU.Text.Normalizer.DONE) {
	            FindNextChar();
	        }
	        return nextChar != IBM.ICU.Text.Normalizer.DONE;
	    }
	
	    /// <summary>
	    /// Returns the next precomposed Unicode character. Repeated calls to
	    /// <tt>next</tt> return all of the precomposed characters defined by
	    /// Unicode, in ascending order. After all precomposed characters have been
	    /// returned, <see cref="M:IBM.ICU.Text.ComposedCharIter.HasNext"/> will return <tt>false</tt> and further calls
	    /// to <tt>next</tt> will return <see cref="F:IBM.ICU.Text.ComposedCharIter.DONE"/>.
	    /// </summary>
	    ///
	    public char Next() {
	        if (nextChar == IBM.ICU.Text.Normalizer.DONE) {
	            FindNextChar();
	        }
	        curChar = nextChar;
	        nextChar = IBM.ICU.Text.Normalizer.DONE;
	        return (char) curChar;
	    }
	
	    /// <summary>
	    /// Returns the Unicode decomposition of the current character. This method
	    /// returns the decomposition of the precomposed character most recently
	    /// returned by <see cref="M:IBM.ICU.Text.ComposedCharIter.Next"/>. The resulting decomposition is affected by the
	    /// settings of the options passed to the constructor.
	    /// </summary>
	    ///
	    public String Decomposition() {
	        // the decomposition buffer contains the decomposition of
	        // current char so just return it
	        return new String(decompBuf, 0, bufLen);
	    }
	
	    private void FindNextChar() {
	        int c = curChar + 1;
	        for (;;) {
	            if (c < 0xFFFF) {
	                bufLen = IBM.ICU.Impl.NormalizerImpl.GetDecomposition(c, compat, decompBuf,
	                        0, decompBuf.Length);
	                if (bufLen > 0) {
	                    // the curChar can be decomposed... so it is a composed char
	                    // cache the result
	                    break;
	                }
	                c++;
	            } else {
	                c = IBM.ICU.Text.Normalizer.DONE;
	                break;
	            }
	        }
	        nextChar = c;
	    }
	
	    // private int options;
	    private bool compat;
	
	    private char[] decompBuf;
	
	    private int bufLen;
	
	    private int curChar;
	
	    private int nextChar;
	
	}
}
