/*
 *******************************************************************************
 * Copyright (C) 2000-2007, International Business Machines Corporation and    *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 */
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:30 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Text {
	
	using IBM.ICU.Util;
	using ILOG.J2CsMapping.Text;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Text;
	
	/// <summary>
	/// Unicode Normalization
	/// <h2>Unicode normalization API</h2>
	/// <c>normalize</c> transforms Unicode text into an equivalent composed or
	/// decomposed form, allowing for easier sorting and searching of text.
	/// <c>normalize</c> supports the standard normalization forms described in
	/// <a href="http://www.unicode.org/unicode/reports/tr15/" target="unicode">
	/// Unicode Standard Annex #15 &mdash; Unicode Normalization Forms</a>.
	/// Characters with accents or other adornments can be encoded in several
	/// different ways in Unicode. For example, take the character A-acute. In
	/// Unicode, this can be encoded as a single character (the "composed" form):
	/// <p>
	/// 00C1 LATIN CAPITAL LETTER A WITH ACUTE
	/// </p>
	/// or as two separate characters (the "decomposed" form):
	/// <p>
	/// 0041 LATIN CAPITAL LETTER A 0301 COMBINING ACUTE ACCENT
	/// </p>
	/// To a user of your program, however, both of these sequences should be treated
	/// as the same "user-level" character "A with acute accent". When you are
	/// searching or comparing text, you must ensure that these two sequences are
	/// treated equivalently. In addition, you must handle characters with more than
	/// one accent. Sometimes the order of a character's combining accents is
	/// significant, while in other cases accent sequences in different orders are
	/// really equivalent.
	/// Similarly, the string "ffi" can be encoded as three separate letters:
	/// <p>
	/// 0066 LATIN SMALL LETTER F 0066 LATIN SMALL LETTER F 0069 LATIN SMALL LETTER I
	/// <\p>
	/// or as the single character
	/// <p>
	/// FB03 LATIN SMALL LIGATURE FFI <\p>
	/// The ffi ligature is not a distinct semantic character, and strictly speaking
	/// it shouldn't be in Unicode at all, but it was included for compatibility with
	/// existing character sets that already provided it. The Unicode standard
	/// identifies such characters by giving them "compatibility" decompositions into
	/// the corresponding semantic characters. When sorting and searching, you will
	/// often want to use these mappings.
	/// <c>normalize</c> helps solve these problems by transforming text into
	/// the canonical composed and decomposed forms as shown in the first example
	/// above. In addition, you can have it perform compatibility decompositions so
	/// that you can treat compatibility characters the same as their equivalents.
	/// Finally, <c>normalize</c> rearranges accents into the proper canonical
	/// order, so that you do not have to worry about accent rearrangement on your
	/// own.
	/// Form FCD, "Fast C or D", is also designed for collation. It allows to work on
	/// strings that are not necessarily normalized with an algorithm (like in
	/// collation) that works under "canonical closure", i.e., it treats precomposed
	/// characters and their decomposed equivalents the same.
	/// It is not a normalization form because it does not provide for uniqueness of
	/// representation. Multiple strings may be canonically equivalent (their NFDs
	/// are identical) and may all conform to FCD without being identical themselves.
	/// The form is defined such that the "raw decomposition", the recursive
	/// canonical decomposition of each character, results in a string that is
	/// canonically ordered. This means that precomposed characters are allowed for
	/// as long as their decompositions do not need canonical reordering.
	/// Its advantage for a process like collation is that all NFD and most NFC texts
	/// - and many unnormalized texts - already conform to FCD and do not need to be
	/// normalized (NFD) for such a process. The FCD quick check will return YES for
	/// most strings in practice.
	/// normalize(FCD) may be implemented with NFD.
	/// For more details on FCD see the collation design document:
	/// http://source.icu-project
	/// .org/repos/icu/icuhtml/trunk/design/collation/ICU_collation_design.htm
	/// ICU collation performs either NFD or FCD normalization automatically if
	/// normalization is turned on for the collator object. Beyond collation and
	/// string search, normalized strings may be useful for string equivalence
	/// comparisons, transliteration/transcription, unique representations, etc.
	/// The W3C generally recommends to exchange texts in NFC. Note also that most
	/// legacy character encodings use only precomposed forms and often do not encode
	/// any combining marks by themselves. For conversion to such character encodings
	/// the Unicode text needs to be normalized to NFC. For more usage examples, see
	/// the Unicode Standard Annex.
	/// </summary>
	///
	/// @stable ICU 2.8
	
	public sealed class Normalizer : ICloneable {
	
	    // -------------------------------------------------------------------------
	    // Private data
	    // -------------------------------------------------------------------------
	    private char[] buffer;
	
	    private int bufferStart;
	
	    private int bufferPos;
	
	    private int bufferLimit;
	
	    // This tells us what the bits in the "mode" object mean.
	    private const int COMPAT_BIT = 1;
	
	    private const int DECOMP_BIT = 2;
	
	    private const int COMPOSE_BIT = 4;
	
	    // The input text and our position in it
	    private UCharacterIterator text;
	
	    private Normalizer.Mode  mode;
	
	    private int options;
	
	    private int currentIndex;
	
	    private int nextIndex;
	
	    /// <summary>
	    /// Options bit set value to select Unicode 3.2 normalization (except
	    /// NormalizationCorrections). At most one Unicode version can be selected at
	    /// a time.
	    /// </summary>
	    ///
	    /// @stable ICU 2.6
	    public const int UNICODE_3_2 = 0x20;
	
	    /// <summary>
	    /// Constant indicating that the end of the iteration has been reached. This
	    /// is guaranteed to have the same value as <see cref="null"/>.
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    public const int DONE = IBM.ICU.Text.UForwardCharacterIterator_Constants.DONE;
	
	    /// <summary>
	    /// Constants for normalization modes.
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    public class Mode {
	        // private int modeValue;
	        public Mode(int value_ren) {
	            // modeValue = value;
	        }
	
	        /// <summary>
	        /// This method is used for method dispatch
	        /// </summary>
	        ///
	        /// @stable ICU 2.6
	        protected internal virtual int Normalize(char[] src, int srcStart, int srcLimit,
	                char[] dest, int destStart, int destLimit, UnicodeSet nx) {
	            int srcLen = (srcLimit - srcStart);
	            int destLen = (destLimit - destStart);
	            if (srcLen > destLen) {
	                return srcLen;
	            }
	            System.Array.Copy((Array)(src),srcStart,(Array)(dest),destStart,srcLen);
	            return srcLen;
	        }
	
	        /// <summary>
	        /// This method is used for method dispatch
	        /// </summary>
	        ///
	        /// @stable ICU 2.6
	        protected internal int Normalize(char[] src, int srcStart, int srcLimit,
	                char[] dest, int destStart, int destLimit, int options_0) {
	            return Normalize(src, srcStart, srcLimit, dest, destStart,
	                    destLimit, IBM.ICU.Impl.NormalizerImpl.GetNX(options_0));
	        }
	
	        /// <summary>
	        /// This method is used for method dispatch
	        /// </summary>
	        ///
	        /// @stable ICU 2.6
	        protected internal virtual String Normalize(String src, int options_0) {
	            return src;
	        }
	
	        /// <summary>
	        /// This method is used for method dispatch
	        /// </summary>
	        ///
	        /// @stable ICU 2.8
	        protected internal virtual int GetMinC() {
	            return -1;
	        }
	
	        /// <summary>
	        /// This method is used for method dispatch
	        /// </summary>
	        ///
	        /// @stable ICU 2.8
	        protected internal virtual int GetMask() {
	            return -1;
	        }
	
	        /// <summary>
	        /// This method is used for method dispatch
	        /// </summary>
	        ///
	        /// @stable ICU 2.8
	        protected internal virtual Normalizer.IsPrevBoundary  GetPrevBoundary() {
	            return null;
	        }
	
	        /// <summary>
	        /// This method is used for method dispatch
	        /// </summary>
	        ///
	        /// @stable ICU 2.8
	        protected internal virtual Normalizer.IsNextBoundary  GetNextBoundary() {
	            return null;
	        }
	
	        /// <summary>
	        /// This method is used for method dispatch
	        /// </summary>
	        ///
	        /// @stable ICU 2.6
	        protected internal virtual Normalizer.QuickCheckResult  QuickCheck(char[] src, int start, int limit,
	                bool allowMaybe, UnicodeSet nx) {
	            if (allowMaybe) {
	                return IBM.ICU.Text.Normalizer.MAYBE;
	            }
	            return IBM.ICU.Text.Normalizer.NO;
	        }
	
	        /// <summary>
	        /// This method is used for method dispatch
	        /// </summary>
	        ///
	        /// @stable ICU 2.8
	        protected internal virtual bool IsNFSkippable(int c) {
	            return true;
	        }
	    }
	
	    /// <summary>
	    /// No decomposition/composition.
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    public static readonly Normalizer.Mode  NONE = new Normalizer.Mode (COMPAT_BIT);
	
	    /// <summary>
	    /// Canonical decomposition.
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    public static readonly Normalizer.Mode  NFD = new Normalizer.NFDMode (DECOMP_BIT);
	
	    private sealed class NFDMode : Normalizer.Mode  {
	        public NFDMode(int value_ren) : base(value_ren) {
	        }
	
	        protected internal override int Normalize(char[] src, int srcStart, int srcLimit,
	                char[] dest, int destStart, int destLimit, UnicodeSet nx) {
	            int[] trailCC = new int[1];
	            return IBM.ICU.Impl.NormalizerImpl.Decompose(src, srcStart, srcLimit, dest,
	                    destStart, destLimit, false, trailCC, nx);
	        }
	
	        protected internal override String Normalize(String src, int options_0) {
	            return IBM.ICU.Text.Normalizer.Decompose(src, false);
	        }
	
	        protected internal override int GetMinC() {
	            return IBM.ICU.Impl.NormalizerImpl.MIN_WITH_LEAD_CC;
	        }
	
	        protected internal override Normalizer.IsPrevBoundary  GetPrevBoundary() {
	            return new Normalizer.IsPrevNFDSafe ();
	        }
	
	        protected internal override Normalizer.IsNextBoundary  GetNextBoundary() {
	            return new Normalizer.IsNextNFDSafe ();
	        }
	
	        protected internal override int GetMask() {
	            return (IBM.ICU.Impl.NormalizerImpl.CC_MASK | IBM.ICU.Impl.NormalizerImpl.QC_NFD);
	        }
	
	        protected internal override Normalizer.QuickCheckResult  QuickCheck(char[] src, int start, int limit,
	                bool allowMaybe, UnicodeSet nx) {
	            return IBM.ICU.Impl.NormalizerImpl.QuickCheck(src, start, limit, IBM.ICU.Impl.NormalizerImpl
	                    .GetFromIndexesArr(IBM.ICU.Impl.NormalizerImpl.INDEX_MIN_NFD_NO_MAYBE),
	                    IBM.ICU.Impl.NormalizerImpl.QC_NFD, 0, allowMaybe, nx);
	        }
	
	        protected internal override bool IsNFSkippable(int c) {
	            return IBM.ICU.Impl.NormalizerImpl.IsNFSkippable(c, this,
	                    (IBM.ICU.Impl.NormalizerImpl.CC_MASK | IBM.ICU.Impl.NormalizerImpl.QC_NFD));
	        }
	    }
	
	    /// <summary>
	    /// Compatibility decomposition.
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    public static readonly Normalizer.Mode  NFKD = new Normalizer.NFKDMode (3);
	
	    private sealed class NFKDMode : Normalizer.Mode  {
	        public NFKDMode(int value_ren) : base(value_ren) {
	        }
	
	        protected internal override int Normalize(char[] src, int srcStart, int srcLimit,
	                char[] dest, int destStart, int destLimit, UnicodeSet nx) {
	            int[] trailCC = new int[1];
	            return IBM.ICU.Impl.NormalizerImpl.Decompose(src, srcStart, srcLimit, dest,
	                    destStart, destLimit, true, trailCC, nx);
	        }
	
	        protected internal override String Normalize(String src, int options_0) {
	            return IBM.ICU.Text.Normalizer.Decompose(src, true);
	        }
	
	        protected internal override int GetMinC() {
	            return IBM.ICU.Impl.NormalizerImpl.MIN_WITH_LEAD_CC;
	        }
	
	        protected internal override Normalizer.IsPrevBoundary  GetPrevBoundary() {
	            return new Normalizer.IsPrevNFDSafe ();
	        }
	
	        protected internal override Normalizer.IsNextBoundary  GetNextBoundary() {
	            return new Normalizer.IsNextNFDSafe ();
	        }
	
	        protected internal override int GetMask() {
	            return (IBM.ICU.Impl.NormalizerImpl.CC_MASK | IBM.ICU.Impl.NormalizerImpl.QC_NFKD);
	        }
	
	        protected internal override Normalizer.QuickCheckResult  QuickCheck(char[] src, int start, int limit,
	                bool allowMaybe, UnicodeSet nx) {
	            return IBM.ICU.Impl.NormalizerImpl.QuickCheck(src, start, limit, IBM.ICU.Impl.NormalizerImpl
	                    .GetFromIndexesArr(IBM.ICU.Impl.NormalizerImpl.INDEX_MIN_NFKD_NO_MAYBE),
	                    IBM.ICU.Impl.NormalizerImpl.QC_NFKD, IBM.ICU.Impl.NormalizerImpl.OPTIONS_COMPAT,
	                    allowMaybe, nx);
	        }
	
	        protected internal override bool IsNFSkippable(int c) {
	            return IBM.ICU.Impl.NormalizerImpl.IsNFSkippable(c, this,
	                    (IBM.ICU.Impl.NormalizerImpl.CC_MASK | IBM.ICU.Impl.NormalizerImpl.QC_NFKD));
	        }
	    }
	
	    /// <summary>
	    /// Canonical decomposition followed by canonical composition.
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    public static readonly Normalizer.Mode  NFC = new Normalizer.NFCMode (COMPOSE_BIT);
	
	    private sealed class NFCMode : Normalizer.Mode  {
	        public NFCMode(int value_ren) : base(value_ren) {
	        }
	
	        protected internal override int Normalize(char[] src, int srcStart, int srcLimit,
	                char[] dest, int destStart, int destLimit, UnicodeSet nx) {
	            return IBM.ICU.Impl.NormalizerImpl.Compose(src, srcStart, srcLimit, dest,
	                    destStart, destLimit, 0, nx);
	        }
	
	        protected internal override String Normalize(String src, int options_0) {
	            return IBM.ICU.Text.Normalizer.Compose(src, false, options_0);
	        }
	
	        protected internal override int GetMinC() {
	            return IBM.ICU.Impl.NormalizerImpl
	                    .GetFromIndexesArr(IBM.ICU.Impl.NormalizerImpl.INDEX_MIN_NFC_NO_MAYBE);
	        }
	
	        protected internal override Normalizer.IsPrevBoundary  GetPrevBoundary() {
	            return new Normalizer.IsPrevTrueStarter ();
	        }
	
	        protected internal override Normalizer.IsNextBoundary  GetNextBoundary() {
	            return new Normalizer.IsNextTrueStarter ();
	        }
	
	        protected internal override int GetMask() {
	            return (IBM.ICU.Impl.NormalizerImpl.CC_MASK | IBM.ICU.Impl.NormalizerImpl.QC_NFC);
	        }
	
	        protected internal override Normalizer.QuickCheckResult  QuickCheck(char[] src, int start, int limit,
	                bool allowMaybe, UnicodeSet nx) {
	            return IBM.ICU.Impl.NormalizerImpl.QuickCheck(src, start, limit, IBM.ICU.Impl.NormalizerImpl
	                    .GetFromIndexesArr(IBM.ICU.Impl.NormalizerImpl.INDEX_MIN_NFC_NO_MAYBE),
	                    IBM.ICU.Impl.NormalizerImpl.QC_NFC, 0, allowMaybe, nx);
	        }
	
	        protected internal override bool IsNFSkippable(int c) {
	            return IBM.ICU.Impl.NormalizerImpl
	                    .IsNFSkippable(
	                            c,
	                            this,
	                            (IBM.ICU.Impl.NormalizerImpl.CC_MASK
	                                    | IBM.ICU.Impl.NormalizerImpl.COMBINES_ANY | (IBM.ICU.Impl.NormalizerImpl.QC_NFC & IBM.ICU.Impl.NormalizerImpl.QC_ANY_NO)));
	        }
	    }
	
	    /// <summary>
	    /// Default normalization.
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    public static readonly Normalizer.Mode  DEFAULT = NFC;
	
	    /// <summary>
	    /// Compatibility decomposition followed by canonical composition.
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    public static readonly Normalizer.Mode  NFKC = new Normalizer.NFKCMode (5);
	
	    private sealed class NFKCMode : Normalizer.Mode  {
	        public NFKCMode(int value_ren) : base(value_ren) {
	        }
	
	        protected internal override int Normalize(char[] src, int srcStart, int srcLimit,
	                char[] dest, int destStart, int destLimit, UnicodeSet nx) {
	            return IBM.ICU.Impl.NormalizerImpl.Compose(src, srcStart, srcLimit, dest,
	                    destStart, destLimit, IBM.ICU.Impl.NormalizerImpl.OPTIONS_COMPAT, nx);
	        }
	
	        protected internal override String Normalize(String src, int options_0) {
	            return IBM.ICU.Text.Normalizer.Compose(src, true, options_0);
	        }
	
	        protected internal override int GetMinC() {
	            return IBM.ICU.Impl.NormalizerImpl
	                    .GetFromIndexesArr(IBM.ICU.Impl.NormalizerImpl.INDEX_MIN_NFKC_NO_MAYBE);
	        }
	
	        protected internal override Normalizer.IsPrevBoundary  GetPrevBoundary() {
	            return new Normalizer.IsPrevTrueStarter ();
	        }
	
	        protected internal override Normalizer.IsNextBoundary  GetNextBoundary() {
	            return new Normalizer.IsNextTrueStarter ();
	        }
	
	        protected internal override int GetMask() {
	            return (IBM.ICU.Impl.NormalizerImpl.CC_MASK | IBM.ICU.Impl.NormalizerImpl.QC_NFKC);
	        }
	
	        protected internal override Normalizer.QuickCheckResult  QuickCheck(char[] src, int start, int limit,
	                bool allowMaybe, UnicodeSet nx) {
	            return IBM.ICU.Impl.NormalizerImpl.QuickCheck(src, start, limit, IBM.ICU.Impl.NormalizerImpl
	                    .GetFromIndexesArr(IBM.ICU.Impl.NormalizerImpl.INDEX_MIN_NFKC_NO_MAYBE),
	                    IBM.ICU.Impl.NormalizerImpl.QC_NFKC, IBM.ICU.Impl.NormalizerImpl.OPTIONS_COMPAT,
	                    allowMaybe, nx);
	        }
	
	        protected internal override bool IsNFSkippable(int c) {
	            return IBM.ICU.Impl.NormalizerImpl
	                    .IsNFSkippable(
	                            c,
	                            this,
	                            (IBM.ICU.Impl.NormalizerImpl.CC_MASK
	                                    | IBM.ICU.Impl.NormalizerImpl.COMBINES_ANY | (IBM.ICU.Impl.NormalizerImpl.QC_NFKC & IBM.ICU.Impl.NormalizerImpl.QC_ANY_NO)));
	        }
	    }
	
	    /// <summary>
	    /// "Fast C or D" form.
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    public static readonly Normalizer.Mode  FCD = new Normalizer.FCDMode (6);
	
	    private sealed class FCDMode : Normalizer.Mode  {
	        public FCDMode(int value_ren) : base(value_ren) {
	        }
	
	        protected internal override int Normalize(char[] src, int srcStart, int srcLimit,
	                char[] dest, int destStart, int destLimit, UnicodeSet nx) {
	            return IBM.ICU.Impl.NormalizerImpl.MakeFCD(src, srcStart, srcLimit, dest,
	                    destStart, destLimit, nx);
	        }
	
	        protected internal override String Normalize(String src, int options_0) {
	            return IBM.ICU.Text.Normalizer.MakeFCD(src, options_0);
	        }
	
	        protected internal override int GetMinC() {
	            return IBM.ICU.Impl.NormalizerImpl.MIN_WITH_LEAD_CC;
	        }
	
	        protected internal override Normalizer.IsPrevBoundary  GetPrevBoundary() {
	            return new Normalizer.IsPrevNFDSafe ();
	        }
	
	        protected internal override Normalizer.IsNextBoundary  GetNextBoundary() {
	            return new Normalizer.IsNextNFDSafe ();
	        }
	
	        protected internal override int GetMask() {
	            return IBM.ICU.Impl.NormalizerImpl.CC_MASK | IBM.ICU.Impl.NormalizerImpl.QC_NFD;
	        }
	
	        protected internal override Normalizer.QuickCheckResult  QuickCheck(char[] src, int start, int limit,
	                bool allowMaybe, UnicodeSet nx) {
	            return (IBM.ICU.Impl.NormalizerImpl.CheckFCD(src, start, limit, nx)) ? IBM.ICU.Text.Normalizer.YES : IBM.ICU.Text.Normalizer.NO;
	        }
	
	        protected internal override bool IsNFSkippable(int c) {
	            /* FCD: skippable if lead cc==0 and trail cc<=1 */
	            return (IBM.ICU.Impl.NormalizerImpl.GetFCD16(c) > 1);
	        }
	    }
	
	    /// <summary>
	    /// Null operation for use with the <see cref="M:IBM.ICU.Text.Normalizer.Normalizer constructors"/> and the
	    /// static <see cref="M:IBM.ICU.Text.Normalizer.Normalize normalize"/> method. This value tells the
	    /// <tt>Normalizer</tt> to do nothing but return unprocessed characters from
	    /// the underlying String or CharacterIterator. If you have code which
	    /// requires raw text at some times and normalized text at others, you can
	    /// use <tt>NO_OP</tt> for the cases where you want raw text, rather than
	    /// having a separate code path that bypasses <tt>Normalizer</tt> altogether.
	    /// <p>
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.Normalizer.SetMode(null)"/>
	    /// <seealso cref="F:IBM.ICU.Text.Normalizer.NONE"/>
	    public static readonly Normalizer.Mode  NO_OP = NONE;
	
	    /// <summary>
	    /// Canonical decomposition followed by canonical composition. Used with the<see cref="M:IBM.ICU.Text.Normalizer.Normalizer constructors"/> and the static <see cref="M:IBM.ICU.Text.Normalizer.Normalizenormalize"/> method to determine the operation to be performed.
	    /// <p>
	    /// If all optional features (<i>e.g.</i> <see cref="F:IBM.ICU.Text.Normalizer.IGNORE_HANGUL"/>) are turned
	    /// off, this operation produces output that is in <a
	    /// href=http://www.unicode.org/unicode/reports/tr15/>Unicode Canonical
	    /// Form</a> <b>C</b>.
	    /// <p>
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.Normalizer.SetMode(null)"/>
	    /// <seealso cref="F:IBM.ICU.Text.Normalizer.NFC"/>
	    public static readonly Normalizer.Mode  COMPOSE = NFC;
	
	    /// <summary>
	    /// Compatibility decomposition followed by canonical composition. Used with
	    /// the <see cref="M:IBM.ICU.Text.Normalizer.Normalizer constructors"/> and the static <see cref="M:IBM.ICU.Text.Normalizer.Normalizenormalize"/> method to determine the operation to be performed.
	    /// <p>
	    /// If all optional features (<i>e.g.</i> <see cref="F:IBM.ICU.Text.Normalizer.IGNORE_HANGUL"/>) are turned
	    /// off, this operation produces output that is in <a
	    /// href=http://www.unicode.org/unicode/reports/tr15/>Unicode Canonical
	    /// Form</a> <b>KC</b>.
	    /// <p>
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.Normalizer.SetMode(null)"/>
	    /// <seealso cref="F:IBM.ICU.Text.Normalizer.NFKC"/>
	    public static readonly Normalizer.Mode  COMPOSE_COMPAT = NFKC;
	
	    /// <summary>
	    /// Canonical decomposition. This value is passed to the <see cref="M:IBM.ICU.Text.Normalizer.Normalizerconstructors"/> and the static <see cref="M:IBM.ICU.Text.Normalizer.Normalize normalize"/> method to
	    /// determine the operation to be performed.
	    /// <p>
	    /// If all optional features (<i>e.g.</i> <see cref="F:IBM.ICU.Text.Normalizer.IGNORE_HANGUL"/>) are turned
	    /// off, this operation produces output that is in <a
	    /// href=http://www.unicode.org/unicode/reports/tr15/>Unicode Canonical
	    /// Form</a> <b>D</b>.
	    /// <p>
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.Normalizer.SetMode(null)"/>
	    /// <seealso cref="F:IBM.ICU.Text.Normalizer.NFD"/>
	    public static readonly Normalizer.Mode  DECOMP = NFD;
	
	    /// <summary>
	    /// Compatibility decomposition. This value is passed to the<see cref="M:IBM.ICU.Text.Normalizer.Normalizer constructors"/> and the static <see cref="M:IBM.ICU.Text.Normalizer.Normalizenormalize"/> method to determine the operation to be performed.
	    /// <p>
	    /// If all optional features (<i>e.g.</i> <see cref="F:IBM.ICU.Text.Normalizer.IGNORE_HANGUL"/>) are turned
	    /// off, this operation produces output that is in <a
	    /// href=http://www.unicode.org/unicode/reports/tr15/>Unicode Canonical
	    /// Form</a> <b>KD</b>.
	    /// <p>
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.Normalizer.SetMode(null)"/>
	    /// <seealso cref="F:IBM.ICU.Text.Normalizer.NFKD"/>
	    public static readonly Normalizer.Mode  DECOMP_COMPAT = NFKD;
	
	    /// <summary>
	    /// Option to disable Hangul/Jamo composition and decomposition. This option
	    /// applies to Korean text, which can be represented either in the Jamo
	    /// alphabet or in Hangul characters, which are really just two or three Jamo
	    /// combined into one visual glyph. Since Jamo takes up more storage space
	    /// than Hangul, applications that process only Hangul text may wish to turn
	    /// this option on when decomposing text.
	    /// <p>
	    /// The Unicode standard treates Hangul to Jamo conversion as a canonical
	    /// decomposition, so this option must be turned <b>off</b> if you wish to
	    /// transform strings into one of the standard <a
	    /// href="http://www.unicode.org/unicode/reports/tr15/" target="unicode">
	    /// Unicode Normalization Forms</a>.
	    /// <p>
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.Normalizer.SetOption(System.Int32, System.Boolean)"/>
	    public const int IGNORE_HANGUL = 0x0001;
	
	    /// <summary>
	    /// Result values for quickCheck(). For details see Unicode Technical Report
	    /// 15.
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    public sealed class QuickCheckResult {
	        // private int resultValue;
	        public QuickCheckResult(int value_ren) {
	            // resultValue=value;
	        }
	    }
	
	    /// <summary>
	    /// Indicates that string is not in the normalized format
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    public static readonly Normalizer.QuickCheckResult  NO = new Normalizer.QuickCheckResult (0);
	
	    /// <summary>
	    /// Indicates that string is in the normalized format
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    public static readonly Normalizer.QuickCheckResult  YES = new Normalizer.QuickCheckResult (1);
	
	    /// <summary>
	    /// Indicates it cannot be determined if string is in the normalized format
	    /// without further thorough checks.
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    public static readonly Normalizer.QuickCheckResult  MAYBE = new Normalizer.QuickCheckResult (2);
	
	    /// <summary>
	    /// Option bit for compare: Case sensitively compare the strings
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    public const int FOLD_CASE_DEFAULT = IBM.ICU.Lang.UCharacter.FOLD_CASE_DEFAULT;
	
	    /// <summary>
	    /// Option bit for compare: Both input strings are assumed to fulfill FCD
	    /// conditions.
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    public const int INPUT_IS_FCD = 0x20000;
	
	    /// <summary>
	    /// Option bit for compare: Perform case-insensitive comparison.
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    public const int COMPARE_IGNORE_CASE = 0x10000;
	
	    /// <summary>
	    /// Option bit for compare: Compare strings in code point order instead of
	    /// code unit order.
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    public const int COMPARE_CODE_POINT_ORDER = 0x8000;
	
	    /// <summary>
	    /// Option value for case folding: exclude the mappings for dotted I and
	    /// dotless i marked with 'I' in CaseFolding.txt.
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    public const int FOLD_CASE_EXCLUDE_SPECIAL_I = IBM.ICU.Lang.UCharacter.FOLD_CASE_EXCLUDE_SPECIAL_I;
	
	    /// <summary>
	    /// Lowest-order bit number of compare() options bits corresponding to
	    /// normalization options bits.
	    /// The options parameter for compare() uses most bits for itself and for
	    /// various comparison and folding flags. The most significant bits, however,
	    /// are shifted down and passed on to the normalization implementation. (That
	    /// is, from compare(..., options, ...), options>>COMPARE_NORM_OPTIONS_SHIFT
	    /// will be passed on to the internal normalization functions.)
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.Normalizer.Compare(null, System.Int32, System.Int32, null, System.Int32, System.Int32, System.Int32)"/>
	    /// @stable ICU 2.6
	    public const int COMPARE_NORM_OPTIONS_SHIFT = 20;
	
	    // -------------------------------------------------------------------------
	    // Constructors
	    // -------------------------------------------------------------------------
	
	    /// <summary>
	    /// Creates a new <tt>Normalizer</tt> object for iterating over the
	    /// normalized form of a given string.
	    /// <p>
	    /// The <tt>options</tt> parameter specifies which optional
	    /// <tt>Normalizer</tt> features are to be enabled for this object.
	    /// <p>
	    /// </summary>
	    ///
	    /// <param name="str">The string to be normalized. The normalization will start atthe beginning of the string.</param>
	    /// <param name="mode_0">The normalization mode.</param>
	    /// <param name="opt">Any optional features to be enabled. Currently the onlyavailable option is <see cref="F:IBM.ICU.Text.Normalizer.UNICODE_3_2"/>. If you want thedefault behavior corresponding to one of the standard UnicodeNormalization Forms, use 0 for this argument.</param>
	    /// @stable ICU 2.6
	    public Normalizer(String str, Normalizer.Mode  mode_0, int opt) {
	        this.buffer = new char[100];
	        this.bufferStart = 0;
	        this.bufferPos = 0;
	        this.bufferLimit = 0;
	        this.mode = NFC;
	        this.options = 0;
	        this.text = IBM.ICU.Text.UCharacterIterator.GetInstance(str);
	        this.mode = mode_0;
	        this.options = opt;
	    }
	
	    /// <summary>
	    /// Creates a new <tt>Normalizer</tt> object for iterating over the
	    /// normalized form of the given text.
	    /// <p>
	    /// </summary>
	    ///
	    /// <param name="iter">The input text to be normalized. The normalization will startat the beginning of the string.</param>
	    /// <param name="mode_0">The normalization mode.</param>
	    /// <param name="opt">Any optional features to be enabled. Currently the onlyavailable option is <see cref="F:IBM.ICU.Text.Normalizer.UNICODE_3_2"/>. If you want thedefault behavior corresponding to one of the standard UnicodeNormalization Forms, use 0 for this argument.</param>
	    /// @stable ICU 2.6
	    public Normalizer(ICharacterIterator iter, Normalizer.Mode  mode_0, int opt) {
	        this.buffer = new char[100];
	        this.bufferStart = 0;
	        this.bufferPos = 0;
	        this.bufferLimit = 0;
	        this.mode = NFC;
	        this.options = 0;
	        this.text = IBM.ICU.Text.UCharacterIterator.GetInstance((ICharacterIterator) iter);
	        this.mode = mode_0;
	        this.options = opt;
	    }
	
	    /// <summary>
	    /// Creates a new <tt>Normalizer</tt> object for iterating over the
	    /// normalized form of the given text.
	    /// <p>
	    /// </summary>
	    ///
	    /// <param name="iter">The input text to be normalized. The normalization will startat the beginning of the string.</param>
	    /// <param name="mode_0">The normalization mode.</param>
	    /// <param name="options_1">The normalization options, ORed together (0 for no options).</param>
	    /// @stable ICU 2.6
	    public Normalizer(UCharacterIterator iter, Normalizer.Mode  mode_0, int options_1) {
	        this.buffer = new char[100];
	        this.bufferStart = 0;
	        this.bufferPos = 0;
	        this.bufferLimit = 0;
	        this.mode = NFC;
	        this.options = 0;
	        try {
	            this.text = (UCharacterIterator) iter.Clone();
	            this.mode = mode_0;
	            this.options = options_1;
	        } catch (Exception e) {
	            throw new InvalidOperationException(e.ToString());
	        }
	    }
	
	    /// <summary>
	    /// Clones this <tt>Normalizer</tt> object. All properties of this object are
	    /// duplicated in the new object, including the cloning of any<see cref="null"/> that was passed in to the constructor or to<see cref="M:IBM.ICU.Text.Normalizer.SetText(null)"/>. However, the text storage
	    /// underlying the <tt>CharacterIterator</tt> is not duplicated unless the
	    /// iterator's <tt>clone</tt> method does so.
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    public Object Clone() {
	        try {
	            Normalizer copy = (Normalizer) base.MemberwiseClone();
	            copy.text = (UCharacterIterator) text.Clone();
	            // clone the internal buffer
	            if (buffer != null) {
	                copy.buffer = new char[buffer.Length];
	                System.Array.Copy((Array)(buffer),0,(Array)(copy.buffer),0,buffer.Length);
	            }
	            return copy;
	        } catch (Exception e) {
	            throw new InvalidOperationException(e.ToString());
	        }
	    }
	
	    // --------------------------------------------------------------------------
	    // Static Utility methods
	    // --------------------------------------------------------------------------
	
	    /// <summary>
	    /// Compose a string. The string will be composed to according the the
	    /// specified mode.
	    /// </summary>
	    ///
	    /// <param name="str">The string to compose.</param>
	    /// <param name="compat">If true the string will be composed accoding to NFKC rules andif false will be composed according to NFC rules.</param>
	    /// <returns>String The composed string</returns>
	    /// @stable ICU 2.8
	    public static String Compose(String str, bool compat) {
	        return Compose(str, compat, 0);
	    }
	
	    /// <summary>
	    /// Compose a string. The string will be composed to according the the
	    /// specified mode.
	    /// </summary>
	    ///
	    /// <param name="str">The string to compose.</param>
	    /// <param name="compat">If true the string will be composed accoding to NFKC rules andif false will be composed according to NFC rules.</param>
	    /// <param name="options_0">The only recognized option is UNICODE_3_2</param>
	    /// <returns>String The composed string</returns>
	    /// @stable ICU 2.6
	    public static String Compose(String str, bool compat, int options_0) {
	
	        char[] dest = new char[str.Length * MAX_BUF_SIZE_COMPOSE];
	        int destSize = 0;
	        char[] src = str.ToCharArray();
	        UnicodeSet nx = IBM.ICU.Impl.NormalizerImpl.GetNX(options_0);
	
	        /* reset options bits that should only be set here or inside compose() */
	        options_0 &= ~(IBM.ICU.Impl.NormalizerImpl.OPTIONS_SETS_MASK
	                | IBM.ICU.Impl.NormalizerImpl.OPTIONS_COMPAT | IBM.ICU.Impl.NormalizerImpl.OPTIONS_COMPOSE_CONTIGUOUS);
	
	        if (compat) {
	            options_0 |= IBM.ICU.Impl.NormalizerImpl.OPTIONS_COMPAT;
	        }
	
	        for (;;) {
	            destSize = IBM.ICU.Impl.NormalizerImpl.Compose(src, 0, src.Length, dest, 0,
	                    dest.Length, options_0, nx);
	            if (destSize <= dest.Length) {
	                return new String(dest, 0, destSize);
	            } else {
	                dest = new char[destSize];
	            }
	        }
	    }
	
	    /// <summary>
	    /// Compose a string. The string will be composed to according the the
	    /// specified mode.
	    /// </summary>
	    ///
	    /// <param name="source">The char array to compose.</param>
	    /// <param name="target">A char buffer to receive the normalized text.</param>
	    /// <param name="compat">If true the char array will be composed accoding to NFKC rulesand if false will be composed according to NFC rules.</param>
	    /// <param name="options_0">The normalization options, ORed together (0 for no options).</param>
	    /// <returns>int The total buffer size needed;if greater than length of
	    /// result, the output was truncated.</returns>
	    /// <exception cref="IndexOutOfBoundsException">if target.length is less than the required length</exception>
	    /// @stable ICU 2.6
	    public static int Compose(char[] source, char[] target, bool compat,
	            int options_0) {
	        UnicodeSet nx = IBM.ICU.Impl.NormalizerImpl.GetNX(options_0);
	
	        /* reset options bits that should only be set here or inside compose() */
	        options_0 &= ~(IBM.ICU.Impl.NormalizerImpl.OPTIONS_SETS_MASK
	                | IBM.ICU.Impl.NormalizerImpl.OPTIONS_COMPAT | IBM.ICU.Impl.NormalizerImpl.OPTIONS_COMPOSE_CONTIGUOUS);
	
	        if (compat) {
	            options_0 |= IBM.ICU.Impl.NormalizerImpl.OPTIONS_COMPAT;
	        }
	
	        int length = IBM.ICU.Impl.NormalizerImpl.Compose(source, 0, source.Length, target,
	                0, target.Length, options_0, nx);
	        if (length <= target.Length) {
	            return length;
	        } else {
	            throw new IndexOutOfRangeException(ILOG.J2CsMapping.Util.IlNumber.ToString(length).ToString());
	        }
	    }
	
	    /// <summary>
	    /// Compose a string. The string will be composed to according the the
	    /// specified mode.
	    /// </summary>
	    ///
	    /// <param name="src">The char array to compose.</param>
	    /// <param name="srcStart">Start index of the source</param>
	    /// <param name="srcLimit">Limit index of the source</param>
	    /// <param name="dest">The char buffer to fill in</param>
	    /// <param name="destStart">Start index of the destination buffer</param>
	    /// <param name="destLimit">End index of the destination buffer</param>
	    /// <param name="compat">If true the char array will be composed accoding to NFKC rulesand if false will be composed according to NFC rules.</param>
	    /// <param name="options_0">The normalization options, ORed together (0 for no options).</param>
	    /// <returns>int The total buffer size needed;if greater than length of
	    /// result, the output was truncated.</returns>
	    /// <exception cref="IndexOutOfBoundsException">if target.length is less than the required length</exception>
	    /// @stable ICU 2.6
	    public static int Compose(char[] src, int srcStart, int srcLimit,
	            char[] dest, int destStart, int destLimit, bool compat,
	            int options_0) {
	        UnicodeSet nx = IBM.ICU.Impl.NormalizerImpl.GetNX(options_0);
	
	        /* reset options bits that should only be set here or inside compose() */
	        options_0 &= ~(IBM.ICU.Impl.NormalizerImpl.OPTIONS_SETS_MASK
	                | IBM.ICU.Impl.NormalizerImpl.OPTIONS_COMPAT | IBM.ICU.Impl.NormalizerImpl.OPTIONS_COMPOSE_CONTIGUOUS);
	
	        if (compat) {
	            options_0 |= IBM.ICU.Impl.NormalizerImpl.OPTIONS_COMPAT;
	        }
	
	        int length = IBM.ICU.Impl.NormalizerImpl.Compose(src, srcStart, srcLimit, dest,
	                destStart, destLimit, options_0, nx);
	        if (length <= (destLimit - destStart)) {
	            return length;
	        } else {
	            throw new IndexOutOfRangeException(ILOG.J2CsMapping.Util.IlNumber.ToString(length).ToString());
	        }
	    }
	
	    private const int MAX_BUF_SIZE_COMPOSE = 2;
	
	    private const int MAX_BUF_SIZE_DECOMPOSE = 3;
	
	    /// <summary>
	    /// Decompose a string. The string will be decomposed to according the the
	    /// specified mode.
	    /// </summary>
	    ///
	    /// <param name="str">The string to decompose.</param>
	    /// <param name="compat">If true the string will be decomposed accoding to NFKD rulesand if false will be decomposed according to NFD rules.</param>
	    /// <returns>String The decomposed string</returns>
	    /// @stable ICU 2.8
	    public static String Decompose(String str, bool compat) {
	        return Decompose(str, compat, 0);
	    }
	
	    /// <summary>
	    /// Decompose a string. The string will be decomposed to according the the
	    /// specified mode.
	    /// </summary>
	    ///
	    /// <param name="str">The string to decompose.</param>
	    /// <param name="compat">If true the string will be decomposed accoding to NFKD rulesand if false will be decomposed according to NFD rules.</param>
	    /// <param name="options_0">The normalization options, ORed together (0 for no options).</param>
	    /// <returns>String The decomposed string</returns>
	    /// @stable ICU 2.6
	    public static String Decompose(String str, bool compat, int options_0) {
	
	        char[] dest = new char[str.Length * MAX_BUF_SIZE_DECOMPOSE];
	        int[] trailCC = new int[1];
	        int destSize = 0;
	        UnicodeSet nx = IBM.ICU.Impl.NormalizerImpl.GetNX(options_0);
	        for (;;) {
	            destSize = IBM.ICU.Impl.NormalizerImpl.Decompose(str.ToCharArray(), 0,
	                    str.Length, dest, 0, dest.Length, compat, trailCC, nx);
	            if (destSize <= dest.Length) {
	                return new String(dest, 0, destSize);
	            } else {
	                dest = new char[destSize];
	            }
	        }
	
	    }
	
	    /// <summary>
	    /// Decompose a string. The string will be decomposed to according the the
	    /// specified mode.
	    /// </summary>
	    ///
	    /// <param name="source">The char array to decompose.</param>
	    /// <param name="target">A char buffer to receive the normalized text.</param>
	    /// <param name="compat">If true the char array will be decomposed accoding to NFKDrules and if false will be decomposed according to NFD rules.</param>
	    /// <returns>int The total buffer size needed;if greater than length of
	    /// result,the output was truncated.</returns>
	    /// <param name="options_0">The normalization options, ORed together (0 for no options).</param>
	    /// <exception cref="IndexOutOfBoundsException">if the target capacity is less than the required length</exception>
	    /// @stable ICU 2.6
	    public static int Decompose(char[] source, char[] target, bool compat,
	            int options_0) {
	        int[] trailCC = new int[1];
	        UnicodeSet nx = IBM.ICU.Impl.NormalizerImpl.GetNX(options_0);
	        int length = IBM.ICU.Impl.NormalizerImpl.Decompose(source, 0, source.Length, target,
	                0, target.Length, compat, trailCC, nx);
	        if (length <= target.Length) {
	            return length;
	        } else {
	            throw new IndexOutOfRangeException(ILOG.J2CsMapping.Util.IlNumber.ToString(length).ToString());
	        }
	    }
	
	    /// <summary>
	    /// Decompose a string. The string will be decomposed to according the the
	    /// specified mode.
	    /// </summary>
	    ///
	    /// <param name="src">The char array to compose.</param>
	    /// <param name="srcStart">Start index of the source</param>
	    /// <param name="srcLimit">Limit index of the source</param>
	    /// <param name="dest">The char buffer to fill in</param>
	    /// <param name="destStart">Start index of the destination buffer</param>
	    /// <param name="destLimit">End index of the destination buffer</param>
	    /// <param name="compat">If true the char array will be decomposed accoding to NFKDrules and if false will be decomposed according to NFD rules.</param>
	    /// <param name="options_0">The normalization options, ORed together (0 for no options).</param>
	    /// <returns>int The total buffer size needed;if greater than length of
	    /// result,the output was truncated.</returns>
	    /// <exception cref="IndexOutOfBoundsException">if the target capacity is less than the required length</exception>
	    /// @stable ICU 2.6
	    public static int Decompose(char[] src, int srcStart, int srcLimit,
	            char[] dest, int destStart, int destLimit, bool compat,
	            int options_0) {
	        int[] trailCC = new int[1];
	        UnicodeSet nx = IBM.ICU.Impl.NormalizerImpl.GetNX(options_0);
	        int length = IBM.ICU.Impl.NormalizerImpl.Decompose(src, srcStart, srcLimit, dest,
	                destStart, destLimit, compat, trailCC, nx);
	        if (length <= (destLimit - destStart)) {
	            return length;
	        } else {
	            throw new IndexOutOfRangeException(ILOG.J2CsMapping.Util.IlNumber.ToString(length).ToString());
	        }
	    }
	
	    private static String MakeFCD(String src, int options_0) {
	        int srcLen = src.Length;
	        char[] dest = new char[MAX_BUF_SIZE_DECOMPOSE * srcLen];
	        int length = 0;
	        UnicodeSet nx = IBM.ICU.Impl.NormalizerImpl.GetNX(options_0);
	        for (;;) {
	            length = IBM.ICU.Impl.NormalizerImpl.MakeFCD(src.ToCharArray(), 0, srcLen, dest,
	                    0, dest.Length, nx);
	            if (length <= dest.Length) {
	                return new String(dest, 0, length);
	            } else {
	                dest = new char[length];
	            }
	        }
	    }
	
	    /// <summary>
	    /// Normalizes a <tt>String</tt> using the given normalization operation.
	    /// <p>
	    /// The <tt>options</tt> parameter specifies which optional
	    /// <tt>Normalizer</tt> features are to be enabled for this operation.
	    /// Currently the only available option is <see cref="F:IBM.ICU.Text.Normalizer.UNICODE_3_2"/>. If you want
	    /// the default behavior corresponding to one of the standard Unicode
	    /// Normalization Forms, use 0 for this argument.
	    /// <p>
	    /// </summary>
	    ///
	    /// <param name="str">the input string to be normalized.</param>
	    /// <param name="mode_0">the normalization mode</param>
	    /// <param name="options_1">the optional features to be enabled.</param>
	    /// <returns>String the normalized string</returns>
	    /// @stable ICU 2.6
	    public static String Normalize(String str, Normalizer.Mode  mode_0, int options_1) {
	        return mode_0.Normalize(str, options_1);
	    }
	
	    /// <summary>
	    /// Normalize a string. The string will be normalized according the the
	    /// specified normalization mode and options.
	    /// </summary>
	    ///
	    /// <param name="src">The string to normalize.</param>
	    /// <param name="mode_0">The normalization mode; one of Normalizer.NONE,Normalizer.NFD, Normalizer.NFC, Normalizer.NFKC,Normalizer.NFKD, Normalizer.DEFAULT</param>
	    /// <returns>the normalized string</returns>
	    /// @stable ICU 2.8
	    public static String Normalize(String src, Normalizer.Mode  mode_0) {
	        return Normalize(src, mode_0, 0);
	    }
	
	    /// <summary>
	    /// Normalize a string. The string will be normalized according the the
	    /// specified normalization mode and options.
	    /// </summary>
	    ///
	    /// <param name="source">The char array to normalize.</param>
	    /// <param name="target">A char buffer to receive the normalized text.</param>
	    /// <param name="mode_0">The normalization mode; one of Normalizer.NONE,Normalizer.NFD, Normalizer.NFC, Normalizer.NFKC,Normalizer.NFKD, Normalizer.DEFAULT</param>
	    /// <param name="options_1">The normalization options, ORed together (0 for no options).</param>
	    /// <returns>int The total buffer size needed;if greater than length of
	    /// result, the output was truncated.</returns>
	    /// <exception cref="IndexOutOfBoundsException">if the target capacity is less than the required length</exception>
	    /// @stable ICU 2.6
	    public static int Normalize(char[] source, char[] target, Normalizer.Mode  mode_0,
	            int options_1) {
	        int length = Normalize(source, 0, source.Length, target, 0,
	                target.Length, mode_0, options_1);
	        if (length <= target.Length) {
	            return length;
	        } else {
	            throw new IndexOutOfRangeException(ILOG.J2CsMapping.Util.IlNumber.ToString(length).ToString());
	        }
	    }
	
	    /// <summary>
	    /// Normalize a string. The string will be normalized according the the
	    /// specified normalization mode and options.
	    /// </summary>
	    ///
	    /// <param name="src">The char array to compose.</param>
	    /// <param name="srcStart">Start index of the source</param>
	    /// <param name="srcLimit">Limit index of the source</param>
	    /// <param name="dest">The char buffer to fill in</param>
	    /// <param name="destStart">Start index of the destination buffer</param>
	    /// <param name="destLimit">End index of the destination buffer</param>
	    /// <param name="mode_0">The normalization mode; one of Normalizer.NONE,Normalizer.NFD, Normalizer.NFC, Normalizer.NFKC,Normalizer.NFKD, Normalizer.DEFAULT</param>
	    /// <param name="options_1">The normalization options, ORed together (0 for no options).</param>
	    /// <returns>int The total buffer size needed;if greater than length of
	    /// result, the output was truncated.</returns>
	    /// <exception cref="IndexOutOfBoundsException">if the target capacity is less than the required length</exception>
	    /// @stable ICU 2.6
	    public static int Normalize(char[] src, int srcStart, int srcLimit,
	            char[] dest, int destStart, int destLimit, Normalizer.Mode  mode_0, int options_1) {
	        int length = mode_0.Normalize(src, srcStart, srcLimit, dest, destStart,
	                destLimit, options_1);
	
	        if (length <= (destLimit - destStart)) {
	            return length;
	        } else {
	            throw new IndexOutOfRangeException(ILOG.J2CsMapping.Util.IlNumber.ToString(length).ToString());
	        }
	    }
	
	    /// <summary>
	    /// Normalize a codepoint accoding to the given mode
	    /// </summary>
	    ///
	    /// <param name="char32">The input string to be normalized.</param>
	    /// <param name="mode_0">The normalization mode</param>
	    /// <param name="options_1">Options for use with exclusion set an tailored NormalizationThe only option that is currently recognized is UNICODE_3_2</param>
	    /// <returns>String The normalized string</returns>
	    /// @stable ICU 2.6
	    /// <seealso cref="F:IBM.ICU.Text.Normalizer.UNICODE_3_2"/>
	    // TODO: actually do the optimization when the guts of Normalizer are
	    // upgraded --has just dumb implementation for now
	    public static String Normalize(int char32, Normalizer.Mode  mode_0, int options_1) {
	        return Normalize(IBM.ICU.Text.UTF16.ValueOf(char32), mode_0, options_1);
	    }
	
	    /// <summary>
	    /// Conveinience method to normalize a codepoint accoding to the given mode
	    /// </summary>
	    ///
	    /// <param name="char32">The input string to be normalized.</param>
	    /// <param name="mode_0">The normalization mode</param>
	    /// <returns>String The normalized string</returns>
	    /// <seealso cref="F:IBM.ICU.Text.Normalizer.UNICODE_3_2"/>
	    /// @stable ICU 2.6
	    // TODO: actually do the optimization when the guts of Normalizer are
	    // upgraded --has just dumb implementation for now
	    public static String Normalize(int char32, Normalizer.Mode  mode_0) {
	        return Normalize(IBM.ICU.Text.UTF16.ValueOf(char32), mode_0, 0);
	    }
	
	    /// <summary>
	    /// Convenience method.
	    /// </summary>
	    ///
	    /// <param name="source">string for determining if it is in a normalized format</param>
	    /// <param name="mode_0">normalization format (Normalizer.NFC,Normalizer.NFD,Normalizer.NFKC,Normalizer.NFKD)</param>
	    /// <returns>Return code to specify if the text is normalized or not
	    /// (Normalizer.YES, Normalizer.NO or Normalizer.MAYBE)</returns>
	    /// @stable ICU 2.8
	    public static Normalizer.QuickCheckResult  QuickCheck(String source, Normalizer.Mode  mode_0) {
	        return mode_0.QuickCheck(source.ToCharArray(), 0, source.Length, true,
	                null);
	    }
	
	    /// <summary>
	    /// Convenience method.
	    /// </summary>
	    ///
	    /// <param name="source">string for determining if it is in a normalized format</param>
	    /// <param name="mode_0">normalization format (Normalizer.NFC,Normalizer.NFD,Normalizer.NFKC,Normalizer.NFKD)</param>
	    /// <param name="options_1">Options for use with exclusion set an tailored NormalizationThe only option that is currently recognized is UNICODE_3_2</param>
	    /// <returns>Return code to specify if the text is normalized or not
	    /// (Normalizer.YES, Normalizer.NO or Normalizer.MAYBE)</returns>
	    /// @stable ICU 2.6
	    public static Normalizer.QuickCheckResult  QuickCheck(String source, Normalizer.Mode  mode_0,
	            int options_1) {
	        return mode_0.QuickCheck(source.ToCharArray(), 0, source.Length, true,
	                IBM.ICU.Impl.NormalizerImpl.GetNX(options_1));
	    }
	
	    /// <summary>
	    /// Convenience method.
	    /// </summary>
	    ///
	    /// <param name="source">Array of characters for determining if it is in a normalizedformat</param>
	    /// <param name="mode_0">normalization format (Normalizer.NFC,Normalizer.NFD,Normalizer.NFKC,Normalizer.NFKD)</param>
	    /// <param name="options_1">Options for use with exclusion set an tailored NormalizationThe only option that is currently recognized is UNICODE_3_2</param>
	    /// <returns>Return code to specify if the text is normalized or not
	    /// (Normalizer.YES, Normalizer.NO or Normalizer.MAYBE)</returns>
	    /// @stable ICU 2.6
	    public static Normalizer.QuickCheckResult  QuickCheck(char[] source, Normalizer.Mode  mode_0,
	            int options_1) {
	        return mode_0.QuickCheck(source, 0, source.Length, true,
	                IBM.ICU.Impl.NormalizerImpl.GetNX(options_1));
	    }
	
	    /// <summary>
	    /// Performing quick check on a string, to quickly determine if the string is
	    /// in a particular normalization format. Three types of result can be
	    /// returned Normalizer.YES, Normalizer.NO or Normalizer.MAYBE. Result
	    /// Normalizer.YES indicates that the argument string is in the desired
	    /// normalized format, Normalizer.NO determines that argument string is not
	    /// in the desired normalized format. A Normalizer.MAYBE result indicates
	    /// that a more thorough check is required, the user may have to put the
	    /// string in its normalized form and compare the results.
	    /// </summary>
	    ///
	    /// <param name="source">string for determining if it is in a normalized format</param>
	    /// <param name="start">the start index of the source</param>
	    /// <param name="limit">the limit index of the source it is equal to the length</param>
	    /// <param name="mode_0">normalization format (Normalizer.NFC,Normalizer.NFD,Normalizer.NFKC,Normalizer.NFKD)</param>
	    /// <param name="options_1">Options for use with exclusion set an tailored NormalizationThe only option that is currently recognized is UNICODE_3_2</param>
	    /// <returns>Return code to specify if the text is normalized or not
	    /// (Normalizer.YES, Normalizer.NO or Normalizer.MAYBE)</returns>
	    /// @stable ICU 2.6
	
	    public static Normalizer.QuickCheckResult  QuickCheck(char[] source, int start,
	            int limit, Normalizer.Mode  mode_0, int options_1) {
	        return mode_0.QuickCheck(source, start, limit, true,
	                IBM.ICU.Impl.NormalizerImpl.GetNX(options_1));
	    }
	
	    // -------------------------------------------------------------------------
	    // Internal methods (for now)
	    // -------------------------------------------------------------------------
	
	    /// <summary>
	    /// Test if a string is in a given normalization form. This is semantically
	    /// equivalent to source.equals(normalize(source, mode)).
	    /// Unlike quickCheck(), this function returns a definitive result, never a
	    /// "maybe". For NFD, NFKD, and FCD, both functions work exactly the same.
	    /// For NFC and NFKC where quickCheck may return "maybe", this function will
	    /// perform further tests to arrive at a true/false result.
	    /// </summary>
	    ///
	    /// <param name="src">The input array of characters to be checked to see if it isnormalized</param>
	    /// <param name="start">The strart index in the source</param>
	    /// <param name="limit">The limit index in the source</param>
	    /// <param name="mode_0">the normalization mode</param>
	    /// <param name="options_1">Options for use with exclusion set an tailored NormalizationThe only option that is currently recognized is UNICODE_3_2</param>
	    /// <returns>Boolean value indicating whether the source string is in the
	    /// "mode" normalization form</returns>
	    /// @stable ICU 2.6
	    public static bool IsNormalized(char[] src, int start, int limit,
	            Normalizer.Mode  mode_0, int options_1) {
	        return (mode_0.QuickCheck(src, start, limit, false,
	                IBM.ICU.Impl.NormalizerImpl.GetNX(options_1)) == YES);
	    }
	
	    /// <summary>
	    /// Convenience Method
	    /// </summary>
	    ///
	    /// <param name="str">the input string to be checked to see if it is normalized</param>
	    /// <param name="mode_0">the normalization mode</param>
	    /// <param name="options_1">Options for use with exclusion set an tailored NormalizationThe only option that is currently recognized is UNICODE_3_2</param>
	    /// <seealso cref="M:IBM.ICU.Text.Normalizer.IsNormalized(null, System.Int32, System.Int32, null, System.Int32)"/>
	    /// @stable ICU 2.6
	    public static bool IsNormalized(String str, Normalizer.Mode  mode_0, int options_1) {
	        return (mode_0.QuickCheck(str.ToCharArray(), 0, str.Length, false,
	                IBM.ICU.Impl.NormalizerImpl.GetNX(options_1)) == YES);
	    }
	
	    /// <summary>
	    /// Convenience Method
	    /// </summary>
	    ///
	    /// <param name="char32">the input code point to be checked to see if it is normalized</param>
	    /// <param name="mode_0">the normalization mode</param>
	    /// <param name="options_1">Options for use with exclusion set an tailored NormalizationThe only option that is currently recognized is UNICODE_3_2</param>
	    /// <seealso cref="M:IBM.ICU.Text.Normalizer.IsNormalized(null, System.Int32, System.Int32, null, System.Int32)"/>
	    /// @stable ICU 2.6
	    // TODO: actually do the optimization when the guts of Normalizer are
	    // upgraded --has just dumb implementation for now
	    public static bool IsNormalized(int char32, Normalizer.Mode  mode_0, int options_1) {
	        return IsNormalized(IBM.ICU.Text.UTF16.ValueOf(char32), mode_0, options_1);
	    }
	
	    /// <summary>
	    /// Compare two strings for canonical equivalence. Further options include
	    /// case-insensitive comparison and code point order (as opposed to code unit
	    /// order).
	    /// Canonical equivalence between two strings is defined as their normalized
	    /// forms (NFD or NFC) being identical. This function compares strings
	    /// incrementally instead of normalizing (and optionally case-folding) both
	    /// strings entirely, improving performance significantly.
	    /// Bulk normalization is only necessary if the strings do not fulfill the
	    /// FCD conditions. Only in this case, and only if the strings are relatively
	    /// long, is memory allocated temporarily. For FCD strings and short non-FCD
	    /// strings there is no memory allocation.
	    /// Semantically, this is equivalent to
	    /// strcmp[CodePointOrder](foldCase(NFD(s1)), foldCase(NFD(s2))) where code
	    /// point order and foldCase are all optional.
	    /// </summary>
	    ///
	    /// <param name="s1">First source character array.</param>
	    /// <param name="s1Start">start index of source</param>
	    /// <param name="s1Limit">limit of the source</param>
	    /// <param name="s2">Second source character array.</param>
	    /// <param name="s2Start">start index of the source</param>
	    /// <param name="s2Limit">limit of the source</param>
	    /// <param name="options_0">A bit set of options: - FOLD_CASE_DEFAULT or 0 is used fordefault options: Case-sensitive comparison in code unit order,and the input strings are quick-checked for FCD.- INPUT_IS_FCD Set if the caller knows that both s1 and s2fulfill the FCD conditions.If not set, the function willquickCheck for FCD and normalize if necessary.- COMPARE_CODE_POINT_ORDER Set to choose code point orderinstead of code unit order- COMPARE_IGNORE_CASE Set to compare stringscase-insensitively using case folding, instead ofcase-sensitively. If set, then the following case foldingoptions are used.</param>
	    /// <returns><0 or 0 or >0 as usual for string comparisons</returns>
	    /// <seealso cref="M:IBM.ICU.Text.Normalizer.Normalize(System.String, null, System.Int32)"/>
	    /// <seealso cref="F:IBM.ICU.Text.Normalizer.FCD"/>
	    /// @stable ICU 2.8
	    public static int Compare(char[] s1, int s1Start, int s1Limit, char[] s2,
	            int s2Start, int s2Limit, int options_0) {
	        return InternalCompare(s1, s1Start, s1Limit, s2, s2Start, s2Limit,
	                options_0);
	    }
	
	    /// <summary>
	    /// Compare two strings for canonical equivalence. Further options include
	    /// case-insensitive comparison and code point order (as opposed to code unit
	    /// order). Convenience method.
	    /// </summary>
	    ///
	    /// <param name="s1">First source string.</param>
	    /// <param name="s2">Second source string.</param>
	    /// <param name="options_0">A bit set of options: - FOLD_CASE_DEFAULT or 0 is used fordefault options: Case-sensitive comparison in code unit order,and the input strings are quick-checked for FCD.- INPUT_IS_FCD Set if the caller knows that both s1 and s2fulfill the FCD conditions. If not set, the function willquickCheck for FCD and normalize if necessary.- COMPARE_CODE_POINT_ORDER Set to choose code point orderinstead of code unit order- COMPARE_IGNORE_CASE Set to compare stringscase-insensitively using case folding, instead ofcase-sensitively. If set, then the following case foldingoptions are used.</param>
	    /// <returns><0 or 0 or >0 as usual for string comparisons</returns>
	    /// <seealso cref="M:IBM.ICU.Text.Normalizer.Normalize(System.String, null, System.Int32)"/>
	    /// <seealso cref="F:IBM.ICU.Text.Normalizer.FCD"/>
	    /// @stable ICU 2.8
	    public static int Compare(String s1, String s2, int options_0) {
	
	        return Compare(s1.ToCharArray(), 0, s1.Length, s2.ToCharArray(), 0,
	                s2.Length, options_0);
	    }
	
	    /// <summary>
	    /// Compare two strings for canonical equivalence. Further options include
	    /// case-insensitive comparison and code point order (as opposed to code unit
	    /// order). Convenience method.
	    /// </summary>
	    ///
	    /// <param name="s1">First source string.</param>
	    /// <param name="s2">Second source string.</param>
	    /// <param name="options_0">A bit set of options: - FOLD_CASE_DEFAULT or 0 is used fordefault options: Case-sensitive comparison in code unit order,and the input strings are quick-checked for FCD.- INPUT_IS_FCD Set if the caller knows that both s1 and s2fulfill the FCD conditions. If not set, the function willquickCheck for FCD and normalize if necessary.- COMPARE_CODE_POINT_ORDER Set to choose code point orderinstead of code unit order- COMPARE_IGNORE_CASE Set to compare stringscase-insensitively using case folding, instead ofcase-sensitively. If set, then the following case foldingoptions are used.</param>
	    /// <returns><0 or 0 or >0 as usual for string comparisons</returns>
	    /// <seealso cref="M:IBM.ICU.Text.Normalizer.Normalize(System.String, null, System.Int32)"/>
	    /// <seealso cref="F:IBM.ICU.Text.Normalizer.FCD"/>
	    /// @stable ICU 2.8
	    public static int Compare(char[] s1, char[] s2, int options_0) {
	        return Compare(s1, 0, s1.Length, s2, 0, s2.Length, options_0);
	    }
	
	    /// <summary>
	    /// Convenience method that can have faster implementation by not allocating
	    /// buffers.
	    /// </summary>
	    ///
	    /// <param name="char32a">the first code point to be checked against the</param>
	    /// <param name="char32b">the second code point</param>
	    /// <param name="options_0">A bit set of options</param>
	    /// @stable ICU 2.8
	    // TODO: actually do the optimization when the guts of Normalizer are
	    // upgraded --has just dumb implementation for now
	    public static int Compare(int char32a, int char32b, int options_0) {
	        return Compare(IBM.ICU.Text.UTF16.ValueOf(char32a), IBM.ICU.Text.UTF16.ValueOf(char32b), options_0);
	    }
	
	    /// <summary>
	    /// Convenience method that can have faster implementation by not allocating
	    /// buffers.
	    /// </summary>
	    ///
	    /// <param name="char32a">the first code point to be checked against</param>
	    /// <param name="str2">the second string</param>
	    /// <param name="options_0">A bit set of options</param>
	    /// @stable ICU 2.8
	    // TODO: actually do the optimization when the guts of Normalizer are
	    // upgraded --has just dumb implementation for now
	    public static int Compare(int char32a, String str2, int options_0) {
	        return Compare(IBM.ICU.Text.UTF16.ValueOf(char32a), str2, options_0);
	    }
	
	    /// <summary>
	    /// Concatenate normalized strings, making sure that the result is normalized
	    /// as well.
	    /// If both the left and the right strings are in the normalization form
	    /// according to "mode", then the result will be
	    /// <code>
	    /// dest=normalize(left+right, mode)
	    /// </code>
	    /// With the input strings already being normalized, this function will use
	    /// next() and previous() to find the adjacent end pieces of the input
	    /// strings. Only the concatenation of these end pieces will be normalized
	    /// and then concatenated with the remaining parts of the input strings.
	    /// It is allowed to have dest==left to avoid copying the entire left string.
	    /// </summary>
	    ///
	    /// <param name="left">Left source array, may be same as dest.</param>
	    /// <param name="leftStart">start in the left array.</param>
	    /// <param name="leftLimit">limit in the left array (==length)</param>
	    /// <param name="right">Right source array.</param>
	    /// <param name="rightStart">start in the right array.</param>
	    /// <param name="rightLimit">limit in the right array (==length)</param>
	    /// <param name="dest">The output buffer; can be null if destStart==destLimit==0 forpure preflighting.</param>
	    /// <param name="destStart">start in the destination array</param>
	    /// <param name="destLimit">limit in the destination array (==length)</param>
	    /// <param name="mode_0">The normalization mode.</param>
	    /// <param name="options_1">The normalization options, ORed together (0 for no options).</param>
	    /// <returns>Length of output (number of chars) when successful or
	    /// IndexOutOfBoundsException</returns>
	    /// <exception cref="IndexOutOfBoundsException">whose message has the string representation of destinationcapacity required.</exception>
	    /// <seealso cref="M:IBM.ICU.Text.Normalizer.Normalize(System.String, null, System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Text.Normalizer.Next"/>
	    /// <seealso cref="M:IBM.ICU.Text.Normalizer.Previous"/>
	    /// <exception cref="IndexOutOfBoundsException">if target capacity is less than the required length</exception>
	    /// @stable ICU 2.8
	    /* Concatenation of normalized strings --------------------------------- */
	
	    public static int Concatenate(char[] left, int leftStart, int leftLimit,
	            char[] right, int rightStart, int rightLimit, char[] dest,
	            int destStart, int destLimit, Normalizer.Mode mode_0, int options_1) {
	
	        UCharacterIterator iter;
	
	        int leftBoundary, rightBoundary, destLength;
	
	        if (dest == null) {
	            throw new ArgumentException();
	        }
	
	        /* check for overlapping right and destination */
	        if (right == dest && rightStart < destLimit && destStart < rightLimit) {
	            throw new ArgumentException(
	                    "overlapping right and dst ranges");
	        }
	
	        /* allow left==dest */
	
	        /*
	         * Input: left[0..leftLength[ + right[0..rightLength[
	         * 
	         * Find normalization-safe boundaries leftBoundary and rightBoundary and
	         * copy the end parts together: buffer=left[leftBoundary..leftLength[ +
	         * right[0..rightBoundary[
	         * 
	         * dest=left[0..leftBoundary[ + normalize(buffer) +
	         * right[rightBoundary..rightLength[
	         */
	
	        /*
	         * find a normalization boundary at the end of the left string and copy
	         * the end part into the buffer
	         */
	
	        iter = IBM.ICU.Text.UCharacterIterator.GetInstance(left, leftStart, leftLimit);
	
	        iter.SetIndex(iter.GetLength()); /* end of left string */
	        char[] buffer_2 = new char[100];
	        int bufferLength;
	        bufferLength = Previous(iter, buffer_2, 0, buffer_2.Length, mode_0, false,
	                null, options_1);
	
	        leftBoundary = iter.GetIndex();
	
	        if (bufferLength > buffer_2.Length) {
	            char[] newBuf = new char[buffer_2.Length * 2];
	            buffer_2 = newBuf;
	            newBuf = null; // null the reference for GC
	            /* just copy from the left string: we know the boundary already */
	            System.Array.Copy((Array)(left),leftBoundary,(Array)(buffer_2),0,bufferLength);
	        }
	
	        /*
	         * find a normalization boundary at the beginning of the right string
	         * and concatenate the beginning part to the buffer
	         */
	
	        iter = IBM.ICU.Text.UCharacterIterator.GetInstance(right, rightStart, rightLimit);
	
	        rightBoundary = Next(iter, buffer_2, bufferLength, buffer_2.Length
	                - bufferLength, mode_0, false, null, options_1);
	
	        if (bufferLength > buffer_2.Length) {
	            char[] newBuf_3 = new char[buffer_2.Length * 2];
	            buffer_2 = newBuf_3;
	            newBuf_3 = null; // null the reference for GC
	            /* just copy from the right string: we know the boundary already */
	            System.Array.Copy((Array)(right),rightBoundary,(Array)(buffer_2),bufferLength,rightBoundary);
	        }
	
	        bufferLength += rightBoundary;
	
	        /* copy left[0..leftBoundary[ to dest */
	        if (left != dest && leftBoundary > 0 && (destLimit) > 0) {
	            System.Array.Copy((Array)(left),0,(Array)(dest),0,Math.Min(leftBoundary,destLimit));
	        }
	        destLength = leftBoundary;
	
	        /* concatenate the normalization of the buffer to dest */
	        if (destLimit > destLength) {
	            destLength += Normalizer.Normalize(buffer_2, 0, bufferLength, dest,
	                    destLength, destLimit, mode_0, options_1);
	
	        } else {
	            destLength += Normalizer.Normalize(buffer_2, 0, bufferLength, null,
	                    0, 0, mode_0, options_1);
	        }
	
	        /* concatenate right[rightBoundary..rightLength[ to dest */
	        rightStart += rightBoundary;
	        int rightLength = (rightLimit - rightStart);
	        if (rightLength > 0 && destLimit > destLength) {
	            System.Array.Copy((Array)(right),rightStart,(Array)(dest),destLength,Math.Min(rightLength,destLength));
	        }
	        destLength += rightLength;
	
	        if (destLength <= (destLimit - destStart)) {
	            return destLength;
	        } else {
	            throw new IndexOutOfRangeException(ILOG.J2CsMapping.Util.IlNumber.ToString(destLength).ToString());
	        }
	    }
	
	    /// <summary>
	    /// Concatenate normalized strings, making sure that the result is normalized
	    /// as well.
	    /// If both the left and the right strings are in the normalization form
	    /// according to "mode", then the result will be
	    /// <code>
	    /// dest=normalize(left+right, mode)
	    /// </code>
	    /// For details see concatenate
	    /// </summary>
	    ///
	    /// <param name="left">Left source string.</param>
	    /// <param name="right">Right source string.</param>
	    /// <param name="mode_0">The normalization mode.</param>
	    /// <param name="options_1">The normalization options, ORed together (0 for no options).</param>
	    /// <returns>result</returns>
	    /// <seealso cref="M:IBM.ICU.Text.Normalizer.Concatenate(null, System.Int32, System.Int32, null, System.Int32, System.Int32, null, System.Int32, System.Int32, IBM.ICU.Text.Mode, System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Text.Normalizer.Normalize(System.String, null, System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Text.Normalizer.Next"/>
	    /// <seealso cref="M:IBM.ICU.Text.Normalizer.Previous"/>
	    /// <seealso cref="M:IBM.ICU.Text.Normalizer.Concatenate(null, System.Int32, System.Int32, null, System.Int32, System.Int32, null, System.Int32, System.Int32, IBM.ICU.Text.Mode, System.Int32)"/>
	    /// @stable ICU 2.8
	    public static String Concatenate(char[] left, char[] right, Normalizer.Mode  mode_0,
	            int options_1) {
	        char[] result = new char[(left.Length + right.Length)
	                * MAX_BUF_SIZE_DECOMPOSE];
	        for (;;) {
	
	            int length = Concatenate(left, 0, left.Length, right, 0,
	                    right.Length, result, 0, result.Length, mode_0, options_1);
	            if (length <= result.Length) {
	                return new String(result, 0, length);
	            } else {
	                result = new char[length];
	            }
	        }
	    }
	
	    /// <summary>
	    /// Concatenate normalized strings, making sure that the result is normalized
	    /// as well.
	    /// If both the left and the right strings are in the normalization form
	    /// according to "mode", then the result will be
	    /// <code>
	    /// dest=normalize(left+right, mode)
	    /// </code>
	    /// For details see concatenate
	    /// </summary>
	    ///
	    /// <param name="left">Left source string.</param>
	    /// <param name="right">Right source string.</param>
	    /// <param name="mode_0">The normalization mode.</param>
	    /// <param name="options_1">The normalization options, ORed together (0 for no options).</param>
	    /// <returns>result</returns>
	    /// <seealso cref="M:IBM.ICU.Text.Normalizer.Concatenate(null, System.Int32, System.Int32, null, System.Int32, System.Int32, null, System.Int32, System.Int32, IBM.ICU.Text.Mode, System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Text.Normalizer.Normalize(System.String, null, System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Text.Normalizer.Next"/>
	    /// <seealso cref="M:IBM.ICU.Text.Normalizer.Previous"/>
	    /// <seealso cref="M:IBM.ICU.Text.Normalizer.Concatenate(null, System.Int32, System.Int32, null, System.Int32, System.Int32, null, System.Int32, System.Int32, IBM.ICU.Text.Mode, System.Int32)"/>
	    /// @stable ICU 2.8
	    public static String Concatenate(String left, String right, Normalizer.Mode  mode_0,
	            int options_1) {
	        char[] result = new char[(left.Length + right.Length)
	                * MAX_BUF_SIZE_DECOMPOSE];
	        for (;;) {
	
	            int length = Concatenate(left.ToCharArray(), 0, left.Length,
	                    right.ToCharArray(), 0, right.Length, result, 0,
	                    result.Length, mode_0, options_1);
	            if (length <= result.Length) {
	                return new String(result, 0, length);
	            } else {
	                result = new char[length];
	            }
	        }
	    }
	
	    /// <summary>
	    /// Gets the FC_NFKC closure set from the normalization data
	    /// </summary>
	    ///
	    /// <param name="c">The code point whose closure set is to be retrieved</param>
	    /// <param name="dest">The char array to recive the closure set</param>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public static int GetFC_NFKC_Closure(int c, char[] dest) {
	        return IBM.ICU.Impl.NormalizerImpl.GetFC_NFKC_Closure(c, dest);
	    }
	
	    /// <summary>
	    /// Gets the FC_NFKC closure set from the normalization data
	    /// </summary>
	    ///
	    /// <param name="c">The the code point whose closure set is to be retrieved</param>
	    /// <returns>String representation of the closure set</returns>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public static String GetFC_NFKC_Closure(int c) {
	        char[] dest = new char[10];
	        for (;;) {
	            int length = GetFC_NFKC_Closure(c, dest);
	            if (length <= dest.Length) {
	                return new String(dest, 0, length);
	            } else {
	                dest = new char[length];
	            }
	        }
	    }
	
	    // -------------------------------------------------------------------------
	    // Iteration API
	    // -------------------------------------------------------------------------
	
	    /// <summary>
	    /// Return the current character in the normalized text->
	    /// </summary>
	    ///
	    /// <returns>The codepoint as an int</returns>
	    /// @stable ICU 2.8
	    public int Current() {
	        if (bufferPos < bufferLimit || NextNormalize()) {
	            return GetCodePointAt(bufferPos);
	        } else {
	            return DONE;
	        }
	    }
	
	    /// <summary>
	    /// Return the next character in the normalized text and advance the
	    /// iteration position by one. If the end of the text has already been
	    /// reached, <see cref="F:IBM.ICU.Text.Normalizer.DONE"/> is returned.
	    /// </summary>
	    ///
	    /// <returns>The codepoint as an int</returns>
	    /// @stable ICU 2.8
	    public int Next() {
	        if (bufferPos < bufferLimit || NextNormalize()) {
	            int c = GetCodePointAt(bufferPos);
	            bufferPos += (c > 0xFFFF) ? 2 : 1;
	            return c;
	        } else {
	            return DONE;
	        }
	    }
	
	    /// <summary>
	    /// Return the previous character in the normalized text and decrement the
	    /// iteration position by one. If the beginning of the text has already been
	    /// reached, <see cref="F:IBM.ICU.Text.Normalizer.DONE"/> is returned.
	    /// </summary>
	    ///
	    /// <returns>The codepoint as an int</returns>
	    /// @stable ICU 2.8
	    public int Previous() {
	        if (bufferPos > 0 || PreviousNormalize()) {
	            int c = GetCodePointAt(bufferPos - 1);
	            bufferPos -= (c > 0xFFFF) ? 2 : 1;
	            return c;
	        } else {
	            return DONE;
	        }
	    }
	
	    /// <summary>
	    /// Reset the index to the beginning of the text. This is equivalent to
	    /// setIndexOnly(startIndex)).
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    public void Reset() {
	        text.SetIndex(0);
	        currentIndex = nextIndex = 0;
	        ClearBuffer();
	    }
	
	    /// <summary>
	    /// Set the iteration position in the input text that is being normalized,
	    /// without any immediate normalization. After setIndexOnly(), getIndex()
	    /// will return the same index that is specified here.
	    /// </summary>
	    ///
	    /// <param name="index">the desired index in the input text.</param>
	    /// @stable ICU 2.8
	    public void SetIndexOnly(int index) {
	        text.SetIndex(index);
	        currentIndex = nextIndex = index; // validates index
	        ClearBuffer();
	    }
	
	    /// <summary>
	    /// Set the iteration position in the input text that is being normalized and
	    /// return the first normalized character at that position.
	    /// <p>
	    /// <b>Note:</b> This method sets the position in the <em>input</em> text,
	    /// while <see cref="M:IBM.ICU.Text.Normalizer.Next"/> and <see cref="M:IBM.ICU.Text.Normalizer.Previous"/> iterate through characters in
	    /// the normalized <em>output</em>. This means that there is not necessarily
	    /// a one-to-one correspondence between characters returned by <tt>next</tt>
	    /// and <tt>previous</tt> and the indices passed to and returned from
	    /// <tt>setIndex</tt> and <see cref="M:IBM.ICU.Text.Normalizer.GetIndex"/>.
	    /// <p>
	    /// </summary>
	    ///
	    /// <param name="index">the desired index in the input text-></param>
	    /// <returns>the first normalized character that is the result of iterating
	    /// forward starting at the given index.</returns>
	    /// <exception cref="IllegalArgumentException">if the given index is less than <see cref="M:IBM.ICU.Text.Normalizer.GetBeginIndex"/> orgreater than <see cref="M:IBM.ICU.Text.Normalizer.GetEndIndex"/>.</exception>
	    /// <returns>The codepoint as an int</returns>
	    /// @obsolete ICU 3.2
	    // /CLOVER:OFF
	    public int SetIndex(int index) {
	        SetIndexOnly(index);
	        return Current();
	    }
	
	    // /CLOVER:ON
	    /// <summary>
	    /// Retrieve the index of the start of the input text. This is the begin
	    /// index of the <tt>CharacterIterator</tt> or the start (i.e. 0) of the
	    /// <tt>String</tt> over which this <tt>Normalizer</tt> is iterating
	    /// </summary>
	    ///
	    /// <returns>The codepoint as an int</returns>
	    /// <seealso cref="M:IBM.ICU.Text.Normalizer.StartIndex"/>
	    public int GetBeginIndex() {
	        return 0;
	    }
	
	    /// <summary>
	    /// Retrieve the index of the end of the input text. This is the end index of
	    /// the <tt>CharacterIterator</tt> or the length of the <tt>String</tt> over
	    /// which this <tt>Normalizer</tt> is iterating
	    /// </summary>
	    ///
	    /// <returns>The codepoint as an int</returns>
	    /// <seealso cref="M:IBM.ICU.Text.Normalizer.EndIndex"/>
	    public int GetEndIndex() {
	        return EndIndex();
	    }
	
	    /// <summary>
	    /// Return the first character in the normalized text-> This resets the
	    /// <tt>Normalizer's</tt> position to the beginning of the text->
	    /// </summary>
	    ///
	    /// <returns>The codepoint as an int</returns>
	    /// @stable ICU 2.8
	    public int First() {
	        Reset();
	        return Next();
	    }
	
	    /// <summary>
	    /// Return the last character in the normalized text-> This resets the
	    /// <tt>Normalizer's</tt> position to be just before the the input text
	    /// corresponding to that normalized character.
	    /// </summary>
	    ///
	    /// <returns>The codepoint as an int</returns>
	    /// @stable ICU 2.8
	    public int Last() {
	        text.SetToLimit();
	        currentIndex = nextIndex = text.GetIndex();
	        ClearBuffer();
	        return Previous();
	    }
	
	    /// <summary>
	    /// Retrieve the current iteration position in the input text that is being
	    /// normalized. This method is useful in applications such as searching,
	    /// where you need to be able to determine the position in the input text
	    /// that corresponds to a given normalized output character.
	    /// <p>
	    /// <b>Note:</b> This method sets the position in the <em>input</em>, while<see cref="M:IBM.ICU.Text.Normalizer.Next"/> and <see cref="M:IBM.ICU.Text.Normalizer.Previous"/> iterate through characters in the
	    /// <em>output</em>. This means that there is not necessarily a one-to-one
	    /// correspondence between characters returned by <tt>next</tt> and
	    /// <tt>previous</tt> and the indices passed to and returned from
	    /// <tt>setIndex</tt> and <see cref="M:IBM.ICU.Text.Normalizer.GetIndex"/>.
	    /// </summary>
	    ///
	    /// <returns>The current iteration position</returns>
	    /// @stable ICU 2.8
	    public int GetIndex() {
	        if (bufferPos < bufferLimit) {
	            return currentIndex;
	        } else {
	            return nextIndex;
	        }
	    }
	
	    /// <summary>
	    /// Retrieve the index of the start of the input text. This is the begin
	    /// index of the <tt>CharacterIterator</tt> or the start (i.e. 0) of the
	    /// <tt>String</tt> over which this <tt>Normalizer</tt> is iterating
	    /// </summary>
	    ///
	    /// <returns>The current iteration position</returns>
	    /// @stable ICU 2.8
	    public int StartIndex() {
	        return 0;
	    }
	
	    /// <summary>
	    /// Retrieve the index of the end of the input text-> This is the end index
	    /// of the <tt>CharacterIterator</tt> or the length of the <tt>String</tt>
	    /// over which this <tt>Normalizer</tt> is iterating
	    /// </summary>
	    ///
	    /// <returns>The current iteration position</returns>
	    /// @stable ICU 2.8
	    public int EndIndex() {
	        return text.GetLength();
	    }
	
	    // -------------------------------------------------------------------------
	    // Property access methods
	    // -------------------------------------------------------------------------
	    /// <summary>
	    /// Set the normalization mode for this object.
	    /// <p>
	    /// <b>Note:</b>If the normalization mode is changed while iterating over a
	    /// string, calls to <see cref="M:IBM.ICU.Text.Normalizer.Next"/> and <see cref="M:IBM.ICU.Text.Normalizer.Previous"/> may return
	    /// previously buffers characters in the old normalization mode until the
	    /// iteration is able to re-sync at the next base character. It is safest to
	    /// call <see cref="M:IBM.ICU.Text.Normalizer.SetText setText"/>, <see cref="M:IBM.ICU.Text.Normalizer.First"/>, <see cref="M:IBM.ICU.Text.Normalizer.Last"/>, etc.
	    /// after calling <tt>setMode</tt>.
	    /// <p>
	    /// </summary>
	    ///
	    /// <param name="newMode">the new mode for this <tt>Normalizer</tt>. The supported modesare:<ul><li><see cref="F:IBM.ICU.Text.Normalizer.COMPOSE"/> - Unicode canonical decompositiionfollowed by canonical composition. <li><see cref="F:IBM.ICU.Text.Normalizer.COMPOSE_COMPAT"/>- Unicode compatibility decompositiion follwed by canonicalcomposition. <li><see cref="F:IBM.ICU.Text.Normalizer.DECOMP"/> - Unicode canonicaldecomposition <li><see cref="F:IBM.ICU.Text.Normalizer.DECOMP_COMPAT"/> - Unicodecompatibility decomposition. <li><see cref="F:IBM.ICU.Text.Normalizer.NO_OP"/> - Do nothingbut return characters from the underlying input text.</ul></param>
	    /// <seealso cref="M:IBM.ICU.Text.Normalizer.GetMode"/>
	    /// @stable ICU 2.8
	    public void SetMode(Normalizer.Mode  newMode) {
	        mode = newMode;
	    }
	
	    /// <summary>
	    /// Return the basic operation performed by this <tt>Normalizer</tt>
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.Normalizer.SetMode(null)"/>
	    /// @stable ICU 2.8
	    public Normalizer.Mode  GetMode() {
	        return mode;
	    }
	
	    /// <summary>
	    /// Set options that affect this <tt>Normalizer</tt>'s operation. Options do
	    /// not change the basic composition or decomposition operation that is being
	    /// performed , but they control whether certain optional portions of the
	    /// operation are done. Currently the only available option is:
	    /// <p>
	    /// <ul>
	    /// <li><see cref="F:IBM.ICU.Text.Normalizer.UNICODE_3_2"/> - Use Normalization conforming to Unicode
	    /// version 3.2.
	    /// </ul>
	    /// <p>
	    /// </summary>
	    ///
	    /// <param name="option">the option whose value is to be set.</param>
	    /// <param name="value">the new setting for the option. Use <tt>true</tt> to turn theoption on and <tt>false</tt> to turn it off.</param>
	    /// <seealso cref="M:IBM.ICU.Text.Normalizer.GetOption(System.Int32)"/>
	    /// @stable ICU 2.6
	    public void SetOption(int option, bool value_ren) {
	        if (value_ren) {
	            options |= option;
	        } else {
	            options &= (~option);
	        }
	    }
	
	    /// <summary>
	    /// Determine whether an option is turned on or off.
	    /// <p>
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.Normalizer.SetOption(System.Int32, System.Boolean)"/>
	    /// @stable ICU 2.6
	    public int GetOption(int option) {
	        if ((options & option) != 0) {
	            return 1;
	        } else {
	            return 0;
	        }
	    }
	
	    /// <summary>
	    /// Gets the underlying text storage
	    /// </summary>
	    ///
	    /// <param name="fillIn">the char buffer to fill the UTF-16 units. The length of thebuffer should be equal to the length of the underlying textstorage</param>
	    /// <exception cref="IndexOutOfBoundsException"></exception>
	    /// <seealso cref="M:IBM.ICU.Text.Normalizer.GetLength"/>
	    /// @stable ICU 2.8
	    public int GetText(char[] fillIn) {
	        return text.GetText(fillIn);
	    }
	
	    /// <summary>
	    /// Gets the length of underlying text storage
	    /// </summary>
	    ///
	    /// <returns>the length</returns>
	    /// @stable ICU 2.8
	    public int GetLength() {
	        return text.GetLength();
	    }
	
	    /// <summary>
	    /// Returns the text under iteration as a string
	    /// </summary>
	    ///
	    /// <returns>a copy of the text under iteration.</returns>
	    /// @stable ICU 2.8
	    public String GetText() {
	        return text.GetText();
	    }
	
	    /// <summary>
	    /// Set the input text over which this <tt>Normalizer</tt> will iterate. The
	    /// iteration position is set to the beginning of the input text->
	    /// </summary>
	    ///
	    /// <param name="newText">The new string to be normalized.</param>
	    /// @stable ICU 2.8
	    public void SetText(StringBuilder newText) {
	
	        UCharacterIterator newIter = IBM.ICU.Text.UCharacterIterator.GetInstance(newText);
	        if (newIter == null) {
	            throw new InvalidOperationException(
	                    "Could not create a new UCharacterIterator");
	        }
	        text = newIter;
	        Reset();
	    }
	
	    /// <summary>
	    /// Set the input text over which this <tt>Normalizer</tt> will iterate. The
	    /// iteration position is set to the beginning of the input text->
	    /// </summary>
	    ///
	    /// <param name="newText">The new string to be normalized.</param>
	    /// @stable ICU 2.8
	    public void SetText(char[] newText) {
	
	        UCharacterIterator newIter = IBM.ICU.Text.UCharacterIterator.GetInstance(newText);
	        if (newIter == null) {
	            throw new InvalidOperationException(
	                    "Could not create a new UCharacterIterator");
	        }
	        text = newIter;
	        Reset();
	    }
	
	    /// <summary>
	    /// Set the input text over which this <tt>Normalizer</tt> will iterate. The
	    /// iteration position is set to the beginning of the input text->
	    /// </summary>
	    ///
	    /// <param name="newText">The new string to be normalized.</param>
	    /// @stable ICU 2.8
	    public void SetText(String newText) {
	
	        UCharacterIterator newIter = IBM.ICU.Text.UCharacterIterator.GetInstance(newText);
	        if (newIter == null) {
	            throw new InvalidOperationException(
	                    "Could not create a new UCharacterIterator");
	        }
	        text = newIter;
	        Reset();
	    }
	
	    /// <summary>
	    /// Set the input text over which this <tt>Normalizer</tt> will iterate. The
	    /// iteration position is set to the beginning of the input text->
	    /// </summary>
	    ///
	    /// <param name="newText">The new string to be normalized.</param>
	    /// @stable ICU 2.8
	    public void SetText(ICharacterIterator newText) {
	
	        UCharacterIterator newIter = IBM.ICU.Text.UCharacterIterator.GetInstance(newText);
	        if (newIter == null) {
	            throw new InvalidOperationException(
	                    "Could not create a new UCharacterIterator");
	        }
	        text = newIter;
	        Reset();
	    }
	
	    /// <summary>
	    /// Set the input text over which this <tt>Normalizer</tt> will iterate. The
	    /// iteration position is set to the beginning of the string.
	    /// </summary>
	    ///
	    /// <param name="newText">The new string to be normalized.</param>
	    /// @stable ICU 2.8
	    public void SetText(UCharacterIterator newText) {
	        try {
	            UCharacterIterator newIter = (UCharacterIterator) newText.Clone();
	            if (newIter == null) {
	                throw new InvalidOperationException(
	                        "Could not create a new UCharacterIterator");
	            }
	            text = newIter;
	            Reset();
	        } catch (Exception e) {
	            throw new InvalidOperationException(
	                    "Could not clone the UCharacterIterator");
	        }
	    }
	
	    // -------------------------------------------------------------------------
	    // Private utility methods
	    // -------------------------------------------------------------------------
	
	    /* backward iteration --------------------------------------------------- */
	
	    /*
	     * read backwards and get norm32 return 0 if the character is <minC if c2!=0
	     * then (c2, c) is a surrogate pair (reversed - c2 is first surrogate but
	     * read second!)
	     */
	
	    private static long GetPrevNorm32(UCharacterIterator src,
	            int/* unsigned */minC, int/* unsigned */mask, char[] chars) {
	        long norm32;
	        int ch = 0;
	        /* need src.hasPrevious() */
	        if ((ch = src.Previous()) == IBM.ICU.Text.UForwardCharacterIterator_Constants.DONE) {
	            return 0;
	        }
	        chars[0] = (char) ch;
	        chars[1] = ((Char)0);
	
	        /*
	         * check for a surrogate before getting norm32 to see if we need to
	         * predecrement further
	         */
	        if (chars[0] < minC) {
	            return 0;
	        } else if (!IBM.ICU.Text.UTF16.IsSurrogate(chars[0])) {
	            return IBM.ICU.Impl.NormalizerImpl.GetNorm32(chars[0]);
	        } else if (IBM.ICU.Text.UTF16.IsLeadSurrogate(chars[0]) || (src.GetIndex() == 0)) {
	            /* unpaired surrogate */
	            chars[1] = (char) src.Current();
	            return 0;
	        } else if (IBM.ICU.Text.UTF16.IsLeadSurrogate(chars[1] = (char) src.Previous())) {
	            norm32 = IBM.ICU.Impl.NormalizerImpl.GetNorm32(chars[1]);
	            if ((norm32 & mask) == 0) {
	                /*
	                 * all surrogate pairs with this lead surrogate have irrelevant
	                 * data
	                 */
	                return 0;
	            } else {
	                /* norm32 must be a surrogate special */
	                return IBM.ICU.Impl.NormalizerImpl.GetNorm32FromSurrogatePair(norm32,
	                        chars[0]);
	            }
	        } else {
	            /* unpaired second surrogate, undo the c2=src.previous() movement */
	            src.MoveIndex(1);
	            return 0;
	        }
	    }
	
	    public interface IsPrevBoundary {
	        bool IsPrevBoundary(UCharacterIterator src,
	                int/* unsigned */minC, int/* unsigned */mask, char[] chars);
	    }
	
	    private sealed class IsPrevNFDSafe : Normalizer.IsPrevBoundary  {
	        /*
	         * for NF*D: read backwards and check if the lead combining class is 0
	         * if c2!=0 then (c2, c) is a surrogate pair (reversed - c2 is first
	         * surrogate but read second!)
	         */
	        public bool IsPrevBoundary(UCharacterIterator src,
	                int/* unsigned */minC, int/* unsigned */ccOrQCMask, char[] chars) {
	
	            return IBM.ICU.Impl.NormalizerImpl.IsNFDSafe(
	                    IBM.ICU.Text.Normalizer.GetPrevNorm32(src, minC, ccOrQCMask, chars), ccOrQCMask,
	                    ccOrQCMask & IBM.ICU.Impl.NormalizerImpl.QC_MASK);
	        }
	    }
	
	    private sealed class IsPrevTrueStarter : Normalizer.IsPrevBoundary  {
	        /*
	         * read backwards and check if the character is (or its decomposition
	         * begins with) a "true starter" (cc==0 and NF*C_YES) if c2!=0 then (c2,
	         * c) is a surrogate pair (reversed - c2 is first surrogate but read
	         * second!)
	         */
	        public bool IsPrevBoundary(UCharacterIterator src,
	                int/* unsigned */minC, int/* unsigned */ccOrQCMask, char[] chars) {
	            long norm32;
	            int/* unsigned */decompQCMask;
	
	            decompQCMask = (ccOrQCMask << 2) & 0xf; /*
	                                                     * decomposition quick check
	                                                     * mask
	                                                     */
	            norm32 = IBM.ICU.Text.Normalizer.GetPrevNorm32(src, minC, ccOrQCMask | decompQCMask, chars);
	            return IBM.ICU.Impl.NormalizerImpl.IsTrueStarter(norm32, ccOrQCMask,
	                    decompQCMask);
	        }
	    }
	
	    private static int FindPreviousIterationBoundary(UCharacterIterator src,
	            Normalizer.IsPrevBoundary  obj, int/* unsigned */minC, int/* mask */mask,
	            char[] buffer_0, int[] startIndex) {
	        char[] chars = new char[2];
	        bool isBoundary;
	
	        /* fill the buffer from the end backwards */
	        startIndex[0] = buffer_0.Length;
	        chars[0] = ((Char)0);
	        while (src.GetIndex() > 0 && chars[0] != IBM.ICU.Text.UForwardCharacterIterator_Constants.DONE) {
	            isBoundary = obj.IsPrevBoundary(src, minC, mask, chars);
	
	            /* always write this character to the front of the buffer */
	            /* make sure there is enough space in the buffer */
	            if (startIndex[0] < ((chars[1] == 0) ? 1 : 2)) {
	
	                // grow the buffer
	                char[] newBuf = new char[buffer_0.Length * 2];
	                /* move the current buffer contents up */
	                System.Array.Copy((Array)(buffer_0),startIndex[0],(Array)(newBuf),newBuf.Length
	                                        - (buffer_0.Length - startIndex[0]),buffer_0.Length
	                                        - startIndex[0]);
	                // adjust the startIndex
	                startIndex[0] += newBuf.Length - buffer_0.Length;
	
	                buffer_0 = newBuf;
	                newBuf = null;
	
	            }
	
	            buffer_0[--startIndex[0]] = chars[0];
	            if (chars[1] != 0) {
	                buffer_0[--startIndex[0]] = chars[1];
	            }
	
	            /* stop if this just-copied character is a boundary */
	            if (isBoundary) {
	                break;
	            }
	        }
	
	        /* return the length of the buffer contents */
	        return buffer_0.Length - startIndex[0];
	    }
	
	    private static int Previous(UCharacterIterator src, char[] dest,
	            int destStart, int destLimit, Normalizer.Mode  mode_0, bool doNormalize,
	            bool[] pNeededToNormalize, int options_1) {
	
	        Normalizer.IsPrevBoundary  isPreviousBoundary;
	        int destLength, bufferLength;
	        int/* unsigned */mask;
	
	        int c, c2;
	
	        char minC;
	        int destCapacity = destLimit - destStart;
	        destLength = 0;
	
	        if (pNeededToNormalize != null) {
	            pNeededToNormalize[0] = false;
	        }
	        minC = (char) mode_0.GetMinC();
	        mask = mode_0.GetMask();
	        isPreviousBoundary = mode_0.GetPrevBoundary();
	
	        if (isPreviousBoundary == null) {
	            destLength = 0;
	            if ((c = src.Previous()) >= 0) {
	                destLength = 1;
	                if (IBM.ICU.Text.UTF16.IsTrailSurrogate((char) c)) {
	                    c2 = src.Previous();
	                    if (c2 != IBM.ICU.Text.UForwardCharacterIterator_Constants.DONE) {
	                        if (IBM.ICU.Text.UTF16.IsLeadSurrogate((char) c2)) {
	                            if (destCapacity >= 2) {
	                                dest[1] = (char) c; // trail surrogate
	                                destLength = 2;
	                            }
	                            // lead surrogate to be written below
	                            c = c2;
	                        } else {
	                            src.MoveIndex(1);
	                        }
	                    }
	                }
	
	                if (destCapacity > 0) {
	                    dest[0] = (char) c;
	                }
	            }
	            return destLength;
	        }
	
	        char[] buffer_2 = new char[100];
	        int[] startIndex = new int[1];
	        bufferLength = FindPreviousIterationBoundary(src, isPreviousBoundary,
	                minC, mask, buffer_2, startIndex);
	        if (bufferLength > 0) {
	            if (doNormalize) {
	                destLength = Normalizer.Normalize(buffer_2, startIndex[0],
	                        startIndex[0] + bufferLength, dest, destStart,
	                        destLimit, mode_0, options_1);
	
	                if (pNeededToNormalize != null) {
	                    pNeededToNormalize[0] = (bool) (destLength != bufferLength || IBM.ICU.Impl.Utility
	                            .ArrayRegionMatches(buffer_2, 0, dest, destStart,
	                                    destLimit));
	                }
	            } else {
	                /* just copy the source characters */
	                if (destCapacity > 0) {
	                    System.Array.Copy((Array)(buffer_2),startIndex[0],(Array)(dest),0,(bufferLength < destCapacity) ? bufferLength
	                                                        : destCapacity);
	                }
	            }
	        }
	
	        return destLength;
	    }
	
	    /* forward iteration ---------------------------------------------------- */
	    /*
	     * read forward and check if the character is a next-iteration boundary if
	     * c2!=0 then (c, c2) is a surrogate pair
	     */
	    public interface IsNextBoundary {
	        bool IsNextBoundary(UCharacterIterator src, int/* unsigned */minC,
	                int/* unsigned */mask, int[] chars);
	    }
	
	    /*
	     * read forward and get norm32 return 0 if the character is <minC if c2!=0
	     * then (c2, c) is a surrogate pair always reads complete characters
	     */
	    private static long /* unsigned */GetNextNorm32(UCharacterIterator src,
	            int/* unsigned */minC, int/* unsigned */mask, int[] chars) {
	        long norm32;
	
	        /* need src.hasNext() to be true */
	        chars[0] = src.Next();
	        chars[1] = 0;
	
	        if (chars[0] < minC) {
	            return 0;
	        }
	
	        norm32 = IBM.ICU.Impl.NormalizerImpl.GetNorm32((char) chars[0]);
	        if (IBM.ICU.Text.UTF16.IsLeadSurrogate((char) chars[0])) {
	            if (src.Current() != IBM.ICU.Text.UForwardCharacterIterator_Constants.DONE
	                    && IBM.ICU.Text.UTF16.IsTrailSurrogate((char) (chars[1] = src.Current()))) {
	                src.MoveIndex(1); /* skip the c2 surrogate */
	                if ((norm32 & mask) == 0) {
	                    /* irrelevant data */
	                    return 0;
	                } else {
	                    /* norm32 must be a surrogate special */
	                    return IBM.ICU.Impl.NormalizerImpl.GetNorm32FromSurrogatePair(norm32,
	                            (char) chars[1]);
	                }
	            } else {
	                /* unmatched surrogate */
	                return 0;
	            }
	        }
	        return norm32;
	    }
	
	    /*
	     * for NF*D: read forward and check if the lead combining class is 0 if
	     * c2!=0 then (c, c2) is a surrogate pair
	     */
	    private sealed class IsNextNFDSafe : Normalizer.IsNextBoundary  {
	        public bool IsNextBoundary(UCharacterIterator src,
	                int/* unsigned */minC, int/* unsigned */ccOrQCMask, int[] chars) {
	            return IBM.ICU.Impl.NormalizerImpl.IsNFDSafe(
	                    IBM.ICU.Text.Normalizer.GetNextNorm32(src, minC, ccOrQCMask, chars), ccOrQCMask,
	                    ccOrQCMask & IBM.ICU.Impl.NormalizerImpl.QC_MASK);
	        }
	    }
	
	    /*
	     * for NF*C: read forward and check if the character is (or its
	     * decomposition begins with) a "true starter" (cc==0 and NF*C_YES) if c2!=0
	     * then (c, c2) is a surrogate pair
	     */
	    private sealed class IsNextTrueStarter : Normalizer.IsNextBoundary  {
	        public bool IsNextBoundary(UCharacterIterator src,
	                int/* unsigned */minC, int/* unsigned */ccOrQCMask, int[] chars) {
	            long norm32;
	            int/* unsigned */decompQCMask;
	
	            decompQCMask = (ccOrQCMask << 2) & 0xf; /*
	                                                     * decomposition quick check
	                                                     * mask
	                                                     */
	            norm32 = IBM.ICU.Text.Normalizer.GetNextNorm32(src, minC, ccOrQCMask | decompQCMask, chars);
	            return IBM.ICU.Impl.NormalizerImpl.IsTrueStarter(norm32, ccOrQCMask,
	                    decompQCMask);
	        }
	    }
	
	    private static int FindNextIterationBoundary(UCharacterIterator src,
	            Normalizer.IsNextBoundary  obj, int/* unsigned */minC, int/* unsigned */mask,
	            char[] buffer_0) {
	        int[] chars = new int[2];
	        int bufferIndex = 0;
	
	        if (src.Current() == IBM.ICU.Text.UForwardCharacterIterator_Constants.DONE) {
	            return 0;
	        }
	        /* get one character and ignore its properties */
	        chars[0] = src.Next();
	        buffer_0[0] = (char) chars[0];
	        bufferIndex = 1;
	
	        if (IBM.ICU.Text.UTF16.IsLeadSurrogate((char) chars[0])
	                && src.Current() != IBM.ICU.Text.UForwardCharacterIterator_Constants.DONE) {
	            if (IBM.ICU.Text.UTF16.IsTrailSurrogate((char) (chars[1] = src.Next()))) {
	                buffer_0[bufferIndex++] = (char) chars[1];
	            } else {
	                src.MoveIndex(-1); /* back out the non-trail-surrogate */
	            }
	        }
	
	        /* get all following characters until we see a boundary */
	        /*
	         * checking hasNext() instead of c!=DONE on the off-chance that U+ffff
	         * is part of the string
	         */
	        while (src.Current() != IBM.ICU.Text.UForwardCharacterIterator_Constants.DONE) {
	            if (obj.IsNextBoundary(src, minC, mask, chars)) {
	                /* back out the latest movement to stop at the boundary */
	                src.MoveIndex((chars[1] == 0) ? -1 : -2);
	                break;
	            } else {
	                if (bufferIndex + ((chars[1] == 0) ? 1 : 2) <= buffer_0.Length) {
	                    buffer_0[bufferIndex++] = (char) chars[0];
	                    if (chars[1] != 0) {
	                        buffer_0[bufferIndex++] = (char) chars[1];
	                    }
	                } else {
	                    char[] newBuf = new char[buffer_0.Length * 2];
	                    System.Array.Copy((Array)(buffer_0),0,(Array)(newBuf),0,bufferIndex);
	                    buffer_0 = newBuf;
	                    buffer_0[bufferIndex++] = (char) chars[0];
	                    if (chars[1] != 0) {
	                        buffer_0[bufferIndex++] = (char) chars[1];
	                    }
	                }
	            }
	        }
	
	        /* return the length of the buffer contents */
	        return bufferIndex;
	    }
	
	    private static int Next(UCharacterIterator src, char[] dest, int destStart,
	            int destLimit, Normalizer.Mode mode_0, bool doNormalize,
	            bool[] pNeededToNormalize, int options_1) {
	
	        Normalizer.IsNextBoundary  isNextBoundary;
	        int /* unsigned */mask;
	        int /* unsigned */bufferLength;
	        int c, c2;
	        char minC;
	        int destCapacity = destLimit - destStart;
	        int destLength = 0;
	
	        if (pNeededToNormalize != null) {
	            pNeededToNormalize[0] = false;
	        }
	
	        minC = (char) mode_0.GetMinC();
	        mask = mode_0.GetMask();
	        isNextBoundary = mode_0.GetNextBoundary();
	
	        if (isNextBoundary == null) {
	            destLength = 0;
	            c = src.Next();
	            if (c != IBM.ICU.Text.UForwardCharacterIterator_Constants.DONE) {
	                destLength = 1;
	                if (IBM.ICU.Text.UTF16.IsLeadSurrogate((char) c)) {
	                    c2 = src.Next();
	                    if (c2 != IBM.ICU.Text.UForwardCharacterIterator_Constants.DONE) {
	                        if (IBM.ICU.Text.UTF16.IsTrailSurrogate((char) c2)) {
	                            if (destCapacity >= 2) {
	                                dest[1] = (char) c2; // trail surrogate
	                                destLength = 2;
	                            }
	                            // lead surrogate to be written below
	                        } else {
	                            src.MoveIndex(-1);
	                        }
	                    }
	                }
	
	                if (destCapacity > 0) {
	                    dest[0] = (char) c;
	                }
	            }
	            return destLength;
	        }
	
	        char[] buffer_2 = new char[100];
	        int[] startIndex = new int[1];
	
	        bufferLength = FindNextIterationBoundary(src, isNextBoundary, minC,
	                mask, buffer_2);
	        if (bufferLength > 0) {
	            if (doNormalize) {
	                destLength = mode_0.Normalize(buffer_2, startIndex[0],
	                        bufferLength, dest, destStart, destLimit, options_1);
	
	                if (pNeededToNormalize != null) {
	                    pNeededToNormalize[0] = (bool) (destLength != bufferLength || IBM.ICU.Impl.Utility
	                            .ArrayRegionMatches(buffer_2, startIndex[0], dest,
	                                    destStart, destLength));
	                }
	            } else {
	                /* just copy the source characters */
	                if (destCapacity > 0) {
	                    System.Array.Copy((Array)(buffer_2),0,(Array)(dest),destStart,Math.Min(bufferLength,destCapacity));
	                }
	
	            }
	        }
	        return destLength;
	    }
	
	    private void ClearBuffer() {
	        bufferLimit = bufferStart = bufferPos = 0;
	    }
	
	    private bool NextNormalize() {
	
	        ClearBuffer();
	        currentIndex = nextIndex;
	        text.SetIndex(nextIndex);
	
	        bufferLimit = Next(text, buffer, bufferStart, buffer.Length, mode,
	                true, null, options);
	
	        nextIndex = text.GetIndex();
	        return (bufferLimit > 0);
	    }
	
	    private bool PreviousNormalize() {
	
	        ClearBuffer();
	        nextIndex = currentIndex;
	        text.SetIndex(currentIndex);
	        bufferLimit = Previous(text, buffer, bufferStart, buffer.Length, mode,
	                true, null, options);
	
	        currentIndex = text.GetIndex();
	        bufferPos = bufferLimit;
	        return bufferLimit > 0;
	    }
	
	    private int GetCodePointAt(int index) {
	        if (IBM.ICU.Text.UTF16.IsSurrogate(buffer[index])) {
	            if (IBM.ICU.Text.UTF16.IsLeadSurrogate(buffer[index])) {
	                if ((index + 1) < bufferLimit
	                        && IBM.ICU.Text.UTF16.IsTrailSurrogate(buffer[index + 1])) {
	                    return IBM.ICU.Impl.UCharacterProperty.GetRawSupplementary(
	                            buffer[index], buffer[index + 1]);
	                }
	            } else if (IBM.ICU.Text.UTF16.IsTrailSurrogate(buffer[index])) {
	                if (index > 0 && IBM.ICU.Text.UTF16.IsLeadSurrogate(buffer[index - 1])) {
	                    return IBM.ICU.Impl.UCharacterProperty.GetRawSupplementary(
	                            buffer[index - 1], buffer[index]);
	                }
	            }
	        }
	        return buffer[index];
	
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Internal API
	    /// </summary>
	    ///
	    public static bool IsNFSkippable(int c, Normalizer.Mode  mode_0) {
	        return mode_0.IsNFSkippable(c);
	    }
	
	    private static int InternalCompare(char[] s1, int s1Start, int s1Limit,
	            char[] s2, int s2Start, int s2Limit, int options_0) {
	
	        char[] fcd1 = new char[300];
	        char[] fcd2 = new char[300];
	
	        Normalizer.Mode mode_1;
	        int result;
	
	        if (s1 == null || s1Start < 0 || s1Limit < 0 || s2 == null
	                || s2Start < 0 || s2Limit < 0 || s1Limit < s1Start
	                || s2Limit < s2Start) {
	
	            throw new ArgumentException();
	        }
	
	        UnicodeSet nx = IBM.ICU.Impl.NormalizerImpl
	                .GetNX((int) (options_0 >> Normalizer.COMPARE_NORM_OPTIONS_SHIFT));
	        options_0 |= IBM.ICU.Impl.NormalizerImpl.COMPARE_EQUIV;
	        result = 0;
	
	        /*
	         * UAX #21 Case Mappings, as fixed for Unicode version 4 (see Jitterbug
	         * 2021), defines a canonical caseless match as
	         * 
	         * A string X is a canonical caseless match for a string Y if and only
	         * if NFD(toCasefold(NFD(X))) = NFD(toCasefold(NFD(Y)))
	         * 
	         * For better performance, we check for FCD (or let the caller tell us
	         * that both strings are in FCD) for the inner normalization.
	         * BasicNormalizerTest::FindFoldFCDExceptions() makes sure that
	         * case-folding preserves the FCD-ness of a string. The outer
	         * normalization is then only performed by NormalizerImpl.cmpEquivFold()
	         * when there is a difference.
	         * 
	         * Exception: When using the Turkic case-folding option, we do perform
	         * full NFD first. This is because in the Turkic case precomposed
	         * characters with 0049 capital I or 0069 small i fold differently
	         * whether they are first decomposed or not, so an FCD check - a check
	         * only for canonical order - is not sufficient.
	         */
	        if ((options_0 & Normalizer.FOLD_CASE_EXCLUDE_SPECIAL_I) > 0) {
	            mode_1 = Normalizer.NFD;
	            options_0 &= ~Normalizer.INPUT_IS_FCD;
	        } else {
	            mode_1 = Normalizer.FCD;
	        }
	        if ((options_0 & Normalizer.INPUT_IS_FCD) == 0) {
	            char[] dest;
	            int fcdLen1, fcdLen2;
	            bool isFCD1, isFCD2;
	
	            // check if s1 and/or s2 fulfill the FCD conditions
	            isFCD1 = Normalizer.YES == mode_1.QuickCheck(s1, s1Start, s1Limit,
	                    true, nx);
	            isFCD2 = Normalizer.YES == mode_1.QuickCheck(s2, s2Start, s2Limit,
	                    true, nx);
	            /*
	             * ICU 2.4 had a further optimization: If both strings were not in
	             * FCD, then they were both NFD'ed, and the COMPARE_EQUIV option was
	             * turned off. It is not entirely clear that this is valid with the
	             * current definition of the canonical caseless match. Therefore,
	             * ICU 2.6 removes that optimization.
	             */
	
	            if (!isFCD1) {
	                fcdLen1 = mode_1.Normalize(s1, 0, s1.Length, fcd1, 0,
	                        fcd1.Length, nx);
	
	                if (fcdLen1 > fcd1.Length) {
	                    dest = new char[fcdLen1];
	                    fcdLen1 = mode_1.Normalize(s1, 0, s1.Length, dest, 0,
	                            dest.Length, nx);
	                    s1 = dest;
	                } else {
	                    s1 = fcd1;
	                }
	                s1Limit = fcdLen1;
	                s1Start = 0;
	            }
	
	            if (!isFCD2) {
	                fcdLen2 = mode_1.Normalize(s2, s2Start, s2Limit, fcd2, 0,
	                        fcd2.Length, nx);
	
	                if (fcdLen2 > fcd2.Length) {
	                    dest = new char[fcdLen2];
	                    fcdLen2 = mode_1.Normalize(s2, s2Start, s2Limit, dest, 0,
	                            dest.Length, nx);
	                    s2 = dest;
	                } else {
	                    s2 = fcd2;
	                }
	                s2Limit = fcdLen2;
	                s2Start = 0;
	            }
	
	        }
	
	        result = IBM.ICU.Impl.NormalizerImpl.CmpEquivFold(s1, s1Start, s1Limit, s2, s2Start,
	                s2Limit, options_0);
	        return result;
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Fetches the Unicode version burned into the Normalization data file
	    /// </summary>
	    ///
	    /// <returns>VersionInfo version information of the normalizer</returns>
	    static internal VersionInfo GetUnicodeVersion() {
	        return IBM.ICU.Impl.NormalizerImpl.GetUnicodeVersion();
	    }
	}
}
