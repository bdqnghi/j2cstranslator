/*
 *******************************************************************************
 * Copyright (C) 1996-2007, International Business Machines Corporation and    *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 */
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:30 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Text {
	
	using IBM.ICU.Util;
	using ILOG.J2CsMapping.IO;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	
	/// <exclude/>
	/// <summary>
	/// This is the class that represents the list of known words used by
	/// DictionaryBasedBreakIterator. The conceptual data structure used here is a
	/// trie: there is a node hanging off the root node for every letter that can
	/// start a word. Each of these nodes has a node hanging off of it for every
	/// letter that can be the second letter of a word if this node is the first
	/// letter, and so on. The trie is represented as a two-dimensional array that
	/// can be treated as a table of state transitions. Indexes are used to compress
	/// this array, taking advantage of the fact that this array will always be very
	/// sparse.
	/// </summary>
	///
	public class BreakDictionary {
	    // =================================================================================
	    // testing and debugging
	    // =================================================================================
	    /// <exclude/>
	    public static void Main(String[] args) {
	        String filename = args[0];
	
	        BreakDictionary dictionary = new BreakDictionary(File.OpenRead(filename));
	
	        StreamWriter xout = null;
	
	        if (args.Length >= 2) {
	            //xout = ILOG.J2CsMapping.IO.IOUtility.NewStreamWriter(ILOG.J2CsMapping.IO.IOUtility.NewStreamWriter(File.OpenWrite(args[1]),System.Text.Encoding.GetEncoding("UnicodeLittle"))) /* Warning: if writer (arg) is a StringWriter exception raised */;
	        }
	
	        dictionary.PrintWordList("", 0, xout);
	
	        if (xout != null) {
	            xout.Close();
	        }
	    }
	
	    /// <exclude/>
	    public void PrintWordList(String partialWord, int state, StreamWriter xout) {
	        if (state == 0xFFFF) {
	            System.Console.Out.WriteLine(partialWord);
	            if (xout != null) {
	                xout.WriteLine(partialWord);
	            }
	        } else {
	            for (int i = 0; i < numCols; i++) {
	                int newState = (At(state, i)) & 0xFFFF;
	
	                if (newState != 0) {
	                    char newChar = reverseColumnMap[i];
	                    String newPartialWord = partialWord;
	
	                    if (newChar != 0) {
	                        newPartialWord += newChar;
	                    }
	
	                    PrintWordList(newPartialWord, newState, xout);
	                }
	            }
	        }
	    }
	
	    /// <summary>
	    /// A map used to go from column numbers to characters. Used only for
	    /// debugging right now.
	    /// </summary>
	    ///
	    private char[] reverseColumnMap;
	
	    // =================================================================================
	    // data members
	    // =================================================================================
	
	    /// <summary>
	    /// Maps from characters to column numbers. The main use of this is to avoid
	    /// making room in the array for empty columns.
	    /// </summary>
	    ///
	    private CompactByteArray columnMap;
	
	    /// <summary>
	    /// The number of actual columns in the table
	    /// </summary>
	    ///
	    private int numCols;
	
	    /*
	     * Columns are organized into groups of 32. This says how many column
	     * groups. (We could calculate this, but we store the value to avoid having
	     * to repeatedly calculate it.)
	     */
	    // private int numColGroups;
	
	    /// <summary>
	    /// The actual compressed state table. Each conceptual row represents a
	    /// state, and the cells in it contain the row numbers of the states to
	    /// transition to for each possible letter. 0 is used to indicate an illegal
	    /// combination of letters (i.e., the error state). The table is compressed
	    /// by eliminating all the unpopulated (i.e., zero) cells. Multiple
	    /// conceptual rows can then be doubled up in a single physical row by
	    /// sliding them up and possibly shifting them to one side or the other so
	    /// the populated cells don't collide. Indexes are used to identify
	    /// unpopulated cells and to locate populated cells.
	    /// </summary>
	    ///
	    private short[] table;
	
	    /// <summary>
	    /// This index maps logical row numbers to physical row numbers
	    /// </summary>
	    ///
	    private short[] rowIndex;
	
	    /// <summary>
	    /// A bitmap is used to tell which cells in the comceptual table are
	    /// populated. This array contains all the unique bit combinations in that
	    /// bitmap. If the table is more than 32 columns wide, successive entries in
	    /// this array are used for a single row.
	    /// </summary>
	    ///
	    private int[] rowIndexFlags;
	
	    /// <summary>
	    /// This index maps from a logical row number into the bitmap table above.
	    /// (This keeps us from storing duplicate bitmap combinations.) Since there
	    /// are a lot of rows with only one populated cell, instead of wasting space
	    /// in the bitmap table, we just store a negative number in this index for
	    /// rows with one populated cell. The absolute value of that number is the
	    /// column number of the populated cell.
	    /// </summary>
	    ///
	    private short[] rowIndexFlagsIndex;
	
	    /// <summary>
	    /// For each logical row, this index contains a constant that is added to the
	    /// logical column number to get the physical column number
	    /// </summary>
	    ///
	    private sbyte[] rowIndexShifts;
	
	    // =================================================================================
	    // deserialization
	    // =================================================================================
	
	    /// <exclude/>
	    public BreakDictionary(Stream dictionaryStream) {
	        this.reverseColumnMap = null;
	        this.columnMap = null;
	        this.table = null;
	        this.rowIndex = null;
	        this.rowIndexFlags = null;
	        this.rowIndexFlagsIndex = null;
	        this.rowIndexShifts = null;
	        ReadDictionaryFile(new DataInputStream(dictionaryStream));
	    }
	
	    /// <exclude/>
	    public void ReadDictionaryFile(DataInputStream ins0) {
	        int l;
	
	        // read in the version number (right now we just ignore it)
	        ins0.ReadInt();
	
	        // read in the column map (this is serialized in its internal form:
	        // an index array followed by a data array)
	        l = ins0.ReadInt();
	        char[] temp = new char[l];
	        for (int i = 0; i < temp.Length; i++)
	            temp[i] = (char) ins0.ReadShort();
	        l = ins0.ReadInt();
	        sbyte[] temp2 = new sbyte[l];
	        for (int i_0 = 0; i_0 < temp2.Length; i_0++)
	            temp2[i_0] = ins0.ReadByte();
	        columnMap = new CompactByteArray(temp, temp2);
	
	        // read in numCols and numColGroups
	        numCols = ins0.ReadInt();
	        /* numColGroups = */ins0.ReadInt();
	
	        // read in the row-number index
	        l = ins0.ReadInt();
	        rowIndex = new short[l];
	        for (int i_1 = 0; i_1 < rowIndex.Length; i_1++)
	            rowIndex[i_1] = ins0.ReadShort();
	
	        // load in the populated-cells bitmap: index first, then bitmap list
	        l = ins0.ReadInt();
	        rowIndexFlagsIndex = new short[l];
	        for (int i_2 = 0; i_2 < rowIndexFlagsIndex.Length; i_2++)
	            rowIndexFlagsIndex[i_2] = ins0.ReadShort();
	        l = ins0.ReadInt();
	        rowIndexFlags = new int[l];
	        for (int i_3 = 0; i_3 < rowIndexFlags.Length; i_3++)
	            rowIndexFlags[i_3] = ins0.ReadInt();
	
	        // load in the row-shift index
	        l = ins0.ReadInt();
	        rowIndexShifts = new sbyte[l];
	        for (int i_4 = 0; i_4 < rowIndexShifts.Length; i_4++)
	            rowIndexShifts[i_4] = ins0.ReadByte();
	
	        // finally, load in the actual state table
	        l = ins0.ReadInt();
	        table = new short[l];
	        for (int i_5 = 0; i_5 < table.Length; i_5++)
	            table[i_5] = ins0.ReadShort();
	
	        // this data structure is only necessary for testing and debugging
	        // purposes
	        reverseColumnMap = new char[numCols];
	        for (char c = (char) (0); c < 0xffff; c++) {
	            int col = columnMap.ElementAt(c);
	            if (col != 0) {
	                reverseColumnMap[col] = c;
	            }
	        }
	
	        // close the stream
	        ins0.Close();
	    }
	
	    // =================================================================================
	    // access to the words
	    // =================================================================================
	
	    /// <exclude/>
	    /// <summary>
	    /// Uses the column map to map the character to a column number, then passes
	    /// the row and column number to the other version of at()
	    /// </summary>
	    ///
	    /// <param name="row">The current state</param>
	    /// <param name="ch">The character whose column we're interested in</param>
	    /// <returns>The new state to transition to</returns>
	    public short At(int row, char ch) {
	        int col = columnMap.ElementAt(ch);
	        return At(row, col);
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Returns the value in the cell with the specified (logical) row and column
	    /// numbers. In DictionaryBasedBreakIterator, the row number is a state
	    /// number, the column number is an input, and the return value is the row
	    /// number of the new state to transition to. (0 is the "error" state, and -1
	    /// is the "end of word" state in a dictionary)
	    /// </summary>
	    ///
	    /// <param name="row">The row number of the current state</param>
	    /// <param name="col">The column number of the input character (0 means "not adictionary character")</param>
	    /// <returns>The row number of the new state to transition to</returns>
	    public short At(int row, int col) {
	        if (CellIsPopulated(row, col)) {
	            // we map from logical to physical row number by looking up the
	            // mapping in rowIndex; we map from logical column number to
	            // physical column number by looking up a shift value for this
	            // logical row and offsetting the logical column number by
	            // the shift amount. Then we can use internalAt() to actually
	            // get the value out of the table.
	            return InternalAt(rowIndex[row], col + rowIndexShifts[row]);
	        } else {
	            return 0;
	        }
	    }
	
	    /// <summary>
	    /// Given (logical) row and column numbers, returns true if the cell in that
	    /// position is populated
	    /// </summary>
	    ///
	    private bool CellIsPopulated(int row, int col) {
	        // look up the entry in the bitmap index for the specified row.
	        // If it's a negative number, it's the column number of the only
	        // populated cell in the row
	        if (rowIndexFlagsIndex[row] < 0) {
	            return col == -rowIndexFlagsIndex[row];
	        }
	
	        // if it's a positive number, it's the offset of an entry in the bitmap
	        // list. If the table is more than 32 columns wide, the bitmap is stored
	        // successive entries in the bitmap list, so we have to divide the
	        // column
	        // number by 32 and offset the number we got out of the index by the
	        // result.
	        // Once we have the appropriate piece of the bitmap, test the
	        // appropriate
	        // bit and return the result.
	        else {
	            int flags = rowIndexFlags[rowIndexFlagsIndex[row] + (col >> 5)];
	            return (flags & (1 << (col & 0x1f))) != 0;
	        }
	    }
	
	    /// <summary>
	    /// Implementation of at() when we know the specified cell is populated.
	    /// </summary>
	    ///
	    /// <param name="row">The PHYSICAL row number of the cell</param>
	    /// <param name="col">The PHYSICAL column number of the cell</param>
	    /// <returns>The value stored in the cell</returns>
	    private short InternalAt(int row, int col) {
	        // the table is a one-dimensional array, so this just does the math
	        // necessary
	        // to treat it as a two-dimensional array (we don't just use a
	        // two-dimensional
	        // array because two-dimensional arrays are inefficient in Java)
	        return table[row * numCols + col];
	    }
	}
}
