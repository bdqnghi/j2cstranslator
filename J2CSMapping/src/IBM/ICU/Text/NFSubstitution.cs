/*
 *******************************************************************************
 * Copyright (C) 1996-2007, International Business Machines Corporation and    *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 */
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:30 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Text {
	
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Text;
     using ILOG.J2CsMapping.Util;
     using ILOG.J2CsMapping.Text;
	
	//===================================================================
	// NFSubstitution (abstract base class)
	//===================================================================
	
	/// <summary>
	/// An abstract class defining protocol for substitutions. A substitution is a
	/// section of a rule that inserts text into the rule's rule text based on some
	/// part of the number being formatted.
	/// </summary>
	///
	abstract internal class NFSubstitution {
	    // -----------------------------------------------------------------------
	    // data members
	    // -----------------------------------------------------------------------
	
	    /// <summary>
	    /// The substitution's position in the rule text of the rule that owns it
	    /// </summary>
	    ///
	    internal int pos;
	
	    /// <summary>
	    /// The rule set this substitution uses to format its result, or null.
	    /// (Either this or numberFormat has to be non-null.)
	    /// </summary>
	    ///
	    internal NFRuleSet ruleSet;
	
	    /// <summary>
	    /// The DecimalFormat this substitution uses to format its result, or null.
	    /// (Either this or ruleSet has to be non-null.)
	    /// </summary>
	    ///
	    internal DecimalFormat numberFormat;
	
	    // -----------------------------------------------------------------------
	    // construction
	    // -----------------------------------------------------------------------
	
	    /// <summary>
	    /// Parses the description, creates the right kind of substitution, and
	    /// initializes it based on the description.
	    /// </summary>
	    ///
	    /// <param name="pos_0">The substitution's position in the rule text of the rule thatowns it.</param>
	    /// <param name="rule">The rule containing this substitution</param>
	    /// <param name="rulePredecessor">The rule preceding the one that contains this substitution inthe rule set's rule list (this is used only for >>>substitutions).</param>
	    /// <param name="ruleSet_1">The rule set containing the rule containing this substitution</param>
	    /// <param name="formatter">The RuleBasedNumberFormat that ultimately owns thissubstitution</param>
	    /// <param name="description">The description to parse to build the substitution (this isjust the substring of the rule's description containing thesubstitution token itself)</param>
	    /// <returns>A new substitution constructed according to the description</returns>
	    public static NFSubstitution MakeSubstitution(int pos_0, NFRule rule,
	            NFRule rulePredecessor, NFRuleSet ruleSet_1,
	            RuleBasedNumberFormat formatter, String description) {
	        // if the description is empty, return a NummSubstitution
	        if (description.Length == 0) {
	            return new NullSubstitution(pos_0, ruleSet_1, formatter, description);
	        }
	
	        switch ((int) description[0]) {
	        // if the description begins with '<'...
	        case '<':
	            // throw an exception if the rule is a negative number
	            // rule
	            if (rule.GetBaseValue() == IBM.ICU.Text.NFRule.NEGATIVE_NUMBER_RULE) {
	                throw new ArgumentException(
	                        "<< not allowed in negative-number rule");
	            }
	
	            // if the rule is a fraction rule, return an
	            // IntegralPartSubstitution
	            else if (rule.GetBaseValue() == IBM.ICU.Text.NFRule.IMPROPER_FRACTION_RULE
	                    || rule.GetBaseValue() == IBM.ICU.Text.NFRule.PROPER_FRACTION_RULE
	                    || rule.GetBaseValue() == IBM.ICU.Text.NFRule.MASTER_RULE) {
	                return new IntegralPartSubstitution(pos_0, ruleSet_1, formatter,
	                        description);
	            }
	
	            // if the rule set containing the rule is a fraction
	            // rule set, return a NumeratorSubstitution
	            else if (ruleSet_1.IsFractionSet()) {
	                return new NumeratorSubstitution(pos_0, rule.GetBaseValue(),
	                        formatter.GetDefaultRuleSet(), formatter, description);
	            }
	
	            // otherwise, return a MultiplierSubstitution
	            else {
	                return new MultiplierSubstitution(pos_0, rule.GetDivisor(),
	                        ruleSet_1, formatter, description);
	            }
	
	            break;
	        // if the description begins with '>'...
	        case '>':
	            // if the rule is a negative-number rule, return
	            // an AbsoluteValueSubstitution
	            if (rule.GetBaseValue() == IBM.ICU.Text.NFRule.NEGATIVE_NUMBER_RULE) {
	                return new AbsoluteValueSubstitution(pos_0, ruleSet_1, formatter,
	                        description);
	            }
	
	            // if the rule is a fraction rule, return a
	            // FractionalPartSubstitution
	            else if (rule.GetBaseValue() == IBM.ICU.Text.NFRule.IMPROPER_FRACTION_RULE
	                    || rule.GetBaseValue() == IBM.ICU.Text.NFRule.PROPER_FRACTION_RULE
	                    || rule.GetBaseValue() == IBM.ICU.Text.NFRule.MASTER_RULE) {
	                return new FractionalPartSubstitution(pos_0, ruleSet_1, formatter,
	                        description);
	            }
	
	            // if the rule set owning the rule is a fraction rule set,
	            // throw an exception
	            else if (ruleSet_1.IsFractionSet()) {
	                throw new ArgumentException(
	                        ">> not allowed in fraction rule set");
	            }
	
	            // otherwise, return a ModulusSubstitution
	            else {
	                return new ModulusSubstitution(pos_0, rule.GetDivisor(),
	                        rulePredecessor, ruleSet_1, formatter, description);
	            }
	
	            break;
	        // if the description begins with '=', always return a
	            // SameValueSubstitution
	        case '=':
	            return new SameValueSubstitution(pos_0, ruleSet_1, formatter,
	                    description);
	
	            // and if it's anything else, throw an exception
	        default:
	            throw new ArgumentException("Illegal substitution character");
	        }
	    }
	
	    /// <summary>
	    /// Base constructor for substitutions. This constructor sets up the fields
	    /// which are common to all substitutions.
	    /// </summary>
	    ///
	    /// <param name="pos_0">The substitution's position in the owning rule's rule text</param>
	    /// <param name="ruleSet_1">The rule set that owns this substitution</param>
	    /// <param name="formatter">The RuleBasedNumberFormat that owns this substitution</param>
	    /// <param name="description">The substitution descriptor (i.e., the text inside the tokencharacters)</param>
	    internal NFSubstitution(int pos_0, NFRuleSet ruleSet_1, RuleBasedNumberFormat formatter,
	            String description) {
	        this.ruleSet = null;
	                this.numberFormat = null;
	        // initialize the substitution's position in its parent rule
	        this.pos = pos_0;
	
	        // the description should begin and end with the same character.
	        // If it doesn't that's a syntax error. Otherwise,
	        // makeSubstitution() was the only thing that needed to know
	        // about these characters, so strip them off
	        if (description.Length >= 2
	                && description[0] == description[description.Length - 1]) {
	            description = description.Substring(1,(description.Length - 1)-(1));
	        } else if (description.Length != 0) {
	            throw new ArgumentException("Illegal substitution syntax");
	        }
	
	        // if the description was just two paired token characters
	        // (i.e., "<<" or ">>"), it uses the rule set it belongs to to
	        // format its result
	        if (description.Length == 0) {
	            this.ruleSet = ruleSet_1;
	        }
	
	        // if the description contains a rule set name, that's the rule
	        // set we use to format the result: get a reference to the
	        // names rule set
	        else if (description[0] == '%') {
	            this.ruleSet = formatter.FindRuleSet(description);
	        }
	
	        // if the description begins with 0 or #, treat it as a
	        // DecimalFormat pattern, and initialize a DecimalFormat with
	        // that pattern (then set it to use the DecimalFormatSymbols
	        // belonging to our formatter)
	        else if (description[0] == '#' || description[0] == '0') {
	            this.numberFormat = new DecimalFormat(description);
	            this.numberFormat.SetDecimalFormatSymbols(formatter
	                    .GetDecimalFormatSymbols());
	        }
	
	        // if the description is ">>>", this substitution bypasses the
	        // usual rule-search process and always uses the rule that precedes
	        // it in its own rule set's rule list (this is used for place-value
	        // notations: formats where you want to see a particular part of
	        // a number even when it's 0)
	        else if (description[0] == '>') {
	            this.ruleSet = ruleSet_1; // was null, thai rules added to control
	                                    // space
	            this.numberFormat = null;
	        }
	
	        // and of the description is none of these things, it's a syntax error
	        else {
	            throw new ArgumentException("Illegal substitution syntax");
	        }
	    }
	
	    /// <summary>
	    /// Set's the substitution's divisor. Used by NFRule.setBaseValue(). A no-op
	    /// for all substitutions except multiplier and modulus substitutions.
	    /// </summary>
	    ///
	    /// <param name="radix">The radix of the divisor</param>
	    /// <param name="exponent">The exponent of the divisor</param>
	    public virtual void SetDivisor(int radix, int exponent) {
	        // a no-op for all substitutions except multiplier and modulus
	        // substitutions
	    }
	
	    // -----------------------------------------------------------------------
	    // boilerplate
	    // -----------------------------------------------------------------------
	
	    /// <summary>
	    /// Compares two substitutions for equality
	    /// </summary>
	    ///
	    /// <param name="The">substitution to compare this one to</param>
	    /// <returns>true if the two substitutions are functionally equivalent</returns>
	    public override bool Equals(Object that) {
	        // compare class and all of the fields all substitutions have
	        // in common
	        if ((Object) this.GetType() == (Object) that.GetType()) {
	            NFSubstitution that2 = (NFSubstitution) that;
	
	            return pos == that2.pos
	                    && ((ruleSet == null) ? that2.ruleSet == null : true) // can't
	                                                                        // compare
	                                                                        // tree
	                                                                        // structure,
	                                                                        // no
	                                                                        // .equals
	                                                                        // or
	                                                                        // recurse
	                    && ((numberFormat == null) ? (that2.numberFormat == null)
	                            : numberFormat.Equals(that2.numberFormat));
	        }
	        return false;
	    }
	
	    /// <summary>
	    /// Returns a textual description of the substitution
	    /// </summary>
	    ///
	    /// <returns>A textual description of the substitution. This might not be
	    /// identical to the description it was created from, but it'll
	    /// produce the same result.</returns>
	    public override String ToString() {
	        // use tokenChar() to get the character at the beginning and
	        // end of the substitution token. In between them will go
	        // either the name of the rule set it uses, or the pattern of
	        // the DecimalFormat it uses
	        if (ruleSet != null) {
	            return TokenChar() + ruleSet.GetName() + TokenChar();
	        } else {
	            return TokenChar() + numberFormat.ToPattern() + TokenChar();
	        }
	    }
	
	    // -----------------------------------------------------------------------
	    // formatting
	    // -----------------------------------------------------------------------
	
	    /// <summary>
	    /// Performs a mathematical operation on the number, formats it using either
	    /// ruleSet or decimalFormat, and inserts the result into toInsertInto.
	    /// </summary>
	    ///
	    /// <param name="number">The number being formatted.</param>
	    /// <param name="toInsertInto">The string we insert the result into</param>
	    /// <param name="pos_0">The position in toInsertInto where the owning rule's rule textbegins (this value is added to this substitution's position todetermine exactly where to insert the new text)</param>
	    public virtual void DoSubstitution(long number, StringBuilder toInsertInto, int pos_0) {
	        if (ruleSet != null) {
	            // perform a transformation on the number that is dependent
	            // on the type of substitution this is, then just call its
	            // rule set's format() method to format the result
	            long numberToFormat = TransformNumber(number);
	
	            ruleSet.Format(numberToFormat, toInsertInto, pos_0 + this.pos);
	        } else {
	            // or perform the transformation on the number (preserving
	            // the result's fractional part if the formatter it set
	            // to show it), then use that formatter's format() method
	            // to format the result
	            double numberToFormat_1 = TransformNumber((double) number);
	            if (numberFormat.GetMaximumFractionDigits() == 0) {
	                numberToFormat_1 = Math.Floor(numberToFormat_1);
	            }
	
	            toInsertInto.Insert(pos_0 + this.pos,
	                    numberFormat.Format(numberToFormat_1));
	        }
	    }
	
	    /// <summary>
	    /// Performs a mathematical operation on the number, formats it using either
	    /// ruleSet or decimalFormat, and inserts the result into toInsertInto.
	    /// </summary>
	    ///
	    /// <param name="number">The number being formatted.</param>
	    /// <param name="toInsertInto">The string we insert the result into</param>
	    /// <param name="pos_0">The position in toInsertInto where the owning rule's rule textbegins (this value is added to this substitution's position todetermine exactly where to insert the new text)</param>
	    public virtual void DoSubstitution(double number, StringBuilder toInsertInto, int pos_0) {
	        // perform a transformation on the number being formatted that
	        // is dependent on the type of substitution this is
	        double numberToFormat = TransformNumber(number);
	
	        // if the result is an integer, from here on out we work in integer
	        // space (saving time and memory and preserving accuracy)
	        if (numberToFormat == Math.Floor(numberToFormat) && ruleSet != null) {
	            ruleSet.Format((long) numberToFormat, toInsertInto, pos_0 + this.pos);
	
	            // if the result isn't an integer, then call either our rule set's
	            // format() method or our DecimalFormat's format() method to
	            // format the result
	        } else {
	            if (ruleSet != null) {
	                ruleSet.Format(numberToFormat, toInsertInto, pos_0 + this.pos);
	            } else {
	                toInsertInto.Insert(pos_0 + this.pos,
	                        numberFormat.Format(numberToFormat));
	            }
	        }
	    }
	
	    /// <summary>
	    /// Subclasses override this function to perform some kind of mathematical
	    /// operation on the number. The result of this operation is formatted using
	    /// the rule set or DecimalFormat that this substitution refers to, and the
	    /// result is inserted into the result string.
	    /// </summary>
	    ///
	    /// <param name="The">number being formatted</param>
	    /// <returns>The result of performing the opreration on the number</returns>
	    public abstract long TransformNumber(long number);
	
	    /// <summary>
	    /// Subclasses override this function to perform some kind of mathematical
	    /// operation on the number. The result of this operation is formatted using
	    /// the rule set or DecimalFormat that this substitution refers to, and the
	    /// result is inserted into the result string.
	    /// </summary>
	    ///
	    /// <param name="The">number being formatted</param>
	    /// <returns>The result of performing the opreration on the number</returns>
	    public abstract double TransformNumber(double number);
	
	    // -----------------------------------------------------------------------
	    // parsing
	    // -----------------------------------------------------------------------
	
	    /// <summary>
	    /// Parses a string using the rule set or DecimalFormat belonging to this
	    /// substitution. If there's a match, a mathematical operation (the inverse
	    /// of the one used in formatting) is performed on the result of the parse
	    /// and the value passed in and returned as the result. The parse position is
	    /// updated to point to the first unmatched character in the string.
	    /// </summary>
	    ///
	    /// <param name="text">The string to parse</param>
	    /// <param name="parsePosition">On entry, ignored, but assumed to be 0. On exit, this isupdated to point to the first unmatched character (or 0 if thesubstitution didn't match)</param>
	    /// <param name="baseValue">A partial parse result that should be combined with the resultof this parse</param>
	    /// <param name="upperBound">When searching the rule set for a rule matching the stringpassed in, only rules with base values lower than this areconsidered</param>
	    /// <param name="lenientParse">If true and matching against rules fails, the substitutionwill also try matching the text against numerals using adefault-costructed NumberFormat. If false, no extra work isdone. (This value is false whenever the formatter isn't inlenient-parse mode, but is also false under some conditionseven when the formatter _is_ in lenient-parse mode.)</param>
	    /// <returns>If there's a match, this is the result of composing baseValue
	    /// with whatever was returned from matching the characters. This
	    /// will be either a Long or a Double. If there's no match this is
	    /// new Long(0) (not null), and parsePosition is left unchanged.</returns>
	    public virtual object DoParse(String text, ParsePosition parsePosition,
	            double baseValue, double upperBound, bool lenientParse) {
	        object tempResult;
	
	        // figure out the highest base value a rule can have and match
	        // the text being parsed (this varies according to the type of
	        // substitutions: multiplier, modulus, and numerator substitutions
	        // restrict the search to rules with base values lower than their
	        // own; same-value substitutions leave the upper bound wherever
	        // it was, and the others allow any rule to match
	        upperBound = CalcUpperBound(upperBound);
	
	        // use our rule set to parse the text. If that fails and
	        // lenient parsing is enabled (this is always false if the
	        // formatter's lenient-parsing mode is off, but it may also
	        // be false even when the formatter's lenient-parse mode is
	        // on), then also try parsing the text using a default-
	        // constructed NumberFormat
	        if (ruleSet != null) {
	            tempResult = ruleSet.Parse(text, parsePosition, upperBound);
	            if (lenientParse && !ruleSet.IsFractionSet()
	                    && parsePosition.GetIndex() == 0) {
	                tempResult = IBM.ICU.Text.NumberFormat.GetInstance().Parse(text,
	                        parsePosition);
	            }
	
	            // ...or use our DecimalFormat to parse the text
	        } else {
	            tempResult = numberFormat.Parse(text, parsePosition);
	        }
	
	        // if the parse was successful, we've already advanced the caller's
	        // parse position (this is the one function that doesn't have one
	        // of its own). Derive a parse result and return it as a Long,
	        // if possible, or a Double
	        if (parsePosition.GetIndex() != 0) {
	            double result = Convert.ToDouble(tempResult);
	
	            // composeRuleValue() produces a full parse result from
	            // the partial parse result passed to this function from
	            // the caller (this is either the owning rule's base value
	            // or the partial result obtained from composing the
	            // owning rule's base value with its other substitution's
	            // parse result) and the partial parse result obtained by
	            // matching the substitution (which will be the same value
	            // the caller would get by parsing just this part of the
	            // text with RuleBasedNumberFormat.parse() ). How the two
	            // values are used to derive the full parse result depends
	            // on the types of substitutions: For a regular rule, the
	            // ultimate result is its multiplier substitution's result
	            // times the rule's divisor (or the rule's base value) plus
	            // the modulus substitution's result (which will actually
	            // supersede part of the rule's base value). For a negative-
	            // number rule, the result is the negative of its substitution's
	            // result. For a fraction rule, it's the sum of its two
	            // substitution results. For a rule in a fraction rule set,
	            // it's the numerator substitution's result divided by
	            // the rule's base value. Results from same-value substitutions
	            // propagate back upard, and null substitutions don't affect
	            // the result.
	            result = ComposeRuleValue(result, baseValue);
	            if (result == (long) result) {
	                return (long)((long) result);
	            } else {
	                return (double )(result);
	            }
	
	            // if the parse was UNsuccessful, return 0
	        } else {
	            return tempResult;
	        }
	    }
	
	    /// <summary>
	    /// Derives a new value from the two values passed in. The two values are
	    /// typically either the base values of two rules (the one containing the
	    /// substitution and the one matching the substitution) or partial parse
	    /// results derived in some other way. The operation is generally the inverse
	    /// of the operation performed by transformNumber().
	    /// </summary>
	    ///
	    /// <param name="newRuleValue">The value produced by matching this substitution</param>
	    /// <param name="oldRuleValue">The value that was passed to the substitution by the rule thatowns it</param>
	    /// <returns>A third value derived from the other two, representing a partial
	    /// parse result</returns>
	    public abstract double ComposeRuleValue(double newRuleValue,
	            double oldRuleValue);
	
	    /// <summary>
	    /// Calculates an upper bound when searching for a rule that matches this
	    /// substitution. Rules with base values greater than or equal to upperBound
	    /// are not considered.
	    /// </summary>
	    ///
	    /// <param name="oldUpperBound">The current upper-bound setting. The new upper bound can't beany higher.</param>
	    public abstract double CalcUpperBound(double oldUpperBound);
	
	    // -----------------------------------------------------------------------
	    // simple accessors
	    // -----------------------------------------------------------------------
	
	    /// <summary>
	    /// Returns the substitution's position in the rule that owns it.
	    /// </summary>
	    ///
	    /// <returns>The substitution's position in the rule that owns it.</returns>
	    public int GetPos() {
	        return pos;
	    }
	
	    /// <summary>
	    /// Returns the character used in the textual representation of substitutions
	    /// of this type. Used by toString().
	    /// </summary>
	    ///
	    /// <returns>This substitution's token character.</returns>
	    abstract internal char TokenChar();
	
	    /// <summary>
	    /// Returns true if this is a null substitution. (We didn't do this with
	    /// instanceof partially because it causes source files to proliferate and
	    /// partially because we have to port this to C++.)
	    /// </summary>
	    ///
	    /// <returns>true if this object is an instance of NullSubstitution</returns>
	    public virtual bool IsNullSubstitution() {
	        return false;
	    }
	
	    /// <summary>
	    /// Returns true if this is a modulus substitution. (We didn't do this with
	    /// instanceof partially because it causes source files to proliferate and
	    /// partially because we have to port this to C++.)
	    /// </summary>
	    ///
	    /// <returns>true if this object is an instance of ModulusSubstitution</returns>
	    public virtual bool IsModulusSubstitution() {
	        return false;
	    }
	}
	
	// ===================================================================
	// SameValueSubstitution
	// ===================================================================
	
	/// <summary>
	/// A substitution that passes the value passed to it through unchanged.
	/// Represented by == in rule descriptions.
	/// </summary>
	///
	internal class SameValueSubstitution : NFSubstitution {
	    // -----------------------------------------------------------------------
	    // construction
	    // -----------------------------------------------------------------------
	
	    /// <summary>
	    /// Constructs a SameValueSubstution. This function just uses the superclass
	    /// constructor, but it performs a check that this substitution doesn't call
	    /// the rule set that owns it, since that would lead to infinite recursion.
	    /// </summary>
	    ///
	    internal SameValueSubstitution(int pos_0, NFRuleSet ruleSet_1,
	            RuleBasedNumberFormat formatter, String description) : base(pos_0, ruleSet_1, formatter, description) {
	        if (description.Equals("==")) {
	            throw new ArgumentException("== is not a legal token");
	        }
	    }
	
	    // -----------------------------------------------------------------------
	    // formatting
	    // -----------------------------------------------------------------------
	
	    /// <summary>
	    /// Returns "number" unchanged.
	    /// </summary>
	    ///
	    /// <returns>"number"</returns>
	    public override long TransformNumber(long number) {
	        return number;
	    }
	
	    /// <summary>
	    /// Returns "number" unchanged.
	    /// </summary>
	    ///
	    /// <returns>"number"</returns>
	    public override double TransformNumber(double number) {
	        return number;
	    }
	
	    // -----------------------------------------------------------------------
	    // parsing
	    // -----------------------------------------------------------------------
	
	    /// <summary>
	    /// Returns newRuleValue and ignores oldRuleValue. (The value we got matching
	    /// the substitution supersedes the value of the rule that owns the
	    /// substitution.)
	    /// </summary>
	    ///
	    /// <param name="newRuleValue">The value resulting from matching the substituion</param>
	    /// <param name="oldRuleValue">The value of the rule containing the substitution.</param>
	    /// <returns>newRuleValue</returns>
	    public override double ComposeRuleValue(double newRuleValue, double oldRuleValue) {
	        return newRuleValue;
	    }
	
	    /// <summary>
	    /// SameValueSubstitution doesn't change the upper bound.
	    /// </summary>
	    ///
	    /// <param name="oldUpperBound">The current upper bound.</param>
	    /// <returns>oldUpperBound</returns>
	    public override double CalcUpperBound(double oldUpperBound) {
	        return oldUpperBound;
	    }
	
	    // -----------------------------------------------------------------------
	    // simple accessor
	    // -----------------------------------------------------------------------
	
	    /// <summary>
	    /// The token character for a SameValueSubstitution is =.
	    /// </summary>
	    ///
	    /// <returns>'='</returns>
	    internal override char TokenChar() {
	        return '=';
	    }
	}
	
	// ===================================================================
	// MultiplierSubstitution
	// ===================================================================
	
	/// <summary>
	/// A substitution that divides the number being formatted by the rule's divisor
	/// and formats the quotient. Represented by &lt;&lt; in normal rules.
	/// </summary>
	///
	internal class MultiplierSubstitution : NFSubstitution {
	    // -----------------------------------------------------------------------
	    // data members
	    // -----------------------------------------------------------------------
	
	    /// <summary>
	    /// The divisor of the rule that owns this substitution.
	    /// </summary>
	    ///
	    internal double divisor;
	
	    // -----------------------------------------------------------------------
	    // construction
	    // -----------------------------------------------------------------------
	
	    /// <summary>
	    /// Constructs a MultiplierSubstitution. This uses the superclass constructor
	    /// to initialize most members, but this substitution also maintains its own
	    /// copy of its rule's divisor.
	    /// </summary>
	    ///
	    /// <param name="pos_0">The substitution's position in its rule's rule text</param>
	    /// <param name="divisor_1">The owning rule's divisor</param>
	    /// @ruleSet The ruleSet this substitution uses to format its result
	    /// @formatter The formatter that owns this substitution
	    /// @description The description describing this substitution
	    internal MultiplierSubstitution(int pos_0, double divisor_1, NFRuleSet ruleSet_2,
	            RuleBasedNumberFormat formatter, String description) : base(pos_0, ruleSet_2, formatter, description) {
	        // the owning rule's divisor affects the behavior of this
	        // substitution. Rather than keeping a back-pointer to the
	        // rule, we keep a copy of the divisor
	        this.divisor = divisor_1;
	
	        if (divisor_1 == 0) { // this will cause recursion
	            throw new InvalidOperationException("Substitution with bad divisor ("
	                    + divisor_1 + ") " + description.Substring(0,(pos_0)-(0)) + " | "
	                    + description.Substring(pos_0));
	        }
	    }
	
	    /// <summary>
	    /// Sets the substitution's divisor based on the values passed in.
	    /// </summary>
	    ///
	    /// <param name="radix">The radix of the divisor.</param>
	    /// <param name="exponent">The exponent of the divisor.</param>
	    public override void SetDivisor(int radix, int exponent) {
	        divisor = Math.Pow(radix,exponent);
	
	        if (divisor == 0) {
	            throw new InvalidOperationException("Substitution with divisor 0");
	        }
	    }
	
	    // -----------------------------------------------------------------------
	    // boilerplate
	    // -----------------------------------------------------------------------
	
	    /// <summary>
	    /// Augments the superclass's equals() function by comparing divisors.
	    /// </summary>
	    ///
	    /// <param name="that">The other substitution</param>
	    /// <returns>true if the two substitutions are functionally equal</returns>
	    public override bool Equals(Object that) {
	        if (base.Equals(that)) {
	            MultiplierSubstitution that2 = (MultiplierSubstitution) that;
	
	            return divisor == that2.divisor;
	        } else {
	            return false;
	        }
	    }
	
	    // -----------------------------------------------------------------------
	    // formatting
	    // -----------------------------------------------------------------------
	
	    /// <summary>
	    /// Divides the number by the rule's divisor and returns the quotient.
	    /// </summary>
	    ///
	    /// <param name="number">The number being formatted.</param>
	    /// <returns>"number" divided by the rule's divisor</returns>
	    public override long TransformNumber(long number) {
	        return (long) Math.Floor(number / divisor);
	    }
	
	    /// <summary>
	    /// Divides the number by the rule's divisor and returns the quotient. This
	    /// is an integral quotient if we're filling in the substitution using
	    /// another rule set, but it's the full quotient (integral and fractional
	    /// parts) if we're filling in the substitution using a DecimalFormat. (This
	    /// allows things such as "1.2 million".)
	    /// </summary>
	    ///
	    /// <param name="number">The number being formatted</param>
	    /// <returns>"number" divided by the rule's divisor</returns>
	    public override double TransformNumber(double number) {
	        if (ruleSet == null) {
	            return number / divisor;
	        } else {
	            return Math.Floor(number / divisor);
	        }
	    }
	
	    // -----------------------------------------------------------------------
	    // parsing
	    // -----------------------------------------------------------------------
	
	    /// <summary>
	    /// Returns newRuleValue times the divisor. Ignores oldRuleValue. (The result
	    /// of matching a << substitution supersedes the base value of the rule that
	    /// contains it.)
	    /// </summary>
	    ///
	    /// <param name="newRuleValue">The result of matching the substitution</param>
	    /// <param name="oldRuleValue">The base value of the rule containing the substitution</param>
	    /// <returns>newRuleValue /// divisor</returns>
	    public override double ComposeRuleValue(double newRuleValue, double oldRuleValue) {
	        return newRuleValue * divisor;
	    }
	
	    /// <summary>
	    /// Sets the upper bound down to the rule's divisor.
	    /// </summary>
	    ///
	    /// <param name="oldUpperBound">Ignored.</param>
	    /// <returns>The rule's divisor.</returns>
	    public override double CalcUpperBound(double oldUpperBound) {
	        return divisor;
	    }
	
	    // -----------------------------------------------------------------------
	    // simple accessor
	    // -----------------------------------------------------------------------
	
	    /// <summary>
	    /// The token character for a multiplier substitution is &lt;.
	    /// </summary>
	    ///
	    /// <returns>'&lt;'</returns>
	    internal override char TokenChar() {
	        return '<';
	    }
	}
	
	// ===================================================================
	// ModulusSubstitution
	// ===================================================================
	
	/// <summary>
	/// A substitution that divides the number being formatted by the its rule's
	/// divisor and formats the remainder. Represented by "&gt;&gt;" in a regular
	/// rule.
	/// </summary>
	///
	internal class ModulusSubstitution : NFSubstitution {
	    // -----------------------------------------------------------------------
	    // data members
	    // -----------------------------------------------------------------------
	
	    /// <summary>
	    /// The divisor of the rule owning this substitution
	    /// </summary>
	    ///
	    internal double divisor;
	
	    /// <summary>
	    /// If this is a &gt;&gt;&gt; substitution, the rule to use to format the
	    /// substitution value. Otherwise, null.
	    /// </summary>
	    ///
	    internal NFRule ruleToUse;
	
	    // -----------------------------------------------------------------------
	    // construction
	    // -----------------------------------------------------------------------
	
	    /// <summary>
	    /// Constructs a ModulusSubstution. In addition to the inherited members, a
	    /// ModulusSubstitution keeps track of the divisor of the rule that owns it,
	    /// and may also keep a reference to the rule that precedes the rule
	    /// containing this substitution in the rule set's rule list.
	    /// </summary>
	    ///
	    /// <param name="pos_0">The substitution's position in its rule's rule text</param>
	    /// <param name="divisor_1">The divisor of the rule that owns this substitution</param>
	    /// <param name="rulePredecessor">The rule that precedes this substitution's rule in its ruleset's rule list</param>
	    /// <param name="formatter">The RuleBasedNumberFormat owning this substitution</param>
	    /// <param name="description">The description for this substitution</param>
	    internal ModulusSubstitution(int pos_0, double divisor_1, NFRule rulePredecessor,
	            NFRuleSet ruleSet_2, RuleBasedNumberFormat formatter,
	            String description) : base(pos_0, ruleSet_2, formatter, description) {
	        // the owning rule's divisor controls the behavior of this
	        // substitution: rather than keeping a backpointer to the rule,
	        // we keep a copy of the divisor
	        this.divisor = divisor_1;
	
	        if (divisor_1 == 0) { // this will cause recursion
	            throw new InvalidOperationException("Substitution with bad divisor ("
	                    + divisor_1 + ") " + description.Substring(0,(pos_0)-(0)) + " | "
	                    + description.Substring(pos_0));
	        }
	
	        // the >>> token doesn't alter how this substituion calculates the
	        // values it uses for formatting and parsing, but it changes
	        // what's done with that value after it's obtained: >>> short-
	        // circuits the rule-search process and goes straight to the
	        // specified rule to format the substitution value
	        if (description.Equals(">>>")) {
	            ruleToUse = rulePredecessor;
	        } else {
	            ruleToUse = null;
	        }
	    }
	
	    /// <summary>
	    /// Makes the substitution's divisor conform to that of the rule that owns
	    /// it. Used when the divisor is determined after creation.
	    /// </summary>
	    ///
	    /// <param name="radix">The radix of the divsor.</param>
	    /// <param name="exponent">The exponent of the divisor.</param>
	    public override void SetDivisor(int radix, int exponent) {
	        divisor = Math.Pow(radix,exponent);
	
	        if (divisor == 0) { // this will cause recursion
	            throw new InvalidOperationException("Substitution with bad divisor");
	        }
	    }
	
	    // -----------------------------------------------------------------------
	    // boilerplate
	    // -----------------------------------------------------------------------
	
	    /// <summary>
	    /// Augments the inherited equals() function by comparing divisors and
	    /// ruleToUse.
	    /// </summary>
	    ///
	    /// <param name="that">The other substitution</param>
	    /// <returns>true if the two substitutions are functionally equivalent</returns>
	    public override bool Equals(Object that) {
	        if (base.Equals(that)) {
	            ModulusSubstitution that2 = (ModulusSubstitution) that;
	
	            return divisor == that2.divisor;
	        } else {
	            return false;
	        }
	    }
	
	    // -----------------------------------------------------------------------
	    // formatting
	    // -----------------------------------------------------------------------
	
	    /// <summary>
	    /// If this is a &gt;&gt;&gt; substitution, use ruleToUse to fill in the
	    /// substitution. Otherwise, just use the superclass function.
	    /// </summary>
	    ///
	    /// <param name="number">The number being formatted</param>
	    /// @toInsertInto The string to insert the result of this substitution into
	    /// <param name="pos_0">The position of the rule text in toInsertInto</param>
	    public override void DoSubstitution(long number, StringBuilder toInsertInto, int pos_0) {
	        // if this isn't a >>> substitution, just use the inherited version
	        // of this function (which uses either a rule set or a DecimalFormat
	        // to format its substitution value)
	        if (ruleToUse == null) {
	            base.DoSubstitution(number,toInsertInto,pos_0);
	
	            // a >>> substitution goes straight to a particular rule to
	            // format the substitution value
	        } else {
	            long numberToFormat = TransformNumber(number);
	            ruleToUse.DoFormat(numberToFormat, toInsertInto, pos_0 + this.pos);
	        }
	    }
	
	    /// <summary>
	    /// If this is a &gt;&gt;&gt; substitution, use ruleToUse to fill in the
	    /// substitution. Otherwise, just use the superclass function.
	    /// </summary>
	    ///
	    /// <param name="number">The number being formatted</param>
	    /// @toInsertInto The string to insert the result of this substitution into
	    /// <param name="pos_0">The position of the rule text in toInsertInto</param>
	    public override void DoSubstitution(double number, StringBuilder toInsertInto, int pos_0) {
	        // if this isn't a >>> substitution, just use the inherited version
	        // of this function (which uses either a rule set or a DecimalFormat
	        // to format its substitution value)
	        if (ruleToUse == null) {
	            base.DoSubstitution(number,toInsertInto,pos_0);
	
	            // a >>> substitution goes straight to a particular rule to
	            // format the substitution value
	        } else {
	            double numberToFormat = TransformNumber(number);
	
	            ruleToUse.DoFormat(numberToFormat, toInsertInto, pos_0 + this.pos);
	        }
	    }
	
	    /// <summary>
	    /// Divides the number being formatted by the rule's divisor and returns the
	    /// remainder.
	    /// </summary>
	    ///
	    /// <param name="number">The number being formatted</param>
	    /// <returns>"number" mod divisor</returns>
	    public override long TransformNumber(long number) {
	        return (long) Math.Floor(number % divisor);
	    }
	
	    /// <summary>
	    /// Divides the number being formatted by the rule's divisor and returns the
	    /// remainder.
	    /// </summary>
	    ///
	    /// <param name="number">The number being formatted</param>
	    /// <returns>"number" mod divisor</returns>
	    public override double TransformNumber(double number) {
	        return Math.Floor(number % divisor);
	    }
	
	    // -----------------------------------------------------------------------
	    // parsing
	    // -----------------------------------------------------------------------
	
	    /// <summary>
	    /// If this is a &gt;&gt;&gt; substitution, match only against ruleToUse.
	    /// Otherwise, use the superclass function.
	    /// </summary>
	    ///
	    /// <param name="text">The string to parse</param>
	    /// <param name="parsePosition">Ignored on entry, updated on exit to point to the firstunmatched character.</param>
	    /// <param name="baseValue">The partial parse result prior to calling this routine.</param>
	    public override object DoParse(String text, ParsePosition parsePosition,
	            double baseValue, double upperBound, bool lenientParse) {
	        // if this isn't a >>> substitution, we can just use the
	        // inherited parse() routine to do the parsing
	        if (ruleToUse == null) {
	            return base.DoParse(text,parsePosition,baseValue,upperBound,lenientParse);
	
	            // but if it IS a >>> substitution, we have to do it here: we
	            // use the specific rule's doParse() method, and then we have to
	            // do some of the other work of NFRuleSet.parse()
	        } else {
	            object tempResult = ruleToUse.DoParse(text, parsePosition, false,
	                    upperBound);
	
	            if (parsePosition.GetIndex() != 0) {
	                double result = Convert.ToDouble(tempResult);
	
	                result = ComposeRuleValue(result, baseValue);
	                if (result == (long) result) {
	                    return (long)((long) result);
	                } else {
	                    return (double )(result);
	                }
	            } else {
	                return tempResult;
	            }
	        }
	    }
	
	    /// <summary>
	    /// Returns the highest multiple of the rule's divisor that its less than or
	    /// equal to oldRuleValue, plus newRuleValue. (The result is the sum of the
	    /// result of parsing the substitution plus the base valueof the rule
	    /// containing the substitution, but if the owning rule's base value isn't an
	    /// even multiple of its divisor, we have to round it down to a multiple of
	    /// the divisor, or we get unwanted digits in the result.)
	    /// </summary>
	    ///
	    /// <param name="newRuleValue">The result of parsing the substitution</param>
	    /// <param name="oldRuleValue">The base value of the rule containing the substitution</param>
	    /// <returns>(oldRuleValue - (oldRuleValue % divisor)) + newRuleValue</returns>
	    public override double ComposeRuleValue(double newRuleValue, double oldRuleValue) {
	        return (oldRuleValue - (oldRuleValue % divisor)) + newRuleValue;
	    }
	
	    /// <summary>
	    /// Sets the upper bound down to the owning rule's divisor
	    /// </summary>
	    ///
	    /// <param name="oldUpperBound">Ignored</param>
	    /// <returns>The owning rule's dvisor</returns>
	    public override double CalcUpperBound(double oldUpperBound) {
	        return divisor;
	    }
	
	    // -----------------------------------------------------------------------
	    // simple accessors
	    // -----------------------------------------------------------------------
	
	    /// <summary>
	    /// Returns true. This _is_ a ModulusSubstitution.
	    /// </summary>
	    ///
	    /// <returns>true</returns>
	    public override bool IsModulusSubstitution() {
	        return true;
	    }
	
	    /// <summary>
	    /// The token character of a ModulusSubstitution is &gt;.
	    /// </summary>
	    ///
	    /// <returns>'&gt;'</returns>
	    internal override char TokenChar() {
	        return '>';
	    }
	}
	
	// ===================================================================
	// IntegralPartSubstitution
	// ===================================================================
	
	/// <summary>
	/// A substitution that formats the number's integral part. This is represented
	/// by &lt;&lt; in a fraction rule.
	/// </summary>
	///
	internal class IntegralPartSubstitution : NFSubstitution {
	    // -----------------------------------------------------------------------
	    // construction
	    // -----------------------------------------------------------------------
	
	    /// <summary>
	    /// Constructs an IntegralPartSubstitution. This just calls the superclass
	    /// constructor.
	    /// </summary>
	    ///
	    internal IntegralPartSubstitution(int pos_0, NFRuleSet ruleSet_1,
	            RuleBasedNumberFormat formatter, String description) : base(pos_0, ruleSet_1, formatter, description) {
	    }
	
	    // -----------------------------------------------------------------------
	    // formatting
	    // -----------------------------------------------------------------------
	
	    /// <summary>
	    /// Returns the number's integral part. (For a long, that's just the number
	    /// unchanged.)
	    /// </summary>
	    ///
	    /// <param name="number">The number being formatted</param>
	    /// <returns>"number" unchanged</returns>
	    public override long TransformNumber(long number) {
	        return number;
	    }
	
	    /// <summary>
	    /// Returns the number's integral part.
	    /// </summary>
	    ///
	    /// <param name="number">The integral part of the number being formatted</param>
	    /// <returns>floor(number)</returns>
	    public override double TransformNumber(double number) {
	        return Math.Floor(number);
	    }
	
	    // -----------------------------------------------------------------------
	    // parsing
	    // -----------------------------------------------------------------------
	
	    /// <summary>
	    /// Returns the sum of the result of parsing the substitution and the owning
	    /// rule's base value. (The owning rule, at best, has an integral-part
	    /// substitution and a fractional-part substitution, so we can safely just
	    /// add them.)
	    /// </summary>
	    ///
	    /// <param name="newRuleValue">The result of matching the substitution</param>
	    /// <param name="oldRuleValue">The partial result of the parse prior to calling this function</param>
	    /// <returns>oldRuleValue + newRuleValue</returns>
	    public override double ComposeRuleValue(double newRuleValue, double oldRuleValue) {
	        return newRuleValue + oldRuleValue;
	    }
	
	    /// <summary>
	    /// An IntegralPartSubstitution sets the upper bound back up so all
	    /// potentially matching rules are considered.
	    /// </summary>
	    ///
	    /// <param name="oldUpperBound">Ignored</param>
	    /// <returns>Double.MAX_VALUE</returns>
	    public override double CalcUpperBound(double oldUpperBound) {
	        return System.Double.MaxValue;
	    }
	
	    // -----------------------------------------------------------------------
	    // simple accessor
	    // -----------------------------------------------------------------------
	
	    /// <summary>
	    /// An IntegralPartSubstitution's token character is &lt;
	    /// </summary>
	    ///
	    /// <returns>'&lt;'</returns>
	    internal override char TokenChar() {
	        return '<';
	    }
	}
	
	// ===================================================================
	// FractionalPartSubstitution
	// ===================================================================
	
	/// <summary>
	/// A substitution that formats the fractional part of a number. This is
	/// represented by &gt;&gt; in a fraction rule.
	/// </summary>
	///
	internal class FractionalPartSubstitution : NFSubstitution {
	    // -----------------------------------------------------------------------
	    // data members
	    // -----------------------------------------------------------------------
	
	    /// <summary>
	    /// true if this substitution should have the default "by digits" behavior,
	    /// false otherwise
	    /// </summary>
	    ///
	    private bool byDigits;
	
	    /// <summary>
	    /// true if we automatically insert spaces to separate names of digits set to
	    /// false by '>>>' in fraction rules, used by Thai.
	    /// </summary>
	    ///
	    private bool useSpaces;
	
	    /*
	     * The largest number of digits after the decimal point that this object
	     * will show in "by digits" mode
	     */
	    // private static final int MAXDECIMALDIGITS = 18; // 8
	
	    // -----------------------------------------------------------------------
	    // construction
	    // -----------------------------------------------------------------------
	
	    /// <summary>
	    /// Constructs a FractionalPartSubstitution. This object keeps a flag telling
	    /// whether it should format by digits or not. In addition, it marks the rule
	    /// set it calls (if any) as a fraction rule set.
	    /// </summary>
	    ///
	    internal FractionalPartSubstitution(int pos_0, NFRuleSet ruleSet_1,
	            RuleBasedNumberFormat formatter, String description) : base(pos_0, ruleSet_1, formatter, description) {
	        // boolean chevron = description.startsWith(">>") || ruleSet ==
	        // this.ruleSet;
	        // if (chevron || ruleSet == this.ruleSet) {
	        this.byDigits = false;
	        this.useSpaces = true;
	
	        if (description.Equals(">>") || description.Equals(">>>")
	                || ruleSet_1 == this.ruleSet) {
	            byDigits = true;
	            if (description.Equals(">>>")) {
	                useSpaces = false;
	            }
	        } else {
	            this.ruleSet.MakeIntoFractionRuleSet();
	        }
	    }
	
	    // -----------------------------------------------------------------------
	    // formatting
	    // -----------------------------------------------------------------------
	
	    /// <summary>
	    /// If in "by digits" mode, fills in the substitution one decimal digit at a
	    /// time using the rule set containing this substitution. Otherwise, uses the
	    /// superclass function.
	    /// </summary>
	    ///
	    /// <param name="number">The number being formatted</param>
	    /// <param name="toInsertInto">The string to insert the result of formatting the substitutioninto</param>
	    /// <param name="pos_0">The position of the owning rule's rule text in toInsertInto</param>
	    public override void DoSubstitution(double number, StringBuilder toInsertInto, int pos_0) {
	        // if we're not in "byDigits" mode, just use the inherited
	        // doSubstitution() routine
	        if (!byDigits) {
	            base.DoSubstitution(number,toInsertInto,pos_0);
	
	            // if we're in "byDigits" mode, transform the value into an integer
	            // by moving the decimal point eight places to the right and
	            // pulling digits off the right one at a time, formatting each digit
	            // as an integer using this substitution's owning rule set
	            // (this is slower, but more accurate, than doing it from the
	            // other end)
	        } else {
	            // int numberToFormat = (int)Math.round(transformNumber(number) *
	            // Math.pow(
	            // 10, MAXDECIMALDIGITS));
	            // long numberToFormat = (long)Math.round(transformNumber(number) *
	            // Math.pow(10, MAXDECIMALDIGITS));
	
	            // just print to string and then use that
	            DigitList dl = new DigitList();
	            dl.Set(number, 20, true);
	
	            // this flag keeps us from formatting trailing zeros. It starts
	            // out false because we're pulling from the right, and switches
	            // to true the first time we encounter a non-zero digit
	            // boolean doZeros = false;
	            // System.out.println("class: " + getClass().getName());
	            // System.out.println("number: " + number + " transformed: " +
	            // transformNumber(number));
	            // System.out.println("formatting " + numberToFormat);
	            // for (int i = 0; i < MAXDECIMALDIGITS; i++) {
	            // int digit = (int)(numberToFormat % 10);
	            // System.out.println("   #: '" + numberToFormat + "'" + " digit '"
	            // + digit + "'");
	            // if (digit != 0 || doZeros) {
	            // if (doZeros && useSpaces) {
	            // toInsertInto.insert(pos + this.pos, ' ');
	            // }
	            // doZeros = true;
	            // ruleSet.format(digit, toInsertInto, pos + this.pos);
	            // }
	            // numberToFormat /= 10;
	            // }
	
	            bool pad = false;
	            while (dl.count > Math.Max(0,dl.decimalAt)) {
	                if (pad && useSpaces) {
	                    toInsertInto.Insert(pos_0 + this.pos, ' ');
	                } else {
	                    pad = true;
	                }
	                ruleSet.Format(dl.digits[--dl.count] - '0', toInsertInto, pos_0
	                        + this.pos);
	            }
	            while (dl.decimalAt < 0) {
	                if (pad && useSpaces) {
	                    toInsertInto.Insert(pos_0 + this.pos, ' ');
	                } else {
	                    pad = true;
	                }
	                ruleSet.Format(0, toInsertInto, pos_0 + this.pos);
	                ++dl.decimalAt;
	            }
	        }
	    }
	
	    /// <summary>
	    /// Returns the fractional part of the number, which will always be zero if
	    /// it's a long.
	    /// </summary>
	    ///
	    /// <param name="number">The number being formatted</param>
	    /// <returns>0</returns>
	    public override long TransformNumber(long number) {
	        return 0;
	    }
	
	    /// <summary>
	    /// Returns the fractional part of the number.
	    /// </summary>
	    ///
	    /// <param name="number">The number being formatted.</param>
	    /// <returns>number - floor(number)</returns>
	    public override double TransformNumber(double number) {
	        return number - Math.Floor(number);
	    }
	
	    // -----------------------------------------------------------------------
	    // parsing
	    // -----------------------------------------------------------------------
	
	    /// <summary>
	    /// If in "by digits" mode, parses the string as if it were a string of
	    /// individual digits; otherwise, uses the superclass function.
	    /// </summary>
	    ///
	    /// <param name="text">The string to parse</param>
	    /// <param name="parsePosition">Ignored on entry, but updated on exit to point to the firstunmatched character</param>
	    /// <param name="baseValue">The partial parse result prior to entering this function</param>
	    /// <param name="upperBound">Only consider rules with base values lower than this whenfilling in the substitution</param>
	    /// <param name="lenientParse">If true, try matching the text as numerals if matching aswords doesn't work</param>
	    /// <returns>If the match was successful, the current partial parse result;
	    /// otherwise new Long(0). The result is either a Long or a Double.</returns>
	    public override object DoParse(String text, ParsePosition parsePosition,
	            double baseValue, double upperBound, bool lenientParse) {
	        // if we're not in byDigits mode, we can just use the inherited
	        // doParse()
	        if (!byDigits) {
	            return base.DoParse(text,parsePosition,baseValue,0,lenientParse);
	
	            // if we ARE in byDigits mode, parse the text one digit at a time
	            // using this substitution's owning rule set (we do this by setting
	            // upperBound to 10 when calling doParse() ) until we reach
	            // nonmatching text
	        } else {
	            String workText = text;
	            ParsePosition workPos = new ParsePosition(1);
	            double result = 0;
	            int digit;
	            // double p10 = 0.1;
	
	            // while (workText.length() > 0 && workPos.getIndex() != 0) {
	            // workPos.setIndex(0);
	            // digit = ruleSet.parse(workText, workPos, 10).intValue();
	            // if (lenientParse && workPos.getIndex() == 0) {
	            // digit = NumberFormat.getInstance().parse(workText,
	            // workPos).intValue();
	            // }
	
	            // if (workPos.getIndex() != 0) {
	            // result += digit * p10;
	            // p10 /= 10;
	            // parsePosition.setIndex(parsePosition.getIndex() +
	            // workPos.getIndex());
	            // workText = workText.substring(workPos.getIndex());
	            // while (workText.length() > 0 && workText.charAt(0) == ' ') {
	            // workText = workText.substring(1);
	            // parsePosition.setIndex(parsePosition.getIndex() + 1);
	            // }
	            // }
	            // }
	
	            DigitList dl = new DigitList();
	            while (workText.Length > 0 && workPos.GetIndex() != 0) {
	                workPos.SetIndex(0);
	                digit = System.Convert.ToInt32(ruleSet.Parse(workText, workPos, 10));
	                if (lenientParse && workPos.GetIndex() == 0) {
	                    digit = System.Convert.ToInt32(IBM.ICU.Text.NumberFormat.GetInstance().Parse(workText, workPos));
	                }
	
	                if (workPos.GetIndex() != 0) {
	                    dl.Append('0' + digit);
	
	                    parsePosition.SetIndex(parsePosition.GetIndex()
	                            + workPos.GetIndex());
	                    workText = workText.Substring(workPos.GetIndex());
	                    while (workText.Length > 0 && workText[0] == ' ') {
	                        workText = workText.Substring(1);
	                        parsePosition.SetIndex(parsePosition.GetIndex() + 1);
	                    }
	                }
	            }
	            result = (dl.count == 0) ? (double) (0) : (double) (dl.GetDouble());
	
	            result = ComposeRuleValue(result, baseValue);
	            return (double )(result);
	        }
	    }
	
	    /// <summary>
	    /// Returns the sum of the two partial parse results.
	    /// </summary>
	    ///
	    /// <param name="newRuleValue">The result of parsing the substitution</param>
	    /// <param name="oldRuleValue">The partial parse result prior to calling this function</param>
	    /// <returns>newRuleValue + oldRuleValue</returns>
	    public override double ComposeRuleValue(double newRuleValue, double oldRuleValue) {
	        return newRuleValue + oldRuleValue;
	    }
	
	    /// <summary>
	    /// Not used.
	    /// </summary>
	    ///
	    public override double CalcUpperBound(double oldUpperBound) {
	        return 0; // this value is ignored
	    }
	
	    // -----------------------------------------------------------------------
	    // simple accessor
	    // -----------------------------------------------------------------------
	
	    /// <summary>
	    /// The token character for a FractionalPartSubstitution is &gt;.
	    /// </summary>
	    ///
	    /// <returns>'&gt;'</returns>
	    internal override char TokenChar() {
	        return '>';
	    }
	}
	
	// ===================================================================
	// AbsoluteValueSubstitution
	// ===================================================================
	
	/// <summary>
	/// A substitution that formats the absolute value of the number. This substition
	/// is represented by &gt;&gt; in a negative-number rule.
	/// </summary>
	///
	internal class AbsoluteValueSubstitution : NFSubstitution {
	    // -----------------------------------------------------------------------
	    // construction
	    // -----------------------------------------------------------------------
	
	    /// <summary>
	    /// Constructs an AbsoluteValueSubstitution. This just uses the superclass
	    /// constructor.
	    /// </summary>
	    ///
	    internal AbsoluteValueSubstitution(int pos_0, NFRuleSet ruleSet_1,
	            RuleBasedNumberFormat formatter, String description) : base(pos_0, ruleSet_1, formatter, description) {
	    }
	
	    // -----------------------------------------------------------------------
	    // formatting
	    // -----------------------------------------------------------------------
	
	    /// <summary>
	    /// Returns the absolute value of the number.
	    /// </summary>
	    ///
	    /// <param name="number">The number being formatted.</param>
	    /// <returns>abs(number)</returns>
	    public override long TransformNumber(long number) {
	        return Math.Abs(number);
	    }
	
	    /// <summary>
	    /// Returns the absolute value of the number.
	    /// </summary>
	    ///
	    /// <param name="number">The number being formatted.</param>
	    /// <returns>abs(number)</returns>
	    public override double TransformNumber(double number) {
	        return Math.Abs(number);
	    }
	
	    // -----------------------------------------------------------------------
	    // parsing
	    // -----------------------------------------------------------------------
	
	    /// <summary>
	    /// Returns the addtive inverse of the result of parsing the substitution
	    /// (this supersedes the earlier partial result)
	    /// </summary>
	    ///
	    /// <param name="newRuleValue">The result of parsing the substitution</param>
	    /// <param name="oldRuleValue">The partial parse result prior to calling this function</param>
	    /// <returns>-newRuleValue</returns>
	    public override double ComposeRuleValue(double newRuleValue, double oldRuleValue) {
	        return -newRuleValue;
	    }
	
	    /// <summary>
	    /// Sets the upper bound beck up to consider all rules
	    /// </summary>
	    ///
	    /// <param name="oldUpperBound">Ignored.</param>
	    /// <returns>Double.MAX_VALUE</returns>
	    public override double CalcUpperBound(double oldUpperBound) {
	        return System.Double.MaxValue;
	    }
	
	    // -----------------------------------------------------------------------
	    // simple accessor
	    // -----------------------------------------------------------------------
	
	    /// <summary>
	    /// The token character for an AbsoluteValueSubstitution is &gt;
	    /// </summary>
	    ///
	    /// <returns>'&gt;'</returns>
	    internal override char TokenChar() {
	        return '>';
	    }
	}
	
	// ===================================================================
	// NumeratorSubstitution
	// ===================================================================
	
	/// <summary>
	/// A substitution that multiplies the number being formatted (which is between 0
	/// and 1) by the base value of the rule that owns it and formats the result. It
	/// is represented by &lt;&lt; in the rules in a fraction rule set.
	/// </summary>
	///
	internal class NumeratorSubstitution : NFSubstitution {
	    // -----------------------------------------------------------------------
	    // data members
	    // -----------------------------------------------------------------------
	
	    /// <summary>
	    /// The denominator of the fraction we're finding the numerator for. (The
	    /// base value of the rule that owns this substitution.)
	    /// </summary>
	    ///
	    internal double denominator;
	
	    /// <summary>
	    /// True if we format leading zeros (this is a hack for Hebrew spellout)
	    /// </summary>
	    ///
	    internal bool withZeros;
	
	    // -----------------------------------------------------------------------
	    // construction
	    // -----------------------------------------------------------------------
	
	    /// <summary>
	    /// Constructs a NumberatorSubstitution. In addition to the inherited fields,
	    /// a NumeratorSubstitution keeps track of a denominator, which is merely the
	    /// base value of the rule that owns it.
	    /// </summary>
	    ///
	    internal NumeratorSubstitution(int pos_0, double denominator_1, NFRuleSet ruleSet_2,
	            RuleBasedNumberFormat formatter, String description) : base(pos_0, ruleSet_2, formatter, Fixdesc(description)) {
	        // this substitution's behavior depends on the rule's base value
	        // Rather than keeping a backpointer to the rule, we copy its
	        // base value here
	        this.denominator = denominator_1;
	
	        this.withZeros = description.EndsWith("<<");
	    }
	
	    static internal String Fixdesc(String description) {
	        return (description.EndsWith("<<")) ? description.Substring(0,(description.Length - 1)-(0)) : description;
	    }
	
	    // -----------------------------------------------------------------------
	    // boilerplate
	    // -----------------------------------------------------------------------
	
	    /// <summary>
	    /// Tests two NumeratorSubstitutions for equality
	    /// </summary>
	    ///
	    /// <param name="that">The other NumeratorSubstitution</param>
	    /// <returns>true if the two objects are functionally equivalent</returns>
	    public override bool Equals(Object that) {
	        if (base.Equals(that)) {
	            NumeratorSubstitution that2 = (NumeratorSubstitution) that;
	            return denominator == that2.denominator;
	        } else {
	            return false;
	        }
	    }
	
	    // -----------------------------------------------------------------------
	    // formatting
	    // -----------------------------------------------------------------------
	
	    /// <summary>
	    /// Performs a mathematical operation on the number, formats it using either
	    /// ruleSet or decimalFormat, and inserts the result into toInsertInto.
	    /// </summary>
	    ///
	    /// <param name="number">The number being formatted.</param>
	    /// <param name="toInsertInto">The string we insert the result into</param>
	    /// <param name="pos_0">The position in toInsertInto where the owning rule's rule textbegins (this value is added to this substitution's position todetermine exactly where to insert the new text)</param>
	    public override void DoSubstitution(double number, StringBuilder toInsertInto, int pos_0) {
	        // perform a transformation on the number being formatted that
	        // is dependent on the type of substitution this is
	        // String s = toInsertInto.toString();
	        double numberToFormat = TransformNumber(number);
	
	        if (withZeros && ruleSet != null) {
	            // if there are leading zeros in the decimal expansion then emit
	            // them
	            long nf = (long) numberToFormat;
	            int len = toInsertInto.Length;
	            while ((nf *= 10) < denominator) {
	                toInsertInto.Insert(pos_0 + this.pos, ' ');
	                ruleSet.Format(0, toInsertInto, pos_0 + this.pos);
	            }
	            pos_0 += toInsertInto.Length - len;
	        }
	
	        // if the result is an integer, from here on out we work in integer
	        // space (saving time and memory and preserving accuracy)
	        if (numberToFormat == Math.Floor(numberToFormat) && ruleSet != null) {
	            ruleSet.Format((long) numberToFormat, toInsertInto, pos_0 + this.pos);
	
	            // if the result isn't an integer, then call either our rule set's
	            // format() method or our DecimalFormat's format() method to
	            // format the result
	        } else {
	            if (ruleSet != null) {
	                ruleSet.Format(numberToFormat, toInsertInto, pos_0 + this.pos);
	            } else {
	                toInsertInto.Insert(pos_0 + this.pos,
	                        numberFormat.Format(numberToFormat));
	            }
	        }
	    }
	
	    /// <summary>
	    /// Returns the number being formatted times the denominator.
	    /// </summary>
	    ///
	    /// <param name="number">The number being formatted</param>
	    /// <returns>number /// denominator</returns>
	    public override long TransformNumber(long number) {
	        return (long) Math.Round(number * denominator,MidpointRounding.AwayFromZero);
	    }
	
	    /// <summary>
	    /// Returns the number being formatted times the denominator.
	    /// </summary>
	    ///
	    /// <param name="number">The number being formatted</param>
	    /// <returns>number /// denominator</returns>
	    public override double TransformNumber(double number) {
	        return Math.Round(number * denominator,MidpointRounding.AwayFromZero);
	    }
	
	    // -----------------------------------------------------------------------
	    // parsing
	    // -----------------------------------------------------------------------
	
	    /// <summary>
	    /// Dispatches to the inherited version of this function, but makes sure that
	    /// lenientParse is off.
	    /// </summary>
	    ///
	    public override object DoParse(String text, ParsePosition parsePosition,
	            double baseValue, double upperBound, bool lenientParse) {
	        // we don't have to do anything special to do the parsing here,
	        // but we have to turn lenient parsing off-- if we leave it on,
	        // it SERIOUSLY messes up the algorithm
	
	        // if withZeros is true, we need to count the zeros
	        // and use that to adjust the parse result
	        int zeroCount = 0;
	        if (withZeros) {
	            String workText = text;
	            ParsePosition workPos = new ParsePosition(1);
	            // int digit;
	
	            while (workText.Length > 0 && workPos.GetIndex() != 0) {
	                workPos.SetIndex(0);
	                /* digit = */System.Convert.ToInt32(ruleSet.Parse(workText, workPos, 1)); // parse
	                                                                             // zero
	                                                                             // or
	                                                                             // nothing
	                                                                             // at
	                                                                             // all
	                if (workPos.GetIndex() == 0) {
	                    // we failed, either there were no more zeros, or the number
	                    // was formatted with digits
	                    // either way, we're done
	                    break;
	                }
	
	                ++zeroCount;
	                parsePosition.SetIndex(parsePosition.GetIndex()
	                        + workPos.GetIndex());
	                workText = workText.Substring(workPos.GetIndex());
	                while (workText.Length > 0 && workText[0] == ' ') {
	                    workText = workText.Substring(1);
	                    parsePosition.SetIndex(parsePosition.GetIndex() + 1);
	                }
	            }
	
	            text = text.Substring(parsePosition.GetIndex()); // arrgh!
	            parsePosition.SetIndex(0);
	        }
	
	        // we've parsed off the zeros, now let's parse the rest from our current
	        // position
	        object result = base.DoParse(text,parsePosition,(withZeros) ? (double) (1)
	                        : (double) (baseValue),upperBound,false);
	
	        if (withZeros) {
	            // any base value will do in this case. is there a way to
	            // force this to not bother trying all the base values?
	
	            // compute the 'effective' base and prescale the value down
	            long n = Convert.ToInt64(result);
	            long d = 1;
	            int pow = 0;
	            while (d <= n) {
	                d *= 10;
	                ++pow;
	            }
	            // now add the zeros
	            while (zeroCount > 0) {
	                d *= 10;
	                --zeroCount;
	            }
	            // d is now our true denominator
	            result = (double )(n / (double) d);
	        }
	
	        return result;
	    }
	
	    /// <summary>
	    /// Divides the result of parsing the substitution by the partial parse
	    /// result.
	    /// </summary>
	    ///
	    /// <param name="newRuleValue">The result of parsing the substitution</param>
	    /// <param name="oldRuleValue">The owning rule's base value</param>
	    /// <returns>newRuleValue / oldRuleValue</returns>
	    public override double ComposeRuleValue(double newRuleValue, double oldRuleValue) {
	        return newRuleValue / oldRuleValue;
	    }
	
	    /// <summary>
	    /// Sets the uper bound down to this rule's base value
	    /// </summary>
	    ///
	    /// <param name="oldUpperBound">Ignored</param>
	    /// <returns>The base value of the rule owning this substitution</returns>
	    public override double CalcUpperBound(double oldUpperBound) {
	        return denominator;
	    }
	
	    // -----------------------------------------------------------------------
	    // simple accessor
	    // -----------------------------------------------------------------------
	
	    /// <summary>
	    /// The token character for a NumeratorSubstitution is &lt;
	    /// </summary>
	    ///
	    /// <returns>'&lt;'</returns>
	    internal override char TokenChar() {
	        return '<';
	    }
	}
	
	// ===================================================================
	// NullSubstitution
	// ===================================================================
	
	/// <summary>
	/// A substitution which does nothing. This class exists just to simplify the
	/// logic in some other routines so that they don't have to worry about how many
	/// substitutions a rule has.
	/// </summary>
	///
	internal class NullSubstitution : NFSubstitution {
	    // -----------------------------------------------------------------------
	    // construction
	    // -----------------------------------------------------------------------
	
	    /// <summary>
	    /// Constructs a NullSubstitution. This just delegates to the superclass
	    /// constructor, but the only value we really care about is the position.
	    /// </summary>
	    ///
	    internal NullSubstitution(int pos_0, NFRuleSet ruleSet_1,
	            RuleBasedNumberFormat formatter, String description) : base(pos_0, ruleSet_1, formatter, description) {
	    }
	
	    // -----------------------------------------------------------------------
	    // boilerplate
	    // -----------------------------------------------------------------------
	
	    /// <summary>
	    /// Only checks for class equality
	    /// </summary>
	    ///
	    public override bool Equals(Object that) {
	        return base.Equals(that);
	    }
	
	    /// <summary>
	    /// NullSubstitutions don't show up in the textual representation of a
	    /// RuleBasedNumberFormat
	    /// </summary>
	    ///
	    public override String ToString() {
	        return "";
	    }
	
	    // -----------------------------------------------------------------------
	    // formatting
	    // -----------------------------------------------------------------------
	
	    /// <summary>
	    /// Does nothing.
	    /// </summary>
	    ///
	    public override void DoSubstitution(long number, StringBuilder toInsertInto, int pos_0) {
	    }
	
	    /// <summary>
	    /// Does nothing.
	    /// </summary>
	    ///
	    public override void DoSubstitution(double number, StringBuilder toInsertInto, int pos_0) {
	    }
	
	    /// <summary>
	    /// Never called.
	    /// </summary>
	    ///
	    // /CLOVER:OFF
	    public override long TransformNumber(long number) {
	        return 0;
	    }
	
	    // /CLOVER:ON
	
	    /// <summary>
	    /// Never called.
	    /// </summary>
	    ///
	    // /CLOVER:OFF
	    public override double TransformNumber(double number) {
	        return 0;
	    }
	
	    // /CLOVER:ON
	
	    // -----------------------------------------------------------------------
	    // parsing
	    // -----------------------------------------------------------------------
	
	    /// <summary>
	    /// Returns the partial parse result unchanged
	    /// </summary>
	    ///
	    public override object DoParse(String text, ParsePosition parsePosition,
	            double baseValue, double upperBound, bool lenientParse) {
	        if (baseValue == (long) baseValue) {
	            return (long)((long) baseValue);
	        } else {
	            return (double )(baseValue);
	        }
	    }
	
	    /// <summary>
	    /// Never called.
	    /// </summary>
	    ///
	    // /CLOVER:OFF
	    public override double ComposeRuleValue(double newRuleValue, double oldRuleValue) {
	        return 0;
	    }
	
	    // /CLOVER:ON
	
	    /// <summary>
	    /// Never called.
	    /// </summary>
	    ///
	    // /CLOVER:OFF
	    public override double CalcUpperBound(double oldUpperBound) {
	        return 0;
	    }
	
	    // /CLOVER:ON
	
	    // -----------------------------------------------------------------------
	    // simple accessors
	    // -----------------------------------------------------------------------
	
	    /// <summary>
	    /// Returns true (this _is_ a NullSubstitution).
	    /// </summary>
	    ///
	    /// <returns>true</returns>
	    public override bool IsNullSubstitution() {
	        return true;
	    }
	
	    /// <summary>
	    /// Never called.
	    /// </summary>
	    ///
	    internal override // /CLOVER:OFF
	    char TokenChar() {
	        return ' ';
	    }
	    // /CLOVER:ON
	}
}
