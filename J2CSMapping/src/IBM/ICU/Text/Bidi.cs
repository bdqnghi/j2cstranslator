//##header J2SE15
/*
 *******************************************************************************
 *   Copyright (C) 2001-2007, International Business Machines
 *   Corporation and others.  All Rights Reserved.
 *******************************************************************************
 */

/* FOOD FOR THOUGHT: currently the reordering modes are a mixture of
 * algorithm for direct BiDi, algorithm for inverse Bidi and the bizarre
 * concept of RUNS_ONLY which is a double operation.
 * It could be advantageous to divide this into 3 concepts:
 * a) Operation: direct / inverse / RUNS_ONLY
 * b) Direct algorithm: default / NUMBERS_SPECIAL / GROUP_NUMBERS_WITH_L
 * c) Inverse algorithm: default / INVERSE_LIKE_DIRECT / NUMBERS_SPECIAL
 * This would allow combinations not possible today like RUNS_ONLY with
 * NUMBERS_SPECIAL.
 * Also allow to set INSERT_MARKS for the direct step of RUNS_ONLY and
 * REMOVE_CONTROLS for the inverse step.
 * Not all combinations would be supported, and probably not all do make sense.
 * This would need to document which ones are supported and what are the
 * fallbacks for unsupported combinations.
 */

//TODO: make sample program do something simple but real and complete

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:30 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Text {
	
	using IBM.ICU.Impl;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Resources;
	using System.Runtime.CompilerServices;
     using ILOG.J2CsMapping.Util;
     using ILOG.J2CsMapping.Text;
	
	/// <summary>
	/// <h2>Bidi algorithm for ICU</h2>
	/// This is an implementation of the Unicode Bidirectional algorithm. The
	/// algorithm is defined in the <a
	/// href="http://www.unicode.org/unicode/reports/tr9/">Unicode Standard Annex
	/// #9</a>, version 13, also described in The Unicode Standard, Version 4.0 .
	/// <p>
	/// Note: Libraries that perform a bidirectional algorithm and reorder strings
	/// accordingly are sometimes called "Storage Layout Engines". ICU's Bidi and
	/// shaping (ArabicShaping) classes can be used at the core of such "Storage
	/// Layout Engines".
	/// <h3>General remarks about the API:</h3>
	/// The &quot;limit&quot; of a sequence of characters is the position just after
	/// their last character, i.e., one more than that position.
	/// <p>
	/// Some of the API methods provide access to &quot;runs&quot;. Such a
	/// &quot;run&quot; is defined as a sequence of characters that are at the same
	/// embedding level after performing the Bidi algorithm.
	/// <p>
	/// <h3>Basic concept: paragraph</h3>
	/// A piece of text can be divided into several paragraphs by characters with the
	/// Bidi class <c>Block Separator</c>. For handling of paragraphs, see:
	/// <ul>
	/// <li><see cref="M:IBM.ICU.Text.Bidi.CountParagraphs"/><li><see cref="M:IBM.ICU.Text.Bidi.GetParaLevel"/><li><see cref="M:IBM.ICU.Text.Bidi.GetParagraph(System.Int32)"/><li><see cref="M:IBM.ICU.Text.Bidi.GetParagraphByIndex(System.Int32)"/></ul>
	/// <h3>Basic concept: text direction</h3>
	/// The direction of a piece of text may be:
	/// <ul>
	/// <li><see cref="F:IBM.ICU.Text.Bidi.LTR"/><li><see cref="F:IBM.ICU.Text.Bidi.RTL"/><li><see cref="F:IBM.ICU.Text.Bidi.MIXED"/></ul>
	/// <h3>Basic concept: levels</h3>
	/// Levels in this API represent embedding levels according to the Unicode
	/// Bidirectional Algorithm. Their low-order bit (even/odd value) indicates the
	/// visual direction.
	/// <p>
	/// Levels can be abstract values when used for the <c>paraLevel</c> and
	/// <c>embeddingLevels</c> arguments of <c>setPara()</c>; there:
	/// <ul>
	/// <li>the high-order bit of an <c>embeddingLevels[]</c> value indicates
	/// whether the using application is specifying the level of a character to
	/// <i>override</i> whatever the Bidi implementation would resolve it to.</li>
	/// <li><c>paraLevel</c> can be set to the pseudo-level values
	/// <c>LEVEL_DEFAULT_LTR</c> and <c>LEVEL_DEFAULT_RTL</c>.</li>
	/// </ul>
	/// <p>
	/// The related constants are not real, valid level values.
	/// <c>DEFAULT_XXX</c> can be used to specify a default for the paragraph
	/// level for when the <c>setPara()</c> method shall determine it but there
	/// is no strongly typed character in the input.
	/// <p>
	/// Note that the value for <c>LEVEL_DEFAULT_LTR</c> is even and the one
	/// for <c>LEVEL_DEFAULT_RTL</c> is odd, just like with normal LTR and RTL
	/// level values - these special values are designed that way. Also, the
	/// implementation assumes that MAX_EXPLICIT_LEVEL is odd.
	/// <ul>
	/// <b>See Also:</b>
	/// <li><see cref="F:IBM.ICU.Text.Bidi.LEVEL_DEFAULT_LTR"/><li><see cref="F:IBM.ICU.Text.Bidi.LEVEL_DEFAULT_RTL"/><li><see cref="F:IBM.ICU.Text.Bidi.LEVEL_OVERRIDE"/><li><see cref="F:IBM.ICU.Text.Bidi.MAX_EXPLICIT_LEVEL"/><li><see cref="M:IBM.ICU.Text.Bidi.SetPara(System.String, System.Byte, null)"/></ul>
	/// <h3>Basic concept: Reordering Mode</h3>
	/// Reordering mode values indicate which variant of the Bidi algorithm to use.
	/// <ul>
	/// <b>See Also:</b>
	/// <li><see cref="M:IBM.ICU.Text.Bidi.SetReorderingMode(System.Int32)"/><li><see cref="F:IBM.ICU.Text.Bidi.REORDER_DEFAULT"/><li><see cref="F:IBM.ICU.Text.Bidi.REORDER_NUMBERS_SPECIAL"/><li><see cref="F:IBM.ICU.Text.Bidi.REORDER_GROUP_NUMBERS_WITH_R"/><li><see cref="F:IBM.ICU.Text.Bidi.REORDER_RUNS_ONLY"/><li><see cref="F:IBM.ICU.Text.Bidi.REORDER_INVERSE_NUMBERS_AS_L"/><li><see cref="F:IBM.ICU.Text.Bidi.REORDER_INVERSE_LIKE_DIRECT"/><li><see cref="F:IBM.ICU.Text.Bidi.REORDER_INVERSE_FOR_NUMBERS_SPECIAL"/></ul>
	/// <h3>Basic concept: Reordering Options</h3>
	/// Reordering options can be applied during Bidi text transformations.
	/// <ul>
	/// <b>See Also:</b>
	/// <li><see cref="M:IBM.ICU.Text.Bidi.SetReorderingOptions(System.Int32)"/><li><see cref="F:IBM.ICU.Text.Bidi.OPTION_DEFAULT"/><li><see cref="F:IBM.ICU.Text.Bidi.OPTION_INSERT_MARKS"/><li><see cref="F:IBM.ICU.Text.Bidi.OPTION_REMOVE_CONTROLS"/><li><see cref="F:IBM.ICU.Text.Bidi.OPTION_STREAMING"/></ul>
	/// </summary>
	///
	/// @draft ICU 3.8
	/// @provisional This API might change or be removed in a future release.
	/// <h4>Sample code for the ICU Bidi API</h4>
	/// <h5>Rendering a paragraph with the ICU Bidi API</h5>
	/// This is (hypothetical) sample code that illustrates how the ICU
	/// Bidi API could be used to render a paragraph of text. Rendering
	/// code depends highly on the graphics system, therefore this
	/// sample code must make a lot of assumptions, which may or may not
	/// match any existing graphics system's properties.
	/// <p>
	/// The basic assumptions are:
	/// </p>
	/// <ul>
	/// <li>Rendering is done from left to right on a horizontal line.</li>
	/// <li>A run of single-style, unidirectional text can be rendered
	/// at once.</li>
	/// <li>Such a run of text is passed to the graphics system with
	/// characters (code units) in logical order.</li>
	/// <li>The line-breaking algorithm is very complicated and
	/// Locale-dependent - and therefore its implementation omitted from
	/// this sample code.</li>
	/// </ul>
	/// <pre>
	/// package com.ibm.icu.dev.test.bidi;
	/// import com.ibm.icu.text.Bidi;
	/// import com.ibm.icu.text.BidiRun;
	/// public class Sample {
	/// static final int styleNormal = 0;
	/// static final int styleSelected = 1;
	/// static final int styleBold = 2;
	/// static final int styleItalics = 4;
	/// static final int styleSuper = 8;
	/// static final int styleSub = 16;
	/// static class StyleRun {
	/// int limit;
	/// int style;
	/// public StyleRun(int limit, int style) {
	/// this.limit = limit;
	/// this.style = style;
	/// }
	/// }
	/// static class Bounds {
	/// int start;
	/// int limit;
	/// public Bounds(int start, int limit) {
	/// this.start = start;
	/// this.limit = limit;
	/// }
	/// }
	/// static int getTextWidth(String text, int start, int limit,
	/// StyleRun[] styleRuns, int styleRunCount) {
	/// // simplistic way to compute the width
	/// return limit - start;
	/// }
	/// // set limit and StyleRun limit for a line
	/// // from text[start] and from styleRuns[styleRunStart]
	/// // using Bidi.getLogicalRun(...)
	/// // returns line width
	/// static int getLineBreak(String text, Bounds line, Bidi para,
	/// StyleRun styleRuns[], Bounds styleRun) {
	/// // dummy return
	/// return 0;
	/// }
	/// // render runs on a line sequentially, always from left to right
	/// // prepare rendering a new line
	/// static void startLine(byte textDirection, int lineWidth) {
	/// System.out.println();
	/// }
	/// // render a run of text and advance to the right by the run width
	/// // the text[start..limit-1] is always in logical order
	/// static void renderRun(String text, int start, int limit,
	/// byte textDirection, int style) {
	/// }
	/// // We could compute a cross-product
	/// // from the style runs with the directional runs
	/// // and then reorder it.
	/// // Instead, here we iterate over each run type
	/// // and render the intersections -
	/// // with shortcuts in simple (and common) cases.
	/// // renderParagraph() is the main function.
	/// // render a directional run with
	/// // (possibly) multiple style runs intersecting with it
	/// static void renderDirectionalRun(String text, int start, int limit,
	/// byte direction, StyleRun styleRuns[], int styleRunCount) {
	/// int i;
	/// // iterate over style runs
	/// if (direction == Bidi.LTR) {
	/// int styleLimit;
	/// for (i = 0; i &lt; styleRunCount; ++i) {
	/// styleLimit = styleRuns[i].limit;
	/// if (start &lt; styleLimit) {
	/// if (styleLimit &gt; limit) {
	/// styleLimit = limit;
	/// }
	/// renderRun(text, start, styleLimit, direction,
	/// styleRuns[i].style);
	/// if (styleLimit == limit) {
	/// break;
	/// }
	/// start = styleLimit;
	/// }
	/// }
	/// } else {
	/// int styleStart;
	/// for (i = styleRunCount - 1; i &gt;= 0; --i) {
	/// if (i &gt; 0) {
	/// styleStart = styleRuns[i - 1].limit;
	/// } else {
	/// styleStart = 0;
	/// }
	/// if (limit &gt;= styleStart) {
	/// if (styleStart &lt; start) {
	/// styleStart = start;
	/// }
	/// renderRun(text, styleStart, limit, direction,
	/// styleRuns[i].style);
	/// if (styleStart == start) {
	/// break;
	/// }
	/// limit = styleStart;
	/// }
	/// }
	/// }
	/// }
	/// // the line object represents text[start..limit-1]
	/// static void renderLine(Bidi line, String text, int start, int limit,
	/// StyleRun styleRuns[], int styleRunCount) {
	/// byte direction = line.getDirection();
	/// if (direction != Bidi.MIXED) {
	/// // unidirectional
	/// if (styleRunCount &lt;= 1) {
	/// renderRun(text, start, limit, direction, styleRuns[0].style);
	/// } else {
	/// renderDirectionalRun(text, start, limit, direction, styleRuns,
	/// styleRunCount);
	/// }
	/// } else {
	/// // mixed-directional
	/// int count, i;
	/// BidiRun run;
	/// try {
	/// count = line.countRuns();
	/// } catch (IllegalStateException e) {
	/// e.printStackTrace();
	/// return;
	/// }
	/// if (styleRunCount &lt;= 1) {
	/// int style = styleRuns[0].style;
	/// // iterate over directional runs
	/// for (i = 0; i &lt; count; ++i) {
	/// run = line.getVisualRun(i);
	/// renderRun(text, run.getStart(), run.getLimit(),
	/// run.getDirection(), style);
	/// }
	/// } else {
	/// // iterate over both directional and style runs
	/// for (i = 0; i &lt; count; ++i) {
	/// run = line.getVisualRun(i);
	/// renderDirectionalRun(text, run.getStart(), run.getLimit(),
	/// run.getDirection(), styleRuns, styleRunCount);
	/// }
	/// }
	/// }
	/// }
	/// static void renderParagraph(String text, byte textDirection,
	/// StyleRun styleRuns[], int styleRunCount, int lineWidth) {
	/// int length = text.length();
	/// Bidi para = new Bidi();
	/// try {
	/// para.setPara(text, textDirection != 0 ? Bidi.LEVEL_DEFAULT_RTL
	/// : Bidi.LEVEL_DEFAULT_LTR, null);
	/// } catch (Exception e) {
	/// e.printStackTrace();
	/// return;
	/// }
	/// byte paraLevel = (byte) (1 &amp; para.getParaLevel());
	/// StyleRun styleRun = new StyleRun(length, styleNormal);
	/// if (styleRuns == null || styleRunCount &lt;= 0) {
	/// styleRuns = new StyleRun[1];
	/// styleRunCount = 1;
	/// styleRuns[0] = styleRun;
	/// }
	/// // assume styleRuns[styleRunCount-1].limit&gt;=length
	/// int width = getTextWidth(text, 0, length, styleRuns, styleRunCount);
	/// if (width &lt;= lineWidth) {
	/// // everything fits onto one line
	/// // prepare rendering a new line from either left or right
	/// startLine(paraLevel, width);
	/// renderLine(para, text, 0, length, styleRuns, styleRunCount);
	/// } else {
	/// // we need to render several lines
	/// Bidi line = new Bidi(length, 0);
	/// int start = 0, limit;
	/// int styleRunStart = 0, styleRunLimit;
	/// for (;;) {
	/// limit = length;
	/// styleRunLimit = styleRunCount;
	/// width = getLineBreak(text, new Bounds(start, limit), para,
	/// styleRuns, new Bounds(styleRunStart, styleRunLimit));
	/// try {
	/// line = para.setLine(start, limit);
	/// } catch (Exception e) {
	/// e.printStackTrace();
	/// return;
	/// }
	/// // prepare rendering a new line
	/// // from either left or right
	/// startLine(paraLevel, width);
	/// if (styleRunStart &gt; 0) {
	/// int newRunCount = styleRuns.length - styleRunStart;
	/// StyleRun[] newRuns = new StyleRun[newRunCount];
	/// System.arraycopy(styleRuns, styleRunStart, newRuns, 0,
	/// newRunCount);
	/// renderLine(line, text, start, limit, newRuns, styleRunLimit
	/// - styleRunStart);
	/// } else {
	/// renderLine(line, text, start, limit, styleRuns,
	/// styleRunLimit - styleRunStart);
	/// }
	/// if (limit == length) {
	/// break;
	/// }
	/// start = limit;
	/// styleRunStart = styleRunLimit - 1;
	/// if (start &gt;= styleRuns[styleRunStart].limit) {
	/// ++styleRunStart;
	/// }
	/// }
	/// }
	/// }
	/// public static void main(String[] args) {
	/// renderParagraph(&quot;Some Latin text...&quot;, Bidi.LTR, null, 0, 80);
	/// renderParagraph(&quot;Some Hebrew text...&quot;, Bidi.RTL, null, 0, 60);
	/// }
	/// }
	/// </pre>
	
	public class Bidi {
	
	    internal class Point {
	        internal int pos; /* position in text */
	
	        internal int flag; /* flag for LRM/RLM, before/after */
	    }
	
	    internal class InsertPoints {
	        public InsertPoints() {
	            this.points = new Bidi.Point [0];
	        }
	
	        internal int size;
	
	        internal int confirmed;
	
	        internal Bidi.Point [] points;
	    }
	
	    /// <summary>
	    /// Paragraph level setting
	    /// <p>
	    /// Constant indicating that the base direction depends on the first strong
	    /// directional character in the text according to the Unicode Bidirectional
	    /// Algorithm. If no strong directional character is present, then set the
	    /// paragraph level to 0 (left-to-right).
	    /// <p>
	    /// If this value is used in conjunction with reordering modes
	    /// <c>REORDER_INVERSE_LIKE_DIRECT</c> or
	    /// <c>REORDER_INVERSE_FOR_NUMBERS_SPECIAL</c>, the text to reorder is
	    /// assumed to be visual LTR, and the text after reordering is required to be
	    /// the corresponding logical string with appropriate contextual direction.
	    /// The direction of the result string will be RTL if either the righmost or
	    /// leftmost strong character of the source text is RTL or Arabic Letter, the
	    /// direction will be LTR otherwise.
	    /// <p>
	    /// If reordering option <c>OPTION_INSERT_MARKS</c> is set, an RLM may
	    /// be added at the beginning of the result string to ensure round trip (that
	    /// the result string, when reordered back to visual, will produce the
	    /// original source text).
	    /// </summary>
	    ///
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.REORDER_INVERSE_LIKE_DIRECT"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.REORDER_INVERSE_FOR_NUMBERS_SPECIAL"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const sbyte LEVEL_DEFAULT_LTR = (sbyte) 0x7e;
	
	    /// <summary>
	    /// Paragraph level setting
	    /// <p>
	    /// Constant indicating that the base direction depends on the first strong
	    /// directional character in the text according to the Unicode Bidirectional
	    /// Algorithm. If no strong directional character is present, then set the
	    /// paragraph level to 1 (right-to-left).
	    /// <p>
	    /// If this value is used in conjunction with reordering modes
	    /// <c>REORDER_INVERSE_LIKE_DIRECT</c> or
	    /// <c>REORDER_INVERSE_FOR_NUMBERS_SPECIAL</c>, the text to reorder is
	    /// assumed to be visual LTR, and the text after reordering is required to be
	    /// the corresponding logical string with appropriate contextual direction.
	    /// The direction of the result string will be RTL if either the righmost or
	    /// leftmost strong character of the source text is RTL or Arabic Letter, or
	    /// if the text contains no strong character; the direction will be LTR
	    /// otherwise.
	    /// <p>
	    /// If reordering option <c>OPTION_INSERT_MARKS</c> is set, an RLM may
	    /// be added at the beginning of the result string to ensure round trip (that
	    /// the result string, when reordered back to visual, will produce the
	    /// original source text).
	    /// </summary>
	    ///
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.REORDER_INVERSE_LIKE_DIRECT"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.REORDER_INVERSE_FOR_NUMBERS_SPECIAL"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const sbyte LEVEL_DEFAULT_RTL = (sbyte) 0x7f;
	
	    /// <summary>
	    /// Maximum explicit embedding level. (The maximum resolved level can be up
	    /// to <c>MAX_EXPLICIT_LEVEL+1</c>).
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const sbyte MAX_EXPLICIT_LEVEL = 61;
	
	    /// <summary>
	    /// Bit flag for level input. Overrides directional properties.
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const sbyte LEVEL_OVERRIDE = -1; // TODO: was (sbyte) 0x80;
	
	    /// <summary>
	    /// Special value which can be returned by the mapping methods when a logical
	    /// index has no corresponding visual index or vice-versa. This may happen
	    /// for the logical-to-visual mapping of a Bidi control when option
	    /// <c>OPTION_REMOVE_CONTROLS</c> is specified. This can also happen
	    /// for the visual-to-logical mapping of a Bidi mark (LRM or RLM) inserted by
	    /// option <c>OPTION_INSERT_MARKS</c>.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.GetVisualIndex(System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.GetVisualMap"/>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.GetLogicalIndex(System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.GetLogicalMap"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.OPTION_INSERT_MARKS"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.OPTION_REMOVE_CONTROLS"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const int MAP_NOWHERE = -1;
	
	    /// <summary>
	    /// All left-to-right text.
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const sbyte LTR = 0;
	
	    /// <summary>
	    /// All right-to-left text.
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const sbyte RTL = 1;
	
	    /// <summary>
	    /// Mixed-directional text.
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const sbyte MIXED = 2;
	
	    /// <summary>
	    /// option bit for writeReordered(): keep combining characters after their
	    /// base characters in RTL runs
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.WriteReordered(System.Int32)"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const short KEEP_BASE_COMBINING = 1;
	
	    /// <summary>
	    /// option bit for writeReordered(): replace characters with the "mirrored"
	    /// property in RTL runs by their mirror-image mappings
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.WriteReordered(System.Int32)"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const short DO_MIRRORING = 2;
	
	    /// <summary>
	    /// option bit for writeReordered(): surround the run with LRMs if necessary;
	    /// this is part of the approximate "inverse Bidi" algorithm
	    /// <p>
	    /// This option does not imply corresponding adjustment of the index
	    /// mappings.
	    /// </p>
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.SetInverse(System.Boolean)"/>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.WriteReordered(System.Int32)"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const short INSERT_LRM_FOR_NUMERIC = 4;
	
	    /// <summary>
	    /// option bit for writeReordered(): remove Bidi control characters (this
	    /// does not affect INSERT_LRM_FOR_NUMERIC)
	    /// <p>
	    /// This option does not imply corresponding adjustment of the index
	    /// mappings.
	    /// </p>
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.WriteReordered(System.Int32)"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.INSERT_LRM_FOR_NUMERIC"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const short REMOVE_BIDI_CONTROLS = 8;
	
	    /// <summary>
	    /// option bit for writeReordered(): write the output in reverse order
	    /// <p>
	    /// This has the same effect as calling <c>writeReordered()</c> first
	    /// without this option, and then calling <c>writeReverse()</c> without
	    /// mirroring. Doing this in the same step is faster and avoids a temporary
	    /// buffer. An example for using this option is output to a character
	    /// terminal that is designed for RTL scripts and stores text in reverse
	    /// order.
	    /// </p>
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.WriteReordered(System.Int32)"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const short OUTPUT_REVERSE = 16;
	
	    /// <summary>
	    /// Reordering mode: Regular Logical to Visual Bidi algorithm according to
	    /// Unicode.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.SetReorderingMode(System.Int32)"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const short REORDER_DEFAULT = 0;
	
	    /// <summary>
	    /// Reordering mode: Logical to Visual algorithm which handles numbers in a
	    /// way which mimicks the behavior of Windows XP.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.SetReorderingMode(System.Int32)"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const short REORDER_NUMBERS_SPECIAL = 1;
	
	    /// <summary>
	    /// Reordering mode: Logical to Visual algorithm grouping numbers with
	    /// adjacent R characters (reversible algorithm).
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.SetReorderingMode(System.Int32)"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const short REORDER_GROUP_NUMBERS_WITH_R = 2;
	
	    /// <summary>
	    /// Reordering mode: Reorder runs only to transform a Logical LTR string to
	    /// the logical RTL string with the same display, or vice-versa.<br>
	    /// If this mode is set together with option <c>OPTION_INSERT_MARKS</c>
	    /// , some Bidi controls in the source text may be removed and other controls
	    /// may be added to produce the minimum combination which has the required
	    /// display.
	    /// </summary>
	    ///
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.OPTION_INSERT_MARKS"/>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.SetReorderingMode(System.Int32)"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const short REORDER_RUNS_ONLY = 3;
	
	    /// <summary>
	    /// Reordering mode: Visual to Logical algorithm which handles numbers like L
	    /// (same algorithm as selected by <c>setInverse(true)</c>.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.SetInverse(System.Boolean)"/>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.SetReorderingMode(System.Int32)"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const short REORDER_INVERSE_NUMBERS_AS_L = 4;
	
	    /// <summary>
	    /// Reordering mode: Visual to Logical algorithm equivalent to the regular
	    /// Logical to Visual algorithm.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.SetReorderingMode(System.Int32)"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const short REORDER_INVERSE_LIKE_DIRECT = 5;
	
	    /// <summary>
	    /// Reordering mode: Inverse Bidi (Visual to Logical) algorithm for the
	    /// <c>REORDER_NUMBERS_SPECIAL</c> Bidi algorithm.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.SetReorderingMode(System.Int32)"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const short REORDER_INVERSE_FOR_NUMBERS_SPECIAL = 6;
	
	    /* Number of values for reordering mode. */
	    internal const short REORDER_COUNT = 7;
	
	    /*
	     * Reordering mode values must be ordered so that all the regular logical to
	     * visual modes come first, and all inverse Bidi modes come last.
	     */
	    internal const short REORDER_LAST_LOGICAL_TO_VISUAL = REORDER_NUMBERS_SPECIAL;
	
	    /// <summary>
	    /// Option value for <c>setReorderingOptions</c>: disable all the
	    /// options which can be set with this method
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.SetReorderingOptions(System.Int32)"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const int OPTION_DEFAULT = 0;
	
	    /// <summary>
	    /// Option bit for <c>setReorderingOptions</c>: insert Bidi marks (LRM
	    /// or RLM) when needed to ensure correct result of a reordering to a Logical
	    /// order
	    /// <p>
	    /// This option must be set or reset before calling <c>setPara</c>.
	    /// </p>
	    /// <p>
	    /// This option is significant only with reordering modes which generate a
	    /// result with Logical order, specifically.
	    /// </p>
	    /// <ul>
	    /// <li><c>REORDER_RUNS_ONLY</c></li>
	    /// <li><c>REORDER_INVERSE_NUMBERS_AS_L</c></li>
	    /// <li><c>REORDER_INVERSE_LIKE_DIRECT</c></li>
	    /// <li><c>REORDER_INVERSE_FOR_NUMBERS_SPECIAL</c></li>
	    /// </ul>
	    /// <p>
	    /// If this option is set in conjunction with reordering mode
	    /// <c>REORDER_INVERSE_NUMBERS_AS_L</c> or with calling
	    /// <c>setInverse(true)</c>, it implies option
	    /// <c>INSERT_LRM_FOR_NUMERIC</c> in calls to method
	    /// <c>writeReordered()</c>.
	    /// </p>
	    /// <p>
	    /// For other reordering modes, a minimum number of LRM or RLM characters
	    /// will be added to the source text after reordering it so as to ensure
	    /// round trip, i.e. when applying the inverse reordering mode on the
	    /// resulting logical text with removal of Bidi marks (option
	    /// <c>OPTION_REMOVE_CONTROLS</c> set before calling
	    /// <c>setPara()</c> or option <c>REMOVE_BIDI_CONTROLS</c> in
	    /// <c>writeReordered</c>), the result will be identical to the source
	    /// text in the first transformation.
	    /// <p>
	    /// This option will be ignored if specified together with option
	    /// <c>OPTION_REMOVE_CONTROLS</c>. It inhibits option
	    /// <c>REMOVE_BIDI_CONTROLS</c> in calls to method
	    /// <c>writeReordered()</c> and it implies option
	    /// <c>INSERT_LRM_FOR_NUMERIC</c> in calls to method
	    /// <c>writeReordered()</c> if the reordering mode is
	    /// <c>REORDER_INVERSE_NUMBERS_AS_L</c>.
	    /// </p>
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.SetReorderingMode(System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.SetReorderingOptions(System.Int32)"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.INSERT_LRM_FOR_NUMERIC"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.REMOVE_BIDI_CONTROLS"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.OPTION_REMOVE_CONTROLS"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.REORDER_RUNS_ONLY"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.REORDER_INVERSE_NUMBERS_AS_L"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.REORDER_INVERSE_LIKE_DIRECT"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.REORDER_INVERSE_FOR_NUMBERS_SPECIAL"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const int OPTION_INSERT_MARKS = 1;
	
	    /// <summary>
	    /// Option bit for <c>setReorderingOptions</c>: remove Bidi control
	    /// characters
	    /// <p>
	    /// This option must be set or reset before calling <c>setPara</c>.
	    /// </p>
	    /// <p>
	    /// This option nullifies option <c>OPTION_INSERT_MARKS</c>. It
	    /// inhibits option <c>INSERT_LRM_FOR_NUMERIC</c> in calls to method
	    /// <c>writeReordered()</c> and it implies option
	    /// <c>REMOVE_BIDI_CONTROLS</c> in calls to that method.
	    /// </p>
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.SetReorderingMode(System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.SetReorderingOptions(System.Int32)"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.OPTION_INSERT_MARKS"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.INSERT_LRM_FOR_NUMERIC"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.REMOVE_BIDI_CONTROLS"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const int OPTION_REMOVE_CONTROLS = 2;
	
	    /// <summary>
	    /// Option bit for <c>setReorderingOptions</c>: process the output as
	    /// part of a stream to be continued
	    /// <p>
	    /// This option must be set or reset before calling <c>setPara</c>.
	    /// </p>
	    /// <p>
	    /// This option specifies that the caller is interested in processing large
	    /// text object in parts. The results of the successive calls are expected to
	    /// be concatenated by the caller. Only the call for the last part will have
	    /// this option bit off.
	    /// </p>
	    /// <p>
	    /// When this option bit is on, <c>setPara()</c> may process less than
	    /// the full source text in order to truncate the text at a meaningful
	    /// boundary. The caller should call <c>getProcessedLength()</c>
	    /// immediately after calling <c>setPara()</c> in order to determine
	    /// how much of the source text has been processed. Source text beyond that
	    /// length should be resubmitted in following calls to <c>setPara</c>.
	    /// The processed length may be less than the length of the source text if a
	    /// character preceding the last character of the source text constitutes a
	    /// reasonable boundary (like a block separator) for text to be continued.<br>
	    /// If the last character of the source text constitutes a reasonable
	    /// boundary, the whole text will be processed at once.<br>
	    /// If nowhere in the source text there exists such a reasonable boundary,
	    /// the processed length will be zero.<br>
	    /// The caller should check for such an occurrence and do one of the
	    /// following:
	    /// <ul>
	    /// <li>submit a larger amount of text with a better chance to include a
	    /// reasonable boundary.</li>
	    /// <li>resubmit the same text after turning off option
	    /// <c>OPTION_STREAMING</c>.</li>
	    /// </ul>
	    /// In all cases, this option should be turned off before processing the last
	    /// part of the text.
	    /// </p>
	    /// <p>
	    /// When the <c>OPTION_STREAMING</c> option is used, it is recommended
	    /// to call <c>orderParagraphsLTR()</c> with argument
	    /// <c>orderParagraphsLTR</c> set to <c>true</c> before calling
	    /// <c>setPara()</c> so that later paragraphs may be concatenated to
	    /// previous paragraphs on the right.
	    /// </p>
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.SetReorderingMode(System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.SetReorderingOptions(System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.GetProcessedLength"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.orderParagraphsLTR"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const int OPTION_STREAMING = 4;
	
	    /*
	     * Comparing the description of the Bidi algorithm with this implementation
	     * is easier with the same names for the Bidi types in the code as there.
	     * See UCharacterDirection
	     */
	    internal const sbyte L = IBM.ICU.Lang.UCharacterEnums.ECharacterDirection.LEFT_TO_RIGHT;
	
	    internal const sbyte R = IBM.ICU.Lang.UCharacterEnums.ECharacterDirection.RIGHT_TO_LEFT;
	
	    internal const sbyte EN = IBM.ICU.Lang.UCharacterEnums.ECharacterDirection.EUROPEAN_NUMBER;
	
	    internal const sbyte ES = IBM.ICU.Lang.UCharacterEnums.ECharacterDirection.EUROPEAN_NUMBER_SEPARATOR;
	
	    internal const sbyte ET = IBM.ICU.Lang.UCharacterEnums.ECharacterDirection.EUROPEAN_NUMBER_TERMINATOR;
	
	    internal const sbyte AN = IBM.ICU.Lang.UCharacterEnums.ECharacterDirection.ARABIC_NUMBER;
	
	    internal const sbyte CS = IBM.ICU.Lang.UCharacterEnums.ECharacterDirection.COMMON_NUMBER_SEPARATOR;
	
	    internal const sbyte B = IBM.ICU.Lang.UCharacterEnums.ECharacterDirection.BLOCK_SEPARATOR;
	
	    internal const sbyte S = IBM.ICU.Lang.UCharacterEnums.ECharacterDirection.SEGMENT_SEPARATOR;
	
	    internal const sbyte WS = IBM.ICU.Lang.UCharacterEnums.ECharacterDirection.WHITE_SPACE_NEUTRAL;
	
	    internal const sbyte ON = IBM.ICU.Lang.UCharacterEnums.ECharacterDirection.OTHER_NEUTRAL;
	
	    internal const sbyte LRE = IBM.ICU.Lang.UCharacterEnums.ECharacterDirection.LEFT_TO_RIGHT_EMBEDDING;
	
	    internal const sbyte LRO = IBM.ICU.Lang.UCharacterEnums.ECharacterDirection.LEFT_TO_RIGHT_OVERRIDE;
	
	    internal const sbyte AL = IBM.ICU.Lang.UCharacterEnums.ECharacterDirection.RIGHT_TO_LEFT_ARABIC;
	
	    internal const sbyte RLE = IBM.ICU.Lang.UCharacterEnums.ECharacterDirection.RIGHT_TO_LEFT_EMBEDDING;
	
	    internal const sbyte RLO = IBM.ICU.Lang.UCharacterEnums.ECharacterDirection.RIGHT_TO_LEFT_OVERRIDE;
	
	    internal const sbyte PDF = IBM.ICU.Lang.UCharacterEnums.ECharacterDirection.POP_DIRECTIONAL_FORMAT;
	
	    internal const sbyte NSM = IBM.ICU.Lang.UCharacterEnums.ECharacterDirection.DIR_NON_SPACING_MARK;
	
	    internal const sbyte BN = IBM.ICU.Lang.UCharacterEnums.ECharacterDirection.BOUNDARY_NEUTRAL;
	
	    internal const int MASK_R_AL = (1 << R | 1 << AL);
	
	    /// <summary>
	    /// Value returned by <c>BidiClassifier</c> when there is no need to
	    /// override the standard Bidi class for a given code point.
	    /// </summary>
	    ///
	    /// <seealso cref="T:IBM.ICU.Text.BidiClassifier"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const int CLASS_DEFAULT = IBM.ICU.Lang.UCharacterEnums.ECharacterDirection.CHAR_DIRECTION_COUNT;
	
	    private const char CR = '\r';
	
	    private const char LF = '\n';
	
	    internal const int LRM_BEFORE = 1;
	
	    internal const int LRM_AFTER = 2;
	
	    internal const int RLM_BEFORE = 4;
	
	    internal const int RLM_AFTER = 8;
	
	    /*
	     * reference to parent paragraph object (reference to self if this object is
	     * a paragraph object); set to null in a newly opened object; set to a real
	     * value after a successful execution of setPara or setLine
	     */
	    internal Bidi paraBidi;
	
	    internal readonly UBiDiProps bdp;
	
	    /* character array representing the current text */
	    internal char[] text;
	
	    /* length of the current text */
	    internal int originalLength;
	
	    /*
	     * if the option OPTION_STREAMING is set, this is the length of text
	     * actually processed by <code>setPara</code>, which may be shorter than the
	     * original length. Otherwise, it is identical to the original length.
	     */
	    internal int length;
	
	    /*
	     * if option OPTION_REMOVE_CONTROLS is set, and/or Bidi marks are allowed to
	     * be inserted in one of the reordering modes, the length of the result
	     * string may be different from the processed length.
	     */
	    internal int resultLength;
	
	    /* indicators for whether memory may be allocated after construction */
	    internal bool mayAllocateText;
	
	    internal bool mayAllocateRuns;
	
	    /* arrays with one value per text-character */
	    internal sbyte[] dirPropsMemory;
	
	    internal sbyte[] levelsMemory;
	
	    internal sbyte[] dirProps;
	
	    internal sbyte[] levels;
	
	    /* are we performing an approximation of the "inverse Bidi" algorithm? */
	    internal bool isInverse;
	
	    /* are we using the basic algorithm or its variation? */
	    internal int reorderingMode;
	
	    /* bitmask for reordering options */
	    internal int reorderingOptions;
	
	    /* must block separators receive level 0? */
	    internal bool orderParagraphsLTR;
	
	    /* the paragraph level */
	    internal sbyte paraLevel;
	
	    /* original paraLevel when contextual */
	    /* must be one of DEFAULT_xxx or 0 if not contextual */
	    internal sbyte defaultParaLevel;
	
	    /* the following is set in setPara, used in processPropertySeq */
	
	    internal Bidi.ImpTabPair  impTabPair; /* reference to levels state table pair */
	
	    /* the overall paragraph or line directionality */
	    internal sbyte direction;
	
	    /* flags is a bit set for which directional properties are in the text */
	    internal int flags;
	
	    /* lastArabicPos is index to the last AL in the text, -1 if none */
	    internal int lastArabicPos;
	
	    /* characters after trailingWSStart are WS and are */
	    /* implicitly at the paraLevel (rule (L1)) - levels may not reflect that */
	    internal int trailingWSStart;
	
	    /* fields for paragraph handling */
	    internal int paraCount; /* set in getDirProps() */
	
	    internal int[] parasMemory;
	
	    internal int[] paras; /*
	                  * limits of paragraphs, filled in ResolveExplicitLevels() or
	                  * CheckExplicitLevels()
	                  */
	
	    /*
	     * for single paragraph text, we only need a tiny array of paras (no
	     * allocation)
	     */
	    internal int[] simpleParas;
	
	    /* fields for line reordering */
	    internal int runCount; /* ==-1: runs not set up yet */
	
	    internal BidiRun[] runsMemory;
	
	    internal BidiRun[] runs;
	
	    /* for non-mixed text, we only need a tiny array of runs (no allocation) */
	    internal BidiRun[] simpleRuns;
	
	    /* mapping of runs in logical order to visual order */
	    internal int[] logicalToVisualRunsMap;
	
	    /* flag to indicate that the map has been updated */
	    internal bool isGoodLogicalToVisualRunsMap;
	
	    /* customized class provider */
	    internal BidiClassifier customClassifier;
	
	    /* for inverse Bidi with insertion of directional marks */
	    internal Bidi.InsertPoints  insertPoints;
	
	    /* for option OPTION_REMOVE_CONTROLS */
	    internal int controlCount;
	
	    /*
	     * Sometimes, bit values are more appropriate to deal with directionality
	     * properties. Abbreviations in these method names refer to names used in
	     * the Bidi algorithm.
	     */
	    static internal int DirPropFlag(sbyte dir) {
	        return (1 << dir);
	    }
	
	    internal bool TestDirPropFlagAt(int flag_0, int index) {
	        return ((DirPropFlag((sbyte) (dirProps[index] & ~CONTEXT_RTL)) & flag_0) != 0);
	    }
	
	    /*
	     * The following bit is ORed to the property of characters in paragraphs
	     * with contextual RTL direction when paraLevel is contextual.
	     */
	    internal const sbyte CONTEXT_RTL_SHIFT = 6;
	
	    internal const sbyte CONTEXT_RTL = (sbyte) (1 << CONTEXT_RTL_SHIFT); // 0x40
	
	    static internal sbyte NoContextRTL(sbyte dir) {
	        return (sbyte) (dir & ~CONTEXT_RTL);
	    }
	
	    /*
	     * The following is a variant of DirProp.DirPropFlag() which ignores the
	     * CONTEXT_RTL bit.
	     */
	    static internal int DirPropFlagNC(sbyte dir) {
	        return (1 << (dir & ~CONTEXT_RTL));
	    }
	
	    static internal readonly int DirPropFlagMultiRuns = DirPropFlag((sbyte) 31);
	
	    static internal readonly int[] DirPropFlagLR = { DirPropFlag(L), DirPropFlag(R) };
	
	    static internal readonly int[] DirPropFlagE = { DirPropFlag(LRE), DirPropFlag(RLE) };
	
	    static internal readonly int[] DirPropFlagO = { DirPropFlag(LRO), DirPropFlag(RLO) };

        static internal int DirPropFlagLRMthd(sbyte level) {
            return DirPropFlagLR[level & 1];
        }
	
        static internal int DirPropFlagEMthd(sbyte level) {
            return DirPropFlagE[level & 1];
        }
	
        static internal int DirPropFlagOMthd(sbyte level) {
            return DirPropFlagO[level & 1];
        }

        /*
         * are there any characters that are LTR?
         */
	    static internal readonly int MASK_LTR = DirPropFlag(L) | DirPropFlag(EN)
	            | DirPropFlag(AN) | DirPropFlag(LRE) | DirPropFlag(LRO);
	
	    /*
	     * are there any characters that are RTL?
	     */
	    static internal readonly int MASK_RTL = DirPropFlag(R) | DirPropFlag(AL)
	            | DirPropFlag(RLE) | DirPropFlag(RLO);
	
	    /* explicit embedding codes */
	    static internal readonly int MASK_LRX = DirPropFlag(LRE) | DirPropFlag(LRO);
	
	    static internal readonly int MASK_RLX = DirPropFlag(RLE) | DirPropFlag(RLO);
	
	    static internal readonly int MASK_OVERRIDE = DirPropFlag(LRO) | DirPropFlag(RLO);
	
	    static internal readonly int MASK_EXPLICIT = MASK_LRX | MASK_RLX | DirPropFlag(PDF);
	
	    static internal readonly int MASK_BN_EXPLICIT = DirPropFlag(BN) | MASK_EXPLICIT;
	
	    /* paragraph and segment separators */
	    static internal readonly int MASK_B_S = DirPropFlag(B) | DirPropFlag(S);
	
	    /* all types that are counted as White Space or Neutral in some steps */
	    static internal readonly int MASK_WS = MASK_B_S | DirPropFlag(WS) | MASK_BN_EXPLICIT;
	
	    static internal readonly int MASK_N = DirPropFlag(ON) | MASK_WS;
	
	    /*
	     * all types that are included in a sequence of European Terminators for
	     * (W5)
	     */
	    static internal readonly int MASK_ET_NSM_BN = DirPropFlag(ET) | DirPropFlag(NSM)
	            | MASK_BN_EXPLICIT;
	
	    /* types that are neutrals or could becomes neutrals in (Wn) */
	    static internal readonly int MASK_POSSIBLE_N = DirPropFlag(CS) | DirPropFlag(ES)
	            | DirPropFlag(ET) | MASK_N;
	
	    /*
	     * These types may be changed to "e", the embedding type (L or R) of the
	     * run, in the Bidi algorithm (N2)
	     */
	    static internal readonly int MASK_EMBEDDING = DirPropFlag(NSM) | MASK_POSSIBLE_N;
	
	    /*
	     * the dirProp's L and R are defined to 0 and 1 values in
	     * UCharacterDirection.java
	     */
	    static internal sbyte GetLRFromLevel(sbyte level) {
	        return (sbyte) (level & 1);
	    }
	
	    static internal bool IsDefaultLevel(sbyte level) {
	        return ((level & LEVEL_DEFAULT_LTR) == LEVEL_DEFAULT_LTR);
	    }
	
	    internal sbyte GetParaLevelAt(int index) {
	        return (defaultParaLevel != 0) ? (sbyte) (dirProps[index] >> CONTEXT_RTL_SHIFT)
	                : paraLevel;
	    }
	
	    static internal bool IsBidiControlChar(int c) {
	        /*
	         * check for range 0x200c to 0x200f (ZWNJ, ZWJ, LRM, RLM) or 0x202a to
	         * 0x202e (LRE, RLE, PDF, LRO, RLO)
	         */
	        return (((c & -4) == 0x200c) || ((c >= 0x202a) && (c <= 0x202e)));
	    }
	
	    internal void VerifyValidPara() {
	        if (!(this == this.paraBidi)) {
	            throw new InvalidOperationException();
	        }
	    }
	
	    internal void VerifyValidParaOrLine() {
	        Bidi para = this.paraBidi;
	        /* verify Para */
	        if (this == para) {
	            return;
	        }
	        /* verify Line */
	        if ((para == null) || (para != para.paraBidi)) {
	           throw new InvalidOperationException();
	        }
	    }
	
	    internal void VerifyRange(int index, int start, int limit) {
	        if (index < start || index >= limit) {
	            throw new ArgumentException("Value " + index
	                    + " is out of range " + start + " to " + limit);
	        }
	    }
	
	    /// <summary>
	    /// Allocate a <c>Bidi</c> object. Such an object is initially empty.
	    /// It is assigned the Bidi properties of a piece of text containing one or
	    /// more paragraphs by <c>setPara()</c> or the Bidi properties of a
	    /// line within a paragraph by <c>setLine()</c>.
	    /// <p>
	    /// This object can be reused.
	    /// <p>
	    /// <c>setPara()</c> and <c>setLine()</c> will allocate
	    /// additional memory for internal structures as necessary.
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public Bidi() : this(0, 0) {
	    }
	
	    /// <summary>
	    /// Allocate a <c>Bidi</c> object with preallocated memory for internal
	    /// structures. This method provides a <c>Bidi</c> object like the
	    /// default constructor but it also preallocates memory for internal
	    /// structures according to the sizings supplied by the caller.
	    /// <p>
	    /// The preallocation can be limited to some of the internal memory by
	    /// setting some values to 0 here. That means that if, e.g.,
	    /// <c>maxRunCount</c> cannot be reasonably predetermined and should
	    /// not be set to <c>maxLength</c> (the only failproof value) to avoid
	    /// wasting memory, then <c>maxRunCount</c> could be set to 0 here and
	    /// the internal structures that are associated with it will be allocated on
	    /// demand, just like with the default constructor.
	    /// </summary>
	    ///
	    /// <param name="maxLength">is the maximum text or line length that internal memory willbe preallocated for. An attempt to associate this object witha longer text will fail, unless this value is 0, which leavesthe allocation up to the implementation.</param>
	    /// <param name="maxRunCount">is the maximum anticipated number of same-level runs thatinternal memory will be preallocated for. An attempt to accessvisual runs on an object that was not preallocated for as manyruns as the text was actually resolved to will fail, unlessthis value is 0, which leaves the allocation up to theimplementation.<br><br>The number of runs depends on the actual text and maybeanywhere between 1 and <c>maxLength</c>. It is typicallysmall.</param>
	    /// <exception cref="IllegalArgumentException">if maxLength or maxRunCount is less than 0</exception>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public Bidi(int maxLength, int maxRunCount) {
	        this.dirPropsMemory = new sbyte[1];
	        this.levelsMemory = new sbyte[1];
	        this.parasMemory = new int[1];
	        this.simpleParas = new int[] { 0 };
	        this.runsMemory = new BidiRun[0];
	        this.simpleRuns = new BidiRun[] { new BidiRun() };
	        this.customClassifier = null;
	        this.insertPoints = new Bidi.InsertPoints ();
	        /* check the argument values */
	        if (maxLength < 0 || maxRunCount < 0) {
	            throw new ArgumentException();
	        }
	
	        /*
	         * reset the object, all reference variables null, all flags false, all
	         * sizes 0. In fact, we don't need to do anything, since class members
	         * are initialized as zero when an instance is created.
	         */
	        /*
	         * mayAllocateText = false; mayAllocateRuns = false; orderParagraphsLTR
	         * = false; paraCount = 0; runCount = 0; trailingWSStart = 0; flags = 0;
	         * paraLevel = 0; defaultParaLevel = 0; direction = 0;
	         */
	        /* get Bidi properties */
	        try {
	            bdp = IBM.ICU.Impl.UBiDiProps.GetSingleton();
	        } catch (IOException e) {
	            throw new MissingManifestResourceException(e.Message);
	        }
	
	        /* allocate memory for arrays as requested */
	        if (maxLength > 0) {
	            GetInitialDirPropsMemory(maxLength);
	            GetInitialLevelsMemory(maxLength);
	        } else {
	            mayAllocateText = true;
	        }
	
	        if (maxRunCount > 0) {
	            // if maxRunCount == 1, use simpleRuns[]
	            if (maxRunCount > 1) {
	                GetInitialRunsMemory(maxRunCount);
	            }
	        } else {
	            mayAllocateRuns = true;
	        }
	    }
	
	    /*
	     * We are allowed to allocate memory if object==null or mayAllocate==true
	     * for each array that we need.
	     * 
	     * Assume sizeNeeded>0. If object != null, then assume size > 0.
	     */
	    private Object GetMemory(String label, Object array, Type arrayClass,
	            bool mayAllocate, int sizeNeeded) {
	        int length_0 = ((Array)array).Length;
	
	        /* we have at least enough memory and must not allocate */
	        if (sizeNeeded == length_0) {
	            return array;
	        }
	        if (!mayAllocate) {
	            /* we must not allocate */
	            if (sizeNeeded <= length_0) {
	                return array;
	            }
	            throw new Exception("Failed to allocate memory for " + label);
	        }
	        /* we may try to grow or shrink */
	        /*
	         * FOOD FOR THOUGHT: when shrinking it should be possible to avoid the
	         * allocation altogether and rely on this.length
	         */
	        try {
	            return ILOG.J2CsMapping.Collections.Arrays.NewInstance(arrayClass,sizeNeeded);
	        } catch (Exception e) {
                throw new Exception("Failed to allocate memory for " + label);
	        }
	    }
	
	    /* helper methods for each allocated array */
	    private void GetDirPropsMemory(bool mayAllocate, int length_0) {
	        Object array = GetMemory("DirProps", dirPropsMemory, typeof(Byte),
	                mayAllocate, length_0);
	        dirPropsMemory = (sbyte[]) array;
	    }
	
	    internal void GetDirPropsMemory(int length_0) {
	        GetDirPropsMemory(mayAllocateText, length_0);
	    }
	
	    private void GetLevelsMemory(bool mayAllocate, int length_0) {
	        Object array = GetMemory("Levels", levelsMemory, typeof(SByte),
	                mayAllocate, length_0);
	        levelsMemory = (sbyte[]) array;
	    }
	
	    internal void GetLevelsMemory(int length_0) {
	        GetLevelsMemory(mayAllocateText, length_0);
	    }
	
	    private void GetRunsMemory(bool mayAllocate, int length_0) {
	        Object array = GetMemory("Runs", runsMemory, typeof(BidiRun),
	                mayAllocate, length_0);
	        runsMemory = (BidiRun[]) array;
	    }
	
	    internal void GetRunsMemory(int length_0) {
	        GetRunsMemory(mayAllocateRuns, length_0);
	    }
	
	    /* additional methods used by constructor - always allow allocation */
	    private void GetInitialDirPropsMemory(int length_0) {
	        GetDirPropsMemory(true, length_0);
	    }
	
	    private void GetInitialLevelsMemory(int length_0) {
	        GetLevelsMemory(true, length_0);
	    }
	
	    private void GetInitialParasMemory(int length_0) {
	        Object array = GetMemory("Paras", parasMemory, typeof(Int32), true,
	                length_0);
	        parasMemory = (int[]) array;
	    }
	
	    private void GetInitialRunsMemory(int length_0) {
	        GetRunsMemory(true, length_0);
	    }
	
	    /// <summary>
	    /// Modify the operation of the Bidi algorithm such that it approximates an
	    /// "inverse Bidi" algorithm. This method must be called before
	    /// <c>setPara()</c>.
	    /// <p>
	    /// The normal operation of the Bidi algorithm as described in the Unicode
	    /// Technical Report is to take text stored in logical (keyboard, typing)
	    /// order and to determine the reordering of it for visual rendering. Some
	    /// legacy systems store text in visual order, and for operations with
	    /// standard, Unicode-based algorithms, the text needs to be transformed to
	    /// logical order. This is effectively the inverse algorithm of the described
	    /// Bidi algorithm. Note that there is no standard algorithm for this
	    /// "inverse Bidi" and that the current implementation provides only an
	    /// approximation of "inverse Bidi".
	    /// </p>
	    /// <p>
	    /// With <c>isInversed</c> set to <c>true</c>, this method
	    /// changes the behavior of some of the subsequent methods in a way that they
	    /// can be used for the inverse Bidi algorithm. Specifically, runs of text
	    /// with numeric characters will be treated in a special way and may need to
	    /// be surrounded with LRM characters when they are written in reordered
	    /// sequence.
	    /// </p>
	    /// <p>
	    /// Output runs should be retrieved using <c>getVisualRun()</c>. Since
	    /// the actual input for "inverse Bidi" is visually ordered text and
	    /// <c>getVisualRun()</c> gets the reordered runs, these are actually
	    /// the runs of the logically ordered output.
	    /// </p>
	    /// <p>
	    /// Calling this method with argument <c>isInverse</c> set to
	    /// <c>true</c> is equivalent to calling <c>setReorderingMode</c>
	    /// with argument <c>reorderingMode</c> set to
	    /// <c>REORDER_INVERSE_NUMBERS_AS_L</c>.<br>
	    /// Calling this method with argument <c>isInverse</c> set to
	    /// <c>false</c> is equivalent to calling
	    /// <c>setReorderingMode</c> with argument <c>reorderingMode</c>
	    /// set to <c>REORDER_DEFAULT</c>.
	    /// </summary>
	    ///
	    /// <param name="isInverse_0">specifies "forward" or "inverse" Bidi operation.</param>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.SetPara(System.String, System.Byte, null)"/>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.WriteReordered(System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.SetReorderingMode(System.Int32)"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.REORDER_INVERSE_NUMBERS_AS_L"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.REORDER_DEFAULT"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public void SetInverse(bool isInverse_0) {
	        this.isInverse = (isInverse_0);
	        this.reorderingMode = (isInverse_0) ? REORDER_INVERSE_NUMBERS_AS_L
	                : REORDER_DEFAULT;
	    }
	
	    /// <summary>
	    /// Is this <c>Bidi</c> object set to perform the inverse Bidi
	    /// algorithm?
	    /// <p>
	    /// Note: calling this method after setting the reordering mode with
	    /// <c>setReorderingMode</c> will return <c>true</c> if the
	    /// reordering mode was set to
	    /// <code>REORDER_INVERSE_NUMBERS_AS_L<code>, <c>false</c> for all
	    /// other values.
	    /// </p>
	    /// </summary>
	    ///
	    /// <returns><c>true</c> if the <c>Bidi</c> object is set to
	    /// perform the inverse Bidi algorithm by handling numbers as L.</returns>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.SetInverse(System.Boolean)"/>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.SetReorderingMode(System.Int32)"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.REORDER_INVERSE_NUMBERS_AS_L"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public bool IsInverse() {
	        return isInverse;
	    }
	
	    /// <summary>
	    /// Modify the operation of the Bidi algorithm such that it implements some
	    /// variant to the basic Bidi algorithm or approximates an "inverse Bidi"
	    /// algorithm, depending on different values of the "reordering mode". This
	    /// method must be called before <c>setPara()</c>, and stays in effect
	    /// until called again with a different argument.
	    /// <p>
	    /// The normal operation of the Bidi algorithm as described in the Unicode
	    /// Standard Annex #9 is to take text stored in logical (keyboard, typing)
	    /// order and to determine how to reorder it for visual rendering.
	    /// </p>
	    /// <p>
	    /// With the reordering mode set to a value other than
	    /// <c>REORDER_DEFAULT</c>, this method changes the behavior of some of
	    /// the subsequent methods in a way such that they implement an inverse Bidi
	    /// algorithm or some other algorithm variants.
	    /// </p>
	    /// <p>
	    /// Some legacy systems store text in visual order, and for operations with
	    /// standard, Unicode-based algorithms, the text needs to be transformed into
	    /// logical order. This is effectively the inverse algorithm of the described
	    /// Bidi algorithm. Note that there is no standard algorithm for this
	    /// "inverse Bidi", so a number of variants are implemented here.
	    /// </p>
	    /// <p>
	    /// In other cases, it may be desirable to emulate some variant of the
	    /// Logical to Visual algorithm (e.g. one used in MS Windows), or perform a
	    /// Logical to Logical transformation.
	    /// </p>
	    /// <ul>
	    /// <li>When the Reordering Mode is set to <c>REORDER_DEFAULT</c>, the
	    /// standard Bidi Logical to Visual algorithm is applied.</li>
	    /// <li>When the reordering mode is set to
	    /// <c>REORDER_NUMBERS_SPECIAL</c>, the algorithm used to perform Bidi
	    /// transformations when calling <c>setPara</c> should approximate the
	    /// algorithm used in Microsoft Windows XP rather than strictly conform to
	    /// the Unicode Bidi algorithm. <br>
	    /// The differences between the basic algorithm and the algorithm addressed
	    /// by this option are as follows:
	    /// <ul>
	    /// <li>Within text at an even embedding level, the sequence "123AB" (where
	    /// AB represent R or AL letters) is transformed to "123BA" by the Unicode
	    /// algorithm and to "BA123" by the Windows algorithm.</li>
	    /// <li>Arabic-Indic numbers (AN) are handled by the Windows algorithm just
	    /// like regular numbers (EN).</li>
	    /// </ul>
	    /// </li>
	    /// <li>When the reordering mode is set to
	    /// <c>REORDER_GROUP_NUMBERS_WITH_R</c>, numbers located between LTR
	    /// text and RTL text are associated with the RTL text. For instance, an LTR
	    /// paragraph with content "abc 123 DEF" (where upper case letters represent
	    /// RTL characters) will be transformed to "abc FED 123" (and not
	    /// "abc 123 FED"), "DEF 123 abc" will be transformed to "123 FED abc" and
	    /// "123 FED abc" will be transformed to "DEF 123 abc". This makes the
	    /// algorithm reversible and makes it useful when round trip (from visual to
	    /// logical and back to visual) must be achieved without adding LRM
	    /// characters. However, this is a variation from the standard Unicode Bidi
	    /// algorithm.<br>
	    /// The source text should not contain Bidi control characters other than LRM
	    /// or RLM.</li>
	    /// <li>When the reordering mode is set to <c>REORDER_RUNS_ONLY</c>, a
	    /// "Logical to Logical" transformation must be performed:
	    /// <ul>
	    /// <li>If the default text level of the source text (argument
	    /// <c>paraLevel</c> in <c>setPara</c>) is even, the source text
	    /// will be handled as LTR logical text and will be transformed to the RTL
	    /// logical text which has the same LTR visual display.</li>
	    /// <li>If the default level of the source text is odd, the source text will
	    /// be handled as RTL logical text and will be transformed to the LTR logical
	    /// text which has the same LTR visual display.</li>
	    /// </ul>
	    /// This mode may be needed when logical text which is basically Arabic or
	    /// Hebrew, with possible included numbers or phrases in English, has to be
	    /// displayed as if it had an even embedding level (this can happen if the
	    /// displaying application treats all text as if it was basically LTR). <br>
	    /// This mode may also be needed in the reverse case, when logical text which
	    /// is basically English, with possible included phrases in Arabic or Hebrew,
	    /// has to be displayed as if it had an odd embedding level. <br>
	    /// Both cases could be handled by adding LRE or RLE at the head of the text,
	    /// if the display subsystem supports these formatting controls. If it does
	    /// not, the problem may be handled by transforming the source text in this
	    /// mode before displaying it, so that it will be displayed properly. <br>
	    /// The source text should not contain Bidi control characters other than LRM
	    /// or RLM.</li>
	    /// <li>When the reordering mode is set to
	    /// <c>REORDER_INVERSE_NUMBERS_AS_L</c>, an "inverse Bidi" algorithm is
	    /// applied. Runs of text with numeric characters will be treated like LTR
	    /// letters and may need to be surrounded with LRM characters when they are
	    /// written in reordered sequence (the option
	    /// <c>INSERT_LRM_FOR_NUMERIC</c> can be used with method
	    /// <c>writeReordered</c> to this end. This mode is equivalent to
	    /// calling <c>setInverse()</c> with argument <c>isInverse</c>
	    /// set to <c>true</c>.</li>
	    /// <li>When the reordering mode is set to
	    /// <c>REORDER_INVERSE_LIKE_DIRECT</c>, the "direct" Logical to Visual
	    /// Bidi algorithm is used as an approximation of an "inverse Bidi"
	    /// algorithm. This mode is similar to mode
	    /// <c>REORDER_INVERSE_NUMBERS_AS_L</c> but is closer to the regular
	    /// Bidi algorithm. <br>
	    /// For example, an LTR paragraph with the content "FED 123 456 CBA" (where
	    /// upper case represents RTL characters) will be transformed to
	    /// "ABC 456 123 DEF", as opposed to "DEF 123 456 ABC" with mode
	    /// <c>REORDER_INVERSE_NUMBERS_AS_L</c>.<br>
	    /// When used in conjunction with option <c>OPTION_INSERT_MARKS</c>,
	    /// this mode generally adds Bidi marks to the output significantly more
	    /// sparingly than mode <c>REORDER_INVERSE_NUMBERS_AS_L</c>.<br>
	    /// with option <c>INSERT_LRM_FOR_NUMERIC</c> in calls to
	    /// <c>writeReordered</c>.</li>
	    /// <li>When the reordering mode is set to
	    /// <c>REORDER_INVERSE_FOR_NUMBERS_SPECIAL</c>, the Logical to Visual
	    /// Bidi algorithm used in Windows XP is used as an approximation of an
	    /// "inverse Bidi" algorithm. <br>
	    /// For example, an LTR paragraph with the content "abc FED123" (where upper
	    /// case represents RTL characters) will be transformed to "abc 123DEF.</li>
	    /// </ul>
	    /// <p>
	    /// In all the reordering modes specifying an "inverse Bidi" algorithm (i.e.
	    /// those with a name starting with <c>REORDER_INVERSE</c>), output
	    /// runs should be retrieved using <c>getVisualRun()</c>, and the
	    /// output text with <c>writeReordered()</c>. The caller should keep in
	    /// mind that in "inverse Bidi" modes the input is actually visually ordered
	    /// text and reordered output returned by <c>getVisualRun()</c> or
	    /// <c>writeReordered()</c> are actually runs or character string of
	    /// logically ordered output.<br>
	    /// For all the "inverse Bidi" modes, the source text should not contain Bidi
	    /// control characters other than LRM or RLM.
	    /// </p>
	    /// <p>
	    /// Note that option <c>OUTPUT_REVERSE</c> of
	    /// <c>writeReordered</c> has no useful meaning and should not be used
	    /// in conjunction with any value of the reordering mode specifying "inverse
	    /// Bidi" or with value <c>REORDER_RUNS_ONLY</c>.
	    /// </summary>
	    ///
	    /// <param name="reorderingMode_0">specifies the required variant of the Bidi algorithm.</param>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.SetInverse(System.Boolean)"/>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.SetPara(System.String, System.Byte, null)"/>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.WriteReordered(System.Int32)"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.INSERT_LRM_FOR_NUMERIC"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.OUTPUT_REVERSE"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.REORDER_DEFAULT"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.REORDER_NUMBERS_SPECIAL"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.REORDER_GROUP_NUMBERS_WITH_R"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.REORDER_RUNS_ONLY"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.REORDER_INVERSE_NUMBERS_AS_L"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.REORDER_INVERSE_LIKE_DIRECT"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.REORDER_INVERSE_FOR_NUMBERS_SPECIAL"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public void SetReorderingMode(int reorderingMode_0) {
	        if ((reorderingMode_0 < REORDER_DEFAULT)
	                || (reorderingMode_0 >= REORDER_COUNT))
	            return; /* don't accept a wrong value */
	        this.reorderingMode = reorderingMode_0;
	        this.isInverse = reorderingMode_0 == REORDER_INVERSE_NUMBERS_AS_L;
	    }
	
	    /// <summary>
	    /// What is the requested reordering mode for a given Bidi object?
	    /// </summary>
	    ///
	    /// <returns>the current reordering mode of the Bidi object</returns>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.SetReorderingMode(System.Int32)"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public int GetReorderingMode() {
	        return this.reorderingMode;
	    }
	
	    /// <summary>
	    /// Specify which of the reordering options should be applied during Bidi
	    /// transformations.
	    /// </summary>
	    ///
	    /// <param name="options">A combination of zero or more of the following reorderingoptions: <c>OPTION_DEFAULT</c>,<c>OPTION_INSERT_MARKS</c>,<c>OPTION_REMOVE_CONTROLS</c>,<c>OPTION_STREAMING</c>.</param>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.GetReorderingOptions"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.OPTION_DEFAULT"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.OPTION_INSERT_MARKS"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.OPTION_REMOVE_CONTROLS"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.OPTION_STREAMING"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public void SetReorderingOptions(int options) {
	        if ((options & OPTION_REMOVE_CONTROLS) != 0) {
	            this.reorderingOptions = options & ~OPTION_INSERT_MARKS;
	        } else {
	            this.reorderingOptions = options;
	        }
	    }
	
	    /// <summary>
	    /// What are the reordering options applied to a given Bidi object?
	    /// </summary>
	    ///
	    /// <returns>the current reordering options of the Bidi object</returns>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.SetReorderingOptions(System.Int32)"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public int GetReorderingOptions() {
	        return this.reorderingOptions;
	    }
	
	    /*
	     * perform (P2)..(P3)
	     * -------------------------------------------------------
	     */
	
	    private void GetDirProps() {
	        int i = 0, i0, i1;
	        flags = 0; /* collect all directionalities in the text */
	        int uchar;
	        sbyte dirProp;
	        sbyte paraDirDefault = 0; /* initialize to avoid compiler warnings */
	        bool isDefaultLevel = IsDefaultLevel(paraLevel);
	        /*
	         * for inverse Bidi, the default para level is set to RTL if there is a
	         * strong R or AL character at either end of the text
	         */
	        bool isDefaultLevelInverse = isDefaultLevel
	                && (reorderingMode == REORDER_INVERSE_LIKE_DIRECT || reorderingMode == REORDER_INVERSE_FOR_NUMBERS_SPECIAL);
	        lastArabicPos = -1;
	        controlCount = 0;
	        bool removeBidiControls = (reorderingOptions & OPTION_REMOVE_CONTROLS) != 0;
	
	        int NOT_CONTEXTUAL = 0; /* 0: not contextual paraLevel */
	        int LOOKING_FOR_STRONG = 1; /* 1: looking for first strong char */
	        int FOUND_STRONG_CHAR = 2; /* 2: found first strong char */
	
	        int state;
	        int paraStart = 0; /* index of first char in paragraph */
	        sbyte paraDir; /*
	                       * == CONTEXT_RTL within paragraphs starting with strong R
	                       * char
	                       */
	        sbyte lastStrongDir = 0; /* for default level & inverse Bidi */
	        int lastStrongLTR = 0; /* for STREAMING option */
	
	        if ((reorderingOptions & OPTION_STREAMING) > 0) {
	            length = 0;
	            lastStrongLTR = 0;
	        }
	        if (isDefaultLevel) {
	            paraDirDefault = ((paraLevel & 1) != 0) ? (sbyte) (CONTEXT_RTL) : (sbyte) (0);
	            paraDir = paraDirDefault;
	            lastStrongDir = paraDirDefault;
	            state = LOOKING_FOR_STRONG;
	        } else {
	            state = NOT_CONTEXTUAL;
	            paraDir = 0;
	        }
	        /* count paragraphs and determine the paragraph level (P2..P3) */
	        /*
	         * see comment on constant fields: the LEVEL_DEFAULT_XXX values are
	         * designed so that their low-order bit alone yields the intended
	         * default
	         */
	
	        for (i = 0; i < originalLength; /* i is incremented in the loop */) {
	            i0 = i; /* index of first code unit */
	            uchar = IBM.ICU.Text.UTF16.CharAt(text, 0, originalLength, i);
	            i += IBM.ICU.Text.UTF16.GetCharCount(uchar);
	            i1 = i - 1; /*
	                         * index of last code unit, gets the directional
	                         * property
	                         */
	
	            dirProp = (sbyte) GetCustomizedClass(uchar);
	            flags |= DirPropFlag(dirProp);
	            dirProps[i1] = (sbyte) (dirProp | paraDir);
	            if (i1 > i0) { /* set previous code units' properties to BN */
	                flags |= DirPropFlag(BN);
	                do {
	                    dirProps[--i1] = (sbyte) (BN | paraDir);
	                } while (i1 > i0);
	            }
	            if (state == LOOKING_FOR_STRONG) {
	                if (dirProp == L) {
	                    state = FOUND_STRONG_CHAR;
	                    if (paraDir != 0) {
	                        paraDir = 0;
	                        for (i1 = paraStart; i1 < i; i1++) {
	                            dirProps[i1] &= ~CONTEXT_RTL;
	                        }
	                    }
	                    continue;
	                }
	                if (dirProp == R || dirProp == AL) {
	                    state = FOUND_STRONG_CHAR;
	                    if (paraDir == 0) {
	                        paraDir = CONTEXT_RTL;
	                        for (i1 = paraStart; i1 < i; i1++) {
	                            dirProps[i1] |= CONTEXT_RTL;
	                        }
	                    }
	                    continue;
	                }
	            }
	            if (dirProp == L) {
	                lastStrongDir = 0;
	                lastStrongLTR = i; /* i is index to next character */
	            } else if (dirProp == R) {
	                lastStrongDir = CONTEXT_RTL;
	            } else if (dirProp == AL) {
	                lastStrongDir = CONTEXT_RTL;
	                lastArabicPos = i - 1;
	            } else if (dirProp == B) {
	                if ((reorderingOptions & OPTION_STREAMING) != 0) {
	                    this.length = i; /* i is index to next character */
	                }
	                if (isDefaultLevelInverse && (lastStrongDir == CONTEXT_RTL)
	                        && (paraDir != lastStrongDir)) {
	                    for (; paraStart < i; paraStart++) {
	                        dirProps[paraStart] |= CONTEXT_RTL;
	                    }
	                }
	                if (i < originalLength) { /* B not last char in text */
	                    if (!((uchar == (int) CR) && (text[i] == (int) LF))) {
	                        paraCount++;
	                    }
	                    if (isDefaultLevel) {
	                        state = LOOKING_FOR_STRONG;
	                        paraStart = i; /* i is index to next character */
	                        paraDir = paraDirDefault;
	                        lastStrongDir = paraDirDefault;
	                    }
	                }
	            }
	            if (removeBidiControls && IsBidiControlChar(uchar)) {
	                controlCount++;
	            }
	        }
	        if (isDefaultLevelInverse && (lastStrongDir == CONTEXT_RTL)
	                && (paraDir != lastStrongDir)) {
	            for (i1 = paraStart; i1 < originalLength; i1++) {
	                dirProps[i1] |= CONTEXT_RTL;
	            }
	        }
	        if (isDefaultLevel) {
	            paraLevel = GetParaLevelAt(0);
	        }
	        if ((reorderingOptions & OPTION_STREAMING) > 0) {
	            if ((lastStrongLTR > this.length)
	                    && (GetParaLevelAt(lastStrongLTR) == 0)) {
	                this.length = lastStrongLTR;
	            }
	            if (this.length < originalLength) {
	                paraCount--;
	            }
	        }
	        /*
	         * The following line does nothing new for contextual paraLevel, but is
	         * needed for absolute paraLevel.
	         */
            flags |= DirPropFlagLRMthd(paraLevel);
	
	        if (orderParagraphsLTR && (flags & DirPropFlag(B)) != 0) {
	            flags |= DirPropFlag(L);
	        }
	    }
	
	    /*
	     * perform (X1)..(X9)
	     * -------------------------------------------------------
	     */
	
	    /* determine if the text is mixed-directional or single-directional */
	    private sbyte DirectionFromFlags() {
	        /*
	         * if the text contains AN and neutrals, then some neutrals may become
	         * RTL
	         */
	        if (!((flags & MASK_RTL) != 0 || ((flags & DirPropFlag(AN)) != 0 && (flags & MASK_POSSIBLE_N) != 0))) {
	            return LTR;
	        } else if ((flags & MASK_LTR) == 0) {
	            return RTL;
	        } else {
	            return MIXED;
	        }
	    }
	
	    /*
	     * Resolve the explicit levels as specified by explicit embedding codes.
	     * Recalculate the flags to have them reflect the real properties after
	     * taking the explicit embeddings into account.
	     * 
	     * The Bidi algorithm is designed to result in the same behavior whether
	     * embedding levels are externally specified (from "styled text", supposedly
	     * the preferred method) or set by explicit embedding codes (LRx, RLx, PDF)
	     * in the plain text. That is why (X9) instructs to remove all explicit
	     * codes (and BN). However, in a real implementation, this removal of these
	     * codes and their index positions in the plain text is undesirable since it
	     * would result in reallocated, reindexed text. Instead, this implementation
	     * leaves the codes in there and just ignores them in the subsequent
	     * processing. In order to get the same reordering behavior, positions with
	     * a BN or an explicit embedding code just get the same level assigned as
	     * the last "real" character.
	     * 
	     * Some implementations, not this one, then overwrite some of these
	     * directionality properties at "real" same-level-run boundaries by L or R
	     * codes so that the resolution of weak types can be performed on the entire
	     * paragraph at once instead of having to parse it once more and perform
	     * that resolution on same-level-runs. This limits the scope of the implicit
	     * rules in effectively the same way as the run limits.
	     * 
	     * Instead, this implementation does not modify these codes. On one hand,
	     * the paragraph has to be scanned for same-level-runs, but on the other
	     * hand, this saves another loop to reset these codes, or saves making and
	     * modifying a copy of dirProps[].
	     * 
	     * 
	     * Note that (Pn) and (Xn) changed significantly from version 4 of the Bidi
	     * algorithm.
	     * 
	     * 
	     * Handling the stack of explicit levels (Xn):
	     * 
	     * With the Bidi stack of explicit levels, as pushed with each LRE, RLE,
	     * LRO, and RLO and popped with each PDF, the explicit level must never
	     * exceed MAX_EXPLICIT_LEVEL==61.
	     * 
	     * In order to have a correct push-pop semantics even in the case of
	     * overflows, there are two overflow counters: - countOver60 is incremented
	     * with each LRx at level 60 - from level 60, one RLx increases the level to
	     * 61 - countOver61 is incremented with each LRx and RLx at level 61
	     * 
	     * Popping levels with PDF must work in the opposite order so that level 61
	     * is correct at the correct point. Underflows (too many PDFs) must be
	     * checked.
	     * 
	     * This implementation assumes that MAX_EXPLICIT_LEVEL is odd.
	     */
	    private sbyte ResolveExplicitLevels() {
	        int i = 0;
	        sbyte dirProp;
	        sbyte level = GetParaLevelAt(0);
	
	        sbyte direction_0;
	        int paraIndex = 0;
	
	        /* determine if the text is mixed-directional or single-directional */
	        direction_0 = DirectionFromFlags();
	
	        /*
	         * we may not need to resolve any explicit levels, but for multiple
	         * paragraphs we want to loop on all chars to set the para boundaries
	         */
	        if ((direction_0 != MIXED) && (paraCount == 1)) {
	            /*
	             * not mixed directionality: levels don't matter - trailingWSStart
	             * will be 0
	             */
	        } else if ((paraCount == 1)
	                && ((flags & MASK_EXPLICIT) == 0 || reorderingMode > REORDER_LAST_LOGICAL_TO_VISUAL)) {
	            /* mixed, but all characters are at the same embedding level */
	            /* or we are in "inverse Bidi" */
	            /* and we don't have contextual multiple paragraphs with some B char */
	            /* set all levels to the paragraph level */
	            for (i = 0; i < length; ++i) {
	                levels[i] = level;
	            }
	        } else {
	            /* continue to perform (Xn) */
	
	            /*
	             * (X1) level is set for all codes, embeddingLevel keeps track of
	             * the push/pop operations
	             */
	            /*
	             * both variables may carry the LEVEL_OVERRIDE flag to indicate the
	             * override status
	             */
	            sbyte embeddingLevel = level;
	            sbyte newLevel;
	            byte stackTop = 0;
	
	            sbyte[] stack = new sbyte[MAX_EXPLICIT_LEVEL]; /*
	                                                          * we never push
	                                                          * anything
	                                                          * >=MAX_EXPLICIT_LEVEL
	                                                          */
	            int countOver60 = 0;
	            int countOver61 = 0; /* count overflows of explicit levels */
	
	            /* recalculate the flags */
	            flags = 0;
	
	            for (i = 0; i < length; ++i) {
	                dirProp = NoContextRTL(dirProps[i]);
	                switch (dirProp) {
	                case LRE:
	                case LRO:
	                    /* (X3, X5) */
	                    newLevel = (sbyte) ((embeddingLevel + 2) & ~(LEVEL_OVERRIDE | 1)); /*
	                                                                                       * least
	                                                                                       * greater
	                                                                                       * even
	                                                                                       * level
	                                                                                       */
	                    if (newLevel <= MAX_EXPLICIT_LEVEL) {
	                        stack[stackTop] = embeddingLevel;
	                        ++stackTop;
	                        embeddingLevel = newLevel;
	                        if (dirProp == LRO) {
	                            embeddingLevel |= LEVEL_OVERRIDE;
	                        }
	                        /*
	                         * we don't need to set LEVEL_OVERRIDE off for LRE since
	                         * this has already been done for newLevel which is the
	                         * source for embeddingLevel.
	                         */
	                    } else if ((embeddingLevel & ~LEVEL_OVERRIDE) == MAX_EXPLICIT_LEVEL) {
	                        ++countOver61;
	                    } else /*
	                            * (embeddingLevel & ~LEVEL_OVERRIDE) ==
	                            * MAX_EXPLICIT_LEVEL-1
	                            */{
	                        ++countOver60;
	                    }
	                    flags |= DirPropFlag(BN);
	                    break;
	                case RLE:
	                case RLO:
	                    /* (X2, X4) */
	                    newLevel = (sbyte) (((embeddingLevel & ~LEVEL_OVERRIDE) + 1) | 1); /*
	                                                                                       * least
	                                                                                       * greater
	                                                                                       * odd
	                                                                                       * level
	                                                                                       */
	                    if (newLevel <= MAX_EXPLICIT_LEVEL) {
	                        stack[stackTop] = embeddingLevel;
	                        ++stackTop;
	                        embeddingLevel = newLevel;
	                        if (dirProp == RLO) {
	                            embeddingLevel |= LEVEL_OVERRIDE;
	                        }
	                        /*
	                         * we don't need to set LEVEL_OVERRIDE off for RLE since
	                         * this has already been done for newLevel which is the
	                         * source for embeddingLevel.
	                         */
	                    } else {
	                        ++countOver61;
	                    }
	                    flags |= DirPropFlag(BN);
	                    break;
	                case PDF:
	                    /* (X7) */
	                    /* handle all the overflow cases first */
	                    if (countOver61 > 0) {
	                        --countOver61;
	                    } else if (countOver60 > 0
	                            && (embeddingLevel & ~LEVEL_OVERRIDE) != MAX_EXPLICIT_LEVEL) {
	                        /* handle LRx overflows from level 60 */
	                        --countOver60;
	                    } else if (stackTop > 0) {
	                        /*
	                         * this is the pop operation; it also pops level 61
	                         * while countOver60>0
	                         */
	                        --stackTop;
	                        embeddingLevel = stack[stackTop];
	                        /* } else { (underflow) */
	                    }
	                    flags |= DirPropFlag(BN);
	                    break;
	                case B:
	                    stackTop = 0;
	                    countOver60 = 0;
	                    countOver61 = 0;
	                    level = GetParaLevelAt(i);
	                    if ((i + 1) < length) {
	                        embeddingLevel = GetParaLevelAt(i + 1);
	                        if (!((text[i] == CR) && (text[i + 1] == LF))) {
	                            paras[paraIndex++] = i + 1;
	                        }
	                    }
	                    flags |= DirPropFlag(B);
	                    break;
	                case BN:
	                    /* BN, LRE, RLE, and PDF are supposed to be removed (X9) */
	                    /*
	                     * they will get their levels set correctly in
	                     * adjustWSLevels()
	                     */
	                    flags |= DirPropFlag(BN);
	                    break;
	                default:
	                    /* all other types get the "real" level */
	                    if (level != embeddingLevel) {
	                        level = embeddingLevel;
	                        if ((level & LEVEL_OVERRIDE) != 0) {
                                flags |= DirPropFlagOMthd(level) | DirPropFlagMultiRuns;
	                        } else {
                                flags |= DirPropFlagEMthd(level) | DirPropFlagMultiRuns;
	                        }
	                    }
	                    if ((level & LEVEL_OVERRIDE) == 0) {
	                        flags |= DirPropFlag(dirProp);
	                    }
	                    break;
	                }
	
	                /*
	                 * We need to set reasonable levels even on BN codes and
	                 * explicit codes because we will later look at same-level runs
	                 * (X10).
	                 */
	                levels[i] = level;
	            }
	            if ((flags & MASK_EMBEDDING) != 0) {
                    flags |= DirPropFlagLRMthd(paraLevel);
	            }
	            if (orderParagraphsLTR && (flags & DirPropFlag(B)) != 0) {
	                flags |= DirPropFlag(L);
	            }
	
	            /* subsequently, ignore the explicit codes and BN (X9) */
	
	            /*
	             * again, determine if the text is mixed-directional or
	             * single-directional
	             */
	            direction_0 = DirectionFromFlags();
	        }
	
	        return direction_0;
	    }
	
	    /*
	     * Use a pre-specified embedding levels array:
	     * 
	     * Adjust the directional properties for overrides (->LEVEL_OVERRIDE),
	     * ignore all explicit codes (X9), and check all the preset levels.
	     * 
	     * Recalculate the flags to have them reflect the real properties after
	     * taking the explicit embeddings into account.
	     */
	    private sbyte CheckExplicitLevels() {
	        sbyte dirProp;
	        int i;
	        this.flags = 0; /* collect all directionalities in the text */
	        sbyte level;
	        int paraIndex = 0;
	
	        for (i = 0; i < length; ++i) {
	            level = levels[i];
	            dirProp = NoContextRTL(dirProps[i]);
	            if ((level & LEVEL_OVERRIDE) != 0) {
	                /* keep the override flag in levels[i] but adjust the flags */
	                level &= ~LEVEL_OVERRIDE; /* make the range check below simpler */
                    flags |= DirPropFlagOMthd(level);
	            } else {
	                /* set the flags */
                    flags |= DirPropFlagEMthd(level) | DirPropFlag(dirProp);
	            }
	            if ((level < GetParaLevelAt(i) && !((0 == level) && (dirProp == B)))
	                    || (MAX_EXPLICIT_LEVEL < level)) {
	                /* level out of bounds */
	                throw new ArgumentException("level " + level
	                        + " out of bounds at " + i);
	            }
	            if ((dirProp == B) && ((i + 1) < length)) {
	                if (!((text[i] == CR) && (text[i + 1] == LF))) {
	                    paras[paraIndex++] = i + 1;
	                }
	            }
	        }
	        if ((flags & MASK_EMBEDDING) != 0) {
                flags |= DirPropFlagLRMthd(paraLevel);
	        }
	
	        /* determine if the text is mixed-directional or single-directional */
	        return DirectionFromFlags();
	    }
	
	    /*********************************************************************/
	    /* The Properties state machine table */
	    /*********************************************************************/
	    /*                                                                   */
	    /* All table cells are 8 bits: */
	    /* bits 0..4: next state */
	    /* bits 5..7: action to perform (if > 0) */
	    /*                                                                   */
	    /* Cells may be of format "n" where n represents the next state */
	    /* (except for the rightmost column). */
	    /* Cells may also be of format "_(x,y)" where x represents an action */
	    /* to perform and y represents the next state. */
	    /*                                                                   */
	    /*********************************************************************/
	    /* Definitions and type for properties state tables */
	    private const int IMPTABPROPS_COLUMNS = 14;
	
	    private const int IMPTABPROPS_RES = IMPTABPROPS_COLUMNS - 1;
	
	    private static short GetStateProps(short cell) {
	        return (short) (cell & 0x1f);
	    }
	
	    private static short GetActionProps(short cell) {
	        return (short) (cell >> 5);
	    }
	
	    private static readonly short[] groupProp = { 0, 1, 2, 7, 8, 3, 9, 6, 5, 4, 4,
	            10, 10, 12, 10, 10, 10, 11, 10 };
	
	    private const short _L = 0;
	
	    private const short _R = 1;
	
	    private const short _EN = 2;
	
	    private const short _AN = 3;
	
	    private const short _ON = 4;
	
	    private const short _S = 5;
	
	    private const short _B = 6; /* reduced dirProp */
	
	    private static readonly short[][] impTabProps = {
	            new short[] { 1, 2, 4, 5, 7, 15, 17, 7, 9, 7, 0, 7, 3, _ON },
	            new short[] { 1, 32 + 2, 32 + 4, 32 + 5, 32 + 7, 32 + 15, 32 + 17,
	                    32 + 7, 32 + 9, 32 + 7, 1, 1, 32 + 3, _L },
	            new short[] { 32 + 1, 2, 32 + 4, 32 + 5, 32 + 7, 32 + 15, 32 + 17,
	                    32 + 7, 32 + 9, 32 + 7, 2, 2, 32 + 3, _R },
	            new short[] { 32 + 1, 32 + 2, 32 + 6, 32 + 6, 32 + 8, 32 + 16,
	                    32 + 17, 32 + 8, 32 + 8, 32 + 8, 3, 3, 3, _R },
	            new short[] { 32 + 1, 32 + 2, 4, 32 + 5, 32 + 7, 32 + 15, 32 + 17,
	                    64 + 10, 11, 64 + 10, 4, 4, 32 + 3, _EN },
	            new short[] { 32 + 1, 32 + 2, 32 + 4, 5, 32 + 7, 32 + 15, 32 + 17,
	                    32 + 7, 32 + 9, 64 + 12, 5, 5, 32 + 3, _AN },
	            new short[] { 32 + 1, 32 + 2, 6, 6, 32 + 8, 32 + 16, 32 + 17,
	                    32 + 8, 32 + 8, 64 + 13, 6, 6, 32 + 3, _AN },
	            new short[] { 32 + 1, 32 + 2, 32 + 4, 32 + 5, 7, 32 + 15, 32 + 17,
	                    7, 64 + 14, 7, 7, 7, 32 + 3, _ON },
	            new short[] { 32 + 1, 32 + 2, 32 + 6, 32 + 6, 8, 32 + 16, 32 + 17,
	                    8, 8, 8, 8, 8, 32 + 3, _ON },
	            new short[] { 32 + 1, 32 + 2, 4, 32 + 5, 7, 32 + 15, 32 + 17, 7, 9,
	                    7, 9, 9, 32 + 3, _ON },
	            new short[] { 96 + 1, 96 + 2, 4, 96 + 5, 128 + 7, 96 + 15, 96 + 17,
	                    128 + 7, 128 + 14, 128 + 7, 10, 128 + 7, 96 + 3, _EN },
	            new short[] { 32 + 1, 32 + 2, 4, 32 + 5, 32 + 7, 32 + 15, 32 + 17,
	                    32 + 7, 11, 32 + 7, 11, 11, 32 + 3, _EN },
	            new short[] { 96 + 1, 96 + 2, 96 + 4, 5, 128 + 7, 96 + 15, 96 + 17,
	                    128 + 7, 128 + 14, 128 + 7, 12, 128 + 7, 96 + 3, _AN },
	            new short[] { 96 + 1, 96 + 2, 6, 6, 128 + 8, 96 + 16, 96 + 17,
	                    128 + 8, 128 + 8, 128 + 8, 13, 128 + 8, 96 + 3, _AN },
	            new short[] { 32 + 1, 32 + 2, 128 + 4, 32 + 5, 7, 32 + 15, 32 + 17,
	                    7, 14, 7, 14, 14, 32 + 3, _ON },
	            new short[] { 32 + 1, 32 + 2, 32 + 4, 32 + 5, 32 + 7, 15, 32 + 17,
	                    32 + 7, 32 + 9, 32 + 7, 15, 32 + 7, 32 + 3, _S },
	            new short[] { 32 + 1, 32 + 2, 32 + 6, 32 + 6, 32 + 8, 16, 32 + 17,
	                    32 + 8, 32 + 8, 32 + 8, 16, 32 + 8, 32 + 3, _S },
	            new short[] { 32 + 1, 32 + 2, 32 + 4, 32 + 5, 32 + 7, 32 + 15, 17,
	                    32 + 7, 32 + 9, 32 + 7, 17, 32 + 7, 32 + 3, _B } };
	
	    /*********************************************************************/
	    /* The levels state machine tables */
	    /*********************************************************************/
	    /*                                                                   */
	    /* All table cells are 8 bits: */
	    /* bits 0..3: next state */
	    /* bits 4..7: action to perform (if > 0) */
	    /*                                                                   */
	    /* Cells may be of format "n" where n represents the next state */
	    /* (except for the rightmost column). */
	    /* Cells may also be of format "_(x,y)" where x represents an action */
	    /* to perform and y represents the next state. */
	    /*                                                                   */
	    /* This format limits each table to 16 states each and to 15 actions. */
	    /*                                                                   */
	    /*********************************************************************/
	    /* Definitions and type for levels state tables */
	    private const int IMPTABLEVELS_COLUMNS = _B + 2;
	
	    private const int IMPTABLEVELS_RES = IMPTABLEVELS_COLUMNS - 1;
	
	    private static short GetState(byte cell) {
	        return (short) (cell & 0x0f);
	    }
	
	    private static short GetAction(byte cell) {
	        return (short) (cell >> 4);
	    }
	
	    public class ImpTabPair {
	        internal byte[][][] imptab;
	
	        internal short[][] impact;
	
	        internal ImpTabPair(byte[][] table1, byte[][] table2, short[] act1, short[] act2) {
	            imptab = new byte[][][] { table1, table2 };
	            impact = new short[][] { act1, act2 };
	        }
	    }
	
	    private static readonly byte[][] impTabL_DEFAULT = {
	            new byte[] { 0, 1, 0, 2, 0, 0, 0, 0 },
	            new byte[] { 0, 1, 3, 3, 0x14, 0x14, 0, 1 },
	            new byte[] { 0, 1, 0, 2, 0x15, 0x15, 0, 2 },
	            new byte[] { 0, 1, 3, 3, 0x14, 0x14, 0, 2 },
	            new byte[] { 0x20, 1, 3, 3, 4, 4, 0x20, 1 },
	            new byte[] { 0x20, 1, 0x20, 2, 5, 5, 0x20, 1 } };
	
	    private static readonly byte[][] impTabR_DEFAULT = {
	            new byte[] { 1, 0, 2, 2, 0, 0, 0, 0 },
	            new byte[] { 1, 0, 1, 3, 0x14, 0x14, 0, 1 },
	            new byte[] { 1, 0, 2, 2, 0, 0, 0, 1 },
	            new byte[] { 1, 0, 1, 3, 5, 5, 0, 1 },
	            new byte[] { 0x21, 0, 0x21, 3, 4, 4, 0, 0 },
	            new byte[] { 1, 0, 1, 3, 5, 5, 0, 0 } };
	
	    private static readonly short[] impAct0 = { 0, 1, 2, 3, 4, 5, 6 };
	
	    private static readonly Bidi.ImpTabPair  impTab_DEFAULT = new Bidi.ImpTabPair (
	            impTabL_DEFAULT, impTabR_DEFAULT, impAct0, impAct0);
	
	    private static readonly byte[][] impTabL_NUMBERS_SPECIAL = {
	            new byte[] { 0, 2, 1, 1, 0, 0, 0, 0 },
	            new byte[] { 0, 2, 1, 1, 0, 0, 0, 2 },
	            new byte[] { 0, 2, 4, 4, 0x13, 0, 0, 1 },
	            new byte[] { 0x20, 2, 4, 4, 3, 3, 0x20, 1 },
	            new byte[] { 0, 2, 4, 4, 0x13, 0x13, 0, 2 } };
	
	    private static readonly Bidi.ImpTabPair  impTab_NUMBERS_SPECIAL = new Bidi.ImpTabPair (
	            impTabL_NUMBERS_SPECIAL, impTabR_DEFAULT, impAct0, impAct0);
	
	    private static readonly byte[][] impTabL_GROUP_NUMBERS_WITH_R = {
	            new byte[] { 0, 3, 0x11, 0x11, 0, 0, 0, 0 },
	            new byte[] { 0x20, 3, 1, 1, 2, 0x20, 0x20, 2 },
	            new byte[] { 0x20, 3, 1, 1, 2, 0x20, 0x20, 1 },
	            new byte[] { 0, 3, 5, 5, 0x14, 0, 0, 1 },
	            new byte[] { 0x20, 3, 5, 5, 4, 0x20, 0x20, 1 },
	            new byte[] { 0, 3, 5, 5, 0x14, 0, 0, 2 } };
	
	    private static readonly byte[][] impTabR_GROUP_NUMBERS_WITH_R = {
	            new byte[] { 2, 0, 1, 1, 0, 0, 0, 0 },
	            new byte[] { 2, 0, 1, 1, 0, 0, 0, 1 },
	            new byte[] { 2, 0, 0x14, 0x14, 0x13, 0, 0, 1 },
	            new byte[] { 0x22, 0, 4, 4, 3, 0, 0, 0 },
	            new byte[] { 0x22, 0, 4, 4, 3, 0, 0, 1 } };
	
	    private static readonly Bidi.ImpTabPair  impTab_GROUP_NUMBERS_WITH_R = new Bidi.ImpTabPair (
	            impTabL_GROUP_NUMBERS_WITH_R, impTabR_GROUP_NUMBERS_WITH_R,
	            impAct0, impAct0);
	
	    private static readonly byte[][] impTabL_INVERSE_NUMBERS_AS_L = {
	            new byte[] { 0, 1, 0, 0, 0, 0, 0, 0 },
	            new byte[] { 0, 1, 0, 0, 0x14, 0x14, 0, 1 },
	            new byte[] { 0, 1, 0, 0, 0x15, 0x15, 0, 2 },
	            new byte[] { 0, 1, 0, 0, 0x14, 0x14, 0, 2 },
	            new byte[] { 0x20, 1, 0x20, 0x20, 4, 4, 0x20, 1 },
	            new byte[] { 0x20, 1, 0x20, 0x20, 5, 5, 0x20, 1 } };
	
	    private static readonly byte[][] impTabR_INVERSE_NUMBERS_AS_L = {
	            new byte[] { 1, 0, 1, 1, 0, 0, 0, 0 },
	            new byte[] { 1, 0, 1, 1, 0x14, 0x14, 0, 1 },
	            new byte[] { 1, 0, 1, 1, 0, 0, 0, 1 },
	            new byte[] { 1, 0, 1, 1, 5, 5, 0, 1 },
	            new byte[] { 0x21, 0, 0x21, 0x21, 4, 4, 0, 0 },
	            new byte[] { 1, 0, 1, 1, 5, 5, 0, 0 } };
	
	    private static readonly Bidi.ImpTabPair  impTab_INVERSE_NUMBERS_AS_L = new Bidi.ImpTabPair (
	            impTabL_INVERSE_NUMBERS_AS_L, impTabR_INVERSE_NUMBERS_AS_L,
	            impAct0, impAct0);
	
	    private static readonly byte[][] impTabR_INVERSE_LIKE_DIRECT = {
	            new byte[] { 1, 0, 2, 2, 0, 0, 0, 0 },
	            new byte[] { 1, 0, 1, 2, 0x13, 0x13, 0, 1 },
	            new byte[] { 1, 0, 2, 2, 0, 0, 0, 1 },
	            new byte[] { 0x21, 0x30, 6, 4, 3, 3, 0x30, 0 },
	            new byte[] { 0x21, 0x30, 6, 4, 5, 5, 0x30, 3 },
	            new byte[] { 0x21, 0x30, 6, 4, 5, 5, 0x30, 2 },
	            new byte[] { 0x21, 0x30, 6, 4, 3, 3, 0x30, 1 } };
	
	    private static readonly short[] impAct1 = { 0, 1, 11, 12 };
	
	    private static readonly Bidi.ImpTabPair  impTab_INVERSE_LIKE_DIRECT = new Bidi.ImpTabPair (
	            impTabL_DEFAULT, impTabR_INVERSE_LIKE_DIRECT, impAct0, impAct1);
	
	    private static readonly byte[][] impTabL_INVERSE_LIKE_DIRECT_WITH_MARKS = {
	            new byte[] { 0, 0x63, 0, 1, 0, 0, 0, 0 },
	            new byte[] { 0, 0x63, 0, 1, 0x12, 0x30, 0, 4 },
	            new byte[] { 0x20, 0x63, 0x20, 1, 2, 0x30, 0x20, 3 },
	            new byte[] { 0, 0x63, 0x55, 0x56, 0x14, 0x30, 0, 3 },
	            new byte[] { 0x30, 0x43, 0x55, 0x56, 4, 0x30, 0x30, 3 },
	            new byte[] { 0x30, 0x43, 5, 0x56, 0x14, 0x30, 0x30, 4 },
	            new byte[] { 0x30, 0x43, 0x55, 6, 0x14, 0x30, 0x30, 4 } };
	
	    private static readonly byte[][] impTabR_INVERSE_LIKE_DIRECT_WITH_MARKS = {
	            new byte[] { 0x13, 0, 1, 1, 0, 0, 0, 0 },
	            new byte[] { 0x23, 0, 1, 1, 2, 0x40, 0, 1 },
	            new byte[] { 0x23, 0, 1, 1, 2, 0x40, 0, 0 },
	            new byte[] { 3, 0, 3, 0x36, 0x14, 0x40, 0, 1 },
	            new byte[] { 0x53, 0x40, 5, 0x36, 4, 0x40, 0x40, 0 },
	            new byte[] { 0x53, 0x40, 5, 0x36, 4, 0x40, 0x40, 1 },
	            new byte[] { 0x53, 0x40, 6, 6, 4, 0x40, 0x40, 3 } };
	
	    private static readonly short[] impAct2 = { 0, 1, 7, 8, 9, 10 };
	
	    private static readonly Bidi.ImpTabPair  impTab_INVERSE_LIKE_DIRECT_WITH_MARKS = new Bidi.ImpTabPair (
	            impTabL_INVERSE_LIKE_DIRECT_WITH_MARKS,
	            impTabR_INVERSE_LIKE_DIRECT_WITH_MARKS, impAct0, impAct2);
	
	    private static readonly Bidi.ImpTabPair  impTab_INVERSE_FOR_NUMBERS_SPECIAL = new Bidi.ImpTabPair (
	            impTabL_NUMBERS_SPECIAL, impTabR_INVERSE_LIKE_DIRECT, impAct0,
	            impAct1);
	
	    private static readonly byte[][] impTabL_INVERSE_FOR_NUMBERS_SPECIAL_WITH_MARKS = {
	            new byte[] { 0, 0x62, 1, 1, 0, 0, 0, 0 },
	            new byte[] { 0, 0x62, 1, 1, 0, 0x30, 0, 4 },
	            new byte[] { 0, 0x62, 0x54, 0x54, 0x13, 0x30, 0, 3 },
	            new byte[] { 0x30, 0x42, 0x54, 0x54, 3, 0x30, 0x30, 3 },
	            new byte[] { 0x30, 0x42, 4, 4, 0x13, 0x30, 0x30, 4 } };
	
	    private static readonly Bidi.ImpTabPair  impTab_INVERSE_FOR_NUMBERS_SPECIAL_WITH_MARKS = new Bidi.ImpTabPair (
	            impTabL_INVERSE_FOR_NUMBERS_SPECIAL_WITH_MARKS,
	            impTabR_INVERSE_LIKE_DIRECT_WITH_MARKS, impAct0, impAct2);
	
	    private class LevState {
	        internal byte[][] impTab; /* level table pointer */
	
	        internal short[] impAct; /* action map array */
	
	        internal int startON; /* start of ON sequence */
	
	        internal int startL2EN; /* start of level 2 sequence */
	
	        internal int lastStrongRTL; /* index of last found R or AL */
	
	        internal short state; /* current state */
	
	        internal sbyte runLevel; /* run level before implicit solving */
	    }
	
	    /*------------------------------------------------------------------------*/
	
	    internal const int FIRSTALLOC = 10;
	
	    /*
	     * param pos: position where to insert param flag: one of LRM_BEFORE,
	     * LRM_AFTER, RLM_BEFORE, RLM_AFTER
	     */
	    private void AddPoint(int pos_0, int flag_1) {
	        Bidi.Point  point = new Bidi.Point ();
	
	        int len = insertPoints.points.Length;
	        if (len == 0) {
	            insertPoints.points = new Bidi.Point [FIRSTALLOC];
	            len = FIRSTALLOC;
	        }
	        if (insertPoints.size >= len) { /* no room for new point */
	            Bidi.Point [] savePoints = insertPoints.points;
	            insertPoints.points = new Bidi.Point [len * 2];
	            System.Array.Copy((Array)(savePoints),0,(Array)(insertPoints.points),0,len);
	        }
	        point.pos = pos_0;
	        point.flag = flag_1;
	        insertPoints.points[insertPoints.size] = point;
	        insertPoints.size++;
	    }
	
	    /*
	     * perform rules (Wn), (Nn), and (In) on a run of the text
	     * ------------------
	     */
	
	    /*
	     * This implementation of the (Wn) rules applies all rules in one pass. In
	     * order to do so, it needs a look-ahead of typically 1 character (except
	     * for W5: sequences of ET) and keeps track of changes in a rule Wp that
	     * affect a later Wq (p<q).
	     * 
	     * The (Nn) and (In) rules are also performed in that same single loop, but
	     * effectively one iteration behind for white space.
	     * 
	     * Since all implicit rules are performed in one step, it is not necessary
	     * to actually store the intermediate directional properties in dirProps[].
	     */
	
	    private void ProcessPropertySeq(Bidi.LevState  levState, short _prop, int start,
	            int limit) {
	        byte cell;
	        byte[][] impTab_0 = levState.impTab;
	        short[] impAct_1 = levState.impAct;
	        short oldStateSeq, actionSeq;
	        sbyte level, addLevel;
	        int start0, k;
	
	        start0 = start; /* save original start position */
	        oldStateSeq = levState.state;
	        cell = impTab_0[oldStateSeq][_prop];
	        levState.state = GetState(cell); /* isolate the new state */
	        actionSeq = impAct_1[GetAction(cell)]; /* isolate the action */
	        addLevel = (sbyte) impTab_0[levState.state][IMPTABLEVELS_RES];
	
	        if (actionSeq != 0) {
	            switch (actionSeq) {
	            case 1: /* init ON seq */
	                levState.startON = start0;
	                break;
	
	            case 2: /* prepend ON seq to current seq */
	                start = levState.startON;
	                break;
	
	            case 3: /* L or S after possible relevant EN/AN */
	                /* check if we had EN after R/AL */
	                if (levState.startL2EN >= 0) {
	                    AddPoint(levState.startL2EN, LRM_BEFORE);
	                }
	                levState.startL2EN = -1; /*
	                                          * not within previous if since could
	                                          * also be -2
	                                          */
	                /* check if we had any relevant EN/AN after R/AL */
	                if ((insertPoints.points.Length == 0)
	                        || (insertPoints.size <= insertPoints.confirmed)) {
	                    /* nothing, just clean up */
	                    levState.lastStrongRTL = -1;
	                    /* check if we have a pending conditional segment */
	                    level = (sbyte) impTab_0[oldStateSeq][IMPTABLEVELS_RES];
	                    if ((level & 1) != 0 && levState.startON > 0) { /* after ON */
	                        start = levState.startON; /* reset to basic run level */
	                    }
	                    if (_prop == _S) { /* add LRM before S */
	                        AddPoint(start0, LRM_BEFORE);
	                        insertPoints.confirmed = insertPoints.size;
	                    }
	                    break;
	                }
	                /* reset previous RTL cont to level for LTR text */
	                for (k = levState.lastStrongRTL + 1; k < start0; k++) {
	                    /* reset odd level, leave runLevel+2 as is */
	                    levels[k] = (sbyte) ((levels[k] - 2) & ~1);
	                }
	                /* mark insert points as confirmed */
	                insertPoints.confirmed = insertPoints.size;
	                levState.lastStrongRTL = -1;
	                if (_prop == _S) { /* add LRM before S */
	                    AddPoint(start0, LRM_BEFORE);
	                    insertPoints.confirmed = insertPoints.size;
	                }
	                break;
	
	            case 4: /* R/AL after possible relevant EN/AN */
	                /* just clean up */
	                if (insertPoints.points.Length > 0)
	                    /* remove all non confirmed insert points */
	                    insertPoints.size = insertPoints.confirmed;
	                levState.startON = -1;
	                levState.startL2EN = -1;
	                levState.lastStrongRTL = limit - 1;
	                break;
	
	            case 5: /* EN/AN after R/AL + possible cont */
	                /* check for real AN */
	                if ((_prop == _AN)
	                        && (NoContextRTL(dirProps[start0]) == AN)
	                        && (reorderingMode != REORDER_INVERSE_FOR_NUMBERS_SPECIAL)) {
	                    /* real AN */
	                    if (levState.startL2EN == -1) { /*
	                                                     * if no relevant EN already
	                                                     * found
	                                                     */
	                        /* just note the righmost digit as a strong RTL */
	                        levState.lastStrongRTL = limit - 1;
	                        break;
	                    }
	                    if (levState.startL2EN >= 0) { /* after EN, no AN */
	                        AddPoint(levState.startL2EN, LRM_BEFORE);
	                        levState.startL2EN = -2;
	                    }
	                    /* note AN */
	                    AddPoint(start0, LRM_BEFORE);
	                    break;
	                }
	                /* if first EN/AN after R/AL */
	                if (levState.startL2EN == -1) {
	                    levState.startL2EN = start0;
	                }
	                break;
	
	            case 6: /* note location of latest R/AL */
	                levState.lastStrongRTL = limit - 1;
	                levState.startON = -1;
	                break;
	
	            case 7: /* L after R+ON/EN/AN */
	                /* include possible adjacent number on the left */
	                for (k = start0 - 1; k >= 0 && ((levels[k] & 1) == 0); k--) {
	                }
	                if (k >= 0) {
	                    AddPoint(k, RLM_BEFORE); /* add RLM before */
	                    insertPoints.confirmed = insertPoints.size; /* confirm it */
	                }
	                levState.startON = start0;
	                break;
	
	            case 8: /* AN after L */
	                /* AN numbers between L text on both sides may be trouble. */
	                /*
	                 * tentatively bracket with LRMs; will be confirmed if followed
	                 * by L
	                 */
	                AddPoint(start0, LRM_BEFORE); /* add LRM before */
	                AddPoint(start0, LRM_AFTER); /* add LRM after */
	                break;
	
	            case 9: /* R after L+ON/EN/AN */
	                /* false alert, infirm LRMs around previous AN */
	                insertPoints.size = insertPoints.confirmed;
	                if (_prop == _S) { /* add RLM before S */
	                    AddPoint(start0, RLM_BEFORE);
	                    insertPoints.confirmed = insertPoints.size;
	                }
	                break;
	
	            case 10: /* L after L+ON/AN */
	                level = (sbyte) (levState.runLevel + addLevel);
	                for (k = levState.startON; k < start0; k++) {
	                    if (levels[k] < level) {
	                        levels[k] = level;
	                    }
	                }
	                insertPoints.confirmed = insertPoints.size; /* confirm inserts */
	                levState.startON = start0;
	                break;
	
	            case 11: /* L after L+ON+EN/AN/ON */
	                level = (sbyte) levState.runLevel;
	                for (k = start0 - 1; k >= levState.startON; k--) {
	                    if (levels[k] == level + 3) {
	                        while (levels[k] == level + 3) {
	                            levels[k--] -= 2;
	                        }
	                        while (levels[k] == level) {
	                            k--;
	                        }
	                    }
	                    if (levels[k] == level + 2) {
	                        levels[k] = level;
	                        continue;
	                    }
	                    levels[k] = (sbyte) (level + 1);
	                }
	                break;
	
	            case 12: /* R after L+ON+EN/AN/ON */
	                level = (sbyte) (levState.runLevel + 1);
	                for (k = start0 - 1; k >= levState.startON; k--) {
	                    if (levels[k] > level) {
	                        levels[k] -= 2;
	                    }
	                }
	                break;
	
	            default: /* we should never get here */
	                throw new InvalidOperationException(
	                        "Internal ICU error in processPropertySeq");
	            }
	        }
	        if ((addLevel) != 0 || (start < start0)) {
	            level = (sbyte) (levState.runLevel + addLevel);
	            for (k = start; k < limit; k++) {
	                levels[k] = level;
	            }
	        }
	    }
	
	    private void ResolveImplicitLevels(int start, int limit, short sor,
	            short eor) {
	        Bidi.LevState  levState = new Bidi.LevState ();
	        int i, start1, start2;
	        short oldStateImp, stateImp, actionImp;
	        short gprop, resProp, cell;
	        bool inverseRTL;
	        short nextStrongProp = R;
	        int nextStrongPos = -1;
	
	        /* check for RTL inverse Bidi mode */
	        /*
	         * FOOD FOR THOUGHT: in case of RTL inverse Bidi, it would make sense to
	         * loop on the text characters from end to start. This would need a
	         * different properties state table (at least different actions) and
	         * different levels state tables (maybe very similar to the LTR
	         * corresponding ones.
	         */
	        inverseRTL = ((start < lastArabicPos)
	                && ((GetParaLevelAt(start) & 1) > 0) && (reorderingMode == REORDER_INVERSE_LIKE_DIRECT || reorderingMode == REORDER_INVERSE_FOR_NUMBERS_SPECIAL));
	        /* initialize for levels state table */
	        levState.startL2EN = -1; /* used for INVERSE_LIKE_DIRECT_WITH_MARKS */
	        levState.lastStrongRTL = -1; /* used for INVERSE_LIKE_DIRECT_WITH_MARKS */
	        levState.state = 0;
	        levState.runLevel = levels[start];
	        levState.impTab = impTabPair.imptab[levState.runLevel & 1];
	        levState.impAct = impTabPair.impact[levState.runLevel & 1];
	        ProcessPropertySeq(levState, (short) sor, start, start);
	        /* initialize for property state table */
	        if (dirProps[start] == NSM) {
	            stateImp = (short) (1 + sor);
	        } else {
	            stateImp = 0;
	        }
	        start1 = start;
	        start2 = 0;
	
	        for (i = start; i <= limit; i++) {
	            if (i >= limit) {
	                gprop = eor;
	            } else {
	                short prop, prop1;
	                prop = NoContextRTL(dirProps[i]);
	                if (inverseRTL) {
	                    if (prop == AL) {
	                        /* AL before EN does not make it AN */
	                        prop = R;
	                    } else if (prop == EN) {
	                        if (nextStrongPos <= i) {
	                            /* look for next strong char (L/R/AL) */
	                            int j;
	                            nextStrongProp = R; /* set default */
	                            nextStrongPos = limit;
	                            for (j = i + 1; j < limit; j++) {
	                                prop1 = NoContextRTL(dirProps[j]);
	                                if (prop1 == L || prop1 == R || prop1 == AL) {
	                                    nextStrongProp = prop1;
	                                    nextStrongPos = j;
	                                    break;
	                                }
	                            }
	                        }
	                        if (nextStrongProp == AL) {
	                            prop = AN;
	                        }
	                    }
	                }
	                gprop = groupProp[prop];
	            }
	            oldStateImp = stateImp;
	            cell = impTabProps[oldStateImp][gprop];
	            stateImp = GetStateProps(cell); /* isolate the new state */
	            actionImp = GetActionProps(cell); /* isolate the action */
	            if ((i == limit) && (actionImp == 0)) {
	                /* there is an unprocessed sequence if its property == eor */
	                actionImp = 1; /* process the last sequence */
	            }
	            if (actionImp != 0) {
	                resProp = impTabProps[oldStateImp][IMPTABPROPS_RES];
	                switch (actionImp) {
	                case 1: /* process current seq1, init new seq1 */
	                    ProcessPropertySeq(levState, resProp, start1, i);
	                    start1 = i;
	                    break;
	                case 2: /* init new seq2 */
	                    start2 = i;
	                    break;
	                case 3: /* process seq1, process seq2, init new seq1 */
	                    ProcessPropertySeq(levState, resProp, start1, start2);
	                    ProcessPropertySeq(levState, _ON, start2, i);
	                    start1 = i;
	                    break;
	                case 4: /* process seq1, set seq1=seq2, init new seq2 */
	                    ProcessPropertySeq(levState, resProp, start1, start2);
	                    start1 = start2;
	                    start2 = i;
	                    break;
	                default: /* we should never get here */
	                    throw new InvalidOperationException(
	                            "Internal ICU error in resolveImplicitLevels");
	                }
	            }
	        }
	        /* flush possible pending sequence, e.g. ON */
	        ProcessPropertySeq(levState, (short) eor, limit, limit);
	    }
	
	    /*
	     * perform (L1) and (X9)
	     * ----------------------------------------------------
	     */
	
	    /*
	     * Reset the embedding levels for some non-graphic characters (L1). This
	     * method also sets appropriate levels for BN, and explicit embedding types
	     * that are supposed to have been removed from the paragraph in (X9).
	     */
	    private void AdjustWSLevels() {
	        int i;
	
	        if ((flags & MASK_WS) != 0) {
	            int flag_0;
	            i = trailingWSStart;
	            while (i > 0) {
	                /*
	                 * reset a sequence of WS/BN before eop and B/S to the paragraph
	                 * paraLevel
	                 */
	                while (i > 0
                            && ((flag_0 = DirPropFlagNC(dirProps[--i])) & MASK_WS) != 0)
                    {
	                    if (orderParagraphsLTR && (flag_0 & DirPropFlag(B)) != 0) {
	                        levels[i] = 0;
	                    } else {
	                        levels[i] = GetParaLevelAt(i);
	                    }
	                }
	
	                /*
	                 * reset BN to the next character's paraLevel until B/S, which
	                 * restarts above loop
	                 */
	                /* here, i+1 is guaranteed to be <length */
	                while (i > 0) {
	                    flag_0 = DirPropFlagNC(dirProps[--i]);
	                    if ((flag_0 & MASK_BN_EXPLICIT) != 0) {
	                        levels[i] = levels[i + 1];
	                    } else if (orderParagraphsLTR
	                            && (flag_0 & DirPropFlag(B)) != 0) {
	                        levels[i] = 0;
	                        break;
	                    } else if ((flag_0 & MASK_B_S) != 0) {
	                        levels[i] = GetParaLevelAt(i);
	                        break;
	                    }
	                }
	            }
	        }
	    }
	
	    internal int Bidi_Min(int x, int y) {
	        return (x < y) ? x : y;
	    }
	
	    internal int Bidi_Abs(int x) {
	        return (x >= 0) ? x : -x;
	    }
	
	    internal void SetParaRunsOnly(char[] parmText, sbyte parmParaLevel) {
	        int[] visualMap;
	        String visualText;
	        int saveLength, saveTrailingWSStart;
	        sbyte[] saveLevels;
	        sbyte saveDirection;
	        int i, j, visualStart, logicalStart, oldRunCount, runLength, addedRuns, insertRemove, start, limit, step, indexOddBit, logicalPos, index, index1;
	        int saveOptions;
	
	        reorderingMode = REORDER_DEFAULT;
	        int parmLength = parmText.Length;
	        if (parmLength == 0) {
	            SetPara(parmText, parmParaLevel, null);
	            reorderingMode = REORDER_RUNS_ONLY;
	            return;
	        }
	        /* obtain memory for mapping table and visual text */
	        saveOptions = reorderingOptions;
	        if ((saveOptions & OPTION_INSERT_MARKS) > 0) {
	            reorderingOptions &= ~OPTION_INSERT_MARKS;
	            reorderingOptions |= OPTION_REMOVE_CONTROLS;
	        }
	        parmParaLevel &= 1; /* accept only 0 or 1 */
	        SetPara(parmText, parmParaLevel, null);
	        /*
	         * we cannot access directly pBiDi->levels since it is not yet set if
	         * direction is not MIXED
	         */
	        saveLevels = new sbyte[this.length];
	        System.Array.Copy((Array)(GetLevels()),0,(Array)(saveLevels),0,this.length);
	        saveTrailingWSStart = trailingWSStart;
	
	        /*
	         * FOOD FOR THOUGHT: instead of writing the visual text, we could use
	         * the visual map and the dirProps array to drive the second call to
	         * setPara (but must make provision for possible removal of Bidi
	         * controls. Alternatively, only use the dirProps array via customized
	         * classifier callback.
	         */
	        visualText = WriteReordered(DO_MIRRORING);
	        visualMap = GetVisualMap();
	        this.reorderingOptions = saveOptions;
	        saveLength = this.length;
	        saveDirection = this.direction;
	
	        this.reorderingMode = REORDER_INVERSE_LIKE_DIRECT;
	        parmParaLevel ^= 1;
	        SetPara(visualText, parmParaLevel, null);
	        IBM.ICU.Text.BidiLine.GetRuns(this);
	        /* check if some runs must be split, count how many splits */
	        addedRuns = 0;
	        oldRunCount = this.runCount;
	        visualStart = 0;
	        for (i = 0; i < oldRunCount; i++, visualStart += runLength) {
	            runLength = runs[i].limit - visualStart;
	            if (runLength < 2) {
	                continue;
	            }
	            logicalStart = runs[i].start;
	            for (j = logicalStart + 1; j < logicalStart + runLength; j++) {
	                index = visualMap[j];
	                index1 = visualMap[j - 1];
	                if ((Bidi_Abs(index - index1) != 1)
	                        || (saveLevels[index] != saveLevels[index1])) {
	                    addedRuns++;
	                }
	            }
	        }
	        if (addedRuns > 0) {
	            GetRunsMemory(oldRunCount + addedRuns);
	            if (runCount == 1) {
	                /* because we switch from UBiDi.simpleRuns to UBiDi.runs */
	                runsMemory[0] = runs[0];
	            } else {
	                System.Array.Copy((Array)(runs),0,(Array)(runsMemory),0,runCount);
	            }
	            runs = runsMemory;
	            runCount += addedRuns;
	            for (i = oldRunCount; i < runCount; i++) {
	                if (runs[i] == null) {
	                    runs[i] = new BidiRun(0, 0, (sbyte) 0);
	                }
	            }
	        }
	        /* split runs which are not consecutive in source text */
	        int newI;
	        for (i = oldRunCount - 1; i >= 0; i--) {
	            newI = i + addedRuns;
	            runLength = (i == 0) ? runs[0].limit : runs[i].limit
	                    - runs[i - 1].limit;
	            logicalStart = runs[i].start;
	            indexOddBit = runs[i].level & 1;
	            if (runLength < 2) {
	                if (addedRuns > 0) {
	                    runs[newI].CopyFrom(runs[i]);
	                }
	                logicalPos = visualMap[logicalStart];
	                runs[newI].start = logicalPos;
	                runs[newI].level = (sbyte) (saveLevels[logicalPos] ^ indexOddBit);
	                continue;
	            }
	            if (indexOddBit > 0) {
	                start = logicalStart;
	                limit = logicalStart + runLength - 1;
	                step = 1;
	            } else {
	                start = logicalStart + runLength - 1;
	                limit = logicalStart;
	                step = -1;
	            }
	            for (j = start; j != limit; j += step) {
	                index = visualMap[j];
	                index1 = visualMap[j + step];
	                if ((Bidi_Abs(index - index1) != 1)
	                        || (saveLevels[index] != saveLevels[index1])) {
	                    logicalPos = Bidi_Min(visualMap[start], index);
	                    runs[newI].start = logicalPos;
	                    runs[newI].level = (sbyte) (saveLevels[logicalPos] ^ indexOddBit);
	                    runs[newI].limit = runs[i].limit;
	                    runs[i].limit -= Bidi_Abs(j - start) + 1;
	                    insertRemove = runs[i].insertRemove
	                            & (LRM_AFTER | RLM_AFTER);
	                    runs[newI].insertRemove = insertRemove;
	                    runs[i].insertRemove &= ~insertRemove;
	                    start = j + step;
	                    addedRuns--;
	                    newI--;
	                }
	            }
	            if (addedRuns > 0) {
	                runs[newI].CopyFrom(runs[i]);
	            }
	            logicalPos = Bidi_Min(visualMap[start], visualMap[limit]);
	            runs[newI].start = logicalPos;
	            runs[newI].level = (sbyte) (saveLevels[logicalPos] ^ indexOddBit);
	        }
	
	        // cleanup1:
	        /* restore initial paraLevel */
	        this.paraLevel ^= 1;
	        // cleanup2:
	        /* restore real text */
	        this.text = parmText;
	        this.length = saveLength;
	        this.originalLength = parmLength;
	        this.direction = saveDirection;
	        this.levels = saveLevels;
	        this.trailingWSStart = saveTrailingWSStart;
	        /* free memory for mapping table and visual text */
	        visualMap = null;
	        visualText = null;
	        if (runCount > 1) {
	            this.direction = MIXED;
	        }
	        // cleanup3:
	        this.reorderingMode = REORDER_RUNS_ONLY;
	    }
	
	    /// <summary>
	    /// Perform the Unicode Bidi algorithm. It is defined in the <a
	    /// href="http://www.unicode.org/unicode/reports/tr9/">Unicode Standard Annex
	    /// #9</a>, version 13, also described in The Unicode Standard, Version 4.0 .
	    /// <p>
	    /// This method takes a piece of plain text containing one or more
	    /// paragraphs, with or without externally specified embedding levels from
	    /// <i>styled</i> text and computes the left-right-directionality of each
	    /// character.
	    /// <p>
	    /// If the entire text is all of the same directionality, then the method may
	    /// not perform all the steps described by the algorithm, i.e., some levels
	    /// may not be the same as if all steps were performed. This is not relevant
	    /// for unidirectional text.<br>
	    /// For example, in pure LTR text with numbers the numbers would get a
	    /// resolved level of 2 higher than the surrounding text according to the
	    /// algorithm. This implementation may set all resolved levels to the same
	    /// value in such a case.
	    /// <p>
	    /// The text can be composed of multiple paragraphs. Occurrence of a block
	    /// separator in the text terminates a paragraph, and whatever comes next
	    /// starts a new paragraph. The exception to this rule is when a Carriage
	    /// Return (CR) is followed by a Line Feed (LF). Both CR and LF are block
	    /// separators, but in that case, the pair of characters is considered as
	    /// terminating the preceding paragraph, and a new paragraph will be started
	    /// by a character coming after the LF.
	    /// Although the text is passed here as a <c>String</c>, it is stored
	    /// internally as an array of characters. Therefore the documentation will
	    /// refer to indexes of the characters in the text.
	    /// </summary>
	    ///
	    /// <param name="text_0">contains the text that the Bidi algorithm will be performedon. This text can be retrieved with <c>getText()</c> or<c>getTextAsString</c>.<br></param>
	    /// <param name="paraLevel_1">specifies the default level for the text; it is typically 0(LTR) or 1 (RTL). If the method shall determine the paragraphlevel from the text, then <c>paraLevel</c> can be set toeither <c>LEVEL_DEFAULT_LTR</c> or<c>LEVEL_DEFAULT_RTL</c>; if the text contains multipleparagraphs, the paragraph level shall be determined separatelyfor each paragraph; if a paragraph does not include anystrongly typed character, then the desired default is used (0for LTR or 1 for RTL). Any other value between 0 and<c>MAX_EXPLICIT_LEVEL</c> is also valid, with odd levelsindicating RTL.</param>
	    /// <param name="embeddingLevels">(in) may be used to preset the embedding and override levels,ignoring characters like LRE and PDF in the text. A leveloverrides the directional property of its corresponding (sameindex) character if the level has the<c>LEVEL_OVERRIDE</c> bit set.<br><br>Except for that bit, it must be<code>paraLevel<=embeddingLevels[]<=MAX_EXPLICIT_LEVEL</code>,with one exception: a level of zero may be specified for aparagraph separator even if <c>paraLevel&gt;0</c> whenmultiple paragraphs are submitted in the same call to<c>setPara()</c>.<br><br><strong>Caution: </strong>A reference to this array, not acopy of the levels, will be stored in the <c>Bidi</c>object; the <c>embeddingLevels</c> should not bemodified to avoid unexpected results on subsequent Bidioperations. However, the <c>setPara()</c> and<c>setLine()</c> methods may modify some or all of thelevels.<br><br><strong>Note:</strong> the <c>embeddingLevels</c> arraymust have one entry for each character in <c>text</c>.</param>
	    /// <exception cref="IllegalArgumentException">if the values in embeddingLevels are not within the allowedrange</exception>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.LEVEL_DEFAULT_LTR"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.LEVEL_DEFAULT_RTL"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.LEVEL_OVERRIDE"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.MAX_EXPLICIT_LEVEL"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public void SetPara(String text_0, sbyte paraLevel_1, sbyte[] embeddingLevels) {
	        if (text_0 == null) {
	            SetPara(new char[0], paraLevel_1, embeddingLevels);
	        } else {
	            SetPara(text_0.ToCharArray(), paraLevel_1, embeddingLevels);
	        }
	    }
	
	    /// <summary>
	    /// Perform the Unicode Bidi algorithm. It is defined in the <a
	    /// href="http://www.unicode.org/unicode/reports/tr9/">Unicode Standard Annex
	    /// #9</a>, version 13, also described in The Unicode Standard, Version 4.0 .
	    /// <p>
	    /// This method takes a piece of plain text containing one or more
	    /// paragraphs, with or without externally specified embedding levels from
	    /// <i>styled</i> text and computes the left-right-directionality of each
	    /// character.
	    /// <p>
	    /// If the entire text is all of the same directionality, then the method may
	    /// not perform all the steps described by the algorithm, i.e., some levels
	    /// may not be the same as if all steps were performed. This is not relevant
	    /// for unidirectional text.<br>
	    /// For example, in pure LTR text with numbers the numbers would get a
	    /// resolved level of 2 higher than the surrounding text according to the
	    /// algorithm. This implementation may set all resolved levels to the same
	    /// value in such a case.
	    /// <p>
	    /// The text can be composed of multiple paragraphs. Occurrence of a block
	    /// separator in the text terminates a paragraph, and whatever comes next
	    /// starts a new paragraph. The exception to this rule is when a Carriage
	    /// Return (CR) is followed by a Line Feed (LF). Both CR and LF are block
	    /// separators, but in that case, the pair of characters is considered as
	    /// terminating the preceding paragraph, and a new paragraph will be started
	    /// by a character coming after the LF.
	    /// The text is stored internally as an array of characters. Therefore the
	    /// documentation will refer to indexes of the characters in the text.
	    /// </summary>
	    ///
	    /// <param name="chars">contains the text that the Bidi algorithm will be performedon. This text can be retrieved with <c>getText()</c> or<c>getTextAsString</c>.<br></param>
	    /// <param name="paraLevel_0">specifies the default level for the text; it is typically 0(LTR) or 1 (RTL). If the method shall determine the paragraphlevel from the text, then <c>paraLevel</c> can be set toeither <c>LEVEL_DEFAULT_LTR</c> or<c>LEVEL_DEFAULT_RTL</c>; if the text contains multipleparagraphs, the paragraph level shall be determined separatelyfor each paragraph; if a paragraph does not include anystrongly typed character, then the desired default is used (0for LTR or 1 for RTL). Any other value between 0 and<c>MAX_EXPLICIT_LEVEL</c> is also valid, with odd levelsindicating RTL.</param>
	    /// <param name="embeddingLevels">(in) may be used to preset the embedding and override levels,ignoring characters like LRE and PDF in the text. A leveloverrides the directional property of its corresponding (sameindex) character if the level has the<c>LEVEL_OVERRIDE</c> bit set.<br><br>Except for that bit, it must be<code>paraLevel<=embeddingLevels[]<=MAX_EXPLICIT_LEVEL</code>,with one exception: a level of zero may be specified for aparagraph separator even if <c>paraLevel&gt;0</c> whenmultiple paragraphs are submitted in the same call to<c>setPara()</c>.<br><br><strong>Caution: </strong>A reference to this array, not acopy of the levels, will be stored in the <c>Bidi</c>object; the <c>embeddingLevels</c> should not bemodified to avoid unexpected results on subsequent Bidioperations. However, the <c>setPara()</c> and<c>setLine()</c> methods may modify some or all of thelevels.<br><br><strong>Note:</strong> the <c>embeddingLevels</c> arraymust have one entry for each character in <c>text</c>.</param>
	    /// <exception cref="IllegalArgumentException">if the values in embeddingLevels are not within the allowedrange</exception>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.LEVEL_DEFAULT_LTR"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.LEVEL_DEFAULT_RTL"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.LEVEL_OVERRIDE"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.MAX_EXPLICIT_LEVEL"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public void SetPara(char[] chars, sbyte paraLevel_0, sbyte[] embeddingLevels) {
	        /* check the argument values */
	        if (paraLevel_0 < LEVEL_DEFAULT_LTR) {
	            VerifyRange(paraLevel_0, 0, MAX_EXPLICIT_LEVEL + 1);
	        }
	        if (chars == null) {
	            chars = new char[0];
	        }
	
	        /* special treatment for RUNS_ONLY mode */
	        if (reorderingMode == REORDER_RUNS_ONLY) {
	            SetParaRunsOnly(chars, paraLevel_0);
	            return;
	        }
	
	        /* initialize the Bidi object */
	        this.paraBidi = null; /* mark unfinished setPara */
	        this.text = chars;
	        this.length = this.originalLength = this.resultLength = text.Length;
	        this.paraLevel = paraLevel_0;
	        this.direction = LTR;
	        this.paraCount = 1;
	
	        /*
	         * Allocate zero-length arrays instead of setting to null here; then
	         * checks for null in various places can be eliminated.
	         */
	        dirProps = new sbyte[0];
	        levels = new sbyte[0];
	        runs = new BidiRun[0];
	        isGoodLogicalToVisualRunsMap = false;
	        insertPoints.size = 0; /* clean up from last call */
	        insertPoints.confirmed = 0; /* clean up from last call */
	
	        /*
	         * Save the original paraLevel if contextual; otherwise, set to 0.
	         */
	        if (IsDefaultLevel(paraLevel_0)) {
	            defaultParaLevel = paraLevel_0;
	        } else {
	            defaultParaLevel = 0;
	        }
	
	        if (length == 0) {
	            /*
	             * For an empty paragraph, create a Bidi object with the paraLevel
	             * and the flags and the direction set but without allocating
	             * zero-length arrays. There is nothing more to do.
	             */
	            if (IsDefaultLevel(paraLevel_0)) {
	                this.paraLevel &= 1;
	                defaultParaLevel = 0;
	            }
	            if ((this.paraLevel & 1) != 0) {
	                flags = DirPropFlag(R);
	                direction = RTL;
	            } else {
	                flags = DirPropFlag(L);
	                direction = LTR;
	            }
	
	            runCount = 0;
	            paraCount = 0;
	            paraBidi = this; /* mark successful setPara */
	            return;
	        }
	
	        runCount = -1;
	
	        /*
	         * Get the directional properties, the flags bit-set, and determine the
	         * paragraph level if necessary.
	         */
	        GetDirPropsMemory(length);
	        dirProps = dirPropsMemory;
	        GetDirProps();
	        /* the processed length may have changed if OPTION_STREAMING is set */
	        trailingWSStart = length; /* the levels[] will reflect the WS run */
	
	        /* allocate paras memory */
	        if (paraCount > 1) {
	            GetInitialParasMemory(paraCount);
	            paras = parasMemory;
	            paras[paraCount - 1] = length;
	        } else {
	            /* initialize paras for single paragraph */
	            paras = simpleParas;
	            simpleParas[0] = length;
	        }
	
	        /* are explicit levels specified? */
	        if (embeddingLevels == null) {
	            /* no: determine explicit levels according to the (Xn) rules */
	            GetLevelsMemory(length);
	            levels = levelsMemory;
	            direction = ResolveExplicitLevels();
	        } else {
	            /*
	             * set BN for all explicit codes, check that all levels are 0 or
	             * paraLevel..MAX_EXPLICIT_LEVEL
	             */
	            levels = embeddingLevels;
	            direction = CheckExplicitLevels();
	        }
	
	        /*
	         * The steps after (X9) in the Bidi algorithm are performed only if the
	         * paragraph text has mixed directionality!
	         */
	        switch (direction) {
	        case LTR:
	            /* make sure paraLevel is even */
	            paraLevel_0 = (sbyte) ((paraLevel_0 + 1) & ~1);
	
	            /*
	             * all levels are implicitly at paraLevel (important for
	             * getLevels())
	             */
	            trailingWSStart = 0;
	            break;
	        case RTL:
	            /* make sure paraLevel is odd */
	            paraLevel_0 |= 1;
	
	            /*
	             * all levels are implicitly at paraLevel (important for
	             * getLevels())
	             */
	            trailingWSStart = 0;
	            break;
	        default:
	            /*
	             * Choose the right implicit state table
	             */
	            switch (reorderingMode) {
	            case REORDER_DEFAULT:
	                this.impTabPair = impTab_DEFAULT;
	                break;
	            case REORDER_NUMBERS_SPECIAL:
	                this.impTabPair = impTab_NUMBERS_SPECIAL;
	                break;
	            case REORDER_GROUP_NUMBERS_WITH_R:
	                this.impTabPair = impTab_GROUP_NUMBERS_WITH_R;
	                break;
	            case REORDER_RUNS_ONLY:
	                /* we should never get here */
                    throw new Exception("Internal ICU error in setPara");
	                /* break; */
	            case REORDER_INVERSE_NUMBERS_AS_L:
	                this.impTabPair = impTab_INVERSE_NUMBERS_AS_L;
	                break;
	            case REORDER_INVERSE_LIKE_DIRECT:
	                if ((reorderingOptions & OPTION_INSERT_MARKS) != 0) {
	                    this.impTabPair = impTab_INVERSE_LIKE_DIRECT_WITH_MARKS;
	                } else {
	                    this.impTabPair = impTab_INVERSE_LIKE_DIRECT;
	                }
	                break;
	            case REORDER_INVERSE_FOR_NUMBERS_SPECIAL:
	                if ((reorderingOptions & OPTION_INSERT_MARKS) != 0) {
	                    this.impTabPair = impTab_INVERSE_FOR_NUMBERS_SPECIAL_WITH_MARKS;
	                } else {
	                    this.impTabPair = impTab_INVERSE_FOR_NUMBERS_SPECIAL;
	                }
	                break;
	            }
	            /*
	             * If there are no external levels specified and there are no
	             * significant explicit level codes in the text, then we can treat
	             * the entire paragraph as one run. Otherwise, we need to perform
	             * the following rules on runs of the text with the same embedding
	             * levels. (X10) "Significant" explicit level codes are ones that
	             * actually affect non-BN characters. Examples for "insignificant"
	             * ones are empty embeddings LRE-PDF, LRE-RLE-PDF-PDF, etc.
	             */
	            if (embeddingLevels == null && (flags & DirPropFlagMultiRuns) == 0) {
	                ResolveImplicitLevels(0, length,
	                        GetLRFromLevel(GetParaLevelAt(0)),
	                        GetLRFromLevel(GetParaLevelAt(length - 1)));
	            } else {
	                /* sor, eor: start and end types of same-level-run */
	                int start, limit = 0;
	                sbyte level, nextLevel;
	                short sor, eor;
	
	                /*
	                 * determine the first sor and set eor to it because of the loop
	                 * body (sor=eor there)
	                 */
	                level = GetParaLevelAt(0);
	                nextLevel = levels[0];
	                if (level < nextLevel) {
	                    eor = GetLRFromLevel(nextLevel);
	                } else {
	                    eor = GetLRFromLevel(level);
	                }
	
	                do {
	                    /*
	                     * determine start and limit of the run (end points just
	                     * behind the run)
	                     */
	
	                    /*
	                     * the values for this run's start are the same as for the
	                     * previous run's end
	                     */
	                    start = limit;
	                    level = nextLevel;
	                    if ((start > 0) && (NoContextRTL(dirProps[start - 1]) == B)) {
	                        /*
	                         * except if this is a new paragraph, then set sor =
	                         * para level
	                         */
	                        sor = GetLRFromLevel(GetParaLevelAt(start));
	                    } else {
	                        sor = eor;
	                    }
	
	                    /* search for the limit of this run */
	                    while (++limit < length && levels[limit] == level) {
	                    }
	
	                    /* get the correct level of the next run */
	                    if (limit < length) {
	                        nextLevel = levels[limit];
	                    } else {
	                        nextLevel = GetParaLevelAt(length - 1);
	                    }
	
	                    /*
	                     * determine eor from max(level, nextLevel); sor is last
	                     * run's eor
	                     */
	                    if ((level & ~LEVEL_OVERRIDE) < (nextLevel & ~LEVEL_OVERRIDE)) {
	                        eor = GetLRFromLevel(nextLevel);
	                    } else {
	                        eor = GetLRFromLevel(level);
	                    }
	
	                    /*
	                     * if the run consists of overridden directional types, then
	                     * there are no implicit types to be resolved
	                     */
	                    if ((level & LEVEL_OVERRIDE) == 0) {
	                        ResolveImplicitLevels(start, limit, sor, eor);
	                    } else {
	                        /* remove the LEVEL_OVERRIDE flags */
	                        do {
	                            levels[start++] &= ~LEVEL_OVERRIDE;
	                        } while (start < limit);
	                    }
	                } while (limit < length);
	            }
	
	            /*
	             * reset the embedding levels for some non-graphic characters (L1),
	             * (X9)
	             */
	            AdjustWSLevels();
	
	            break;
	        }
	        /*
	         * add RLM for inverse Bidi with contextual orientation resolving to RTL
	         * which would not round-trip otherwise
	         */
	        if ((defaultParaLevel > 0)
	                && ((reorderingOptions & OPTION_INSERT_MARKS) != 0)
	                && ((reorderingMode == REORDER_INVERSE_LIKE_DIRECT) || (reorderingMode == REORDER_INVERSE_FOR_NUMBERS_SPECIAL))) {
	            int start_1, last;
	            sbyte dirProp;
	            for (int i = 0; i < paraCount; i++) {
	                last = paras[i] - 1;
	                if ((dirProps[last] & CONTEXT_RTL) == 0) {
	                    continue; /* LTR paragraph */
	                }
	                start_1 = (i == 0) ? 0 : paras[i - 1];
	                for (int j = last; j >= start_1; j--) {
	                    dirProp = NoContextRTL(dirProps[j]);
	                    if (dirProp == L) {
	                        if (j < last) {
	                            while (NoContextRTL(dirProps[last]) == B) {
	                                last--;
	                            }
	                        }
	                        AddPoint(last, RLM_BEFORE);
	                        break;
	                    }
	                    if ((DirPropFlag(dirProp) & MASK_R_AL) != 0) {
	                        break;
	                    }
	                }
	            }
	        }
	
	        if ((reorderingOptions & OPTION_REMOVE_CONTROLS) != 0) {
	            resultLength -= controlCount;
	        } else {
	            resultLength += insertPoints.size;
	        }
	        paraBidi = this; /* mark successful setPara */
	    }
	
	    // #if defined(FOUNDATION10)
	    // #else
	    /// <summary>
	    /// Perform the Unicode Bidi algorithm on a given paragraph, as defined in
	    /// the <a href="http://www.unicode.org/unicode/reports/tr9/">Unicode
	    /// Standard Annex #9</a>, version 13, also described in The Unicode
	    /// Standard, Version 4.0 .
	    /// <p>
	    /// This method takes a paragraph of text and computes the
	    /// left-right-directionality of each character. The text should not contain
	    /// any Unicode block separators.
	    /// <p>
	    /// The RUN_DIRECTION attribute in the text, if present, determines the base
	    /// direction (left-to-right or right-to-left). If not present, the base
	    /// direction is computed using the Unicode Bidirectional Algorithm,
	    /// defaulting to left-to-right if there are no strong directional characters
	    /// in the text. This attribute, if present, must be applied to all the text
	    /// in the paragraph.
	    /// <p>
	    /// The BIDI_EMBEDDING attribute in the text, if present, represents
	    /// embedding level information. Negative values from -1 to -62 indicate
	    /// overrides at the absolute value of the level. Positive values from 1 to
	    /// 62 indicate embeddings. Where values are zero or not defined, the base
	    /// embedding level as determined by the base direction is assumed.
	    /// <p>
	    /// The NUMERIC_SHAPING attribute in the text, if present, converts European
	    /// digits to other decimal digits before running the bidi algorithm. This
	    /// attribute, if present, must be applied to all the text in the paragraph.
	    /// If the entire text is all of the same directionality, then the method may
	    /// not perform all the steps described by the algorithm, i.e., some levels
	    /// may not be the same as if all steps were performed. This is not relevant
	    /// for unidirectional text.<br>
	    /// For example, in pure LTR text with numbers the numbers would get a
	    /// resolved level of 2 higher than the surrounding text according to the
	    /// algorithm. This implementation may set all resolved levels to the same
	    /// value in such a case.
	    /// <p>
	    /// </summary>
	    ///
	    /// <param name="paragraph">a paragraph of text with optional character and paragraphattribute information</param>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public void SetPara(ILOG.J2CsMapping.Text.AttributedCharacterIterator paragraph) {
	        sbyte paraLevel_0;            
            
	        Object runDirection = (Boolean) paragraph
	                .GetAttribute(ILOG.J2CsMapping.Text.TextAttribute.RUN_DIRECTION);
	        if (runDirection == null) {
	            paraLevel_0 = LEVEL_DEFAULT_LTR;
	        } else {
	            paraLevel_0 = (runDirection.Equals(ILOG.J2CsMapping.Text.TextAttribute.RUN_DIRECTION_LTR)) ? LTR
	                    : RTL;
	        }
	
	        sbyte[] levels_1 = null;
	        int length_2 = paragraph.GetEndIndex() - paragraph.GetBeginIndex();
	        sbyte[] embeddingLevels = new sbyte[length_2];
	        char[] text_3 = new char[length_2];
	        int i = 0;
	        char ch = paragraph.First();
	        while (ch != ILOG.J2CsMapping.Text.CharacterIterator.Done) {
	            text_3[i] = ch;                
                
	            Int32 embedding = (Int32) paragraph
	                    .GetAttribute(ILOG.J2CsMapping.Text.TextAttribute.BIDI_EMBEDDING);
	            if (embedding != null) {
	                sbyte level = Convert.ToSByte(embedding);
	                if (level == 0) {
	                    /* no-op */
	                } else if (level < 0) {
	                    levels_1 = embeddingLevels;
	                    embeddingLevels[i] = (sbyte) ((0 - level) | LEVEL_OVERRIDE);
	                } else {
	                    levels_1 = embeddingLevels;
	                    embeddingLevels[i] = level;
	                }
	            }
	            ch = paragraph.Next();
	            ++i;
	        }
	
	        // #if defined(J2SE13)
	        // #else
            
	        NumericShaper shaper = (NumericShaper) paragraph
	                .GetAttribute(ILOG.J2CsMapping.Text.TextAttribute.NUMERIC_SHAPING);
	        if (shaper != null) {
	            shaper.Shape(text_3, 0, length_2);
	        }
	        // #endif
	        SetPara(text_3, paraLevel_0, levels_1);
	    }
	
	    // #endif
	
	    /// <summary>
	    /// Specify whether block separators must be allocated level zero, so that
	    /// successive paragraphs will progress from left to right. This method must
	    /// be called before <c>setPara()</c>. Paragraph separators (B) may
	    /// appear in the text. Setting them to level zero means that all paragraph
	    /// separators (including one possibly appearing in the last text position)
	    /// are kept in the reordered text after the text that they follow in the
	    /// source text. When this feature is not enabled, a paragraph separator at
	    /// the last position of the text before reordering will go to the first
	    /// position of the reordered text when the paragraph level is odd.
	    /// </summary>
	    ///
	    /// <param name="orderParagraphsLTR_0">specifies whether paragraph separators (B) must receive level0, so that successive paragraphs progress from left to right.</param>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.SetPara(System.String, System.Byte, null)"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public void OrderParagraphsLTR(bool orderParagraphsLTR_0) {
	        this.orderParagraphsLTR = orderParagraphsLTR_0;
	    }
	
	    /// <summary>
	    /// Is this <c>Bidi</c> object set to allocate level 0 to block
	    /// separators so that successive paragraphs progress from left to right?
	    /// </summary>
	    ///
	    /// <returns><c>true</c> if the <c>Bidi</c> object is set to
	    /// allocate level 0 to block separators.</returns>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.orderParagraphsLTR"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public bool IsOrderParagraphsLTR() {
	        return orderParagraphsLTR;
	    }
	
	    /// <summary>
	    /// Get the directionality of the text.
	    /// </summary>
	    ///
	    /// <returns>a value of <c>LTR</c>, <c>RTL</c> or
	    /// <c>MIXED</c> that indicates if the entire text represented
	    /// by this object is unidirectional, and which direction, or if it
	    /// is mixed-directional.</returns>
	    /// <exception cref="IllegalStateException">if this call is not preceded by a successful call to<c>setPara</c> or <c>setLine</c></exception>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.LTR"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.RTL"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.MIXED"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public sbyte GetDirection() {
	        VerifyValidParaOrLine();
	        return direction;
	    }
	
	    /// <summary>
	    /// Get the text.
	    /// </summary>
	    ///
	    /// <returns>A <c>String</c> containing the text that the
	    /// <c>Bidi</c> object was created for.</returns>
	    /// <exception cref="IllegalStateException">if this call is not preceded by a successful call to<c>setPara</c> or <c>setLine</c></exception>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.SetPara(System.String, System.Byte, null)"/>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.SetLine(System.Int32, System.Int32)"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public String GetTextAsString() {
	        VerifyValidParaOrLine();
	        return ILOG.J2CsMapping.Util.StringUtil.NewString(text);
	    }
	
	    /// <summary>
	    /// Get the text.
	    /// </summary>
	    ///
	    /// <returns>A <c>char</c> array containing the text that the
	    /// <c>Bidi</c> object was created for.</returns>
	    /// <exception cref="IllegalStateException">if this call is not preceded by a successful call to<c>setPara</c> or <c>setLine</c></exception>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.SetPara(System.String, System.Byte, null)"/>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.SetLine(System.Int32, System.Int32)"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public char[] GetText() {
	        VerifyValidParaOrLine();
	        return text;
	    }
	
	    /// <summary>
	    /// Get the length of the text.
	    /// </summary>
	    ///
	    /// <returns>The length of the text that the <c>Bidi</c> object was
	    /// created for.</returns>
	    /// <exception cref="IllegalStateException">if this call is not preceded by a successful call to<c>setPara</c> or <c>setLine</c></exception>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public int GetLength() {
	        VerifyValidParaOrLine();
	        return originalLength;
	    }
	
	    /// <summary>
	    /// Get the length of the source text processed by the last call to
	    /// <c>setPara()</c>. This length may be different from the length of
	    /// the source text if option <c>OPTION_STREAMING</c> has been set. <br>
	    /// Note that whenever the length of the text affects the execution or the
	    /// result of a method, it is the processed length which must be considered,
	    /// except for <c>setPara</c> (which receives unprocessed source text)
	    /// and <c>getLength</c> (which returns the original length of the
	    /// source text).<br>
	    /// In particular, the processed length is the one to consider in the
	    /// following cases:
	    /// <ul>
	    /// <li>maximum value of the <c>limit</c> argument of
	    /// <c>setLine</c></li>
	    /// <li>maximum value of the <c>charIndex</c> argument of
	    /// <c>getParagraph</c></li>
	    /// <li>maximum value of the <c>charIndex</c> argument of
	    /// <c>getLevelAt</c></li>
	    /// <li>number of elements in the array returned by <c>getLevels</c></li>
	    /// <li>maximum value of the <c>logicalStart</c> argument of
	    /// <c>getLogicalRun</c></li>
	    /// <li>maximum value of the <c>logicalIndex</c> argument of
	    /// <c>getVisualIndex</c></li>
	    /// <li>number of elements returned by <c>getLogicalMap</c></li>
	    /// <li>length of text processed by <c>writeReordered</c></li>
	    /// </ul>
	    /// </summary>
	    ///
	    /// <returns>The length of the part of the source text processed by the last
	    /// call to <c>setPara</c>.</returns>
	    /// <exception cref="IllegalStateException">if this call is not preceded by a successful call to<c>setPara</c> or <c>setLine</c></exception>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.SetPara(System.String, System.Byte, null)"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.OPTION_STREAMING"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public int GetProcessedLength() {
	        VerifyValidParaOrLine();
	        return length;
	    }
	
	    /// <summary>
	    /// Get the length of the reordered text resulting from the last call to
	    /// <c>setPara()</c>. This length may be different from the length of
	    /// the source text if option <c>OPTION_INSERT_MARKS</c> or option
	    /// <c>OPTION_REMOVE_CONTROLS</c> has been set. <br>
	    /// This resulting length is the one to consider in the following cases:
	    /// <ul>
	    /// <li>maximum value of the <c>visualIndex</c> argument of
	    /// <c>getLogicalIndex</c></li>
	    /// <li>number of elements returned by <c>getVisualMap</c></li>
	    /// </ul>
	    /// Note that this length stays identical to the source text length if Bidi
	    /// marks are inserted or removed using option bits of
	    /// <c>writeReordered</c>, or if option
	    /// <c>REORDER_INVERSE_NUMBERS_AS_L</c> has been set.
	    /// </summary>
	    ///
	    /// <returns>The length of the reordered text resulting from the last call to
	    /// <c>setPara</c>.</returns>
	    /// <exception cref="IllegalStateException">if this call is not preceded by a successful call to<c>setPara</c> or <c>setLine</c></exception>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.SetPara(System.String, System.Byte, null)"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.OPTION_INSERT_MARKS"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.OPTION_REMOVE_CONTROLS"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.REORDER_INVERSE_NUMBERS_AS_L"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public int GetResultLength() {
	        VerifyValidParaOrLine();
	        return resultLength;
	    }
	
	    /* paragraphs API methods ------------------------------------------------- */
	
	    /// <summary>
	    /// Get the paragraph level of the text.
	    /// </summary>
	    ///
	    /// <returns>The paragraph level. If there are multiple paragraphs, their
	    /// level may vary if the required paraLevel is LEVEL_DEFAULT_LTR or
	    /// LEVEL_DEFAULT_RTL. In that case, the level of the first paragraph
	    /// is returned.</returns>
	    /// <exception cref="IllegalStateException">if this call is not preceded by a successful call to<c>setPara</c> or <c>setLine</c></exception>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.LEVEL_DEFAULT_LTR"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.LEVEL_DEFAULT_RTL"/>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.GetParagraph(System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.GetParagraphByIndex(System.Int32)"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public sbyte GetParaLevel() {
	        VerifyValidParaOrLine();
	        return paraLevel;
	    }
	
	    /// <summary>
	    /// Get the number of paragraphs.
	    /// </summary>
	    ///
	    /// <returns>The number of paragraphs.</returns>
	    /// <exception cref="IllegalStateException">if this call is not preceded by a successful call to<c>setPara</c> or <c>setLine</c></exception>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public int CountParagraphs() {
	        VerifyValidParaOrLine();
	        return paraCount;
	    }
	
	    /// <summary>
	    /// Get a paragraph, given the index of this paragraph.
	    /// This method returns information about a paragraph.
	    /// <p>
	    /// </summary>
	    ///
	    /// <param name="paraIndex">is the number of the paragraph, in the range<c>[0..countParagraphs()-1]</c>.</param>
	    /// <returns>a BidiRun object with the details of the paragraph:<br>
	    /// <c>start</c> will receive the index of the first character
	    /// of the paragraph in the text.<br>
	    /// <c>limit</c> will receive the limit of the paragraph.<br>
	    /// <c>embeddingLevel</c> will receive the level of the
	    /// paragraph.</returns>
	    /// <exception cref="IllegalStateException">if this call is not preceded by a successful call to<c>setPara</c> or <c>setLine</c></exception>
	    /// <exception cref="IllegalArgumentException">if paraIndex is not in the range<c>[0..countParagraphs()-1]</c></exception>
	    /// <seealso cref="T:IBM.ICU.Text.BidiRun"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public BidiRun GetParagraphByIndex(int paraIndex) {
	        VerifyValidParaOrLine();
	        VerifyRange(paraIndex, 0, paraCount);
	
	        Bidi bidi = paraBidi; /* get Para object if Line object */
	        int paraStart;
	        if (paraIndex == 0) {
	            paraStart = 0;
	        } else {
	            paraStart = bidi.paras[paraIndex - 1];
	        }
	        BidiRun bidiRun = new BidiRun();
	        bidiRun.start = paraStart;
	        bidiRun.limit = bidi.paras[paraIndex];
	        bidiRun.level = GetParaLevelAt(paraStart);
	        return bidiRun;
	    }
	
	    /// <summary>
	    /// Get a paragraph, given a position within the text. This method returns
	    /// information about a paragraph.<br>
	    /// Note: if the paragraph index is known, it is more efficient to retrieve
	    /// the paragraph information using getParagraphByIndex().
	    /// <p>
	    /// </summary>
	    ///
	    /// <param name="charIndex">is the index of a character within the text, in the range<c>[0..getProcessedLength()-1]</c>.</param>
	    /// <returns>a BidiRun object with the details of the paragraph:<br>
	    /// <c>start</c> will receive the index of the first character
	    /// of the paragraph in the text.<br>
	    /// <c>limit</c> will receive the limit of the paragraph.<br>
	    /// <c>embeddingLevel</c> will receive the level of the
	    /// paragraph.</returns>
	    /// <exception cref="IllegalStateException">if this call is not preceded by a successful call to<c>setPara</c> or <c>setLine</c></exception>
	    /// <exception cref="IllegalArgumentException">if charIndex is not within the legal range</exception>
	    /// <seealso cref="T:IBM.ICU.Text.BidiRun"/>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.GetParagraphByIndex(System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.GetProcessedLength"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public BidiRun GetParagraph(int charIndex) {
	        VerifyValidParaOrLine();
	        Bidi bidi = paraBidi; /* get Para object if Line object */
	        VerifyRange(charIndex, 0, bidi.length);
	        int paraIndex;
	        for (paraIndex = 0; charIndex >= bidi.paras[paraIndex]; paraIndex++) {
	        }
	        return GetParagraphByIndex(paraIndex);
	    }
	
	    /// <summary>
	    /// Get the index of a paragraph, given a position within the text.
	    /// <p>
	    /// </summary>
	    ///
	    /// <param name="charIndex">is the index of a character within the text, in the range<c>[0..getProcessedLength()-1]</c>.</param>
	    /// <returns>The index of the paragraph containing the specified position,
	    /// starting from 0.</returns>
	    /// <exception cref="IllegalStateException">if this call is not preceded by a successful call to<c>setPara</c> or <c>setLine</c></exception>
	    /// <exception cref="IllegalArgumentException">if charIndex is not within the legal range</exception>
	    /// <seealso cref="T:IBM.ICU.Text.BidiRun"/>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.GetProcessedLength"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public int GetParagraphIndex(int charIndex) {
	        VerifyValidParaOrLine();
	        Bidi bidi = paraBidi; /* get Para object if Line object */
	        VerifyRange(charIndex, 0, bidi.length);
	        int paraIndex;
	        for (paraIndex = 0; charIndex >= bidi.paras[paraIndex]; paraIndex++) {
	        }
	        return paraIndex;
	    }
	
	    /// <summary>
	    /// Set a custom Bidi classifier used by the UBA implementation for Bidi
	    /// class determination.
	    /// </summary>
	    ///
	    /// <param name="classifier">A new custom classifier. This can be null.</param>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.GetCustomClassifier"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public void SetCustomClassifier(BidiClassifier classifier) {
	        this.customClassifier = classifier;
	    }
	
	    /// <summary>
	    /// Gets the current custom class classifier used for Bidi class
	    /// determination.
	    /// </summary>
	    ///
	    /// <returns>An instance of class <c>BidiClassifier</c></returns>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.SetCustomClassifier(IBM.ICU.Text.BidiClassifier)"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public BidiClassifier GetCustomClassifier() {
	        return this.customClassifier;
	    }
	
	    /// <summary>
	    /// Retrieves the Bidi class for a given code point.
	    /// <p>
	    /// If a <c>BidiClassifier</c> is defined and returns a value other
	    /// than <c>CLASS_DEFAULT</c>, that value is used; otherwise the
	    /// default class determination mechanism is invoked.
	    /// </p>
	    /// </summary>
	    ///
	    /// <param name="c">The code point to get a Bidi class for.</param>
	    /// <returns>The Bidi class for the character <c>c</c> that is in effect
	    /// for this <c>Bidi</c> instance.</returns>
	    /// <seealso cref="T:IBM.ICU.Text.BidiClassifier"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public int GetCustomizedClass(int c) {
	        int dir;
	
	        if (customClassifier == null
	                || (dir = customClassifier.Classify(c)) == Bidi.CLASS_DEFAULT) {
	            return bdp.GetClass(c);
	        } else {
	            return dir;
	        }
	    }
	
	    /// <summary>
	    /// <c>setLine()</c> returns a <c>Bidi</c> object to contain the
	    /// reordering information, especially the resolved levels, for all the
	    /// characters in a line of text. This line of text is specified by referring
	    /// to a <c>Bidi</c> object representing this information for a piece
	    /// of text containing one or more paragraphs, and by specifying a range of
	    /// indexes in this text.
	    /// <p>
	    /// In the new line object, the indexes will range from 0 to
	    /// <c>limit-start-1</c>.
	    /// <p>
	    /// This is used after calling <c>setPara()</c> for a piece of text,
	    /// and after line-breaking on that text. It is not necessary if each
	    /// paragraph is treated as a single line.
	    /// <p>
	    /// After line-breaking, rules (L1) and (L2) for the treatment of trailing WS
	    /// and for reordering are performed on a <c>Bidi</c> object that
	    /// represents a line.
	    /// <p>
	    /// <strong>Important: </strong>the line <c>Bidi</c> object may
	    /// reference data within the global text <c>Bidi</c> object. You
	    /// should not alter the content of the global text object until you are
	    /// finished using the line object.
	    /// </summary>
	    ///
	    /// <param name="start">is the line's first index into the text.</param>
	    /// <param name="limit">is just behind the line's last index into the text (its lastindex +1).</param>
	    /// <returns>a <c>Bidi</c> object that will now represent a line of the
	    /// text.</returns>
	    /// <exception cref="IllegalStateException">if this call is not preceded by a successful call to<c>setPara</c></exception>
	    /// <exception cref="IllegalArgumentException">if start and limit are not in the range<c>0&lt;=start&lt;limit&lt;=getProcessedLength()</c>,or if the specified line crosses a paragraph boundary</exception>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.SetPara(System.String, System.Byte, null)"/>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.GetProcessedLength"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public Bidi SetLine(int start, int limit) {
	        VerifyValidPara();
	        VerifyRange(start, 0, limit);
	        VerifyRange(limit, 0, length + 1);
	        if (GetParagraphIndex(start) != GetParagraphIndex(limit - 1)) {
	            /* the line crosses a paragraph boundary */
	            throw new ArgumentException();
	        }
	        return IBM.ICU.Text.BidiLine.SetLine(this, start, limit);
	    }
	
	    /// <summary>
	    /// Get the level for one character.
	    /// </summary>
	    ///
	    /// <param name="charIndex">the index of a character.</param>
	    /// <returns>The level for the character at <c>charIndex</c>.</returns>
	    /// <exception cref="IllegalStateException">if this call is not preceded by a successful call to<c>setPara</c> or <c>setLine</c></exception>
	    /// <exception cref="IllegalArgumentException">if charIndex is not in the range<c>0&lt;=charIndex&lt;getProcessedLength()</c></exception>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.GetProcessedLength"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public sbyte GetLevelAt(int charIndex) {
	        VerifyValidParaOrLine();
	        VerifyRange(charIndex, 0, length);
	        return IBM.ICU.Text.BidiLine.GetLevelAt(this, charIndex);
	    }
	
	    /// <summary>
	    /// Get an array of levels for each character.
	    /// <p>
	    /// Note that this method may allocate memory under some circumstances,
	    /// unlike <c>getLevelAt()</c>.
	    /// </summary>
	    ///
	    /// <returns>The levels array for the text, or <c>null</c> if an error
	    /// occurs.</returns>
	    /// <exception cref="IllegalStateException">if this call is not preceded by a successful call to<c>setPara</c> or <c>setLine</c></exception>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public sbyte[] GetLevels() {
	        VerifyValidParaOrLine();
	        if (length <= 0) {
	            return new sbyte[0];
	        }
	        return IBM.ICU.Text.BidiLine.GetLevels(this);
	    }
	
	    /// <summary>
	    /// Get a logical run. This method returns information about a run and is
	    /// used to retrieve runs in logical order.
	    /// <p>
	    /// This is especially useful for line-breaking on a paragraph.
	    /// </summary>
	    ///
	    /// <param name="logicalPosition">is a logical position within the source text.</param>
	    /// <returns>a BidiRun object filled with <c>start</c> containing the
	    /// first character of the run, <c>limit</c> containing the
	    /// limit of the run, and <c>embeddingLevel</c> containing the
	    /// level of the run.</returns>
	    /// <exception cref="IllegalStateException">if this call is not preceded by a successful call to<c>setPara</c> or <c>setLine</c></exception>
	    /// <exception cref="IllegalArgumentException">if logicalPosition is not in the range<c>0&lt;=logicalPosition&lt;getProcessedLength()</c></exception>
	    /// <seealso cref="T:IBM.ICU.Text.BidiRun"/>
	    /// <seealso cref="M:IBM.ICU.Text.BidiRun.GetStart"/>
	    /// <seealso cref="M:IBM.ICU.Text.BidiRun.GetLimit"/>
	    /// <seealso cref="M:IBM.ICU.Text.BidiRun.GetEmbeddingLevel"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public BidiRun GetLogicalRun(int logicalPosition) {
	        VerifyValidParaOrLine();
	        VerifyRange(logicalPosition, 0, length);
	        return IBM.ICU.Text.BidiLine.GetLogicalRun(this, logicalPosition);
	    }
	
	    /// <summary>
	    /// Get the number of runs. This method may invoke the actual reordering on
	    /// the <c>Bidi</c> object, after <c>setPara()</c> may have
	    /// resolved only the levels of the text. Therefore, <c>countRuns()</c>
	    /// may have to allocate memory, and may throw an exception if it fails to do
	    /// so.
	    /// </summary>
	    ///
	    /// <returns>The number of runs.</returns>
	    /// <exception cref="IllegalStateException">if this call is not preceded by a successful call to<c>setPara</c> or <c>setLine</c></exception>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public int CountRuns() {
	        VerifyValidParaOrLine();
	        IBM.ICU.Text.BidiLine.GetRuns(this);
	        return runCount;
	    }
	
	    /// <summary>
	    /// Get a <c>BidiRun</c> object according to its index. BidiRun methods
	    /// may be used to retrieve the run's logical start, length and level, which
	    /// can be even for an LTR run or odd for an RTL run. In an RTL run, the
	    /// character at the logical start is visually on the right of the displayed
	    /// run. The length is the number of characters in the run.
	    /// <p>
	    /// <c>countRuns()</c> is normally called before the runs are
	    /// retrieved.
	    /// <p>
	    /// Example:
	    /// <pre>
	    /// Bidi bidi = new Bidi();
	    /// String text = &quot;abc 123 DEFG xyz&quot;;
	    /// bidi.setPara(text, Bidi.RTL, null);
	    /// int i, count = bidi.countRuns(), logicalStart, visualIndex = 0, length;
	    /// BidiRun run;
	    /// for (i = 0; i &lt; count; ++i) {
	    /// run = bidi.getVisualRun(i);
	    /// logicalStart = run.getStart();
	    /// length = run.getLength();
	    /// if (Bidi.LTR == run.getEmbeddingLevel()) {
	    /// do { // LTR
	    /// show_char(text.charAt(logicalStart++), visualIndex++);
	    /// } while (--length &gt; 0);
	    /// } else {
	    /// logicalStart += length; // logicalLimit
	    /// do { // RTL
	    /// show_char(text.charAt(--logicalStart), visualIndex++);
	    /// } while (--length &gt; 0);
	    /// }
	    /// }
	    /// </pre>
	    /// <p>
	    /// Note that in right-to-left runs, code like this places modifier letters
	    /// before base characters and second surrogates before first ones.
	    /// </summary>
	    ///
	    /// <param name="runIndex">is the number of the run in visual order, in the range<c>[0..countRuns()-1]</c>.</param>
	    /// <returns>a BidiRun object containing the details of the run. The
	    /// directionality of the run is <c>LTR==0</c> or
	    /// <c>RTL==1</c>, never <c>MIXED</c>.</returns>
	    /// <exception cref="IllegalStateException">if this call is not preceded by a successful call to<c>setPara</c> or <c>setLine</c></exception>
	    /// <exception cref="IllegalArgumentException">if <c>runIndex</c> is not in the range<c>0&lt;=runIndex&lt;countRuns()</c></exception>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.CountRuns"/>
	    /// <seealso cref="T:IBM.ICU.Text.BidiRun"/>
	    /// <seealso cref="M:IBM.ICU.Text.BidiRun.GetStart"/>
	    /// <seealso cref="M:IBM.ICU.Text.BidiRun.GetLength"/>
	    /// <seealso cref="M:IBM.ICU.Text.BidiRun.GetEmbeddingLevel"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public BidiRun GetVisualRun(int runIndex) {
	        VerifyValidParaOrLine();
	        IBM.ICU.Text.BidiLine.GetRuns(this);
	        VerifyRange(runIndex, 0, runCount);
	        return IBM.ICU.Text.BidiLine.GetVisualRun(this, runIndex);
	    }
	
	    /// <summary>
	    /// Get the visual position from a logical text position. If such a mapping
	    /// is used many times on the same <c>Bidi</c> object, then calling
	    /// <c>getLogicalMap()</c> is more efficient.
	    /// <p>
	    /// The value returned may be <c>MAP_NOWHERE</c> if there is no visual
	    /// position because the corresponding text character is a Bidi control
	    /// removed from output by the option <c>OPTION_REMOVE_CONTROLS</c>.
	    /// <p>
	    /// When the visual output is altered by using options of
	    /// <c>writeReordered()</c> such as <c>INSERT_LRM_FOR_NUMERIC</c>, <c>KEEP_BASE_COMBINING</c>, <c>OUTPUT_REVERSE</c>,
	    /// <c>REMOVE_BIDI_CONTROLS</c>, the visual position returned may not
	    /// be correct. It is advised to use, when possible, reordering options such
	    /// as <see cref="F:IBM.ICU.Text.Bidi.OPTION_INSERT_MARKS"/> and <see cref="F:IBM.ICU.Text.Bidi.OPTION_REMOVE_CONTROLS"/>.
	    /// <p>
	    /// Note that in right-to-left runs, this mapping places modifier letters
	    /// before base characters and second surrogates before first ones.
	    /// </summary>
	    ///
	    /// <param name="logicalIndex">is the index of a character in the text.</param>
	    /// <returns>The visual position of this character.</returns>
	    /// <exception cref="IllegalStateException">if this call is not preceded by a successful call to<c>setPara</c> or <c>setLine</c></exception>
	    /// <exception cref="IllegalArgumentException">if <c>logicalIndex</c> is not in the range<c>0&lt;=logicalIndex&lt;getProcessedLength()</c></exception>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.GetLogicalMap"/>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.GetLogicalIndex(System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.GetProcessedLength"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.MAP_NOWHERE"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.OPTION_REMOVE_CONTROLS"/>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.WriteReordered(System.Int32)"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public int GetVisualIndex(int logicalIndex) {
	        VerifyValidParaOrLine();
	        VerifyRange(logicalIndex, 0, length);
	        return IBM.ICU.Text.BidiLine.GetVisualIndex(this, logicalIndex);
	    }
	
	    /// <summary>
	    /// Get the logical text position from a visual position. If such a mapping
	    /// is used many times on the same <c>Bidi</c> object, then calling
	    /// <c>getVisualMap()</c> is more efficient.
	    /// <p>
	    /// The value returned may be <c>MAP_NOWHERE</c> if there is no logical
	    /// position because the corresponding text character is a Bidi mark inserted
	    /// in the output by option <c>OPTION_INSERT_MARKS</c>.
	    /// <p>
	    /// This is the inverse method to <c>getVisualIndex()</c>.
	    /// <p>
	    /// When the visual output is altered by using options of
	    /// <c>writeReordered()</c> such as <c>INSERT_LRM_FOR_NUMERIC</c>, <c>KEEP_BASE_COMBINING</c>, <c>OUTPUT_REVERSE</c>,
	    /// <c>REMOVE_BIDI_CONTROLS</c>, the logical position returned may not
	    /// be correct. It is advised to use, when possible, reordering options such
	    /// as <see cref="F:IBM.ICU.Text.Bidi.OPTION_INSERT_MARKS"/> and <see cref="F:IBM.ICU.Text.Bidi.OPTION_REMOVE_CONTROLS"/>.
	    /// </summary>
	    ///
	    /// <param name="visualIndex">is the visual position of a character.</param>
	    /// <returns>The index of this character in the text.</returns>
	    /// <exception cref="IllegalStateException">if this call is not preceded by a successful call to<c>setPara</c> or <c>setLine</c></exception>
	    /// <exception cref="IllegalArgumentException">if <c>visualIndex</c> is not in the range<c>0&lt;=visualIndex&lt;getResultLength()</c></exception>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.GetVisualMap"/>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.GetVisualIndex(System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.GetResultLength"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.MAP_NOWHERE"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.OPTION_INSERT_MARKS"/>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.WriteReordered(System.Int32)"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public int GetLogicalIndex(int visualIndex) {
	        VerifyValidParaOrLine();
	        VerifyRange(visualIndex, 0, resultLength);
	        /* we can do the trivial cases without the runs array */
	        if (insertPoints.size == 0 && controlCount == 0) {
	            if (direction == LTR) {
	                return visualIndex;
	            } else if (direction == RTL) {
	                return length - visualIndex - 1;
	            }
	        }
	        IBM.ICU.Text.BidiLine.GetRuns(this);
	        return IBM.ICU.Text.BidiLine.GetLogicalIndex(this, visualIndex);
	    }
	
	    /// <summary>
	    /// Get a logical-to-visual index map (array) for the characters in the
	    /// <c>Bidi</c> (paragraph or line) object.
	    /// <p>
	    /// Some values in the map may be <c>MAP_NOWHERE</c> if the
	    /// corresponding text characters are Bidi controls removed from the visual
	    /// output by the option <c>OPTION_REMOVE_CONTROLS</c>.
	    /// <p>
	    /// When the visual output is altered by using options of
	    /// <c>writeReordered()</c> such as <c>INSERT_LRM_FOR_NUMERIC</c>, <c>KEEP_BASE_COMBINING</c>, <c>OUTPUT_REVERSE</c>,
	    /// <c>REMOVE_BIDI_CONTROLS</c>, the visual positions returned may not
	    /// be correct. It is advised to use, when possible, reordering options such
	    /// as <see cref="F:IBM.ICU.Text.Bidi.OPTION_INSERT_MARKS"/> and <see cref="F:IBM.ICU.Text.Bidi.OPTION_REMOVE_CONTROLS"/>.
	    /// </summary>
	    ///
	    /// <returns>an array of <c>getProcessedLength()</c> indexes which will
	    /// reflect the reordering of the characters.<br>
	    /// <br>
	    /// The index map will result in
	    /// <c>indexMap[logicalIndex]==visualIndex</c>, where
	    /// <c>indexMap</c> represents the returned array.</returns>
	    /// <exception cref="IllegalStateException">if this call is not preceded by a successful call to<c>setPara</c> or <c>setLine</c></exception>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.GetVisualMap"/>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.GetVisualIndex(System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.GetProcessedLength"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.MAP_NOWHERE"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.OPTION_REMOVE_CONTROLS"/>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.WriteReordered(System.Int32)"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public int[] GetLogicalMap() {
	        /* countRuns() checks successful call to setPara/setLine */
	        CountRuns();
	        if (length <= 0) {
	            return new int[0];
	        }
	        return IBM.ICU.Text.BidiLine.GetLogicalMap(this);
	    }
	
	    /// <summary>
	    /// Get a visual-to-logical index map (array) for the characters in the
	    /// <c>Bidi</c> (paragraph or line) object.
	    /// <p>
	    /// Some values in the map may be <c>MAP_NOWHERE</c> if the
	    /// corresponding text characters are Bidi marks inserted in the visual
	    /// output by the option <c>OPTION_INSERT_MARKS</c>.
	    /// <p>
	    /// When the visual output is altered by using options of
	    /// <c>writeReordered()</c> such as <c>INSERT_LRM_FOR_NUMERIC</c>, <c>KEEP_BASE_COMBINING</c>, <c>OUTPUT_REVERSE</c>,
	    /// <c>REMOVE_BIDI_CONTROLS</c>, the logical positions returned may not
	    /// be correct. It is advised to use, when possible, reordering options such
	    /// as <see cref="F:IBM.ICU.Text.Bidi.OPTION_INSERT_MARKS"/> and <see cref="F:IBM.ICU.Text.Bidi.OPTION_REMOVE_CONTROLS"/>.
	    /// </summary>
	    ///
	    /// <returns>an array of <c>getResultLength()</c> indexes which will
	    /// reflect the reordering of the characters.<br>
	    /// <br>
	    /// The index map will result in
	    /// <c>indexMap[visualIndex]==logicalIndex</c>, where
	    /// <c>indexMap</c> represents the returned array.</returns>
	    /// <exception cref="IllegalStateException">if this call is not preceded by a successful call to<c>setPara</c> or <c>setLine</c></exception>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.GetLogicalMap"/>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.GetLogicalIndex(System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.GetResultLength"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.MAP_NOWHERE"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.OPTION_INSERT_MARKS"/>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.WriteReordered(System.Int32)"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public int[] GetVisualMap() {
	        /* countRuns() checks successful call to setPara/setLine */
	        CountRuns();
	        if (resultLength <= 0) {
	            return new int[0];
	        }
	        return IBM.ICU.Text.BidiLine.GetVisualMap(this);
	    }
	
	    /// <summary>
	    /// This is a convenience method that does not use a <c>Bidi</c>
	    /// object. It is intended to be used for when an application has determined
	    /// the levels of objects (character sequences) and just needs to have them
	    /// reordered (L2). This is equivalent to using <c>getLogicalMap()</c>
	    /// on a <c>Bidi</c> object.
	    /// </summary>
	    ///
	    /// <param name="levels_0">is an array of levels that have been determined by theapplication.</param>
	    /// <returns>an array of <c>levels.length</c> indexes which will reflect
	    /// the reordering of the characters.
	    /// <p>
	    /// The index map will result in
	    /// <c>indexMap[logicalIndex]==visualIndex</c>, where
	    /// <c>indexMap</c> represents the returned array.</returns>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public static int[] ReorderLogical(sbyte[] levels_0) {
	        return IBM.ICU.Text.BidiLine.ReorderLogical(levels_0);
	    }
	
	    /// <summary>
	    /// This is a convenience method that does not use a <c>Bidi</c>
	    /// object. It is intended to be used for when an application has determined
	    /// the levels of objects (character sequences) and just needs to have them
	    /// reordered (L2). This is equivalent to using <c>getVisualMap()</c>
	    /// on a <c>Bidi</c> object.
	    /// </summary>
	    ///
	    /// <param name="levels_0">is an array of levels that have been determined by theapplication.</param>
	    /// <returns>an array of <c>levels.length</c> indexes which will reflect
	    /// the reordering of the characters.
	    /// <p>
	    /// The index map will result in
	    /// <c>indexMap[visualIndex]==logicalIndex</c>, where
	    /// <c>indexMap</c> represents the returned array.</returns>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public static int[] ReorderVisual(sbyte[] levels_0) {
	        return IBM.ICU.Text.BidiLine.ReorderVisual(levels_0);
	    }
	
	    /// <summary>
	    /// Invert an index map. The index mapping of the argument map is inverted
	    /// and returned as an array of indexes that we will call the inverse map.
	    /// </summary>
	    ///
	    /// <param name="srcMap">is an array whose elements define the original mapping from asource array to a destination array. Some elements of thesource array may have no mapping in the destination array. Inthat case, their value will be the special value<c>MAP_NOWHERE</c>. All elements must be >=0 or equal to<c>MAP_NOWHERE</c>. Some elements in the source map mayhave a value greater than the srcMap.length if the destinationarray has more elements than the source array. There must beno duplicate indexes (two or more elements with the same valueexcept <c>MAP_NOWHERE</c>).</param>
	    /// <returns>an array representing the inverse map. This array has a number of
	    /// elements equal to 1 + the highest value in <c>srcMap</c>.
	    /// For elements of the result array which have no matching elements
	    /// in the source array, the corresponding elements in the inverse
	    /// map will receive a value equal to <c>MAP_NOWHERE</c>. If
	    /// element with index i in <c>srcMap</c> has a value k
	    /// different from <c>MAP_NOWHERE</c>, this means that element
	    /// i of the source array maps to element k in the destination array.
	    /// The inverse map will have value i in its k-th element. For all
	    /// elements of the destination array which do not map to an element
	    /// in the source array, the corresponding element in the inverse map
	    /// will have a value equal to <c>MAP_NOWHERE</c>.</returns>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.MAP_NOWHERE"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public static int[] InvertMap(int[] srcMap) {
	        if (srcMap == null) {
	            return null;
	        } else {
	            return IBM.ICU.Text.BidiLine.InvertMap(srcMap);
	        }
	    }
	
	    /*
	     * Fields and methods for compatibility with java.text.bidi (Sun
	     * implementation)
	     */
	
	    /// <summary>
	    /// Constant indicating base direction is left-to-right.
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const int DIRECTION_LEFT_TO_RIGHT = LTR;
	
	    /// <summary>
	    /// Constant indicating base direction is right-to-left.
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const int DIRECTION_RIGHT_TO_LEFT = RTL;
	
	    /// <summary>
	    /// Constant indicating that the base direction depends on the first strong
	    /// directional character in the text according to the Unicode Bidirectional
	    /// Algorithm. If no strong directional character is present, the base
	    /// direction is left-to-right.
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const int DIRECTION_DEFAULT_LEFT_TO_RIGHT = LEVEL_DEFAULT_LTR;
	
	    /// <summary>
	    /// Constant indicating that the base direction depends on the first strong
	    /// directional character in the text according to the Unicode Bidirectional
	    /// Algorithm. If no strong directional character is present, the base
	    /// direction is right-to-left.
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const int DIRECTION_DEFAULT_RIGHT_TO_LEFT = LEVEL_DEFAULT_RTL;
	
	    /// <summary>
	    /// Create Bidi from the given paragraph of text and base direction.
	    /// </summary>
	    ///
	    /// <param name="paragraph">a paragraph of text</param>
	    /// <param name="flags_0">a collection of flags that control the algorithm. Thealgorithm understands the flags DIRECTION_LEFT_TO_RIGHT,DIRECTION_RIGHT_TO_LEFT, DIRECTION_DEFAULT_LEFT_TO_RIGHT, andDIRECTION_DEFAULT_RIGHT_TO_LEFT. Other values are reserved.</param>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.DIRECTION_LEFT_TO_RIGHT"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.DIRECTION_RIGHT_TO_LEFT"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.DIRECTION_DEFAULT_LEFT_TO_RIGHT"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.DIRECTION_DEFAULT_RIGHT_TO_LEFT"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public Bidi(String paragraph, int flags_0) : this(paragraph.ToCharArray(), 0, null, 0, paragraph.Length, flags_0) {
	    }
	
	    // #if defined(FOUNDATION10)
	    // #else
	    /// <summary>
	    /// Create Bidi from the given paragraph of text.
	    /// <p>
	    /// The RUN_DIRECTION attribute in the text, if present, determines the base
	    /// direction (left-to-right or right-to-left). If not present, the base
	    /// direction is computed using the Unicode Bidirectional Algorithm,
	    /// defaulting to left-to-right if there are no strong directional characters
	    /// in the text. This attribute, if present, must be applied to all the text
	    /// in the paragraph.
	    /// <p>
	    /// The BIDI_EMBEDDING attribute in the text, if present, represents
	    /// embedding level information. Negative values from -1 to -62 indicate
	    /// overrides at the absolute value of the level. Positive values from 1 to
	    /// 62 indicate embeddings. Where values are zero or not defined, the base
	    /// embedding level as determined by the base direction is assumed.
	    /// <p>
	    /// The NUMERIC_SHAPING attribute in the text, if present, converts European
	    /// digits to other decimal digits before running the bidi algorithm. This
	    /// attribute, if present, must be applied to all the text in the paragraph.
	    /// <p>
	    /// Note: this constructor calls setPara() internally.
	    /// </summary>
	    ///
	    /// <param name="paragraph">a paragraph of text with optional character and paragraphattribute information</param>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public Bidi(ILOG.J2CsMapping.Text.AttributedCharacterIterator paragraph) : this() {
	        SetPara(paragraph);
	    }
	
	    // #endif
	
	    /// <summary>
	    /// Create Bidi from the given text, embedding, and direction information.
	    /// The embeddings array may be null. If present, the values represent
	    /// embedding level information. Negative values from -1 to -61 indicate
	    /// overrides at the absolute value of the level. Positive values from 1 to
	    /// 61 indicate embeddings. Where values are zero, the base embedding level
	    /// as determined by the base direction is assumed.
	    /// <p>
	    /// Note: this constructor calls setPara() internally.
	    /// </summary>
	    ///
	    /// <param name="text_0">an array containing the paragraph of text to process.</param>
	    /// <param name="textStart">the index into the text array of the start of the paragraph.</param>
	    /// <param name="embeddings">an array containing embedding values for each character in theparagraph. This can be null, in which case it is assumed thatthere is no external embedding information.</param>
	    /// <param name="embStart">the index into the embedding array of the start of theparagraph.</param>
	    /// <param name="paragraphLength">the length of the paragraph in the text and embeddings arrays.</param>
	    /// <param name="flags_1">a collection of flags that control the algorithm. Thealgorithm understands the flags DIRECTION_LEFT_TO_RIGHT,DIRECTION_RIGHT_TO_LEFT, DIRECTION_DEFAULT_LEFT_TO_RIGHT, andDIRECTION_DEFAULT_RIGHT_TO_LEFT. Other values are reserved.</param>
	    /// <exception cref="IllegalArgumentException">if the values in embeddings are not within the allowed range</exception>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.DIRECTION_LEFT_TO_RIGHT"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.DIRECTION_RIGHT_TO_LEFT"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.DIRECTION_DEFAULT_LEFT_TO_RIGHT"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.DIRECTION_DEFAULT_RIGHT_TO_LEFT"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public Bidi(char[] text_0, int textStart, sbyte[] embeddings, int embStart,
	            int paragraphLength, int flags_1) : this() {
	        sbyte paraLevel_2;
	        switch (flags_1) {
	        case DIRECTION_LEFT_TO_RIGHT:
	        default:
	            paraLevel_2 = LTR;
	            break;
	        case DIRECTION_RIGHT_TO_LEFT:
	            paraLevel_2 = RTL;
	            break;
	        case DIRECTION_DEFAULT_LEFT_TO_RIGHT:
	            paraLevel_2 = LEVEL_DEFAULT_LTR;
	            break;
	        case DIRECTION_DEFAULT_RIGHT_TO_LEFT:
	            paraLevel_2 = LEVEL_DEFAULT_RTL;
	            break;
	        }
	        sbyte[] paraEmbeddings;
	        if (embeddings == null) {
	            paraEmbeddings = null;
	        } else {
	            paraEmbeddings = new sbyte[paragraphLength];
	            sbyte lev;
	            for (int i = 0; i < paragraphLength; i++) {
	                lev = embeddings[i + embStart];
	                if (lev < 0) {
	                    lev = (sbyte) ((-lev) | LEVEL_OVERRIDE);
	                } else if (lev == 0) {
	                    lev = paraLevel_2;
	                    if (paraLevel_2 > MAX_EXPLICIT_LEVEL) {
	                        lev &= 1;
	                    }
	                }
	                paraEmbeddings[i] = lev;
	            }
	        }
	        if (textStart == 0 && embStart == 0 && paragraphLength == text_0.Length) {
	            SetPara(text_0, paraLevel_2, paraEmbeddings);
	        } else {
	            char[] paraText = new char[paragraphLength];
	            System.Array.Copy((Array)(text_0),textStart,(Array)(paraText),0,paragraphLength);
	            SetPara(paraText, paraLevel_2, paraEmbeddings);
	        }
	    }
	
	    /// <summary>
	    /// Create a Bidi object representing the bidi information on a line of text
	    /// within the paragraph represented by the current Bidi. This call is not
	    /// required if the entire paragraph fits on one line.
	    /// </summary>
	    ///
	    /// <param name="lineStart">the offset from the start of the paragraph to the start of theline.</param>
	    /// <param name="lineLimit">the offset from the start of the paragraph to the limit of theline.</param>
	    /// <exception cref="IllegalStateException">if this call is not preceded by a successful call to<c>setPara</c></exception>
	    /// <exception cref="IllegalArgumentException">if lineStart and lineLimit are not in the range<c>0&lt;=lineStart&lt;lineLimit&lt;=getProcessedLength()</c>, or if the specified line crosses a paragraph boundary</exception>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public Bidi CreateLineBidi(int lineStart, int lineLimit) {
	        return SetLine(lineStart, lineLimit);
	    }
	
	    /// <summary>
	    /// Return true if the line is not left-to-right or right-to-left. This means
	    /// it either has mixed runs of left-to-right and right-to-left text, or the
	    /// base direction differs from the direction of the only run of text.
	    /// </summary>
	    ///
	    /// <returns>true if the line is not left-to-right or right-to-left.</returns>
	    /// <exception cref="IllegalStateException">if this call is not preceded by a successful call to<c>setPara</c></exception>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public bool IsMixed() {
	        return (!IsLeftToRight() && !IsRightToLeft());
	    }
	
	    /// <summary>
	    /// Return true if the line is all left-to-right text and the base direction
	    /// is left-to-right.
	    /// </summary>
	    ///
	    /// <returns>true if the line is all left-to-right text and the base direction
	    /// is left-to-right.</returns>
	    /// <exception cref="IllegalStateException">if this call is not preceded by a successful call to<c>setPara</c></exception>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public bool IsLeftToRight() {
	        return (GetDirection() == LTR && (paraLevel & 1) == 0);
	    }
	
	    /// <summary>
	    /// Return true if the line is all right-to-left text, and the base direction
	    /// is right-to-left
	    /// </summary>
	    ///
	    /// <returns>true if the line is all right-to-left text, and the base
	    /// direction is right-to-left</returns>
	    /// <exception cref="IllegalStateException">if this call is not preceded by a successful call to<c>setPara</c></exception>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public bool IsRightToLeft() {
	        return (GetDirection() == RTL && (paraLevel & 1) == 1);
	    }
	
	    /// <summary>
	    /// Return true if the base direction is left-to-right
	    /// </summary>
	    ///
	    /// <returns>true if the base direction is left-to-right</returns>
	    /// <exception cref="IllegalStateException">if this call is not preceded by a successful call to<c>setPara</c> or <c>setLine</c></exception>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public bool BaseIsLeftToRight() {
	        return (GetParaLevel() == LTR);
	    }
	
	    /// <summary>
	    /// Return the base level (0 if left-to-right, 1 if right-to-left).
	    /// </summary>
	    ///
	    /// <returns>the base level</returns>
	    /// <exception cref="IllegalStateException">if this call is not preceded by a successful call to<c>setPara</c> or <c>setLine</c></exception>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public int GetBaseLevel() {
	        return GetParaLevel();
	    }
	
	    /// <summary>
	    /// Return the number of level runs.
	    /// </summary>
	    ///
	    /// <returns>the number of level runs</returns>
	    /// <exception cref="IllegalStateException">if this call is not preceded by a successful call to<c>setPara</c> or <c>setLine</c></exception>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public int GetRunCount() {
	        return CountRuns();
	    }
	
	    /// <summary>
	    /// Compute the logical to visual run mapping
	    /// </summary>
	    ///
	    internal void GetLogicalToVisualRunsMap() {
	        if (isGoodLogicalToVisualRunsMap) {
	            return;
	        }
	        int count = CountRuns();
	        if ((logicalToVisualRunsMap == null)
	                || (logicalToVisualRunsMap.Length < count)) {
	            logicalToVisualRunsMap = new int[count];
	        }
	        int i;
	        long[] keys = new long[count];
	        for (i = 0; i < count; i++) {
	            keys[i] = ((long) (runs[i].start) << 32) + i;
	        }
	        System.Array.Sort(keys);
	        for (i = 0; i < count; i++) {
	            logicalToVisualRunsMap[i] = (int) (keys[i] & -1);
	        }
	        keys = null;
	        isGoodLogicalToVisualRunsMap = true;
	    }
	
	    /// <summary>
	    /// Return the level of the nth logical run in this line.
	    /// </summary>
	    ///
	    /// <param name="run">the index of the run, between 0 and <c>countRuns()-1</c></param>
	    /// <returns>the level of the run</returns>
	    /// <exception cref="IllegalStateException">if this call is not preceded by a successful call to<c>setPara</c> or <c>setLine</c></exception>
	    /// <exception cref="IllegalArgumentException">if <c>run</c> is not in the range<c>0&lt;=run&lt;countRuns()</c></exception>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public int GetRunLevel(int run) {
	        VerifyValidParaOrLine();
	        IBM.ICU.Text.BidiLine.GetRuns(this);
	        VerifyRange(run, 0, runCount);
	        GetLogicalToVisualRunsMap();
	        return runs[logicalToVisualRunsMap[run]].level;
	    }
	
	    /// <summary>
	    /// Return the index of the character at the start of the nth logical run in
	    /// this line, as an offset from the start of the line.
	    /// </summary>
	    ///
	    /// <param name="run">the index of the run, between 0 and <c>countRuns()</c></param>
	    /// <returns>the start of the run</returns>
	    /// <exception cref="IllegalStateException">if this call is not preceded by a successful call to<c>setPara</c> or <c>setLine</c></exception>
	    /// <exception cref="IllegalArgumentException">if <c>run</c> is not in the range<c>0&lt;=run&lt;countRuns()</c></exception>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public int GetRunStart(int run) {
	        VerifyValidParaOrLine();
	        IBM.ICU.Text.BidiLine.GetRuns(this);
	        VerifyRange(run, 0, runCount);
	        GetLogicalToVisualRunsMap();
	        return runs[logicalToVisualRunsMap[run]].start;
	    }
	
	    /// <summary>
	    /// Return the index of the character past the end of the nth logical run in
	    /// this line, as an offset from the start of the line. For example, this
	    /// will return the length of the line for the last run on the line.
	    /// </summary>
	    ///
	    /// <param name="run">the index of the run, between 0 and <c>countRuns()</c></param>
	    /// <returns>the limit of the run</returns>
	    /// <exception cref="IllegalStateException">if this call is not preceded by a successful call to<c>setPara</c> or <c>setLine</c></exception>
	    /// <exception cref="IllegalArgumentException">if <c>run</c> is not in the range<c>0&lt;=run&lt;countRuns()</c></exception>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public int GetRunLimit(int run) {
	        VerifyValidParaOrLine();
	        IBM.ICU.Text.BidiLine.GetRuns(this);
	        VerifyRange(run, 0, runCount);
	        GetLogicalToVisualRunsMap();
	        int idx = logicalToVisualRunsMap[run];
	        int length_0 = (idx == 0) ? runs[idx].limit : runs[idx].limit
	                - runs[idx - 1].limit;
	        return runs[idx].start + length_0;
	    }
	
	    /// <summary>
	    /// Return true if the specified text requires bidi analysis. If this returns
	    /// false, the text will display left-to-right. Clients can then avoid
	    /// constructing a Bidi object. Text in the Arabic Presentation Forms area of
	    /// Unicode is presumed to already be shaped and ordered for display, and so
	    /// will not cause this method to return true.
	    /// </summary>
	    ///
	    /// <param name="text_0">the text containing the characters to test</param>
	    /// <param name="start">the start of the range of characters to test</param>
	    /// <param name="limit">the limit of the range of characters to test</param>
	    /// <returns>true if the range of characters requires bidi analysis</returns>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public static bool RequiresBidi(char[] text_0, int start, int limit) {
	        int RTLMask = (1 << IBM.ICU.Lang.UCharacterEnums.ECharacterDirection.DIRECTIONALITY_RIGHT_TO_LEFT
	                | 1 << IBM.ICU.Lang.UCharacterEnums.ECharacterDirection.DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC
	                | 1 << IBM.ICU.Lang.UCharacterEnums.ECharacterDirection.DIRECTIONALITY_RIGHT_TO_LEFT_EMBEDDING
	                | 1 << IBM.ICU.Lang.UCharacterEnums.ECharacterDirection.DIRECTIONALITY_RIGHT_TO_LEFT_OVERRIDE | 1 << IBM.ICU.Lang.UCharacterEnums.ECharacterDirection.DIRECTIONALITY_ARABIC_NUMBER);
	
	        for (int i = start; i < limit; ++i) {
	            if (((1 << IBM.ICU.Lang.UCharacter.GetDirection(text_0[i])) & RTLMask) != 0) {
	                return true;
	            }
	        }
	        return false;
	    }
	
	    /// <summary>
	    /// Reorder the objects in the array into visual order based on their levels.
	    /// This is a utility method to use when you have a collection of objects
	    /// representing runs of text in logical order, each run containing text at a
	    /// single level. The elements at <c>index</c> from
	    /// <c>objectStart</c> up to <c>objectStart + count</c> in the
	    /// objects array will be reordered into visual order assuming each run of
	    /// text has the level indicated by the corresponding element in the levels
	    /// array (at <c>index - objectStart + levelStart</c>).
	    /// </summary>
	    ///
	    /// <param name="levels_0">an array representing the bidi level of each object</param>
	    /// <param name="levelStart">the start position in the levels array</param>
	    /// <param name="objects">the array of objects to be reordered into visual order</param>
	    /// <param name="objectStart">the start position in the objects array</param>
	    /// <param name="count">the number of objects to reorder</param>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public static void ReorderVisually(sbyte[] levels_0, int levelStart,
	            Object[] objects, int objectStart, int count) {
	        sbyte[] reorderLevels = new sbyte[count];
	        System.Array.Copy((Array)(levels_0),levelStart,(Array)(reorderLevels),0,count);
	        int[] indexMap = ReorderVisual(reorderLevels);
	        Object[] temp = new Object[count];
	        System.Array.Copy((Array)(objects),objectStart,(Array)(temp),0,count);
	        for (int i = 0; i < count; ++i) {
	            objects[objectStart + i] = temp[indexMap[i]];
	        }
	    }
	
	    /// <summary>
	    /// Take a <c>Bidi</c> object containing the reordering information for
	    /// a piece of text (one or more paragraphs) set by <c>setPara()</c> or
	    /// for a line of text set by <c>setLine()</c> and return a string
	    /// containing the reordered text.
	    /// <p>
	    /// The text may have been aliased (only a reference was stored without
	    /// copying the contents), thus it must not have been modified since the
	    /// <c>setPara()</c> call.
	    /// </p>
	    /// This method preserves the integrity of characters with multiple code
	    /// units and (optionally) modifier letters. Characters in RTL runs can be
	    /// replaced by mirror-image characters in the returned string. Note that
	    /// "real" mirroring has to be done in a rendering engine by glyph selection
	    /// and that for many "mirrored" characters there are no Unicode characters
	    /// as mirror-image equivalents. There are also options to insert or remove
	    /// Bidi control characters; see the descriptions of the return value and the
	    /// <c>options</c> parameter, and of the option bit flags.
	    /// </summary>
	    ///
	    /// <param name="options">A bit set of options for the reordering that control how thereordered text is written. The options include mirroring thecharacters on a code point basis and inserting LRM characters,which is used especially for transforming visually stored textto logically stored text (although this is still an imperfectimplementation of an "inverse Bidi" algorithm because it usesthe "forward Bidi" algorithm at its core). The availableoptions are: <c>DO_MIRRORING</c>,<c>INSERT_LRM_FOR_NUMERIC</c>,<c>KEEP_BASE_COMBINING</c>, <c>OUTPUT_REVERSE</c>,<c>REMOVE_BIDI_CONTROLS</c>, <c>STREAMING</c></param>
	    /// <returns>The reordered text. If the <c>INSERT_LRM_FOR_NUMERIC</c>
	    /// option is set, then the length of the returned string could be as
	    /// large as <code>getLength()+2///countRuns()</code>.<br>
	    /// If the <c>REMOVE_BIDI_CONTROLS</c> option is set, then the
	    /// length of the returned string may be less than
	    /// <c>getLength()</c>.<br>
	    /// If none of these options is set, then the length of the returned
	    /// string will be exactly <c>getProcessedLength()</c>.</returns>
	    /// <exception cref="IllegalStateException">if this call is not preceded by a successful call to<c>setPara</c> or <c>setLine</c></exception>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.DO_MIRRORING"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.INSERT_LRM_FOR_NUMERIC"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.KEEP_BASE_COMBINING"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.OUTPUT_REVERSE"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.REMOVE_BIDI_CONTROLS"/>
	    /// <seealso cref="F:IBM.ICU.Text.Bidi.OPTION_STREAMING"/>
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.GetProcessedLength"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public String WriteReordered(int options) {
	        VerifyValidParaOrLine();
	        if (length == 0) {
	            /* nothing to do */
	            return "";
	        }
	
	        return IBM.ICU.Text.BidiWriter.WriteReordered(this, options);
	    }
	
	    /// <summary>
	    /// Reverse a Right-To-Left run of Unicode text.
	    /// This method preserves the integrity of characters with multiple code
	    /// units and (optionally) modifier letters. Characters can be replaced by
	    /// mirror-image characters in the destination buffer. Note that "real"
	    /// mirroring has to be done in a rendering engine by glyph selection and
	    /// that for many "mirrored" characters there are no Unicode characters as
	    /// mirror-image equivalents. There are also options to insert or remove Bidi
	    /// control characters.
	    /// This method is the implementation for reversing RTL runs as part of
	    /// <c>writeReordered()</c>. For detailed descriptions of the
	    /// parameters, see there. Since no Bidi controls are inserted here, the
	    /// output string length will never exceed <c>src.length()</c>.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.Bidi.WriteReordered(System.Int32)"/>
	    /// <param name="src">The RTL run text.</param>
	    /// <param name="options">A bit set of options for the reordering that control how thereordered text is written. See the <c>options</c>parameter in <c>writeReordered()</c>.</param>
	    /// <returns>The reordered text. If the <c>REMOVE_BIDI_CONTROLS</c>
	    /// option is set, then the length of the returned string may be less
	    /// than <c>src.length()</c>. If this option is not set, then
	    /// the length of the returned string will be exactly
	    /// <c>src.length()</c>.</returns>
	    /// <exception cref="IllegalArgumentException">if <c>src</c> is null.</exception>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public static String WriteReverse(String src, int options) {
	        /* error checking */
	        if (src == null) {
	            throw new ArgumentException();
	        }
	
	        if (src.Length > 0) {
	            return IBM.ICU.Text.BidiWriter.WriteReverse(src, options);
	        } else {
	            /* nothing to do */
	            return "";
	        }
	    }
	
	}
}
