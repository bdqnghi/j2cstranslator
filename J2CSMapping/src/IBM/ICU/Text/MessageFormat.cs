//##header J2SE15
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:30 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /*
 **********************************************************************
 * Copyright (c) 2004-2007, International Business Machines
 * Corporation and others.  All Rights Reserved.
 **********************************************************************
 * Author: Alan Liu
 * Created: April 6, 2004
 * Since: ICU 3.0
 **********************************************************************
 */
namespace IBM.ICU.Text {
	
	using IBM.ICU.Util;
	using ILOG.J2CsMapping.Collections;
	using ILOG.J2CsMapping.Collections.Generics;
	using ILOG.J2CsMapping.IO;
	using ILOG.J2CsMapping.Text;
	using ILOG.J2CsMapping.Util;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.Globalization;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Text;
    using ILOG.J2CsMapping.Formatting;

	/// <summary>
	/// <c>MessageFormat</c> provides a means to produce concatenated messages
	/// in language-neutral way. Use this to construct messages displayed for end
	/// users.
	/// <p>
	/// <c>MessageFormat</c> takes a set of objects, formats them, then inserts
	/// the formatted strings into the pattern at the appropriate places.
	/// <p>
	/// <strong>Note:</strong> <c>MessageFormat</c> differs from the other
	/// <c>Format</c> classes in that you create a <c>MessageFormat</c>
	/// object with one of its constructors (not with a <c>getInstance</c>
	/// style factory method). The factory methods aren't necessary because
	/// <c>MessageFormat</c> itself doesn't implement locale specific behavior.
	/// Any locale specific behavior is defined by the pattern that you provide as
	/// well as the subformats used for inserted arguments.
	/// <p>
	/// <strong>Note:</strong> In ICU 3.8 MessageFormat supports named arguments. If
	/// a named argument is used, all arguments must be named. Names start with a
	/// character in <c>:ID_START:</c> and continue with characters in
	/// <c>:ID_CONTINUE:</c>, in particular they do not start with a digit. If
	/// named arguments are used, <see cref="M:IBM.ICU.Text.MessageFormat.UsesNamedArguments"/> will return true.
	/// <p>
	/// The other new APIs supporting named arguments are<see cref="M:IBM.ICU.Text.MessageFormat.SetFormatsByArgumentName(null)"/>,<see cref="M:IBM.ICU.Text.MessageFormat.SetFormatByArgumentName(System.String, null)"/>,<see cref="M:IBM.ICU.Text.MessageFormat.Format(null, System.Text.StringBuilder, null)"/>,<see cref="M:IBM.ICU.Text.MessageFormat.Format(System.String, null)"/>, <see cref="M:IBM.ICU.Text.MessageFormat.ParseToMap(System.String, null)"/>, and<see cref="M:IBM.ICU.Text.MessageFormat.ParseToMap(System.String)"/>. These APIs are all compatible with patterns that
	/// do not used named arguments-- in these cases the keys in the input or output
	/// <c>Map</c>s use <c>String</c>s that name the argument indices,
	/// e.g. "0", "1", "2"... etc.
	/// <p>
	/// When named arguments are used, certain APIs on Message that take or return
	/// arrays will throw an exception, since it is not possible to identify
	/// positions in an array using a name. These APIs are<see cref="M:IBM.ICU.Text.MessageFormat.SetFormatsByArgumentIndex(null)"/>,<see cref="M:IBM.ICU.Text.MessageFormat.GetFormatsByArgumentIndex"/>,<see cref="M:IBM.ICU.Text.MessageFormat.Format(null, System.Text.StringBuilder, null)"/>,<see cref="M:IBM.ICU.Text.MessageFormat.Format(System.String, null)"/>,<see cref="M:IBM.ICU.Text.MessageFormat.Parse(System.String, null)"/>, and<see cref="M:IBM.ICU.Text.MessageFormat.Parse(System.String)"/>. These APIs all have corresponding new versions as
	/// listed above.
	/// <p>
	/// The API <see cref="M:IBM.ICU.Text.MessageFormat.Format(System.Object, System.Text.StringBuilder, null)"/> has been
	/// modified so that the <c>Object</c> argument can be either an
	/// <c>Object</c> array or a <c>Map</c>. If this format uses named
	/// arguments, this argument must not be an <c>Object</c> array otherwise
	/// an exception will be thrown. If the argument is a <c>Map</c> it can be
	/// used with Strings that represent indices as described above.
	/// <h4><a name="patterns">Patterns and Their Interpretation</a></h4>
	/// <c>MessageFormat</c> uses patterns of the following form: <blockquote>
	/// <pre>
	/// <i>MessageFormatPattern:</i>
	/// <i>String</i>
	/// <i>MessageFormatPattern</i> <i>FormatElement</i> <i>String</i>
	/// <i>FormatElement:</i>
	/// { <i>ArgumentIndexOrName</i> }
	/// { <i>ArgumentIndexOrName</i> , <i>FormatType</i> }
	/// { <i>ArgumentIndexOrName</i> , <i>FormatType</i> , <i>FormatStyle</i> }
	/// <i>ArgumentIndexOrName: one of </i>
	/// ['0'-'9']+
	/// [:ID_START:][:ID_CONTINUE:]
	/// <i>FormatType: one of </i>
	/// number date time choice
	/// <i>FormatStyle:</i>
	/// short
	/// medium
	/// long
	/// full
	/// integer
	/// currency
	/// percent
	/// <i>SubformatPattern</i>
	/// <i>String:</i>
	/// <i>StringPart<sub>opt</sub></i>
	/// <i>String</i> <i>StringPart</i>
	/// <i>StringPart:</i>
	/// ''
	/// ' <i>QuotedString</i> '
	/// <i>UnquotedString</i>
	/// <i>SubformatPattern:</i>
	/// <i>SubformatPatternPart<sub>opt</sub></i>
	/// <i>SubformatPattern</i> <i>SubformatPatternPart</i>
	/// <i>SubFormatPatternPart:</i>
	/// ' <i>QuotedPattern</i> '
	/// <i>UnquotedPattern</i>
	/// </pre>
	/// </blockquote>
	/// <p>
	/// Within a <i>String</i>, <c>"''"</c> represents a single quote. A
	/// <i>QuotedString</i> can contain arbitrary characters except single quotes;
	/// the surrounding single quotes are removed. An <i>UnquotedString</i> can
	/// contain arbitrary characters except single quotes and left curly brackets.
	/// Thus, a string that should result in the formatted message "'{0}'" can be
	/// written as <c>"'''{'0}''"</c> or <c>"'''{0}'''"</c>.
	/// <p>
	/// Within a <i>SubformatPattern</i>, different rules apply. A
	/// <i>QuotedPattern</i> can contain arbitrary characters except single quotes;
	/// but the surrounding single quotes are <strong>not</strong> removed, so they
	/// may be interpreted by the subformat. For example,
	/// <c>"{1,number,$'#',##}"</c> will produce a number format with the
	/// pound-sign quoted, with a result such as: "$#31,45". An
	/// <i>UnquotedPattern</i> can contain arbitrary characters except single quotes,
	/// but curly braces within it must be balanced. For example,
	/// <c>"ab {0} de"</c> and <c>"ab '}' de"</c> are valid subformat
	/// patterns, but <c>"ab {0'}' de"</c> and <c>"ab } de"</c> are not.
	/// <p>
	/// <dl>
	/// <dt><b>Warning:</b>
	/// <dd>The rules for using quotes within message format patterns unfortunately
	/// have shown to be somewhat confusing. In particular, it isn't always obvious
	/// to localizers whether single quotes need to be doubled or not. Make sure to
	/// inform localizers about the rules, and tell them (for example, by using
	/// comments in resource bundle source files) which strings will be processed by
	/// MessageFormat. Note that localizers may need to use single quotes in
	/// translated strings where the original version doesn't have them. <br>
	/// Note also that the simplest way to avoid the problem is to use the real
	/// apostrophe (single quote) character \u2019 (') for human-readable text, and
	/// to use the ASCII apostrophe (\u0027 ' ) only in program syntax, like quoting
	/// in MessageFormat. See the annotations for U+0027 Apostrophe in The Unicode
	/// Standard.
	/// </p>
	/// </dl>
	/// <p>
	/// The <i>ArgumentIndex</i> value is a non-negative integer written using the
	/// digits '0' through '9', and represents an index into the
	/// <c>arguments</c> array passed to the <c>format</c> methods or the
	/// result array returned by the <c>parse</c> methods.
	/// <p>
	/// The <i>FormatType</i> and <i>FormatStyle</i> values are used to create a
	/// <c>Format</c> instance for the format element. The following table
	/// shows how the values map to Format instances. Combinations not shown in the
	/// table are illegal. A <i>SubformatPattern</i> must be a valid pattern string
	/// for the Format subclass used.
	/// <p>
	/// <table border=1>
	/// <tr>
	/// <th>Format Type
	/// <th>Format Style
	/// <th>Subformat Created
	/// <tr>
	/// <td colspan=2><i>(none)</i>
	/// <td><c>null</c>
	/// <tr>
	/// <td rowspan=5><c>number</c>
	/// <td><i>(none)</i>
	/// <td><c>NumberFormat.getInstance(getLocale())</c>
	/// <tr>
	/// <td><c>integer</c>
	/// <td><c>NumberFormat.getIntegerInstance(getLocale())</c>
	/// <tr>
	/// <td><c>currency</c>
	/// <td><c>NumberFormat.getCurrencyInstance(getLocale())</c>
	/// <tr>
	/// <td><c>percent</c>
	/// <td><c>NumberFormat.getPercentInstance(getLocale())</c>
	/// <tr>
	/// <td><i>SubformatPattern</i>
	/// <td>
	/// <c>new DecimalFormat(subformatPattern, new DecimalFormatSymbols(getLocale()))</c>
	/// <tr>
	/// <td rowspan=6><c>date</c>
	/// <td><i>(none)</i>
	/// <td><c>DateFormat.getDateInstance(DateFormat.DEFAULT, getLocale())</c>
	/// <tr>
	/// <td><c>short</c>
	/// <td><c>DateFormat.getDateInstance(DateFormat.SHORT, getLocale())</c>
	/// <tr>
	/// <td><c>medium</c>
	/// <td><c>DateFormat.getDateInstance(DateFormat.DEFAULT, getLocale())</c>
	/// <tr>
	/// <td><c>long</c>
	/// <td><c>DateFormat.getDateInstance(DateFormat.LONG, getLocale())</c>
	/// <tr>
	/// <td><c>full</c>
	/// <td><c>DateFormat.getDateInstance(DateFormat.FULL, getLocale())</c>
	/// <tr>
	/// <td><i>SubformatPattern</i>
	/// <td><code>new SimpleDateFormat(subformatPattern, getLocale())
	/// <tr>
	/// <td rowspan=6><c>time</c>
	/// <td><i>(none)</i>
	/// <td><c>DateFormat.getTimeInstance(DateFormat.DEFAULT, getLocale())</c>
	/// <tr>
	/// <td><c>short</c>
	/// <td><c>DateFormat.getTimeInstance(DateFormat.SHORT, getLocale())</c>
	/// <tr>
	/// <td><c>medium</c>
	/// <td><c>DateFormat.getTimeInstance(DateFormat.DEFAULT, getLocale())</c>
	/// <tr>
	/// <td><c>long</c>
	/// <td><c>DateFormat.getTimeInstance(DateFormat.LONG, getLocale())</c>
	/// <tr>
	/// <td><c>full</c>
	/// <td><c>DateFormat.getTimeInstance(DateFormat.FULL, getLocale())</c>
	/// <tr>
	/// <td><i>SubformatPattern</i>
	/// <td><code>new SimpleDateFormat(subformatPattern, getLocale())
	/// <tr>
	/// <td><c>choice</c>
	/// <td><i>SubformatPattern</i>
	/// <td><c>new ChoiceFormat(subformatPattern)</c>
	/// <tr>
	/// <td><c>plural</c>
	/// <td><i>SubformatPattern</i>
	/// <td><c>new PluralFormat(subformatPattern)</c>
	/// </table>
	/// <p>
	/// <h4>Usage Information</h4>
	/// <p>
	/// Here are some examples of usage: <blockquote>
	/// <pre>
	/// Object[] arguments = {
	/// new Integer(7),
	/// new Date(System.currentTimeMillis()),
	/// "a disturbance in the Force"
	/// };
	/// String result = MessageFormat.format(
	/// "At {1,time} on {1,date}, there was {2} on planet {0,number,integer}.",
	/// arguments);
	/// <em>output</em>: At 12:30 PM on Jul 3, 2053, there was a disturbance
	/// in the Force on planet 7.
	/// </pre>
	/// </blockquote> Typically, the message format will come from resources, and the
	/// arguments will be dynamically set at runtime.
	/// <p>
	/// Example 2: <blockquote>
	/// <pre>
	/// Object[] testArgs = {new Long(3), "MyDisk"};
	/// MessageFormat form = new MessageFormat(
	/// "The disk \"{1}\" contains {0} file(s).");
	/// System.out.println(form.format(testArgs));
	/// // output, with different testArgs
	/// <em>output</em>: The disk "MyDisk" contains 0 file(s).
	/// <em>output</em>: The disk "MyDisk" contains 1 file(s).
	/// <em>output</em>: The disk "MyDisk" contains 1,273 file(s).
	/// </pre>
	/// </blockquote>
	/// <p>
	/// For more sophisticated patterns, you can use a <c>ChoiceFormat</c> to
	/// get output such as: <blockquote>
	/// <pre>
	/// MessageFormat form = new MessageFormat("The disk \"{1}\" contains {0}.");
	/// double[] filelimits = {0,1,2};
	/// String[] filepart = {"no files","one file","{0,number} files"};
	/// ChoiceFormat fileform = new ChoiceFormat(filelimits, filepart);
	/// form.setFormatByArgumentIndex(0, fileform);
	/// Object[] testArgs = {new Long(12373), "MyDisk"};
	/// System.out.println(form.format(testArgs));
	/// // output, with different testArgs
	/// output: The disk "MyDisk" contains no files.
	/// output: The disk "MyDisk" contains one file.
	/// output: The disk "MyDisk" contains 1,273 files.
	/// </pre>
	/// </blockquote> You can either do this programmatically, as in the above
	/// example, or by using a pattern (see <see cref="null"/> for more
	/// information) as in: <blockquote>
	/// <pre>
	/// form.applyPattern(&quot;There {0,choice,0#are no files|1#is one file|1&lt;are {0,number,integer} files}.&quot;);
	/// </pre>
	/// </blockquote>
	/// <p>
	/// <strong>Note:</strong> As we see above, the string produced by a
	/// <c>ChoiceFormat</c> in <c>MessageFormat</c> is treated specially;
	/// occurances of '{' are used to indicated subformats, and cause recursion. If
	/// you create both a <c>MessageFormat</c> and <c>ChoiceFormat</c>
	/// programmatically (instead of using the string patterns), then be careful not
	/// to produce a format that recurses on itself, which will cause an infinite
	/// loop.
	/// <p>
	/// When a single argument is parsed more than once in the string, the last match
	/// will be the final result of the parsing. For example,
	/// <pre>
	/// MessageFormat mf = new MessageFormat(&quot;{0,number,#.##}, {0,number,#.#}&quot;);
	/// Object[] objs = { new Double(3.1415) };
	/// String result = mf.format(objs);
	/// // result now equals &quot;3.14, 3.1&quot;
	/// objs = null;
	/// objs = mf.parse(result, new ParsePosition(0));
	/// // objs now equals {new Double(3.1)}
	/// </pre>
	/// <p>
	/// Likewise, parsing with a MessageFormat object using patterns containing
	/// multiple occurances of the same argument would return the last match. For
	/// example,
	/// <pre>
	/// MessageFormat mf = new MessageFormat(&quot;{0}, {0}, {0}&quot;);
	/// String forParsing = &quot;x, y, z&quot;;
	/// Object[] objs = mf.parse(forParsing, new ParsePosition(0));
	/// // result now equals {new String(&quot;z&quot;)}
	/// </pre>
	/// <h4><a name="synchronization">Synchronization</a></h4>
	/// <p>
	/// Message formats are not synchronized. It is recommended to create separate
	/// format instances for each thread. If multiple threads access a format
	/// concurrently, it must be synchronized externally.
	/// </summary>
	///
	/// <seealso cref="T:System.Globalization.CultureInfo"/>
	/// <seealso cref="null"/>
	/// <seealso cref="T:IBM.ICU.Text.NumberFormat"/>
	/// <seealso cref="T:IBM.ICU.Text.DecimalFormat"/>
	/// <seealso cref="null"/>
	/// @stable ICU 3.0
	// TODO: Update JavaDoc class description with regards to named arguments.
	// TODO: Update JavaDoc class description with regards to PluralFormat
	// integration.
	public class MessageFormat : UFormat {
	
	    // Generated by serialver from JDK 1.4.1_01
	    internal const long serialVersionUID = 7136212545847378651L;
	
	    /// <summary>
	    /// Constructs a MessageFormat for the default locale and the specified
	    /// pattern. The constructor first sets the locale, then parses the pattern
	    /// and creates a list of subformats for the format elements contained in it.
	    /// Patterns and their interpretation are specified in the <a
	    /// href="#patterns">class description</a>.
	    /// </summary>
	    ///
	    /// <param name="pattern">the pattern for this message format</param>
	    /// <exception cref="IllegalArgumentException">if the pattern is invalid</exception>
	    /// @stable ICU 3.0
	    public MessageFormat(String pattern) {
	        this.pattern = "";
	        this.formats = new Format[INITIAL_FORMATS];
	        this.offsets = new int[INITIAL_FORMATS];
	        this.argumentNumbers = new int[INITIAL_FORMATS];
	        this.argumentNames = new String[INITIAL_FORMATS];
	        this.argumentNamesAreNumeric = true;
	        this.maxOffset = -1;
	        this.ulocale = IBM.ICU.Util.ULocale.GetDefault();
	        ApplyPattern(pattern);
	    }
	
	    /// <summary>
	    /// Constructs a MessageFormat for the specified locale and pattern. The
	    /// constructor first sets the locale, then parses the pattern and creates a
	    /// list of subformats for the format elements contained in it. Patterns and
	    /// their interpretation are specified in the <a href="#patterns">class
	    /// description</a>.
	    /// </summary>
	    ///
	    /// <param name="pattern">the pattern for this message format</param>
	    /// <param name="locale">the locale for this message format</param>
	    /// <exception cref="IllegalArgumentException">if the pattern is invalid</exception>
	    /// @stable ICU 3.0
        public MessageFormat(String pattern, Locale locale)
            : this(pattern, IBM.ICU.Util.ULocale.ForLocale(locale))
        {
	    }
	
	    /// <summary>
	    /// Constructs a MessageFormat for the specified locale and pattern. The
	    /// constructor first sets the locale, then parses the pattern and creates a
	    /// list of subformats for the format elements contained in it. Patterns and
	    /// their interpretation are specified in the <a href="#patterns">class
	    /// description</a>.
	    /// </summary>
	    ///
	    /// <param name="pattern">the pattern for this message format</param>
	    /// <param name="locale">the locale for this message format</param>
	    /// <exception cref="IllegalArgumentException">if the pattern is invalid</exception>
	    /// @stable ICU 3.2
	    public MessageFormat(String pattern, ULocale locale) {
	        this.pattern = "";
	        this.formats = new Format[INITIAL_FORMATS];
	        this.offsets = new int[INITIAL_FORMATS];
	        this.argumentNumbers = new int[INITIAL_FORMATS];
	        this.argumentNames = new String[INITIAL_FORMATS];
	        this.argumentNamesAreNumeric = true;
	        this.maxOffset = -1;
	        this.ulocale = locale;
	        ApplyPattern(pattern);
	    }
	
	    /// <summary>
	    /// Sets the locale to be used when creating or comparing subformats. This
	    /// affects subsequent calls to the <see cref="M:IBM.ICU.Text.MessageFormat.ApplyPattern applyPattern"/> and<see cref="M:IBM.ICU.Text.MessageFormat.ToPattern toPattern"/> methods as well as to the
	    /// <c>format</c> and <see cref="M:IBM.ICU.Text.MessageFormat.FormatToCharacterIteratorformatToCharacterIterator"/> methods.
	    /// </summary>
	    ///
	    /// <param name="locale">the locale to be used when creating or comparing subformats</param>
	    /// @stable ICU 3.0
        public void SetLocale(Locale locale)
        {
	        SetLocale(IBM.ICU.Util.ULocale.ForLocale(locale));
	    }
	
	    /// <summary>
	    /// Sets the locale to be used when creating or comparing subformats. This
	    /// affects subsequent calls to the <see cref="M:IBM.ICU.Text.MessageFormat.ApplyPattern applyPattern"/> and<see cref="M:IBM.ICU.Text.MessageFormat.ToPattern toPattern"/> methods as well as to the
	    /// <c>format</c> and <see cref="M:IBM.ICU.Text.MessageFormat.FormatToCharacterIteratorformatToCharacterIterator"/> methods.
	    /// </summary>
	    ///
	    /// <param name="locale">the locale to be used when creating or comparing subformats</param>
	    /// @stable ICU 3.2
	    public void SetLocale(ULocale locale) {
	        /* Save the pattern, and then reapply so that */
	        /* we pick up any changes in locale specific */
	        /* elements */
	        String existingPattern = ToPattern(); /* ibm.3550 */
	        this.ulocale = locale;
	        ApplyPattern(existingPattern); /* ibm.3550 */
	    }
	
	    /// <summary>
	    /// Gets the locale that's used when creating or comparing subformats.
	    /// </summary>
	    ///
	    /// <returns>the locale used when creating or comparing subformats</returns>
	    /// @stable ICU 3.0
        public Locale GetLocale()
        {
	        return ulocale.ToLocale();
	    }
	
	    /// <summary>
	    /// Gets the locale that's used when creating or comparing subformats.
	    /// </summary>
	    ///
	    /// <returns>the locale used when creating or comparing subformats</returns>
	    /// @stable ICU 3.2
	    public ULocale GetULocale() {
	        return ulocale;
	    }
	
	    /// <summary>
	    /// Sets the pattern used by this message format. The method parses the
	    /// pattern and creates a list of subformats for the format elements
	    /// contained in it. Patterns and their interpretation are specified in the
	    /// <a href="#patterns">class description</a>.
	    /// <p>
	    /// The pattern must contain only named or only numeric arguments, mixing
	    /// them is not allowed.
	    /// </summary>
	    ///
	    /// <param name="pattern">the pattern for this message format</param>
	    /// <exception cref="IllegalArgumentException">if the pattern is invalid</exception>
	    /// @stable ICU 3.0
	    public void ApplyPattern(String pattern) {
	        StringBuilder[] segments = new StringBuilder[4];
	        for (int i = 0; i < segments.Length; ++i) {
	            segments[i] = new StringBuilder();
	        }
	        int part = 0;
	        int formatNumber = 0;
	        bool inQuote = false;
	        int braceStack = 0;
	        maxOffset = -1;
	        for (int i_0 = 0; i_0 < pattern.Length; ++i_0) {
	            char ch = pattern[i_0];
	            if (part == 0) {
	                if (ch == '\'') {
	                    if (i_0 + 1 < pattern.Length
	                            && pattern[i_0 + 1] == '\'') {
	                        segments[part].Append(ch); // handle doubles
	                        ++i_0;
	                    } else {
	                        inQuote = !inQuote;
	                    }
	                } else if (ch == '{' && !inQuote) {
	                    part = 1;
	                } else {
	                    segments[part].Append(ch);
	                }
	            } else if (inQuote) { // just copy quotes in parts
	                segments[part].Append(ch);
	                if (ch == '\'') {
	                    inQuote = false;
	                }
	            } else {
	                switch ((int) ch) {
	                case ',':
	                    if (part < 3)
	                        part += 1;
	                    else
	                        segments[part].Append(ch);
	                    break;
	                case '{':
	                    ++braceStack;
	                    segments[part].Append(ch);
	                    break;
	                case '}':
	                    if (braceStack == 0) {
	                        part = 0;
	                        MakeFormat(i_0, formatNumber, segments);
	                        formatNumber++;
	                    } else {
	                        --braceStack;
	                        segments[part].Append(ch);
	                    }
	                    break;
	                case '\'':
	                    inQuote = true;
	                    {
	                        segments[part].Append(ch);
	                        break;
	                    }
	                    break;
	                // fall through, so we keep quotes in other parts
	                default:
	                    segments[part].Append(ch);
	                    break;
	                }
	            }
	        }
	        if (braceStack == 0 && part != 0) {
	            maxOffset = -1;
	            throw new ArgumentException(
	                    "Unmatched braces in the pattern.");
	        }
	        this.pattern = segments[0].ToString();
	    }
	
	    /// <summary>
	    /// Returns a pattern representing the current state of the message format.
	    /// The string is constructed from internal information and therefore does
	    /// not necessarily equal the previously applied pattern.
	    /// </summary>
	    ///
	    /// <returns>a pattern representing the current state of the message format</returns>
	    /// @stable ICU 3.0
	    public String ToPattern() {
	        // later, make this more extensible
	        int lastOffset = 0;
	        StringBuilder result = new StringBuilder();
	        for (int i = 0; i <= maxOffset; ++i) {
	            CopyAndFixQuotes(pattern, lastOffset, offsets[i], result);
	            lastOffset = offsets[i];
	            result.Append('{');
	            result.Append(argumentNames[i]);
	            if (formats[i] == null) {
	                // do nothing, string format
	            } else if (formats[i]  is  DecimalFormat) {
	                if (formats[i].Equals(IBM.ICU.Text.NumberFormat.GetInstance(ulocale))) {
	                    result.Append(",number");
	                } else if (formats[i].Equals(IBM.ICU.Text.NumberFormat
	                        .GetCurrencyInstance(ulocale))) {
	                    result.Append(",number,currency");
	                } else if (formats[i].Equals(IBM.ICU.Text.NumberFormat
	                        .GetPercentInstance(ulocale))) {
	                    result.Append(",number,percent");
	                } else if (formats[i].Equals(IBM.ICU.Text.NumberFormat
	                        .GetIntegerInstance(ulocale))) {
	                    result.Append(",number,integer");
	                } else {
	                    result.Append(",number,"
	                            + ((DecimalFormat) formats[i]).ToPattern());
	                }
	            } else if (formats[i]  is  SimpleDateFormat) {
	                if (formats[i].Equals(IBM.ICU.Text.DateFormat.GetDateInstance(
	                        IBM.ICU.Text.DateFormat.DEFAULT, ulocale))) {
	                    result.Append(",date");
	                } else if (formats[i].Equals(IBM.ICU.Text.DateFormat.GetDateInstance(
	                        IBM.ICU.Text.DateFormat.SHORT, ulocale))) {
	                    result.Append(",date,short");
	                    // This code will never be executed [alan]
	                    // } else if
	                    // (formats[i].equals(DateFormat.getDateInstance(DateFormat.DEFAULT,ulocale)))
	                    // {
	                    // result.append(",date,medium");
	                } else if (formats[i].Equals(IBM.ICU.Text.DateFormat.GetDateInstance(
	                        IBM.ICU.Text.DateFormat.LONG, ulocale))) {
	                    result.Append(",date,long");
	                } else if (formats[i].Equals(IBM.ICU.Text.DateFormat.GetDateInstance(
	                        IBM.ICU.Text.DateFormat.FULL, ulocale))) {
	                    result.Append(",date,full");
	                } else if (formats[i].Equals(IBM.ICU.Text.DateFormat.GetTimeInstance(
	                        IBM.ICU.Text.DateFormat.DEFAULT, ulocale))) {
	                    result.Append(",time");
	                } else if (formats[i].Equals(IBM.ICU.Text.DateFormat.GetTimeInstance(
	                        IBM.ICU.Text.DateFormat.SHORT, ulocale))) {
	                    result.Append(",time,short");
	                    // This code will never be executed [alan]
	                    // } else if
	                    // (formats[i].equals(DateFormat.getTimeInstance(DateFormat.DEFAULT,ulocale)))
	                    // {
	                    // result.append(",time,medium");
	                } else if (formats[i].Equals(IBM.ICU.Text.DateFormat.GetTimeInstance(
	                        IBM.ICU.Text.DateFormat.LONG, ulocale))) {
	                    result.Append(",time,long");
	                } else if (formats[i].Equals(IBM.ICU.Text.DateFormat.GetTimeInstance(
	                        IBM.ICU.Text.DateFormat.FULL, ulocale))) {
	                    result.Append(",time,full");
	                } else {
	                    result.Append(",date,"
	                            + ((SimpleDateFormat) formats[i]).ToPattern());
	                }
	            } else if (formats[i]  is  ChoiceFormat) {
	                result.Append(",choice,"
	                        + ((ChoiceFormat) formats[i]).ToPattern());
	            } else if (formats[i]  is  PluralFormat) {
	                // TODO: Implement PluralFormat.toPattern().
	                result.Append(", plural, support for converting PluralFormat "
	                        + "to pattern not yet available.");
	            } else {
	                // result.append(", unknown");
	            }
	            result.Append('}');
	        }
	        CopyAndFixQuotes(pattern, lastOffset, pattern.Length, result);
	        return result.ToString();
	    }
	
	    /// <summary>
	    /// Sets the formats to use for the values passed into <c>format</c>
	    /// methods or returned from <c>parse</c> methods. The indices of
	    /// elements in <c>newFormats</c> correspond to the argument indices
	    /// used in the previously set pattern string. The order of formats in
	    /// <c>newFormats</c> thus corresponds to the order of elements in the
	    /// <c>arguments</c> array passed to the <c>format</c> methods or
	    /// the result array returned by the <c>parse</c> methods.
	    /// <p>
	    /// If an argument index is used for more than one format element in the
	    /// pattern string, then the corresponding new format is used for all such
	    /// format elements. If an argument index is not used for any format element
	    /// in the pattern string, then the corresponding new format is ignored. If
	    /// fewer formats are provided than needed, then only the formats for
	    /// argument indices less than <c>newFormats.length</c> are replaced.
	    /// This method is only supported if the format does not use named arguments,
	    /// otherwise an IllegalArgumentException is thrown.
	    /// </summary>
	    ///
	    /// <param name="newFormats">the new formats to use</param>
	    /// <exception cref="NullPointerException">if <c>newFormats</c> is null</exception>
	    /// <exception cref="IllegalArgumentException">if this formatter uses named arguments</exception>
	    /// @stable ICU 3.0
	    public void SetFormatsByArgumentIndex(Format[] newFormats) {
	        if (!argumentNamesAreNumeric) {
	            throw new ArgumentException(
	                    "This method is not available in MessageFormat objects "
	                            + "that use alphanumeric argument names.");
	        }
	        for (int i = 0; i <= maxOffset; i++) {
	            int j = Int32.Parse(argumentNames[i]);
	            if (j < newFormats.Length) {
	                formats[i] = newFormats[j];
	            }
	        }
	    }
	
	    /// <summary>
	    /// Sets the formats to use for the values passed into <c>format</c>
	    /// methods or returned from <c>parse</c> methods. The keys in
	    /// <c>newFormats</c> are the argument names in the previously set
	    /// pattern string, and the values are the formats.
	    /// <p>
	    /// Only argument names from the pattern string are considered. Extra keys in
	    /// <c>newFormats</c> that do not correspond to an argument name are
	    /// ignored. Similarly, if there is no format in newFormats for an argument
	    /// name, the formatter for that argument remains unchanged.
	    /// <p>
	    /// This may be called on formats that do not use named arguments. In this
	    /// case the map will be queried for key Strings that represent argument
	    /// indices, e.g. "0", "1", "2" etc.
	    /// </summary>
	    ///
	    /// <param name="newFormats">a map from String to Format providing new formats for namedarguments.</param>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public void SetFormatsByArgumentName(IDictionary newFormats) {
	        for (int i = 0; i <= maxOffset; i++) {
	            if (newFormats.Contains(argumentNames[i])) {
	                Format f = (Format) ILOG.J2CsMapping.Collections.Collections.Get(newFormats,argumentNames[i]);
	                formats[i] = f;
	            }
	        }
	    }
	
	    /// <summary>
	    /// Sets the formats to use for the format elements in the previously set
	    /// pattern string. The order of formats in <c>newFormats</c>
	    /// corresponds to the order of format elements in the pattern string.
	    /// <p>
	    /// If more formats are provided than needed by the pattern string, the
	    /// remaining ones are ignored. If fewer formats are provided than needed,
	    /// then only the first <c>newFormats.length</c> formats are replaced.
	    /// <p>
	    /// Since the order of format elements in a pattern string often changes
	    /// during localization, it is generally better to use the<see cref="M:IBM.ICU.Text.MessageFormat.SetFormatsByArgumentIndex setFormatsByArgumentIndex"/> method,
	    /// which assumes an order of formats corresponding to the order of elements
	    /// in the <c>arguments</c> array passed to the <c>format</c>
	    /// methods or the result array returned by the <c>parse</c> methods.
	    /// </summary>
	    ///
	    /// <param name="newFormats">the new formats to use</param>
	    /// <exception cref="NullPointerException">if <c>newFormats</c> is null</exception>
	    /// @stable ICU 3.0
	    public void SetFormats(Format[] newFormats) {
	        int runsToCopy = newFormats.Length;
	        if (runsToCopy > maxOffset + 1) {
	            runsToCopy = maxOffset + 1;
	        }
	        for (int i = 0; i < runsToCopy; i++) {
	            formats[i] = newFormats[i];
	        }
	    }
	
	    /// <summary>
	    /// Sets the format to use for the format elements within the previously set
	    /// pattern string that use the given argument index. The argument index is
	    /// part of the format element definition and represents an index into the
	    /// <c>arguments</c> array passed to the <c>format</c> methods or
	    /// the result array returned by the <c>parse</c> methods.
	    /// <p>
	    /// If the argument index is used for more than one format element in the
	    /// pattern string, then the new format is used for all such format elements.
	    /// If the argument index is not used for any format element in the pattern
	    /// string, then the new format is ignored.
	    /// This method is only supported when exclusively numbers are used for
	    /// argument names. Otherwise an IllegalArgumentException is thrown.
	    /// </summary>
	    ///
	    /// <param name="argumentIndex">the argument index for which to use the new format</param>
	    /// <param name="newFormat">the new format to use</param>
	    /// <exception cref="IllegalArgumentException">if alphanumeric arguments where used in MessageFormat.</exception>
	    /// @stable ICU 3.0
	    public void SetFormatByArgumentIndex(int argumentIndex, Format newFormat) {
	        if (!argumentNamesAreNumeric) {
	            throw new ArgumentException(
	                    "This method is not available in MessageFormat objects "
	                            + "that use alphanumeric argument names.");
	        }
	        for (int j = 0; j <= maxOffset; j++) {
	            if (Int32.Parse(argumentNames[j]) == argumentIndex) {
	                formats[j] = newFormat;
	            }
	        }
	    }
	
	    /// <summary>
	    /// Sets the format to use for the format elements within the previously set
	    /// pattern string that use the given argument name.
	    /// <p>
	    /// If the argument name is used for more than one format element in the
	    /// pattern string, then the new format is used for all such format elements.
	    /// If the argument name is not used for any format element in the pattern
	    /// string, then the new format is ignored.
	    /// <p>
	    /// This API may be used on formats that do not use named arguments. In this
	    /// case <c>argumentName</c> should be a String that names an argument
	    /// index, e.g. "0", "1", "2"... etc. If it does not name a valid index, the
	    /// format will be ignored. No error is thrown.
	    /// </summary>
	    ///
	    /// <param name="argumentName">the name of the argument to change</param>
	    /// <param name="newFormat">the new format to use</param>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public void SetFormatByArgumentName(String argumentName, Format newFormat) {
	        for (int i = 0; i < maxOffset; ++i) {
	            if (argumentName.Equals(argumentNames[i])) {
	                formats[i] = newFormat;
	            }
	        }
	    }
	
	    /// <summary>
	    /// Sets the format to use for the format element with the given format
	    /// element index within the previously set pattern string. The format
	    /// element index is the zero-based number of the format element counting
	    /// from the start of the pattern string.
	    /// <p>
	    /// Since the order of format elements in a pattern string often changes
	    /// during localization, it is generally better to use the<see cref="M:IBM.ICU.Text.MessageFormat.SetFormatByArgumentIndex setFormatByArgumentIndex"/> method, which
	    /// accesses format elements based on the argument index they specify.
	    /// </summary>
	    ///
	    /// <param name="formatElementIndex">the index of a format element within the pattern</param>
	    /// <param name="newFormat">the format to use for the specified format element</param>
	    /// <exception cref="ArrayIndexOutOfBoundsException">if formatElementIndex is equal to or larger than thenumber of format elements in the pattern string</exception>
	    /// @stable ICU 3.0
	    public void SetFormat(int formatElementIndex, Format newFormat) {
	        formats[formatElementIndex] = newFormat;
	    }
	
	    /// <summary>
	    /// Gets the formats used for the values passed into <c>format</c>
	    /// methods or returned from <c>parse</c> methods. The indices of
	    /// elements in the returned array correspond to the argument indices used in
	    /// the previously set pattern string. The order of formats in the returned
	    /// array thus corresponds to the order of elements in the
	    /// <c>arguments</c> array passed to the <c>format</c> methods or
	    /// the result array returned by the <c>parse</c> methods.
	    /// <p>
	    /// If an argument index is used for more than one format element in the
	    /// pattern string, then the format used for the last such format element is
	    /// returned in the array. If an argument index is not used for any format
	    /// element in the pattern string, then null is returned in the array.
	    /// This method is only supported when exclusively numbers are used for
	    /// argument names. Otherwise an IllegalArgumentException is thrown.
	    /// </summary>
	    ///
	    /// <returns>the formats used for the arguments within the pattern</returns>
	    /// <exception cref="IllegalArgumentException">if this format uses named arguments</exception>
	    /// @stable ICU 3.0
	    public Format[] GetFormatsByArgumentIndex() {
	        if (!argumentNamesAreNumeric) {
	            throw new ArgumentException(
	                    "This method is not available in MessageFormat objects "
	                            + "that use alphanumeric argument names.");
	        }
	        int maximumArgumentNumber = -1;
	        for (int i = 0; i <= maxOffset; i++) {
	            int argumentNumber = Int32.Parse(argumentNames[i]);
	            if (argumentNumber > maximumArgumentNumber) {
	                maximumArgumentNumber = argumentNumber;
	            }
	        }
	        Format[] resultArray = new Format[maximumArgumentNumber + 1];
	        for (int i_0 = 0; i_0 <= maxOffset; i_0++) {
	            resultArray[Int32.Parse(argumentNames[i_0])] = formats[i_0];
	        }
	        return resultArray;
	    }
	
	    // TODO: provide method public Map getFormatsByArgumentName().
	    // Where Map is: String argumentName --> Format format.
	
	    /// <summary>
	    /// Gets the formats used for the format elements in the previously set
	    /// pattern string. The order of formats in the returned array corresponds to
	    /// the order of format elements in the pattern string.
	    /// <p>
	    /// Since the order of format elements in a pattern string often changes
	    /// during localization, it's generally better to use the<see cref="M:IBM.ICU.Text.MessageFormat.GetFormatsByArgumentIndex"/> method, which assumes an order of
	    /// formats corresponding to the order of elements in the
	    /// <c>arguments</c> array passed to the <c>format</c> methods or
	    /// the result array returned by the <c>parse</c> methods.
	    /// This method is only supported when exclusively numbers are used for
	    /// argument names. Otherwise an IllegalArgumentException is thrown.
	    /// </summary>
	    ///
	    /// <returns>the formats used for the format elements in the pattern</returns>
	    /// @stable ICU 3.0
	    public Format[] GetFormats() {
            Format[] resultArray = new Format[maxOffset + 1];
	        System.Array.Copy((Array)(formats),0,(Array)(resultArray),0,maxOffset + 1);
	        return resultArray;
	    }
	
	    /// <summary>
	    /// Formats an array of objects and appends the <c>MessageFormat</c>'s
	    /// pattern, with format elements replaced by the formatted objects, to the
	    /// provided <c>StringBuffer</c>.
	    /// <p>
	    /// The text substituted for the individual format elements is derived from
	    /// the current subformat of the format element and the
	    /// <c>arguments</c> element at the format element's argument index as
	    /// indicated by the first matching line of the following table. An argument
	    /// is <i>unavailable</i> if <c>arguments</c> is <c>null</c> or
	    /// has fewer than argumentIndex+1 elements. When an argument is unavailable
	    /// no substitution is performed.
	    /// <p>
	    /// <table border=1>
	    /// <tr>
	    /// <th>Subformat
	    /// <th>Argument
	    /// <th>Formatted Text
	    /// <tr>
	    /// <td><i>any</i>
	    /// <td><i>unavailable</i>
	    /// <td><c>"{" + argumentIndex + "}"</c>
	    /// <tr>
	    /// <td><i>any</i>
	    /// <td><c>null</c>
	    /// <td><c>"null"</c>
	    /// <tr>
	    /// <td><c>instanceof ChoiceFormat</c>
	    /// <td><i>any</i>
	    /// <td><code>subformat.format(argument).indexOf('{') >= 0 ?<br>
	    /// (new MessageFormat(subformat.format(argument), getLocale())).format(argument) :
	    /// subformat.format(argument)</code>
	    /// <tr>
	    /// <td><c>!= null</c>
	    /// <td><i>any</i>
	    /// <td><c>subformat.format(argument)</c>
	    /// <tr>
	    /// <td><c>null</c>
	    /// <td><c>instanceof Number</c>
	    /// <td><c>NumberFormat.getInstance(getLocale()).format(argument)</c>
	    /// <tr>
	    /// <td><c>null</c>
	    /// <td><c>instanceof Date</c>
	    /// <td>
	    /// <c>DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT, getLocale()).format(argument)</c>
	    /// <tr>
	    /// <td><c>null</c>
	    /// <td><c>instanceof String</c>
	    /// <td><c>argument</c>
	    /// <tr>
	    /// <td><c>null</c>
	    /// <td><i>any</i>
	    /// <td><c>argument.toString()</c>
	    /// </table>
	    /// <p>
	    /// If <c>pos</c> is non-null, and refers to
	    /// <c>Field.ARGUMENT</c>, the location of the first formatted string
	    /// will be returned.
	    /// This method is only supported when the format does not use named
	    /// arguments, otherwise an IllegalArgumentException is thrown.
	    /// </summary>
	    ///
	    /// <param name="arguments">an array of objects to be formatted and substituted.</param>
	    /// <param name="result">where text is appended.</param>
	    /// <param name="pos">On input: an alignment field, if desired. On output: theoffsets of the alignment field.</param>
	    /// <exception cref="IllegalArgumentException">if an argument in the <c>arguments</c> array is not ofthe type expected by the format element(s) that use it.</exception>
	    /// <exception cref="IllegalArgumentException">if this format uses named arguments</exception>
	    /// @stable ICU 3.0
	    public StringBuilder Format(Object[] arguments, StringBuilder result,
	            FieldPosition pos) {
	        if (!argumentNamesAreNumeric) {
	            throw new ArgumentException(
	                    "This method is not available in MessageFormat objects "
	                            + "that use alphanumeric argument names.");
	        }
	        return Subformat(arguments, result, pos, null);
	    }
	
	    /// <summary>
	    /// Formats a map of objects and appends the <c>MessageFormat</c>'s
	    /// pattern, with format elements replaced by the formatted objects, to the
	    /// provided <c>StringBuffer</c>.
	    /// <p>
	    /// The text substituted for the individual format elements is derived from
	    /// the current subformat of the format element and the
	    /// <c>arguments</c> value corresopnding to the format element's
	    /// argument name.
	    /// <p>
	    /// This API may be called on formats that do not use named arguments. In
	    /// this case the the keys in <c>arguments</c> must be numeric strings
	    /// (e.g. "0", "1", "2"...).
	    /// <p>
	    /// An argument is <i>unavailable</i> if <c>arguments</c> is
	    /// <c>null</c> or does not have a value corresponding to an argument
	    /// name in the pattern. When an argument is unavailable no substitution is
	    /// performed.
	    /// </summary>
	    ///
	    /// <param name="arguments">a map of objects to be formatted and substituted.</param>
	    /// <param name="result">where text is appended.</param>
	    /// <param name="pos">On input: an alignment field, if desired. On output: theoffsets of the alignment field.</param>
	    /// <exception cref="IllegalArgumentException">if an argument in the <c>arguments</c> array is not ofthe type expected by the format element(s) that use it.</exception>
	    /// <returns>the passed-in StringBuffer</returns>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public StringBuilder Format(IDictionary arguments, StringBuilder result,
	            FieldPosition pos) {
	        return Subformat(arguments, result, pos, null);
	    }
	
	    /// <summary>
	    /// Creates a MessageFormat with the given pattern and uses it to format the
	    /// given arguments. This is equivalent to <blockquote>
	    /// <code>(new <see cref="M:IBM.ICU.Text.MessageFormat.MessageFormat(null)"/>(pattern)).<see cref="M:IBM.ICU.Text.MessageFormat.Format(null, System.Text.StringBuilder, null)"/>(arguments, new StringBuffer(), null).toString()</code>
	    /// </blockquote>
	    /// </summary>
	    ///
	    /// <exception cref="IllegalArgumentException">if the pattern is invalid, or if an argument in the<c>arguments</c> array is not of the type expected bythe format element(s) that use it.</exception>
	    /// <exception cref="IllegalArgumentException">if this format uses named arguments</exception>
	    /// @stable ICU 3.0
	    public static String Format(String pattern, Object[] arguments) {
	        MessageFormat temp = new MessageFormat(pattern);
	        return temp.FormatObject(arguments);
	    }
	
	    /// <summary>
	    /// Creates a MessageFormat with the given pattern and uses it to format the
	    /// given arguments. The pattern must identifyarguments by name instead of by
	    /// number.
	    /// <p>
	    /// </summary>
	    ///
	    /// <exception cref="IllegalArgumentException">if the pattern is invalid, or if an argument in the<c>arguments</c> map is not of the type expected by theformat element(s) that use it.</exception>
	    /// <seealso cref="M:IBM.ICU.Text.MessageFormat.Format(null, System.Text.StringBuilder, null)"/>
	    /// <seealso cref="M:IBM.ICU.Text.MessageFormat.Format(System.String, null)"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public static String Format(String pattern, IDictionary arguments) {
	        MessageFormat temp = new MessageFormat(pattern);
	        return temp.FormatObject(arguments);
	    }
	
	    /// <summary>
	    /// Returns true if this MessageFormat uses named arguments, and false
	    /// otherwise. See class description.
	    /// </summary>
	    ///
	    /// <returns>true if named arguments are used.</returns>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public bool UsesNamedArguments() {
	        return !argumentNamesAreNumeric;
	    }
	
	    // Overrides
	    /// <summary>
	    /// Formats a map or array of objects and appends the
	    /// <c>MessageFormat</c>'s pattern, with format elements replaced by
	    /// the formatted objects, to the provided <c>StringBuffer</c>. This is
	    /// equivalent to either of <blockquote>
	    /// <code><see cref="M:IBM.ICU.Text.MessageFormat.Format(null, System.Text.StringBuilder, null)"/>((Object[]) arguments, result, pos)</code>
	    /// <code><see cref="M:IBM.ICU.Text.MessageFormat.Format(System.Collections.IDictionary, System.Text.StringBuilder, null)"/>((Map) arguments, result, pos)</code>
	    /// </blockquote> A map must be provided if this format uses named arguments,
	    /// otherwise an IllegalArgumentException will be thrown.
	    /// </summary>
	    ///
	    /// <param name="arguments">a map or array of objects to be formatted</param>
	    /// <param name="result">where text is appended</param>
	    /// <param name="pos">On input: an alignment field, if desired On output: theoffsets of the alignment field</param>
	    /// <exception cref="IllegalArgumentException">if an argument in <c>arguments</c> is not of the typeexpected by the format element(s) that use it</exception>
	    /// <exception cref="IllegalArgumentException">if <code>arguments<code> isan array of Object and this format uses named arguments</exception>
	    /// @stable ICU 3.0
	    public sealed override StringBuilder FormatObject(Object arguments, StringBuilder result,
	            FieldPosition pos) {
	        if ((arguments == null || arguments  is  IDictionary)) {
	            return Subformat((IDictionary) arguments, result, pos, null);
	        } else {
	            if (!argumentNamesAreNumeric) {
	                throw new ArgumentException(
	                        "This method is not available in MessageFormat objects "
	                                + "that use alphanumeric argument names.");
	            }
	            return Subformat((Object[]) arguments, result, pos, null);
	        }
	    }
	
	    // #if defined(FOUNDATION10) || defined(J2SE13)
	    // #else
	    /// <summary>
	    /// Formats an array of objects and inserts them into the
	    /// <c>MessageFormat</c>'s pattern, producing an
	    /// <c>AttributedCharacterIterator</c>. You can use the returned
	    /// <c>AttributedCharacterIterator</c> to build the resulting String,
	    /// as well as to determine information about the resulting String.
	    /// <p>
	    /// The text of the returned <c>AttributedCharacterIterator</c> is the
	    /// same that would be returned by <blockquote>
	    /// <code><see cref="M:IBM.ICU.Text.MessageFormat.Format(null, System.Text.StringBuilder, null)"/>(arguments, new StringBuffer(), null).toString()</code>
	    /// </blockquote>
	    /// <p>
	    /// In addition, the <c>AttributedCharacterIterator</c> contains at
	    /// least attributes indicating where text was generated from an argument in
	    /// the <c>arguments</c> array. The keys of these attributes are of
	    /// type <c>MessageFormat.Field</c>, their values are
	    /// <c>Integer</c> objects indicating the index in the
	    /// <c>arguments</c> array of the argument from which the text was
	    /// generated.
	    /// <p>
	    /// The attributes/value from the underlying <c>Format</c> instances
	    /// that <c>MessageFormat</c> uses will also be placed in the resulting
	    /// <c>AttributedCharacterIterator</c>. This allows you to not only
	    /// find where an argument is placed in the resulting String, but also which
	    /// fields it contains in turn.
	    /// </summary>
	    ///
	    /// <param name="arguments">an array of objects to be formatted and substituted.</param>
	    /// <returns>AttributedCharacterIterator describing the formatted value.</returns>
	    /// <exception cref="NullPointerException">if <c>arguments</c> is null.</exception>
	    /// <exception cref="IllegalArgumentException">if an argument in the <c>arguments</c> array is notof the type expected by the format element(s) that use it.</exception>
	    /// @stable ICU 3.8
	    public override AttributedCharacterIterator FormatToCharacterIterator(
	            Object arguments) {
	        StringBuilder result = new StringBuilder();
	        ArrayList iterators = new ArrayList();
	
	        if (arguments == null) {
	            throw new NullReferenceException(
	                    "formatToCharacterIterator must be passed non-null object");
	        }
	        if (arguments  is  IDictionary) {
	            Subformat((IDictionary) arguments, result, null, iterators);
	        } else {
	            Subformat((Object[]) arguments, result, null, iterators);
	        }
	        if (iterators.Count == 0) {
	            return _createAttributedCharacterIterator("");
	        }
	        return _createAttributedCharacterIterator((AttributedCharacterIterator[]) ILOG.J2CsMapping.Collections.Generics.Collections.ToArray(iterators,new AttributedCharacterIterator[iterators.Count]));
	    }
	
	    // #endif
	
	    /// <summary>
	    /// Parses the string.
	    /// <p>
	    /// Caveats: The parse may fail in a number of circumstances. For example:
	    /// <ul>
	    /// <li>If one of the arguments does not occur in the pattern.
	    /// <li>If the format of an argument loses information, such as with a choice
	    /// format where a large number formats to "many".
	    /// <li>Does not yet handle recursion (where the substituted strings contain
	    /// {n} references.)
	    /// <li>Will not always find a match (or the correct match) if some part of
	    /// the parse is ambiguous. For example, if the pattern "{1},{2}" is used
	    /// with the string arguments {"a,b", "c"}, it will format as "a,b,c". When
	    /// the result is parsed, it will return {"a", "b,c"}.
	    /// <li>If a single argument is parsed more than once in the string, then the
	    /// later parse wins.
	    /// </ul>
	    /// When the parse fails, use ParsePosition.getErrorIndex() to find out where
	    /// in the string did the parsing failed. The returned error index is the
	    /// starting offset of the sub-patterns that the string is comparing with.
	    /// For example, if the parsing string "AAA {0} BBB" is comparing against the
	    /// pattern "AAD {0} BBB", the error index is 0. When an error occurs, the
	    /// call to this method will return null. If the source is null, return an
	    /// empty array.
	    /// <p>
	    /// This method is only supported with numbered arguments. If the format
	    /// pattern used named argument an IllegalArgumentException is thrown.
	    /// </summary>
	    ///
	    /// <exception cref="IllegalArgumentException">if this format uses named arguments</exception>
	    /// @stable ICU 3.0
	    public Object[] Parse(String source, ParsePosition pos) {
	        if (!argumentNamesAreNumeric) {
	            throw new ArgumentException(
	                    "This method is not available in MessageFormat objects "
	                            + "that use named argument.");
	        }
	        IDictionary objectMap = ParseToMap(source, pos);
	        int maximumArgumentNumber = -1;
	        for (int i = 0; i <= maxOffset; i++) {
	            int argumentNumber = Int32.Parse(argumentNames[i]);
	            if (argumentNumber > maximumArgumentNumber) {
	                maximumArgumentNumber = argumentNumber;
	            }
	        }
	
	        if (objectMap == null) {
	            return null;
	        }
	
	        Object[] resultArray = new Object[maximumArgumentNumber + 1];
	        IIterator keyIter = new ILOG.J2CsMapping.Collections.IteratorAdapter(new ILOG.J2CsMapping.Collections.ListSet(objectMap.Keys).GetEnumerator());
	        while (keyIter.HasNext()) {
	            String key = (String) keyIter.Next();
	            resultArray[Int32.Parse(key)] = ILOG.J2CsMapping.Collections.Collections.Get(objectMap,key);
	        }
	
	        return resultArray;
	    }
	
	    /// <summary>
	    /// Parses the string, returning the results in a Map. This is similar to the
	    /// version that returns an array of Object. This supports both named and
	    /// numbered arguments-- if numbered, the keys in the map are the
	    /// corresponding Strings (e.g. "0", "1", "2"...).
	    /// </summary>
	    ///
	    /// <param name="source">the text to parse</param>
	    /// <param name="pos">the position at which to start parsing. on return, containsthe result of the parse.</param>
	    /// <returns>a Map containing key/value pairs for each parsed argument.</returns>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public IDictionary ParseToMap(String source, ParsePosition pos) {
	        if (source == null) {
	            IDictionary empty = new Hashtable();
	            return empty;
	        }
	
	        // int maximumArgumentNumber = -1;
	        // for (int i = 0; i <= maxOffset; i++) {
	        // int argumentNumber = Integer.parseInt(argumentNames[i]);
	        // if (argumentNumber > maximumArgumentNumber) {
	        // maximumArgumentNumber = argumentNumber;
	        // }
	        // }
	        // Object[] resultArray = new Object[maximumArgumentNumber + 1];
	
	        IDictionary resultMap = new Hashtable();
	
	        int patternOffset = 0;
	        int sourceOffset = pos.GetIndex();
	        ParsePosition tempStatus = new ParsePosition(0);
	        for (int i = 0; i <= maxOffset; ++i) {
	            // match up to format
	            int len = offsets[i] - patternOffset;
	            if (len == 0
	                    || StringUtil.RegionMatches(pattern, patternOffset, source,
	                            sourceOffset, len)) {
	                sourceOffset += len;
	                patternOffset += len;
	            } else {
	                pos.SetErrorIndex(sourceOffset);
	                return null; // leave index as is to signal error
	            }
	
	            // now use format
	            if (formats[i] == null) { // string format
	                // if at end, use longest possible match
	                // otherwise uses first match to intervening string
	                // does NOT recursively try all possibilities
	                int tempLength = (i != maxOffset) ? offsets[i + 1] : pattern.Length;
	
	                int next;
	                if (patternOffset >= tempLength) {
	                    next = source.Length;
	                } else {
	                    next = ILOG.J2CsMapping.Util.StringUtil.IndexOf(source,pattern.Substring(patternOffset,(tempLength)-(patternOffset)),sourceOffset);
	                }
	
	                if (next < 0) {
	                    pos.SetErrorIndex(sourceOffset);
	                    return null; // leave index as is to signal error
	                } else {
	                    String strValue = source.Substring(sourceOffset,(next)-(sourceOffset));
	                    if (!strValue.Equals("{" + argumentNames[i] + "}"))
	                        ILOG.J2CsMapping.Collections.Collections.Put(resultMap,argumentNames[i],source.Substring(sourceOffset,(next)-(sourceOffset)));
	                    // resultArray[Integer.parseInt(argumentNames[i])] =
	                    // source.substring(sourceOffset, next);
	                    sourceOffset = next;
	                }
	            } else {
	                tempStatus.SetIndex(sourceOffset);
	                ILOG.J2CsMapping.Collections.Collections.Put(resultMap,argumentNames[i],formats[i].ParseObject(source, tempStatus));
	                // resultArray[Integer.parseInt(argumentNames[i])] =
	                // formats[i].parseObject(source, tempStatus);
	                if (tempStatus.GetIndex() == sourceOffset) {
	                    pos.SetErrorIndex(sourceOffset);
	                    return null; // leave index as is to signal error
	                }
	                sourceOffset = tempStatus.GetIndex(); // update
	            }
	        }
	        int len_0 = pattern.Length - patternOffset;
	        if (len_0 == 0
	                || StringUtil.RegionMatches(pattern, patternOffset, source, sourceOffset,
	                        len_0)) {
	            pos.SetIndex(sourceOffset + len_0);
	        } else {
	            pos.SetErrorIndex(sourceOffset);
	            return null; // leave index as is to signal error
	        }
	        return resultMap;
	    }
	
	    /// <summary>
	    /// Parses text from the beginning of the given string to produce an object
	    /// array. The method may not use the entire text of the given string.
	    /// <p>
	    /// See the <see cref="M:IBM.ICU.Text.MessageFormat.Parse(System.String, null)"/> method for more information
	    /// on message parsing.
	    /// </summary>
	    ///
	    /// <param name="source">A <c>String</c> whose beginning should be parsed.</param>
	    /// <returns>An <c>Object</c> array parsed from the string.</returns>
	    /// <exception cref="ParseException">if the beginning of the specified string cannot be parsed.</exception>
	    /// <exception cref="IllegalArgumentException">if this format uses named arguments</exception>
	    /// @stable ICU 3.0
	    public Object[] Parse(String source) {
	        ParsePosition pos = new ParsePosition(0);
	        Object[] result = Parse(source, pos);
	        if (pos.GetIndex() == 0) // unchanged, returned object is null
	            throw new ILOG.J2CsMapping.Util.ParseException("MessageFormat parse error!"+pos.GetErrorIndex());
	
	        return result;
	    }
	
	    /// <summary>
	    /// Parses text from the beginning of the given string to produce a map from
	    /// argument to values. The method may not use the entire text of the given
	    /// string.
	    /// <p>
	    /// See the <see cref="M:IBM.ICU.Text.MessageFormat.Parse(System.String, null)"/> method for more information
	    /// on message parsing.
	    /// </summary>
	    ///
	    /// <param name="source">A <c>String</c> whose beginning should be parsed.</param>
	    /// <returns>A <c>Map</c> parsed from the string.</returns>
	    /// <exception cref="ParseException">if the beginning of the specified string cannot be parsed.</exception>
	    /// <seealso cref="M:IBM.ICU.Text.MessageFormat.ParseToMap(System.String, null)"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public IDictionary ParseToMap(String source) {
	
	        ParsePosition pos = new ParsePosition(0);
	        IDictionary result = ParseToMap(source, pos);
	        if (pos.GetIndex() == 0) // unchanged, returned object is null
	            throw new ILOG.J2CsMapping.Util.ParseException("MessageFormat parse error!"+pos.GetErrorIndex());
	
	        return result;
	    }
	
	    /// <summary>
	    /// Parses text from a string to produce an object array or Map.
	    /// <p>
	    /// The method attempts to parse text starting at the index given by
	    /// <c>pos</c>. If parsing succeeds, then the index of <c>pos</c>
	    /// is updated to the index after the last character used (parsing does not
	    /// necessarily use all characters up to the end of the string), and the
	    /// parsed object array is returned. The updated <c>pos</c> can be used
	    /// to indicate the starting point for the next call to this method. If an
	    /// error occurs, then the index of <c>pos</c> is not changed, the
	    /// error index of <c>pos</c> is set to the index of the character
	    /// where the error occurred, and null is returned.
	    /// <p>
	    /// See the <see cref="M:IBM.ICU.Text.MessageFormat.Parse(System.String, null)"/> method for more information
	    /// on message parsing.
	    /// </summary>
	    ///
	    /// <param name="source">A <c>String</c>, part of which should be parsed.</param>
	    /// <param name="pos">A <c>ParsePosition</c> object with index and error indexinformation as described above.</param>
	    /// <returns>An <c>Object</c> parsed from the string, either an array of
	    /// Object, or a Map, depending on whether named arguments are used.
	    /// This can be queried using <c>usesNamedArguments</c>. In
	    /// case of error, returns null.</returns>
	    /// <exception cref="NullPointerException">if <c>pos</c> is null.</exception>
	    /// @stable ICU 3.0
	    public override Object ParseObject(String source, ParsePosition pos) {
	        if (argumentNamesAreNumeric) {
	            return Parse(source, pos);
	        } else {
	            return ParseToMap(source, pos);
	        }
	    }
	
	    /// <summary>
	    /// Creates and returns a copy of this object.
	    /// </summary>
	    ///
	    /// <returns>a clone of this instance.</returns>
	    /// @stable ICU 3.0
	    public override Object Clone() {
	        MessageFormat other = (MessageFormat) base.Clone();
	
	        // clone arrays. Can't do with utility because of bug in Cloneable
	        other.formats = (Format[]) formats.Clone(); // shallow clone
	        for (int i = 0; i < formats.Length; ++i) {
	            if (formats[i] != null)
	                other.formats[i] = (Format) formats[i].Clone();
	        }
	        // for primitives or immutables, shallow clone is enough
	        other.offsets = (int[]) offsets.Clone();
	        other.argumentNames = (String[]) argumentNames.Clone();
	        other.argumentNamesAreNumeric = argumentNamesAreNumeric;
	
	        return other;
	    }
	
	    /// <summary>
	    /// Equality comparison between two message format objects
	    /// </summary>
	    ///
	    /// @stable ICU 3.0
	    public override bool Equals(Object obj) {
	        if ((Object) this == obj) // quick check
	            return true;
	        if (obj == null || (Object) GetType() != (Object) obj.GetType())
	            return false;
	        MessageFormat other = (MessageFormat) obj;
	        return (maxOffset == other.maxOffset
	                && pattern.Equals(other.pattern)
	                && IBM.ICU.Impl.Utility.ObjectEquals(ulocale, other.ulocale) // does null
	                                                                // check
	                && IBM.ICU.Impl.Utility.ArrayEquals(offsets, other.offsets)
	                && IBM.ICU.Impl.Utility.ArrayEquals(argumentNames, other.argumentNames)
	                && IBM.ICU.Impl.Utility.ArrayEquals(formats, other.formats) && (argumentNamesAreNumeric == other.argumentNamesAreNumeric));
	    }
	
	    /// <summary>
	    /// Generates a hash code for the message format object.
	    /// </summary>
	    ///
	    /// @stable ICU 3.0
	    public override int GetHashCode() {
	        return pattern.GetHashCode(); // enough for reasonable distribution
	    }
	
	    // #if defined(FOUNDATION10) || defined(J2SE13)
	    // #else
	    /// <summary>
	    /// Defines constants that are used as attribute keys in the
	    /// <c>AttributedCharacterIterator</c> returned from
	    /// <c>MessageFormat.formatToCharacterIterator</c>.
	    /// </summary>
	    ///
	    /// @stable ICU 3.8
	    [Serializable]
	    public class Field : Format.Field {
	
	        private const long serialVersionUID = 7510380454602616157L;
	
	        /// <summary>
	        /// Create a <c>Field</c> with the specified name.
	        /// </summary>
	        ///
	        /// <param name="name">The name of the attribute</param>
	        /// @stable ICU 3.8
	        protected internal Field(String name) : base(name) {
	        }
	
	        /// <summary>
	        /// Resolves instances being deserialized to the predefined constants.
	        /// </summary>
	        ///
	        /// <returns>resolved MessageFormat.Field constant</returns>
	        /// <exception cref="InvalidObjectException">if the constant could not be resolved.</exception>
	        /// @stable ICU 3.8
	        protected internal override Object ReadResolve() {
	            if ((Object) this.GetType() != (Object) typeof(MessageFormat.Field)) {
	                throw new IOException(
	                        "A subclass of MessageFormat.Field must implement readResolve.");
	            }
	            if (this.GetName().Equals(ARGUMENT.GetName())) {
	                return ARGUMENT;
	            } else {
	                throw new IOException("Unknown attribute name.");
	            }
	        }
	
	        /// <summary>
	        /// Constant identifying a portion of a message that was generated from
	        /// an argument passed into <c>formatToCharacterIterator</c>. The
	        /// value associated with the key will be an <c>Integer</c>
	        /// indicating the index in the <c>arguments</c> array of the
	        /// argument from which the text was generated.
	        /// </summary>
	        ///
	        /// @stable ICU 3.8
	        public static readonly MessageFormat.Field  ARGUMENT = new MessageFormat.Field ("message argument field");
	
	    }
	
	    // #endif
	
	    // ===========================privates============================
	
	    /// <summary>
	    /// The locale to use for formatting numbers and dates. This is no longer
	    /// used, and here only for serialization compatibility.
	    /// </summary>
	    ///
	    /// @serial
        private Locale locale;
	
	    /// <summary>
	    /// The locale to use for formatting numbers and dates.
	    /// </summary>
	    ///
	    /// @serial
	    private ULocale ulocale;
	
	    /// <summary>
	    /// The string that the formatted values are to be plugged into. In other
	    /// words, this is the pattern supplied on construction with all of the {}
	    /// expressions taken out.
	    /// </summary>
	    ///
	    /// @serial
	    private String pattern;
	
	    /// <summary>
	    /// The initially expected number of subformats in the format 
	    /// </summary>
	    ///
	    private const int INITIAL_FORMATS = 10;
	
	    /// <summary>
	    /// An array of formatters, which are used to format the arguments.
	    /// </summary>
	    ///
	    /// @serial
	    private Format[] formats;
	
	    /// <summary>
	    /// The positions where the results of formatting each argument are to be
	    /// inserted into the pattern.
	    /// </summary>
	    ///
	    /// @serial
	    private int[] offsets;
	
	    /// <summary>
	    /// The argument numbers corresponding to each formatter. (The formatters are
	    /// stored in the order they occur in the pattern, not in the order in which
	    /// the arguments are specified.)
	    /// </summary>
	    ///
	    /// @serial
	    // retained for backwards compatibility
	    private int[] argumentNumbers;
	
	    /// <summary>
	    /// The argument names corresponding to each formatter. (The formatters are
	    /// stored in the order they occur in the pattern, not in the order in which
	    /// the arguments are specified.)
	    /// </summary>
	    ///
	    /// @serial
	    private String[] argumentNames;
	
	    /// <summary>
	    /// Is true iff all argument names are non-negative numbers.
	    /// </summary>
	    ///
	    /// @serial
	    private bool argumentNamesAreNumeric;
	
	    /// <summary>
	    /// One less than the number of entries in <c>offsets</c>. Can also be
	    /// thought of as the index of the highest-numbered element in
	    /// <c>offsets</c> that is being used. All of these arrays should have
	    /// the same number of elements being used as <c>offsets</c> does, and
	    /// so this variable suffices to tell us how many entries are in all of them.
	    /// </summary>
	    ///
	    /// @serial
	    private int maxOffset;
	
	    /// <summary>
	    /// Internal routine used by format. If <c>characterIterators</c> is
	    /// non-null, AttributedCharacterIterator will be created from the subformats
	    /// as necessary. If <c>characterIterators</c> is null and
	    /// <c>fp</c> is non-null and identifies
	    /// <c>Field.MESSAGE_ARGUMENT</c>, the location of the first replaced
	    /// argument will be set in it.
	    /// </summary>
	    ///
	    /// <exception cref="IllegalArgumentException">if an argument in the <c>arguments</c> array is notof the type expected by the format element(s) that use it.</exception>
	    private StringBuilder Subformat(Object[] arguments, StringBuilder result,
	            FieldPosition fp, IList characterIterators) {
	        return Subformat(ArrayToMap(arguments), result, fp, characterIterators);
	    }
	
	    /// <summary>
	    /// Internal routine used by format.
	    /// </summary>
	    ///
	    /// <exception cref="IllegalArgumentException">if an argument in the <c>arguments</c> map is not ofthe type expected by the format element(s) that use it.</exception>
	    private StringBuilder Subformat(IDictionary arguments, StringBuilder result,
	            FieldPosition fp, IList characterIterators) {
	        // note: this implementation assumes a fast substring & index.
	        // if this is not true, would be better to append chars one by one.
	        int lastOffset = 0;
	        int last = result.Length;
	        for (int i = 0; i <= maxOffset; ++i) {
	            result.Append(pattern.Substring(lastOffset,(offsets[i])-(lastOffset)));
	            lastOffset = offsets[i];
	            String argumentName = argumentNames[i];
	            if (arguments == null || ILOG.J2CsMapping.Collections.Collections.Get(arguments,argumentName) == null) {
	                result.Append("{" + argumentName + "}");
	                continue;
	            }
	            // int argRecursion = ((recursionProtection >> (argumentNumber*2)) &
	            // 0x3);
	            if (false) { // if (argRecursion == 3){
	                // prevent loop!!!
	                result.Append('\uFFFD');
	            } else {
	                Object obj = ILOG.J2CsMapping.Collections.Collections.Get(arguments,argumentName);
	                String arg = null;
	                Format subFormatter = null;
	                if (obj == null) {
	                    arg = "null";
	                } else if (formats[i] != null) {
	                    subFormatter = formats[i];
	                    if (subFormatter  is  ChoiceFormat
	                            || subFormatter  is  PluralFormat) {
	                        arg = formats[i].FormatObject(obj);
	                        // TODO: This should be made more robust.
	                        // Does this work with '{' in quotes?
	                        if (arg.IndexOf('{') >= 0) {
	                            subFormatter = new MessageFormat(arg, ulocale);
	                            obj = arguments;
	                            arg = null;
	                        }
	                    }
                    }
                    else if (obj is DateTime)
                    {
                        // format a Date if can
                        subFormatter = IBM.ICU.Text.DateFormat.GetDateTimeInstance(
                                IBM.ICU.Text.DateFormat.SHORT, IBM.ICU.Text.DateFormat.SHORT, ulocale);// fix
	                } else if (obj  is  ValueType) {
	                    // format number if can
	                    subFormatter = IBM.ICU.Text.NumberFormat.GetInstance(ulocale);	               
	                } else if (obj  is  String) {
	                    arg = (String) obj;
	
	                } else {
	                    arg = obj.ToString();
	                    if (arg == null)
	                        arg = "null";
	                }
	
	                // At this point we are in two states, either subFormatter
	                // is non-null indicating we should format obj using it,
	                // or arg is non-null and we should use it as the value.
	
	                // #if defined(FOUNDATION10) || defined(J2SE13)
	                // ## if (subFormatter != null) {
	                // ## arg = subFormatter.format(obj);
	                // ## }
	                // ## result.append(arg);
	                // #else
	                if (characterIterators != null) {
	                    // If characterIterators is non-null, it indicates we need
	                    // to get the CharacterIterator from the child formatter.
	                    if (last != result.Length) {
	                        ILOG.J2CsMapping.Collections.Generics.Collections.Add(characterIterators,_createAttributedCharacterIterator(result.ToString(last,result.Length-last)));
	                        last = result.Length;
	                    }
	                    if (subFormatter != null) {
	                        AttributedCharacterIterator subIterator = subFormatter
	                                .FormatToCharacterIterator(obj);
	
	                        Append(result, subIterator);
	                        if (last != result.Length) {
	                            ILOG.J2CsMapping.Collections.Generics.Collections.Add(characterIterators,_createAttributedCharacterIterator(
	                                                                        subIterator,
	                                                                        IBM.ICU.Text.MessageFormat.Field.ARGUMENT,
	                                                                        (argumentNamesAreNumeric) ? (Object) ((Int32)Int32.Parse(argumentName))
	                                                                                : (Object) argumentName));
	                            last = result.Length;
	                        }
	                        arg = null;
	                    }
	                    if (arg != null && arg.Length > 0) {
	                        result.Append(arg);
	                        ILOG.J2CsMapping.Collections.Generics.Collections.Add(characterIterators,_createAttributedCharacterIterator(
	                                                                arg,
	                                                                IBM.ICU.Text.MessageFormat.Field.ARGUMENT,
	                                                                (argumentNamesAreNumeric) ? (Object) ((Int32)Int32.Parse(argumentName))
	                                                                        : (Object) argumentName));
	                        last = result.Length;
	                    }
	                } else {
	                    if (subFormatter != null) {
	                        arg = subFormatter.FormatObject(obj);
	                    }
	                    last = result.Length;
	                    result.Append(arg);
	                    if (i == 0 && fp != null
	                            && IBM.ICU.Text.MessageFormat.Field.ARGUMENT.Equals(fp.GetFieldAttribute())) {
	                        fp.SetBeginIndex(last);
	                        fp.SetEndIndex(result.Length);
	                    }
	                    last = result.Length;
	                }
	                // #endif
	            }
	        }
	        result.Append(pattern.Substring(lastOffset,(pattern.Length)-(lastOffset)));
	        // #if defined(FOUNDATION10) || defined(J2SE13)
	        // #else
	        if (characterIterators != null && last != result.Length) {
	            ILOG.J2CsMapping.Collections.Generics.Collections.Add(characterIterators,_createAttributedCharacterIterator(result.ToString(last,result.Length-last)));
	        }
	        // #endif
	        return result;
	    }
	
	    /// <summary>
	    /// Convenience method to append all the characters in <c>iterator</c>
	    /// to the StringBuffer <c>result</c>.
	    /// </summary>
	    ///
	    private void Append(StringBuilder result, ICharacterIterator iterator) {
	        if (iterator.First() != ILOG.J2CsMapping.Text.CharacterIterator.Done) {
	            char aChar;
	
	            result.Append(iterator.First());
	            while ((aChar = iterator.Next()) != ILOG.J2CsMapping.Text.CharacterIterator.Done) {
	                result.Append(aChar);
	            }
	        }
	    }
	
	    private static readonly String[] typeList = { "", "number", "date", "time",
	            "choice", "spellout", "ordinal", "duration", "plural" };
	
	    private const int TYPE_EMPTY = 0, TYPE_NUMBER = 1, TYPE_DATE = 2,
	            TYPE_TIME = 3, TYPE_CHOICE = 4, TYPE_SPELLOUT = 5,
	            TYPE_ORDINAL = 6, TYPE_DURATION = 7, TYPE_PLURAL = 8;
	
	    private static readonly String[] modifierList = { "", "currency", "percent",
	            "integer" };
	
	    private const int MODIFIER_EMPTY = 0, MODIFIER_CURRENCY = 1,
	            MODIFIER_PERCENT = 2, MODIFIER_INTEGER = 3;
	
	    private static readonly String[] dateModifierList = { "", "short", "medium",
	            "long", "full" };
	
	    private const int DATE_MODIFIER_EMPTY = 0, DATE_MODIFIER_SHORT = 1,
	            DATE_MODIFIER_MEDIUM = 2, DATE_MODIFIER_LONG = 3,
	            DATE_MODIFIER_FULL = 4;
	
	    private void MakeFormat(int position, int offsetNumber,
	            StringBuilder[] segments) {
	        // get the argument number
	        // int argumentNumber;
	        // try {
	        // argumentNumber = Integer.parseInt(segments[1].toString()); // always
	        // unlocalized!
	        // } catch (NumberFormatException e) {
	        // throw new IllegalArgumentException("can't parse argument number "
	        // + segments[1]);
	        // }
	        // if (argumentNumber < 0) {
	        // throw new IllegalArgumentException("negative argument number "
	        // + argumentNumber);
	        // }
	
	        // resize format information arrays if necessary
	        if (offsetNumber >= formats.Length) {
	            int newLength = formats.Length * 2;
	            Format[] newFormats = new Format[newLength];
	            int[] newOffsets = new int[newLength];
	            String[] newArgumentNames = new String[newLength];
	            System.Array.Copy((Array)(formats),0,(Array)(newFormats),0,maxOffset + 1);
	            System.Array.Copy((Array)(offsets),0,(Array)(newOffsets),0,maxOffset + 1);
	            System.Array.Copy((Array)(argumentNames),0,(Array)(newArgumentNames),0,maxOffset + 1);
	            formats = newFormats;
	            offsets = newOffsets;
	            argumentNames = newArgumentNames;
	        }
	        int oldMaxOffset = maxOffset;
	        maxOffset = offsetNumber;
	        offsets[offsetNumber] = segments[0].Length;
	        argumentNames[offsetNumber] = segments[1].ToString();
	        // All argument names numeric ?
	        int argumentNumber;
	        try {
	            // always unlocalized!
	            argumentNumber = Int32.Parse(segments[1].ToString());
	        } catch (FormatException e) {
	            argumentNumber = -1;
	        }
	        if (offsetNumber == 0) {
	            // First argument determines whether all argument identifiers have
	            // to be numbers or (IDStartChars IDContChars*) strings.
	            argumentNamesAreNumeric = argumentNumber >= 0;
	        }
	
	        if (argumentNamesAreNumeric && argumentNumber < 0
	                || !argumentNamesAreNumeric
	                && !IsAlphaIdentifier(argumentNames[offsetNumber])) {
	            throw new ArgumentException(
	                    "All argument identifiers have to be either non-negative "
	                            + "numbers or strings following the pattern "
	                            + "([:ID_Start:] [:ID_Continue:]*).\n"
	                            + "For more details on these unicode sets, visit "
	                            + "http://demo.icu-project.org/icu-bin/ubrowse");
	        }
	
	        // now get the format
	        Format newFormat = null;
	        switch (FindKeyword(segments[2].ToString(), typeList)) {
	        case TYPE_EMPTY:
	            break;
	        case TYPE_NUMBER:
	            switch (FindKeyword(segments[3].ToString(), modifierList)) {
	            case MODIFIER_EMPTY:
	                newFormat = IBM.ICU.Text.NumberFormat.GetInstance(ulocale);
	                break;
	            case MODIFIER_CURRENCY:
	                newFormat = IBM.ICU.Text.NumberFormat.GetCurrencyInstance(ulocale);
	                break;
	            case MODIFIER_PERCENT:
	                newFormat = IBM.ICU.Text.NumberFormat.GetPercentInstance(ulocale);
	                break;
	            case MODIFIER_INTEGER:
	                newFormat = IBM.ICU.Text.NumberFormat.GetIntegerInstance(ulocale);
	                break;
	            default: // pattern
	                newFormat = new DecimalFormat(segments[3].ToString(),
	                        new DecimalFormatSymbols(ulocale));
	                break;
	            }
	            break;
	        case TYPE_DATE:
	            switch (FindKeyword(segments[3].ToString(), dateModifierList)) {
	            case DATE_MODIFIER_EMPTY:
	                newFormat = IBM.ICU.Text.DateFormat.GetDateInstance(IBM.ICU.Text.DateFormat.DEFAULT,
	                        ulocale);
	                break;
	            case DATE_MODIFIER_SHORT:
	                newFormat = IBM.ICU.Text.DateFormat.GetDateInstance(IBM.ICU.Text.DateFormat.SHORT,
	                        ulocale);
	                break;
	            case DATE_MODIFIER_MEDIUM:
	                newFormat = IBM.ICU.Text.DateFormat.GetDateInstance(IBM.ICU.Text.DateFormat.DEFAULT,
	                        ulocale);
	                break;
	            case DATE_MODIFIER_LONG:
	                newFormat = IBM.ICU.Text.DateFormat
	                        .GetDateInstance(IBM.ICU.Text.DateFormat.LONG, ulocale);
	                break;
	            case DATE_MODIFIER_FULL:
	                newFormat = IBM.ICU.Text.DateFormat
	                        .GetDateInstance(IBM.ICU.Text.DateFormat.FULL, ulocale);
	                break;
	            default:
	                newFormat = new SimpleDateFormat(segments[3].ToString(),
	                        ulocale);
	                break;
	            }
	            break;
	        case TYPE_TIME:
	            switch (FindKeyword(segments[3].ToString(), dateModifierList)) {
	            case DATE_MODIFIER_EMPTY:
	                newFormat = IBM.ICU.Text.DateFormat.GetTimeInstance(IBM.ICU.Text.DateFormat.DEFAULT,
	                        ulocale);
	                break;
	            case DATE_MODIFIER_SHORT:
	                newFormat = IBM.ICU.Text.DateFormat.GetTimeInstance(IBM.ICU.Text.DateFormat.SHORT,
	                        ulocale);
	                break;
	            case DATE_MODIFIER_MEDIUM:
	                newFormat = IBM.ICU.Text.DateFormat.GetTimeInstance(IBM.ICU.Text.DateFormat.DEFAULT,
	                        ulocale);
	                break;
	            case DATE_MODIFIER_LONG:
	                newFormat = IBM.ICU.Text.DateFormat
	                        .GetTimeInstance(IBM.ICU.Text.DateFormat.LONG, ulocale);
	                break;
	            case DATE_MODIFIER_FULL:
	                newFormat = IBM.ICU.Text.DateFormat
	                        .GetTimeInstance(IBM.ICU.Text.DateFormat.FULL, ulocale);
	                break;
	            default:
	                newFormat = new SimpleDateFormat(segments[3].ToString(),
	                        ulocale);
	                break;
	            }
	            break;
	        case TYPE_CHOICE:
	            try {
	                newFormat = new ChoiceFormat(segments[3].ToString());
	            } catch (Exception e_0) {
	                maxOffset = oldMaxOffset;
	                throw new ArgumentException("Choice Pattern incorrect");
	            }
	            break;
	        case TYPE_SPELLOUT: {
	            RuleBasedNumberFormat rbnf = new RuleBasedNumberFormat(ulocale,
	                    IBM.ICU.Text.RuleBasedNumberFormat.SPELLOUT);
	            String ruleset = segments[3].ToString().Trim();
	            if (ruleset.Length != 0) {
	                try {
	                    rbnf.SetDefaultRuleSet(ruleset);
	                } catch (Exception e_1) {
	                    // warn invalid ruleset
	                }
	            }
	            newFormat = rbnf;
	        }
	            break;
	        case TYPE_ORDINAL: {
	            RuleBasedNumberFormat rbnf_2 = new RuleBasedNumberFormat(ulocale,
	                    IBM.ICU.Text.RuleBasedNumberFormat.ORDINAL);
	            String ruleset_3 = segments[3].ToString().Trim();
	            if (ruleset_3.Length != 0) {
	                try {
	                    rbnf_2.SetDefaultRuleSet(ruleset_3);
	                } catch (Exception e_4) {
	                    // warn invalid ruleset
	                }
	            }
	            newFormat = rbnf_2;
	        }
	            break;
	        case TYPE_DURATION: {
	            RuleBasedNumberFormat rbnf_5 = new RuleBasedNumberFormat(ulocale,
	                    IBM.ICU.Text.RuleBasedNumberFormat.DURATION);
	            String ruleset_6 = segments[3].ToString().Trim();
	            if (ruleset_6.Length != 0) {
	                try {
	                    rbnf_5.SetDefaultRuleSet(ruleset_6);
	                } catch (Exception e_7) {
	                    // warn invalid ruleset
	                }
	            }
	            newFormat = rbnf_5;
	        }
	            break;
	        case TYPE_PLURAL: {
	            // PluralFormat does not handle quotes.
	            // Remove quotes.
	            // TODO: Should PluralFormat handle quotes?
	            StringBuilder unquotedPattern = new StringBuilder();
	            String quotedPattern = segments[3].ToString();
	            bool inQuote = false;
	            for (int i = 0; i < quotedPattern.Length; ++i) {
	                char ch = quotedPattern[i];
	                if (ch == '\'') {
	                    if (i + 1 < quotedPattern.Length
	                            && quotedPattern[i + 1] == '\'') {
	                        unquotedPattern.Append(ch);
	                        ++i;
	                    } else {
	                        inQuote = !inQuote;
	                    }
	                } else {
	                    unquotedPattern.Append(ch);
	                }
	            }
	
	            PluralFormat pls = new PluralFormat(ulocale,
	                    unquotedPattern.ToString());
	            newFormat = pls;
	        }
	            break;
	        default:
	            maxOffset = oldMaxOffset;
	            throw new ArgumentException("unknown format type at ");
	        }
	        formats[offsetNumber] = newFormat;
	        segments[1].Length=0; // throw away other segments
	        segments[2].Length=0;
	        segments[3].Length=0;
	    }
	
	    private static int FindKeyword(String s, String[] list) {
	        s = s.Trim().ToLower();
	        for (int i = 0; i < list.Length; ++i) {
	            if (s.Equals(list[i]))
	                return i;
	        }
	        return -1;
	    }
	
	    private static void CopyAndFixQuotes(String source, int start,
	            int end, StringBuilder target) {
	        // added 'gotLB' logic from ICU4C - questionable [alan]
	        bool gotLB = false;
	        for (int i = start; i < end; ++i) {
	            char ch = source[i];
	            if (ch == '{') {
	                target.Append("'{'");
	                gotLB = true;
	            } else if (ch == '}') {
	                if (gotLB) {
	                    target.Append(ch);
	                    gotLB = false;
	                } else {
	                    target.Append("'}'");
	                }
	            } else if (ch == '\'') {
	                target.Append("''");
	            } else {
	                target.Append(ch);
	            }
	        }
	    }
	
	    /// <summary>
	    /// After reading an object from the input stream, do a simple verification
	    /// to maintain class invariants.
	    /// </summary>
	    ///
	    /// <exception cref="InvalidObjectException">if the objects read from the stream is invalid.</exception>
	    private void ReadObject(IlObjectInputStream ins0) {
	        ins0.DefaultReadObject();
	        if (argumentNames == null) { // name mod, rev
	            argumentNamesAreNumeric = true;
	            argumentNames = new String[argumentNumbers.Length];
	            for (int i = 0; i < argumentNumbers.Length; ++i) {
	                argumentNames[i] = argumentNumbers[i].ToString();
	            }
	        }
	        bool isValid = maxOffset >= -1 && formats.Length > maxOffset
	                && offsets.Length > maxOffset
	                && argumentNames.Length > maxOffset;
	        if (isValid) {
	            int lastOffset = pattern.Length + 1;
	            for (int i_0 = maxOffset; i_0 >= 0; --i_0) {
	                if ((offsets[i_0] < 0) || (offsets[i_0] > lastOffset)) {
	                    isValid = false;
	                    break;
	                } else {
	                    lastOffset = offsets[i_0];
	                }
	            }
	        }
	        if (!isValid) {
	            throw new IOException(
	                    "Could not reconstruct MessageFormat from corrupt stream.");
	        }
	        if (ulocale == null) {
	            ulocale = IBM.ICU.Util.ULocale.ForLocale(locale);
	        }
	    }
	
	    /// <summary>
	    /// This is a helper method for converting an object array into a map. The
	    /// key set of the map is [0, ..., array.length]. The value associated with
	    /// each key is the ith entry of the passed object array.
	    /// </summary>
	    ///
	    /// <exception cref="InvalidObjectException">if the objects read from the stream is invalid.</exception>
	    private IDictionary ArrayToMap(Object[] array) {
	        IDictionary map = new Hashtable();
	        if (array != null) {
	            for (int i = 0; i < array.Length; ++i) {
	                ILOG.J2CsMapping.Collections.Collections.Put(map,ILOG.J2CsMapping.Util.IlNumber.ToString(i),array[i]);
	            }
	        }
	        return map;
	    }
	
	    private bool IsAlphaIdentifier(String argument) {
	        if (argument.Length == 0) {
	            return false;
	        }
	        for (int i = 0; i < argument.Length; ++i) {
	            if (i == 0 && !IDStartChars.Contains(argument[i]) || i > 0
	                    && !IDContChars.Contains(argument[i])) {
	                return false;
	            }
	        }
	        return true;
	    }
	
	    private const char SINGLE_QUOTE = '\'';
	
	    private const char CURLY_BRACE_LEFT = '{';
	
	    private const char CURLY_BRACE_RIGHT = '}';
	
	    private const int STATE_INITIAL = 0;
	
	    private const int STATE_SINGLE_QUOTE = 1;
	
	    private const int STATE_IN_QUOTE = 2;
	
	    private const int STATE_MSG_ELEMENT = 3;
	
	    private static UnicodeSet IDStartChars = new UnicodeSet("[:ID_Start:]");
	
	    private static UnicodeSet IDContChars = new UnicodeSet("[:ID_Continue:]");
	
	    /// <summary>
	    /// Convert an 'apostrophe-friendly' pattern into a standard pattern.
	    /// Standard patterns treat all apostrophes as quotes, which is problematic
	    /// in some languages, e.g. French, where apostrophe is commonly used. This
	    /// utility assumes that only an unpaired apostrophe immediately before a
	    /// brace is a true quote. Other unpaired apostrophes are paired, and the
	    /// resulting standard pattern string is returned.
	    /// <p>
	    /// <b>Note</b> it is not guaranteed that the returned pattern is indeed a
	    /// valid pattern. The only effect is to convert between patterns having
	    /// different quoting semantics.
	    /// </summary>
	    ///
	    /// <param name="pattern_0">the 'apostrophe-friendly' patttern to convert</param>
	    /// <returns>the standard equivalent of the original pattern</returns>
	    /// @stable ICU 3.4
	    public static String AutoQuoteApostrophe(String pattern_0) {
	        StringBuilder buf = new StringBuilder(pattern_0.Length * 2);
	        int state = STATE_INITIAL;
	        int braceCount = 0;
	        for (int i = 0, j = pattern_0.Length; i < j; ++i) {
	            char c = pattern_0[i];
	            switch (state) {
	            case STATE_INITIAL:
	                switch ((int) c) {
	                case SINGLE_QUOTE:
	                    state = STATE_SINGLE_QUOTE;
	                    break;
	                case CURLY_BRACE_LEFT:
	                    state = STATE_MSG_ELEMENT;
	                    ++braceCount;
	                    break;
	                }
	                break;
	            case STATE_SINGLE_QUOTE:
	                switch ((int) c) {
	                case SINGLE_QUOTE:
	                    state = STATE_INITIAL;
	                    break;
	                case CURLY_BRACE_LEFT:
	                case CURLY_BRACE_RIGHT:
	                    state = STATE_IN_QUOTE;
	                    break;
	                default:
	                    buf.Append(SINGLE_QUOTE);
	                    state = STATE_INITIAL;
	                    break;
	                }
	                break;
	            case STATE_IN_QUOTE:
	                switch ((int) c) {
	                case SINGLE_QUOTE:
	                    state = STATE_INITIAL;
	                    break;
	                }
	                break;
	            case STATE_MSG_ELEMENT:
	                switch ((int) c) {
	                case CURLY_BRACE_LEFT:
	                    ++braceCount;
	                    break;
	                case CURLY_BRACE_RIGHT:
	                    if (--braceCount == 0) {
	                        state = STATE_INITIAL;
	                    }
	                    break;
	                }
	                break;
	            default: // Never happens.
	                break;
	            }
	            buf.Append(c);
	        }
	        // End of scan
	        if (state == STATE_SINGLE_QUOTE || state == STATE_IN_QUOTE) {
	            buf.Append(SINGLE_QUOTE);
	        }
	        return buf.ToString();
	    }
	
	    // #if defined(FOUNDATION10) || defined(J2SE13)
	    // #else
	    //
	    // private methods for AttributedCharacterIterator support
	    //
	    // Note: The equivalent methods are defined as package local methods in
	    // java.text.Format. ICU cannot access these methods, so we have
	    // these methods locally, with "_" prefix for avoiding name collision.
	    // (The collision itself is not a problem, but Eclipse displays warnings
	    // by the default warning level.) We may move these utility methods
	    // up to com.ibm.icu.text.UFormat later. Yoshito
	
	    private static AttributedCharacterIterator _createAttributedCharacterIterator(
	            String text) {
	        AttributedString al = new AttributedString(text);
	        return al.GetIterator();
	    }
	
	    private static AttributedCharacterIterator _createAttributedCharacterIterator(
	            AttributedCharacterIterator[] iterators) {
	        if (iterators == null || iterators.Length == 0) {
	            return _createAttributedCharacterIterator("");
	        }
	        // Create a single AttributedString
	        StringBuilder sb = new StringBuilder();
	        for (int i = 0; i < iterators.Length; i++) {
	            int index = iterators[i].GetBeginIndex();
	            int end = iterators[i].GetEndIndex();
	            while (index < end) {
	                sb.Append(iterators[i].SetIndex(index++));
	            }
	        }
	        AttributedString al = new AttributedString(sb.ToString());
	
	        // Set attributes
	        int offset = 0;
	        for (int i_0 = 0; i_0 < iterators.Length; i_0++) {
	            iterators[i_0].First();
	            int start = iterators[i_0].GetBeginIndex();
	            while (true) {
	                IDictionary<AttributedCharacterIterator_Constants.Attribute, object> map = iterators[i_0].GetAttributes();
	                int len = iterators[i_0].GetRunLimit() - start; // run length
	                if (map.Count > 0) {
	                    IIterator eit = new ILOG.J2CsMapping.Collections.IteratorAdapter(map.GetEnumerator());
	                    while (eit.HasNext()) {
	                        DictionaryEntry entry = (DictionaryEntry) eit.Next();
	                        al.AddAttribute(
	                                (AttributedCharacterIterator_Constants.Attribute) ((DictionaryEntry) entry).Key, ((DictionaryEntry) entry).Value, offset,
	                                offset + len);
	                    }
	                }
	                offset += len;
	                start += len;
	                iterators[i_0].SetIndex(start);
	                if (iterators[i_0].Current() == ILOG.J2CsMapping.Text.CharacterIterator.Done) {
	                    break;
	                }
	            }
	        }
	
	        return al.GetIterator();
	    }
	
	    private static AttributedCharacterIterator _createAttributedCharacterIterator(
	            AttributedCharacterIterator iterator,
	            AttributedCharacterIterator_Constants.Attribute key, Object value_ren) {
	        AttributedString al = new AttributedString(iterator);
	        al.AddAttribute(key, value_ren);
	        return al.GetIterator();
	    }
	
	    private static AttributedCharacterIterator _createAttributedCharacterIterator(
                String text, AttributedCharacterIterator_Constants.Attribute key, Object value_ren)
        {
	        AttributedString al = new AttributedString(text);
	        al.AddAttribute(key, value_ren);
	        return al.GetIterator();
	    }
	    // #endif
	}
}
