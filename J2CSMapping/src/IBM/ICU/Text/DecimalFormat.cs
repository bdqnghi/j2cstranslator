//##header J2SE15
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:30 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /*
 *******************************************************************************
 * Copyright (C) 1996-2007, International Business Machines Corporation and    *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 */
namespace IBM.ICU.Text {
	
	//using IBM.ICU.Lang;
	using IBM.ICU.Math;
	using IBM.ICU.Util;
	using ILOG.J2CsMapping.IO;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Text;
    using ILOG.J2CsMapping.Util;
    using FieldPosition = ILOG.J2CsMapping.Text.FieldPosition;
    using ParsePosition = ILOG.J2CsMapping.Text.ParsePosition;
    using ILOG.J2CsMapping.Text;
    using ILOG.J2CsMapping.Formatting;
	
	/// <summary>
	/// <c>DecimalFormat</c> is a concrete subclass of <see cref="T:IBM.ICU.Text.NumberFormat"/>that formats decimal numbers. It has a variety of features designed to make
	/// it possible to parse and format numbers in any locale, including support for
	/// Western, Arabic, or Indic digits. It also supports different flavors of
	/// numbers, including integers ("123"), fixed-point numbers ("123.4"),
	/// scientific notation ("1.23E4"), percentages ("12%"), and currency amounts
	/// ("$123"). All of these flavors can be easily localized.
	/// <p>
	/// <strong>This is an enhanced version of <c>DecimalFormat</c> that is
	/// based on the standard version in the JDK. New or changed functionality is
	/// labeled <strong><font face=helvetica color=red>NEW</font></strong> or
	/// <strong><font face=helvetica color=red>CHANGED</font></strong>.</strong>
	/// <p>
	/// To obtain a <see cref="T:IBM.ICU.Text.NumberFormat"/> for a specific locale (including the default
	/// locale) call one of <c>NumberFormat</c>'s factory methods such as<see cref="M:IBM.ICU.Text.NumberFormat.GetInstance"/>. Do not call the <c>DecimalFormat</c>
	/// constructors directly, unless you know what you are doing, since the<see cref="T:IBM.ICU.Text.NumberFormat"/> factory methods may return subclasses other than
	/// <c>DecimalFormat</c>. If you need to customize the format object, do
	/// something like this:
	/// <blockquote>
	/// <pre>
	/// NumberFormat f = NumberFormat.getInstance(loc);
	/// if (f instanceof DecimalFormat) {
	/// ((DecimalFormat) f).setDecimalSeparatorAlwaysShown(true);
	/// }
	/// </pre>
	/// </blockquote>
	/// <p>
	/// <strong>Example Usage</strong>
	/// <blockquote>
	/// <pre>
	/// <strong>// Print out a number using the localized number, currency,
	/// // and percent format for each locale</strong>
	/// Locale[] locales = NumberFormat.getAvailableLocales();
	/// double myNumber = -1234.56;
	/// NumberFormat format;
	/// for (int j=0; j<3; ++j) {
	/// System.out.println("FORMAT");
	/// for (int i = 0; i < locales.length; ++i) {
	/// if (locales[i].getCountry().length() == 0) {
	/// // Skip language-only locales
	/// continue;
	/// }
	/// System.out.print(locales[i].getDisplayName());
	/// switch (j) {
	/// case 0:
	/// format = NumberFormat.getInstance(locales[i]); break;
	/// case 1:
	/// format = NumberFormat.getCurrencyInstance(locales[i]); break;
	/// default:
	/// format = NumberFormat.getPercentInstance(locales[i]); break;
	/// }
	/// try {
	/// // Assume format is a DecimalFormat
	/// System.out.print(": " + ((DecimalFormat) format).toPattern()
	/// + " -> " + form.format(myNumber));
	/// } catch (Exception e) {}
	/// try {
	/// System.out.println(" -> " + format.parse(form.format(myNumber)));
	/// } catch (ParseException e) {}
	/// }
	/// }
	/// </pre>
	/// </blockquote>
	/// <h4>Patterns</h4>
	/// <p>
	/// A <c>DecimalFormat</c> consists of a <em>pattern</em> and a set of
	/// <em>symbols</em>. The pattern may be set directly using <see cref="M:IBM.ICU.Text.DecimalFormat.ApplyPattern(System.String)"/>, or indirectly using other API methods which manipulate aspects of the
	/// pattern, such as the minimum number of integer digits. The symbols are stored
	/// in a <see cref="T:IBM.ICU.Text.DecimalFormatSymbols"/> object. When using the <see cref="T:IBM.ICU.Text.NumberFormat"/>factory methods, the pattern and symbols are read from ICU's locale data.
	/// <h4>Special Pattern Characters</h4>
	/// <p>
	/// Many characters in a pattern are taken literally; they are matched during
	/// parsing and output unchanged during formatting. Special characters, on the
	/// other hand, stand for other characters, strings, or classes of characters.
	/// For example, the '#' character is replaced by a localized digit. Often the
	/// replacement character is the same as the pattern character; in the U.S.
	/// locale, the ',' grouping character is replaced by ','. However, the
	/// replacement is still happening, and if the symbols are modified, the grouping
	/// character changes. Some special characters affect the behavior of the
	/// formatter by their presence; for example, if the percent character is seen,
	/// then the value is multiplied by 100 before being displayed.
	/// <p>
	/// To insert a special character in a pattern as a literal, that is, without any
	/// special meaning, the character must be quoted. There are some exceptions to
	/// this which are noted below.
	/// <p>
	/// The characters listed here are used in non-localized patterns. Localized
	/// patterns use the corresponding characters taken from this formatter's<see cref="T:IBM.ICU.Text.DecimalFormatSymbols"/> object instead, and these characters lose their
	/// special status. Two exceptions are the currency sign and quote, which are not
	/// localized.
	/// <blockquote>
	/// <table border=0 cellspacing=3 cellpadding=0 summary="Chart showing symbol,/// location, localized, and meaning.">
	/// <tr bgcolor="#ccccff">
	/// <th align=left>Symbol
	/// <th align=left>Location
	/// <th align=left>Localized?
	/// <th align=left>Meaning
	/// <tr valign=top>
	/// <td><c>0</c>
	/// <td>Number
	/// <td>Yes
	/// <td>Digit
	/// <tr valign=top bgcolor="#eeeeff">
	/// <td><c>1-9</c>
	/// <td>Number
	/// <td>Yes
	/// <td><strong><font face=helvetica color=red>NEW</font></strong> '1' through
	/// '9' indicate rounding.
	/// <tr valign=top>
	/// <td><c>@</c>
	/// <td>Number
	/// <td>No
	/// <td><strong><font face=helvetica color=red>NEW</font></strong> Significant
	/// digit
	/// <tr valign=top bgcolor="#eeeeff">
	/// <td><c>#</c>
	/// <td>Number
	/// <td>Yes
	/// <td>Digit, zero shows as absent
	/// <tr valign=top>
	/// <td><c>.</c>
	/// <td>Number
	/// <td>Yes
	/// <td>Decimal separator or monetary decimal separator
	/// <tr valign=top bgcolor="#eeeeff">
	/// <td><c>-</c>
	/// <td>Number
	/// <td>Yes
	/// <td>Minus sign
	/// <tr valign=top>
	/// <td><c>,</c>
	/// <td>Number
	/// <td>Yes
	/// <td>Grouping separator
	/// <tr valign=top bgcolor="#eeeeff">
	/// <td><c>E</c>
	/// <td>Number
	/// <td>Yes
	/// <td>Separates mantissa and exponent in scientific notation.
	/// <em>Need not be quoted in prefix or suffix.</em>
	/// <tr valign=top>
	/// <td><c>+</c>
	/// <td>Exponent
	/// <td>Yes
	/// <td><strong><font face=helvetica color=red>NEW</font></strong> Prefix
	/// positive exponents with localized plus sign.
	/// <em>Need not be quoted in prefix or suffix.</em>
	/// <tr valign=top bgcolor="#eeeeff">
	/// <td><c>;</c>
	/// <td>Subpattern boundary
	/// <td>Yes
	/// <td>Separates positive and negative subpatterns
	/// <tr valign=top>
	/// <td><c>%</c>
	/// <td>Prefix or suffix
	/// <td>Yes
	/// <td>Multiply by 100 and show as percentage
	/// <tr valign=top bgcolor="#eeeeff">
	/// <td><c>&#92;u2030</c>
	/// <td>Prefix or suffix
	/// <td>Yes
	/// <td>Multiply by 1000 and show as per mille
	/// <tr valign=top>
	/// <td><c>&#164;</c> (<c>&#92;u00A4</c>)
	/// <td>Prefix or suffix
	/// <td>No
	/// <td>Currency sign, replaced by currency symbol. If doubled, replaced by
	/// international currency symbol. If present in a pattern, the monetary decimal
	/// separator is used instead of the decimal separator.
	/// <tr valign=top bgcolor="#eeeeff">
	/// <td><c>'</c>
	/// <td>Prefix or suffix
	/// <td>No
	/// <td>Used to quote special characters in a prefix or suffix, for example,
	/// <c>"'#'#"</c> formats 123 to <c>"#123"</c>. To create a single
	/// quote itself, use two in a row: <c>"# o''clock"</c>.
	/// <tr valign=top>
	/// <td><code>///</code>
	/// <td>Prefix or suffix boundary
	/// <td>Yes
	/// <td><strong><font face=helvetica color=red>NEW</font></strong> Pad escape,
	/// precedes pad character
	/// </table>
	/// </blockquote>
	/// <p>
	/// A <c>DecimalFormat</c> pattern contains a postive and negative
	/// subpattern, for example, "#,##0.00;(#,##0.00)". Each subpattern has a prefix,
	/// a numeric part, and a suffix. If there is no explicit negative subpattern,
	/// the negative subpattern is the localized minus sign prefixed to the positive
	/// subpattern. That is, "0.00" alone is equivalent to "0.00;-0.00". If there is
	/// an explicit negative subpattern, it serves only to specify the negative
	/// prefix and suffix; the number of digits, minimal digits, and other
	/// characteristics are ignored in the negative subpattern. That means that
	/// "#,##0.0#;(#)" has precisely the same result as "#,##0.0#;(#,##0.0#)".
	/// <p>
	/// The prefixes, suffixes, and various symbols used for infinity, digits,
	/// thousands separators, decimal separators, etc. may be set to arbitrary
	/// values, and they will appear properly during formatting. However, care must
	/// be taken that the symbols and strings do not conflict, or parsing will be
	/// unreliable. For example, either the positive and negative prefixes or the
	/// suffixes must be distinct for <see cref="M:IBM.ICU.Text.DecimalFormat.Parse(System.String, null)"/> to be able to distinguish
	/// positive from negative values. Another example is that the decimal separator
	/// and thousands separator should be distinct characters, or parsing will be
	/// impossible.
	/// <p>
	/// The <em>grouping separator</em> is a character that separates clusters of
	/// integer digits to make large numbers more legible. It commonly used for
	/// thousands, but in some locales it separates ten-thousands. The <em>grouping
	/// size</em> is the number of digits between the grouping separators, such as 3
	/// for "100,000,000" or 4 for "1 0000 0000". There are actually two different
	/// grouping sizes: One used for the least significant integer digits, the
	/// <em>primary grouping size</em>, and one used for all others, the
	/// <em>secondary grouping size</em>. In most locales these are the same, but
	/// sometimes they are different. For example, if the primary grouping interval
	/// is 3, and the secondary is 2, then this corresponds to the pattern
	/// "#,##,##0", and the number 123456789 is formatted as "12,34,56,789". If a
	/// pattern contains multiple grouping separators, the interval between the last
	/// one and the end of the integer defines the primary grouping size, and the
	/// interval between the last two defines the secondary grouping size. All others
	/// are ignored, so "#,##,###,####" == "###,###,####" == "##,#,###,####".
	/// <p>
	/// Illegal patterns, such as "#.#.#" or "#.###,###", will cause
	/// <c>DecimalFormat</c> to throw an <see cref="T:System.ArgumentException"/> with
	/// a message that describes the problem.
	/// <h4>Pattern BNF</h4>
	/// <pre>
	/// pattern    := subpattern (';' subpattern)?
	/// subpattern := prefix? number exponent? suffix?
	/// number     := (integer ('.' fraction)?) | sigDigits
	/// prefix     := '&#92;u0000'..'&#92;uFFFD' - specialCharacters
	/// suffix     := '&#92;u0000'..'&#92;uFFFD' - specialCharacters
	/// integer    := '#'/// '0'/// '0'
	/// fraction   := '0'/// '#'
	/// sigDigits  := '#'/// '@' '@'/// '#'
	/// exponent   := 'E' '+'? '0'/// '0'
	/// padSpec    := '///' padChar
	/// padChar    := '&#92;u0000'..'&#92;uFFFD' - quote
	/// &#32;
	/// Notation:
	/// X///       0 or more instances of X
	/// X?       0 or 1 instances of X
	/// X|Y      either X or Y
	/// C..D     any character from C up to D, inclusive
	/// S-T      characters in S, except those in T
	/// </pre>
	/// The first subpattern is for positive numbers. The second (optional)
	/// subpattern is for negative numbers.
	/// <p>
	/// Not indicated in the BNF syntax above:
	/// <ul>
	/// <li>The grouping separator ',' can occur inside the integer and sigDigits
	/// elements, between any two pattern characters of that element, as long as the
	/// integer or sigDigits element is not followed by the exponent element.
	/// <li><font color=red face=helvetica><strong>NEW</strong></font> Two grouping
	/// intervals are recognized: That between the decimal point and the first
	/// grouping symbol, and that between the first and second grouping symbols.
	/// These intervals are identical in most locales, but in some locales they
	/// differ. For example, the pattern &quot;#,##,###&quot; formats the number
	/// 123456789 as &quot;12,34,56,789&quot;.</li>
	/// <li>
	/// <strong><font face=helvetica color=red>NEW</font></strong> The pad specifier
	/// <c>padSpec</c> may appear before the prefix, after the prefix, before
	/// the suffix, after the suffix, or not at all.
	/// <li>
	/// <strong><font face=helvetica color=red>NEW</font></strong> In place of '0',
	/// the digits '1' through '9' may be used to indicate a rounding increment.
	/// </ul>
	/// <h4>Parsing</h4>
	/// <p>
	/// <c>DecimalFormat</c> parses all Unicode characters that represent
	/// decimal digits, as defined by <see cref="null"/>. In addition,
	/// <c>DecimalFormat</c> also recognizes as digits the ten consecutive
	/// characters starting with the localized zero digit defined in the<see cref="T:IBM.ICU.Text.DecimalFormatSymbols"/> object. During formatting, the<see cref="T:IBM.ICU.Text.DecimalFormatSymbols"/>-based digits are output.
	/// <p>
	/// During parsing, grouping separators are ignored.
	/// <p>
	/// If <see cref="M:IBM.ICU.Text.DecimalFormat.Parse(System.String, null)"/> fails to parse a string, it returns
	/// <c>null</c> and leaves the parse position unchanged. The convenience
	/// method <see cref="M:IBM.ICU.Text.DecimalFormat.Parse(System.String)"/> indicates parse failure by throwing a<see cref="T:ILOG.J2CsMapping.Util.ParseException"/>.
	/// <h4>Formatting</h4>
	/// <p>
	/// Formatting is guided by several parameters, all of which can be specified
	/// either using a pattern or using the API. The following description applies to
	/// formats that do not use <a href="#sci">scientific notation</a> or <a
	/// href="#sigdig">significant digits</a>.
	/// <ul>
	/// <li>If the number of actual integer digits exceeds the
	/// <em>maximum integer digits</em>, then only the least significant digits are
	/// shown. For example, 1997 is formatted as "97" if the maximum integer digits
	/// is set to 2.
	/// <li>If the number of actual integer digits is less than the
	/// <em>minimum integer digits</em>, then leading zeros are added. For example,
	/// 1997 is formatted as "01997" if the minimum integer digits is set to 5.
	/// <li>If the number of actual fraction digits exceeds the <em>maximum
	/// fraction digits</em>, then half-even rounding it performed to the maximum
	/// fraction digits. For example, 0.125 is formatted as "0.12" if the maximum
	/// fraction digits is 2. This behavior can be changed by specifying a rounding
	/// increment and a rounding mode.
	/// <li>If the number of actual fraction digits is less than the
	/// <em>minimum fraction digits</em>, then trailing zeros are added. For example,
	/// 0.125 is formatted as "0.1250" if the mimimum fraction digits is set to 4.
	/// <li>Trailing fractional zeros are not displayed if they occur <em>j</em>
	/// positions after the decimal, where <em>j</em> is less than the maximum
	/// fraction digits. For example, 0.10004 is formatted as "0.1" if the maximum
	/// fraction digits is four or less.
	/// </ul>
	/// <p>
	/// <strong>Special Values</strong>
	/// <p>
	/// <c>NaN</c> is represented as a single character, typically
	/// <c>&#92;uFFFD</c>. This character is determined by the<see cref="T:IBM.ICU.Text.DecimalFormatSymbols"/> object. This is the only value for which the
	/// prefixes and suffixes are not used.
	/// <p>
	/// Infinity is represented as a single character, typically
	/// <c>&#92;u221E</c>, with the positive or negative prefixes and suffixes
	/// applied. The infinity character is determined by the<see cref="T:IBM.ICU.Text.DecimalFormatSymbols"/> object.
	/// <a name="sci">
	/// <h4>Scientific Notation</h4></a>
	/// <p>
	/// Numbers in scientific notation are expressed as the product of a mantissa and
	/// a power of ten, for example, 1234 can be expressed as 1.234 x 10<sup>3</sup>.
	/// The mantissa is typically in the half-open interval [1.0, 10.0) or sometimes
	/// [0.0, 1.0), but it need not be. <c>DecimalFormat</c> supports arbitrary
	/// mantissas. <c>DecimalFormat</c> can be instructed to use scientific
	/// notation through the API or through the pattern. In a pattern, the exponent
	/// character immediately followed by one or more digit characters indicates
	/// scientific notation. Example: "0.###E0" formats the number 1234 as "1.234E3".
	/// <ul>
	/// <li>The number of digit characters after the exponent character gives the
	/// minimum exponent digit count. There is no maximum. Negative exponents are
	/// formatted using the localized minus sign, <em>not</em> the prefix and suffix
	/// from the pattern. This allows patterns such as "0.###E0 m/s". To prefix
	/// positive exponents with a localized plus sign, specify '+' between the
	/// exponent and the digits: "0.###E+0" will produce formats "1E+1", "1E+0",
	/// "1E-1", etc. (In localized patterns, use the localized plus sign rather than
	/// '+'.)
	/// <li>The minimum number of integer digits is achieved by adjusting the
	/// exponent. Example: 0.00123 formatted with "00.###E0" yields "12.3E-4". This
	/// only happens if there is no maximum number of integer digits. If there is a
	/// maximum, then the minimum number of integer digits is fixed at one.
	/// <li>The maximum number of integer digits, if present, specifies the exponent
	/// grouping. The most common use of this is to generate <em>engineering
	/// notation</em>, in which the exponent is a multiple of three, e.g.,
	/// "##0.###E0". The number 12345 is formatted using "##0.####E0" as "12.345E3".
	/// <li>When using scientific notation, the formatter controls the digit counts
	/// using significant digits logic. The maximum number of significant digits
	/// limits the total number of integer and fraction digits that will be shown in
	/// the mantissa; it does not affect parsing. For example, 12345 formatted with
	/// "##0.##E0" is "12.3E3". See the section on significant digits for more
	/// details.
	/// <li>The number of significant digits shown is determined as follows: If
	/// areSignificantDigitsUsed() returns false, then the minimum number of
	/// significant digits shown is one, and the maximum number of significant digits
	/// shown is the sum of the <em>minimum
	/// integer</em> and <em>maximum fraction</em> digits, and is unaffected by the
	/// maximum integer digits. If this sum is zero, then all significant digits are
	/// shown. If areSignificantDigitsUsed() returns true, then the significant digit
	/// counts are specified by getMinimumSignificantDigits() and
	/// getMaximumSignificantDigits(). In this case, the number of integer digits is
	/// fixed at one, and there is no exponent grouping.
	/// <li>Exponential patterns may not contain grouping separators.
	/// </ul>
	/// <a name="sigdig">
	/// <h4>
	/// <strong><font face=helvetica color=red>NEW</font></strong> Significant Digits
	/// </h4></a>
	/// <c>DecimalFormat</c> has two ways of controlling how many digits are
	/// shows: (a) significant digits counts, or (b) integer and fraction digit
	/// counts. Integer and fraction digit counts are described above. When a
	/// formatter is using significant digits counts, the number of integer and
	/// fraction digits is not specified directly, and the formatter settings for
	/// these counts are ignored. Instead, the formatter uses however many integer
	/// and fraction digits are required to display the specified number of
	/// significant digits. Examples:
	/// <blockquote>
	/// <table border=0 cellspacing=3 cellpadding=0>
	/// <tr bgcolor="#ccccff">
	/// <th align=left>Pattern
	/// <th align=left>Minimum significant digits
	/// <th align=left>Maximum significant digits
	/// <th align=left>Number
	/// <th align=left>Output of format()
	/// <tr valign=top>
	/// <td><c>@@@</c>
	/// <td>3
	/// <td>3
	/// <td>12345
	/// <td><c>12300</c>
	/// <tr valign=top bgcolor="#eeeeff">
	/// <td><c>@@@</c>
	/// <td>3
	/// <td>3
	/// <td>0.12345
	/// <td><c>0.123</c>
	/// <tr valign=top>
	/// <td><c>@@##</c>
	/// <td>2
	/// <td>4
	/// <td>3.14159
	/// <td><c>3.142</c>
	/// <tr valign=top bgcolor="#eeeeff">
	/// <td><c>@@##</c>
	/// <td>2
	/// <td>4
	/// <td>1.23004
	/// <td><c>1.23</c>
	/// </table>
	/// </blockquote>
	/// <ul>
	/// <li>Significant digit counts may be expressed using patterns that specify a
	/// minimum and maximum number of significant digits. These are indicated by the
	/// <c>'@'</c> and <c>'#'</c> characters. The minimum number of
	/// significant digits is the number of <c>'@'</c> characters. The maximum
	/// number of significant digits is the number of <c>'@'</c> characters
	/// plus the number of <c>'#'</c> characters following on the right. For
	/// example, the pattern <c>"@@@"</c> indicates exactly 3 significant
	/// digits. The pattern <c>"@##"</c> indicates from 1 to 3 significant
	/// digits. Trailing zero digits to the right of the decimal separator are
	/// suppressed after the minimum number of significant digits have been shown.
	/// For example, the pattern <c>"@##"</c> formats the number 0.1203 as
	/// <c>"0.12"</c>.
	/// <li>If a pattern uses significant digits, it may not contain a decimal
	/// separator, nor the <c>'0'</c> pattern character. Patterns such as
	/// <c>"@00"</c> or <c>"@.###"</c> are disallowed.
	/// <li>Any number of <c>'#'</c> characters may be prepended to the left of
	/// the leftmost <c>'@'</c> character. These have no effect on the minimum
	/// and maximum significant digits counts, but may be used to position grouping
	/// separators. For example, <c>"#,#@#"</c> indicates a minimum of one
	/// significant digits, a maximum of two significant digits, and a grouping size
	/// of three.
	/// <li>In order to enable significant digits formatting, use a pattern
	/// containing the <c>'@'</c> pattern character. Alternatively, call<see cref="M:IBM.ICU.Text.DecimalFormat.SetSignificantDigitsUsed setSignificantDigitsUsed(null)"/>.
	/// <li>In order to disable significant digits formatting, use a pattern that
	/// does not contain the <c>'@'</c> pattern character. Alternatively, call<see cref="M:IBM.ICU.Text.DecimalFormat.SetSignificantDigitsUsed setSignificantDigitsUsed(null)"/>.
	/// <li>The number of significant digits has no effect on parsing.
	/// <li>Significant digits may be used together with exponential notation. Such
	/// patterns are equivalent to a normal exponential pattern with a minimum and
	/// maximum integer digit count of one, a minimum fraction digit count of
	/// <c>getMinimumSignificantDigits() - 1</c>, and a maximum fraction digit
	/// count of <c>getMaximumSignificantDigits() - 1</c>. For example, the
	/// pattern <c>"@@###E0"</c> is equivalent to <c>"0.0###E0"</c>.
	/// <li>If signficant digits are in use, then the integer and fraction digit
	/// counts, as set via the API, are ignored. If significant digits are not in
	/// use, then the signficant digit counts, as set via the API, are ignored.
	/// </ul>
	/// <h4>
	/// <strong><font face=helvetica color=red>NEW</font></strong> Padding</h4>
	/// <p>
	/// <c>DecimalFormat</c> supports padding the result of <see cref="M:IBM.ICU.Text.DecimalFormat.Format(System.Double, System.Text.StringBuilder, null)"/> to
	/// a specific width. Padding may be specified either through the API or through
	/// the pattern syntax. In a pattern the pad escape character, followed by a
	/// single pad character, causes padding to be parsed and formatted. The pad
	/// escape character is '///' in unlocalized patterns, and can be localized using<see cref="M:IBM.ICU.Text.DecimalFormatSymbols.SetPadEscape(System.Character)"/>. For example,
	/// <code>"$///x#,##0.00"</code> formats 123 to <c>"$xx123.00"</c>, and 1234
	/// to <c>"$1,234.00"</c>.
	/// <ul>
	/// <li>When padding is in effect, the width of the positive subpattern,
	/// including prefix and suffix, determines the format width. For example, in the
	/// pattern <code>"/// #0 o''clock"</code>, the format width is 10.
	/// <li>The width is counted in 16-bit code units (Java <c>char</c>s).
	/// <li>Some parameters which usually do not matter have meaning when padding is
	/// used, because the pattern width is significant with padding. In the pattern
	/// "/// ##,##,#,##0.##", the format width is 14. The initial characters "##,##,"
	/// do not affect the grouping size or maximum integer digits, but they do affect
	/// the format width.
	/// <li>Padding may be inserted at one of four locations: before the prefix,
	/// after the prefix, before the suffix, or after the suffix. If padding is
	/// specified in any other location, <see cref="M:IBM.ICU.Text.DecimalFormat.ApplyPattern(System.String)"/> throws an<see cref="T:System.ArgumentException"/>. If there is no prefix, before the prefix
	/// and after the prefix are equivalent, likewise for the suffix.
	/// <li>When specified in a pattern, the 16-bit <c>char</c> immediately
	/// following the pad escape is the pad character. This may be any character,
	/// including a special pattern character. That is, the pad escape
	/// <em>escapes</em> the following character. If there is no character after the
	/// pad escape, then the pattern is illegal.
	/// </ul>
	/// <p>
	/// <strong><font face=helvetica color=red>NEW</font></strong>
	/// <strong>Rounding</strong>
	/// <p>
	/// <c>DecimalFormat</c> supports rounding to a specific increment. For
	/// example, 1230 rounded to the nearest 50 is 1250. 1.234 rounded to the nearest
	/// 0.65 is 1.3. The rounding increment may be specified through the API or in a
	/// pattern. To specify a rounding increment in a pattern, include the increment
	/// in the pattern itself. "#,#50" specifies a rounding increment of 50.
	/// "#,##0.05" specifies a rounding increment of 0.05.
	/// <ul>
	/// <li>Rounding only affects the string produced by formatting. It does not
	/// affect parsing or change any numerical values.
	/// <li>A <em>rounding mode</em> determines how values are rounded; see the<see cref="T:IBM.ICU.Text.BigDecimal"/> documentation for a description of the
	/// modes. Rounding increments specified in patterns use the default mode,<see cref="M:IBM.ICU.Text.BigDecimal.ROUND_HALF_EVEN"/>.
	/// <li>Some locales use rounding in their currency formats to reflect the
	/// smallest currency denomination.
	/// <li>In a pattern, digits '1' through '9' specify rounding, but otherwise
	/// behave identically to digit '0'.
	/// </ul>
	/// <h4>Synchronization</h4>
	/// <p>
	/// <c>DecimalFormat</c> objects are not synchronized. Multiple threads
	/// should not access one formatter concurrently.
	/// </summary>
	///
	/// <seealso cref="T:ILOG.J2CsMapping.Text.IlFormat"/>
	/// <seealso cref="T:IBM.ICU.Text.NumberFormat"/>
	/// @stable ICU 2.0
	public class DecimalFormat : NumberFormat {
	
	    /// <summary>
	    /// Create a DecimalFormat using the default pattern and symbols for the
	    /// default locale. This is a convenient way to obtain a DecimalFormat when
	    /// internationalization is not the main concern.
	    /// <p>
	    /// To obtain standard formats for a given locale, use the factory methods on
	    /// NumberFormat such as getNumberInstance. These factories will return the
	    /// most appropriate sub-class of NumberFormat for a given locale.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.NumberFormat.GetInstance"/>
	    /// <seealso cref="M:IBM.ICU.Text.NumberFormat.GetNumberInstance"/>
	    /// <seealso cref="M:IBM.ICU.Text.NumberFormat.GetCurrencyInstance"/>
	    /// <seealso cref="M:IBM.ICU.Text.NumberFormat.GetPercentInstance"/>
	    /// @stable ICU 2.0
	    public DecimalFormat() {
	        this.digitList = new DigitList();
	        this.positivePrefix = "";
	        this.positiveSuffix = "";
	        this.negativePrefix = "-";
	        this.negativeSuffix = "";
	        this.multiplier = 1;
	        this.groupingSize = 3;
	        this.groupingSize2 = 0;
	        this.decimalSeparatorAlwaysShown = false;
	        this.isCurrencyFormat = false;
	        this.symbols = null;
	        this.useSignificantDigits = false;
	        this.minSignificantDigits = 1;
	        this.maxSignificantDigits = 6;
	        this.exponentSignAlwaysShown = false;
	        this.roundingIncrement = default(decimal);
	        this.roundingIncrementICU = null;
	        this.roundingDouble = 0.0d;
	        this.roundingDoubleReciprocal = 0.0d;
	        this.roundingMode = IBM.ICU.Math.BigDecimal.ROUND_HALF_EVEN;
	        this.formatWidth = 0;
	        this.pad = ' ';
	        this.padPosition = PAD_BEFORE_PREFIX;
	        this.parseBigDecimal = false;
	        this.serialVersionOnStream = currentSerialVersion;
	        this.attributes = new ArrayList();
	        // [NEW]
	        ULocale def = IBM.ICU.Util.ULocale.GetDefault();
	        String pattern = IBM.ICU.Text.NumberFormat.GetPattern(def, 0);
	        // Always applyPattern after the symbols are set
	        this.symbols = new DecimalFormatSymbols(def);
	        SetCurrency(IBM.ICU.Util.Currency.GetInstance(def));
	        ApplyPattern(pattern, false);
	    }
	
	    /// <summary>
	    /// Create a DecimalFormat from the given pattern and the symbols for the
	    /// default locale. This is a convenient way to obtain a DecimalFormat when
	    /// internationalization is not the main concern.
	    /// <p>
	    /// To obtain standard formats for a given locale, use the factory methods on
	    /// NumberFormat such as getNumberInstance. These factories will return the
	    /// most appropriate sub-class of NumberFormat for a given locale.
	    /// </summary>
	    ///
	    /// <param name="pattern">A non-localized pattern string.</param>
	    /// <exception cref="IllegalArgumentException">if the given pattern is invalid.</exception>
	    /// <seealso cref="M:IBM.ICU.Text.NumberFormat.GetInstance"/>
	    /// <seealso cref="M:IBM.ICU.Text.NumberFormat.GetNumberInstance"/>
	    /// <seealso cref="M:IBM.ICU.Text.NumberFormat.GetCurrencyInstance"/>
	    /// <seealso cref="M:IBM.ICU.Text.NumberFormat.GetPercentInstance"/>
	    /// @stable ICU 2.0
	    public DecimalFormat(String pattern) {
	        this.digitList = new DigitList();
	        this.positivePrefix = "";
	        this.positiveSuffix = "";
	        this.negativePrefix = "-";
	        this.negativeSuffix = "";
	        this.multiplier = 1;
	        this.groupingSize = 3;
	        this.groupingSize2 = 0;
	        this.decimalSeparatorAlwaysShown = false;
	        this.isCurrencyFormat = false;
	        this.symbols = null;
	        this.useSignificantDigits = false;
	        this.minSignificantDigits = 1;
	        this.maxSignificantDigits = 6;
	        this.exponentSignAlwaysShown = false;
	        this.roundingIncrement = default(decimal);
	        this.roundingIncrementICU = null;
	        this.roundingDouble = 0.0d;
	        this.roundingDoubleReciprocal = 0.0d;
	        this.roundingMode = IBM.ICU.Math.BigDecimal.ROUND_HALF_EVEN;
	        this.formatWidth = 0;
	        this.pad = ' ';
	        this.padPosition = PAD_BEFORE_PREFIX;
	        this.parseBigDecimal = false;
	        this.serialVersionOnStream = currentSerialVersion;
	        this.attributes = new ArrayList();
	        // Always applyPattern after the symbols are set
	        ULocale def = IBM.ICU.Util.ULocale.GetDefault();
	        this.symbols = new DecimalFormatSymbols(def);
	        SetCurrency(IBM.ICU.Util.Currency.GetInstance(def));
	        ApplyPattern(pattern, false);
	    }
	
	    /// <summary>
	    /// Create a DecimalFormat from the given pattern and symbols. Use this
	    /// constructor when you need to completely customize the behavior of the
	    /// format.
	    /// <p>
	    /// To obtain standard formats for a given locale, use the factory methods on
	    /// NumberFormat such as getInstance or getCurrencyInstance. If you need only
	    /// minor adjustments to a standard format, you can modify the format
	    /// returned by a NumberFormat factory method.
	    /// </summary>
	    ///
	    /// <param name="pattern">a non-localized pattern string</param>
	    /// <param name="symbols">the set of symbols to be used</param>
	    /// <exception cref="IllegalArgumentException">if the given pattern is invalid</exception>
	    /// <seealso cref="M:IBM.ICU.Text.NumberFormat.GetInstance"/>
	    /// <seealso cref="M:IBM.ICU.Text.NumberFormat.GetNumberInstance"/>
	    /// <seealso cref="M:IBM.ICU.Text.NumberFormat.GetCurrencyInstance"/>
	    /// <seealso cref="M:IBM.ICU.Text.NumberFormat.GetPercentInstance"/>
	    /// <seealso cref="T:IBM.ICU.Text.DecimalFormatSymbols"/>
	    /// @stable ICU 2.0
	    public DecimalFormat(String pattern, DecimalFormatSymbols symbols) {
	        this.digitList = new DigitList();
	        this.positivePrefix = "";
	        this.positiveSuffix = "";
	        this.negativePrefix = "-";
	        this.negativeSuffix = "";
	        this.multiplier = 1;
	        this.groupingSize = 3;
	        this.groupingSize2 = 0;
	        this.decimalSeparatorAlwaysShown = false;
	        this.isCurrencyFormat = false;
	        this.symbols = null;
	        this.useSignificantDigits = false;
	        this.minSignificantDigits = 1;
	        this.maxSignificantDigits = 6;
	        this.exponentSignAlwaysShown = false;
	        this.roundingIncrement = default(decimal);
	        this.roundingIncrementICU = null;
	        this.roundingDouble = 0.0d;
	        this.roundingDoubleReciprocal = 0.0d;
	        this.roundingMode = IBM.ICU.Math.BigDecimal.ROUND_HALF_EVEN;
	        this.formatWidth = 0;
	        this.pad = ' ';
	        this.padPosition = PAD_BEFORE_PREFIX;
	        this.parseBigDecimal = false;
	        this.serialVersionOnStream = currentSerialVersion;
	        this.attributes = new ArrayList();
	        // Always applyPattern after the symbols are set
	        this.symbols = (DecimalFormatSymbols) symbols.Clone();
	        SetCurrencyForSymbols();
	        ApplyPattern(pattern, false);
	    }
	
	    
	    /// @stable ICU 2.0
	    public override StringBuilder Format(double number, StringBuilder result,
	            FieldPosition fieldPosition) {
	        return Format(number, result, fieldPosition, false);
	    }
	
	    // [Spark/CDL] The actual method to format number. If boolean value
	    // parseAttr == true, then attribute information will be recorded.
	    private StringBuilder Format(double number, StringBuilder result,
	            FieldPosition fieldPosition, bool parseAttr) {
	        fieldPosition.SetBeginIndex(0);
	        fieldPosition.SetEndIndex(0);
	
	        if (Double.IsNaN(number)) {
	            if (fieldPosition.GetField() == IBM.ICU.Text.NumberFormat.INTEGER_FIELD) {
	                fieldPosition.SetBeginIndex(result.Length);
	            }
	
	            result.Append(symbols.GetNaN());
	            // [Spark/CDL] Add attribute for NaN here.
	            // result.append(symbols.getNaN());
	            // #if defined(FOUNDATION10) || defined(J2SE13)
	            // #else
	            if (parseAttr) {
	                AddAttribute(IBM.ICU.Text.NumberFormat.Field.INTEGER, result.Length
	                        - symbols.GetNaN().Length, result.Length);
	            }
	            // #endif
	            if (fieldPosition.GetField() == IBM.ICU.Text.NumberFormat.INTEGER_FIELD) {
	                fieldPosition.SetEndIndex(result.Length);
	            }
	
	            AddPadding(result, fieldPosition, 0, 0);
	            return result;
	        }
	
	        /*
	         * Detecting whether a double is negative is easy with the exception of
	         * the value -0.0. This is a double which has a zero mantissa (and
	         * exponent), but a negative sign bit. It is semantically distinct from
	         * a zero with a positive sign bit, and this distinction is important to
	         * certain kinds of computations. However, it's a little tricky to
	         * detect, since (-0.0 == 0.0) and !(-0.0 < 0.0). How then, you may ask,
	         * does it behave distinctly from +0.0? Well, 1/(-0.0) == -Infinity.
	         * Proper detection of -0.0 is needed to deal with the issues raised by
	         * bugs 4106658, 4106667, and 4147706. Liu 7/6/98.
	         */
	        bool isNegative = (number < 0.0d)
	                || (number == 0.0d && 1 / number < 0.0d);
	        if (isNegative)
	            number = -number;
	
	        // Do this BEFORE checking to see if value is infinite!
	        if (multiplier != 1)
	            number *= multiplier;
	
	        // Apply rounding after multiplier
	        if (roundingDouble > 0.0d) {
	            // number = roundingDouble
	            // * round(number / roundingDouble, roundingMode, isNegative);
	            double newNumber = Round(number, roundingDouble,
	                    roundingDoubleReciprocal, roundingMode, isNegative);
	            if (newNumber == 0.0d && number != newNumber)
	                isNegative = false; // if we touched it, then make zero be zero.
	            number = newNumber;
	        }
	
	        if (Double.IsInfinity(number)) {
	            int prefixLen = AppendAffix(result, isNegative, true, parseAttr);
	
	            if (fieldPosition.GetField() == IBM.ICU.Text.NumberFormat.INTEGER_FIELD) {
	                fieldPosition.SetBeginIndex(result.Length);
	            }
	
	            // [Spark/CDL] Add attribute for infinity here.
	            result.Append(symbols.GetInfinity());
	            // #if defined(FOUNDATION10) || defined(J2SE13)
	            // #else
	            if (parseAttr) {
	                AddAttribute(IBM.ICU.Text.NumberFormat.Field.INTEGER, result.Length
	                        - symbols.GetInfinity().Length, result.Length);
	            }
	            // #endif
	            if (fieldPosition.GetField() == IBM.ICU.Text.NumberFormat.INTEGER_FIELD) {
	                fieldPosition.SetEndIndex(result.Length);
	            }
	
	            int suffixLen = AppendAffix(result, isNegative, false, parseAttr);
	
	            AddPadding(result, fieldPosition, prefixLen, suffixLen);
	            return result;
	        }
	
	         lock (digitList) {
	                    digitList.Set(number, Precision(false), !useExponentialNotation
	                            && !AreSignificantDigitsUsed());
	                    return Subformat(result, fieldPosition, isNegative, false,
	                            parseAttr);
	                }
	    }
	
	    /// <summary>
	    /// <strong><font face=helvetica color=red>NEW</font></strong> Round a double
	    /// value to the nearest multiple of the given rounding increment, according
	    /// to the given mode. This is equivalent to rounding value/roundingInc to
	    /// the nearest integer, according to the given mode, and returning that
	    /// integer/// roundingInc. Note this is changed from the version in 2.4,
	    /// since division of doubles have inaccuracies. jitterbug 1871.
	    /// </summary>
	    ///
	    /// <param name="number">the absolute value of the number to be rounded</param>
	    /// <param name="roundingInc">the rounding increment</param>
	    /// <param name="roundingIncReciprocal">if non-zero, is the</param>
	    /// <param name="mode">a BigDecimal rounding mode</param>
	    /// <param name="isNegative">true if the number to be rounded is negative</param>
	    /// <returns>the absolute value of the rounded result</returns>
	    private static double Round(double number, double roundingInc,
	            double roundingIncReciprocal, int mode, bool isNegative) {
	
	        double div = (roundingIncReciprocal == 0.0d) ? number / roundingInc
	                : number * roundingIncReciprocal;
	
	        // do the absolute cases first
	
	        switch (mode) {
	        case IBM.ICU.Math.BigDecimal.ROUND_CEILING:
	            div = ((isNegative) ? Math.Floor(div + epsilon) : Math.Ceiling(div
	                                - epsilon));
	            break;
	        case IBM.ICU.Math.BigDecimal.ROUND_FLOOR:
	            div = ((isNegative) ? Math.Ceiling(div - epsilon) : Math.Floor(div
	                                + epsilon));
	            break;
	        case IBM.ICU.Math.BigDecimal.ROUND_DOWN:
	            div = (Math.Floor(div + epsilon));
	            break;
	        case IBM.ICU.Math.BigDecimal.ROUND_UP:
	            div = (Math.Ceiling(div - epsilon));
	            break;
	        case IBM.ICU.Math.BigDecimal.ROUND_UNNECESSARY:
	            if (div != Math.Floor(div)) {
	                throw new ArithmeticException("Rounding necessary");
	            }
	            return number;
	        default:
	
	            // Handle complex cases, where the choice depends on the closer
	            // value.
	
	            // We figure out the distances to the two possible values, ceiling
	            // and floor.
	            // We then go for the diff that is smaller.
	            // Only if they are equal does the mode matter.
	
	            double ceil = Math.Ceiling(div);
	            double ceildiff = ceil - div; // (ceil * roundingInc) - number;
	            double floor = Math.Floor(div);
	            double floordiff = div - floor; // number - (floor * roundingInc);
	
	            // Note that the diff values were those mapped back to the "normal"
	            // space
	            // by using the roundingInc. I don't have access to the original
	            // author of the code
	            // but suspect that that was to produce better result in edge cases
	            // because of machine
	            // precision, rather than simply using the difference between, say,
	            // ceil and div.
	            // However, it didn't work in all cases. Am trying instead using an
	            // epsilon value.
	
	            switch (mode) {
	            case IBM.ICU.Math.BigDecimal.ROUND_HALF_EVEN:
	                // We should be able to just return Math.rint(a), but this
	                // doesn't work in some VMs.
	                // if one is smaller than the other, take the corresponding side
	                if (floordiff + epsilon < ceildiff) {
	                    div = floor;
	                } else if (ceildiff + epsilon < floordiff) {
	                    div = ceil;
	                } else { // they are equal, so we want to round to whichever is
	                         // even
	                    double testFloor = floor / 2;
	                    div = (testFloor == Math.Floor(testFloor)) ? floor : ceil;
	                }
	                break;
	            case IBM.ICU.Math.BigDecimal.ROUND_HALF_DOWN:
	                div = ((floordiff <= ceildiff + epsilon) ? floor : ceil);
	                break;
	            case IBM.ICU.Math.BigDecimal.ROUND_HALF_UP:
	                div = ((ceildiff <= floordiff + epsilon) ? ceil : floor);
	                break;
	            default:
	                throw new ArgumentException("Invalid rounding mode: "
	                        + mode);
	            }
	            break;
	        }
	        number = (roundingIncReciprocal == 0.0d) ? div * roundingInc : div
	                / roundingIncReciprocal;
	        return number;
	    }
	
	    private static double epsilon = 0.00000000001d;
	
	    
	    /// @stable ICU 2.0
	    // [Spark/CDL] Delegate to format_long_StringBuffer_FieldPosition_boolean
	    public override StringBuilder Format(long number, StringBuilder result,
	            FieldPosition fieldPosition) {
	        return Format(number, result, fieldPosition, false);
	    }
	
	    private StringBuilder Format(long number, StringBuilder result,
	            FieldPosition fieldPosition, bool parseAttr) {
	        fieldPosition.SetBeginIndex(0);
	        fieldPosition.SetEndIndex(0);
	
	        // If we are to do rounding, we need to move into the BigDecimal
	        // domain in order to do divide/multiply correctly.
	        // [NEW]
	        if (roundingIncrementICU != null) {
	            return Format(IBM.ICU.Math.BigDecimal.ValueOf(number), result, fieldPosition);
	        }
	
	        bool isNegative = (number < 0);
	        if (isNegative)
	            number = -number;
	
	        // In general, long values always represent real finite numbers, so
	        // we don't have to check for +/- Infinity or NaN. However, there
	        // is one case we have to be careful of: The multiplier can push
	        // a number near MIN_VALUE or MAX_VALUE outside the legal range. We
	        // check for this before multiplying, and if it happens we use
	        // BigInteger
	        // instead.
	        // [NEW]
	        if (multiplier != 1) {
	            bool tooBig = false;
	            if (number < 0) { // This can only happen if number ==
	                              // Long.MIN_VALUE
	                long cutoff = Int64.MinValue / multiplier;
	                tooBig = (number < cutoff);
	            } else {
	                long cutoff_0 = Int64.MaxValue / multiplier;
	                tooBig = (number > cutoff_0);
	            }
	            if (tooBig) {
	                // [Spark/CDL] Use
	                // format_BigInteger_StringBuffer_FieldPosition_boolean instead
	                // parseAttr is used to judge whether to synthesize attributes.
	                return Format(
	                        (isNegative) ? -number : number,
	                        result, fieldPosition, parseAttr);
	            }
	        }
	
	        number *= multiplier;
	         lock (digitList) {
	                    digitList.Set(number, Precision(true));
	                    return Subformat(result, fieldPosition, isNegative, true, parseAttr);
	                }
	    }
	
	    /// <summary>
	    /// <strong><font face=helvetica color=red>NEW</font></strong> Format a
	    /// BigInteger number.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public override StringBuilder FormatObject(Int64 number, StringBuilder result,
	            FieldPosition fieldPosition) {
	        return Format(number, result, fieldPosition, false);
	    }
	
	    // [Spark/CDL]
        /*private StringBuilder FormatObject(Int64 number, StringBuilder result,
	            FieldPosition fieldPosition, bool parseAttr) {
	        // If we are to do rounding, we need to move into the BigDecimal
	        // domain in order to do divide/multiply correctly.
	        if (roundingIncrementICU != null) {
	            return Format(new BigDecimal(number), result, fieldPosition);
	        }
	
	        if (multiplier != 1) {
	            number = number.Multiply(multiplier);
	        }
	
	         lock (digitList) {
	                    digitList.Set(number, Precision(true));
	                    return Subformat(result, fieldPosition, number.Signum() < 0, true,
	                            parseAttr);
	                }
	    }*/
	
	    // #if defined(FOUNDATION10) || defined(J2SE13)
	    // #else
	    /// <summary>
	    /// <strong><font face=helvetica color=red>NEW</font></strong> Format a
	    /// BigDecimal number.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public override StringBuilder Format(Decimal number,
	            StringBuilder result, FieldPosition fieldPosition) {
	        return Format(number, result, fieldPosition, false);
	    }
	
	    private StringBuilder Format(Decimal number,
	            StringBuilder result, FieldPosition fieldPosition, bool parseAttr) {
	        if (multiplier != 1) {
	            number = Decimal.Multiply(number,multiplier);
	        }
	
	        if (roundingIncrement != 0) {
	            number = Decimal.Multiply(number / roundingIncrement,roundingIncrement);
	        }
	
	         lock (digitList) {
	                    digitList.Set(number, Precision(false), !useExponentialNotation
	                            && !AreSignificantDigitsUsed());
	                    return Subformat(result, fieldPosition, (int)number < 0, false,
	                            parseAttr);
	                }
	    }
	
	    // #endif
	
	    /// <summary>
	    /// <strong><font face=helvetica color=red>NEW</font></strong> Format a
	    /// BigDecimal number.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public override StringBuilder Format(BigDecimal number, StringBuilder result,
	            FieldPosition fieldPosition) {
	        /*
	         * This method is just a copy of the corresponding java.math.BigDecimal
	         * method for now. It isn't very efficient since it must create a
	         * conversion object to do math on the rounding increment. In the future
	         * we may try to clean this up, or even better, limit our support to
	         * just one flavor of BigDecimal.
	         */
	        if (multiplier != 1) {
	            number = number.Multiply(IBM.ICU.Math.BigDecimal.ValueOf(multiplier));
	        }
	
	        if (roundingIncrementICU != null) {
	            number = number.Divide(roundingIncrementICU, 0, roundingMode)
	                    .Multiply(roundingIncrementICU);
	        }
	
	         lock (digitList) {
	                    digitList.Set(number, Precision(false), !useExponentialNotation
	                            && !AreSignificantDigitsUsed());
	                    return Subformat(result, fieldPosition, number.Signum() < 0, false);
	                }
	    }
	
	    /// <summary>
	    /// Return true if a grouping separator belongs at the given position, based
	    /// on whether grouping is in use and the values of the primary and secondary
	    /// grouping interval.
	    /// </summary>
	    ///
	    /// <param name="pos">the number of integer digits to the right of the currentposition. Zero indicates the position after the rightmostinteger digit.</param>
	    /// <returns>true if a grouping character belongs at the current position.</returns>
	    private bool IsGroupingPosition(int pos) {
	        bool result = false;
	        if (IsGroupingUsed() && (pos > 0) && (groupingSize > 0)) {
	            if ((groupingSize2 > 0) && (pos > groupingSize)) {
	                result = ((pos - groupingSize) % groupingSize2) == 0;
	            } else {
	                result = pos % groupingSize == 0;
	            }
	        }
	        return result;
	    }
	
	    /// <summary>
	    /// Return the number of fraction digits to display, or the total number of
	    /// digits for significant digit formats and exponential formats.
	    /// </summary>
	    ///
	    private int Precision(bool isIntegral) {
	        if (AreSignificantDigitsUsed()) {
	            return GetMaximumSignificantDigits();
	        } else if (useExponentialNotation) {
	            return GetMinimumIntegerDigits() + GetMaximumFractionDigits();
	        } else {
	            return (isIntegral) ? 0 : GetMaximumFractionDigits();
	        }
	    }
	
	    /// <summary>
	    /// Complete the formatting of a finite number. On entry, the digitList must
	    /// be filled in with the correct digits.
	    /// </summary>
	    ///
	    private StringBuilder Subformat(StringBuilder result,
	            FieldPosition fieldPosition, bool isNegative, bool isInteger) {
	        return Subformat(result, fieldPosition, isNegative, isInteger, false);
	    }
	
	    private StringBuilder Subformat(StringBuilder result,
	            FieldPosition fieldPosition, bool isNegative, bool isInteger,
	            bool parseAttr) {
	        // NOTE: This isn't required anymore because DigitList takes care of
	        // this.
	        //
	        // // The negative of the exponent represents the number of leading
	        // // zeros between the decimal and the first non-zero digit, for
	        // // a value < 0.1 (e.g., for 0.00123, -fExponent == 2). If this
	        // // is more than the maximum fraction digits, then we have an
	        // underflow
	        // // for the printed representation. We recognize this here and set
	        // // the DigitList representation to zero in this situation.
	        //
	        // if (-digitList.decimalAt >= getMaximumFractionDigits())
	        // {
	        // digitList.count = 0;
	        // }
	
	        int i;
	        char zero = symbols.GetZeroDigit();
	        int zeroDelta = zero - '0'; // '0' is the DigitList representation of
	                                    // zero
	        char grouping = (isCurrencyFormat) ? symbols
	                .GetMonetaryGroupingSeparator() : symbols
	                .GetGroupingSeparator();
	        char _decimal = (isCurrencyFormat) ? symbols.GetMonetaryDecimalSeparator()
	                : symbols.GetDecimalSeparator();
	        bool useSigDig = AreSignificantDigitsUsed();
	        int maxIntDig = GetMaximumIntegerDigits();
	        int minIntDig = GetMinimumIntegerDigits();
	
	        /*
	         * Per bug 4147706, DecimalFormat must respect the sign of numbers which
	         * format as zero. This allows sensible computations and preserves
	         * relations such as signum(1/x) = signum(x), where x is +Infinity or
	         * -Infinity. Prior to this fix, we always formatted zero values as if
	         * they were positive. Liu 7/6/98.
	         */
	        if (digitList.IsZero()) {
	            digitList.decimalAt = 0; // Normalize
	        }
	
	        int prefixLen = AppendAffix(result, isNegative, true, parseAttr);
	
	        if (useExponentialNotation) {
	            // Record field information for caller.
	            if (fieldPosition.GetField() == IBM.ICU.Text.NumberFormat.INTEGER_FIELD) {
	                fieldPosition.SetBeginIndex(result.Length);
	                fieldPosition.SetEndIndex(-1);
	            } else if (fieldPosition.GetField() == IBM.ICU.Text.NumberFormat.FRACTION_FIELD) {
	                fieldPosition.SetBeginIndex(-1);
	            }
	
	            // [Spark/CDL]
	            // the begin index of integer part
	            // the end index of integer part
	            // the begin index of fractional part
	            int intBegin = result.Length;
	            int intEnd = -1;
	            int fracBegin = -1;
	
	            int minFracDig = 0;
	            if (useSigDig) {
	                maxIntDig = minIntDig = 1;
	                minFracDig = GetMinimumSignificantDigits() - 1;
	            } else {
	                minFracDig = GetMinimumFractionDigits();
	                if (maxIntDig > MAX_SCIENTIFIC_INTEGER_DIGITS) {
	                    maxIntDig = 1;
	                    if (maxIntDig < minIntDig) {
	                        maxIntDig = minIntDig;
	                    }
	                }
	                if (maxIntDig > minIntDig) {
	                    minIntDig = 1;
	                }
	            }
	
	            // Minimum integer digits are handled in exponential format by
	            // adjusting the exponent. For example, 0.01234 with 3 minimum
	            // integer digits is "123.4E-4".
	
	            // Maximum integer digits are interpreted as indicating the
	            // repeating range. This is useful for engineering notation, in
	            // which the exponent is restricted to a multiple of 3. For
	            // example, 0.01234 with 3 maximum integer digits is "12.34e-3".
	            // If maximum integer digits are defined and are larger than
	            // minimum integer digits, then minimum integer digits are
	            // ignored.
	
	            int exponent = digitList.decimalAt;
	            if (maxIntDig > 1 && maxIntDig != minIntDig) {
	                // A exponent increment is defined; adjust to it.
	                exponent = (exponent > 0) ? (exponent - 1) / maxIntDig
	                        : (exponent / maxIntDig) - 1;
	                exponent *= maxIntDig;
	            } else {
	                // No exponent increment is defined; use minimum integer digits.
	                // If none is specified, as in "#E0", generate 1 integer digit.
	                exponent -= (minIntDig > 0 || minFracDig > 0) ? minIntDig : 1;
	            }
	
	            // We now output a minimum number of digits, and more if there
	            // are more digits, up to the maximum number of digits. We
	            // place the decimal point after the "integer" digits, which
	            // are the first (decimalAt - exponent) digits.
	            int minimumDigits = minIntDig + minFracDig;
	            // The number of integer digits is handled specially if the number
	            // is zero, since then there may be no digits.
	            int integerDigits = (digitList.IsZero()) ? minIntDig
	                    : digitList.decimalAt - exponent;
	            int totalDigits = digitList.count;
	            if (minimumDigits > totalDigits)
	                totalDigits = minimumDigits;
	            if (integerDigits > totalDigits)
	                totalDigits = integerDigits;
	
	            for (i = 0; i < totalDigits; ++i) {
	                if (i == integerDigits) {
	                    // Record field information for caller.
	                    if (fieldPosition.GetField() == IBM.ICU.Text.NumberFormat.INTEGER_FIELD) {
	                        fieldPosition.SetEndIndex(result.Length);
	                    }
	                    // #if defined(FOUNDATION10) || defined(J2SE13)
	                    // #else
	                    // [Spark/CDL] Add attribute for integer part
	                    if (parseAttr) {
	                        intEnd = result.Length;
	                        AddAttribute(IBM.ICU.Text.NumberFormat.Field.INTEGER, intBegin, result.Length);
	                    }
	                    // #endif
	                    result.Append(_decimal);
	                    // #if defined(FOUNDATION10) || defined(J2SE13)
	                    // #else
	                    // [Spark/CDL] Add attribute for decimal separator
	                    if (parseAttr) {
	                        // Length of decimal separator is 1.
	                        int decimalSeparatorBegin = result.Length - 1;
	                        AddAttribute(IBM.ICU.Text.NumberFormat.Field.DECIMAL_SEPARATOR,
	                                decimalSeparatorBegin, result.Length);
	                        fracBegin = result.Length;
	                    }
	                    // #endif
	                    // Record field information for caller.
	                    if (fieldPosition.GetField() == IBM.ICU.Text.NumberFormat.FRACTION_FIELD) {
	                        fieldPosition.SetBeginIndex(result.Length);
	                    }
	                }
	                result.Append((i < digitList.count) ? (char) (digitList.digits[i] + zeroDelta)
	                        : zero);
	            }
	
	            // For ICU compatibility and format 0 to 0E0 with pattern "#E0"
	            // [Richard/GCL]
	            if (digitList.IsZero() && (totalDigits == 0)) {
	                result.Append(zero);
	            }
	
	            // Record field information
	            if (fieldPosition.GetField() == IBM.ICU.Text.NumberFormat.INTEGER_FIELD) {
	                if (fieldPosition.GetEndIndex() < 0) {
	                    fieldPosition.SetEndIndex(result.Length);
	                }
	            } else if (fieldPosition.GetField() == IBM.ICU.Text.NumberFormat.FRACTION_FIELD) {
	                if (fieldPosition.GetBeginIndex() < 0) {
	                    fieldPosition.SetBeginIndex(result.Length);
	                }
	                fieldPosition.SetEndIndex(result.Length);
	            }
	            // #if defined(FOUNDATION10) || defined(J2SE13)
	            // #else
	            // [Spark/CDL] Calcuate the end index of integer part and fractional
	            // part if they are not properly processed yet.
	            if (parseAttr) {
	                if (intEnd < 0) {
	                    AddAttribute(IBM.ICU.Text.NumberFormat.Field.INTEGER, intBegin, result.Length);
	                }
	                if (fracBegin > 0) {
	                    AddAttribute(IBM.ICU.Text.NumberFormat.Field.FRACTION, fracBegin, result.Length);
	                }
	            }
	            // #endif
	
	            // The exponent is output using the pattern-specified minimum
	            // exponent digits. There is no maximum limit to the exponent
	            // digits, since truncating the exponent would result in an
	            // unacceptable inaccuracy.
	            result.Append(symbols.GetExponentSeparator());
	            // #if defined(FOUNDATION10) || defined(J2SE13)
	            // #else
	            // [Spark/CDL] For exponent symbol, add an attribute.
	            if (parseAttr) {
	                AddAttribute(IBM.ICU.Text.NumberFormat.Field.EXPONENT_SYMBOL, result.Length
	                        - symbols.GetExponentSeparator().Length,
	                        result.Length);
	            }
	            // #endif
	            // For zero values, we force the exponent to zero. We
	            // must do this here, and not earlier, because the value
	            // is used to determine integer digit count above.
	            if (digitList.IsZero())
	                exponent = 0;
	
	            bool negativeExponent = exponent < 0;
	            if (negativeExponent) {
	                exponent = -exponent;
	                result.Append(symbols.GetMinusSign());
	                // #if defined(FOUNDATION10) || defined(J2SE13)
	                // #else
	                // [Spark/CDL] If exponent has sign, then add an exponent sign
	                // attribute.
	                if (parseAttr) {
	                    // Length of exponent sign is 1.
	                    AddAttribute(IBM.ICU.Text.NumberFormat.Field.EXPONENT_SIGN, result.Length - 1,
	                            result.Length);
	                }
	                // #endif
	            } else if (exponentSignAlwaysShown) {
	                result.Append(symbols.GetPlusSign());
	                // #if defined(FOUNDATION10) || defined(J2SE13)
	                // #else
	                // [Spark/CDL] Add an plus sign attribute.
	                if (parseAttr) {
	                    // Length of exponent sign is 1.
	                    int expSignBegin = result.Length - 1;
	                    AddAttribute(IBM.ICU.Text.NumberFormat.Field.EXPONENT_SIGN, expSignBegin,
	                            result.Length);
	                }
	                // #endif
	            }
	            int expBegin = result.Length;
	            digitList.Set(exponent);
	            {
	                int expDig = minExponentDigits;
	                if (useExponentialNotation && expDig < 1) {
	                    expDig = 1;
	                }
	                for (i = digitList.decimalAt; i < expDig; ++i)
	                    result.Append(zero);
	            }
	            for (i = 0; i < digitList.decimalAt; ++i) {
	                result.Append((i < digitList.count) ? (char) (digitList.digits[i] + zeroDelta)
	                        : zero);
	            }
	            // #if defined(FOUNDATION10) || defined(J2SE13)
	            // #else
	            // [Spark/CDL] Add attribute for exponent part.
	            if (parseAttr) {
	                AddAttribute(IBM.ICU.Text.NumberFormat.Field.EXPONENT, expBegin, result.Length);
	            }
	            // #endif
	        } else {
	            // [Spark/CDL] Record the integer start index.
	            int intBegin_0 = result.Length;
	            // Record field information for caller.
	            if (fieldPosition.GetField() == IBM.ICU.Text.NumberFormat.INTEGER_FIELD) {
	                fieldPosition.SetBeginIndex(result.Length);
	            }
	
	            int sigCount = 0;
	            int minSigDig = GetMinimumSignificantDigits();
	            int maxSigDig = GetMaximumSignificantDigits();
	            if (!useSigDig) {
	                minSigDig = 0;
	                maxSigDig = Int32.MaxValue;
	            }
	
	            // Output the integer portion. Here 'count' is the total
	            // number of integer digits we will display, including both
	            // leading zeros required to satisfy getMinimumIntegerDigits,
	            // and actual digits present in the number.
	            int count = (useSigDig) ? Math.Max(1,digitList.decimalAt)
	                    : minIntDig;
	            if (digitList.decimalAt > 0 && count < digitList.decimalAt) {
	                count = digitList.decimalAt;
	            }
	
	            // Handle the case where getMaximumIntegerDigits() is smaller
	            // than the real number of integer digits. If this is so, we
	            // output the least significant max integer digits. For example,
	            // the value 1997 printed with 2 max integer digits is just "97".
	
	            int digitIndex = 0; // Index into digitList.fDigits[]
	            if (count > maxIntDig && maxIntDig >= 0) {
	                count = maxIntDig;
	                digitIndex = digitList.decimalAt - count;
	            }
	
	            int sizeBeforeIntegerPart = result.Length;
	            for (i = count - 1; i >= 0; --i) {
	                if (i < digitList.decimalAt && digitIndex < digitList.count
	                        && sigCount < maxSigDig) {
	                    // Output a real digit
	                    byte d = digitList.digits[digitIndex++];
	                    result.Append((char) (d + zeroDelta));
	                    ++sigCount;
	                } else {
	                    // Output a zero (leading or trailing)
	                    result.Append(zero);
	                    if (sigCount > 0) {
	                        ++sigCount;
	                    }
	                }
	
	                // Output grouping separator if necessary.
	                if (IsGroupingPosition(i)) {
	                    result.Append(grouping);
	                    // #if defined(FOUNDATION10) || defined(J2SE13)
	                    // #else
	                    // [Spark/CDL] Add grouping separator attribute here.
	                    if (parseAttr) {
	                        // Length of grouping separator is 1.
	                        AddAttribute(IBM.ICU.Text.NumberFormat.Field.GROUPING_SEPARATOR,
	                                result.Length - 1, result.Length);
	                    }
	                    // #endif
	                }
	            }
	
	            // Record field information for caller.
	            if (fieldPosition.GetField() == IBM.ICU.Text.NumberFormat.INTEGER_FIELD) {
	                fieldPosition.SetEndIndex(result.Length);
	            }
	
	            // Determine whether or not there are any printable fractional
	            // digits. If we've used up the digits we know there aren't.
	            bool fractionPresent = (!isInteger && digitIndex < digitList.count)
	                    || ((useSigDig) ? (sigCount < minSigDig)
	                            : (GetMinimumFractionDigits() > 0));
	
	            // If there is no fraction present, and we haven't printed any
	            // integer digits, then print a zero. Otherwise we won't print
	            // _any_ digits, and we won't be able to parse this string.
	            if (!fractionPresent && result.Length == sizeBeforeIntegerPart)
	                result.Append(zero);
	            // #if defined(FOUNDATION10) || defined(J2SE13)
	            // #else
	            // [Spark/CDL] Add attribute for integer part.
	            if (parseAttr) {
	                AddAttribute(IBM.ICU.Text.NumberFormat.Field.INTEGER, intBegin_0, result.Length);
	            }
	            // #endif
	            // Output the decimal separator if we always do so.
	            if (decimalSeparatorAlwaysShown || fractionPresent) {
	                result.Append(_decimal);
	                // #if defined(FOUNDATION10) || defined(J2SE13)
	                // #else
	                // [Spark/CDL] Add attribute for decimal separator
	                if (parseAttr) {
	                    AddAttribute(IBM.ICU.Text.NumberFormat.Field.DECIMAL_SEPARATOR, result.Length - 1,
	                            result.Length);
	                }
	                // #endif
	            }
	
	            // Record field information for caller.
	            if (fieldPosition.GetField() == IBM.ICU.Text.NumberFormat.FRACTION_FIELD) {
	                fieldPosition.SetBeginIndex(result.Length);
	            }
	
	            // [Spark/CDL] Record the begin index of fraction part.
	            int fracBegin_1 = result.Length;
	
	            count = (useSigDig) ? Int32.MaxValue : GetMaximumFractionDigits();
	            if (useSigDig
	                    && (sigCount == maxSigDig || (sigCount >= minSigDig && digitIndex == digitList.count))) {
	                count = 0;
	            }
	            for (i = 0; i < count; ++i) {
	                // Here is where we escape from the loop. We escape
	                // if we've output the maximum fraction digits
	                // (specified in the for expression above). We also
	                // stop when we've output the minimum digits and
	                // either: we have an integer, so there is no
	                // fractional stuff to display, or we're out of
	                // significant digits.
	                if (!useSigDig && i >= GetMinimumFractionDigits()
	                        && (isInteger || digitIndex >= digitList.count)) {
	                    break;
	                }
	
	                // Output leading fractional zeros. These are zeros
	                // that come after the decimal but before any
	                // significant digits. These are only output if
	                // abs(number being formatted) < 1.0.
	                if (-1 - i > (digitList.decimalAt - 1)) {
	                    result.Append(zero);
	                    continue;
	                }
	
	                // Output a digit, if we have any precision left, or a
	                // zero if we don't. We don't want to output noise digits.
	                if (!isInteger && digitIndex < digitList.count) {
	                    result.Append((char) (digitList.digits[digitIndex++] + zeroDelta));
	                } else {
	                    result.Append(zero);
	                }
	
	                // If we reach the maximum number of significant
	                // digits, or if we output all the real digits and
	                // reach the minimum, then we are done.
	                ++sigCount;
	                if (useSigDig
	                        && (sigCount == maxSigDig || (digitIndex == digitList.count && sigCount >= minSigDig))) {
	                    break;
	                }
	            }
	
	            // Record field information for caller.
	            if (fieldPosition.GetField() == IBM.ICU.Text.NumberFormat.FRACTION_FIELD) {
	                fieldPosition.SetEndIndex(result.Length);
	            }
	            // #if defined(FOUNDATION10) || defined(J2SE13)
	            // #else
	            // [Spark/CDL] Add attribute information if necessary.
	            if (parseAttr && (decimalSeparatorAlwaysShown || fractionPresent)) {
	                AddAttribute(IBM.ICU.Text.NumberFormat.Field.FRACTION, fracBegin_1, result.Length);
	            }
	            // #endif
	        }
	
	        int suffixLen = AppendAffix(result, isNegative, false, parseAttr);
	
	        // [NEW]
	        AddPadding(result, fieldPosition, prefixLen, suffixLen);
	        return result;
	    }
	
	    // [NEW]
	    private void AddPadding(StringBuilder result,
	            FieldPosition fieldPosition, int prefixLen, int suffixLen) {
	        if (formatWidth > 0) {
	            int len = formatWidth - result.Length;
	            if (len > 0) {
	                char[] padding = new char[len];
	                for (int i = 0; i < len; ++i) {
	                    padding[i] = pad;
	                }
	                switch (padPosition) {
	                case PAD_AFTER_PREFIX:
	                    result.Insert(prefixLen, padding);
	                    break;
	                case PAD_BEFORE_PREFIX:
	                    result.Insert(0, padding);
	                    break;
	                case PAD_BEFORE_SUFFIX:
	                    result.Insert(result.Length - suffixLen, padding);
	                    break;
	                case PAD_AFTER_SUFFIX:
	                    result.Append(padding);
	                    break;
	                }
	                if (padPosition == PAD_BEFORE_PREFIX
	                        || padPosition == PAD_AFTER_PREFIX) {
	                    fieldPosition.SetBeginIndex(fieldPosition.GetBeginIndex()
	                            + len);
	                    fieldPosition
	                            .SetEndIndex(fieldPosition.GetEndIndex() + len);
	                }
	            }
	        }
	    }
	
	    /// <summary>
	    /// <strong><font face=helvetica color=red>CHANGED</font></strong> Parse the
	    /// given string, returning a <c>Number</c> object to represent the
	    /// parsed value. <c>Double</c> objects are returned to represent
	    /// non-integral values which cannot be stored in a <c>BigDecimal</c>.
	    /// These are <c>NaN</c>, infinity, -infinity, and -0.0. If<see cref="M:IBM.ICU.Text.DecimalFormat.IsParseBigDecimal"/> is false (the default), all other values are
	    /// returned as <c>Long</c>, <c>BigInteger</c>, or
	    /// <c>BigDecimal</c> values, in that order of preference. If<see cref="M:IBM.ICU.Text.DecimalFormat.IsParseBigDecimal"/> is true, all other values are returned as
	    /// <c>BigDecimal</c> valuse. If the parse fails, null is returned.
	    /// </summary>
	    ///
	    /// <param name="text">the string to be parsed</param>
	    /// <param name="parsePosition">defines the position where parsing is to begin, and uponreturn, the position where parsing left off. If the positionhas not changed upon return, then parsing failed.</param>
	    /// <returns>a <c>Number</c> object with the parsed value or
	    /// <c>null</c> if the parse failed</returns>
	    /// @stable ICU 2.0
	    public override object Parse(String text, ParsePosition parsePosition) {
	        return (object) Parse(text, parsePosition, false);
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// <strong><font face=helvetica color=red>NEW</font></strong> Parses text
	    /// from the given string as a CurrencyAmount. Unlike the parse() method,
	    /// this method will attempt to parse a generic currency name, searching for
	    /// a match of this object's locale's currency display names, or for a
	    /// 3-letter ISO currency code. This method will fail if this format is not a
	    /// currency format, that is, if it does not contain the currency pattern
	    /// symbol (U+00A4) in its prefix or suffix.
	    /// </summary>
	    ///
	    /// <param name="text">the string to parse</param>
	    /// <param name="pos">input-output position; on input, the position within text tomatch; must have 0 <= pos.getIndex() < text.length(); onoutput, the position after the last matched character. If theparse fails, the position in unchanged upon output.</param>
	    /// <returns>a CurrencyAmount, or null upon failure</returns>
	    internal override CurrencyAmount ParseCurrency(String text, ParsePosition pos) {
	        return (CurrencyAmount) Parse(text, pos, true);
	    }
	
	    /// <summary>
	    /// Parses the given text as either a Number or a CurrencyAmount.
	    /// </summary>
	    ///
	    /// <param name="text">the string to parse</param>
	    /// <param name="parsePosition">input-output position; on input, the position within text tomatch; must have 0 <= pos.getIndex() < text.length(); onoutput, the position after the last matched character. If theparse fails, the position in unchanged upon output.</param>
	    /// <param name="parseCurrency">if true, a CurrencyAmount is parsed and returned; otherwise aNumber is parsed and returned</param>
	    /// <returns>a Number or CurrencyAmount or null</returns>
	    private Object Parse(String text, ParsePosition parsePosition,
	            bool parseCurrency) {
	        int backup;
	        int i = backup = parsePosition.GetIndex();
	
	        // Handle NaN as a special case:
	
	        // Skip padding characters, if around prefix
	        if (formatWidth > 0
	                && (padPosition == PAD_BEFORE_PREFIX || padPosition == PAD_AFTER_PREFIX)) {
	            i = SkipPadding(text, i);
	        }
	        if (StringUtil.RegionMatches(text, i, symbols.GetNaN(), 0, symbols.GetNaN().Length)) {
	            i += symbols.GetNaN().Length;
	            // Skip padding characters, if around suffix
	            if (formatWidth > 0
	                    && (padPosition == PAD_BEFORE_SUFFIX || padPosition == PAD_AFTER_SUFFIX)) {
	                i = SkipPadding(text, i);
	            }
	            parsePosition.SetIndex(i);
	            return (double )(System.Double.NaN);
	        }
	
	        // NaN parse failed; start over
	        i = backup;
	
	        bool[] status = new bool[STATUS_LENGTH];
	        Currency[] currency = (parseCurrency) ? new Currency[1] : null;
	        if (!Subparse(text, parsePosition, digitList, false, status, currency)) {
	            parsePosition.SetIndex(backup);
	            return null;
	        }
	
	        object n = null;
	
	        // Handle infinity
	        if (status[STATUS_INFINITE]) {
	            n = (double )((status[STATUS_POSITIVE]) ? System.Double.PositiveInfinity
	                                : System.Double.NegativeInfinity);
	        }
	
	        // Handle -0.0
	        else if (!status[STATUS_POSITIVE] && digitList.IsZero()) {
	            n = (double )(-0.0d);
	        }
	
	        else {
	            // Do as much of the multiplier conversion as possible without
	            // losing accuracy.
	            int mult = multiplier; // Don't modify this.multiplier
	            while (mult % 10 == 0) {
	                --digitList.decimalAt;
	                mult /= 10;
	            }
	
	            // Handle integral values
	            if (!parseBigDecimal && mult == 1 && digitList.IsIntegral()) {
	                // hack quick long
	                if (digitList.decimalAt < 12) { // quick check for long
	                    long l = 0;
	                    if (digitList.count > 0) {
	                        int nx = 0;
	                        while (nx < digitList.count) {
	                            l = l * 10 + (char) digitList.digits[nx++] - '0';
	                        }
	                        while (nx++ < digitList.decimalAt) {
	                            l *= 10;
	                        }
	                        if (!status[STATUS_POSITIVE]) {
	                            l = -l;
	                        }
	                    }
	                    n = (long)(l);
	                } else {
	                    Int64 big = digitList
	                            .GetBigInteger(status[STATUS_POSITIVE]);
	                    n = (Int64Helper.BitCount(big) < 64) ? (object) (long)(Convert.ToInt64(big)) : (object) big;
	                }
	            }
	
	            // Handle non-integral values or the case where parseBigDecimal is
	            // set
	            else {
	                BigDecimal big_0 = digitList
	                        .GetBigDecimalICU(status[STATUS_POSITIVE]);
	                n = big_0;
	                if (mult != 1) {
	                    n = big_0.Divide(IBM.ICU.Math.BigDecimal.ValueOf(mult),
	                            IBM.ICU.Math.BigDecimal.ROUND_HALF_EVEN);
	                }
	            }
	        }
	
	        // Assemble into CurrencyAmount if necessary
	        return (parseCurrency) ? (Object) new CurrencyAmount(n, currency[0])
	                : (Object) n;
	    }
	
	    private const int STATUS_INFINITE = 0;
	
	    private const int STATUS_POSITIVE = 1;
	
	    private const int STATUS_LENGTH = 2;
	
	    /// <summary>
	    /// <strong><font face=helvetica color=red>CHANGED</font></strong> Parse the
	    /// given text into a number. The text is parsed beginning at parsePosition,
	    /// until an unparseable character is seen.
	    /// </summary>
	    ///
	    /// <param name="text">The string to parse.</param>
	    /// <param name="parsePosition">The position at which to being parsing. Upon return, the firstunparseable character.</param>
	    /// <param name="digits">The DigitList to set to the parsed value.</param>
	    /// <param name="isExponent">If true, parse an exponent. This means no infinite values andinteger only.</param>
	    /// <param name="status">Upon return contains boolean status flags indicating whetherthe value was infinite and whether it was positive.</param>
	    /// <param name="currency">return value for parsed currency, for generic currency parsingmode, or null for normal parsing. In generic currency parsingmode, any currency is parsed, not just the currency that thisformatter is set to.</param>
	    private bool Subparse(String text, ParsePosition parsePosition,
	            DigitList digits, bool isExponent, bool[] status,
	            Currency[] currency) {
	        int position = parsePosition.GetIndex();
	        int oldStart = parsePosition.GetIndex();
	
	        // Match padding before prefix
	        if (formatWidth > 0 && padPosition == PAD_BEFORE_PREFIX) {
	            position = SkipPadding(text, position);
	        }
	
	        // Match positive and negative prefixes; prefer longest match.
	        int posMatch = CompareAffix(text, position, false, true, currency);
	        int negMatch = CompareAffix(text, position, true, true, currency);
	        if (posMatch >= 0 && negMatch >= 0) {
	            if (posMatch > negMatch) {
	                negMatch = -1;
	            } else if (negMatch > posMatch) {
	                posMatch = -1;
	            }
	        }
	        if (posMatch >= 0) {
	            position += posMatch;
	        } else if (negMatch >= 0) {
	            position += negMatch;
	        } else {
	            parsePosition.SetErrorIndex(position);
	            return false;
	        }
	
	        // Match padding after prefix
	        if (formatWidth > 0 && padPosition == PAD_AFTER_PREFIX) {
	            position = SkipPadding(text, position);
	        }
	
	        // process digits or Inf, find decimal position
	        status[STATUS_INFINITE] = false;
	        if (!isExponent
	                && StringUtil.RegionMatches(text, position, symbols.GetInfinity(), 0,
	                        symbols.GetInfinity().Length)) {
	            position += symbols.GetInfinity().Length;
	            status[STATUS_INFINITE] = true;
	        } else {
	            // We now have a string of digits, possibly with grouping symbols,
	            // and decimal points. We want to process these into a DigitList.
	            // We don't want to put a bunch of leading zeros into the DigitList
	            // though, so we keep track of the location of the decimal point,
	            // put only significant digits into the DigitList, and adjust the
	            // exponent as needed.
	
	            digits.decimalAt = digits.count = 0;
	            char zero = symbols.GetZeroDigit();
	            char _decimal = (isCurrencyFormat) ? symbols
	                    .GetMonetaryDecimalSeparator() : symbols
	                    .GetDecimalSeparator();
	            char grouping = symbols.GetGroupingSeparator();
	            String exponentSep = symbols.GetExponentSeparator();
	            bool sawDecimal = false;
	            bool sawExponent = false;
	            bool sawDigit = false;
	            int exponent = 0; // Set to the exponent value, if any
	            int digit = 0;
	
	            // strict parsing
	            bool strictParse = IsParseStrict();
	            bool strictFail = false; // did we exit with a strict parse
	                                        // failure?
	            bool leadingZero = false; // did we see a leading zero?
	            int lastGroup = -1; // where did we last see a grouping separator?
	            int prevGroup = -1; // where did we see the grouping separator
	                                // before that?
	            int gs2 = (groupingSize2 == 0) ? groupingSize : groupingSize2;
	
	            // We have to track digitCount ourselves, because digits.count will
	            // pin when the maximum allowable digits is reached.
	            int digitCount = 0;
	
	            int backup = -1;
	            for (; position < text.Length; ++position) {
	                char ch = text[position];
	
	                /*
	                 * We recognize all digit ranges, not only the Latin digit range
	                 * '0'..'9'. We do so by using the UCharacter.digit() method,
	                 * which converts a valid Unicode digit to the range 0..9.
	                 * 
	                 * The character 'ch' may be a digit. If so, place its value
	                 * from 0 to 9 in 'digit'. First try using the locale digit,
	                 * which may or MAY NOT be a standard Unicode digit range. If
	                 * this fails, try using the standard Unicode digit ranges by
	                 * calling UCharacter.digit(). If this also fails, digit will
	                 * have a value outside the range 0..9.
	                 */
	                digit = ch - zero;
	                if (digit < 0 || digit > 9)
	                    digit = IBM.ICU.Lang.UCharacter.Digit(ch, 10);
	
	                if (digit == 0) {
	                    // Cancel out backup setting (see grouping handler below)
	                    if (strictParse && backup != -1) {
	                        // comma followed by digit, so group before comma is a
	                        // secondary group. If there was a group separator
	                        // before that, the group must == the secondary group
	                        // length, else it can be <= the the secondary group
	                        // length.
	                        if ((lastGroup != -1 && backup - lastGroup - 1 != gs2)
	                                || (lastGroup == -1 && position - oldStart - 1 > gs2)) {
	                            strictFail = true;
	                            break;
	                        }
	                        prevGroup = lastGroup;
	                        lastGroup = backup;
	                    }
	                    backup = -1; // Do this BEFORE continue statement below!!!
	                    sawDigit = true;
	
	                    // Handle leading zeros
	                    if (digits.count == 0) {
	                        if (!sawDecimal) {
	                            if (strictParse && !isExponent) {
	                                // Allow leading zeros in exponents
	                                if (leadingZero) {
	                                    strictFail = true;
	                                    break;
	                                }
	                                leadingZero = true;
	                            }
	                            // Ignore leading zeros in integer part of number.
	                            continue;
	                        }
	
	                        // If we have seen the decimal, but no significant
	                        // digits yet,
	                        // then we account for leading zeros by decrementing the
	                        // digits.decimalAt into negative values.
	                        --digits.decimalAt;
	                    } else {
	                        ++digitCount;
	                        digits.Append((char) (digit + '0'));
	                    }
	                } else if (digit > 0 && digit <= 9) // [sic] digit==0 handled
	                                                    // above
	                {
	                    if (strictParse) {
	                        if (leadingZero) {
	                            // a leading zero before a digit is an error with
	                            // strict parsing
	                            strictFail = true;
	                            break;
	                        }
	                        if (backup != -1) {
	                            if ((lastGroup != -1 && backup - lastGroup - 1 != gs2)
	                                    || (lastGroup == -1 && position - oldStart
	                                            - 1 > gs2)) {
	                                strictFail = true;
	                                break;
	                            }
	                            prevGroup = lastGroup;
	                            lastGroup = backup;
	                        }
	                    }
	
	                    sawDigit = true;
	                    ++digitCount;
	                    digits.Append((char) (digit + '0'));
	
	                    // Cancel out backup setting (see grouping handler below)
	                    backup = -1;
	                } else if (!isExponent && ch == _decimal) {
	                    if (strictParse) {
	                        if (backup != -1
	                                || (lastGroup != -1 && position - lastGroup != groupingSize + 1)) {
	                            strictFail = true;
	                            break;
	                        }
	                    }
	                    // If we're only parsing integers, or if we ALREADY saw the
	                    // decimal, then don't parse this one.
	                    if (IsParseIntegerOnly() || sawDecimal)
	                        break;
	                    digits.decimalAt = digitCount; // Not digits.count!
	                    sawDecimal = true;
	                    leadingZero = false; // a single leading zero before a
	                                         // decimal is ok
	                } else if (!isExponent && ch == grouping && IsGroupingUsed()) {
	                    if (sawDecimal) {
	                        break;
	                    }
	                    if (strictParse) {
	                        if ((!sawDigit || backup != -1)) {
	                            // leading group, or two group separators in a row
	                            strictFail = true;
	                            break;
	                        }
	                    }
	                    // Ignore grouping characters, if we are using them, but
	                    // require
	                    // that they be followed by a digit. Otherwise we backup and
	                    // reprocess them.
	                    backup = position;
	                } else if (!isExponent
	                        && !sawExponent
	                        && StringUtil.RegionMatches(text, position, exponentSep, 0,
	                                exponentSep.Length)) {
	                    // Parse sign, if present
	                    bool negExp = false;
	                    int pos = position + exponentSep.Length;
	                    if (pos < text.Length) {
	                        ch = text[pos];
	                        if (ch == symbols.GetPlusSign()) {
	                            ++pos;
	                        } else if (ch == symbols.GetMinusSign()) {
	                            ++pos;
	                            negExp = true;
	                        }
	                    }
	
	                    DigitList exponentDigits = new DigitList();
	                    exponentDigits.count = 0;
	                    while (pos < text.Length) {
	                        digit = text[pos] - zero;
	                        if (digit < 0 || digit > 9) {
	                            /*
	                             * Can't parse "[1E0]" when pattern is
	                             * "0.###E0;[0.###E0]" Should update reassign the
	                             * value of 'ch' in the code: digit =
	                             * Character.digit(ch, 10); [Richard/GCL]
	                             */
	                            digit = IBM.ICU.Lang.UCharacter.Digit(text[pos], 10);
	                        }
	                        if (digit >= 0 && digit <= 9) {
	                            exponentDigits.Append((char) (digit + '0'));
	                            ++pos;
	                        } else {
	                            break;
	                        }
	                    }
	
	                    if (exponentDigits.count > 0) {
	                        // defer strict parse until we know we have a bona-fide
	                        // exponent
	                        if (strictParse) {
	                            if (backup != -1 || lastGroup != -1) {
	                                strictFail = true;
	                                break;
	                            }
	                        }
	
	                        exponentDigits.decimalAt = exponentDigits.count;
	                        exponent = (int) exponentDigits.GetLong();
	                        if (negExp) {
	                            exponent = -exponent;
	                        }
	                        position = pos; // Advance past the exponent
	                        sawExponent = true;
	                    }
	
	                    break; // Whether we fail or succeed, we exit this loop
	                } else
	                    break;
	            }
	
	            if (backup != -1)
	                position = backup;
	
	            if (strictParse && !sawDecimal) {
	                if (lastGroup != -1 && position - lastGroup != groupingSize + 1) {
	                    strictFail = true;
	                }
	            }
	            if (strictFail) {
	                // only set with strictParse and a leading zero error
	                // leading zeros are an error with strict parsing except
	                // immediately before nondigit (except group separator
	                // followed by digit), or end of text.
	
	                parsePosition.SetIndex(oldStart);
	                parsePosition.SetErrorIndex(position);
	                return false;
	            }
	
	            // If there was no decimal point we have an integer
	            if (!sawDecimal)
	                digits.decimalAt = digitCount; // Not digits.count!
	
	            // Adjust for exponent, if any
	            digits.decimalAt += exponent;
	
	            // If none of the text string was recognized. For example, parse
	            // "x" with pattern "#0.00" (return index and error index both 0)
	            // parse "$" with pattern "$#0.00". (return index 0 and error index
	            // 1).
	            if (!sawDigit && digitCount == 0) {
	                parsePosition.SetIndex(oldStart);
	                parsePosition.SetErrorIndex(oldStart);
	                return false;
	            }
	        }
	
	        // Match padding before suffix
	        if (formatWidth > 0 && padPosition == PAD_BEFORE_SUFFIX) {
	            position = SkipPadding(text, position);
	        }
	
	        // Match positive and negative suffixes; prefer longest match.
	        if (posMatch >= 0) {
	            posMatch = CompareAffix(text, position, false, false, currency);
	        }
	        if (negMatch >= 0) {
	            negMatch = CompareAffix(text, position, true, false, currency);
	        }
	        if (posMatch >= 0 && negMatch >= 0) {
	            if (posMatch > negMatch) {
	                negMatch = -1;
	            } else if (negMatch > posMatch) {
	                posMatch = -1;
	            }
	        }
	
	        // Fail if neither or both
	        if ((posMatch >= 0) == (negMatch >= 0)) {
	            parsePosition.SetErrorIndex(position);
	            return false;
	        }
	
	        position += ((posMatch >= 0) ? posMatch : negMatch);
	
	        // Match padding after suffix
	        if (formatWidth > 0 && padPosition == PAD_AFTER_SUFFIX) {
	            position = SkipPadding(text, position);
	        }
	
	        parsePosition.SetIndex(position);
	
	        status[STATUS_POSITIVE] = (posMatch >= 0);
	
	        if (parsePosition.GetIndex() == oldStart) {
	            parsePosition.SetErrorIndex(position);
	            return false;
	        }
	        return true;
	    }
	
	    /// <summary>
	    /// Starting at position, advance past a run of pad characters, if any.
	    /// Return the index of the first character after position that is not a pad
	    /// character. Result is >= position.
	    /// </summary>
	    ///
	    private int SkipPadding(String text, int position) {
	        while (position < text.Length && text[position] == pad) {
	            ++position;
	        }
	        return position;
	    }
	
	    /// <summary>
	    /// Return the length matched by the given affix, or -1 if none. Runs of
	    /// white space in the affix, match runs of white space in the input. Pattern
	    /// white space and input white space are determined differently; see code.
	    /// </summary>
	    ///
	    /// <param name="text">input text</param>
	    /// <param name="pos">offset into input at which to begin matching</param>
	    /// <param name="isNegative"></param>
	    /// <param name="isPrefix"></param>
	    /// <param name="currency">return value for parsed currency, for generic currency parsingmode, or null for normal parsing. In generic currency parsingmode, any currency is parsed, not just the currency that thisformatter is set to.</param>
	    /// <returns>length of input that matches, or -1 if match failure</returns>
	    private int CompareAffix(String text, int pos, bool isNegative,
	            bool isPrefix, Currency[] currency) {
	        if (currency != null || currencyChoice != null) {
	            if (isPrefix) {
	                return CompareComplexAffix((isNegative) ? negPrefixPattern
	                        : posPrefixPattern, text, pos, currency);
	            } else {
	                return CompareComplexAffix((isNegative) ? negSuffixPattern
	                        : posSuffixPattern, text, pos, currency);
	            }
	        }
	
	        if (isPrefix) {
	            return CompareSimpleAffix((isNegative) ? negativePrefix
	                    : positivePrefix, text, pos);
	        } else {
	            return CompareSimpleAffix((isNegative) ? negativeSuffix
	                    : positiveSuffix, text, pos);
	        }
	    }
	
	    /// <summary>
	    /// Return the length matched by the given affix, or -1 if none. Runs of
	    /// white space in the affix, match runs of white space in the input. Pattern
	    /// white space and input white space are determined differently; see code.
	    /// </summary>
	    ///
	    /// <param name="affix">pattern string, taken as a literal</param>
	    /// <param name="input">input text</param>
	    /// <param name="pos">offset into input at which to begin matching</param>
	    /// <returns>length of input that matches, or -1 if match failure</returns>
	    private static int CompareSimpleAffix(String affix, String input, int pos) {
	        int start = pos;
	        for (int i = 0; i < affix.Length;) {
	            int c = IBM.ICU.Text.UTF16.CharAt(affix, i);
	            int len = IBM.ICU.Text.UTF16.GetCharCount(c);
	            if (IBM.ICU.Impl.UCharacterProperty.IsRuleWhiteSpace(c)) {
	                // We may have a pattern like: \u200F
	                // and input text like: \u200F
	                // Note that U+200F and U+0020 are RuleWhiteSpace but only
	                // U+0020 is UWhiteSpace. So we have to first do a direct
	                // match of the run of RULE whitespace in the pattern,
	                // then match any extra characters.
	                bool literalMatch = false;
	                while (pos < input.Length && IBM.ICU.Text.UTF16.CharAt(input, pos) == c) {
	                    literalMatch = true;
	                    i += len;
	                    pos += len;
	                    if (i == affix.Length) {
	                        break;
	                    }
	                    c = IBM.ICU.Text.UTF16.CharAt(affix, i);
	                    len = IBM.ICU.Text.UTF16.GetCharCount(c);
	                    if (!IBM.ICU.Impl.UCharacterProperty.IsRuleWhiteSpace(c)) {
	                        break;
	                    }
	                }
	
	                // Advance over run in affix
	                i = SkipRuleWhiteSpace(affix, i);
	
	                // Advance over run in input text
	                // Must see at least one white space char in input,
	                // unless we've already matched some characters literally.
	                int s = pos;
	                pos = SkipUWhiteSpace(input, pos);
	                if (pos == s && !literalMatch) {
	                    return -1;
	                }
	            } else {
	                if (pos < input.Length && IBM.ICU.Text.UTF16.CharAt(input, pos) == c) {
	                    i += len;
	                    pos += len;
	                } else {
	                    return -1;
	                }
	            }
	        }
	        return pos - start;
	    }
	
	    /// <summary>
	    /// Skip over a run of zero or more isRuleWhiteSpace() characters at pos in
	    /// text.
	    /// </summary>
	    ///
	    private static int SkipRuleWhiteSpace(String text, int pos) {
	        while (pos < text.Length) {
	            int c = IBM.ICU.Text.UTF16.CharAt(text, pos);
	            if (!IBM.ICU.Impl.UCharacterProperty.IsRuleWhiteSpace(c)) {
	                break;
	            }
	            pos += IBM.ICU.Text.UTF16.GetCharCount(c);
	        }
	        return pos;
	    }
	
	    /// <summary>
	    /// Skip over a run of zero or more isUWhiteSpace() characters at pos in
	    /// text.
	    /// </summary>
	    ///
	    private static int SkipUWhiteSpace(String text, int pos) {
	        while (pos < text.Length) {
	            int c = IBM.ICU.Text.UTF16.CharAt(text, pos);
	            if (!IBM.ICU.Lang.UCharacter.IsUWhiteSpace(c)) {
	                break;
	            }
	            pos += IBM.ICU.Text.UTF16.GetCharCount(c);
	        }
	        return pos;
	    }
	
	    /// <summary>
	    /// Return the length matched by the given affix, or -1 if none.
	    /// </summary>
	    ///
	    /// <param name="affixPat">pattern string</param>
	    /// <param name="text">input text</param>
	    /// <param name="pos">offset into input at which to begin matching</param>
	    /// <param name="currency">return value for parsed currency, for generic currency parsingmode, or null for normal parsing. In generic currency parsingmode, any currency is parsed, not just the currency that thisformatter is set to.</param>
	    /// <returns>length of input that matches, or -1 if match failure</returns>
	    private int CompareComplexAffix(String affixPat, String text, int pos,
	            Currency[] currency) {
	
	        for (int i = 0; i < affixPat.Length && pos >= 0;) {
	            char c = affixPat[i++];
	            if (c == QUOTE) {
	                for (;;) {
	                    int j = affixPat.IndexOf(QUOTE, i);
	                    if (j == i) {
	                        pos = Match(text, pos, QUOTE);
	                        i = j + 1;
	                        break;
	                    } else if (j > i) {
	                        pos = Match(text, pos, affixPat.Substring(i,(j)-(i)));
	                        i = j + 1;
	                        if (i < affixPat.Length
	                                && affixPat[i] == QUOTE) {
	                            pos = Match(text, pos, QUOTE);
	                            ++i;
	                            // loop again
	                        } else {
	                            break;
	                        }
	                    } else {
	                        // Unterminated quote; should be caught by apply
	                        // pattern.
	                        throw new Exception();
	                    }
	                }
	                continue;
	            }
	
	            switch ((int) c) {
	            case CURRENCY_SIGN:
	                // If currency != null, then perform generic currency matching.
	                // Otherwise, do currency choice parsing.
	                // assert(currency != null ||
	                // (getCurrency() != null && currencyChoice != null));
	                bool intl = i < affixPat.Length
	                        && affixPat[i] == CURRENCY_SIGN;
	
	                // Parse generic currency -- anything for which we
	                // have a display name, or any 3-letter ISO code.
	                if (currency != null) {
	                    // Try to parse display name for our locale; first
	                    // determine our locale.
	                    ULocale uloc = GetLocale(IBM.ICU.Util.ULocale.VALID_LOCALE);
	                    if (uloc == null) {
	                        // applyPattern has been called; use the symbols
	                        uloc = symbols.GetLocale(IBM.ICU.Util.ULocale.VALID_LOCALE);
	                    }
	                    // Delegate parse of display name => ISO code to Currency
	                    ParsePosition ppos = new ParsePosition(pos);
	                    String iso = IBM.ICU.Util.Currency.Parse(uloc, text, ppos);
	
	                    // If parse succeeds, populate currency[0]
	                    if (iso != null) {
	                        currency[0] = IBM.ICU.Util.Currency.GetInstance(iso);
	                        pos = ppos.GetIndex();
	                    } else {
	                        pos = -1;
	                    }
	                } else {
	                    if (intl) {
	                        ++i;
	                        pos = Match(text, pos, GetCurrency().GetCurrencyCode());
	                    } else {
	                        ParsePosition ppos_0 = new ParsePosition(pos);
	                        /* Number n = */currencyChoice.Parse(text, ppos_0);
	                        pos = (ppos_0.GetIndex() == pos) ? -1 : ppos_0.GetIndex();
	                    }
	                }
	                continue;
	            case PATTERN_PERCENT:
	                c = symbols.GetPercent();
	                break;
	            case PATTERN_PER_MILLE:
	                c = symbols.GetPerMill();
	                break;
	            case PATTERN_MINUS:
	                c = symbols.GetMinusSign();
	                break;
	            }
	            pos = Match(text, pos, c);
	            if (IBM.ICU.Impl.UCharacterProperty.IsRuleWhiteSpace(c)) {
	                i = SkipRuleWhiteSpace(affixPat, i);
	            }
	        }
	
	        return pos;
	    }
	
	    /// <summary>
	    /// Match a single character at text[pos] and return the index of the next
	    /// character upon success. Return -1 on failure. If isRuleWhiteSpace(ch)
	    /// then match a run of white space in text.
	    /// </summary>
	    ///
	    static internal int Match(String text, int pos, int ch) {
	        if (IBM.ICU.Impl.UCharacterProperty.IsRuleWhiteSpace(ch)) {
	            // Advance over run of white space in input text
	            // Must see at least one white space char in input
	            int s = pos;
	            pos = SkipUWhiteSpace(text, pos);
	            if (pos == s) {
	                return -1;
	            }
	            return pos;
	        }
	        return (pos >= 0 && IBM.ICU.Text.UTF16.CharAt(text, pos) == ch) ? (pos + IBM.ICU.Text.UTF16
	                .GetCharCount(ch)) : -1;
	    }
	
	    /// <summary>
	    /// Match a string at text[pos] and return the index of the next character
	    /// upon success. Return -1 on failure. Match a run of white space in str
	    /// with a run of white space in text.
	    /// </summary>
	    ///
	    static internal int Match(String text, int pos, String str) {
	        for (int i = 0; i < str.Length && pos >= 0;) {
	            int ch = IBM.ICU.Text.UTF16.CharAt(str, i);
	            i += IBM.ICU.Text.UTF16.GetCharCount(ch);
	            pos = Match(text, pos, ch);
	            if (IBM.ICU.Impl.UCharacterProperty.IsRuleWhiteSpace(ch)) {
	                i = SkipRuleWhiteSpace(str, i);
	            }
	        }
	        return pos;
	    }
	
	    /// <summary>
	    /// Returns a copy of the decimal format symbols used by this format.
	    /// </summary>
	    ///
	    /// <returns>desired DecimalFormatSymbols</returns>
	    /// <seealso cref="T:IBM.ICU.Text.DecimalFormatSymbols"/>
	    /// @stable ICU 2.0
	    public DecimalFormatSymbols GetDecimalFormatSymbols() {
	        try {
	            // don't allow multiple references
	            return (DecimalFormatSymbols) symbols.Clone();
	        } catch (Exception foo) {
	            return null; // should never happen
	        }
	    }
	
	    /// <summary>
	    /// Sets the decimal format symbols used by this format. The format uses a
	    /// copy of the provided symbols.
	    /// </summary>
	    ///
	    /// <param name="newSymbols">desired DecimalFormatSymbols</param>
	    /// <seealso cref="T:IBM.ICU.Text.DecimalFormatSymbols"/>
	    /// @stable ICU 2.0
	    public void SetDecimalFormatSymbols(DecimalFormatSymbols newSymbols) {
	        symbols = (DecimalFormatSymbols) newSymbols.Clone();
	        SetCurrencyForSymbols();
	        ExpandAffixes();
	    }
	
	    /// <summary>
	    /// Update the currency object to match the symbols. This method is used only
	    /// when the caller has passed in a symbols object that may not be the
	    /// default object for its locale.
	    /// </summary>
	    ///
	    private void SetCurrencyForSymbols() {
	        /*
	         * Bug 4212072 Update the affix strings accroding to symbols in order to
	         * keep the affix strings up to date. [Richard/GCL]
	         */
	
	        // With the introduction of the Currency object, the currency
	        // symbols in the DFS object are ignored. For backward
	        // compatibility, we check any explicitly set DFS object. If it
	        // is a default symbols object for its locale, we change the
	        // currency object to one for that locale. If it is custom,
	        // we set the currency to null.
	        DecimalFormatSymbols def = new DecimalFormatSymbols(symbols.GetLocale());
	
	        if (symbols.GetCurrencySymbol().Equals(def.GetCurrencySymbol())
	                && symbols.GetInternationalCurrencySymbol().Equals(
	                        def.GetInternationalCurrencySymbol())) {
	            SetCurrency(IBM.ICU.Util.Currency.GetInstance(symbols.GetLocale()));
	        } else {
	            SetCurrency(null);
	        }
	    }
	
	    /// <summary>
	    /// Get the positive prefix.
	    /// <P>
	    /// Examples: +123, $123, sFr123
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public String GetPositivePrefix() {
	        return positivePrefix;
	    }
	
	    /// <summary>
	    /// Set the positive prefix.
	    /// <P>
	    /// Examples: +123, $123, sFr123
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public void SetPositivePrefix(String newValue) {
	        positivePrefix = newValue;
	        posPrefixPattern = null;
	    }
	
	    /// <summary>
	    /// Get the negative prefix.
	    /// <P>
	    /// Examples: -123, ($123) (with negative suffix), sFr-123
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public String GetNegativePrefix() {
	        return negativePrefix;
	    }
	
	    /// <summary>
	    /// Set the negative prefix.
	    /// <P>
	    /// Examples: -123, ($123) (with negative suffix), sFr-123
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public void SetNegativePrefix(String newValue) {
	        negativePrefix = newValue;
	        negPrefixPattern = null;
	    }
	
	    /// <summary>
	    /// Get the positive suffix.
	    /// <P>
	    /// Example: 123%
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public String GetPositiveSuffix() {
	        return positiveSuffix;
	    }
	
	    /// <summary>
	    /// Set the positive suffix.
	    /// <P>
	    /// Example: 123%
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public void SetPositiveSuffix(String newValue) {
	        positiveSuffix = newValue;
	        posSuffixPattern = null;
	    }
	
	    /// <summary>
	    /// Get the negative suffix.
	    /// <P>
	    /// Examples: -123%, ($123) (with positive suffixes)
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public String GetNegativeSuffix() {
	        return negativeSuffix;
	    }
	
	    /// <summary>
	    /// Set the positive suffix.
	    /// <P>
	    /// Examples: 123%
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public void SetNegativeSuffix(String newValue) {
	        negativeSuffix = newValue;
	        negSuffixPattern = null;
	    }
	
	    /// <summary>
	    /// Get the multiplier for use in percent, permill, etc. For a percentage,
	    /// set the suffixes to have "%" and the multiplier to be 100. (For Arabic,
	    /// use arabic percent symbol). For a permill, set the suffixes to have
	    /// "\u2031" and the multiplier to be 1000.
	    /// <P>
	    /// Examples: with 100, 1.23 -> "123", and "123" -> 1.23
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public int GetMultiplier() {
	        return multiplier;
	    }
	
	    /// <summary>
	    /// Set the multiplier for use in percent, permill, etc. For a percentage,
	    /// set the suffixes to have "%" and the multiplier to be 100. (For Arabic,
	    /// use arabic percent symbol). For a permill, set the suffixes to have
	    /// "\u2031" and the multiplier to be 1000.
	    /// <P>
	    /// Examples: with 100, 1.23 -> "123", and "123" -> 1.23
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public void SetMultiplier(int newValue) {
	        if (newValue <= 0) {
	            throw new ArgumentException("Bad multiplier: " + newValue);
	        }
	        multiplier = newValue;
	    }
	
	    /// <summary>
	    /// <strong><font face=helvetica color=red>NEW</font></strong> Get the
	    /// rounding increment.
	    /// </summary>
	    ///
	    /// <returns>A positive rounding increment, or <c>null</c> if rounding
	    /// is not in effect.</returns>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.SetRoundingIncrement(System.Decimal)"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.GetRoundingMode"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.SetRoundingMode(System.Int32)"/>
	    /// @stable ICU 2.0
	    // #if defined(FOUNDATION10) || defined(J2SE13) || defined(ECLIPSE_FRAGMENT)
	    // ## public BigDecimal getRoundingIncrement() {
	    // ## if (roundingIncrementICU == null) return null;
	    // ## return new BigDecimal(roundingIncrementICU.toString());
	    // ## }
	    // #else
	    public Decimal GetRoundingIncrement() {
	        if (roundingIncrementICU == null)
	            return default(decimal);
	        return roundingIncrementICU.ToBigDecimal();
	    }
	
	    // #endif
	
	    // #if defined(FOUNDATION10) || defined(J2SE13)
	    // #else
	    /// <summary>
	    /// <strong><font face=helvetica color=red>NEW</font></strong> Set the
	    /// rounding increment. This method also controls whether rounding is
	    /// enabled.
	    /// </summary>
	    ///
	    /// <param name="newValue">A positive rounding increment, or <c>null</c> or<c>BigDecimal(0.0)</c> to disable rounding.</param>
	    /// <exception cref="IllegalArgumentException">if <c>newValue</c> is < 0.0</exception>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.GetRoundingIncrement"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.GetRoundingMode"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.SetRoundingMode(System.Int32)"/>
	    /// @stable ICU 2.0
	    public void SetRoundingIncrement(Decimal newValue) {
	        if (newValue == null) {
	            SetRoundingIncrement((BigDecimal) null);
	        } else {
	            SetRoundingIncrement(new BigDecimal(newValue));
	        }
	    }
	
	    // #endif
	
	    /// <summary>
	    /// <strong><font face=helvetica color=red>NEW</font></strong> Set the
	    /// rounding increment. This method also controls whether rounding is
	    /// enabled.
	    /// </summary>
	    ///
	    /// <param name="newValue">A positive rounding increment, or <c>null</c> or<c>BigDecimal(0.0)</c> to disable rounding.</param>
	    /// <exception cref="IllegalArgumentException">if <c>newValue</c> is < 0.0</exception>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.GetRoundingIncrement"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.GetRoundingMode"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.SetRoundingMode(System.Int32)"/>
	    /// @stable ICU 3.6
	    public void SetRoundingIncrement(BigDecimal newValue) {
	        int i = (newValue == null) ? 0 : newValue.CompareTo(IBM.ICU.Math.BigDecimal.ZERO);
	        if (i < 0) {
	            throw new ArgumentException("Illegal rounding increment");
	        }
	        if (i == 0) {
	            SetInternalRoundingIncrement(null);
	        } else {
	            SetInternalRoundingIncrement(newValue);
	        }
	        SetRoundingDouble();
	    }
	
	    /// <summary>
	    /// <strong><font face=helvetica color=red>NEW</font></strong> Set the
	    /// rounding increment. This method also controls whether rounding is
	    /// enabled.
	    /// </summary>
	    ///
	    /// <param name="newValue">A positive rounding increment, or 0.0 to disable rounding.</param>
	    /// <exception cref="IllegalArgumentException">if <c>newValue</c> is < 0.0</exception>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.GetRoundingIncrement"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.GetRoundingMode"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.SetRoundingMode(System.Int32)"/>
	    /// @stable ICU 2.0
	    public void SetRoundingIncrement(double newValue) {
	        if (newValue < 0.0d) {
	            throw new ArgumentException("Illegal rounding increment");
	        }
	        roundingDouble = newValue;
	        roundingDoubleReciprocal = 0.0d;
	        if (newValue == 0.0d) {
	            SetRoundingIncrement((BigDecimal) null);
	        } else {
	            roundingDouble = newValue;
	            if (roundingDouble < 1.0d) {
	                double rawRoundedReciprocal = 1.0d / roundingDouble;
	                SetRoundingDoubleReciprocal(rawRoundedReciprocal);
	            }
	            SetInternalRoundingIncrement(new BigDecimal(newValue));
	        }
	    }
	
	    private void SetRoundingDoubleReciprocal(double rawRoundedReciprocal) {
	        roundingDoubleReciprocal = Math.Round(rawRoundedReciprocal);
	        if (Math.Abs(rawRoundedReciprocal - roundingDoubleReciprocal) > roundingIncrementEpsilon) {
	            roundingDoubleReciprocal = 0.0d;
	        }
	    }
	
	    internal const double roundingIncrementEpsilon = 0.000000001d;
	
	    /// <summary>
	    /// <strong><font face=helvetica color=red>NEW</font></strong> Get the
	    /// rounding mode.
	    /// </summary>
	    ///
	    /// <returns>A rounding mode, between <c>BigDecimal.ROUND_UP</c> and
	    /// <c>BigDecimal.ROUND_UNNECESSARY</c>.</returns>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.SetRoundingIncrement(System.Decimal)"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.GetRoundingIncrement"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.SetRoundingMode(System.Int32)"/>
	    /// <seealso cref="T:System.Decimal"/>
	    /// @stable ICU 2.0
	    public int GetRoundingMode() {
	        return roundingMode;
	    }
	
	    /// <summary>
	    /// <strong><font face=helvetica color=red>NEW</font></strong> Set the
	    /// rounding mode. This has no effect unless the rounding increment is
	    /// greater than zero.
	    /// </summary>
	    ///
	    /// <param name="roundingMode">A rounding mode, between <c>BigDecimal.ROUND_UP</c> and<c>BigDecimal.ROUND_UNNECESSARY</c>.</param>
	    /// <exception cref="IllegalArgumentException">if <c>roundingMode</c> is unrecognized.</exception>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.SetRoundingIncrement(System.Decimal)"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.GetRoundingIncrement"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.GetRoundingMode"/>
	    /// <seealso cref="T:System.Decimal"/>
	    /// @stable ICU 2.0
	    public void SetRoundingMode(int roundingMode) {
	        if (roundingMode < IBM.ICU.Math.BigDecimal.ROUND_UP
	                || roundingMode > IBM.ICU.Math.BigDecimal.ROUND_UNNECESSARY) {
	            throw new ArgumentException("Invalid rounding mode: "
	                    + roundingMode);
	        }
	        this.roundingMode = roundingMode;
	    }
	
	    /// <summary>
	    /// <strong><font face=helvetica color=red>NEW</font></strong> Get the width
	    /// to which the output of <c>format()</c> is padded. The width is
	    /// counted in 16-bit code units.
	    /// </summary>
	    ///
	    /// <returns>the format width, or zero if no padding is in effect</returns>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.SetFormatWidth(System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.GetPadCharacter"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.SetPadCharacter(System.Character)"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.GetPadPosition"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.SetPadPosition(System.Int32)"/>
	    /// @stable ICU 2.0
	    public int GetFormatWidth() {
	        return formatWidth;
	    }
	
	    /// <summary>
	    /// <strong><font face=helvetica color=red>NEW</font></strong> Set the width
	    /// to which the output of <c>format()</c> is padded. The width is
	    /// counted in 16-bit code units. This method also controls whether padding
	    /// is enabled.
	    /// </summary>
	    ///
	    /// <param name="width">the width to which to pad the result of <c>format()</c>,or zero to disable padding</param>
	    /// <exception cref="IllegalArgumentException">if <c>width</c> is < 0</exception>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.GetFormatWidth"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.GetPadCharacter"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.SetPadCharacter(System.Character)"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.GetPadPosition"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.SetPadPosition(System.Int32)"/>
	    /// @stable ICU 2.0
	    public void SetFormatWidth(int width) {
	        if (width < 0) {
	            throw new ArgumentException("Illegal format width");
	        }
	        formatWidth = width;
	    }
	
	    /// <summary>
	    /// <strong><font face=helvetica color=red>NEW</font></strong> Get the
	    /// character used to pad to the format width. The default is ' '.
	    /// </summary>
	    ///
	    /// <returns>the pad character</returns>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.SetFormatWidth(System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.GetFormatWidth"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.SetPadCharacter(System.Character)"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.GetPadPosition"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.SetPadPosition(System.Int32)"/>
	    /// @stable ICU 2.0
	    public char GetPadCharacter() {
	        return pad;
	    }
	
	    /// <summary>
	    /// <strong><font face=helvetica color=red>NEW</font></strong> Set the
	    /// character used to pad to the format width. If padding is not enabled,
	    /// then this will take effect if padding is later enabled.
	    /// </summary>
	    ///
	    /// <param name="padChar">the pad character</param>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.SetFormatWidth(System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.GetFormatWidth"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.GetPadCharacter"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.GetPadPosition"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.SetPadPosition(System.Int32)"/>
	    /// @stable ICU 2.0
	    public void SetPadCharacter(char padChar) {
	        pad = padChar;
	    }
	
	    /// <summary>
	    /// <strong><font face=helvetica color=red>NEW</font></strong> Get the
	    /// position at which padding will take place. This is the location at which
	    /// padding will be inserted if the result of <c>format()</c> is
	    /// shorter than the format width.
	    /// </summary>
	    ///
	    /// <returns>the pad position, one of <c>PAD_BEFORE_PREFIX</c>,
	    /// <c>PAD_AFTER_PREFIX</c>, <c>PAD_BEFORE_SUFFIX</c>, or
	    /// <c>PAD_AFTER_SUFFIX</c>.</returns>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.SetFormatWidth(System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.GetFormatWidth"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.SetPadCharacter(System.Character)"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.GetPadCharacter"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.SetPadPosition(System.Int32)"/>
	    /// <seealso cref="F:IBM.ICU.Text.DecimalFormat.PAD_BEFORE_PREFIX"/>
	    /// <seealso cref="F:IBM.ICU.Text.DecimalFormat.PAD_AFTER_PREFIX"/>
	    /// <seealso cref="F:IBM.ICU.Text.DecimalFormat.PAD_BEFORE_SUFFIX"/>
	    /// <seealso cref="F:IBM.ICU.Text.DecimalFormat.PAD_AFTER_SUFFIX"/>
	    /// @stable ICU 2.0
	    public int GetPadPosition() {
	        return padPosition;
	    }
	
	    /// <summary>
	    /// <strong><font face=helvetica color=red>NEW</font></strong> Set the
	    /// position at which padding will take place. This is the location at which
	    /// padding will be inserted if the result of <c>format()</c> is
	    /// shorter than the format width. This has no effect unless padding is
	    /// enabled.
	    /// </summary>
	    ///
	    /// <param name="padPos">the pad position, one of <c>PAD_BEFORE_PREFIX</c>,<c>PAD_AFTER_PREFIX</c>, <c>PAD_BEFORE_SUFFIX</c>,or <c>PAD_AFTER_SUFFIX</c>.</param>
	    /// <exception cref="IllegalArgumentException">if the pad position in unrecognized</exception>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.SetFormatWidth(System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.GetFormatWidth"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.SetPadCharacter(System.Character)"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.GetPadCharacter"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.GetPadPosition"/>
	    /// <seealso cref="F:IBM.ICU.Text.DecimalFormat.PAD_BEFORE_PREFIX"/>
	    /// <seealso cref="F:IBM.ICU.Text.DecimalFormat.PAD_AFTER_PREFIX"/>
	    /// <seealso cref="F:IBM.ICU.Text.DecimalFormat.PAD_BEFORE_SUFFIX"/>
	    /// <seealso cref="F:IBM.ICU.Text.DecimalFormat.PAD_AFTER_SUFFIX"/>
	    /// @stable ICU 2.0
	    public void SetPadPosition(int padPos) {
	        if (padPos < PAD_BEFORE_PREFIX || padPos > PAD_AFTER_SUFFIX) {
	            throw new ArgumentException("Illegal pad position");
	        }
	        padPosition = padPos;
	    }
	
	    /// <summary>
	    /// <strong><font face=helvetica color=red>NEW</font></strong> Return whether
	    /// or not scientific notation is used.
	    /// </summary>
	    ///
	    /// <returns>true if this object formats and parses scientific notation</returns>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.SetScientificNotation(System.Boolean)"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.GetMinimumExponentDigits"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.SetMinimumExponentDigits(System.Byte)"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.IsExponentSignAlwaysShown"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.SetExponentSignAlwaysShown(System.Boolean)"/>
	    /// @stable ICU 2.0
	    public bool IsScientificNotation() {
	        return useExponentialNotation;
	    }
	
	    /// <summary>
	    /// <strong><font face=helvetica color=red>NEW</font></strong> Set whether or
	    /// not scientific notation is used. When scientific notation is used, the
	    /// effective maximum number of integer digits is <= 8. If the maximum number
	    /// of integer digits is set to more than 8, the effective maximum will be 1.
	    /// This allows this call to generate a 'default' scientific number format
	    /// without additional changes.
	    /// </summary>
	    ///
	    /// <param name="useScientific">true if this object formats and parses scientific notation</param>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.IsScientificNotation"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.GetMinimumExponentDigits"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.SetMinimumExponentDigits(System.Byte)"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.IsExponentSignAlwaysShown"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.SetExponentSignAlwaysShown(System.Boolean)"/>
	    /// @stable ICU 2.0
	    public void SetScientificNotation(bool useScientific) {
	        useExponentialNotation = useScientific;
	    }
	
	    /// <summary>
	    /// <strong><font face=helvetica color=red>NEW</font></strong> Return the
	    /// minimum exponent digits that will be shown.
	    /// </summary>
	    ///
	    /// <returns>the minimum exponent digits that will be shown</returns>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.SetScientificNotation(System.Boolean)"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.IsScientificNotation"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.SetMinimumExponentDigits(System.Byte)"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.IsExponentSignAlwaysShown"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.SetExponentSignAlwaysShown(System.Boolean)"/>
	    /// @stable ICU 2.0
	    public sbyte GetMinimumExponentDigits() {
	        return minExponentDigits;
	    }
	
	    /// <summary>
	    /// <strong><font face=helvetica color=red>NEW</font></strong> Set the
	    /// minimum exponent digits that will be shown. This has no effect unless
	    /// scientific notation is in use.
	    /// </summary>
	    ///
	    /// <param name="minExpDig">a value >= 1 indicating the fewest exponent digits that willbe shown</param>
	    /// <exception cref="IllegalArgumentException">if <c>minExpDig</c> < 1</exception>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.SetScientificNotation(System.Boolean)"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.IsScientificNotation"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.GetMinimumExponentDigits"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.IsExponentSignAlwaysShown"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.SetExponentSignAlwaysShown(System.Boolean)"/>
	    /// @stable ICU 2.0
	    public void SetMinimumExponentDigits(sbyte minExpDig) {
	        if (minExpDig < 1) {
	            throw new ArgumentException("Exponent digits must be >= 1");
	        }
	        minExponentDigits = minExpDig;
	    }
	
	    /// <summary>
	    /// <strong><font face=helvetica color=red>NEW</font></strong> Return whether
	    /// the exponent sign is always shown.
	    /// </summary>
	    ///
	    /// <returns>true if the exponent is always prefixed with either the localized
	    /// minus sign or the localized plus sign, false if only negative
	    /// exponents are prefixed with the localized minus sign.</returns>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.SetScientificNotation(System.Boolean)"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.IsScientificNotation"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.SetMinimumExponentDigits(System.Byte)"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.GetMinimumExponentDigits"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.SetExponentSignAlwaysShown(System.Boolean)"/>
	    /// @stable ICU 2.0
	    public bool IsExponentSignAlwaysShown() {
	        return exponentSignAlwaysShown;
	    }
	
	    /// <summary>
	    /// <strong><font face=helvetica color=red>NEW</font></strong> Set whether
	    /// the exponent sign is always shown. This has no effect unless scientific
	    /// notation is in use.
	    /// </summary>
	    ///
	    /// <param name="expSignAlways">true if the exponent is always prefixed with either thelocalized minus sign or the localized plus sign, false if onlynegative exponents are prefixed with the localized minus sign.</param>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.SetScientificNotation(System.Boolean)"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.IsScientificNotation"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.SetMinimumExponentDigits(System.Byte)"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.GetMinimumExponentDigits"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.IsExponentSignAlwaysShown"/>
	    /// @stable ICU 2.0
	    public void SetExponentSignAlwaysShown(bool expSignAlways) {
	        exponentSignAlwaysShown = expSignAlways;
	    }
	
	    /// <summary>
	    /// Return the grouping size. Grouping size is the number of digits between
	    /// grouping separators in the integer portion of a number. For example, in
	    /// the number "123,456.78", the grouping size is 3.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.SetGroupingSize(System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Text.NumberFormat.IsGroupingUsed"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormatSymbols.GetGroupingSeparator"/>
	    /// @stable ICU 2.0
	    public int GetGroupingSize() {
	        return groupingSize;
	    }
	
	    /// <summary>
	    /// Set the grouping size. Grouping size is the number of digits between
	    /// grouping separators in the integer portion of a number. For example, in
	    /// the number "123,456.78", the grouping size is 3.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.GetGroupingSize"/>
	    /// <seealso cref="M:IBM.ICU.Text.NumberFormat.SetGroupingUsed(System.Boolean)"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormatSymbols.SetGroupingSeparator(System.Character)"/>
	    /// @stable ICU 2.0
	    public void SetGroupingSize(int newValue) {
	        groupingSize = (byte) newValue;
	    }
	
	    /// <summary>
	    /// Return the secondary grouping size. In some locales one grouping interval
	    /// is used for the least significant integer digits (the primary grouping
	    /// size), and another is used for all others (the secondary grouping size).
	    /// A formatter supporting a secondary grouping size will return a positive
	    /// integer unequal to the primary grouping size returned by
	    /// <c>getGroupingSize()</c>. For example, if the primary grouping size
	    /// is 4, and the secondary grouping size is 2, then the number 123456789
	    /// formats as "1,23,45,6789", and the pattern appears as "#,##,###0". [NEW]
	    /// </summary>
	    ///
	    /// <returns>the secondary grouping size, or a value less than one if there is
	    /// none</returns>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.SetSecondaryGroupingSize(System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Text.NumberFormat.IsGroupingUsed"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormatSymbols.GetGroupingSeparator"/>
	    /// @stable ICU 2.0
	    public int GetSecondaryGroupingSize() {
	        return groupingSize2;
	    }
	
	    /// <summary>
	    /// Set the secondary grouping size. If set to a value less than 1, then
	    /// secondary grouping is turned off, and the primary grouping size is used
	    /// for all intervals, not just the least significant. [NEW]
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.GetSecondaryGroupingSize"/>
	    /// <seealso cref="M:IBM.ICU.Text.NumberFormat.SetGroupingUsed(System.Boolean)"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormatSymbols.SetGroupingSeparator(System.Character)"/>
	    /// @stable ICU 2.0
	    public void SetSecondaryGroupingSize(int newValue) {
	        groupingSize2 = (byte) newValue;
	    }
	
	    /// <summary>
	    /// Allows you to get the behavior of the decimal separator with integers.
	    /// (The decimal separator will always appear with decimals.)
	    /// <P>
	    /// Example: Decimal ON: 12345 -> 12345.; OFF: 12345 -> 12345
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public bool IsDecimalSeparatorAlwaysShown() {
	        return decimalSeparatorAlwaysShown;
	    }
	
	    /// <summary>
	    /// Allows you to set the behavior of the decimal separator with integers.
	    /// (The decimal separator will always appear with decimals.)
	    /// <p>
	    /// This only affects formatting, and only where there might be no digits
	    /// after the decimal point, e.g., if true, 3456.00 -> "3,456." if false,
	    /// 3456.00 -> "3456" This is independent of parsing. If you want parsing to
	    /// stop at the decimal point, use setParseIntegerOnly.
	    /// <P>
	    /// Example: Decimal ON: 12345 -> 12345.; OFF: 12345 -> 12345
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public void SetDecimalSeparatorAlwaysShown(bool newValue) {
	        decimalSeparatorAlwaysShown = newValue;
	    }
	
	    /// <summary>
	    /// Standard override; no change in semantics.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public override Object Clone() {
	        try {
	            DecimalFormat other = (DecimalFormat) base.Clone();
	            other.symbols = (DecimalFormatSymbols) symbols.Clone();
	            other.digitList = new DigitList(); // fix for JB#5358
	            /*
	             * TODO: We need to figure out whether we share a single copy of
	             * DigitList by multiple cloned copies. format/subformat are
	             * designed to use a single instance, but parse/subparse
	             * implementation is not.
	             */
	            return other;
	        } catch (Exception e) {
	            throw new InvalidOperationException();
	        }
	    }
	
	    /// <summary>
	    /// Overrides equals
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public override bool Equals(Object obj) {
	        if (obj == null)
	            return false;
	        if (!base.Equals(obj))
	            return false; // super does class check
	
	        DecimalFormat other = (DecimalFormat) obj;
	        /*
	         * Add the comparison of the four new added fields ,they are
	         * posPrefixPattern, posSuffixPattern, negPrefixPattern,
	         * negSuffixPattern. [Richard/GCL]
	         */
	        return (posPrefixPattern != null && Equals(posPrefixPattern,
	                other.posPrefixPattern))
	                && (posSuffixPattern != null && Equals(posSuffixPattern,
	                        other.posSuffixPattern))
	                && (negPrefixPattern != null && Equals(negPrefixPattern,
	                        other.negPrefixPattern))
	                && (negSuffixPattern != null && Equals(negSuffixPattern,
	                        other.negSuffixPattern))
	                && multiplier == other.multiplier
	                && groupingSize == other.groupingSize
	                && groupingSize2 == other.groupingSize2
	                && decimalSeparatorAlwaysShown == other.decimalSeparatorAlwaysShown
	                && useExponentialNotation == other.useExponentialNotation
	                && (!useExponentialNotation || minExponentDigits == other.minExponentDigits)
	                && useSignificantDigits == other.useSignificantDigits
	                && (!useSignificantDigits || minSignificantDigits == other.minSignificantDigits
	                        && maxSignificantDigits == other.maxSignificantDigits)
	                && symbols.Equals(other.symbols);
	    }
	
	    // method to unquote the strings and compare
	    private bool Equals(String pat1, String pat2) {
	        // fast path
	        if (pat1.Equals(pat2)) {
	            return true;
	        }
	        return Unquote(pat1).Equals(Unquote(pat2));
	    }
	
	    private String Unquote(String pat) {
	        StringBuilder buf = new StringBuilder(pat.Length);
	        int i = 0;
	        while (i < pat.Length) {
	            char ch = pat[i++];
	            if (ch != QUOTE) {
	                buf.Append(ch);
	            }
	        }
	        return buf.ToString();
	    }
	
	    // protected void handleToString(StringBuffer buf) {
	    // buf.append("\nposPrefixPattern: '" + posPrefixPattern + "'\n");
	    // buf.append("positivePrefix: '" + positivePrefix + "'\n");
	    // buf.append("posSuffixPattern: '" + posSuffixPattern + "'\n");
	    // buf.append("positiveSuffix: '" + positiveSuffix + "'\n");
	    // buf.append("negPrefixPattern: '" +
	    // com.ibm.icu.impl.Utility.format1ForSource(negPrefixPattern) + "'\n");
	    // buf.append("negativePrefix: '" +
	    // com.ibm.icu.impl.Utility.format1ForSource(negativePrefix) + "'\n");
	    // buf.append("negSuffixPattern: '" + negSuffixPattern + "'\n");
	    // buf.append("negativeSuffix: '" + negativeSuffix + "'\n");
	    // buf.append("multiplier: '" + multiplier + "'\n");
	    // buf.append("groupingSize: '" + groupingSize + "'\n");
	    // buf.append("groupingSize2: '" + groupingSize2 + "'\n");
	    // buf.append("decimalSeparatorAlwaysShown: '" + decimalSeparatorAlwaysShown
	    // + "'\n");
	    // buf.append("useExponentialNotation: '" + useExponentialNotation + "'\n");
	    // buf.append("minExponentDigits: '" + minExponentDigits + "'\n");
	    // buf.append("useSignificantDigits: '" + useSignificantDigits + "'\n");
	    // buf.append("minSignificantDigits: '" + minSignificantDigits + "'\n");
	    // buf.append("maxSignificantDigits: '" + maxSignificantDigits + "'\n");
	    // buf.append("symbols: '" + symbols + "'");
	    // }
	
	    /// <summary>
	    /// Overrides hashCode
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public override int GetHashCode() {
	        return base.GetHashCode() * 37 + positivePrefix.GetHashCode();
	        // just enough fields for a reasonable distribution
	    }
	
	    /// <summary>
	    /// Synthesizes a pattern string that represents the current state of this
	    /// Format object.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.ApplyPattern(System.String)"/>
	    /// @stable ICU 2.0
	    public String ToPattern() {
	        return ToPattern(false);
	    }
	
	    /// <summary>
	    /// Synthesizes a localized pattern string that represents the current state
	    /// of this Format object.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.ApplyPattern(System.String)"/>
	    /// @stable ICU 2.0
	    public String ToLocalizedPattern() {
	        return ToPattern(true);
	    }
	
	    /// <summary>
	    /// Expand the affix pattern strings into the expanded affix strings. If any
	    /// affix pattern string is null, do not expand it. This method should be
	    /// called any time the symbols or the affix patterns change in order to keep
	    /// the expanded affix strings up to date.
	    /// </summary>
	    ///
	    // Bug 4212072 [Richard/GCL]
	    private void ExpandAffixes() {
	        // expandAffix() will set currencyChoice to a non-null value if
	        // appropriate AND if it is null.
	        currencyChoice = null;
	
	        // Reuse one StringBuffer for better performance
	        StringBuilder buffer = new StringBuilder();
	        if (posPrefixPattern != null) {
	            ExpandAffix(posPrefixPattern, buffer, false);
	            positivePrefix = buffer.ToString();
	        }
	        if (posSuffixPattern != null) {
	            ExpandAffix(posSuffixPattern, buffer, false);
	            positiveSuffix = buffer.ToString();
	        }
	        if (negPrefixPattern != null) {
	            ExpandAffix(negPrefixPattern, buffer, false);
	            negativePrefix = buffer.ToString();
	        }
	        if (negSuffixPattern != null) {
	            ExpandAffix(negSuffixPattern, buffer, false);
	            negativeSuffix = buffer.ToString();
	        }
	    }
	
	    /// <summary>
	    /// Expand an affix pattern into an affix string. All characters in the
	    /// pattern are literal unless bracketed by QUOTEs. The following characters
	    /// outside QUOTE are recognized: PATTERN_PERCENT, PATTERN_PER_MILLE,
	    /// PATTERN_MINUS, and CURRENCY_SIGN. If CURRENCY_SIGN is doubled, it is
	    /// interpreted as an international currency sign. Any other character
	    /// outside QUOTE represents itself. Quoted text must be well-formed.
	    /// This method is used in two distinct ways. First, it is used to expand the
	    /// stored affix patterns into actual affixes. For this usage, doFormat must
	    /// be false. Second, it is used to expand the stored affix patterns given a
	    /// specific number (doFormat == true), for those rare cases in which a
	    /// currency format references a ChoiceFormat (e.g., en_IN display name for
	    /// INR). The number itself is taken from digitList.
	    /// When used in the first way, this method has a side effect: It sets
	    /// currencyChoice to a ChoiceFormat object, if the currency's display name
	    /// in this locale is a ChoiceFormat pattern (very rare). It only does this
	    /// if currencyChoice is null to start with.
	    /// </summary>
	    ///
	    /// <param name="pattern">the non-null, possibly empty pattern</param>
	    /// <param name="buffer">a scratch StringBuffer; its contents will be lost</param>
	    /// <param name="doFormat">if false, then the pattern will be expanded, and if a currencysymbol is encountered that expands to a ChoiceFormat, thecurrencyChoice member variable will be initialized if it isnull. If doFormat is true, then it is assumed that thecurrencyChoice has been created, and it will be used to formatthe value in digitList.</param>
	    /// <returns>the expanded equivalent of pattern</returns>
	    // Bug 4212072 [Richard/GCL]
	    private void ExpandAffix(String pattern, StringBuilder buffer,
	            bool doFormat) {
	        buffer.Length=0;
	        for (int i = 0; i < pattern.Length;) {
	            char c = pattern[i++];
	            if (c == QUOTE) {
	                for (;;) {
	                    int j = pattern.IndexOf(QUOTE, i);
	                    if (j == i) {
	                        buffer.Append(QUOTE);
	                        i = j + 1;
	                        break;
	                    } else if (j > i) {
	                        buffer.Append(pattern.Substring(i,(j)-(i)));
	                        i = j + 1;
	                        if (i < pattern.Length && pattern[i] == QUOTE) {
	                            buffer.Append(QUOTE);
	                            ++i;
	                            // loop again
	                        } else {
	                            break;
	                        }
	                    } else {
	                        // Unterminated quote; should be caught by apply
	                        // pattern.
	                        throw new Exception();
	                    }
	                }
	                continue;
	            }
	
	            switch ((int) c) {
	            case CURRENCY_SIGN:
	                // As of ICU 2.2 we use the currency object, and
	                // ignore the currency symbols in the DFS, unless
	                // we have a null currency object. This occurs if
	                // resurrecting a pre-2.2 object or if the user
	                // sets a custom DFS.
	                bool intl = i < pattern.Length
	                        && pattern[i] == CURRENCY_SIGN;
	                if (intl) {
	                    ++i;
	                }
	                String s = null;
	                Currency currency = GetCurrency();
	                if (currency != null) {
	                    if (!intl) {
	                        bool[] isChoiceFormat = new bool[1];
	                        s = currency.GetName(symbols.GetULocale(),
	                                IBM.ICU.Util.Currency.SYMBOL_NAME, isChoiceFormat);
	                        if (isChoiceFormat[0]) {
	                            // Two modes here: If doFormat is false, we set up
	                            // currencyChoice. If doFormat is true, we use the
	                            // previously created currencyChoice to format the
	                            // value in digitList.
	                            if (!doFormat) {
	                                // If the currency is handled by a ChoiceFormat,
	                                // then we're not going to use the expanded
	                                // patterns. Instantiate the ChoiceFormat and
	                                // return.
	                                if (currencyChoice == null) {
	                                    currencyChoice = new ChoiceFormat(s);
	                                }
	                                // We could almost return null or "" here, since
	                                // the
	                                // expanded affixes are almost not used at all
	                                // in this situation. However, one method --
	                                // toPattern() -- still does use the expanded
	                                // affixes, in order to set up a padding
	                                // pattern. We use the CURRENCY_SIGN as a
	                                // placeholder.
	                                s = CURRENCY_SIGN.ToString();
	                            } else {
	                                FieldPosition pos = new FieldPosition(0); // ignored
	                                currencyChoice.Format(digitList.GetDouble(),
	                                        buffer, pos);
	                                continue;
	                            }
	                        }
	                    } else {
	                        s = currency.GetCurrencyCode();
	                    }
	                } else {
	                    s = (intl) ? symbols.GetInternationalCurrencySymbol()
	                            : symbols.GetCurrencySymbol();
	                }
	                buffer.Append(s);
	                continue;
	            case PATTERN_PERCENT:
	                c = symbols.GetPercent();
	                break;
	            case PATTERN_PER_MILLE:
	                c = symbols.GetPerMill();
	                break;
	            case PATTERN_MINUS:
	                c = symbols.GetMinusSign();
	                break;
	            }
	            buffer.Append(c);
	        }
	    }
	
	    /// <summary>
	    /// Append an affix to the given StringBuffer.
	    /// </summary>
	    ///
	    /// <param name="buf">buffer to append to</param>
	    /// <param name="isNegative"></param>
	    /// <param name="isPrefix"></param>
	    private int AppendAffix(StringBuilder buf, bool isNegative,
	            bool isPrefix, bool parseAttr) {
	        if (currencyChoice != null) {
	            String affixPat = null;
	            if (isPrefix) {
	                affixPat = (isNegative) ? negPrefixPattern : posPrefixPattern;
	            } else {
	                affixPat = (isNegative) ? negSuffixPattern : posSuffixPattern;
	            }
	            StringBuilder affixBuf = new StringBuilder();
	            ExpandAffix(affixPat, affixBuf, true);
	            buf.Append(affixBuf.ToString());
	            return affixBuf.Length;
	        }
	
	        String affix = null;
	        if (isPrefix) {
	            affix = (isNegative) ? negativePrefix : positivePrefix;
	        } else {
	            affix = (isNegative) ? negativeSuffix : positiveSuffix;
	        }
	        // #if defined(FOUNDATION10) || defined(J2SE13)
	        // #else
	        // [Spark/CDL] Invoke formatAffix2Attribute to add attributes for affix
	        if (parseAttr) {
	            int offset = affix.IndexOf(symbols.GetCurrencySymbol());
	            if (-1 == offset) {
	                offset = affix.IndexOf(symbols.GetPercent());
	                if (-1 == offset) {
	                    offset = 0;
	                }
	            }
	            FormatAffix2Attribute(affix, buf.Length + offset, buf.Length
	                    + affix.Length);
	        }
	        // #endif
	        buf.Append(affix);
	        return affix.Length;
	    }
	
	    // #if defined(FOUNDATION10) || defined(J2SE13)
	    // #else
	    /*
	     * [Spark/CDL] This is a newly added method, used to add attributes for
	     * prefix and suffix.
	     */
	    private void FormatAffix2Attribute(String affix, int begin, int end) {
	        // [Spark/CDL] It is the invoker's responsibility to ensure that, before
	        // the invocation of
	        // this method, attributes is not null.
	        // if( attributes == null ) return;
	        if (affix.IndexOf(symbols.GetCurrencySymbol()) > -1) {
	            AddAttribute(IBM.ICU.Text.NumberFormat.Field.CURRENCY, begin, end);
	        } else if (affix.IndexOf(symbols.GetMinusSign()) > -1) {
	            AddAttribute(IBM.ICU.Text.NumberFormat.Field.SIGN, begin, end);
	        } else if (affix.IndexOf(symbols.GetPercent()) > -1) {
	            AddAttribute(IBM.ICU.Text.NumberFormat.Field.PERCENT, begin, end);
	        } else if (affix.IndexOf(symbols.GetPerMill()) > -1) {
	            AddAttribute(IBM.ICU.Text.NumberFormat.Field.PERMILLE, begin, end);
	        }
	    }
	
	    // #endif
	
	    // #if defined(FOUNDATION10) || defined(J2SE13)
	    // #else
	    /*
	     * [Spark/CDL] Use this method to add attribute.
	     */
	    private void AddAttribute(NumberFormat.Field  field, int begin, int end) {
	        FieldPosition pos = new FieldPosition(field);
	        pos.SetBeginIndex(begin);
	        pos.SetEndIndex(end);
	        ILOG.J2CsMapping.Collections.Generics.Collections.Add(attributes,pos);
	    }
	
	    // #endif
	
	    // #if defined(FOUNDATION10) || defined(J2SE13)
	    // #else
	    /// <summary>
	    /// Format the object to an attributed string, and return the corresponding
	    /// iterator Overrides superclass method.
	    /// </summary>
	    ///
	    /// @stable ICU 3.6
	    // [Spark/CDL]
	    public override ILOG.J2CsMapping.Text.AttributedCharacterIterator FormatToCharacterIterator(Object obj) {
	        if (!(obj  is  object))
	            throw new ArgumentException();
	        object number = (object) obj;
	        StringBuilder text = null;
	        ILOG.J2CsMapping.Collections.Collections.Clear(attributes);
	        if (obj  is  Int64) {
	            text = Format((Int64) number, new StringBuilder(),
	                    new FieldPosition(0), true);
	        } else if (obj  is  Decimal) {
	            text = Format((Decimal) number, new StringBuilder(),
	                    new FieldPosition(0), true);
	        } else if (obj  is  Double) {
	            text = Format(Convert.ToDouble(number), new StringBuilder(),
	                    new FieldPosition(0), true);
	        } else if (obj  is  Int32 || obj  is  Int64) {
	            text = Format(Convert.ToInt64(number), new StringBuilder(),
	                    new FieldPosition(0), true);
	        }
	
	        ILOG.J2CsMapping.Text.AttributedString al = new ILOG.J2CsMapping.Text.AttributedString(text.ToString());
	
	        // add NumberFormat field attributes to the AttributedString
	        for (int i = 0; i < attributes.Count; i++) {
	            FieldPosition pos = (FieldPosition) attributes[i];
	            Format.Field attribute = pos.GetFieldAttribute();
	            al.AddAttribute(attribute, attribute, pos.GetBeginIndex(),
	                    pos.GetEndIndex());
	        }
	
	        // return the CharacterIterator from AttributedString
	        return al.GetIterator();
	    }
	
	    // #endif
	    /// <summary>
	    /// Append an affix pattern to the given StringBuffer. Localize unquoted
	    /// specials.
	    /// </summary>
	    ///
	    private void AppendAffixPattern(StringBuilder buffer, bool isNegative,
	            bool isPrefix, bool localized) {
	        String affixPat = null;
	        if (isPrefix) {
	            affixPat = (isNegative) ? negPrefixPattern : posPrefixPattern;
	        } else {
	            affixPat = (isNegative) ? negSuffixPattern : posSuffixPattern;
	        }
	
	        // When there is a null affix pattern, we use the affix itself.
	        if (affixPat == null) {
	            String affix = null;
	            if (isPrefix) {
	                affix = (isNegative) ? negativePrefix : positivePrefix;
	            } else {
	                affix = (isNegative) ? negativeSuffix : positiveSuffix;
	            }
	            // Do this crudely for now: Wrap everything in quotes.
	            buffer.Append(QUOTE);
	            for (int i = 0; i < affix.Length; ++i) {
	                char ch = affix[i];
	                if (ch == QUOTE) {
	                    buffer.Append(ch);
	                }
	                buffer.Append(ch);
	            }
	            buffer.Append(QUOTE);
	            return;
	        }
	
	        if (!localized) {
	            buffer.Append(affixPat);
	        } else {
	            int i_0, j;
	            for (i_0 = 0; i_0 < affixPat.Length; ++i_0) {
	                char ch_1 = affixPat[i_0];
	                switch ((int) ch_1) {
	                case QUOTE:
	                    j = affixPat.IndexOf(QUOTE, i_0 + 1);
	                    if (j < 0) {
	                        throw new ArgumentException(
	                                "Malformed affix pattern: " + affixPat);
	                    }
	                    buffer.Append(affixPat.Substring(i_0,(j + 1)-(i_0)));
	                    i_0 = j;
	                    continue;
	                case PATTERN_PER_MILLE:
	                    ch_1 = symbols.GetPerMill();
	                    break;
	                case PATTERN_PERCENT:
	                    ch_1 = symbols.GetPercent();
	                    break;
	                case PATTERN_MINUS:
	                    ch_1 = symbols.GetMinusSign();
	                    break;
	                }
	                // check if char is same as any other symbol
	                if (ch_1 == symbols.GetDecimalSeparator()
	                        || ch_1 == symbols.GetGroupingSeparator()) {
	                    buffer.Append(QUOTE);
	                    buffer.Append(ch_1);
	                    buffer.Append(QUOTE);
	                } else {
	                    buffer.Append(ch_1);
	                }
	            }
	        }
	    }
	
	    /// <summary>
	    /// <strong><font face=helvetica color=red>CHANGED</font></strong> Does the
	    /// real work of generating a pattern.
	    /// </summary>
	    ///
	    private String ToPattern(bool localized) {
	        StringBuilder result = new StringBuilder();
	        char zero = (localized) ? symbols.GetZeroDigit() : PATTERN_ZERO_DIGIT;
	        char digit = (localized) ? symbols.GetDigit() : PATTERN_DIGIT;
	        char sigDigit = (char) (0);
	        bool useSigDig = AreSignificantDigitsUsed();
	        if (useSigDig) {
	            sigDigit = (localized) ? symbols.GetSignificantDigit()
	                    : PATTERN_SIGNIFICANT_DIGIT;
	        }
	        char group = (localized) ? symbols.GetGroupingSeparator()
	                : PATTERN_GROUPING_SEPARATOR;
	        int i;
	        int roundingDecimalPos = 0; // Pos of decimal in roundingDigits
	        String roundingDigits = null;
	        int padPos = (formatWidth > 0) ? padPosition : -1;
	        String padSpec = (formatWidth > 0) ? new StringBuilder(2)
	                .Append((localized) ? symbols.GetPadEscape() : PATTERN_PAD_ESCAPE)
	                .Append(pad).ToString()
	                : null;
	        if (roundingIncrementICU != null) {
	            i = roundingIncrementICU.Scale();
	            roundingDigits = roundingIncrementICU.MovePointRight(i).ToString();
	            roundingDecimalPos = roundingDigits.Length - i;
	        }
	        for (int part = 0; part < 2; ++part) {
	            // variable not used int partStart = result.length();
	            if (padPos == PAD_BEFORE_PREFIX) {
	                result.Append(padSpec);
	            }
	            /*
	             * Use original symbols read from resources in pattern eg. use
	             * "\u00A4" instead of "$" in Locale.US [Richard/GCL]
	             */
	            AppendAffixPattern(result, part != 0, true, localized);
	            if (padPos == PAD_AFTER_PREFIX) {
	                result.Append(padSpec);
	            }
	            int sub0Start = result.Length;
	            int g = (IsGroupingUsed()) ? Math.Max(0,(int)groupingSize) : 0;
	            if (g > 0 && groupingSize2 > 0 && groupingSize2 != groupingSize) {
	                g += groupingSize2;
	            }
	            int maxDig = 0, minDig = 0, maxSigDig = 0;
	            if (useSigDig) {
	                minDig = GetMinimumSignificantDigits();
	                maxDig = maxSigDig = GetMaximumSignificantDigits();
	            } else {
	                minDig = GetMinimumIntegerDigits();
	                maxDig = GetMaximumIntegerDigits();
	            }
	            if (useExponentialNotation) {
	                if (maxDig > MAX_SCIENTIFIC_INTEGER_DIGITS) {
	                    maxDig = 1;
	                }
	            } else if (useSigDig) {
	                maxDig = Math.Max(maxDig,g + 1);
	            } else {
	                maxDig = Math.Max(Math.Max(g,GetMinimumIntegerDigits()),roundingDecimalPos) + 1;
	            }
	            for (i = maxDig; i > 0; --i) {
	                if (!useExponentialNotation && i < maxDig
	                        && IsGroupingPosition(i)) {
	                    result.Append(group);
	                }
	                if (useSigDig) {
	                    // #@,@### (maxSigDig == 5, minSigDig == 2)
	                    // 65 4321 (1-based pos, count from the right)
	                    // Use # if pos > maxSigDig or 1 <= pos <= (maxSigDig -
	                    // minSigDig)
	                    // Use @ if (maxSigDig - minSigDig) < pos <= maxSigDig
	                    result.Append((maxSigDig >= i && i > (maxSigDig - minDig)) ? sigDigit
	                            : digit);
	                } else {
	                    if (roundingDigits != null) {
	                        int pos = roundingDecimalPos - i;
	                        if (pos >= 0 && pos < roundingDigits.Length) {
	                            result.Append((char) (roundingDigits[pos] - '0' + zero));
	                            continue;
	                        }
	                    }
	                    result.Append((i <= minDig) ? zero : digit);
	                }
	            }
	            if (!useSigDig) {
	                if (GetMaximumFractionDigits() > 0
	                        || decimalSeparatorAlwaysShown) {
	                    result.Append((localized) ? symbols.GetDecimalSeparator()
	                            : PATTERN_DECIMAL_SEPARATOR);
	                }
	                int pos_0 = roundingDecimalPos;
	                for (i = 0; i < GetMaximumFractionDigits(); ++i) {
	                    if (roundingDigits != null && pos_0 < roundingDigits.Length) {
	                        result.Append((pos_0 < 0) ? zero : (char) (roundingDigits[pos_0] - '0' + zero));
	                        ++pos_0;
	                        continue;
	                    }
	                    result.Append((i < GetMinimumFractionDigits()) ? zero : digit);
	                }
	            }
	            if (useExponentialNotation) {
	                if (localized) {
	                    result.Append(symbols.GetExponentSeparator());
	                } else {
	                    result.Append(PATTERN_EXPONENT);
	                }
	                if (exponentSignAlwaysShown) {
	                    result.Append((localized) ? symbols.GetPlusSign()
	                            : PATTERN_PLUS_SIGN);
	                }
	                for (i = 0; i < minExponentDigits; ++i) {
	                    result.Append(zero);
	                }
	            }
	            if (padSpec != null && !useExponentialNotation) {
	                int add = formatWidth
	                        - result.Length
	                        + sub0Start
	                        - ((part == 0) ? positivePrefix.Length
	                                + positiveSuffix.Length : negativePrefix.Length + negativeSuffix.Length);
	                while (add > 0) {
	                    result.Insert(sub0Start, digit);
	                    ++maxDig;
	                    --add;
	                    // Only add a grouping separator if we have at least
	                    // 2 additional characters to be added, so we don't
	                    // end up with ",###".
	                    if (add > 1 && IsGroupingPosition(maxDig)) {
	                        result.Insert(sub0Start, group);
	                        --add;
	                    }
	                }
	            }
	            if (padPos == PAD_BEFORE_SUFFIX) {
	                result.Append(padSpec);
	            }
	            /*
	             * Use original symbols read from resources in pattern eg. use
	             * "\u00A4" instead of "$" in Locale.US [Richard/GCL]
	             */
	            AppendAffixPattern(result, part != 0, false, localized);
	            if (padPos == PAD_AFTER_SUFFIX) {
	                result.Append(padSpec);
	            }
	            if (part == 0) {
	                if (negativeSuffix.Equals(positiveSuffix)
	                        && negativePrefix
	                                .Equals(PATTERN_MINUS + positivePrefix)) {
	                    break;
	                } else {
	                    result.Append((localized) ? symbols.GetPatternSeparator()
	                            : PATTERN_SEPARATOR);
	                }
	            }
	        }
	        return result.ToString();
	    }
	
	    /// <summary>
	    /// Apply the given pattern to this Format object. A pattern is a short-hand
	    /// specification for the various formatting properties. These properties can
	    /// also be changed individually through the various setter methods.
	    /// <p>
	    /// There is no limit to integer digits are set by this routine, since that
	    /// is the typical end-user desire; use setMaximumInteger if you want to set
	    /// a real value. For negative numbers, use a second pattern, separated by a
	    /// semicolon
	    /// <P>
	    /// Example "#,#00.0#" -> 1,234.56
	    /// <P>
	    /// This means a minimum of 2 integer digits, 1 fraction digit, and a maximum
	    /// of 2 fraction digits.
	    /// <p>
	    /// Example: "#,#00.0#;(#,#00.0#)" for negatives in parentheses.
	    /// <p>
	    /// In negative patterns, the minimum and maximum counts are ignored; these
	    /// are presumed to be set in the positive pattern.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public void ApplyPattern(String pattern) {
	        ApplyPattern(pattern, false);
	    }
	
	    /// <summary>
	    /// Apply the given pattern to this Format object. The pattern is assumed to
	    /// be in a localized notation. A pattern is a short-hand specification for
	    /// the various formatting properties. These properties can also be changed
	    /// individually through the various setter methods.
	    /// <p>
	    /// There is no limit to integer digits are set by this routine, since that
	    /// is the typical end-user desire; use setMaximumInteger if you want to set
	    /// a real value. For negative numbers, use a second pattern, separated by a
	    /// semicolon
	    /// <P>
	    /// Example "#,#00.0#" -> 1,234.56
	    /// <P>
	    /// This means a minimum of 2 integer digits, 1 fraction digit, and a maximum
	    /// of 2 fraction digits.
	    /// <p>
	    /// Example: "#,#00.0#;(#,#00.0#)" for negatives in parantheses.
	    /// <p>
	    /// In negative patterns, the minimum and maximum counts are ignored; these
	    /// are presumed to be set in the positive pattern.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public void ApplyLocalizedPattern(String pattern) {
	        ApplyPattern(pattern, true);
	    }
	
	    /// <summary>
	    /// <strong><font face=helvetica color=red>CHANGED</font></strong> Does the
	    /// real work of applying a pattern.
	    /// </summary>
	    ///
	    private void ApplyPattern(String pattern, bool localized) {
	        char zeroDigit = PATTERN_ZERO_DIGIT; // '0'
	        char sigDigit = PATTERN_SIGNIFICANT_DIGIT; // '@'
	        char groupingSeparator = PATTERN_GROUPING_SEPARATOR;
	        char decimalSeparator = PATTERN_DECIMAL_SEPARATOR;
	        char percent = PATTERN_PERCENT;
	        char perMill = PATTERN_PER_MILLE;
	        char digit = PATTERN_DIGIT; // '#'
	        char separator = PATTERN_SEPARATOR;
	        String exponent = PATTERN_EXPONENT.ToString();
	        char plus = PATTERN_PLUS_SIGN;
	        char padEscape = PATTERN_PAD_ESCAPE;
	        char minus = PATTERN_MINUS; // Bug 4212072 [Richard/GCL]
	        if (localized) {
	            zeroDigit = symbols.GetZeroDigit();
	            sigDigit = symbols.GetSignificantDigit();
	            groupingSeparator = symbols.GetGroupingSeparator();
	            decimalSeparator = symbols.GetDecimalSeparator();
	            percent = symbols.GetPercent();
	            perMill = symbols.GetPerMill();
	            digit = symbols.GetDigit();
	            separator = symbols.GetPatternSeparator();
	            exponent = symbols.GetExponentSeparator();
	            plus = symbols.GetPlusSign();
	            padEscape = symbols.GetPadEscape();
	            minus = symbols.GetMinusSign(); // Bug 4212072 [Richard/GCL]
	        }
	        char nineDigit = (char) (zeroDigit + 9);
	
	        bool gotNegative = false;
	
	        int pos = 0;
	        // Part 0 is the positive pattern. Part 1, if present, is the negative
	        // pattern.
	        for (int part = 0; part < 2 && pos < pattern.Length; ++part) {
	            // The subpart ranges from 0 to 4: 0=pattern proper, 1=prefix,
	            // 2=suffix, 3=prefix in quote, 4=suffix in quote. Subpart 0 is
	            // between the prefix and suffix, and consists of pattern
	            // characters. In the prefix and suffix, percent, permille, and
	            // currency symbols are recognized and translated.
	            int subpart = 1, sub0Start = 0, sub0Limit = 0, sub2Limit = 0;
	
	            // It's important that we don't change any fields of this object
	            // prematurely. We set the following variables for the multiplier,
	            // grouping, etc., and then only change the actual object fields if
	            // everything parses correctly. This also lets us register
	            // the data from part 0 and ignore the part 1, except for the
	            // prefix and suffix.
	            StringBuilder prefix = new StringBuilder();
	            StringBuilder suffix = new StringBuilder();
	            int decimalPos = -1;
	            int multiplier = 1;
	            int digitLeftCount = 0, zeroDigitCount = 0, digitRightCount = 0, sigDigitCount = 0;
	            sbyte groupingCount = -1;
	            sbyte groupingCount2 = -1;
	            int padPos = -1;
	            char padChar = (char) (0);
	            int incrementPos = -1;
	            long incrementVal = 0;
	            sbyte expDigits = -1;
	            bool expSignAlways = false;
	            bool isCurrency = false;
	
	            // The affix is either the prefix or the suffix.
	            StringBuilder affix = prefix;
	
	            int start = pos;
	
	            PARTLOOP: {
	                for (; pos < pattern.Length; ++pos) {
	                    char ch = pattern[pos];
	                    switch (subpart) {
	                    case 0: // Pattern proper subpart (between prefix & suffix)
	                        // Process the digits, decimal, and grouping characters. We
	                        // record five pieces of information. We expect the digits
	                        // to occur in the pattern ####00.00####, and we record the
	                        // number of left digits, zero (central) digits, and right
	                        // digits. The position of the last grouping character is
	                        // recorded (should be somewhere within the first two blocks
	                        // of characters), as is the position of the decimal point,
	                        // if any (should be in the zero digits). If there is no
	                        // decimal point, then there should be no right digits.
	                        if (ch == digit) {
	                            if (zeroDigitCount > 0 || sigDigitCount > 0) {
	                                ++digitRightCount;
	                            } else {
	                                ++digitLeftCount;
	                            }
	                            if (groupingCount >= 0 && decimalPos < 0) {
	                                ++groupingCount;
	                            }
	                        } else if ((ch >= zeroDigit && ch <= nineDigit)
	                                || ch == sigDigit) {
	                            if (digitRightCount > 0) {
	                                PatternError("Unexpected '" + ch + '\'', pattern);
	                            }
	                            if (ch == sigDigit) {
	                                ++sigDigitCount;
	                            } else {
	                                ++zeroDigitCount;
	                                if (ch != zeroDigit) {
	                                    int p = digitLeftCount + zeroDigitCount
	                                            + digitRightCount;
	                                    if (incrementPos >= 0) {
	                                        while (incrementPos < p) {
	                                            incrementVal *= 10;
	                                            ++incrementPos;
	                                        }
	                                    } else {
	                                        incrementPos = p;
	                                    }
	                                    incrementVal += ch - zeroDigit;
	                                }
	                            }
	                            if (groupingCount >= 0 && decimalPos < 0) {
	                                ++groupingCount;
	                            }
	                        } else if (ch == groupingSeparator) {
	                            /*
	                             * Bug 4212072 process the Localized pattern like
	                             * "'Fr. '#'##0.05;'Fr.-'#'##0.05" (Locale="CH",
	                             * groupingSeparator == QUOTE) [Richard/GCL]
	                             */
	                            if (ch == QUOTE && (pos + 1) < pattern.Length) {
	                                char after = pattern[pos + 1];
	                                if (!(after == digit || (after >= zeroDigit && after <= nineDigit))) {
	                                    // A quote outside quotes indicates either the
	                                    // opening
	                                    // quote or two quotes, which is a quote
	                                    // literal. That is,
	                                    // we have the first quote in 'do' or o''clock.
	                                    if (after == QUOTE) {
	                                        ++pos;
	                                        // Fall through to append(ch)
	                                    } else {
	                                        if (groupingCount < 0) {
	                                            subpart = 3; // quoted prefix subpart
	                                        } else {
	                                            // Transition to suffix subpart
	                                            subpart = 2; // suffix subpart
	                                            affix = suffix;
	                                            sub0Limit = pos--;
	                                        }
	                                        continue;
	                                    }
	                                }
	                            }
	
	                            if (decimalPos >= 0) {
	                                PatternError("Grouping separator after decimal",
	                                        pattern);
	                            }
	                            groupingCount2 = groupingCount;
	                            groupingCount = 0;
	                        } else if (ch == decimalSeparator) {
	                            if (decimalPos >= 0) {
	                                PatternError("Multiple decimal separators", pattern);
	                            }
	                            // Intentionally incorporate the digitRightCount,
	                            // even though it is illegal for this to be > 0
	                            // at this point. We check pattern syntax below.
	                            decimalPos = digitLeftCount + zeroDigitCount
	                                    + digitRightCount;
	                        } else {
	                            if (StringUtil.RegionMatches(pattern, pos, exponent, 0,
	                                    exponent.Length)) {
	                                if (expDigits >= 0) {
	                                    PatternError("Multiple exponential symbols",
	                                            pattern);
	                                }
	                                if (groupingCount >= 0) {
	                                    PatternError(
	                                            "Grouping separator in exponential",
	                                            pattern);
	                                }
	                                pos += exponent.Length;
	                                // Check for positive prefix
	                                if (pos < pattern.Length
	                                        && pattern[pos] == plus) {
	                                    expSignAlways = true;
	                                    ++pos;
	                                }
	                                // Use lookahead to parse out the exponential part
	                                // of the
	                                // pattern, then jump into suffix subpart.
	                                expDigits = 0;
	                                while (pos < pattern.Length
	                                        && pattern[pos] == zeroDigit) {
	                                    ++expDigits;
	                                    ++pos;
	                                }
	
	                                // 1. Require at least one mantissa pattern digit
	                                // 2. Disallow "#+ @" in mantissa
	                                // 3. Require at least one exponent pattern digit
	                                if (((digitLeftCount + zeroDigitCount) < 1 && (sigDigitCount + digitRightCount) < 1)
	                                        || (sigDigitCount > 0 && digitLeftCount > 0)
	                                        || expDigits < 1) {
	                                    PatternError("Malformed exponential", pattern);
	                                }
	                            }
	                            // Transition to suffix subpart
	                            subpart = 2; // suffix subpart
	                            affix = suffix;
	                            sub0Limit = pos--; // backup: for() will increment
	                            continue;
	                        }
	                        break;
	                    case 1: // Prefix subpart
	                    case 2: // Suffix subpart
	                        // Process the prefix / suffix characters
	                        // Process unquoted characters seen in prefix or suffix
	                        // subpart.
	
	                        // Several syntax characters implicitly begins the
	                        // next subpart if we are in the prefix; otherwise
	                        // they are illegal if unquoted.
	                        if (ch == digit || ch == groupingSeparator
	                                || ch == decimalSeparator
	                                || (ch >= zeroDigit && ch <= nineDigit)
	                                || ch == sigDigit) {
	                            // Any of these characters implicitly begins the
	                            // next subpart if we are in the prefix
	                            if (subpart == 1) { // prefix subpart
	                                subpart = 0; // pattern proper subpart
	                                sub0Start = pos--; // Reprocess this character
	                                continue;
	                            } else if (ch == QUOTE) {
	                                /*
	                                 * Bug 4212072 process the Localized pattern like
	                                 * "'Fr. '#'##0.05;'Fr.-'#'##0.05" (Locale="CH",
	                                 * groupingSeparator == QUOTE) [Richard/GCL]
	                                 */
	                                // A quote outside quotes indicates either the
	                                // opening
	                                // quote or two quotes, which is a quote literal.
	                                // That is,
	                                // we have the first quote in 'do' or o''clock.
	                                if ((pos + 1) < pattern.Length
	                                        && pattern[pos + 1] == QUOTE) {
	                                    ++pos;
	                                    affix.Append(ch);
	                                } else {
	                                    subpart += 2; // open quote
	                                }
	                                continue;
	                            }
	                            PatternError(
	                                    "Unquoted special character '" + ch + '\'',
	                                    pattern);
	                        } else if (ch == CURRENCY_SIGN) {
	                            // Use lookahead to determine if the currency sign is
	                            // doubled or not.
	                            bool doubled = (pos + 1) < pattern.Length
	                                    && pattern[pos + 1] == CURRENCY_SIGN;
	                            /*
	                             * Bug 4212072 To meet the need of expandAffix(String,
	                             * StirngBuffer) [Richard/GCL]
	                             */
	                            if (doubled) {
	                                ++pos; // Skip over the doubled character
	                                affix.Append(ch); // append two: one here, one below
	                            }
	                            isCurrency = true;
	                            // Fall through to append(ch)
	                        } else if (ch == QUOTE) {
	                            // A quote outside quotes indicates either the opening
	                            // quote or two quotes, which is a quote literal. That
	                            // is,
	                            // we have the first quote in 'do' or o''clock.
	                            if ((pos + 1) < pattern.Length
	                                    && pattern[pos + 1] == QUOTE) {
	                                ++pos;
	                                affix.Append(ch); // append two: one here, one below
	                            } else {
	                                subpart += 2; // open quote
	                            }
	                            // Fall through to append(ch)
	                        } else if (ch == separator) {
	                            // Don't allow separators in the prefix, and don't allow
	                            // separators in the second pattern (part == 1).
	                            if (subpart == 1 || part == 1) {
	                                PatternError("Unquoted special character '" + ch
	                                        + '\'', pattern);
	                            }
	                            sub2Limit = pos++;
	                            goto gotoPARTLOOP;
	                        } else if (ch == percent || ch == perMill) {
	                            // Next handle characters which are appended directly.
	                            if (multiplier != 1) {
	                                PatternError(
	                                        "Too many percent/permille characters",
	                                        pattern);
	                            }
	                            multiplier = (ch == percent) ? 100 : 1000;
	                            // Convert to non-localized pattern
	                            ch = (ch == percent) ? PATTERN_PERCENT
	                                    : PATTERN_PER_MILLE;
	                            // Fall through to append(ch)
	                        } else if (ch == minus) {
	                            // Convert to non-localized pattern
	                            ch = PATTERN_MINUS;
	                            // Fall through to append(ch)
	                        } else if (ch == padEscape) {
	                            if (padPos >= 0) {
	                                PatternError("Multiple pad specifiers", pattern);
	                            }
	                            if ((pos + 1) == pattern.Length) {
	                                PatternError("Invalid pad specifier", pattern);
	                            }
	                            padPos = pos++; // Advance past pad char
	                            padChar = pattern[pos];
	                            continue;
	                        }
	                        affix.Append(ch);
	                        break;
	                    case 3: // Prefix subpart, in quote
	                    case 4: // Suffix subpart, in quote
	                        // A quote within quotes indicates either the closing
	                        // quote or two quotes, which is a quote literal. That is,
	                        // we have the second quote in 'do' or 'don''t'.
	                        if (ch == QUOTE) {
	                            if ((pos + 1) < pattern.Length
	                                    && pattern[pos + 1] == QUOTE) {
	                                ++pos;
	                                affix.Append(ch);
	                            } else {
	                                subpart -= 2; // close quote
	                            }
	                            // Fall through to append(ch)
	                        }
	                        // NOTE: In ICU 2.2 there was code here to parse quoted
	                        // percent and permille characters _within quotes_ and give
	                        // them special meaning. This is incorrect, since quoted
	                        // characters are literals without special meaning.
	                        affix.Append(ch);
	                        break;
	                    }
	                }
	            }
	            gotoPARTLOOP:
	            ;
	
	            if (subpart == 3 || subpart == 4) {
	                PatternError("Unterminated quote", pattern);
	            }
	
	            if (sub0Limit == 0) {
	                sub0Limit = pattern.Length;
	            }
	
	            if (sub2Limit == 0) {
	                sub2Limit = pattern.Length;
	            }
	
	            /*
	             * Handle patterns with no '0' pattern character. These patterns are
	             * legal, but must be recodified to make sense. "##.###" ->
	             * "#0.###". ".###" -> ".0##".
	             * 
	             * We allow patterns of the form "####" to produce a zeroDigitCount
	             * of zero (got that?); although this seems like it might make it
	             * possible for format() to produce empty strings, format() checks
	             * for this condition and outputs a zero digit in this situation.
	             * Having a zeroDigitCount of zero yields a minimum integer digits
	             * of zero, which allows proper round-trip patterns. We don't want
	             * "#" to become "#0" when toPattern() is called (even though that's
	             * what it really is, semantically).
	             */
	            if (zeroDigitCount == 0 && sigDigitCount == 0 && digitLeftCount > 0
	                    && decimalPos >= 0) {
	                // Handle "###.###" and "###." and ".###"
	                int n = decimalPos;
	                if (n == 0)
	                    ++n; // Handle ".###"
	                digitRightCount = digitLeftCount - n;
	                digitLeftCount = n - 1;
	                zeroDigitCount = 1;
	            }
	
	            // Do syntax checking on the digits, decimal points, and quotes.
	            if ((decimalPos < 0 && digitRightCount > 0 && sigDigitCount == 0)
	                    || (decimalPos >= 0 && (sigDigitCount > 0
	                            || decimalPos < digitLeftCount || decimalPos > (digitLeftCount + zeroDigitCount)))
	                    || groupingCount == 0 || groupingCount2 == 0
	                    || (sigDigitCount > 0 && zeroDigitCount > 0) || subpart > 2) { // subpart
	                                                                                   // >
	                                                                                   // 2
	                                                                                   // ==
	                                                                                   // unmatched
	                                                                                   // quote
	                PatternError("Malformed pattern", pattern);
	            }
	
	            // Make sure pad is at legal position before or after affix.
	            if (padPos >= 0) {
	                if (padPos == start) {
	                    padPos = PAD_BEFORE_PREFIX;
	                } else if (padPos + 2 == sub0Start) {
	                    padPos = PAD_AFTER_PREFIX;
	                } else if (padPos == sub0Limit) {
	                    padPos = PAD_BEFORE_SUFFIX;
	                } else if (padPos + 2 == sub2Limit) {
	                    padPos = PAD_AFTER_SUFFIX;
	                } else {
	                    PatternError("Illegal pad position", pattern);
	                }
	            }
	
	            if (part == 0) {
	                // Set negative affixes temporarily to match the positive
	                // affixes. Fix this up later after processing both parts.
	                /*
	                 * Bug 4212072 To meet the need of expandAffix(String,
	                 * StirngBuffer) [Richard/GCL]
	                 */
	                posPrefixPattern = negPrefixPattern = prefix.ToString();
	                posSuffixPattern = negSuffixPattern = suffix.ToString();
	
	                useExponentialNotation = (expDigits >= 0);
	                if (useExponentialNotation) {
	                    minExponentDigits = expDigits;
	                    exponentSignAlwaysShown = expSignAlways;
	                }
	                isCurrencyFormat = isCurrency;
	                int digitTotalCount = digitLeftCount + zeroDigitCount
	                        + digitRightCount;
	                // The effectiveDecimalPos is the position the decimal is at or
	                // would be at if there is no decimal. Note that if
	                // decimalPos<0, then digitTotalCount == digitLeftCount +
	                // zeroDigitCount.
	                int effectiveDecimalPos = (decimalPos >= 0) ? decimalPos
	                        : digitTotalCount;
	                bool useSigDig = (sigDigitCount > 0);
	                SetSignificantDigitsUsed(useSigDig);
	                if (useSigDig) {
	                    SetMinimumSignificantDigits(sigDigitCount);
	                    SetMaximumSignificantDigits(sigDigitCount + digitRightCount);
	                } else {
	                    int minInt = effectiveDecimalPos - digitLeftCount;
	                    SetMinimumIntegerDigits(minInt);
	                    /*
	                     * Upper limit on integer and fraction digits for a Java
	                     * double [Richard/GCL]
	                     */
	                    SetMaximumIntegerDigits((useExponentialNotation) ? digitLeftCount
	                            + minInt
	                            : DOUBLE_INTEGER_DIGITS);
	                    SetMaximumFractionDigits((decimalPos >= 0) ? (digitTotalCount - decimalPos)
	                            : 0);
	                    SetMinimumFractionDigits((decimalPos >= 0) ? (digitLeftCount
	                            + zeroDigitCount - decimalPos) : 0);
	                }
	                SetGroupingUsed(groupingCount > 0);
	                this.groupingSize = (groupingCount > 0) ? (byte) (groupingCount) : (byte) (0);
	                this.groupingSize2 = (groupingCount2 > 0 && groupingCount2 != groupingCount) ? (byte) (groupingCount2)
	                        : (byte) (0);
	                this.multiplier = multiplier;
	                SetDecimalSeparatorAlwaysShown(decimalPos == 0
	                        || decimalPos == digitTotalCount);
	                if (padPos >= 0) {
	                    padPosition = padPos;
	                    formatWidth = sub0Limit - sub0Start; // to be fixed up below
	                    pad = padChar;
	                } else {
	                    formatWidth = 0;
	                }
	                if (incrementVal != 0) {
	                    // BigDecimal scale cannot be negative (even though
	                    // this makes perfect sense), so we need to handle this.
	                    int scale = incrementPos - effectiveDecimalPos;
	                    roundingIncrementICU = IBM.ICU.Math.BigDecimal.ValueOf(incrementVal,
	                            (scale > 0) ? scale : 0);
	                    if (scale < 0) {
	                        roundingIncrementICU = roundingIncrementICU
	                                .MovePointRight(-scale);
	                    }
	                    SetRoundingDouble();
	                    roundingMode = IBM.ICU.Math.BigDecimal.ROUND_HALF_EVEN;
	                } else {
	                    SetRoundingIncrement((BigDecimal) null);
	                }
	            } else {
	                /*
	                 * Bug 4212072 To meet the need of expandAffix(String,
	                 * StirngBuffer) [Richard/GCL]
	                 */
	                negPrefixPattern = prefix.ToString();
	                negSuffixPattern = suffix.ToString();
	                gotNegative = true;
	            }
	        }
	
	        /*
	         * Bug 4140009 Process the empty pattern [Richard/GCL]
	         */
	        if (pattern.Length == 0) {
	            posPrefixPattern = posSuffixPattern = "";
	            SetMinimumIntegerDigits(0);
	            SetMaximumIntegerDigits(DOUBLE_INTEGER_DIGITS);
	            SetMinimumFractionDigits(0);
	            SetMaximumFractionDigits(DOUBLE_FRACTION_DIGITS);
	        }
	
	        // If there was no negative pattern, or if the negative pattern is
	        // identical to the positive pattern, then prepend the minus sign to the
	        // positive pattern to form the negative pattern.
	        /*
	         * Bug 4212072 To meet the need of expandAffix(String, StirngBuffer)
	         * [Richard/GCL]
	         */
	        if (!gotNegative
	                || (negPrefixPattern.Equals(posPrefixPattern) && negSuffixPattern
	                        .Equals(posSuffixPattern))) {
	            negSuffixPattern = posSuffixPattern;
	            negPrefixPattern = PATTERN_MINUS + posPrefixPattern;
	        }
	        /*
	         * Bug 4212072 Update the affix strings accroding to symbols in order to
	         * keep the affix strings up to date. [Richard/GCL]
	         */
	        ExpandAffixes();
	
	        // Now that we have the actual prefix and suffix, fix up formatWidth
	        if (formatWidth > 0) {
	            formatWidth += positivePrefix.Length + positiveSuffix.Length;
	        }
	
	        SetLocale(null, null);
	    }
	
	    /// <summary>
	    /// Centralizes the setting of the roundingDouble and
	    /// roundingDoubleReciprocal.
	    /// </summary>
	    ///
	    private void SetRoundingDouble() {
	        if (roundingIncrementICU == null) {
	            roundingDouble = 0.0d;
	            roundingDoubleReciprocal = 0.0d;
	        } else {
	            roundingDouble = Convert.ToDouble(roundingIncrementICU);
	            SetRoundingDoubleReciprocal(Convert.ToDouble(IBM.ICU.Math.BigDecimal.ONE.Divide(
	                                roundingIncrementICU, IBM.ICU.Math.BigDecimal.ROUND_HALF_EVEN)));
	        }
	    }
	
	    private void PatternError(String msg, String pattern) {
	        throw new ArgumentException(msg + " in pattern \"" + pattern
	                + '"');
	    }
	
	    /*
	     * Rewrite the following 4 "set" methods Upper limit on integer and fraction
	     * digits for a Java double [Richard/GCL]
	     */
	    /// <summary>
	    /// Sets the maximum number of digits allowed in the integer portion of a
	    /// number. This override limits the integer digit count to 309.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.NumberFormat.SetMaximumIntegerDigits(System.Int32)"/>
	    /// @stable ICU 2.0
	    public override void SetMaximumIntegerDigits(int newValue) {
	        base.SetMaximumIntegerDigits(Math.Min(newValue,DOUBLE_INTEGER_DIGITS));
	    }
	
	    /// <summary>
	    /// Sets the minimum number of digits allowed in the integer portion of a
	    /// number. This override limits the integer digit count to 309.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.NumberFormat.SetMinimumIntegerDigits(System.Int32)"/>
	    /// @stable ICU 2.0
	    public override void SetMinimumIntegerDigits(int newValue) {
	        base.SetMinimumIntegerDigits(Math.Min(newValue,DOUBLE_INTEGER_DIGITS));
	    }
	
	    /// <summary>
	    /// Returns the minimum number of significant digits that will be displayed.
	    /// This value has no effect unless areSignificantDigitsUsed() returns true.
	    /// </summary>
	    ///
	    /// <returns>the fewest significant digits that will be shown</returns>
	    /// @stable ICU 3.0
	    public int GetMinimumSignificantDigits() {
	        return minSignificantDigits;
	    }
	
	    /// <summary>
	    /// Returns the maximum number of significant digits that will be displayed.
	    /// This value has no effect unless areSignificantDigitsUsed() returns true.
	    /// </summary>
	    ///
	    /// <returns>the most significant digits that will be shown</returns>
	    /// @stable ICU 3.0
	    public int GetMaximumSignificantDigits() {
	        return maxSignificantDigits;
	    }
	
	    /// <summary>
	    /// Sets the minimum number of significant digits that will be displayed. If
	    /// <c>min</c> is less than one then it is set to one. If the maximum
	    /// significant digits count is less than <c>min</c>, then it is set to
	    /// <c>min</c>. This value has no effect unless
	    /// areSignificantDigitsUsed() returns true.
	    /// </summary>
	    ///
	    /// <param name="min">the fewest significant digits to be shown</param>
	    /// @stable ICU 3.0
	    public void SetMinimumSignificantDigits(int min) {
	        if (min < 1) {
	            min = 1;
	        }
	        // pin max sig dig to >= min
	        int max = Math.Max(maxSignificantDigits,min);
	        minSignificantDigits = min;
	        maxSignificantDigits = max;
	    }
	
	    /// <summary>
	    /// Sets the maximum number of significant digits that will be displayed. If
	    /// <c>max</c> is less than one then it is set to one. If the minimum
	    /// significant digits count is greater than <c>max</c>, then it is set
	    /// to <c>max</c>. This value has no effect unless
	    /// areSignificantDigitsUsed() returns true.
	    /// </summary>
	    ///
	    /// <param name="max">the most significant digits to be shown</param>
	    /// @stable ICU 3.0
	    public void SetMaximumSignificantDigits(int max) {
	        if (max < 1) {
	            max = 1;
	        }
	        // pin min sig dig to 1..max
	        int min = Math.Min(minSignificantDigits,max);
	        minSignificantDigits = min;
	        maxSignificantDigits = max;
	    }
	
	    /// <summary>
	    /// Returns true if significant digits are in use or false if integer and
	    /// fraction digit counts are in use.
	    /// </summary>
	    ///
	    /// <returns>true if significant digits are in use</returns>
	    /// @stable ICU 3.0
	    public bool AreSignificantDigitsUsed() {
	        return useSignificantDigits;
	    }
	
	    /// <summary>
	    /// Sets whether significant digits are in use, or integer and fraction digit
	    /// counts are in use.
	    /// </summary>
	    ///
	    /// <param name="useSignificantDigits">true to use significant digits, or false to use integer andfraction digit counts</param>
	    /// @stable ICU 3.0
	    public void SetSignificantDigitsUsed(bool useSignificantDigits) {
	        this.useSignificantDigits = useSignificantDigits;
	    }
	
	    /// <summary>
	    /// Sets the <tt>Currency</tt> object used to display currency amounts. This
	    /// takes effect immediately, if this format is a currency format. If this
	    /// format is not a currency format, then the currency object is used if and
	    /// when this object becomes a currency format through the application of a
	    /// new pattern.
	    /// </summary>
	    ///
	    /// <param name="theCurrency">new currency object to use. Must not be null.</param>
	    /// @stable ICU 2.2
	    public override void SetCurrency(Currency theCurrency) {
	        // If we are a currency format, then modify our affixes to
	        // encode the currency symbol for the given currency in our
	        // locale, and adjust the decimal digits and rounding for the
	        // given currency.
	
	        base.SetCurrency(theCurrency);
	        if (theCurrency != null) {
	            bool[] isChoiceFormat = new bool[1];
	            String s = theCurrency.GetName(symbols.GetULocale(),
	                    IBM.ICU.Util.Currency.SYMBOL_NAME, isChoiceFormat);
	            symbols.SetCurrencySymbol(s);
	            symbols.SetInternationalCurrencySymbol(theCurrency
	                    .GetCurrencyCode());
	        }
	
	        if (isCurrencyFormat) {
	            if (theCurrency != null) {
	                SetRoundingIncrement(theCurrency.GetRoundingIncrement());
	
	                int d = theCurrency.GetDefaultFractionDigits();
	                SetMinimumFractionDigits(d);
	                SetMaximumFractionDigits(d);
	            }
	            ExpandAffixes();
	        }
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Returns the currency in effect for this formatter. Subclasses should
	    /// override this method as needed. Unlike getCurrency(), this method should
	    /// never return null.
	    /// </summary>
	    ///
	    protected internal override Currency GetEffectiveCurrency() {
	        Currency c = GetCurrency();
	        if (c == null) {
	            c = IBM.ICU.Util.Currency.GetInstance(symbols.GetInternationalCurrencySymbol());
	        }
	        return c;
	    }
	
	    /// <summary>
	    /// Sets the maximum number of digits allowed in the fraction portion of a
	    /// number. This override limits the fraction digit count to 340.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.NumberFormat.SetMaximumFractionDigits(System.Int32)"/>
	    /// @stable ICU 2.0
	    public override void SetMaximumFractionDigits(int newValue) {
	        base.SetMaximumFractionDigits(Math.Min(newValue,DOUBLE_FRACTION_DIGITS));
	    }
	
	    /// <summary>
	    /// Sets the minimum number of digits allowed in the fraction portion of a
	    /// number. This override limits the fraction digit count to 340.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.NumberFormat.SetMinimumFractionDigits(System.Int32)"/>
	    /// @stable ICU 2.0
	    public override void SetMinimumFractionDigits(int newValue) {
	        base.SetMinimumFractionDigits(Math.Min(newValue,DOUBLE_FRACTION_DIGITS));
	    }
	
	    /// <summary>
	    /// Sets whether <see cref="M:IBM.ICU.Text.DecimalFormat.Parse(System.String, null)"/> method returns
	    /// BigDecimal. The default value is false.
	    /// </summary>
	    ///
	    /// <param name="value">true if <see cref="M:IBM.ICU.Text.DecimalFormat.Parse(System.String, null)"/> method returnsBigDecimal.</param>
	    /// @stable ICU 3.6
	    public void SetParseBigDecimal(bool value_ren) {
	        parseBigDecimal = value_ren;
	    }
	
	    /// <summary>
	    /// Returns whether <see cref="M:IBM.ICU.Text.DecimalFormat.Parse(System.String, null)"/> method returns
	    /// BigDecimal.
	    /// </summary>
	    ///
	    /// <returns>true if 
	    /// <see cref="M:IBM.ICU.Text.DecimalFormat.Parse(System.String, null)"/>
	    ///  method returns
	    /// BigDecimal.</returns>
	    /// @stable ICU 3.6
	    public bool IsParseBigDecimal() {
	        return parseBigDecimal;
	    }
	
	    // #if defined(FOUNDATION10) || defined(J2SE13)
	    // #else
	    private void WriteObject(IlObjectOutputStream stream) {
	        // Doug, do we need this anymore?
	        // if (roundingIncrementICU != null) {
	        // roundingIncrement = roundingIncrementICU.toBigDecimal();
	        // }
	
	        stream.DefaultWriteObject();
	    }
	
	    // #endif
	
	    /// <summary>
	    /// First, read the default serializable fields from the stream. Then if
	    /// <c>serialVersionOnStream</c> is less than 1, indicating that the
	    /// stream was written by JDK 1.1, initialize
	    /// <c>useExponentialNotation</c> to false, since it was not present in
	    /// JDK 1.1. Finally, set serialVersionOnStream back to the maximum allowed
	    /// value so that default serialization will work properly if this object is
	    /// streamed out again.
	    /// </summary>
	    ///
	    private void ReadObject(IlObjectInputStream stream) {
	        stream.DefaultReadObject();
	        /*
	         * Bug 4185761 validate fields [Richard/GCL]
	         */
	        // We only need to check the maximum counts because NumberFormat
	        // .readObject has already ensured that the maximum is greater than the
	        // minimum count.
	        /*
	         * Commented for compatibility with previous version, and reserved for
	         * further use if (getMaximumIntegerDigits() > DOUBLE_INTEGER_DIGITS ||
	         * getMaximumFractionDigits() > DOUBLE_FRACTION_DIGITS) { throw new
	         * InvalidObjectException("Digit count out of range"); }
	         */
	        /*
	         * Truncate the maximumIntegerDigits to DOUBLE_INTEGER_DIGITS and
	         * maximumFractionDigits to DOUBLE_FRACTION_DIGITS
	         */
	        if (GetMaximumIntegerDigits() > DOUBLE_INTEGER_DIGITS) {
	            SetMaximumIntegerDigits(DOUBLE_INTEGER_DIGITS);
	        }
	        if (GetMaximumFractionDigits() > DOUBLE_FRACTION_DIGITS) {
	            SetMaximumFractionDigits(DOUBLE_FRACTION_DIGITS);
	        }
	        if (serialVersionOnStream < 2) {
	            exponentSignAlwaysShown = false;
	            SetInternalRoundingIncrement(null);
	            SetRoundingDouble();
	            roundingMode = IBM.ICU.Math.BigDecimal.ROUND_HALF_EVEN;
	            formatWidth = 0;
	            pad = ' ';
	            padPosition = PAD_BEFORE_PREFIX;
	            if (serialVersionOnStream < 1) {
	                // Didn't have exponential fields
	                useExponentialNotation = false;
	            }
	        }
	        if (serialVersionOnStream < 3) {
	            // Versions prior to 3 do not store a currency object.
	            // Create one to match the DecimalFormatSymbols object.
	            SetCurrencyForSymbols();
	        }
	        serialVersionOnStream = currentSerialVersion;
	        digitList = new DigitList();
	
	        // #if defined(FOUNDATION10) || defined(J2SE13)
	        // #else
	        if (roundingIncrement != null) {
	            SetInternalRoundingIncrement(new BigDecimal(roundingIncrement));
	            SetRoundingDouble();
	        }
	        // #endif
	    }
	
	    private void SetInternalRoundingIncrement(BigDecimal value_ren) {
	        roundingIncrementICU = value_ren;
	        // #if defined(FOUNDATION10) || defined(J2SE13)
	        // #else
	        roundingIncrement = (value_ren == null) ? default(decimal) : value_ren.ToBigDecimal();
	        // #endif
	    }
	
	    // ----------------------------------------------------------------------
	    // INSTANCE VARIABLES
	    // ----------------------------------------------------------------------
	
	    private DigitList digitList;
	
	    /// <summary>
	    /// The symbol used as a prefix when formatting positive numbers, e.g. "+".
	    /// </summary>
	    ///
	    /// @serial
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.GetPositivePrefix"/>
	    private String positivePrefix;
	
	    /// <summary>
	    /// The symbol used as a suffix when formatting positive numbers. This is
	    /// often an empty string.
	    /// </summary>
	    ///
	    /// @serial
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.GetPositiveSuffix"/>
	    private String positiveSuffix;
	
	    /// <summary>
	    /// The symbol used as a prefix when formatting negative numbers, e.g. "-".
	    /// </summary>
	    ///
	    /// @serial
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.GetNegativePrefix"/>
	    private String negativePrefix;
	
	    /// <summary>
	    /// The symbol used as a suffix when formatting negative numbers. This is
	    /// often an empty string.
	    /// </summary>
	    ///
	    /// @serial
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.GetNegativeSuffix"/>
	    private String negativeSuffix;
	
	    /// <summary>
	    /// The prefix pattern for non-negative numbers. This variable corresponds to
	    /// <c>positivePrefix</c>.
	    /// <p>
	    /// This pattern is expanded by the method <c>expandAffix()</c> to
	    /// <c>positivePrefix</c> to update the latter to reflect changes in
	    /// <c>symbols</c>. If this variable is <c>null</c> then
	    /// <c>positivePrefix</c> is taken as a literal value that does not
	    /// change when <c>symbols</c> changes. This variable is always
	    /// <c>null</c> for <c>DecimalFormat</c> objects older than
	    /// stream version 2 restored from stream.
	    /// </summary>
	    ///
	    /// @serial
	    // [Richard/GCL]
	    private String posPrefixPattern;
	
	    /// <summary>
	    /// The suffix pattern for non-negative numbers. This variable corresponds to
	    /// <c>positiveSuffix</c>. This variable is analogous to
	    /// <c>posPrefixPattern</c>; see that variable for further
	    /// documentation.
	    /// </summary>
	    ///
	    /// @serial
	    // [Richard/GCL]
	    private String posSuffixPattern;
	
	    /// <summary>
	    /// The prefix pattern for negative numbers. This variable corresponds to
	    /// <c>negativePrefix</c>. This variable is analogous to
	    /// <c>posPrefixPattern</c>; see that variable for further
	    /// documentation.
	    /// </summary>
	    ///
	    /// @serial
	    // [Richard/GCL]
	    private String negPrefixPattern;
	
	    /// <summary>
	    /// The suffix pattern for negative numbers. This variable corresponds to
	    /// <c>negativeSuffix</c>. This variable is analogous to
	    /// <c>posPrefixPattern</c>; see that variable for further
	    /// documentation.
	    /// </summary>
	    ///
	    /// @serial
	    // [Richard/GCL]
	    private String negSuffixPattern;
	
	    /// <summary>
	    /// Formatter for ChoiceFormat-based currency names. If this field is not
	    /// null, then delegate to it to format currency symbols.
	    /// </summary>
	    ///
	    private ILOG.J2CsMapping.Formatting.ChoiceFormat currencyChoice;
	
	    /// <summary>
	    /// The multiplier for use in percent, permill, etc.
	    /// </summary>
	    ///
	    /// @serial
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.GetMultiplier"/>
	    private int multiplier;
	
	    /// <summary>
	    /// The number of digits between grouping separators in the integer portion
	    /// of a number. Must be greater than 0 if
	    /// <c>NumberFormat.groupingUsed</c> is true.
	    /// </summary>
	    ///
	    /// @serial
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.GetGroupingSize"/>
	    /// <seealso cref="M:IBM.ICU.Text.NumberFormat.IsGroupingUsed"/>
	    private byte groupingSize; // invariant, > 0 if useThousands
	
	    /// <summary>
	    /// The secondary grouping size. This is only used for Hindi numerals, which
	    /// use a primary grouping of 3 and a secondary grouping of 2, e.g.,
	    /// "12,34,567". If this value is less than 1, then secondary grouping is
	    /// equal to the primary grouping. [NEW]
	    /// </summary>
	    ///
	    private byte groupingSize2;
	
	    /// <summary>
	    /// If true, forces the decimal separator to always appear in a formatted
	    /// number, even if the fractional part of the number is zero.
	    /// </summary>
	    ///
	    /// @serial
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.IsDecimalSeparatorAlwaysShown"/>
	    private bool decimalSeparatorAlwaysShown;
	
	    /// <summary>
	    /// True if this object represents a currency format. This determines whether
	    /// the monetary decimal separator is used instead of the normal one.
	    /// </summary>
	    ///
	    private bool isCurrencyFormat;
	
	    /// <summary>
	    /// The <c>DecimalFormatSymbols</c> object used by this format. It
	    /// contains the symbols used to format numbers, e.g. the grouping separator,
	    /// decimal separator, and so on.
	    /// </summary>
	    ///
	    /// @serial
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.SetDecimalFormatSymbols(IBM.ICU.Text.DecimalFormatSymbols)"/>
	    /// <seealso cref="T:IBM.ICU.Text.DecimalFormatSymbols"/>
	    private DecimalFormatSymbols symbols; // LIU new
	                                                 // DecimalFormatSymbols();
	
	    /// <summary>
	    /// True to use significant digits rather than integer and fraction digit
	    /// counts.
	    /// </summary>
	    ///
	    /// @serial
	    private bool useSignificantDigits;
	
	    /// <summary>
	    /// The minimum number of significant digits to show. Must be >= 1 and <=
	    /// maxSignificantDigits. Ignored unless useSignificantDigits == true.
	    /// </summary>
	    ///
	    /// @serial
	    private int minSignificantDigits;
	
	    /// <summary>
	    /// The maximum number of significant digits to show. Must be >=
	    /// minSignficantDigits. Ignored unless useSignificantDigits == true.
	    /// </summary>
	    ///
	    /// @serial
	    private int maxSignificantDigits;
	
	    /// <summary>
	    /// True to force the use of exponential (i.e. scientific) notation when
	    /// formatting numbers.
	    /// <p>
	    /// Note that the JDK 1.2 public API provides no way to set this field, even
	    /// though it is supported by the implementation and the stream format. The
	    /// intent is that this will be added to the API in the future.
	    /// </summary>
	    ///
	    /// @serial
	    private bool useExponentialNotation; // Newly persistent in JDK 1.2
	
	    /// <summary>
	    /// The minimum number of digits used to display the exponent when a number
	    /// is formatted in exponential notation. This field is ignored if
	    /// <c>useExponentialNotation</c> is not true.
	    /// <p>
	    /// Note that the JDK 1.2 public API provides no way to set this field, even
	    /// though it is supported by the implementation and the stream format. The
	    /// intent is that this will be added to the API in the future.
	    /// </summary>
	    ///
	    /// @serial
	    private sbyte minExponentDigits; // Newly persistent in JDK 1.2
	
	    /// <summary>
	    /// <strong><font face=helvetica color=red>NEW</font></strong> If true, the
	    /// exponent is always prefixed with either the plus sign or the minus sign.
	    /// Otherwise, only negative exponents are prefixed with the minus sign. This
	    /// has no effect unless <c>useExponentialNotation</c> is true.
	    /// </summary>
	    ///
	    /// @serial
	    private bool exponentSignAlwaysShown;
	
	    // #if defined(FOUNDATION10) || defined(J2SE13)
	    // #else
	    /// <summary>
	    /// <strong><font face=helvetica color=red>NEW</font></strong> The value to
	    /// which numbers are rounded during formatting. For example, if the rounding
	    /// increment is 0.05, then 13.371 would be formatted as 13.350, assuming 3
	    /// fraction digits. Has the value <c>null</c> if rounding is not in
	    /// effect, or a positive value if rounding is in effect. Default value
	    /// <c>null</c>.
	    /// </summary>
	    ///
	    /// @serial
	    // Note: this is kept in sync with roundingIncrementICU.
	    // it is only kept around to avoid a conversion when formatting a
	    // java.math.BigDecimal
	    private Decimal roundingIncrement;
	
	    // #endif
	
	    /// <summary>
	    /// <strong><font face=helvetica color=red>NEW</font></strong> The value to
	    /// which numbers are rounded during formatting. For example, if the rounding
	    /// increment is 0.05, then 13.371 would be formatted as 13.350, assuming 3
	    /// fraction digits. Has the value <c>null</c> if rounding is not in
	    /// effect, or a positive value if rounding is in effect. Default value
	    /// <c>null</c>. WARNING: the roundingIncrement value is the one
	    /// serialized.
	    /// </summary>
	    ///
	    /// @serial
	    private BigDecimal roundingIncrementICU;
	
	    /// <summary>
	    /// <strong><font face=helvetica color=red>NEW</font></strong> The rounding
	    /// increment as a double. If this value is <= 0, then no rounding is done.
	    /// This value is <code>roundingIncrementICU.doubleValue()</code>. Default
	    /// value 0.0.
	    /// </summary>
	    ///
	    private double roundingDouble;
	
	    /// <summary>
	    /// <strong><font face=helvetica color=red>NEW</font></strong> If the
	    /// roundingDouble is the reciprocal of an integer (the most common case!),
	    /// this is set to be that integer. Otherwise it is 0.0.
	    /// </summary>
	    ///
	    private double roundingDoubleReciprocal;
	
	    /// <summary>
	    /// <strong><font face=helvetica color=red>NEW</font></strong> The rounding
	    /// mode. This value controls any rounding operations which occur when
	    /// applying a rounding increment or when reducing the number of fraction
	    /// digits to satisfy a maximum fraction digits limit. The value may assume
	    /// any of the <c>BigDecimal</c> rounding mode values. Default value
	    /// <c>BigDecimal.ROUND_HALF_EVEN</c>.
	    /// </summary>
	    ///
	    /// @serial
	    private int roundingMode;
	
	    /// <summary>
	    /// <strong><font face=helvetica color=red>NEW</font></strong> The padded
	    /// format width, or zero if there is no padding. Must be >= 0. Default value
	    /// zero.
	    /// </summary>
	    ///
	    /// @serial
	    private int formatWidth;
	
	    /// <summary>
	    /// <strong><font face=helvetica color=red>NEW</font></strong> The character
	    /// used to pad the result of format to <c>formatWidth</c>, if padding
	    /// is in effect. Default value ' '.
	    /// </summary>
	    ///
	    /// @serial
	    private char pad;
	
	    /// <summary>
	    /// <strong><font face=helvetica color=red>NEW</font></strong> The position
	    /// in the string at which the <c>pad</c> character will be inserted,
	    /// if padding is in effect. Must have a value from
	    /// <c>PAD_BEFORE_PREFIX</c> to <c>PAD_AFTER_SUFFIX</c>. Default
	    /// value <c>PAD_BEFORE_PREFIX</c>.
	    /// </summary>
	    ///
	    /// @serial
	    private int padPosition;
	
	    /// <summary>
	    /// True if <see cref="M:IBM.ICU.Text.DecimalFormat.Parse(System.String, null)"/> to return BigDecimal rather
	    /// than Long, Double or BigDecimal except special values. This property is
	    /// introduced for J2SE 5 compatibility support.
	    /// </summary>
	    ///
	    /// @serial
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.SetParseBigDecimal(System.Boolean)"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.IsParseBigDecimal"/>
	    private bool parseBigDecimal;
	
	    // ----------------------------------------------------------------------
	
	    internal const int currentSerialVersion = 3;
	
	    /// <summary>
	    /// The internal serial version which says which version was written Possible
	    /// values are:
	    /// <ul>
	    /// <li><b>0</b> (default): versions before JDK 1.2
	    /// <li><b>1</b>: version from JDK 1.2 and later, which includes the two new
	    /// fields <c>useExponentialNotation</c> and
	    /// <c>minExponentDigits</c>.
	    /// <li><b>2</b>: version on AlphaWorks, which adds roundingMode,
	    /// formatWidth, pad, padPosition, exponentSignAlwaysShown,
	    /// roundingIncrement.
	    /// <li><b>3</b>: ICU 2.2. Adds currency object.
	    /// </ul>
	    /// </summary>
	    ///
	    /// @serial
	    private int serialVersionOnStream;
	
	    // ----------------------------------------------------------------------
	    // CONSTANTS
	    // ----------------------------------------------------------------------
	
	    /// <summary>
	    /// <strong><font face=helvetica color=red>NEW</font></strong> Constant for
	    /// <c>getPadPosition()</c> and <c>setPadPosition()</c>
	    /// specifying pad characters inserted before the prefix.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.SetPadPosition(System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.GetPadPosition"/>
	    /// <seealso cref="F:IBM.ICU.Text.DecimalFormat.PAD_AFTER_PREFIX"/>
	    /// <seealso cref="F:IBM.ICU.Text.DecimalFormat.PAD_BEFORE_SUFFIX"/>
	    /// <seealso cref="F:IBM.ICU.Text.DecimalFormat.PAD_AFTER_SUFFIX"/>
	    /// @stable ICU 2.0
	    public const int PAD_BEFORE_PREFIX = 0;
	
	    /// <summary>
	    /// <strong><font face=helvetica color=red>NEW</font></strong> Constant for
	    /// <c>getPadPosition()</c> and <c>setPadPosition()</c>
	    /// specifying pad characters inserted after the prefix.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.SetPadPosition(System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.GetPadPosition"/>
	    /// <seealso cref="F:IBM.ICU.Text.DecimalFormat.PAD_BEFORE_PREFIX"/>
	    /// <seealso cref="F:IBM.ICU.Text.DecimalFormat.PAD_BEFORE_SUFFIX"/>
	    /// <seealso cref="F:IBM.ICU.Text.DecimalFormat.PAD_AFTER_SUFFIX"/>
	    /// @stable ICU 2.0
	    public const int PAD_AFTER_PREFIX = 1;
	
	    /// <summary>
	    /// <strong><font face=helvetica color=red>NEW</font></strong> Constant for
	    /// <c>getPadPosition()</c> and <c>setPadPosition()</c>
	    /// specifying pad characters inserted before the suffix.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.SetPadPosition(System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.GetPadPosition"/>
	    /// <seealso cref="F:IBM.ICU.Text.DecimalFormat.PAD_BEFORE_PREFIX"/>
	    /// <seealso cref="F:IBM.ICU.Text.DecimalFormat.PAD_AFTER_PREFIX"/>
	    /// <seealso cref="F:IBM.ICU.Text.DecimalFormat.PAD_AFTER_SUFFIX"/>
	    /// @stable ICU 2.0
	    public const int PAD_BEFORE_SUFFIX = 2;
	
	    /// <summary>
	    /// <strong><font face=helvetica color=red>NEW</font></strong> Constant for
	    /// <c>getPadPosition()</c> and <c>setPadPosition()</c>
	    /// specifying pad characters inserted after the suffix.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.SetPadPosition(System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Text.DecimalFormat.GetPadPosition"/>
	    /// <seealso cref="F:IBM.ICU.Text.DecimalFormat.PAD_BEFORE_PREFIX"/>
	    /// <seealso cref="F:IBM.ICU.Text.DecimalFormat.PAD_AFTER_PREFIX"/>
	    /// <seealso cref="F:IBM.ICU.Text.DecimalFormat.PAD_BEFORE_SUFFIX"/>
	    /// @stable ICU 2.0
	    public const int PAD_AFTER_SUFFIX = 3;
	
	    // Constants for characters used in programmatic (unlocalized) patterns.
	    private const char PATTERN_ZERO_DIGIT = '0';
	
	    private const char PATTERN_GROUPING_SEPARATOR = ',';
	
	    private const char PATTERN_DECIMAL_SEPARATOR = '.';
	
	    private const char PATTERN_DIGIT = '#';
	
	    internal const char PATTERN_SIGNIFICANT_DIGIT = '@';
	
	    internal const char PATTERN_EXPONENT = 'E'; // [NEW]
	
	    internal const char PATTERN_PLUS_SIGN = '+'; // [NEW]
	
	    // Affix
	    private const char PATTERN_PER_MILLE = '\u2030';
	
	    private const char PATTERN_PERCENT = '%';
	
	    internal const char PATTERN_PAD_ESCAPE = '*'; // [NEW]
	
	    /*
	     * Bug 4212072 To meet the need of expandAffix(String, StirngBuffer)
	     * [Richard/GCL]
	     */
	    private const char PATTERN_MINUS = '-'; // [Richard/GCL]
	
	    // Other
	    private const char PATTERN_SEPARATOR = ';';
	
	    // Pad escape is package private to allow access by DecimalFormatSymbols.
	    // Also plus sign. Also exponent.
	
	    /// <summary>
	    /// The CURRENCY_SIGN is the standard Unicode symbol for currency. It is used
	    /// in patterns and substitued with either the currency symbol, or if it is
	    /// doubled, with the international currency symbol. If the CURRENCY_SIGN is
	    /// seen in a pattern, then the decimal separator is replaced with the
	    /// monetary decimal separator.
	    /// The CURRENCY_SIGN is not localized.
	    /// </summary>
	    ///
	    private const char CURRENCY_SIGN = '\u00A4';
	
	    private const char QUOTE = '\'';
	
	    /*
	     * Upper limit on integer and fraction digits for a Java double
	     * [Richard/GCL]
	     */
	    internal const int DOUBLE_INTEGER_DIGITS = 309;
	
	    internal const int DOUBLE_FRACTION_DIGITS = 340;
	
	    /// <summary>
	    /// When someone turns on scientific mode, we assume that more than this
	    /// number of digits is due to flipping from some other mode that didn't
	    /// restrict the maximum, and so we force 1 integer digit. We don't bother to
	    /// track and see if someone is using exponential notation with more than
	    /// this number, it wouldn't make sense anyway, and this is just to make sure
	    /// that someone turning on scientific mode with default settings doesn't end
	    /// up with lots of zeroes.
	    /// </summary>
	    ///
	    internal const int MAX_SCIENTIFIC_INTEGER_DIGITS = 8;
	
	    // #if defined(FOUNDATION10) || defined(J2SE13)
	    // ## // we're not compatible with other versions, since we have no
	    // java.math.BigDecimal field
	    // ## private static final long serialVersionUID = 2;
	    // #else
	    // Proclaim JDK 1.1 serial compatibility.
	    private const long serialVersionUID = 864413376551465018L;
	
	    // #endif
	    private ArrayList attributes;
	}
	
	// eof
}
