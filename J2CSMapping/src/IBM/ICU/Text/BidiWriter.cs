/*
 *******************************************************************************
 *   Copyright (C) 2001-2007, International Business Machines
 *   Corporation and others.  All Rights Reserved.
 *******************************************************************************
 */
/* Written by Simon Montagu, Matitiahu Allouche
 * (ported from C code written by Markus W. Scherer)
 */

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:30 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Text {
	
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Text;
	
	
	internal sealed class BidiWriter {
	
	    /// <summary>
	    /// Bidi control code points 
	    /// </summary>
	    ///
	    internal const char LRM_CHAR = (char) (0x200e);
	
	    internal const char RLM_CHAR = (char) (0x200f);
	
	    static internal readonly int MASK_R_AL = (1 << IBM.ICU.Lang.UCharacterEnums.ECharacterDirection.RIGHT_TO_LEFT | 1 << IBM.ICU.Lang.UCharacterEnums.ECharacterDirection.RIGHT_TO_LEFT_ARABIC);
	
	    private static bool IsCombining(int type) {
	        return ((1 << type & (1 << IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.NON_SPACING_MARK
	                | 1 << IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.COMBINING_SPACING_MARK | 1 << IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.ENCLOSING_MARK)) != 0);
	    }
	
	    /*
	     * When we have OUTPUT_REVERSE set on writeReordered(), then we semantically
	     * write RTL runs in reverse and later reverse them again. Instead, we
	     * actually write them in forward order to begin with. However, if the RTL
	     * run was to be mirrored, we need to mirror here now since the implicit
	     * second reversal must not do it. It looks strange to do mirroring in LTR
	     * output, but it is only because we are writing RTL output in reverse.
	     */
	    private static String DoWriteForward(String src, int options) {
	        /* optimize for several combinations of options */
	        switch (options & (IBM.ICU.Text.Bidi.REMOVE_BIDI_CONTROLS | IBM.ICU.Text.Bidi.DO_MIRRORING)) {
	        case 0: {
	            /* simply copy the LTR run to the destination */
	            return src;
	        }
	        case IBM.ICU.Text.Bidi.DO_MIRRORING: {
	            StringBuilder dest = new StringBuilder(src.Length);
	
	            /* do mirroring */
	            int i = 0;
	            int c;
	
	            do {
	                c = IBM.ICU.Text.UTF16.CharAt(src, i);
	                i += IBM.ICU.Text.UTF16.GetCharCount(c);
	                IBM.ICU.Text.UTF16.Append(dest, IBM.ICU.Lang.UCharacter.GetMirror(c));
	            } while (i < src.Length);
	            return dest.ToString();
	        }
	        case IBM.ICU.Text.Bidi.REMOVE_BIDI_CONTROLS: {
	            StringBuilder dest_0 = new StringBuilder(src.Length);
	
	            /* copy the LTR run and remove any Bidi control characters */
	            int i_1 = 0;
	            char c_2;
	            do {
	                c_2 = src[i_1++];
	                if (!IBM.ICU.Text.Bidi.IsBidiControlChar(c_2)) {
	                    dest_0.Append(c_2);
	                }
	            } while (i_1 < src.Length);
	            return dest_0.ToString();
	        }
	        default: {
	            StringBuilder dest_3 = new StringBuilder(src.Length);
	
	            /* remove Bidi control characters and do mirroring */
	            int i_4 = 0;
	            int c_5;
	            do {
	                c_5 = IBM.ICU.Text.UTF16.CharAt(src, i_4);
	                i_4 += IBM.ICU.Text.UTF16.GetCharCount(c_5);
	                if (!IBM.ICU.Text.Bidi.IsBidiControlChar(c_5)) {
	                    IBM.ICU.Text.UTF16.Append(dest_3, IBM.ICU.Lang.UCharacter.GetMirror(c_5));
	                }
	            } while (i_4 < src.Length);
	            return dest_3.ToString();
	        }
	        } /* end of switch */
	    }
	
	    private static String DoWriteForward(char[] text, int start, int limit,
	            int options) {
	        return DoWriteForward(new String(text, start, limit - start), options);
	    }
	
	    static internal String WriteReverse(String src, int options) {
	        /*
	         * RTL run -
	         * 
	         * RTL runs need to be copied to the destination in reverse order of
	         * code points, not code units, to keep Unicode characters intact.
	         * 
	         * The general strategy for this is to read the source text in backward
	         * order, collect all code units for a code point (and optionally
	         * following combining characters, see below), and copy all these code
	         * units in ascending order to the destination for this run.
	         * 
	         * Several options request whether combining characters should be kept
	         * after their base characters, whether Bidi control characters should
	         * be removed, and whether characters should be replaced by their
	         * mirror-image equivalent Unicode characters.
	         */
	        StringBuilder dest = new StringBuilder(src.Length);
	
	        /* optimize for several combinations of options */
	        switch (options
	                & (IBM.ICU.Text.Bidi.REMOVE_BIDI_CONTROLS | IBM.ICU.Text.Bidi.DO_MIRRORING | IBM.ICU.Text.Bidi.KEEP_BASE_COMBINING)) {
	
	        case 0:
	            /*
	             * With none of the "complicated" options set, the destination run
	             * will have the same length as the source run, and there is no
	             * mirroring and no keeping combining characters with their base
	             * characters.
	             * 
	             * XXX: or dest = UTF16.reverse(new StringBuffer(src));
	             */
	
	            int srcLength = src.Length;
	
	            /* preserve character integrity */
	            do {
	                /*
	                 * i is always after the last code unit known to need to be kept
	                 * in this segment
	                 */
	                int i = srcLength;
	
	                /* collect code units for one base character */
	                srcLength -= IBM.ICU.Text.UTF16.GetCharCount(IBM.ICU.Text.UTF16
	                        .CharAt(src, srcLength - 1));
	
	                /* copy this base character */
	                dest.Append(src.Substring(srcLength,(i)-(srcLength)));
	            } while (srcLength > 0);
	            break;
	
	        case IBM.ICU.Text.Bidi.KEEP_BASE_COMBINING:
	            /*
	             * Here, too, the destination run will have the same length as the
	             * source run, and there is no mirroring. We do need to keep
	             * combining characters with their base characters.
	             */
	            srcLength = src.Length;
	
	            /* preserve character integrity */
	            do {
	                /*
	                 * i is always after the last code unit known to need to be kept
	                 * in this segment
	                 */
	                int c;
	                int i_0 = srcLength;
	
	                /*
	                 * collect code units and modifier letters for one base
	                 * character
	                 */
	                do {
	                    c = IBM.ICU.Text.UTF16.CharAt(src, srcLength - 1);
	                    srcLength -= IBM.ICU.Text.UTF16.GetCharCount(c);
	                } while (srcLength > 0 && IsCombining(IBM.ICU.Lang.UCharacter.GetType(c)));
	
	                /* copy this "user character" */
	                dest.Append(src.Substring(srcLength,(i_0)-(srcLength)));
	            } while (srcLength > 0);
	            break;
	
	        default:
	            /*
	             * With several "complicated" options set, this is the most general
	             * and the slowest copying of an RTL run. We will do mirroring,
	             * remove Bidi controls, and keep combining characters with their
	             * base characters as requested.
	             */
	            srcLength = src.Length;
	
	            /* preserve character integrity */
	            do {
	                /*
	                 * i is always after the last code unit known to need to be kept
	                 * in this segment
	                 */
	                int i_1 = srcLength;
	
	                /* collect code units for one base character */
	                int c_2 = IBM.ICU.Text.UTF16.CharAt(src, srcLength - 1);
	                srcLength -= IBM.ICU.Text.UTF16.GetCharCount(c_2);
	                if ((options & IBM.ICU.Text.Bidi.KEEP_BASE_COMBINING) != 0) {
	                    /* collect modifier letters for this base character */
	                    while (srcLength > 0 && IsCombining(IBM.ICU.Lang.UCharacter.GetType(c_2))) {
	                        c_2 = IBM.ICU.Text.UTF16.CharAt(src, srcLength - 1);
	                        srcLength -= IBM.ICU.Text.UTF16.GetCharCount(c_2);
	                    }
	                }
	
	                if ((options & IBM.ICU.Text.Bidi.REMOVE_BIDI_CONTROLS) != 0
	                        && IBM.ICU.Text.Bidi.IsBidiControlChar(c_2)) {
	                    /* do not copy this Bidi control character */
	                    continue;
	                }
	
	                /* copy this "user character" */
	                int j = srcLength;
	                if ((options & IBM.ICU.Text.Bidi.DO_MIRRORING) != 0) {
	                    /* mirror only the base character */
	                    c_2 = IBM.ICU.Lang.UCharacter.GetMirror(c_2);
	                    IBM.ICU.Text.UTF16.Append(dest, c_2);
	                    j += IBM.ICU.Text.UTF16.GetCharCount(c_2);
	                }
	                dest.Append(src.Substring(j,(i_1)-(j)));
	            } while (srcLength > 0);
	            break;
	        } /* end of switch */
	
	        return dest.ToString();
	    }
	
	    static internal String DoWriteReverse(char[] text, int start, int limit, int options) {
	        return WriteReverse(new String(text, start, limit - start), options);
	    }
	
	    static internal String WriteReordered(Bidi bidi, int options) {
	        int run, runCount;
	        StringBuilder dest;
	        char[] text = bidi.text;
	        runCount = bidi.CountRuns();
	
	        /*
	         * Option "insert marks" implies Bidi.INSERT_LRM_FOR_NUMERIC if the
	         * reordering mode (checked below) is appropriate.
	         */
	        if ((bidi.reorderingOptions & IBM.ICU.Text.Bidi.OPTION_INSERT_MARKS) != 0) {
	            options |= IBM.ICU.Text.Bidi.INSERT_LRM_FOR_NUMERIC;
	            options &= ~IBM.ICU.Text.Bidi.REMOVE_BIDI_CONTROLS;
	        }
	        /*
	         * Option "remove controls" implies Bidi.REMOVE_BIDI_CONTROLS and
	         * cancels Bidi.INSERT_LRM_FOR_NUMERIC.
	         */
	        if ((bidi.reorderingOptions & IBM.ICU.Text.Bidi.OPTION_REMOVE_CONTROLS) != 0) {
	            options |= IBM.ICU.Text.Bidi.REMOVE_BIDI_CONTROLS;
	            options &= ~IBM.ICU.Text.Bidi.INSERT_LRM_FOR_NUMERIC;
	        }
	        /*
	         * If we do not perform the "inverse Bidi" algorithm, then we don't need
	         * to insert any LRMs, and don't need to test for it.
	         */
	        if ((bidi.reorderingMode != IBM.ICU.Text.Bidi.REORDER_INVERSE_NUMBERS_AS_L)
	                && (bidi.reorderingMode != IBM.ICU.Text.Bidi.REORDER_INVERSE_LIKE_DIRECT)
	                && (bidi.reorderingMode != IBM.ICU.Text.Bidi.REORDER_INVERSE_FOR_NUMBERS_SPECIAL)
	                && (bidi.reorderingMode != IBM.ICU.Text.Bidi.REORDER_RUNS_ONLY)) {
	            options &= ~IBM.ICU.Text.Bidi.INSERT_LRM_FOR_NUMERIC;
	        }
	        dest = new StringBuilder(
	                ((options & IBM.ICU.Text.Bidi.INSERT_LRM_FOR_NUMERIC) != 0) ? bidi.length * 2
	                        : bidi.length);
	        /*
	         * Iterate through all visual runs and copy the run text segments to the
	         * destination, according to the options.
	         * 
	         * The tests for where to insert LRMs ignore the fact that there may be
	         * BN codes or non-BMP code points at the beginning and end of a run;
	         * they may insert LRMs unnecessarily but the tests are faster this way
	         * (this would have to be improved for UTF-8).
	         */
	        if ((options & IBM.ICU.Text.Bidi.OUTPUT_REVERSE) == 0) {
	            /* forward output */
	            if ((options & IBM.ICU.Text.Bidi.INSERT_LRM_FOR_NUMERIC) == 0) {
	                /* do not insert Bidi controls */
	                for (run = 0; run < runCount; ++run) {
	                    BidiRun bidiRun = bidi.GetVisualRun(run);
	                    if (bidiRun.IsEvenRun()) {
	                        dest.Append(DoWriteForward(text, bidiRun.start,
	                                bidiRun.limit, options & ~IBM.ICU.Text.Bidi.DO_MIRRORING));
	                    } else {
	                        dest.Append(DoWriteReverse(text, bidiRun.start,
	                                bidiRun.limit, options));
	                    }
	                }
	            } else {
	                /* insert Bidi controls for "inverse Bidi" */
	                sbyte[] dirProps = bidi.dirProps;
	                char uc;
	                int markFlag;
	
	                for (run = 0; run < runCount; ++run) {
	                    BidiRun bidiRun_0 = bidi.GetVisualRun(run);
	                    markFlag = 0;
	                    /* check if something relevant in insertPoints */
	                    markFlag = bidi.runs[run].insertRemove;
	                    if (markFlag < 0) { /* bidi controls count */
	                        markFlag = 0;
	                    }
	                    if (bidiRun_0.IsEvenRun()) {
	                        if (bidi.IsInverse()
	                                && dirProps[bidiRun_0.start] != IBM.ICU.Text.Bidi.L) {
	                            markFlag |= IBM.ICU.Text.Bidi.LRM_BEFORE;
	                        }
	                        if ((markFlag & IBM.ICU.Text.Bidi.LRM_BEFORE) != 0) {
	                            uc = LRM_CHAR;
	                        } else if ((markFlag & IBM.ICU.Text.Bidi.RLM_BEFORE) != 0) {
	                            uc = RLM_CHAR;
	                        } else {
	                            uc = ((Char)0);
	                        }
	                        if (uc != 0) {
	                            dest.Append(uc);
	                        }
	                        dest.Append(DoWriteForward(text, bidiRun_0.start,
	                                bidiRun_0.limit, options & ~IBM.ICU.Text.Bidi.DO_MIRRORING));
	
	                        if (bidi.IsInverse()
	                                && dirProps[bidiRun_0.limit - 1] != IBM.ICU.Text.Bidi.L) {
	                            markFlag |= IBM.ICU.Text.Bidi.LRM_AFTER;
	                        }
	                        if ((markFlag & IBM.ICU.Text.Bidi.LRM_AFTER) != 0) {
	                            uc = LRM_CHAR;
	                        } else if ((markFlag & IBM.ICU.Text.Bidi.RLM_AFTER) != 0) {
	                            uc = RLM_CHAR;
	                        } else {
	                            uc = ((Char)0);
	                        }
	                        if (uc != 0) {
	                            dest.Append(uc);
	                        }
	                    } else { /* RTL run */
	                        if (bidi.IsInverse()
	                                && !bidi.TestDirPropFlagAt(MASK_R_AL,
	                                        bidiRun_0.limit - 1)) {
	                            markFlag |= IBM.ICU.Text.Bidi.RLM_BEFORE;
	                        }
	                        if ((markFlag & IBM.ICU.Text.Bidi.LRM_BEFORE) != 0) {
	                            uc = LRM_CHAR;
	                        } else if ((markFlag & IBM.ICU.Text.Bidi.RLM_BEFORE) != 0) {
	                            uc = RLM_CHAR;
	                        } else {
	                            uc = ((Char)0);
	                        }
	                        if (uc != 0) {
	                            dest.Append(uc);
	                        }
	                        dest.Append(DoWriteReverse(text, bidiRun_0.start,
	                                bidiRun_0.limit, options));
	
	                        if (bidi.IsInverse()
	                                && (MASK_R_AL & IBM.ICU.Text.Bidi
	                                        .DirPropFlag(dirProps[bidiRun_0.start])) == 0) {
	                            markFlag |= IBM.ICU.Text.Bidi.RLM_AFTER;
	                        }
	                        if ((markFlag & IBM.ICU.Text.Bidi.LRM_AFTER) != 0) {
	                            uc = LRM_CHAR;
	                        } else if ((markFlag & IBM.ICU.Text.Bidi.RLM_AFTER) != 0) {
	                            uc = RLM_CHAR;
	                        } else {
	                            uc = ((Char)0);
	                        }
	                        if (uc != 0) {
	                            dest.Append(uc);
	                        }
	                    }
	                }
	            }
	        } else {
	            /* reverse output */
	            if ((options & IBM.ICU.Text.Bidi.INSERT_LRM_FOR_NUMERIC) == 0) {
	                /* do not insert Bidi controls */
	                for (run = runCount; --run >= 0;) {
	                    BidiRun bidiRun_1 = bidi.GetVisualRun(run);
	                    if (bidiRun_1.IsEvenRun()) {
	                        dest.Append(DoWriteReverse(text, bidiRun_1.start,
	                                bidiRun_1.limit, options & ~IBM.ICU.Text.Bidi.DO_MIRRORING));
	                    } else {
	                        dest.Append(DoWriteForward(text, bidiRun_1.start,
	                                bidiRun_1.limit, options));
	                    }
	                }
	            } else {
	                /* insert Bidi controls for "inverse Bidi" */
	
	                sbyte[] dirProps_2 = bidi.dirProps;
	
	                for (run = runCount; --run >= 0;) {
	                    /* reverse output */
	                    BidiRun bidiRun_3 = bidi.GetVisualRun(run);
	                    if (bidiRun_3.IsEvenRun()) {
	                        if (dirProps_2[bidiRun_3.limit - 1] != IBM.ICU.Text.Bidi.L) {
	                            dest.Append(LRM_CHAR);
	                        }
	
	                        dest.Append(DoWriteReverse(text, bidiRun_3.start,
	                                bidiRun_3.limit, options & ~IBM.ICU.Text.Bidi.DO_MIRRORING));
	
	                        if (dirProps_2[bidiRun_3.start] != IBM.ICU.Text.Bidi.L) {
	                            dest.Append(LRM_CHAR);
	                        }
	                    } else {
	                        if ((MASK_R_AL & IBM.ICU.Text.Bidi
	                                .DirPropFlag(dirProps_2[bidiRun_3.start])) == 0) {
	                            dest.Append(RLM_CHAR);
	                        }
	
	                        dest.Append(DoWriteForward(text, bidiRun_3.start,
	                                bidiRun_3.limit, options));
	
	                        if ((MASK_R_AL & IBM.ICU.Text.Bidi
	                                .DirPropFlag(dirProps_2[bidiRun_3.limit - 1])) == 0) {
	                            dest.Append(RLM_CHAR);
	                        }
	                    }
	                }
	            }
	        }
	
	        return dest.ToString();
	    }
	}
}
