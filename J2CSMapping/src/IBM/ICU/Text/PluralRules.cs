/*
 *******************************************************************************
 * Copyright (C) 2007, International Business Machines Corporation and         *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 */

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:30 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Text {
	
	using IBM.ICU.Util;
	using ILOG.J2CsMapping.Collections;
	using ILOG.J2CsMapping.Collections.Generics;
	using ILOG.J2CsMapping.Util;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Runtime.Serialization;
	
	/// <summary>
	/// <p>
	/// Defines rules for mapping positive long values onto a small set of keywords.
	/// Serializable so can be used in formatters, which are serializable. Rules are
	/// constructed from a text description, consisting of a series of keywords and
	/// conditions. The <see cref="M:IBM.ICU.Text.PluralRules.Select(System.Int64)"/> method examines each condition in order and
	/// returns the keyword for the first condition that matches the number. If none
	/// match, <see cref="F:IBM.ICU.Text.PluralRules.KEYWORD_OTHER"/> is returned.
	/// </p>
	/// <p>
	/// Examples:
	/// <pre>
	/// &quot;one: n is 1; few: n in 2..4&quot;
	/// </pre>
	/// </p>
	/// <p>
	/// This defines two rules, for 'one' and 'few'. The condition for 'one' is
	/// "n is 1" which means that the number must be equal to 1 for this condition to
	/// pass. The condition for 'few' is "n in 2..4" which means that the number must
	/// be between 2 and 4 inclusive for this condition to pass. All other numbers
	/// are assigned the keyword "other" by the default rule.
	/// </p>
	/// <p>
	/// <pre>
	/// &quot;zero: n is 0; one: n is 1; zero: n mod 100 in 1..19&quot;
	/// </pre>
	/// This illustrates that the same keyword can be defined multiple times. Each
	/// rule is examined in order, and the first keyword whose condition passes is
	/// the one returned. Also notes that a modulus is applied to n in the last rule.
	/// Thus its condition holds for 119, 219, 319...
	/// </p>
	/// <p>
	/// <pre>
	/// &quot;one: n is 1; few: n mod 10 in 2..4 and n mod 100 not in 12..14&quot;
	/// </pre>
	/// </p>
	/// <p>
	/// This illustrates conjunction and negation. The condition for 'few' has two
	/// parts, both of which must be met: "n mod 10 in 2..4" and
	/// "n mod 100 not in 12..14". The first part applies a modulus to n before the
	/// test as in the previous example. The second part applies a different modulus
	/// and also uses negation, thus it matches all numbers _not_ in 12, 13, 14, 112,
	/// 113, 114, 212, 213, 214...
	/// </p>
	/// <p>
	/// Syntax:
	/// <pre>
	/// rules         = rule (';' rule)
	/// rule          = keyword ':' condition
	/// keyword       = <identifier>
	/// condition     = and_condition ('or' and_condition)
	/// and_condition = relation ('and' relation)
	/// relation      = is_relation | in_relation | 'n' <EOL>
	/// is_relation   = expr 'is' ('not')? value
	/// in_relation   = expr ('not')? 'in' range
	/// expr          = 'n' ('mod' value)?
	/// value         = digit+
	/// digit         = 0|1|2|3|4|5|6|7|8|9
	/// range         = value'..'value
	/// </pre>
	/// </p>
	/// </summary>
	///
	/// @draft ICU 3.8
	/// @provisional This API might change or be removed in a future release.
	[Serializable]
	public class PluralRules {
	    private const long serialVersionUID = 1;
	
	    private static readonly IDictionary ruleMap; // from locale string to PluralRules
	
	    private readonly PluralRules.RuleList  rules;
	
	    private readonly ILOG.J2CsMapping.Collections.ISet keywords;
	
	    private int repeatLimit; // for equality test
	
	    // Standard keywords.
	
	    /// <summary>
	    /// Common name for the 'zero' plural form.
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const String KEYWORD_ZERO = "zero";
	
	    /// <summary>
	    /// Common name for the 'singular' plural form.
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const String KEYWORD_ONE = "one";
	
	    /// <summary>
	    /// Common name for the 'dual' plural form.
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const String KEYWORD_TWO = "two";
	
	    /// <summary>
	    /// Common name for the 'paucal' or other special plural form.
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const String KEYWORD_FEW = "few";
	
	    /// <summary>
	    /// Common name for the arabic (11 to 99) plural form.
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const String KEYWORD_MANY = "many";
	
	    /// <summary>
	    /// Common name for the default plural form. This name is returned for values
	    /// to which no other form in the rule applies. It can additionally be
	    /// assigned rules of its own.
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const String KEYWORD_OTHER = "other";
	
	    /// <summary>
	    /// The set of all characters a valid keyword can start with.
	    /// </summary>
	    ///
	    private static readonly UnicodeSet START_CHARS = new UnicodeSet(
	            "[[:ID_Start:][_]]");
	
	    /// <summary>
	    /// The set of all characters a valid keyword can contain after the first
	    /// character.
	    /// </summary>
	    ///
	    private static readonly UnicodeSet CONT_CHARS = new UnicodeSet(
	            "[:ID_Continue:]");
	
	    /// <summary>
	    /// The default constraint that is always satisfied.
	    /// </summary>
	    ///
	    private static readonly PluralRules.Constraint  NO_CONSTRAINT = new PluralRules.Anonymous_C1 ();
	
	    /// <summary>
	    /// The default rule that always returns "other".
	    /// </summary>
	    ///
	    private static readonly PluralRules.Rule  DEFAULT_RULE = new PluralRules.Anonymous_C0 ();
	
	    /// <summary>
	    /// The default rules that accept any number and return<see cref="F:IBM.ICU.Text.PluralRules.KEYWORD_OTHER"/>.
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public static readonly PluralRules DEFAULT = new PluralRules(new PluralRules.RuleChain (
	            DEFAULT_RULE));
	
	    /// <summary>
	    /// Parses a plural rules description and returns a PluralRules.
	    /// </summary>
	    ///
	    /// <param name="description">the rule description.</param>
	    /// <exception cref="ParseException">if the description cannot be parsed. The exception index istypically not set, it will be -1.</exception>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public static PluralRules ParseDescription(String description) {
	
	        description = description.Trim();
	        if (description.Length == 0) {
	            return DEFAULT;
	        }
	
	        return new PluralRules(ParseRuleChain(description));
	    }
	
	    /// <summary>
	    /// Creates a PluralRules from a description if it is parsable, otherwise
	    /// returns null.
	    /// </summary>
	    ///
	    /// <param name="description">the rule description.</param>
	    /// <returns>the PluralRules</returns>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public static PluralRules CreateRules(String description) {
	        try {
	            return ParseDescription(description);
	        } catch (ParseException e) {
	            return null;
	        }
	    }
	
	    [Serializable]
	    public sealed class Anonymous_C1 : PluralRules.Constraint  {
	        private const long serialVersionUID = 9163464945387899416L;
	
	        public bool IsFulfilled(long n) {
	            return true;
	        }
	
	        public override String ToString() {
	            return "n is any";
	        }
	
	        public int UpdateRepeatLimit(int limit) {
	            return limit;
	        }
	    }
	
	    [Serializable]
	    public sealed class Anonymous_C0 : PluralRules.Rule  {
	        private const long serialVersionUID = -5677499073940822149L;
	
	        public String GetKeyword() {
	            return IBM.ICU.Text.PluralRules.KEYWORD_OTHER;
	        }
	
	        public bool AppliesTo(long n) {
	            return true;
	        }
	
	        public override String ToString() {
	            return "(" + IBM.ICU.Text.PluralRules.KEYWORD_OTHER + ")";
	        }
	
	        public int UpdateRepeatLimit(int limit) {
	            return limit;
	        }
	    }
	
	    /// <summary>
	    /// A constraint on a number.
	    /// </summary>
	    ///
	    private interface Constraint {
	        /// <summary>
	        /// Returns true if the number fulfills the constraint.
	        /// </summary>
	        ///
	        /// <param name="n">the number to test, >= 0.</param>
	        bool IsFulfilled(long n);
	
	        /// <summary>
	        /// Returns the larger of limit or the limit of this constraint. If the
	        /// constraint is a simple range test, this is the higher end of the
	        /// range; if it is a modulo test, this is the modulus.
	        /// </summary>
	        ///
	        /// <param name="limit">the target limit</param>
	        /// <returns>the new limit</returns>
	        int UpdateRepeatLimit(int limit);
	    }
	
	    /// <summary>
	    /// A pluralization rule. .
	    /// </summary>
	    ///
	    private interface Rule {
	        /// <summary>
	        /// Returns the keyword that names this rule. 
	        /// </summary>
	        ///
	        String GetKeyword();
	
	        /// <summary>
	        /// Returns true if the rule applies to the number. 
	        /// </summary>
	        ///
	        bool AppliesTo(long n);
	
	        /// <summary>
	        /// Returns the larger of limit and this rule's limit. 
	        /// </summary>
	        ///
	        int UpdateRepeatLimit(int limit);
	    }
	
	    /// <summary>
	    /// A list of rules to apply in order.
	    /// </summary>
	    ///
	    private interface RuleList {
	        /// <summary>
	        /// Returns the keyword of the first rule that applies to the number. 
	        /// </summary>
	        ///
	        String Select(long n);
	
	        /// <summary>
	        /// Returns the set of defined keywords. 
	        /// </summary>
	        ///
	        ILOG.J2CsMapping.Collections.ISet GetKeywords();
	
	        /// <summary>
	        /// Return the value at which this rulelist starts repeating. 
	        /// </summary>
	        ///
	        int GetRepeatLimit();
	    }
	
	    /// <summary>
	    /// syntax: condition : or_condition and_condition or_condition :
	    /// and_condition 'or' condition and_condition : relation relation 'and'
	    /// relation relation : is_relation in_relation 'n' EOL is_relation : expr
	    /// 'is' value expr 'is' 'not' value in_relation : expr 'in' range expr 'not'
	    /// 'in' range expr : 'n' 'n' 'mod' value value : digit+ digit :
	    /// 0|1|2|3|4|5|6|7|8|9 range : value'..'value
	    /// </summary>
	    ///
	    private static PluralRules.Constraint  ParseConstraint(String description) {
	
	        description = description.Trim().ToLower(System.Globalization.CultureInfo.CreateSpecificCulture("en"));
	
	        PluralRules.Constraint  result = null;
	        String[] or_together = IBM.ICU.Impl.Utility.SplitString(description, "or");
	        for (int i = 0; i < or_together.Length; ++i) {
	            PluralRules.Constraint  andConstraint = null;
	            String[] and_together = IBM.ICU.Impl.Utility.SplitString(or_together[i], "and");
	            for (int j = 0; j < and_together.Length; ++j) {
	                PluralRules.Constraint  newConstraint = NO_CONSTRAINT;
	
	                String condition = and_together[j].Trim();
	                String[] tokens = IBM.ICU.Impl.Utility.SplitWhitespace(condition);
	
	                int mod = 0;
	                bool within = true;
	                long lowBound = -1;
	                long highBound = -1;
	
	                bool isRange = false;
	
	                int x = 0;
	                String t = tokens[x++];
	                if (!"n".Equals(t)) {
	                    throw Unexpected(t, condition);
	                }
	                if (x < tokens.Length) {
	                    t = tokens[x++];
	                    if ("mod".Equals(t)) {
	                        mod = Int32.Parse(tokens[x++]);
	                        t = NextToken(tokens, x++, condition);
	                    }
	                    if ("is".Equals(t)) {
	                        t = NextToken(tokens, x++, condition);
	                        if ("not".Equals(t)) {
	                            within = false;
	                            t = NextToken(tokens, x++, condition);
	                        }
	                    } else {
	                        isRange = true;
	                        if ("not".Equals(t)) {
	                            within = false;
	                            t = NextToken(tokens, x++, condition);
	                        }
	                        if ("in".Equals(t)) {
	                            t = NextToken(tokens, x++, condition);
	                        } else {
	                            throw Unexpected(t, condition);
	                        }
	                    }
	
	                    if (isRange) {
	                        String[] pair = IBM.ICU.Impl.Utility.SplitString(t, "..");
	                        if (pair.Length == 2) {
	                            lowBound = ((Int64 )Int64.Parse(pair[0],System.Globalization.NumberStyles.Integer));
	                            highBound = ((Int64 )Int64.Parse(pair[1],System.Globalization.NumberStyles.Integer));
	                        } else {
	                            throw Unexpected(t, condition);
	                        }
	                    } else {
	                        lowBound = highBound = ((Int64 )Int64.Parse(t,System.Globalization.NumberStyles.Integer));
	                    }
	
	                    if (x != tokens.Length) {
	                        throw Unexpected(tokens[x], condition);
	                    }
	
	                    newConstraint = new PluralRules.RangeConstraint (mod, within, lowBound,
	                            highBound);
	                }
	
	                if (andConstraint == null) {
	                    andConstraint = newConstraint;
	                } else {
	                    andConstraint = new PluralRules.AndConstraint (andConstraint,
	                            newConstraint);
	                }
	            }
	
	            if (result == null) {
	                result = andConstraint;
	            } else {
	                result = new PluralRules.OrConstraint (result, andConstraint);
	            }
	        }
	
	        return result;
	    }
	
	    /// <summary>
	    /// Returns a parse exception wrapping the token and context strings. 
	    /// </summary>
	    ///
	    private static ParseException Unexpected(String token, String context) {
	        return new ILOG.J2CsMapping.Util.ParseException("unexpected token '" + token + "' in '"
	                        + context + "'"+-1);
	    }
	
	    /// <summary>
	    /// Returns the token at x if available, else throws a parse exception.
	    /// </summary>
	    ///
	    private static String NextToken(String[] tokens, int x, String context) {
	        if (x < tokens.Length) {
	            return tokens[x];
	        }
	        throw new ILOG.J2CsMapping.Util.ParseException("missing token at end of '" + context + "'"+-1);
	    }
	
	    /// <summary>
	    /// Syntax: rule : keyword ':' condition keyword: <identifier>
	    /// </summary>
	    ///
	    private static PluralRules.Rule  ParseRule(String description) {
	        int x = description.IndexOf(':');
	        if (x == -1) {
	            throw new ILOG.J2CsMapping.Util.ParseException("missing ':' in rule description '"
	                                + description + "'"+0);
	        }
	
	        String keyword = description.Substring(0,(x)-(0)).Trim();
	        if (!IsValidKeyword(keyword)) {
	            throw new ILOG.J2CsMapping.Util.ParseException("keyword '" + keyword + " is not valid"+0);
	        }
	
	        description = description.Substring(x + 1).Trim();
	        if (description.Length == 0) {
	            throw new ILOG.J2CsMapping.Util.ParseException("missing constraint in '" + description
	                                + "'"+x + 1);
	        }
	        PluralRules.Constraint  constraint = ParseConstraint(description);
	        PluralRules.Rule  rule = new PluralRules.ConstrainedRule (keyword, constraint);
	        return rule;
	    }
	
	    /// <summary>
	    /// Syntax: rules : rule rule ';' rules
	    /// </summary>
	    ///
	    private static PluralRules.RuleChain  ParseRuleChain(String description) {
	
	        PluralRules.RuleChain  rc = null;
	        String[] rules_0 = IBM.ICU.Impl.Utility.Split(description, ';');
	        for (int i = 0; i < rules_0.Length; ++i) {
	            PluralRules.Rule  r = ParseRule(rules_0[i].Trim());
	            if (rc == null) {
	                rc = new PluralRules.RuleChain (r);
	            } else {
	                rc = rc.AddRule(r);
	            }
	        }
	        return rc;
	    }
	
	    /// <summary>
	    /// An implementation of Constraint representing a modulus, a range of
	    /// values, and include/exclude. Provides lots of convenience factory
	    /// methods.
	    /// </summary>
	    ///
	    [Serializable]
	    private class RangeConstraint : PluralRules.Constraint {
	        private const long serialVersionUID = 1;
	
	        private int mod;
	
	        private bool within;
	
	        private long lowerBound;
	
	        private long upperBound;
	
	        public virtual bool IsFulfilled(long n) {
	            if (mod != 0) {
	                n = n % mod;
	            }
	            return within == (n >= lowerBound && n <= upperBound);
	        }
	
	        internal RangeConstraint(int mod_0, bool within_1, long lowerBound_2,
	                long upperBound_3) {
	            this.mod = mod_0;
	            this.within = within_1;
	            this.lowerBound = lowerBound_2;
	            this.upperBound = upperBound_3;
	        }
	
	        public virtual int UpdateRepeatLimit(int limit) {
	            int mylimit = (mod == 0) ? (int) upperBound : mod;
	            return Math.Max(mylimit,limit);
	        }
	
	        public override String ToString() {
	            return "[mod: " + mod + " within: " + within + " low: "
	                    + lowerBound + " high: " + upperBound + "]";
	        }
	    }
	
	    /// <summary>
	    /// Convenience base class for and/or constraints. 
	    /// </summary>
	    ///
	    [Serializable]
	    private abstract class BinaryConstraint : PluralRules.Constraint {
	        private const long serialVersionUID = 1;
	
	        protected internal readonly PluralRules.Constraint  a;
	
	        protected internal readonly PluralRules.Constraint  b;
	
	        private readonly String conjunction;
	
	        protected internal BinaryConstraint(PluralRules.Constraint  a_0, PluralRules.Constraint  b_1, String c) {
	            this.a = a_0;
	            this.b = b_1;
	            this.conjunction = c;
	        }
	
	        public virtual int UpdateRepeatLimit(int limit) {
	            return a.UpdateRepeatLimit(b.UpdateRepeatLimit(limit));
	        }
	
	        public override String ToString() {
	            return a.ToString() + conjunction + b.ToString();
	        }
	
	        /// <summary>
	        /// from com.ibm.icu.text.PluralRules.Constraint
	        /// </summary>
	        ///
	        public abstract bool IsFulfilled(long n);
	    }
	
	    /// <summary>
	    /// A constraint representing the logical and of two constraints. 
	    /// </summary>
	    ///
	    [Serializable]
	    private class AndConstraint : PluralRules.BinaryConstraint  {
	        private const long serialVersionUID = 7766999779862263523L;
	
	        internal AndConstraint(PluralRules.Constraint  a_0, PluralRules.Constraint  b_1) : base(a_0, b_1, " && ") {
	        }
	
	        public override bool IsFulfilled(long n) {
	            return a.IsFulfilled(n) && b.IsFulfilled(n);
	        }
	    }
	
	    /// <summary>
	    /// A constraint representing the logical or of two constraints. 
	    /// </summary>
	    ///
	    [Serializable]
	    private class OrConstraint : PluralRules.BinaryConstraint  {
	        private const long serialVersionUID = 1405488568664762222L;
	
	        internal OrConstraint(PluralRules.Constraint  a_0, PluralRules.Constraint  b_1) : base(a_0, b_1, " || ") {
	        }
	
	        public override bool IsFulfilled(long n) {
	            return a.IsFulfilled(n) || b.IsFulfilled(n);
	        }
	    }
	
	    /// <summary>
	    /// Implementation of Rule that uses a constraint. Provides 'and' and 'or' to
	    /// combine constraints. Immutable.
	    /// </summary>
	    ///
	    [Serializable]
	    private class ConstrainedRule : PluralRules.Rule {
	        private const long serialVersionUID = 1;
	
	        private readonly String keyword;
	
	        private readonly PluralRules.Constraint  constraint;
	
	        public ConstrainedRule(String keyword_0, PluralRules.Constraint  constraint_1) {
	            this.keyword = keyword_0;
	            this.constraint = constraint_1;
	        }
	
	        public PluralRules.Rule  And(PluralRules.Constraint  c) {
	            return new PluralRules.ConstrainedRule (keyword,
	                    new PluralRules.AndConstraint (constraint, c));
	        }
	
	        public PluralRules.Rule  Or(PluralRules.Constraint  c) {
	            return new PluralRules.ConstrainedRule (keyword, new PluralRules.OrConstraint (constraint, c));
	        }
	
	        public virtual String GetKeyword() {
	            return keyword;
	        }
	
	        public virtual bool AppliesTo(long n) {
	            return constraint.IsFulfilled(n);
	        }
	
	        public virtual int UpdateRepeatLimit(int limit) {
	            return constraint.UpdateRepeatLimit(limit);
	        }
	
	        public override String ToString() {
	            return keyword + ": " + constraint;
	        }
	    }
	
	    /// <summary>
	    /// Implementation of RuleList that is itself a node in a linked list.
	    /// Immutable, but supports chaining with 'addRule'.
	    /// </summary>
	    ///
	    [Serializable]
	    private class RuleChain : PluralRules.RuleList {
	        private const long serialVersionUID = 1;
	
	        private readonly PluralRules.Rule  rule;
	
	        private readonly PluralRules.RuleChain  next;
	
	        /// <summary>
	        /// Creates a rule chain with the single rule. 
	        /// </summary>
	        ///
	        public RuleChain(PluralRules.Rule  rule_0) : this(rule_0, null) {
	        }
	
	        public RuleChain(PluralRules.Rule  rule_0, PluralRules.RuleChain  next_1) {
	            this.rule = rule_0;
	            this.next = next_1;
	        }
	
	        public PluralRules.RuleChain  AddRule(PluralRules.Rule  nextRule) {
	            return new PluralRules.RuleChain (nextRule, this);
	        }
	
	        public PluralRules.Rule  SelectRule(long n) {
	            PluralRules.Rule  r = null;
	            if (next != null) {
	                r = next.SelectRule(n);
	            }
	            if (r == null && rule.AppliesTo(n)) {
	                r = rule;
	            }
	            return r;
	        }
	
	        public virtual String Select(long n) {
	            PluralRules.Rule  r = SelectRule(n);
	            if (r == null) {
	                return IBM.ICU.Text.PluralRules.KEYWORD_OTHER;
	            }
	            return r.GetKeyword();
	        }
	
	        public virtual ILOG.J2CsMapping.Collections.ISet GetKeywords() {
	            ILOG.J2CsMapping.Collections.ISet result = new HashedSet();
	            ILOG.J2CsMapping.Collections.Generics.Collections.Add(result,IBM.ICU.Text.PluralRules.KEYWORD_OTHER);
	            PluralRules.RuleChain  rc = this;
	            while (rc != null) {
	                ILOG.J2CsMapping.Collections.Generics.Collections.Add(result,rc.rule.GetKeyword());
	                rc = rc.next;
	            }
	            return result;
	        }
	
	        public virtual int GetRepeatLimit() {
	            int result = 0;
	            PluralRules.RuleChain  rc = this;
	            while (rc != null) {
	                result = rc.rule.UpdateRepeatLimit(result);
	                rc = rc.next;
	            }
	            return result;
	        }
	
	        public override String ToString() {
	            String s = rule.ToString();
	            if (next != null) {
	                s = next.ToString() + "; " + s;
	            }
	            return s;
	        }
	    }
	
	    // -------------------------------------------------------------------------
	    // Static class methods.
	    // -------------------------------------------------------------------------
	
	    /// <summary>
	    /// Provides access to the predefined <c>PluralRules</c> for a given
	    /// locale.
	    /// </summary>
	    ///
	    /// <param name="locale">The locale for which a <c>PluralRules</c> object isreturned.</param>
	    /// <returns>The predefined <c>PluralRules</c> object for this locale.
	    /// If there's no predefined rules for this locale, the rules for the
	    /// closest parent in the locale hierarchy that has one will be
	    /// returned. The final fallback always returns the default rules.</returns>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public static PluralRules ForLocale(ULocale locale) {
	        PluralRules result = null;
	        while (null == (result = (PluralRules) ILOG.J2CsMapping.Collections.Collections.Get(ruleMap,locale.GetName()))) {
	            locale = locale.GetFallback();
	            if (locale == null) {
	                return DEFAULT;
	            }
	        }
	        return result;
	    }
	
	    /// <summary>
	    /// Checks whether a token is a valid keyword.
	    /// </summary>
	    ///
	    /// <param name="token">the token to be checked</param>
	    /// <returns>true if the token is a valid keyword.</returns>
	    private static bool IsValidKeyword(String token) {
	        if (token.Length > 0 && START_CHARS.Contains(token[0])) {
	            for (int i = 1; i < token.Length; ++i) {
	                if (!CONT_CHARS.Contains(token[i])) {
	                    return false;
	                }
	            }
	            return true;
	        }
	        return false;
	    }
	
	    /// <summary>
	    /// Creates a new <c>PluralRules</c> object. Immutable.
	    /// </summary>
	    ///
	    private PluralRules(PluralRules.RuleList  rules_0) {
	        this.rules = rules_0;
	        this.keywords = ILOG.J2CsMapping.Collections.Generics.Collections.UnmodifiableSet(rules_0.GetKeywords());
	    }
	
	    /// <summary>
	    /// Given a number, returns the keyword of the first rule that applies to the
	    /// number.
	    /// </summary>
	    ///
	    /// <param name="number">The number for which the rule has to be determined.</param>
	    /// <returns>The keyword of the selected rule.</returns>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public String Select(long number) {
	        return rules.Select(number);
	    }
	
	    /// <summary>
	    /// Returns a set of all rule keywords used in this <c>PluralRules</c>
	    /// object. The rule "other" is always present by default.
	    /// </summary>
	    ///
	    /// <returns>The set of keywords.</returns>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public ILOG.J2CsMapping.Collections.ISet GetKeywords() {
	        return keywords;
	    }
	
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public override String ToString() {
	        return "keywords: " + keywords + " rules: " + rules.ToString()
	                + " limit: " + GetRepeatLimit();
	    }
	
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public override int GetHashCode() {
	        return keywords.GetHashCode();
	    }
	
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public override bool Equals(Object rhs) {
	        return rhs  is  PluralRules && Equals((PluralRules) rhs);
	    }
	
	    /// <summary>
	    /// Return tif rhs is equal to this.
	    /// </summary>
	    ///
	    /// <param name="rhs">the PluralRules to compare to.</param>
	    /// <returns>true if this and rhs are equal.</returns>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public bool Equals(PluralRules rhs) {
	        if (rhs == null) {
	            return false;
	        }
	        if (rhs == this) {
	            return true;
	        }
	        if (!rhs.GetKeywords().Equals(keywords)) {
	            return false;
	        }
	
	        int limit = Math.Max(GetRepeatLimit(),rhs.GetRepeatLimit());
	        for (int i = 0; i < limit; ++i) {
	            if (!Select(i).Equals(rhs.Select(i))) {
	                return false;
	            }
	        }
	        return true;
	    }
	
	    private int GetRepeatLimit() {
	        if (repeatLimit == 0) {
	            repeatLimit = rules.GetRepeatLimit() + 1;
	        }
	        return repeatLimit;
	    }
	
	    static PluralRules() {
	            String[] ruledata = {
	                    "other: n/ja,ko,tr,vi",
	                    "zero: n is 0; one: n is 1; two: n is 2; few: n in 3..10; "
	                            + "many: n in 11..99/ar",
	                    "one: n is 1/da,de,el,en,eo,es,et,fi,fo,he,hu,it,nb,nl,nn,no,pt,sv",
	                    "one: n in 0..1/fr,pt_BR",
	                    "zero: n is 0; one: n mod 10 is 1 and n mod 100 is not 11/lv",
	                    "one: n is 1; two: n is 2/ga",
	                    "zero: n is 0; one: n is 1; zero: n mod 100 in 1..19/ro",
	                    "other: n mod 100 in 11..19; one: n mod 10 is 1; "
	                            + "few: n mod 10 in 2..9/lt",
	                    "one: n mod 10 is 1 and n mod 100 is not 11; "
	                            + "few: n mod 10 in 2..4 "
	                            + "and n mod 100 not in 12..14/hr,ru,sr,uk",
	                    "one: n is 1; few: n in 2..4/cs,sk",
	                    "one: n is 1; few: n mod 10 in 2..4 and n mod 100 not in 12..14/pl",
	                    "one: n mod 100 is 1; two: n mod 100 is 2; "
	                            + "few: n mod 100 in 3..4/sl" };
	            Hashtable map = new Hashtable();
	            for (int i = 0; i < ruledata.Length; ++i) {
	                String[] data = IBM.ICU.Impl.Utility.Split(ruledata[i], '/');
	                try {
	                    PluralRules pluralRules = ParseDescription(data[0]);
	                    String[] locales = IBM.ICU.Impl.Utility.Split(data[1], ',');
	                    for (int j = 0; j < locales.Length; ++j) {
	                        ILOG.J2CsMapping.Collections.Collections.Put(map,locales[j].Trim(),pluralRules);
	                    }
	                } catch (Exception e) {
	                    System.Console.Error.WriteLine("PluralRules init failure, "
	                            + e.Message + " at line " + i);
	                }
	            }
	            ruleMap = map;
	        }
	}
}
