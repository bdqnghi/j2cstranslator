/*
 *******************************************************************************
 * Copyright (C) 1996-2007, International Business Machines Corporation and    *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 */

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:30 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Text {
	
	using IBM.ICU.Impl;
	using IBM.ICU.Util;
	using ILOG.J2CsMapping.Text;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.Globalization;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Text;
     using ILOG.J2CsMapping.Util;
	
	/// <summary>
	/// <p>
	/// <c>StringSearch</c> is the concrete subclass of
	/// <c>SearchIterator</c> that provides language-sensitive text searching
	/// based on the comparison rules defined in a <see cref="T:IBM.ICU.Text.RuleBasedCollator"/> object.
	/// </p>
	/// <p>
	/// <c>StringSearch</c> uses a version of the fast Boyer-Moore search
	/// algorithm that has been adapted to work with the large character set of
	/// Unicode. Refer to <a href=
	/// "http://www.icu-project.org/docs/papers/efficient_text_searching_in_java.html"
	/// > "Efficient Text Searching in Java"</a>, published in the <i>Java Report</i>
	/// on February, 1999, for further information on the algorithm.
	/// </p>
	/// <p>
	/// Users are also strongly encouraged to read the section on <a
	/// href="http://www.icu-project.org/userguide/searchString.html"> String
	/// Search</a> and <a
	/// href="http://www.icu-project.org/userguide/Collate_Intro.html"> Collation</a>
	/// in the user guide before attempting to use this class.
	/// </p>
	/// <p>
	/// String searching becomes a little complicated when accents are encountered at
	/// match boundaries. If a match is found and it has preceding or trailing
	/// accents not part of the match, the result returned will include the preceding
	/// accents up to the first base character, if the pattern searched for starts an
	/// accent. Likewise, if the pattern ends with an accent, all trailing accents up
	/// to the first base character will be included in the result.
	/// </p>
	/// <p>
	/// For example, if a match is found in target text "a&#92;u0325&#92;u0300" for
	/// the pattern "a&#92;u0325", the result returned by StringSearch will be the
	/// index 0 and length 3 &lt;0, 3&gt;. If a match is found in the target
	/// "a&#92;u0325&#92;u0300" for the pattern "&#92;u0300", then the result will be
	/// index 1 and length 2 <1, 2>.
	/// </p>
	/// <p>
	/// In the case where the decomposition mode is on for the RuleBasedCollator, all
	/// matches that starts or ends with an accent will have its results include
	/// preceding or following accents respectively. For example, if pattern "a" is
	/// looked for in the target text "&aacute;&#92;u0325", the result will be index
	/// 0 and length 2 &lt;0, 2&gt;.
	/// </p>
	/// <p>
	/// The StringSearch class provides two options to handle accent matching
	/// described below:
	/// </p>
	/// <p>
	/// Let S' be the sub-string of a text string S between the offsets start and end
	/// &lt;start, end&gt;. <br>
	/// A pattern string P matches a text string S at the offsets &lt;start,
	/// length&gt; <br>
	/// if
	/// <pre>
	/// option 1. P matches some canonical equivalent string of S'. Suppose the 
	/// RuleBasedCollator used for searching has a collation strength of 
	/// TERTIARY, all accents are non-ignorable. If the pattern 
	/// "a&#92;u0300" is searched in the target text 
	/// "a&#92;u0325&#92;u0300", 
	/// a match will be found, since the target text is canonically 
	/// equivalent to "a&#92;u0300&#92;u0325"
	/// option 2. P matches S' and if P starts or ends with a combining mark, 
	/// there exists no non-ignorable combining mark before or after S' 
	/// in S respectively. Following the example above, the pattern 
	/// "a&#92;u0300" will not find a match in "a&#92;u0325&#92;u0300", 
	/// since
	/// there exists a non-ignorable accent '&#92;u0325' in the middle of 
	/// 'a' and '&#92;u0300'. Even with a target text of 
	/// "a&#92;u0300&#92;u0325" a match will not be found because of the 
	/// non-ignorable trailing accent &#92;u0325.
	/// </pre>
	/// Option 2. will be the default mode for dealing with boundary accents unless
	/// specified via the API setCanonical(boolean). One restriction is to be noted
	/// for option 1. Currently there are no composite characters that consists of a
	/// character with combining class > 0 before a character with combining class ==
	/// 0. However, if such a character exists in the future, the StringSearch may
	/// not work correctly with option 1 when such characters are encountered.
	/// </p>
	/// <p>
	/// <tt>SearchIterator</tt> provides APIs to specify the starting position within
	/// the text string to be searched, e.g. <tt>setIndex</tt>, <tt>preceding</tt>
	/// and <tt>following</tt>. Since the starting position will be set as it is
	/// specified, please take note that there are some dangerous positions which the
	/// search may render incorrect results:
	/// <ul>
	/// <li>The midst of a substring that requires decomposition.
	/// <li>If the following match is to be found, the position should not be the
	/// second character which requires to be swapped with the preceding character.
	/// Vice versa, if the preceding match is to be found, position to search from
	/// should not be the first character which requires to be swapped with the next
	/// character. E.g certain Thai and Lao characters require swapping.
	/// <li>If a following pattern match is to be found, any position within a
	/// contracting sequence except the first will fail. Vice versa if a preceding
	/// pattern match is to be found, a invalid starting point would be any character
	/// within a contracting sequence except the last.
	/// </ul>
	/// </p>
	/// <p>
	/// Though collator attributes will be taken into consideration while performing
	/// matches, there are no APIs provided in StringSearch for setting and getting
	/// the attributes. These attributes can be set by getting the collator from
	/// <tt>getCollator</tt> and using the APIs in <tt>com.ibm.icu.text.Collator</tt>
	/// . To update StringSearch to the new collator attributes, <tt>reset()</tt> or
	/// <tt>setCollator(RuleBasedCollator)</tt> has to be called.
	/// </p>
	/// <p>
	/// Consult the <a href="http://www.icu-project.org/userguide/searchString.html">
	/// String Search</a> user guide and the <c>SearchIterator</c>
	/// documentation for more information and examples of use.
	/// </p>
	/// <p>
	/// This class is not subclassable
	/// </p>
	/// </summary>
	///
	/// <seealso cref="T:IBM.ICU.Text.SearchIterator"/>
	/// <seealso cref="T:IBM.ICU.Text.RuleBasedCollator"/>
	/// @stable ICU 2.0
	// internal notes: all methods do not guarantee the correct status of the
	// characteriterator. the caller has to maintain the original index position
	// if necessary. methods could change the index position as it deems fit
	public sealed class StringSearch : SearchIterator {
	
	    // public constructors --------------------------------------------------
	
	    /// <summary>
	    /// Initializes the iterator to use the language-specific rules defined in
	    /// the argument collator to search for argument pattern in the argument
	    /// target text. The argument breakiter is used to define logical matches.
	    /// See super class documentation for more details on the use of the target
	    /// text and BreakIterator.
	    /// </summary>
	    ///
	    /// <param name="pattern">text to look for.</param>
	    /// <param name="target">target text to search for pattern.</param>
	    /// <param name="collator">RuleBasedCollator that defines the language rules</param>
	    /// <param name="breakiter">A <see cref="T:IBM.ICU.Text.BreakIterator"/> that is used to determine theboundaries of a logical match. This argument can be null.</param>
	    /// <exception cref="IllegalArgumentException">thrown when argument target is null, or of length 0</exception>
	    /// <seealso cref="T:IBM.ICU.Text.BreakIterator"/>
	    /// <seealso cref="T:IBM.ICU.Text.RuleBasedCollator"/>
	    /// <seealso cref="T:IBM.ICU.Text.SearchIterator"/>
	    /// @stable ICU 2.0
	    public StringSearch(String pattern, ICharacterIterator target,
	            RuleBasedCollator collator, BreakIterator breakiter) : base(target, breakiter) {
	        this.m_utilBuffer_ = new int[2];
	        m_textBeginOffset_ = targetText.GetBeginIndex();
	        m_textLimitOffset_ = targetText.GetEndIndex();
	        m_collator_ = collator;
	        m_colEIter_ = m_collator_.GetCollationElementIterator(target);
	        m_utilColEIter_ = collator.GetCollationElementIterator("");
	        m_ceMask_ = GetMask(m_collator_.GetStrength());
	        m_isCanonicalMatch_ = false;
	        m_pattern_ = new StringSearch.Pattern (pattern);
	        m_matchedIndex_ = IBM.ICU.Text.SearchIterator.DONE;
	        m_charBreakIter_ = IBM.ICU.Text.BreakIterator.GetCharacterInstance(/*
	                                                               * m_collator_.
	                                                               * getLocale
	                                                               * (ULocale
	                                                               * .ACTUAL_LOCALE)
	                                                               */);
	        m_charBreakIter_.SetText(target);
	        Initialize();
	    }
	
	    /// <summary>
	    /// Initializes the iterator to use the language-specific rules defined in
	    /// the argument collator to search for argument pattern in the argument
	    /// target text. No BreakIterators are set to test for logical matches.
	    /// </summary>
	    ///
	    /// <param name="pattern">text to look for.</param>
	    /// <param name="target">target text to search for pattern.</param>
	    /// <param name="collator">RuleBasedCollator that defines the language rules</param>
	    /// <exception cref="IllegalArgumentException">thrown when argument target is null, or of length 0</exception>
	    /// <seealso cref="T:IBM.ICU.Text.RuleBasedCollator"/>
	    /// <seealso cref="T:IBM.ICU.Text.SearchIterator"/>
	    /// @stable ICU 2.0
	    public StringSearch(String pattern, ICharacterIterator target,
	            RuleBasedCollator collator) : this(pattern, target, collator, null) {
	    }
	
	    /// <summary>
	    /// Initializes the iterator to use the language-specific rules and break
	    /// iterator rules defined in the argument locale to search for argument
	    /// pattern in the argument target text. See super class documentation for
	    /// more details on the use of the target text and BreakIterator.
	    /// </summary>
	    ///
	    /// <param name="pattern">text to look for.</param>
	    /// <param name="target">target text to search for pattern.</param>
	    /// <param name="locale">locale to use for language and break iterator rules</param>
	    /// <exception cref="IllegalArgumentException">thrown when argument target is null, or of length 0.ClassCastException thrown if the collator for thespecified locale is not a RuleBasedCollator.</exception>
	    /// <seealso cref="T:IBM.ICU.Text.BreakIterator"/>
	    /// <seealso cref="T:IBM.ICU.Text.RuleBasedCollator"/>
	    /// <seealso cref="T:IBM.ICU.Text.SearchIterator"/>
	    /// @stable ICU 2.0
	    public StringSearch(String pattern, ICharacterIterator target, Locale locale) : this(pattern, target, IBM.ICU.Util.ULocale.ForLocale(locale)) {
	    }
	
	    /// <summary>
	    /// Initializes the iterator to use the language-specific rules and break
	    /// iterator rules defined in the argument locale to search for argument
	    /// pattern in the argument target text. See super class documentation for
	    /// more details on the use of the target text and BreakIterator.
	    /// </summary>
	    ///
	    /// <param name="pattern">text to look for.</param>
	    /// <param name="target">target text to search for pattern.</param>
	    /// <param name="locale">ulocale to use for language and break iterator rules</param>
	    /// <exception cref="IllegalArgumentException">thrown when argument target is null, or of length 0.ClassCastException thrown if the collator for thespecified locale is not a RuleBasedCollator.</exception>
	    /// <seealso cref="T:IBM.ICU.Text.BreakIterator"/>
	    /// <seealso cref="T:IBM.ICU.Text.RuleBasedCollator"/>
	    /// <seealso cref="T:IBM.ICU.Text.SearchIterator"/>
	    /// @stable ICU 3.2
	    public StringSearch(String pattern, ICharacterIterator target, ULocale locale) : this(pattern, target, (RuleBasedCollator)IBM.ICU.Text.Collator.GetInstance(locale), null) {
	    }
	
	    /// <summary>
	    /// Initializes the iterator to use the language-specific rules and break
	    /// iterator rules defined in the default locale to search for argument
	    /// pattern in the argument target text. See super class documentation for
	    /// more details on the use of the target text and BreakIterator.
	    /// </summary>
	    ///
	    /// <param name="pattern">text to look for.</param>
	    /// <param name="target">target text to search for pattern.</param>
	    /// <exception cref="IllegalArgumentException">thrown when argument target is null, or of length 0.ClassCastException thrown if the collator for the defaultlocale is not a RuleBasedCollator.</exception>
	    /// <seealso cref="T:IBM.ICU.Text.BreakIterator"/>
	    /// <seealso cref="T:IBM.ICU.Text.RuleBasedCollator"/>
	    /// <seealso cref="T:IBM.ICU.Text.SearchIterator"/>
	    /// @stable ICU 2.0
	    public StringSearch(String pattern, String target) : this(pattern, new StringCharacterIterator(target), (RuleBasedCollator)IBM.ICU.Text.Collator.GetInstance(), null) {
	    }
	
	    // public getters -----------------------------------------------------
	
	    /// <summary>
	    /// <p>
	    /// Gets the RuleBasedCollator used for the language rules.
	    /// </p>
	    /// <p>
	    /// Since StringSearch depends on the returned RuleBasedCollator, any changes
	    /// to the RuleBasedCollator result should follow with a call to either
	    /// StringSearch.reset() or StringSearch.setCollator(RuleBasedCollator) to
	    /// ensure the correct search behaviour.
	    /// </p>
	    /// </summary>
	    ///
	    /// <returns>RuleBasedCollator used by this StringSearch</returns>
	    /// <seealso cref="T:IBM.ICU.Text.RuleBasedCollator"/>
	    /// <seealso cref="M:IBM.ICU.Text.StringSearch.SetCollator(IBM.ICU.Text.RuleBasedCollator)"/>
	    /// @stable ICU 2.0
	    public RuleBasedCollator GetCollator() {
	        return m_collator_;
	    }
	
	    /// <summary>
	    /// Returns the pattern for which StringSearch is searching for.
	    /// </summary>
	    ///
	    /// <returns>the pattern searched for</returns>
	    /// @stable ICU 2.0
	    public String GetPattern() {
	        return m_pattern_.targetText;
	    }
	
	    /// <summary>
	    /// Return the index in the target text where the iterator is currently
	    /// positioned at. If the iteration has gone past the end of the target text
	    /// or past the beginning for a backwards search, <see cref="M:IBM.ICU.Text.StringSearch.DONE"/> is returned.
	    /// </summary>
	    ///
	    /// <returns>index in the target text where the iterator is currently
	    /// positioned at</returns>
	    /// @stable ICU 2.8
	    public override int GetIndex() {
	        int result = m_colEIter_.GetOffset();
	        if (IsOutOfBounds(m_textBeginOffset_, m_textLimitOffset_, result)) {
	            return IBM.ICU.Text.SearchIterator.DONE;
	        }
	        return result;
	    }
	
	    /// <summary>
	    /// Determines whether canonical matches (option 1, as described in the class
	    /// documentation) is set. See setCanonical(boolean) for more information.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.StringSearch.SetCanonical(System.Boolean)"/>
	    /// <returns>true if canonical matches is set, false otherwise</returns>
	    /// @stable ICU 2.8
	    public bool IsCanonical() {
	        return m_isCanonicalMatch_;
	    }
	
	    // public setters -----------------------------------------------------
	
	    /// <summary>
	    /// <p>
	    /// Sets the RuleBasedCollator to be used for language-specific searching.
	    /// </p>
	    /// <p>
	    /// This method causes internal data such as Boyer-Moore shift tables to be
	    /// recalculated, but the iterator's position is unchanged.
	    /// </p>
	    /// </summary>
	    ///
	    /// <param name="collator">to use for this StringSearch</param>
	    /// <exception cref="IllegalArgumentException">thrown when collator is null</exception>
	    /// <seealso cref="M:IBM.ICU.Text.StringSearch.GetCollator"/>
	    /// @stable ICU 2.0
	    public void SetCollator(RuleBasedCollator collator) {
	        if (collator == null) {
	            throw new ArgumentException("Collator can not be null");
	        }
	        m_collator_ = collator;
	        m_ceMask_ = GetMask(m_collator_.GetStrength());
	        // if status is a failure, ucol_getAttribute returns UCOL_DEFAULT
	        Initialize();
	        m_colEIter_.SetCollator(m_collator_);
	        m_utilColEIter_.SetCollator(m_collator_);
	        m_charBreakIter_ = IBM.ICU.Text.BreakIterator.GetCharacterInstance(/*
	                                                               * collator.getLocale
	                                                               * (ULocale.
	                                                               * VALID_LOCALE)
	                                                               */);
	        m_charBreakIter_.SetText(targetText);
	    }
	
	    /// <summary>
	    /// <p>
	    /// Set the pattern to search for.
	    /// </p>
	    /// <p>
	    /// This method causes internal data such as Boyer-Moore shift tables to be
	    /// recalculated, but the iterator's position is unchanged.
	    /// </p>
	    /// </summary>
	    ///
	    /// <param name="pattern">for searching</param>
	    /// <seealso cref="M:IBM.ICU.Text.StringSearch.GetPattern"/>
	    /// <exception cref="IllegalArgumentException">thrown if pattern is null or of length 0</exception>
	    /// @stable ICU 2.0
	    public void SetPattern(String pattern) {
	        if (pattern == null || pattern.Length <= 0) {
	            throw new ArgumentException(
	                    "Pattern to search for can not be null or of length 0");
	        }
	        m_pattern_.targetText = pattern;
	        Initialize();
	    }
	
	    /// <summary>
	    /// Set the target text to be searched. Text iteration will hence begin at
	    /// the start of the text string. This method is useful if you want to re-use
	    /// an iterator to search within a different body of text.
	    /// </summary>
	    ///
	    /// <param name="text">new text iterator to look for match,</param>
	    /// <exception cref="IllegalArgumentException">thrown when text is null or has 0 length</exception>
	    /// <seealso cref="M:IBM.ICU.Text.StringSearch.GetTarget"/>
	    /// @stable ICU 2.8
	    public override void SetTarget(ICharacterIterator text) {
	        base.SetTarget(text);
	        m_textBeginOffset_ = targetText.GetBeginIndex();
	        m_textLimitOffset_ = targetText.GetEndIndex();
	        m_colEIter_.SetText(targetText);
	        m_charBreakIter_.SetText(targetText);
	    }
	
	    /// <summary>
	    /// <p>
	    /// Sets the position in the target text which the next search will start
	    /// from to the argument. This method clears all previous states.
	    /// </p>
	    /// <p>
	    /// This method takes the argument position and sets the position in the
	    /// target text accordingly, without checking if position is pointing to a
	    /// valid starting point to begin searching.
	    /// </p>
	    /// <p>
	    /// Search positions that may render incorrect results are highlighted in the
	    /// class documentation.
	    /// </p>
	    /// </summary>
	    ///
	    /// <param name="position">index to start next search from.</param>
	    /// <exception cref="IndexOutOfBoundsException">thrown if argument position is out of the target textrange.</exception>
	    /// <seealso cref="M:IBM.ICU.Text.StringSearch.GetIndex"/>
	    /// @stable ICU 2.8
	    public override void SetIndex(int position) {
	        base.SetIndex(position);
	        m_matchedIndex_ = IBM.ICU.Text.SearchIterator.DONE;
	        m_colEIter_.SetExactOffset(position);
	    }
	
	    /// <summary>
	    /// <p>
	    /// Set the canonical match mode. See class documentation for details. The
	    /// default setting for this property is false.
	    /// </p>
	    /// </summary>
	    ///
	    /// <param name="allowCanonical">flag indicator if canonical matches are allowed</param>
	    /// <seealso cref="M:IBM.ICU.Text.StringSearch.IsCanonical"/>
	    /// @stable ICU 2.8
	    public void SetCanonical(bool allowCanonical) {
	        m_isCanonicalMatch_ = allowCanonical;
	        if (m_isCanonicalMatch_ == true) {
	            if (m_canonicalPrefixAccents_ == null) {
	                m_canonicalPrefixAccents_ = new StringBuilder();
	            } else {
	                m_canonicalPrefixAccents_.Remove(0,m_canonicalPrefixAccents_.Length-(0));
	            }
	            if (m_canonicalSuffixAccents_ == null) {
	                m_canonicalSuffixAccents_ = new StringBuilder();
	            } else {
	                m_canonicalSuffixAccents_.Remove(0,m_canonicalSuffixAccents_.Length-(0));
	            }
	        }
	    }
	
	    // public miscellaneous methods -----------------------------------------
	
	    /// <summary>
	    /// <p>
	    /// Resets the search iteration. All properties will be reset to the default
	    /// value.
	    /// </p>
	    /// <p>
	    /// Search will begin at the start of the target text if a forward iteration
	    /// is initiated before a backwards iteration. Otherwise if a backwards
	    /// iteration is initiated before a forwards iteration, the search will begin
	    /// at the end of the target text.
	    /// </p>
	    /// <p>
	    /// Canonical match option will be reset to false, ie an exact match.
	    /// </p>
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    public override void Reset() {
	        // reset is setting the attributes that are already in string search,
	        // hence all attributes in the collator should be retrieved without any
	        // problems
	        base.Reset();
	        m_isCanonicalMatch_ = false;
	        m_ceMask_ = GetMask(m_collator_.GetStrength());
	        // if status is a failure, ucol_getAttribute returns UCOL_DEFAULT
	        Initialize();
	        m_colEIter_.SetCollator(m_collator_);
	        m_colEIter_.Reset();
	        m_utilColEIter_.SetCollator(m_collator_);
	    }
	
	    // protected methods -----------------------------------------------------
	
	    /// <summary>
	    /// <p>
	    /// Concrete method to provide the mechanism for finding the next
	    /// <b>forwards</b> match in the target text. See super class documentation
	    /// for its use.
	    /// </p>
	    /// </summary>
	    ///
	    /// <param name="start">index in the target text at which the forwards search shouldbegin.</param>
	    /// <returns>the starting index of the next forwards match if found, DONE
	    /// otherwise</returns>
	    /// <seealso cref="M:IBM.ICU.Text.StringSearch.HandlePrevious(System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Text.StringSearch.DONE"/>
	    /// @stable ICU 2.8
	    protected internal override int HandleNext(int start) {
	        if (m_pattern_.m_CELength_ == 0) {
	            matchLength = 0;
	            if (m_matchedIndex_ == IBM.ICU.Text.SearchIterator.DONE && start == m_textBeginOffset_) {
	                m_matchedIndex_ = start;
	                return m_matchedIndex_;
	            }
	
	            targetText.SetIndex(start);
	            char ch = targetText.Current();
	            // ch can never be done, it is handled by next()
	            char ch2 = targetText.Next();
	            if (ch2 == ILOG.J2CsMapping.Text.CharacterIterator.Done) {
	                m_matchedIndex_ = IBM.ICU.Text.SearchIterator.DONE;
	            } else {
	                m_matchedIndex_ = targetText.GetIndex();
	            }
	            if (IBM.ICU.Text.UTF16.IsLeadSurrogate(ch) && IBM.ICU.Text.UTF16.IsTrailSurrogate(ch2)) {
	                targetText.Next();
	                m_matchedIndex_ = targetText.GetIndex();
	            }
	        } else {
	            if (matchLength <= 0) {
	                // we must have reversed direction after we reached the start
	                // of the target text
	                // see SearchIterator next(), it checks the bounds and returns
	                // if it exceeds the range. It does not allow setting of
	                // m_matchedIndex
	                if (start == m_textBeginOffset_) {
	                    m_matchedIndex_ = IBM.ICU.Text.SearchIterator.DONE;
	                } else {
	                    // for boundary check purposes. this will ensure that the
	                    // next match will not preceed the current offset
	                    // note search->matchedIndex will always be set to something
	                    // in the code
	                    m_matchedIndex_ = start - 1;
	                }
	            }
	
	            // status checked below
	            if (m_isCanonicalMatch_) {
	                // can't use exact here since extra accents are allowed.
	                HandleNextCanonical(start);
	            } else {
	                HandleNextExact(start);
	            }
	        }
	        if (m_matchedIndex_ == IBM.ICU.Text.SearchIterator.DONE) {
	            targetText.SetIndex(m_textLimitOffset_);
	        } else {
	            targetText.SetIndex(m_matchedIndex_);
	        }
	        return m_matchedIndex_;
	    }
	
	    /// <summary>
	    /// <p>
	    /// Concrete method to provide the mechanism for finding the next
	    /// <b>backwards</b> match in the target text. See super class documentation
	    /// for its use.
	    /// </p>
	    /// </summary>
	    ///
	    /// <param name="start">index in the target text at which the backwards search shouldbegin.</param>
	    /// <returns>the starting index of the next backwards match if found, DONE
	    /// otherwise</returns>
	    /// <seealso cref="M:IBM.ICU.Text.StringSearch.HandleNext(System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Text.StringSearch.DONE"/>
	    /// @stable ICU 2.8
	    protected internal override int HandlePrevious(int start) {
	        if (m_pattern_.m_CELength_ == 0) {
	            matchLength = 0;
	            // start can never be DONE or 0, it is handled in previous
	            targetText.SetIndex(start);
	            char ch = targetText.Previous();
	            if (ch == ILOG.J2CsMapping.Text.CharacterIterator.Done) {
	                m_matchedIndex_ = IBM.ICU.Text.SearchIterator.DONE;
	            } else {
	                m_matchedIndex_ = targetText.GetIndex();
	                if (IBM.ICU.Text.UTF16.IsTrailSurrogate(ch)) {
	                    if (IBM.ICU.Text.UTF16.IsLeadSurrogate(targetText.Previous())) {
	                        m_matchedIndex_ = targetText.GetIndex();
	                    }
	                }
	            }
	        } else {
	            if (matchLength == 0) {
	                // we must have reversed direction after we reached the end
	                // of the target text
	                // see SearchIterator next(), it checks the bounds and returns
	                // if it exceeds the range. It does not allow setting of
	                // m_matchedIndex
	                m_matchedIndex_ = IBM.ICU.Text.SearchIterator.DONE;
	            }
	            if (m_isCanonicalMatch_) {
	                // can't use exact here since extra accents are allowed.
	                HandlePreviousCanonical(start);
	            } else {
	                HandlePreviousExact(start);
	            }
	        }
	
	        if (m_matchedIndex_ == IBM.ICU.Text.SearchIterator.DONE) {
	            targetText.SetIndex(m_textBeginOffset_);
	        } else {
	            targetText.SetIndex(m_matchedIndex_);
	        }
	        return m_matchedIndex_;
	    }
	
	    // private static inner classes ----------------------------------------
	
	    private class Pattern {
	        // protected methods -----------------------------------------------
	
	        /// <summary>
	        /// Pattern string
	        /// </summary>
	        ///
	        protected internal String targetText;
	
	        /// <summary>
	        /// Array containing the collation elements of targetText
	        /// </summary>
	        ///
	        protected internal int[] m_CE_;
	
	        /// <summary>
	        /// Number of collation elements in m_CE_
	        /// </summary>
	        ///
	        protected internal int m_CELength_;
	
	        /// <summary>
	        /// Flag indicator if targetText starts with an accent
	        /// </summary>
	        ///
	        protected internal bool m_hasPrefixAccents_;
	
	        /// <summary>
	        /// Flag indicator if targetText ends with an accent
	        /// </summary>
	        ///
	        protected internal bool m_hasSuffixAccents_;
	
	        /// <summary>
	        /// Default number of characters to shift for Boyer Moore
	        /// </summary>
	        ///
	        protected internal int m_defaultShiftSize_;
	
	        /// <summary>
	        /// Number of characters to shift for Boyer Moore, depending on the source text to search
	        /// </summary>
	        ///
	        protected internal char[] m_shift_;
	
	        /// <summary>
	        /// Number of characters to shift backwards for Boyer Moore, depending on the source text to search
	        /// </summary>
	        ///
	        protected internal char[] m_backShift_;
	
	        // protected constructors ------------------------------------------
	
	        /// <summary>
	        /// Empty constructor
	        /// </summary>
	        ///
	        protected internal Pattern(String pattern) {
	            targetText = pattern;
	            m_CE_ = new int[IBM.ICU.Text.StringSearch.INITIAL_ARRAY_SIZE_];
	            m_CELength_ = 0;
	            m_hasPrefixAccents_ = false;
	            m_hasSuffixAccents_ = false;
	            m_defaultShiftSize_ = 1;
	            m_shift_ = new char[IBM.ICU.Text.StringSearch.MAX_TABLE_SIZE_];
	            m_backShift_ = new char[IBM.ICU.Text.StringSearch.MAX_TABLE_SIZE_];
	        }
	    }
	
	    // private data members ------------------------------------------------
	
	    /// <summary>
	    /// target text begin offset. Each targetText has a valid contiguous region
	    /// to iterate and this data member is the offset to the first such character
	    /// in the region.
	    /// </summary>
	    ///
	    private int m_textBeginOffset_;
	
	    /// <summary>
	    /// target text limit offset. Each targetText has a valid contiguous region
	    /// to iterate and this data member is the offset to 1 after the last such
	    /// character in the region.
	    /// </summary>
	    ///
	    private int m_textLimitOffset_;
	
	    /// <summary>
	    /// Upon completion of a search, m_matchIndex_ will store starting offset in
	    /// m_text for the match. The Value DONE is the default value. If we are not
	    /// at the start of the text or the end of the text and m_matchedIndex_ is
	    /// DONE it means that we can find any more matches in that particular
	    /// direction
	    /// </summary>
	    ///
	    private int m_matchedIndex_;
	
	    /// <summary>
	    /// Current pattern to search for
	    /// </summary>
	    ///
	    private StringSearch.Pattern  m_pattern_;
	
	    /// <summary>
	    /// Collator whose rules are used to perform the search
	    /// </summary>
	    ///
	    private RuleBasedCollator m_collator_;
	
	    /// <summary>
	    /// The collation element iterator for the text source.
	    /// </summary>
	    ///
	    private CollationElementIterator m_colEIter_;
	
	    /// <summary>
	    /// Utility collation element, used throughout program for temporary
	    /// iteration.
	    /// </summary>
	    ///
	    private CollationElementIterator m_utilColEIter_;
	
	    /// <summary>
	    /// The mask used on the collation elements to retrieve the valid strength
	    /// weight
	    /// </summary>
	    ///
	    private int m_ceMask_;
	
	    /// <summary>
	    /// Buffer storing accents during a canonical search
	    /// </summary>
	    ///
	    private StringBuilder m_canonicalPrefixAccents_;
	
	    /// <summary>
	    /// Buffer storing accents during a canonical search
	    /// </summary>
	    ///
	    private StringBuilder m_canonicalSuffixAccents_;
	
	    /// <summary>
	    /// Flag to indicate if canonical search is to be done. E.g looking for
	    /// "a\u0300" in "a\u0318\u0300" will yield the match at 0.
	    /// </summary>
	    ///
	    private bool m_isCanonicalMatch_;
	
	    /// <summary>
	    /// Character break iterator for boundary checking.
	    /// </summary>
	    ///
	    private BreakIterator m_charBreakIter_;
	
	    /// <summary>
	    /// Size of the shift tables
	    /// </summary>
	    ///
	    private const int MAX_TABLE_SIZE_ = 257;
	
	    /// <summary>
	    /// Initial array size
	    /// </summary>
	    ///
	    private const int INITIAL_ARRAY_SIZE_ = 256;
	
	    /// <summary>
	    /// Utility mask
	    /// </summary>
	    ///
	    private const int SECOND_LAST_BYTE_SHIFT_ = 8;
	
	    /// <summary>
	    /// Utility mask
	    /// </summary>
	    ///
	    private const int LAST_BYTE_MASK_ = 0xff;
	
	    /// <summary>
	    /// Utility buffer for return values and temporary storage
	    /// </summary>
	    ///
	    private int[] m_utilBuffer_;
	
	    /// <summary>
	    /// Unsigned 32-Bit Integer Mask
	    /// </summary>
	    ///
	    private const long UNSIGNED_32BIT_MASK = 0xffffffffL;
	
	    // private methods -------------------------------------------------------
	
	    /// <summary>
	    /// Hash a collation element from its full size (32 bits) down into a value
	    /// that can be used as an index into the shift tables. Right now we do a
	    /// modulus by the size of the hash table.
	    /// </summary>
	    ///
	    /// <param name="ce">collation element</param>
	    /// <returns>collapsed version of the collation element</returns>
	    private static int Hash(int ce) {
	        // the old value UCOL_PRIMARYORDER(ce) % MAX_TABLE_SIZE_ does not work
	        // well with the new collation where most of the latin 1 characters
	        // are of the value xx000xxx. their hashes will most of the time be 0
	        // to be discussed on the hash algo.
	        return IBM.ICU.Text.CollationElementIterator.PrimaryOrder(ce) % MAX_TABLE_SIZE_;
	    }
	
	    /// <summary>
	    /// Gets the fcd value for a character at the argument index. This method
	    /// takes into accounts of the supplementary characters. Note this method
	    /// changes the offset in the character iterator.
	    /// </summary>
	    ///
	    /// <param name="str">UTF16 string where character for fcd retrieval resides</param>
	    /// <param name="offset">position of the character whose fcd is to be retrieved</param>
	    /// <returns>fcd value</returns>
	    private static char GetFCD(ICharacterIterator str, int offset) {
	        str.SetIndex(offset);
	        char ch = str.Current();
	        char result = IBM.ICU.Impl.NormalizerImpl.GetFCD16(ch);
	
	        if ((result != 0) && (str.GetEndIndex() != offset + 1)
	                && IBM.ICU.Text.UTF16.IsLeadSurrogate(ch)) {
	            ch = str.Next();
	            if (IBM.ICU.Text.UTF16.IsTrailSurrogate(ch)) {
	                result = IBM.ICU.Impl.NormalizerImpl.GetFCD16FromSurrogatePair(result, ch);
	            } else {
	                result = ((Char)0);
	            }
	        }
	        return result;
	    }
	
	    /// <summary>
	    /// Gets the fcd value for a character at the argument index. This method
	    /// takes into accounts of the supplementary characters.
	    /// </summary>
	    ///
	    /// <param name="str">UTF16 string where character for fcd retrieval resides</param>
	    /// <param name="offset">position of the character whose fcd is to be retrieved</param>
	    /// <returns>fcd value</returns>
	    private static char GetFCD(String str, int offset) {
	        char ch = str[offset];
	        char result = IBM.ICU.Impl.NormalizerImpl.GetFCD16(ch);
	
	        if ((result != 0) && (str.Length != offset + 1)
	                && IBM.ICU.Text.UTF16.IsLeadSurrogate(ch)) {
	            ch = str[offset + 1];
	            if (IBM.ICU.Text.UTF16.IsTrailSurrogate(ch)) {
	                result = IBM.ICU.Impl.NormalizerImpl.GetFCD16FromSurrogatePair(result, ch);
	            } else {
	                result = ((Char)0);
	            }
	        }
	        return result;
	    }
	
	    /// <summary>
	    /// Getting the modified collation elements taking into account the collation
	    /// attributes
	    /// </summary>
	    ///
	    /// <param name="ce"></param>
	    /// <returns>the modified collation element</returns>
	    private int GetCE(int ce) {
	        // note for tertiary we can't use the collator->tertiaryMask, that
	        // is a preprocessed mask that takes into account case options. since
	        // we are only concerned with exact matches, we don't need that.
	        ce &= m_ceMask_;
	
	        if (m_collator_.IsAlternateHandlingShifted()) {
	            // alternate handling here, since only the 16 most significant
	            // digits is only used, we can safely do a compare without masking
	            // if the ce is a variable, we mask and get only the primary values
	            // no shifting to quartenary is required since all primary values
	            // less than variabletop will need to be masked off anyway.
	            if (((m_collator_.m_variableTopValue_ << 16) & UNSIGNED_32BIT_MASK) > (ce & UNSIGNED_32BIT_MASK)) {
	                if (m_collator_.GetStrength() == IBM.ICU.Text.Collator.QUATERNARY) {
	                    ce = IBM.ICU.Text.CollationElementIterator.PrimaryOrder(ce);
	                } else {
	                    ce = IBM.ICU.Text.CollationElementIterator.IGNORABLE;
	                }
	            }
	        }
	
	        return ce;
	    }
	
	    /// <summary>
	    /// Appends a int to a int array, increasing the size of the array when we
	    /// are out of space.
	    /// </summary>
	    ///
	    /// <param name="offset">in array to append to</param>
	    /// <param name="value">to append</param>
	    /// <param name="array">to append to</param>
	    /// <returns>the array appended to, this could be a new and bigger array</returns>
	    private static int[] Append(int offset, int value_ren, int[] array) {
	        if (offset >= array.Length) {
	            int[] temp = new int[offset + INITIAL_ARRAY_SIZE_];
	            System.Array.Copy((Array)(array),0,(Array)(temp),0,array.Length);
	            array = temp;
	        }
	        array[offset] = value_ren;
	        return array;
	    }
	
	    /// <summary>
	    /// Initializing the ce table for a pattern. Stores non-ignorable collation
	    /// keys. Table size will be estimated by the size of the pattern text. Table
	    /// expansion will be perform as we go along. Adding 1 to ensure that the
	    /// table size definitely increases. Internal method, status assumed to be a
	    /// success.
	    /// </summary>
	    ///
	    /// <returns>total number of expansions</returns>
	    private int InitializePatternCETable() {
	        m_utilColEIter_.SetText(m_pattern_.targetText);
	
	        int offset = 0;
	        int result = 0;
	        int ce = m_utilColEIter_.Next();
	
	        while (ce != IBM.ICU.Text.CollationElementIterator.NULLORDER) {
	            int newce = GetCE(ce);
	            if (newce != IBM.ICU.Text.CollationElementIterator.IGNORABLE) {
	                m_pattern_.m_CE_ = Append(offset, newce, m_pattern_.m_CE_);
	                offset++;
	            }
	            result += m_utilColEIter_.GetMaxExpansion(ce) - 1;
	            ce = m_utilColEIter_.Next();
	        }
	
	        m_pattern_.m_CE_ = Append(offset, 0, m_pattern_.m_CE_);
	        m_pattern_.m_CELength_ = offset;
	
	        return result;
	    }
	
	    /// <summary>
	    /// Initializes the pattern struct. Internal method, status assumed to be
	    /// success.
	    /// </summary>
	    ///
	    /// <returns>expansionsize the total expansion size of the pattern</returns>
	    private int InitializePattern() {
	        if (m_collator_.GetStrength() == IBM.ICU.Text.Collator.PRIMARY) {
	            m_pattern_.m_hasPrefixAccents_ = false;
	            m_pattern_.m_hasSuffixAccents_ = false;
	        } else {
	            m_pattern_.m_hasPrefixAccents_ = (GetFCD(m_pattern_.targetText, 0) >> SECOND_LAST_BYTE_SHIFT_) != 0;
	            m_pattern_.m_hasSuffixAccents_ = (GetFCD(m_pattern_.targetText,
	                    m_pattern_.targetText.Length - 1) & LAST_BYTE_MASK_) != 0;
	        }
	        // since intializePattern is an internal method status is a success.
	        return InitializePatternCETable();
	    }
	
	    /// <summary>
	    /// Initializing shift tables, with the default values. If a corresponding
	    /// default value is 0, the shift table is not set.
	    /// </summary>
	    ///
	    /// <param name="shift">table for forwards shift</param>
	    /// <param name="backshift">table for backwards shift</param>
	    /// <param name="cetable">table containing pattern ce</param>
	    /// <param name="cesize">size of the pattern ces</param>
	    /// <param name="expansionsize">total size of the expansions</param>
	    /// <param name="defaultforward">the default forward value</param>
	    /// <param name="defaultbackward">the default backward value</param>
	    private void SetShiftTable(char[] shift, char[] backshift,
	            int[] cetable, int cesize, int expansionsize, char defaultforward,
	            char defaultbackward) {
	        // estimate the value to shift. to do that we estimate the smallest
	        // number of characters to give the relevant ces, ie approximately
	        // the number of ces minus their expansion, since expansions can come
	        // from a character.
	        for (int count = 0; count < MAX_TABLE_SIZE_; count++) {
	            shift[count] = defaultforward;
	        }
	        cesize--; // down to the last index
	        for (int count_0 = 0; count_0 < cesize; count_0++) {
	            // number of ces from right of array to the count
	            int temp = defaultforward - count_0 - 1;
	            shift[Hash(cetable[count_0])] = (temp > 1) ? (char) (((char) temp)) : (char) (1);
	        }
	        shift[Hash(cetable[cesize])] = ((Char)1);
	        // for ignorables we just shift by one. see test examples.
	        shift[Hash(0)] = ((Char)1);
	
	        for (int count_1 = 0; count_1 < MAX_TABLE_SIZE_; count_1++) {
	            backshift[count_1] = defaultbackward;
	        }
	        for (int count_2 = cesize; count_2 > 0; count_2--) {
	            // the original value count does not seem to work
	            backshift[Hash(cetable[count_2])] = (char) ((count_2 > expansionsize) ? count_2
	                    - expansionsize
	                    : 1);
	        }
	        backshift[Hash(cetable[0])] = ((Char)1);
	        backshift[Hash(0)] = ((Char)1);
	    }
	
	    /// <summary>
	    /// <p>
	    /// Building of the pattern collation element list and the Boyer Moore
	    /// StringSearch table.
	    /// </p>
	    /// <p>
	    /// The canonical match will only be performed after the default match fails.
	    /// </p>
	    /// <p>
	    /// For both cases we need to remember the size of the composed and
	    /// decomposed versions of the string. Since the Boyer-Moore shift
	    /// calculations shifts by a number of characters in the text and tries to
	    /// match the pattern from that offset, the shift value can not be too large
	    /// in case we miss some characters. To choose a right shift size, we
	    /// estimate the NFC form of the and use its size as a shift guide. The NFC
	    /// form should be the small possible representation of the pattern. Anyways,
	    /// we'll err on the smaller shift size. Hence the calculation for minlength.
	    /// Canonical match will be performed slightly differently. We'll split the
	    /// pattern into 3 parts, the prefix accents (PA), the middle string bounded
	    /// by the first and last base character (MS), the ending accents (EA).
	    /// Matches will be done on MS first, and only when we match MS then some
	    /// processing will be required for the prefix and end accents in order to
	    /// determine if they match PA and EA. Hence the default shift values for the
	    /// canonical match will take the size of either end's accent into
	    /// consideration. Forwards search will take the end accents into
	    /// consideration for the default shift values and the backwards search will
	    /// take the prefix accents into consideration.
	    /// </p>
	    /// <p>
	    /// If pattern has no non-ignorable ce, we return a illegal argument error.
	    /// </p>
	    /// </summary>
	    ///
	    private void Initialize() {
	        int expandlength = InitializePattern();
	        if (m_pattern_.m_CELength_ > 0) {
	            char minlength = (char) ((m_pattern_.m_CELength_ > expandlength) ? m_pattern_.m_CELength_
	                    - expandlength
	                    : 1);
	            m_pattern_.m_defaultShiftSize_ = minlength;
	            SetShiftTable(m_pattern_.m_shift_, m_pattern_.m_backShift_,
	                    m_pattern_.m_CE_, m_pattern_.m_CELength_, expandlength,
	                    minlength, minlength);
	        } else {
	            m_pattern_.m_defaultShiftSize_ = 0;
	        }
	    }
	
	    /// <summary>
	    /// Determine whether the search text bounded by the offset start and end is
	    /// one or more whole units of text as determined by the breakiterator in
	    /// StringSearch.
	    /// </summary>
	    ///
	    /// <param name="start">target text start offset</param>
	    /// <param name="end">target text end offset</param>
	    private bool IsBreakUnit(int start, int end) {
	        if (breakIterator != null) {
	            int startindex = breakIterator.First();
	            int endindex = breakIterator.Last();
	
	            // out-of-range indexes are never boundary positions
	            if (start < startindex || start > endindex || end < startindex
	                    || end > endindex) {
	                return false;
	            }
	            // otherwise, we can use following() on the position before the
	            // specified one and return true of the position we get back is the
	            // one the user specified
	            bool result = (start == startindex || breakIterator
	                    .Following(start - 1) == start)
	                    && (end == endindex || breakIterator.Following(end - 1) == end);
	            if (result) {
	                // iterates the individual ces
	                m_utilColEIter_.SetText(
	                        new CharacterIteratorWrapper(targetText), start);
	                for (int count = 0; count < m_pattern_.m_CELength_; count++) {
	                    int ce = GetCE(m_utilColEIter_.Next());
	                    if (ce == IBM.ICU.Text.CollationElementIterator.IGNORABLE) {
	                        count--;
	                        continue;
	                    }
	                    if (ce != m_pattern_.m_CE_[count]) {
	                        return false;
	                    }
	                }
	                int nextce = m_utilColEIter_.Next();
	                while (m_utilColEIter_.GetOffset() == end
	                        && GetCE(nextce) == IBM.ICU.Text.CollationElementIterator.IGNORABLE) {
	                    nextce = m_utilColEIter_.Next();
	                }
	                if (nextce != IBM.ICU.Text.CollationElementIterator.NULLORDER
	                        && m_utilColEIter_.GetOffset() == end) {
	                    // extra collation elements at the end of the match
	                    return false;
	                }
	            }
	            return result;
	        }
	        return true;
	    }
	
	    /// <summary>
	    /// Getting the next base character offset if current offset is an accent, or
	    /// the current offset if the current character contains a base character.
	    /// accents the following base character will be returned
	    /// </summary>
	    ///
	    /// <param name="text">string</param>
	    /// <param name="textoffset">current offset</param>
	    /// <param name="textlength">length of text string</param>
	    /// <returns>the next base character or the current offset if the current
	    /// character is contains a base character.</returns>
	    private int GetNextBaseOffset(ICharacterIterator text, int textoffset) {
	        if (textoffset < text.GetEndIndex()) {
	            while (text.GetIndex() < text.GetEndIndex()) {
	                int result = textoffset;
	                if ((GetFCD(text, textoffset++) >> SECOND_LAST_BYTE_SHIFT_) == 0) {
	                    return result;
	                }
	            }
	            return text.GetEndIndex();
	        }
	        return textoffset;
	    }
	
	    /// <summary>
	    /// Gets the next base character offset depending on the string search
	    /// pattern data
	    /// </summary>
	    ///
	    /// <param name="textoffset">one offset away from the last character to search for.</param>
	    /// <returns>start index of the next base character or the current offset if
	    /// the current character is contains a base character.</returns>
	    private int GetNextBaseOffset(int textoffset) {
	        if (m_pattern_.m_hasSuffixAccents_ && textoffset < m_textLimitOffset_) {
	            targetText.SetIndex(textoffset);
	            targetText.Previous();
	            if ((GetFCD(targetText, targetText.GetIndex()) & LAST_BYTE_MASK_) != 0) {
	                return GetNextBaseOffset(targetText, textoffset);
	            }
	        }
	        return textoffset;
	    }
	
	    /// <summary>
	    /// Shifting the collation element iterator position forward to prepare for a
	    /// following match. If the last character is a unsafe character, we'll only
	    /// shift by 1 to capture contractions, normalization etc. Internal method,
	    /// status assumed to be success.
	    /// </summary>
	    ///
	    /// <param name="textoffset">start text position to do search</param>
	    /// <param name="ce">the text ce which failed the match.</param>
	    /// <param name="patternceindex">index of the ce within the pattern ce buffer which failed thematch</param>
	    /// <returns>final offset</returns>
	    private int ShiftForward(int textoffset, int ce, int patternceindex)
	
	    {
	        if (ce != IBM.ICU.Text.CollationElementIterator.NULLORDER) {
	            int shift = m_pattern_.m_shift_[Hash(ce)];
	            // this is to adjust for characters in the middle of the
	            // substring for matching that failed.
	            int adjust = m_pattern_.m_CELength_ - patternceindex;
	            if (adjust > 1 && shift >= adjust) {
	                shift -= adjust - 1;
	            }
	            textoffset += shift;
	        } else {
	            textoffset += m_pattern_.m_defaultShiftSize_;
	        }
	
	        textoffset = GetNextBaseOffset(textoffset);
	        // check for unsafe characters
	        // * if it is the start or middle of a contraction: to be done after
	        // a initial match is found
	        // * thai or lao base consonant character: similar to contraction
	        // * high surrogate character: similar to contraction
	        // * next character is a accent: shift to the next base character
	        return textoffset;
	    }
	
	    /// <summary>
	    /// Gets the offset to the next safe point in text. ie. not the middle of a
	    /// contraction, swappable characters or supplementary characters.
	    /// </summary>
	    ///
	    /// <param name="textoffset">offset in string</param>
	    /// <param name="end">offset in string</param>
	    /// <returns>offset to the next safe character</returns>
	    private int GetNextSafeOffset(int textoffset, int end) {
	        int result = textoffset; // first contraction character
	        targetText.SetIndex(result);
	        while (result != end && m_collator_.IsUnsafe(targetText.Current())) {
	            result++;
	            targetText.SetIndex(result);
	        }
	        return result;
	    }
	
	    /// <summary>
	    /// This checks for accents in the potential match started with a composite
	    /// character. This is really painful... we have to check that composite
	    /// character do not have any extra accents. We have to normalize the
	    /// potential match and find the immediate decomposed character before the
	    /// match. The first composite character would have been taken care of by the
	    /// fcd checks in checkForwardExactMatch. This is the slow path after the fcd
	    /// of the first character and the last character has been checked by
	    /// checkForwardExactMatch and we determine that the potential match has
	    /// extra non-ignorable preceding ces. E.g. looking for \u0301 acute in
	    /// \u01FA A ring above and acute, checkExtraMatchAccent should fail since
	    /// there is a middle ring in \u01FA Note here that accents checking are slow
	    /// and cautioned in the API docs. Internal method, status assumed to be a
	    /// success, caller should check status before calling this method
	    /// </summary>
	    ///
	    /// <param name="start">index of the potential unfriendly composite character</param>
	    /// <param name="end">index of the potential unfriendly composite character</param>
	    /// <returns>true if there is non-ignorable accents before at the beginning of
	    /// the match, false otherwise.</returns>
	    private bool CheckExtraMatchAccents(int start, int end) {
	        bool result = false;
	        if (m_pattern_.m_hasPrefixAccents_) {
	            targetText.SetIndex(start);
	
	            if (IBM.ICU.Text.UTF16.IsLeadSurrogate(targetText.Next())) {
	                if (!IBM.ICU.Text.UTF16.IsTrailSurrogate(targetText.Next())) {
	                    targetText.Previous();
	                }
	            }
	            // we are only concerned with the first composite character
	            String str = GetString(targetText, start, end);
	            if (IBM.ICU.Text.Normalizer.QuickCheck(str, IBM.ICU.Text.Normalizer.NFD, 0) == IBM.ICU.Text.Normalizer.NO) {
	                int safeoffset = GetNextSafeOffset(start, end);
	                if (safeoffset != end) {
	                    safeoffset++;
	                }
	                String decomp = IBM.ICU.Text.Normalizer.Decompose(
	                        str.Substring(0,(safeoffset - start)-(0)), false);
	                m_utilColEIter_.SetText(decomp);
	                int firstce = m_pattern_.m_CE_[0];
	                bool ignorable = true;
	                int ce = IBM.ICU.Text.CollationElementIterator.IGNORABLE;
	                int offset = 0;
	                while (ce != firstce) {
	                    offset = m_utilColEIter_.GetOffset();
	                    if (ce != firstce
	                            && ce != IBM.ICU.Text.CollationElementIterator.IGNORABLE) {
	                        ignorable = false;
	                    }
	                    ce = m_utilColEIter_.Next();
	                }
	                m_utilColEIter_.SetExactOffset(offset); // back up 1 to the
	                m_utilColEIter_.Previous(); // right offset
	                offset = m_utilColEIter_.GetOffset();
	                result = !ignorable
	                        && (IBM.ICU.Lang.UCharacter.GetCombiningClass(IBM.ICU.Text.UTF16.CharAt(decomp,
	                                offset)) != 0);
	            }
	        }
	
	        return result;
	    }
	
	    /// <summary>
	    /// Used by exact matches, checks if there are accents before the match. This
	    /// is really painful... we have to check that composite characters at the
	    /// start of the matches have to not have any extra accents. We check the FCD
	    /// of the character first, if it starts with an accent and the first pattern
	    /// ce does not match the first ce of the character, we bail. Otherwise we
	    /// try normalizing the first composite character and find the immediate
	    /// decomposed character before the match to see if it is an non-ignorable
	    /// accent. Now normalizing the first composite character is enough because
	    /// we ensure that when the match is passed in here with extra beginning ces,
	    /// the first or last ce that match has to occur within the first character.
	    /// E.g. looking for \u0301 acute in \u01FA A ring above and acute,
	    /// checkExtraMatchAccent should fail since there is a middle ring in \u01FA
	    /// Note here that accents checking are slow and cautioned in the API docs.
	    /// </summary>
	    ///
	    /// <param name="start">offset</param>
	    /// <param name="end">offset</param>
	    /// <returns>true if there are accents on either side of the match, false
	    /// otherwise</returns>
	    private bool HasAccentsBeforeMatch(int start, int end) {
	        if (m_pattern_.m_hasPrefixAccents_) {
	            // we have been iterating forwards previously
	            bool ignorable = true;
	            int firstce = m_pattern_.m_CE_[0];
	            m_colEIter_.SetExactOffset(start);
	            int ce = GetCE(m_colEIter_.Next());
	            while (ce != firstce) {
	                if (ce != IBM.ICU.Text.CollationElementIterator.IGNORABLE) {
	                    ignorable = false;
	                }
	                ce = GetCE(m_colEIter_.Next());
	            }
	            if (!ignorable && m_colEIter_.IsInBuffer()) {
	                // within normalization buffer, discontiguous handled here
	                return true;
	            }
	
	            // within text
	            bool accent = (GetFCD(targetText, start) >> SECOND_LAST_BYTE_SHIFT_) != 0;
	            if (!accent) {
	                return CheckExtraMatchAccents(start, end);
	            }
	            if (!ignorable) {
	                return true;
	            }
	            if (start > m_textBeginOffset_) {
	                targetText.SetIndex(start);
	                targetText.Previous();
	                if ((GetFCD(targetText, targetText.GetIndex()) & LAST_BYTE_MASK_) != 0) {
	                    m_colEIter_.SetExactOffset(start);
	                    ce = m_colEIter_.Previous();
	                    if (ce != IBM.ICU.Text.CollationElementIterator.NULLORDER
	                            && ce != IBM.ICU.Text.CollationElementIterator.IGNORABLE) {
	                        return true;
	                    }
	                }
	            }
	        }
	
	        return false;
	    }
	
	    /// <summary>
	    /// Used by exact matches, checks if there are accents bounding the match.
	    /// Note this is the initial boundary check. If the potential match starts or
	    /// ends with composite characters, the accents in those characters will be
	    /// determined later. Not doing backwards iteration here, since discontiguos
	    /// contraction for backwards collation element iterator, use up too many
	    /// characters. E.g. looking for \u030A ring in \u01FA A ring above and
	    /// acute, should fail since there is a acute at the end of \u01FA Note here
	    /// that accents checking are slow and cautioned in the API docs.
	    /// </summary>
	    ///
	    /// <param name="start">offset of match</param>
	    /// <param name="end">end offset of the match</param>
	    /// <returns>true if there are accents on either side of the match, false
	    /// otherwise</returns>
	    private bool HasAccentsAfterMatch(int start, int end) {
	        if (m_pattern_.m_hasSuffixAccents_) {
	            targetText.SetIndex(end);
	            if (end > m_textBeginOffset_
	                    && IBM.ICU.Text.UTF16.IsTrailSurrogate(targetText.Previous())) {
	                if (targetText.GetIndex() > m_textBeginOffset_
	                        && !IBM.ICU.Text.UTF16.IsLeadSurrogate(targetText.Previous())) {
	                    targetText.Next();
	                }
	            }
	            if ((GetFCD(targetText, targetText.GetIndex()) & LAST_BYTE_MASK_) != 0) {
	                int firstce = m_pattern_.m_CE_[0];
	                m_colEIter_.SetExactOffset(start);
	                while (GetCE(m_colEIter_.Next()) != firstce) {
	                }
	                int count = 1;
	                while (count < m_pattern_.m_CELength_) {
	                    if (GetCE(m_colEIter_.Next()) == IBM.ICU.Text.CollationElementIterator.IGNORABLE) {
	                        count--;
	                    }
	                    count++;
	                }
	                // int ce = getCE(m_colEIter_.next());
	                int ce = m_colEIter_.Next();
	                if (ce != IBM.ICU.Text.CollationElementIterator.NULLORDER
	                        && ce != IBM.ICU.Text.CollationElementIterator.IGNORABLE) {
	                    ce = GetCE(ce);
	                }
	                if (ce != IBM.ICU.Text.CollationElementIterator.NULLORDER
	                        && ce != IBM.ICU.Text.CollationElementIterator.IGNORABLE) {
	                    if (m_colEIter_.GetOffset() <= end) {
	                        return true;
	                    }
	                    if ((GetFCD(targetText, end) >> SECOND_LAST_BYTE_SHIFT_) != 0) {
	                        return true;
	                    }
	                }
	            }
	        }
	        return false;
	    }
	
	    /// <summary>
	    /// Checks if the offset runs out of the text string range
	    /// </summary>
	    ///
	    /// <param name="textstart">offset of the first character in the range</param>
	    /// <param name="textlimit">limit offset of the text string range</param>
	    /// <param name="offset">to test</param>
	    /// <returns>true if offset is out of bounds, false otherwise</returns>
	    private static bool IsOutOfBounds(int textstart, int textlimit,
	            int offset) {
	        return offset < textstart || offset > textlimit;
	    }
	
	    /// <summary>
	    /// Checks for identical match
	    /// </summary>
	    ///
	    /// <param name="strsrch">string search data</param>
	    /// <param name="start">offset of possible match</param>
	    /// <param name="end">offset of possible match</param>
	    /// <returns>true if identical match is found</returns>
	    private bool CheckIdentical(int start, int end) {
	        if (m_collator_.GetStrength() != IBM.ICU.Text.Collator.IDENTICAL) {
	            return true;
	        }
	
	        String textstr = GetString(targetText, start, end - start);
	        if (IBM.ICU.Text.Normalizer.QuickCheck(textstr, IBM.ICU.Text.Normalizer.NFD, 0) == IBM.ICU.Text.Normalizer.NO) {
	            textstr = IBM.ICU.Text.Normalizer.Decompose(textstr, false);
	        }
	        String patternstr = m_pattern_.targetText;
	        if (IBM.ICU.Text.Normalizer.QuickCheck(patternstr, IBM.ICU.Text.Normalizer.NFD, 0) == IBM.ICU.Text.Normalizer.NO) {
	            patternstr = IBM.ICU.Text.Normalizer.Decompose(patternstr, false);
	        }
	        return textstr.Equals(patternstr);
	    }
	
	    /// <summary>
	    /// Checks to see if the match is repeated
	    /// </summary>
	    ///
	    /// <param name="start">new match start index</param>
	    /// <param name="limit">new match limit index</param>
	    /// <returns>true if the the match is repeated, false otherwise</returns>
	    private bool CheckRepeatedMatch(int start, int limit) {
	        if (m_matchedIndex_ == IBM.ICU.Text.SearchIterator.DONE) {
	            return false;
	        }
	        int end = limit - 1; // last character in the match
	        int lastmatchend = m_matchedIndex_ + matchLength - 1;
	        if (!IsOverlapping()) {
	            return (start >= m_matchedIndex_ && start <= lastmatchend)
	                    || (end >= m_matchedIndex_ && end <= lastmatchend)
	                    || (start <= m_matchedIndex_ && end >= lastmatchend);
	
	        }
	        return start <= m_matchedIndex_ && end >= lastmatchend;
	    }
	
	    /// <summary>
	    /// Checks match for contraction. If the match ends with a partial
	    /// contraction we fail. If the match starts too far off (because of
	    /// backwards iteration) we try to chip off the extra characters depending on
	    /// whether a breakiterator has been used. Temporary utility buffer used to
	    /// return modified start and end.
	    /// </summary>
	    ///
	    /// <param name="start">offset of potential match, to be modified if necessary</param>
	    /// <param name="end">offset of potential match, to be modified if necessary</param>
	    /// <returns>true if match passes the contraction test, false otherwise.</returns>
	    private bool CheckNextExactContractionMatch(int start, int end) {
	        // This part checks if either ends of the match contains potential
	        // contraction. If so we'll have to iterate through them
	        char endchar = (char) (0);
	        if (end < m_textLimitOffset_) {
	            targetText.SetIndex(end);
	            endchar = targetText.Current();
	        }
	        char poststartchar = (char) (0);
	        if (start + 1 < m_textLimitOffset_) {
	            targetText.SetIndex(start + 1);
	            poststartchar = targetText.Current();
	        }
	        if (m_collator_.IsUnsafe(endchar)
	                || m_collator_.IsUnsafe(poststartchar)) {
	            // expansion prefix, what's left to iterate
	            int bufferedCEOffset = m_colEIter_.m_CEBufferOffset_;
	            bool hasBufferedCE = bufferedCEOffset > 0;
	            m_colEIter_.SetExactOffset(start);
	            int temp = start;
	            while (bufferedCEOffset > 0) {
	                // getting rid of the redundant ce, caused by setOffset.
	                // since backward contraction/expansion may have extra ces if
	                // we are in the normalization buffer, hasAccentsBeforeMatch
	                // would have taken care of it.
	                // E.g. the character \u01FA will have an expansion of 3, but
	                // if we are only looking for acute and ring \u030A and \u0301,
	                // we'll have to skip the first ce in the expansion buffer.
	                m_colEIter_.Next();
	                if (m_colEIter_.GetOffset() != temp) {
	                    start = temp;
	                    temp = m_colEIter_.GetOffset();
	                }
	                bufferedCEOffset--;
	            }
	
	            int count = 0;
	            while (count < m_pattern_.m_CELength_) {
	                int ce = GetCE(m_colEIter_.Next());
	                if (ce == IBM.ICU.Text.CollationElementIterator.IGNORABLE) {
	                    continue;
	                }
	                if (hasBufferedCE && count == 0
	                        && m_colEIter_.GetOffset() != temp) {
	                    start = temp;
	                    temp = m_colEIter_.GetOffset();
	                }
	                if (ce != m_pattern_.m_CE_[count]) {
	                    end++;
	                    end = GetNextBaseOffset(end);
	                    m_utilBuffer_[0] = start;
	                    m_utilBuffer_[1] = end;
	                    return false;
	                }
	                count++;
	            }
	        }
	        m_utilBuffer_[0] = start;
	        m_utilBuffer_[1] = end;
	        return true;
	    }
	
	    /// <summary>
	    /// Checks and sets the match information if found. Checks
	    /// <ul>
	    /// <li>the potential match does not repeat the previous match
	    /// <li>boundaries are correct
	    /// <li>exact matches has no extra accents
	    /// <li>identical matchesb
	    /// <li>potential match does not end in the middle of a contraction
	    /// </ul>
	    /// Otherwise the offset will be shifted to the next character. The result
	    /// m_matchIndex_ and m_matchLength_ will be set to the truncated more
	    /// fitting result value. Uses the temporary utility buffer for storing the
	    /// modified textoffset.
	    /// </summary>
	    ///
	    /// <param name="textoffset">offset in the collation element text.</param>
	    /// <returns>true if the match is valid, false otherwise</returns>
	    private bool CheckNextExactMatch(int textoffset) {
	        int start = m_colEIter_.GetOffset();
	        if (!CheckNextExactContractionMatch(start, textoffset)) {
	            // returns the modified textoffset
	            m_utilBuffer_[0] = m_utilBuffer_[1];
	            return false;
	        }
	
	        start = m_utilBuffer_[0];
	        textoffset = m_utilBuffer_[1];
	        // this totally matches, however we need to check if it is repeating
	        if (!IsBreakUnit(start, textoffset)
	                || CheckRepeatedMatch(start, textoffset)
	                || HasAccentsBeforeMatch(start, textoffset)
	                || !CheckIdentical(start, textoffset)
	                || HasAccentsAfterMatch(start, textoffset)) {
	            textoffset++;
	            textoffset = GetNextBaseOffset(textoffset);
	            m_utilBuffer_[0] = textoffset;
	            return false;
	        }
	
	        if (m_collator_.GetStrength() == IBM.ICU.Text.Collator.PRIMARY) {
	            textoffset = CheckBreakBoundary(textoffset);
	        }
	
	        // totally match, we will get rid of the ending ignorables.
	        m_matchedIndex_ = start;
	        matchLength = textoffset - start;
	        return true;
	    }
	
	    /// <summary>
	    /// Getting the previous base character offset, or the current offset if the
	    /// current character is a base character
	    /// </summary>
	    ///
	    /// <param name="text">the source text to work on</param>
	    /// <param name="textoffset">one offset after the current character</param>
	    /// <returns>the offset of the next character after the base character or the
	    /// first composed character with accents</returns>
	    private int GetPreviousBaseOffset(ICharacterIterator text,
	            int textoffset) {
	        if (textoffset > m_textBeginOffset_) {
	            while (true) {
	                int result = textoffset;
	                text.SetIndex(result);
	                if (IBM.ICU.Text.UTF16.IsTrailSurrogate(text.Previous())) {
	                    if (text.GetIndex() != text.GetBeginIndex()
	                            && !IBM.ICU.Text.UTF16.IsLeadSurrogate(text.Previous())) {
	                        text.Next();
	                    }
	                }
	                textoffset = text.GetIndex();
	                char fcd = GetFCD(text, textoffset);
	                if ((fcd >> SECOND_LAST_BYTE_SHIFT_) == 0) {
	                    if ((fcd & LAST_BYTE_MASK_) != 0) {
	                        return textoffset;
	                    }
	                    return result;
	                }
	                if (textoffset == m_textBeginOffset_) {
	                    return m_textBeginOffset_;
	                }
	            }
	        }
	        return textoffset;
	    }
	
	    /// <summary>
	    /// Getting the indexes of the accents that are not blocked in the argument
	    /// accent array
	    /// </summary>
	    ///
	    /// <param name="accents">accents in nfd.</param>
	    /// <param name="accentsindex">array to store the indexes of accents in accents that are notblocked</param>
	    /// <returns>the length of populated accentsindex</returns>
	    private int GetUnblockedAccentIndex(StringBuilder accents,
	            int[] accentsindex) {
	        int index = 0;
	        int length = accents.Length;
	        int cclass = 0;
	        int result = 0;
	        while (index < length) {
	            int codepoint = IBM.ICU.Text.UTF16.CharAt(accents, index);
	            int tempclass = IBM.ICU.Lang.UCharacter.GetCombiningClass(codepoint);
	            if (tempclass != cclass) {
	                cclass = tempclass;
	                accentsindex[result] = index;
	                result++;
	            }
	            if (IBM.ICU.Lang.UCharacter.IsSupplementary(codepoint)) {
	                index += 2;
	            } else {
	                index++;
	            }
	        }
	        accentsindex[result] = length;
	        return result;
	    }
	
	    /// <summary>
	    /// Appends 3 StringBuffer/CharacterIterator together into a destination
	    /// string buffer.
	    /// </summary>
	    ///
	    /// <param name="source1">string buffer</param>
	    /// <param name="source2">character iterator</param>
	    /// <param name="start2">start of the character iterator to merge</param>
	    /// <param name="end2">end of the character iterator to merge</param>
	    /// <param name="source3">string buffer</param>
	    /// <returns>appended string buffer</returns>
	    private static StringBuilder Merge(StringBuilder source1,
	            ICharacterIterator source2, int start2, int end2,
	            StringBuilder source3) {
	        StringBuilder result = new StringBuilder();
	        if (source1 != null && source1.Length != 0) {
	            // jdk 1.3.1 does not have append(StringBuffer) yet
	            if (IBM.ICU.Impl.ICUDebug.isJDK14OrHigher) {
	                result.Append(source1);
	            } else {
	                result.Append(source1.ToString());
	            }
	        }
	        source2.SetIndex(start2);
	        while (source2.GetIndex() < end2) {
	            result.Append(source2.Current());
	            source2.Next();
	        }
	        if (source3 != null && source3.Length != 0) {
	            // jdk 1.3.1 does not have append(StringBuffer) yet
	            if (IBM.ICU.Impl.ICUDebug.isJDK14OrHigher) {
	                result.Append(source3);
	            } else {
	                result.Append(source3.ToString());
	            }
	        }
	        return result;
	    }
	
	    /// <summary>
	    /// Running through a collation element iterator to see if the contents
	    /// matches pattern in string search data
	    /// </summary>
	    ///
	    /// <param name="coleiter">collation element iterator to test</param>
	    /// <returns>true if a match if found, false otherwise</returns>
	    private bool CheckCollationMatch(CollationElementIterator coleiter) {
	        int patternceindex = m_pattern_.m_CELength_;
	        int offset = 0;
	        while (patternceindex > 0) {
	            int ce = GetCE(coleiter.Next());
	            if (ce == IBM.ICU.Text.CollationElementIterator.IGNORABLE) {
	                continue;
	            }
	            if (ce != m_pattern_.m_CE_[offset]) {
	                return false;
	            }
	            offset++;
	            patternceindex--;
	        }
	        return true;
	    }
	
	    /// <summary>
	    /// Rearranges the front accents to try matching. Prefix accents in the text
	    /// will be grouped according to their combining class and the groups will be
	    /// mixed and matched to try find the perfect match with the pattern. So for
	    /// instance looking for "\u0301" in "\u030A\u0301\u0325" step 1: split
	    /// "\u030A\u0301" into 6 other type of potential accent substrings "\u030A",
	    /// "\u0301", "\u0325", "\u030A\u0301", "\u030A\u0325", "\u0301\u0325". step
	    /// 2: check if any of the generated substrings matches the pattern. Internal
	    /// method, status is assumed to be success, caller has to check status
	    /// before calling this method.
	    /// </summary>
	    ///
	    /// <param name="start">first offset of the accents to start searching</param>
	    /// <param name="end">start of the last accent set</param>
	    /// <returns>DONE if a match is not found, otherwise return the starting
	    /// offset of the match. Note this start includes all preceding
	    /// accents.</returns>
	    private int DoNextCanonicalPrefixMatch(int start, int end) {
	        if ((GetFCD(targetText, start) & LAST_BYTE_MASK_) == 0) {
	            // die... failed at a base character
	            return IBM.ICU.Text.SearchIterator.DONE;
	        }
	
	        start = targetText.GetIndex(); // index changed by fcd
	        int offset = GetNextBaseOffset(targetText, start);
	        start = GetPreviousBaseOffset(start);
	
	        StringBuilder accents = new StringBuilder();
	        String accentstr = GetString(targetText, start, offset - start);
	        // normalizing the offensive string
	        if (IBM.ICU.Text.Normalizer.QuickCheck(accentstr, IBM.ICU.Text.Normalizer.NFD, 0) == IBM.ICU.Text.Normalizer.NO) {
	            accentstr = IBM.ICU.Text.Normalizer.Decompose(accentstr, false);
	        }
	        accents.Append(accentstr);
	
	        int[] accentsindex = new int[INITIAL_ARRAY_SIZE_];
	        int accentsize = GetUnblockedAccentIndex(accents, accentsindex);
	        int count = (2 << (accentsize - 1)) - 1;
	        while (count > 0) {
	            // copy the base characters
	            m_canonicalPrefixAccents_.Remove(0,m_canonicalPrefixAccents_.Length-(0));
	            int k = 0;
	            for (; k < accentsindex[0]; k++) {
	                m_canonicalPrefixAccents_.Append(accents[k]);
	            }
	            // forming all possible canonical rearrangement by dropping
	            // sets of accents
	            for (int i = 0; i <= accentsize - 1; i++) {
	                int mask = 1 << (accentsize - i - 1);
	                if ((count & mask) != 0) {
	                    for (int j = accentsindex[i]; j < accentsindex[i + 1]; j++) {
	                        m_canonicalPrefixAccents_.Append(accents[j]);
	                    }
	                }
	            }
	            StringBuilder match = Merge(m_canonicalPrefixAccents_, targetText,
	                    offset, end, m_canonicalSuffixAccents_);
	
	            // if status is a failure, ucol_setText does nothing.
	            // run the collator iterator through this match
	            m_utilColEIter_.SetText(match.ToString());
	            if (CheckCollationMatch(m_utilColEIter_)) {
	                return start;
	            }
	            count--;
	        }
	        return IBM.ICU.Text.SearchIterator.DONE;
	    }
	
	    /// <summary>
	    /// Gets the offset to the safe point in text before textoffset. ie. not the
	    /// middle of a contraction, swappable characters or supplementary
	    /// characters.
	    /// </summary>
	    ///
	    /// <param name="start">offset in string</param>
	    /// <param name="textoffset">offset in string</param>
	    /// <returns>offset to the previous safe character</returns>
	    private int GetPreviousSafeOffset(int start, int textoffset) {
	        int result = textoffset; // first contraction character
	        targetText.SetIndex(textoffset);
	        while (result >= start && m_collator_.IsUnsafe(targetText.Previous())) {
	            result = targetText.GetIndex();
	        }
	        if (result != start) {
	            // the first contraction character is consider unsafe here
	            result = targetText.GetIndex(); // originally result --;
	        }
	        return result;
	    }
	
	    /// <summary>
	    /// Take the rearranged end accents and tries matching. If match failed at a
	    /// seperate preceding set of accents (seperated from the rearranged on by at
	    /// least a base character) then we rearrange the preceding accents and tries
	    /// matching again. We allow skipping of the ends of the accent set if the
	    /// ces do not match. However if the failure is found before the accent set,
	    /// it fails. Internal method, status assumed to be success, caller has to
	    /// check status before calling this method.
	    /// </summary>
	    ///
	    /// <param name="textoffset">of the start of the rearranged accent</param>
	    /// <returns>DONE if a match is not found, otherwise return the starting
	    /// offset of the match. Note this start includes all preceding
	    /// accents.</returns>
	    private int DoNextCanonicalSuffixMatch(int textoffset) {
	        int safelength = 0;
	        StringBuilder safetext;
	        int safeoffset = m_textBeginOffset_;
	
	        if (textoffset != m_textBeginOffset_
	                && m_canonicalSuffixAccents_.Length > 0
	                && m_collator_.IsUnsafe(m_canonicalSuffixAccents_[0])) {
	            safeoffset = GetPreviousSafeOffset(m_textBeginOffset_, textoffset);
	            safelength = textoffset - safeoffset;
	            safetext = Merge(null, targetText, safeoffset, textoffset,
	                    m_canonicalSuffixAccents_);
	        } else {
	            safetext = m_canonicalSuffixAccents_;
	        }
	
	        // if status is a failure, ucol_setText does nothing
	        CollationElementIterator coleiter = m_utilColEIter_;
	        coleiter.SetText(safetext.ToString());
	        // status checked in loop below
	
	        int ceindex = m_pattern_.m_CELength_ - 1;
	        bool isSafe = true; // indication flag for position in safe zone
	
	        while (ceindex >= 0) {
	            int textce = coleiter.Previous();
	            if (textce == IBM.ICU.Text.CollationElementIterator.NULLORDER) {
	                // check if we have passed the safe buffer
	                if (coleiter == m_colEIter_) {
	                    return IBM.ICU.Text.SearchIterator.DONE;
	                }
	                coleiter = m_colEIter_;
	                if (safetext != m_canonicalSuffixAccents_) {
	                    safetext.Remove(0,safetext.Length-(0));
	                }
	                coleiter.SetExactOffset(safeoffset);
	                // status checked at the start of the loop
	                isSafe = false;
	                continue;
	            }
	            textce = GetCE(textce);
	            if (textce != IBM.ICU.Text.CollationElementIterator.IGNORABLE
	                    && textce != m_pattern_.m_CE_[ceindex]) {
	                // do the beginning stuff
	                int failedoffset = coleiter.GetOffset();
	                if (isSafe && failedoffset >= safelength) {
	                    // alas... no hope. failed at rearranged accent set
	                    return IBM.ICU.Text.SearchIterator.DONE;
	                } else {
	                    if (isSafe) {
	                        failedoffset += safeoffset;
	                    }
	
	                    // try rearranging the front accents
	                    int result = DoNextCanonicalPrefixMatch(failedoffset,
	                            textoffset);
	                    if (result != IBM.ICU.Text.SearchIterator.DONE) {
	                        // if status is a failure, ucol_setOffset does nothing
	                        m_colEIter_.SetExactOffset(result);
	                    }
	                    return result;
	                }
	            }
	            if (textce == m_pattern_.m_CE_[ceindex]) {
	                ceindex--;
	            }
	        }
	        // set offset here
	        if (isSafe) {
	            int result_0 = coleiter.GetOffset();
	            // sets the text iterator with the correct expansion and offset
	            int leftoverces = coleiter.m_CEBufferOffset_;
	            if (result_0 >= safelength) {
	                result_0 = textoffset;
	            } else {
	                result_0 += safeoffset;
	            }
	            m_colEIter_.SetExactOffset(result_0);
	            m_colEIter_.m_CEBufferOffset_ = leftoverces;
	            return result_0;
	        }
	
	        return coleiter.GetOffset();
	    }
	
	    /// <summary>
	    /// Trying out the substring and sees if it can be a canonical match. This
	    /// will try normalizing the end accents and arranging them into canonical
	    /// equivalents and check their corresponding ces with the pattern ce. Suffix
	    /// accents in the text will be grouped according to their combining class
	    /// and the groups will be mixed and matched to try find the perfect match
	    /// with the pattern. So for instance looking for "\u0301" in
	    /// "\u030A\u0301\u0325" step 1: split "\u030A\u0301" into 6 other type of
	    /// potential accent substrings "\u030A", "\u0301", "\u0325", "\u030A\u0301",
	    /// "\u030A\u0325", "\u0301\u0325". step 2: check if any of the generated
	    /// substrings matches the pattern.
	    /// </summary>
	    ///
	    /// <param name="textoffset">end offset in the collation element text that ends with theaccents to be rearranged</param>
	    /// <returns>true if the match is valid, false otherwise</returns>
	    private bool DoNextCanonicalMatch(int textoffset) {
	        int offset = m_colEIter_.GetOffset();
	        targetText.SetIndex(textoffset);
	        if (IBM.ICU.Text.UTF16.IsTrailSurrogate(targetText.Previous())
	                && targetText.GetIndex() > m_textBeginOffset_) {
	            if (!IBM.ICU.Text.UTF16.IsLeadSurrogate(targetText.Previous())) {
	                targetText.Next();
	            }
	        }
	        if ((GetFCD(targetText, targetText.GetIndex()) & LAST_BYTE_MASK_) == 0) {
	            if (m_pattern_.m_hasPrefixAccents_) {
	                offset = DoNextCanonicalPrefixMatch(offset, textoffset);
	                if (offset != IBM.ICU.Text.SearchIterator.DONE) {
	                    m_colEIter_.SetExactOffset(offset);
	                    return true;
	                }
	            }
	            return false;
	        }
	
	        if (!m_pattern_.m_hasSuffixAccents_) {
	            return false;
	        }
	
	        StringBuilder accents = new StringBuilder();
	        // offset to the last base character in substring to search
	        int baseoffset = GetPreviousBaseOffset(targetText, textoffset);
	        // normalizing the offensive string
	        String accentstr = GetString(targetText, baseoffset, textoffset
	                - baseoffset);
	        if (IBM.ICU.Text.Normalizer.QuickCheck(accentstr, IBM.ICU.Text.Normalizer.NFD, 0) == IBM.ICU.Text.Normalizer.NO) {
	            accentstr = IBM.ICU.Text.Normalizer.Decompose(accentstr, false);
	        }
	        accents.Append(accentstr);
	        // status checked in loop below
	
	        int[] accentsindex = new int[INITIAL_ARRAY_SIZE_];
	        int size = GetUnblockedAccentIndex(accents, accentsindex);
	
	        // 2 power n - 1 plus the full set of accents
	        int count = (2 << (size - 1)) - 1;
	        while (count > 0) {
	            m_canonicalSuffixAccents_.Remove(0,m_canonicalSuffixAccents_.Length-(0));
	            // copy the base characters
	            for (int k = 0; k < accentsindex[0]; k++) {
	                m_canonicalSuffixAccents_.Append(accents[k]);
	            }
	            // forming all possible canonical rearrangement by dropping
	            // sets of accents
	            for (int i = 0; i <= size - 1; i++) {
	                int mask = 1 << (size - i - 1);
	                if ((count & mask) != 0) {
	                    for (int j = accentsindex[i]; j < accentsindex[i + 1]; j++) {
	                        m_canonicalSuffixAccents_.Append(accents[j]);
	                    }
	                }
	            }
	            offset = DoNextCanonicalSuffixMatch(baseoffset);
	            if (offset != IBM.ICU.Text.SearchIterator.DONE) {
	                return true; // match found
	            }
	            count--;
	        }
	        return false;
	    }
	
	    /// <summary>
	    /// Gets the previous base character offset depending on the string search
	    /// pattern data
	    /// </summary>
	    ///
	    /// <param name="strsrch">string search data</param>
	    /// <param name="textoffset">current offset, current character</param>
	    /// <returns>the offset of the next character after this base character or
	    /// itself if it is a composed character with accents</returns>
	    private int GetPreviousBaseOffset(int textoffset) {
	        if (m_pattern_.m_hasPrefixAccents_ && textoffset > m_textBeginOffset_) {
	            int offset = textoffset;
	            if ((GetFCD(targetText, offset) >> SECOND_LAST_BYTE_SHIFT_) != 0) {
	                return GetPreviousBaseOffset(targetText, textoffset);
	            }
	        }
	        return textoffset;
	    }
	
	    /// <summary>
	    /// Checks match for contraction. If the match ends with a partial
	    /// contraction we fail. If the match starts too far off (because of
	    /// backwards iteration) we try to chip off the extra characters. Uses the
	    /// temporary util buffer for return values of the modified start and end.
	    /// </summary>
	    ///
	    /// <param name="start">offset of potential match, to be modified if necessary</param>
	    /// <param name="end">offset of potential match, to be modified if necessary</param>
	    /// <returns>true if match passes the contraction test, false otherwise.</returns>
	    private bool CheckNextCanonicalContractionMatch(int start, int end) {
	        // This part checks if either ends of the match contains potential
	        // contraction. If so we'll have to iterate through them
	        char schar = (char) (0);
	        char echar = (char) (0);
	        if (end < m_textLimitOffset_) {
	            targetText.SetIndex(end);
	            echar = targetText.Current();
	        }
	        if (start < m_textLimitOffset_) {
	            targetText.SetIndex(start + 1);
	            schar = targetText.Current();
	        }
	        if (m_collator_.IsUnsafe(echar) || m_collator_.IsUnsafe(schar)) {
	            int expansion = m_colEIter_.m_CEBufferOffset_;
	            bool hasExpansion = expansion > 0;
	            m_colEIter_.SetExactOffset(start);
	            int temp = start;
	            while (expansion > 0) {
	                // getting rid of the redundant ce, caused by setOffset.
	                // since backward contraction/expansion may have extra ces if
	                // we are in the normalization buffer, hasAccentsBeforeMatch
	                // would have taken care of it.
	                // E.g. the character \u01FA will have an expansion of 3, but
	                // if we are only looking for acute and ring \u030A and \u0301,
	                // we'll have to skip the first ce in the expansion buffer.
	                m_colEIter_.Next();
	                if (m_colEIter_.GetOffset() != temp) {
	                    start = temp;
	                    temp = m_colEIter_.GetOffset();
	                }
	                expansion--;
	            }
	
	            int count = 0;
	            while (count < m_pattern_.m_CELength_) {
	                int ce = GetCE(m_colEIter_.Next());
	                // status checked below, note that if status is a failure
	                // ucol_next returns UCOL_NULLORDER
	                if (ce == IBM.ICU.Text.CollationElementIterator.IGNORABLE) {
	                    continue;
	                }
	                if (hasExpansion && count == 0
	                        && m_colEIter_.GetOffset() != temp) {
	                    start = temp;
	                    temp = m_colEIter_.GetOffset();
	                }
	
	                if (count == 0 && ce != m_pattern_.m_CE_[0]) {
	                    // accents may have extra starting ces, this occurs when a
	                    // pure accent pattern is matched without rearrangement
	                    // text \u0325\u0300 and looking for \u0300
	                    int expected = m_pattern_.m_CE_[0];
	                    if ((GetFCD(targetText, start) & LAST_BYTE_MASK_) != 0) {
	                        ce = GetCE(m_colEIter_.Next());
	                        while (ce != expected
	                                && ce != IBM.ICU.Text.CollationElementIterator.NULLORDER
	                                && m_colEIter_.GetOffset() <= end) {
	                            ce = GetCE(m_colEIter_.Next());
	                        }
	                    }
	                }
	                if (ce != m_pattern_.m_CE_[count]) {
	                    end++;
	                    end = GetNextBaseOffset(end);
	                    m_utilBuffer_[0] = start;
	                    m_utilBuffer_[1] = end;
	                    return false;
	                }
	                count++;
	            }
	        }
	        m_utilBuffer_[0] = start;
	        m_utilBuffer_[1] = end;
	        return true;
	    }
	
	    /// <summary>
	    /// Checks and sets the match information if found. Checks
	    /// <ul>
	    /// <li>the potential match does not repeat the previous match
	    /// <li>boundaries are correct
	    /// <li>potential match does not end in the middle of a contraction
	    /// <li>identical matches
	    /// </ul>
	    /// Otherwise the offset will be shifted to the next character. The result
	    /// m_matchIndex_ and m_matchLength_ will be set to the truncated more
	    /// fitting result value. Uses the temporary utility buffer for storing the
	    /// modified textoffset.
	    /// </summary>
	    ///
	    /// <param name="textoffset">offset in the collation element text.</param>
	    /// <returns>true if the match is valid, false otherwise</returns>
	    private bool CheckNextCanonicalMatch(int textoffset) {
	        // to ensure that the start and ends are not composite characters
	        // if we have a canonical accent match
	        if ((m_pattern_.m_hasSuffixAccents_ && m_canonicalSuffixAccents_.Length != 0)
	                || (m_pattern_.m_hasPrefixAccents_ && m_canonicalPrefixAccents_.Length != 0)) {
	            m_matchedIndex_ = GetPreviousBaseOffset(m_colEIter_.GetOffset());
	            matchLength = textoffset - m_matchedIndex_;
	            return true;
	        }
	
	        int start = m_colEIter_.GetOffset();
	        if (!CheckNextCanonicalContractionMatch(start, textoffset)) {
	            // return the modified textoffset
	            m_utilBuffer_[0] = m_utilBuffer_[1];
	            return false;
	        }
	        start = m_utilBuffer_[0];
	        textoffset = m_utilBuffer_[1];
	        start = GetPreviousBaseOffset(start);
	        // this totally matches, however we need to check if it is repeating
	        if (CheckRepeatedMatch(start, textoffset)
	                || !IsBreakUnit(start, textoffset)
	                || !CheckIdentical(start, textoffset)) {
	            textoffset++;
	            textoffset = GetNextBaseOffset(targetText, textoffset);
	            m_utilBuffer_[0] = textoffset;
	            return false;
	        }
	
	        m_matchedIndex_ = start;
	        matchLength = textoffset - start;
	        return true;
	    }
	
	    /// <summary>
	    /// Shifting the collation element iterator position forward to prepare for a
	    /// preceding match. If the first character is a unsafe character, we'll only
	    /// shift by 1 to capture contractions, normalization etc.
	    /// </summary>
	    ///
	    /// <param name="textoffset">start text position to do search</param>
	    /// <param name="ce">the text ce which failed the match.</param>
	    /// <param name="patternceindex">index of the ce within the pattern ce buffer which failed thematch</param>
	    /// <returns>final offset</returns>
	    private int ReverseShift(int textoffset, int ce, int patternceindex) {
	        if (IsOverlapping()) {
	            if (textoffset != m_textLimitOffset_) {
	                textoffset--;
	            } else {
	                textoffset -= m_pattern_.m_defaultShiftSize_;
	            }
	        } else {
	            if (ce != IBM.ICU.Text.CollationElementIterator.NULLORDER) {
	                int shift = m_pattern_.m_backShift_[Hash(ce)];
	
	                // this is to adjust for characters in the middle of the
	                // substring
	                // for matching that failed.
	                int adjust = patternceindex;
	                if (adjust > 1 && shift > adjust) {
	                    shift -= adjust - 1;
	                }
	                textoffset -= shift;
	            } else {
	                textoffset -= m_pattern_.m_defaultShiftSize_;
	            }
	        }
	
	        textoffset = GetPreviousBaseOffset(textoffset);
	        return textoffset;
	    }
	
	    /// <summary>
	    /// Checks match for contraction. If the match starts with a partial
	    /// contraction we fail. Uses the temporary utility buffer to return the
	    /// modified start and end.
	    /// </summary>
	    ///
	    /// <param name="start">offset of potential match, to be modified if necessary</param>
	    /// <param name="end">offset of potential match, to be modified if necessary</param>
	    /// <returns>true if match passes the contraction test, false otherwise.</returns>
	    private bool CheckPreviousExactContractionMatch(int start, int end) {
	        // This part checks if either ends of the match contains potential
	        // contraction. If so we'll have to iterate through them
	        char echar = (char) (0);
	        if (end < m_textLimitOffset_) {
	            targetText.SetIndex(end);
	            echar = targetText.Current();
	        }
	        char schar = (char) (0);
	        if (start + 1 < m_textLimitOffset_) {
	            targetText.SetIndex(start + 1);
	            schar = targetText.Current();
	        }
	        if (m_collator_.IsUnsafe(echar) || m_collator_.IsUnsafe(schar)) {
	            // expansion suffix, what's left to iterate
	            int expansion = m_colEIter_.m_CEBufferSize_
	                    - m_colEIter_.m_CEBufferOffset_;
	            bool hasExpansion = expansion > 0;
	            m_colEIter_.SetExactOffset(end);
	            int temp = end;
	            while (expansion > 0) {
	                // getting rid of the redundant ce
	                // since forward contraction/expansion may have extra ces
	                // if we are in the normalization buffer, hasAccentsBeforeMatch
	                // would have taken care of it.
	                // E.g. the character \u01FA will have an expansion of 3, but if
	                // we are only looking for A ring A\u030A, we'll have to skip
	                // the
	                // last ce in the expansion buffer
	                m_colEIter_.Previous();
	                if (m_colEIter_.GetOffset() != temp) {
	                    end = temp;
	                    temp = m_colEIter_.GetOffset();
	                }
	                expansion--;
	            }
	
	            int count = m_pattern_.m_CELength_;
	            while (count > 0) {
	                int ce = GetCE(m_colEIter_.Previous());
	                // status checked below, note that if status is a failure
	                // ucol_previous returns UCOL_NULLORDER
	                if (ce == IBM.ICU.Text.CollationElementIterator.IGNORABLE) {
	                    continue;
	                }
	                if (hasExpansion && count == 0
	                        && m_colEIter_.GetOffset() != temp) {
	                    end = temp;
	                    temp = m_colEIter_.GetOffset();
	                }
	                if (ce != m_pattern_.m_CE_[count - 1]) {
	                    start--;
	                    start = GetPreviousBaseOffset(targetText, start);
	                    m_utilBuffer_[0] = start;
	                    m_utilBuffer_[1] = end;
	                    return false;
	                }
	                count--;
	            }
	        }
	        m_utilBuffer_[0] = start;
	        m_utilBuffer_[1] = end;
	        return true;
	    }
	
	    /// <summary>
	    /// Checks and sets the match information if found. Checks
	    /// <ul>
	    /// <li>the current match does not repeat the last match
	    /// <li>boundaries are correct
	    /// <li>exact matches has no extra accents
	    /// <li>identical matches
	    /// </ul>
	    /// Otherwise the offset will be shifted to the preceding character. Uses the
	    /// temporary utility buffer to store the modified textoffset.
	    /// </summary>
	    ///
	    /// <param name="textoffset">offset in the collation element text. the returned value willbe the truncated start offset of the match or the new startsearch offset.</param>
	    /// <returns>true if the match is valid, false otherwise</returns>
	    private bool CheckPreviousExactMatch(int textoffset) {
	        // to ensure that the start and ends are not composite characters
	        int end = m_colEIter_.GetOffset();
	        if (!CheckPreviousExactContractionMatch(textoffset, end)) {
	            return false;
	        }
	        textoffset = m_utilBuffer_[0];
	        end = m_utilBuffer_[1];
	
	        // this totally matches, however we need to check if it is repeating
	        // the old match
	        if (CheckRepeatedMatch(textoffset, end)
	                || !IsBreakUnit(textoffset, end)
	                || HasAccentsBeforeMatch(textoffset, end)
	                || !CheckIdentical(textoffset, end)
	                || HasAccentsAfterMatch(textoffset, end)) {
	            textoffset--;
	            textoffset = GetPreviousBaseOffset(targetText, textoffset);
	            m_utilBuffer_[0] = textoffset;
	            return false;
	        }
	
	        if (m_collator_.GetStrength() == IBM.ICU.Text.Collator.PRIMARY) {
	            end = CheckBreakBoundary(end);
	        }
	
	        m_matchedIndex_ = textoffset;
	        matchLength = end - textoffset;
	        return true;
	    }
	
	    /// <summary>
	    /// Rearranges the end accents to try matching. Suffix accents in the text
	    /// will be grouped according to their combining class and the groups will be
	    /// mixed and matched to try find the perfect match with the pattern. So for
	    /// instance looking for "\u0301" in "\u030A\u0301\u0325" step 1: split
	    /// "\u030A\u0301" into 6 other type of potential accent substrings "\u030A",
	    /// "\u0301", "\u0325", "\u030A\u0301", "\u030A\u0325", "\u0301\u0325". step
	    /// 2: check if any of the generated substrings matches the pattern.
	    /// </summary>
	    ///
	    /// <param name="start">offset of the first base character</param>
	    /// <param name="end">start of the last accent set</param>
	    /// <returns>DONE if a match is not found, otherwise return the ending offset
	    /// of the match. Note this start includes all following accents.</returns>
	    private int DoPreviousCanonicalSuffixMatch(int start, int end) {
	        targetText.SetIndex(end);
	        if (IBM.ICU.Text.UTF16.IsTrailSurrogate(targetText.Previous())
	                && targetText.GetIndex() > m_textBeginOffset_) {
	            if (!IBM.ICU.Text.UTF16.IsLeadSurrogate(targetText.Previous())) {
	                targetText.Next();
	            }
	        }
	        if ((GetFCD(targetText, targetText.GetIndex()) & LAST_BYTE_MASK_) == 0) {
	            // die... failed at a base character
	            return IBM.ICU.Text.SearchIterator.DONE;
	        }
	        end = GetNextBaseOffset(targetText, end);
	
	        StringBuilder accents = new StringBuilder();
	        int offset = GetPreviousBaseOffset(targetText, end);
	        // normalizing the offensive string
	        String accentstr = GetString(targetText, offset, end - offset);
	        if (IBM.ICU.Text.Normalizer.QuickCheck(accentstr, IBM.ICU.Text.Normalizer.NFD, 0) == IBM.ICU.Text.Normalizer.NO) {
	            accentstr = IBM.ICU.Text.Normalizer.Decompose(accentstr, false);
	        }
	        accents.Append(accentstr);
	
	        int[] accentsindex = new int[INITIAL_ARRAY_SIZE_];
	        int accentsize = GetUnblockedAccentIndex(accents, accentsindex);
	        int count = (2 << (accentsize - 1)) - 1;
	        while (count > 0) {
	            m_canonicalSuffixAccents_.Remove(0,m_canonicalSuffixAccents_.Length-(0));
	            // copy the base characters
	            for (int k = 0; k < accentsindex[0]; k++) {
	                m_canonicalSuffixAccents_.Append(accents[k]);
	            }
	            // forming all possible canonical rearrangement by dropping
	            // sets of accents
	            for (int i = 0; i <= accentsize - 1; i++) {
	                int mask = 1 << (accentsize - i - 1);
	                if ((count & mask) != 0) {
	                    for (int j = accentsindex[i]; j < accentsindex[i + 1]; j++) {
	                        m_canonicalSuffixAccents_.Append(accents[j]);
	                    }
	                }
	            }
	            StringBuilder match = Merge(m_canonicalPrefixAccents_, targetText,
	                    start, offset, m_canonicalSuffixAccents_);
	            // run the collator iterator through this match
	            // if status is a failure ucol_setText does nothing
	            m_utilColEIter_.SetText(match.ToString());
	            if (CheckCollationMatch(m_utilColEIter_)) {
	                return end;
	            }
	            count--;
	        }
	        return IBM.ICU.Text.SearchIterator.DONE;
	    }
	
	    /// <summary>
	    /// Take the rearranged start accents and tries matching. If match failed at
	    /// a seperate following set of accents (seperated from the rearranged on by
	    /// at least a base character) then we rearrange the preceding accents and
	    /// tries matching again. We allow skipping of the ends of the accent set if
	    /// the ces do not match. However if the failure is found before the accent
	    /// set, it fails. Internal method, status assumed to be success, caller has
	    /// to check status before calling this method.
	    /// </summary>
	    ///
	    /// <param name="textoffset">of the ends of the rearranged accent</param>
	    /// <returns>DONE if a match is not found, otherwise return the ending offset
	    /// of the match. Note this start includes all following accents.</returns>
	    private int DoPreviousCanonicalPrefixMatch(int textoffset) {
	        // int safelength = 0;
	        StringBuilder safetext;
	        int safeoffset = textoffset;
	
	        if (textoffset > m_textBeginOffset_
	                && m_collator_.IsUnsafe(m_canonicalPrefixAccents_[m_canonicalPrefixAccents_.Length - 1])) {
	            safeoffset = GetNextSafeOffset(textoffset, m_textLimitOffset_);
	            // safelength = safeoffset - textoffset;
	            safetext = Merge(m_canonicalPrefixAccents_, targetText, textoffset,
	                    safeoffset, null);
	        } else {
	            safetext = m_canonicalPrefixAccents_;
	        }
	
	        // if status is a failure, ucol_setText does nothing
	        CollationElementIterator coleiter = m_utilColEIter_;
	        coleiter.SetText(safetext.ToString());
	        // status checked in loop below
	
	        int ceindex = 0;
	        bool isSafe = true; // safe zone indication flag for position
	        int prefixlength = m_canonicalPrefixAccents_.Length;
	
	        while (ceindex < m_pattern_.m_CELength_) {
	            int textce = coleiter.Next();
	            if (textce == IBM.ICU.Text.CollationElementIterator.NULLORDER) {
	                // check if we have passed the safe buffer
	                if (coleiter == m_colEIter_) {
	                    return IBM.ICU.Text.SearchIterator.DONE;
	                }
	                if (safetext != m_canonicalPrefixAccents_) {
	                    safetext.Remove(0,safetext.Length-(0));
	                }
	                coleiter = m_colEIter_;
	                coleiter.SetExactOffset(safeoffset);
	                // status checked at the start of the loop
	                isSafe = false;
	                continue;
	            }
	            textce = GetCE(textce);
	            if (textce != IBM.ICU.Text.CollationElementIterator.IGNORABLE
	                    && textce != m_pattern_.m_CE_[ceindex]) {
	                // do the beginning stuff
	                int failedoffset = coleiter.GetOffset();
	                if (isSafe && failedoffset <= prefixlength) {
	                    // alas... no hope. failed at rearranged accent set
	                    return IBM.ICU.Text.SearchIterator.DONE;
	                } else {
	                    if (isSafe) {
	                        failedoffset = safeoffset - failedoffset;
	                        if (safetext != m_canonicalPrefixAccents_) {
	                            safetext.Remove(0,safetext.Length-(0));
	                        }
	                    }
	
	                    // try rearranging the end accents
	                    int result = DoPreviousCanonicalSuffixMatch(textoffset,
	                            failedoffset);
	                    if (result != IBM.ICU.Text.SearchIterator.DONE) {
	                        // if status is a failure, ucol_setOffset does nothing
	                        m_colEIter_.SetExactOffset(result);
	                    }
	                    return result;
	                }
	            }
	            if (textce == m_pattern_.m_CE_[ceindex]) {
	                ceindex++;
	            }
	        }
	        // set offset here
	        if (isSafe) {
	            int result_0 = coleiter.GetOffset();
	            // sets the text iterator here with the correct expansion and offset
	            int leftoverces = coleiter.m_CEBufferSize_
	                    - coleiter.m_CEBufferOffset_;
	            if (result_0 <= prefixlength) {
	                result_0 = textoffset;
	            } else {
	                result_0 = textoffset + (safeoffset - result_0);
	            }
	            m_colEIter_.SetExactOffset(result_0);
	            m_colEIter_.m_CEBufferOffset_ = m_colEIter_.m_CEBufferSize_
	                    - leftoverces;
	            return result_0;
	        }
	
	        return coleiter.GetOffset();
	    }
	
	    /// <summary>
	    /// Trying out the substring and sees if it can be a canonical match. This
	    /// will try normalizing the starting accents and arranging them into
	    /// canonical equivalents and check their corresponding ces with the pattern
	    /// ce. Prefix accents in the text will be grouped according to their
	    /// combining class and the groups will be mixed and matched to try find the
	    /// perfect match with the pattern. So for instance looking for "\u0301" in
	    /// "\u030A\u0301\u0325" step 1: split "\u030A\u0301" into 6 other type of
	    /// potential accent substrings "\u030A", "\u0301", "\u0325", "\u030A\u0301",
	    /// "\u030A\u0325", "\u0301\u0325". step 2: check if any of the generated
	    /// substrings matches the pattern.
	    /// </summary>
	    ///
	    /// <param name="textoffset">start offset in the collation element text that starts withthe accents to be rearranged</param>
	    /// <returns>true if the match is valid, false otherwise</returns>
	    private bool DoPreviousCanonicalMatch(int textoffset) {
	        int offset = m_colEIter_.GetOffset();
	        if ((GetFCD(targetText, textoffset) >> SECOND_LAST_BYTE_SHIFT_) == 0) {
	            if (m_pattern_.m_hasSuffixAccents_) {
	                offset = DoPreviousCanonicalSuffixMatch(textoffset, offset);
	                if (offset != IBM.ICU.Text.SearchIterator.DONE) {
	                    m_colEIter_.SetExactOffset(offset);
	                    return true;
	                }
	            }
	            return false;
	        }
	
	        if (!m_pattern_.m_hasPrefixAccents_) {
	            return false;
	        }
	
	        StringBuilder accents = new StringBuilder();
	        // offset to the last base character in substring to search
	        int baseoffset = GetNextBaseOffset(targetText, textoffset);
	        // normalizing the offensive string
	        String textstr = GetString(targetText, textoffset, baseoffset
	                - textoffset);
	        if (IBM.ICU.Text.Normalizer.QuickCheck(textstr, IBM.ICU.Text.Normalizer.NFD, 0) == IBM.ICU.Text.Normalizer.NO) {
	            textstr = IBM.ICU.Text.Normalizer.Decompose(textstr, false);
	        }
	        accents.Append(textstr);
	        // status checked in loop
	
	        int[] accentsindex = new int[INITIAL_ARRAY_SIZE_];
	        int size = GetUnblockedAccentIndex(accents, accentsindex);
	
	        // 2 power n - 1 plus the full set of accents
	        int count = (2 << (size - 1)) - 1;
	        while (count > 0) {
	            m_canonicalPrefixAccents_.Remove(0,m_canonicalPrefixAccents_.Length-(0));
	            // copy the base characters
	            for (int k = 0; k < accentsindex[0]; k++) {
	                m_canonicalPrefixAccents_.Append(accents[k]);
	            }
	            // forming all possible canonical rearrangement by dropping
	            // sets of accents
	            for (int i = 0; i <= size - 1; i++) {
	                int mask = 1 << (size - i - 1);
	                if ((count & mask) != 0) {
	                    for (int j = accentsindex[i]; j < accentsindex[i + 1]; j++) {
	                        m_canonicalPrefixAccents_.Append(accents[j]);
	                    }
	                }
	            }
	            offset = DoPreviousCanonicalPrefixMatch(baseoffset);
	            if (offset != IBM.ICU.Text.SearchIterator.DONE) {
	                return true; // match found
	            }
	            count--;
	        }
	        return false;
	    }
	
	    /// <summary>
	    /// Checks match for contraction. If the match starts with a partial
	    /// contraction we fail. Uses the temporary utility buffer to return the
	    /// modified start and end.
	    /// </summary>
	    ///
	    /// <param name="start">offset of potential match, to be modified if necessary</param>
	    /// <param name="end">offset of potential match, to be modified if necessary</param>
	    /// <returns>true if match passes the contraction test, false otherwise.</returns>
	    private bool CheckPreviousCanonicalContractionMatch(int start, int end) {
	        int temp = end;
	        // This part checks if either ends of the match contains potential
	        // contraction. If so we'll have to iterate through them
	        char echar = (char) (0);
	        char schar = (char) (0);
	        if (end < m_textLimitOffset_) {
	            targetText.SetIndex(end);
	            echar = targetText.Current();
	        }
	        if (start + 1 < m_textLimitOffset_) {
	            targetText.SetIndex(start + 1);
	            schar = targetText.Current();
	        }
	        if (m_collator_.IsUnsafe(echar) || m_collator_.IsUnsafe(schar)) {
	            int expansion = m_colEIter_.m_CEBufferSize_
	                    - m_colEIter_.m_CEBufferOffset_;
	            bool hasExpansion = expansion > 0;
	            m_colEIter_.SetExactOffset(end);
	            while (expansion > 0) {
	                // getting rid of the redundant ce
	                // since forward contraction/expansion may have extra ces
	                // if we are in the normalization buffer, hasAccentsBeforeMatch
	                // would have taken care of it.
	                // E.g. the character \u01FA will have an expansion of 3, but
	                // if we are only looking for A ring A\u030A, we'll have to
	                // skip the last ce in the expansion buffer
	                m_colEIter_.Previous();
	                if (m_colEIter_.GetOffset() != temp) {
	                    end = temp;
	                    temp = m_colEIter_.GetOffset();
	                }
	                expansion--;
	            }
	
	            int count = m_pattern_.m_CELength_;
	            while (count > 0) {
	                int ce = GetCE(m_colEIter_.Previous());
	                // status checked below, note that if status is a failure
	                // previous() returns NULLORDER
	                if (ce == IBM.ICU.Text.CollationElementIterator.IGNORABLE) {
	                    continue;
	                }
	                if (hasExpansion && count == 0
	                        && m_colEIter_.GetOffset() != temp) {
	                    end = temp;
	                    temp = m_colEIter_.GetOffset();
	                }
	                if (count == m_pattern_.m_CELength_
	                        && ce != m_pattern_.m_CE_[m_pattern_.m_CELength_ - 1]) {
	                    // accents may have extra starting ces, this occurs when a
	                    // pure accent pattern is matched without rearrangement
	                    int expected = m_pattern_.m_CE_[m_pattern_.m_CELength_ - 1];
	                    targetText.SetIndex(end);
	                    if (IBM.ICU.Text.UTF16.IsTrailSurrogate(targetText.Previous())) {
	                        if (targetText.GetIndex() > m_textBeginOffset_
	                                && !IBM.ICU.Text.UTF16
	                                        .IsLeadSurrogate(targetText.Previous())) {
	                            targetText.Next();
	                        }
	                    }
	                    end = targetText.GetIndex();
	                    if ((GetFCD(targetText, end) & LAST_BYTE_MASK_) != 0) {
	                        ce = GetCE(m_colEIter_.Previous());
	                        while (ce != expected
	                                && ce != IBM.ICU.Text.CollationElementIterator.NULLORDER
	                                && m_colEIter_.GetOffset() <= start) {
	                            ce = GetCE(m_colEIter_.Previous());
	                        }
	                    }
	                }
	                if (ce != m_pattern_.m_CE_[count - 1]) {
	                    start--;
	                    start = GetPreviousBaseOffset(start);
	                    m_utilBuffer_[0] = start;
	                    m_utilBuffer_[1] = end;
	                    return false;
	                }
	                count--;
	            }
	        }
	        m_utilBuffer_[0] = start;
	        m_utilBuffer_[1] = end;
	        return true;
	    }
	
	    /// <summary>
	    /// Checks and sets the match information if found. Checks
	    /// <ul>
	    /// <li>the potential match does not repeat the previous match
	    /// <li>boundaries are correct
	    /// <li>potential match does not end in the middle of a contraction
	    /// <li>identical matches
	    /// </ul>
	    /// Otherwise the offset will be shifted to the next character. Uses the
	    /// temporary utility buffer for storing the modified textoffset.
	    /// </summary>
	    ///
	    /// <param name="textoffset">offset in the collation element text. the returned value willbe the truncated start offset of the match or the new startsearch offset.</param>
	    /// <returns>true if the match is valid, false otherwise</returns>
	    private bool CheckPreviousCanonicalMatch(int textoffset) {
	        // to ensure that the start and ends are not composite characters
	        // if we have a canonical accent match
	        if (m_pattern_.m_hasSuffixAccents_
	                && m_canonicalSuffixAccents_.Length != 0
	                || m_pattern_.m_hasPrefixAccents_
	                && m_canonicalPrefixAccents_.Length != 0) {
	            m_matchedIndex_ = textoffset;
	            matchLength = GetNextBaseOffset(m_colEIter_.GetOffset())
	                    - textoffset;
	            return true;
	        }
	
	        int end = m_colEIter_.GetOffset();
	        if (!CheckPreviousCanonicalContractionMatch(textoffset, end)) {
	            // storing the modified textoffset
	            return false;
	        }
	        textoffset = m_utilBuffer_[0];
	        end = m_utilBuffer_[1];
	        end = GetNextBaseOffset(end);
	        // this totally matches, however we need to check if it is repeating
	        if (CheckRepeatedMatch(textoffset, end)
	                || !IsBreakUnit(textoffset, end)
	                || !CheckIdentical(textoffset, end)) {
	            textoffset--;
	            textoffset = GetPreviousBaseOffset(textoffset);
	            m_utilBuffer_[0] = textoffset;
	            return false;
	        }
	
	        m_matchedIndex_ = textoffset;
	        matchLength = end - textoffset;
	        return true;
	    }
	
	    /// <summary>
	    /// Method that does the next exact match
	    /// </summary>
	    ///
	    /// <param name="start">the offset to start shifting from and performing the nextexact match</param>
	    private void HandleNextExact(int start) {
	        int textoffset = ShiftForward(start,
	                IBM.ICU.Text.CollationElementIterator.NULLORDER, m_pattern_.m_CELength_);
	        int targetce = IBM.ICU.Text.CollationElementIterator.IGNORABLE;
	        while (textoffset <= m_textLimitOffset_) {
	            m_colEIter_.SetExactOffset(textoffset);
	            int patternceindex = m_pattern_.m_CELength_ - 1;
	            bool found = false;
	            int lastce = IBM.ICU.Text.CollationElementIterator.NULLORDER;
	
	            while (true) {
	                // finding the last pattern ce match, imagine composite
	                // characters. for example: search for pattern A in text \u00C0
	                // we'll have to skip \u0300 the grave first before we get to A
	                targetce = m_colEIter_.Previous();
	                if (targetce == IBM.ICU.Text.CollationElementIterator.NULLORDER) {
	                    found = false;
	                    break;
	                }
	                targetce = GetCE(targetce);
	                if (targetce == IBM.ICU.Text.CollationElementIterator.IGNORABLE
	                        && m_colEIter_.IsInBuffer()) {
	                    // this is for the text \u0315\u0300 that requires
	                    // normalization and pattern \u0300, where \u0315 is
	                    // ignorable
	                    continue;
	                }
	                if (lastce == IBM.ICU.Text.CollationElementIterator.NULLORDER
	                        || lastce == IBM.ICU.Text.CollationElementIterator.IGNORABLE) {
	                    lastce = targetce;
	                }
	                if (targetce == m_pattern_.m_CE_[patternceindex]) {
	                    // the first ce can be a contraction
	                    found = true;
	                    break;
	                }
	                if (m_colEIter_.m_CEBufferOffset_ <= 0) {
	                    found = false;
	                    break;
	                }
	            }
	
	            while (found && patternceindex > 0) {
	                lastce = targetce;
	                targetce = m_colEIter_.Previous();
	                if (targetce == IBM.ICU.Text.CollationElementIterator.NULLORDER) {
	                    found = false;
	                    break;
	                }
	                targetce = GetCE(targetce);
	                if (targetce == IBM.ICU.Text.CollationElementIterator.IGNORABLE) {
	                    continue;
	                }
	
	                patternceindex--;
	                found = found && targetce == m_pattern_.m_CE_[patternceindex];
	            }
	
	            targetce = lastce;
	
	            if (!found) {
	                textoffset = ShiftForward(textoffset, lastce, patternceindex);
	                // status checked at loop.
	                patternceindex = m_pattern_.m_CELength_;
	                continue;
	            }
	
	            if (CheckNextExactMatch(textoffset)) {
	                // status checked in ucol_setOffset
	                return;
	            }
	            textoffset = m_utilBuffer_[0];
	        }
	        SetMatchNotFound();
	    }
	
	    /// <summary>
	    /// Method that does the next canonical match
	    /// </summary>
	    ///
	    /// <param name="start">the offset to start shifting from and performing the nextcanonical match</param>
	    private void HandleNextCanonical(int start) {
	        bool hasPatternAccents = m_pattern_.m_hasSuffixAccents_
	                || m_pattern_.m_hasPrefixAccents_;
	
	        // shifting it check for setting offset
	        // if setOffset is called previously or there was no previous match, we
	        // leave the offset as it is.
	        int textoffset = ShiftForward(start,
	                IBM.ICU.Text.CollationElementIterator.NULLORDER, m_pattern_.m_CELength_);
	        m_canonicalPrefixAccents_.Remove(0,m_canonicalPrefixAccents_.Length-(0));
	        m_canonicalSuffixAccents_.Remove(0,m_canonicalSuffixAccents_.Length-(0));
	        int targetce = IBM.ICU.Text.CollationElementIterator.IGNORABLE;
	
	        while (textoffset <= m_textLimitOffset_) {
	            m_colEIter_.SetExactOffset(textoffset);
	            int patternceindex = m_pattern_.m_CELength_ - 1;
	            bool found = false;
	            int lastce = IBM.ICU.Text.CollationElementIterator.NULLORDER;
	
	            while (true) {
	                // finding the last pattern ce match, imagine composite
	                // characters
	                // for example: search for pattern A in text \u00C0
	                // we'll have to skip \u0300 the grave first before we get to A
	                targetce = m_colEIter_.Previous();
	                if (targetce == IBM.ICU.Text.CollationElementIterator.NULLORDER) {
	                    found = false;
	                    break;
	                }
	                targetce = GetCE(targetce);
	                if (lastce == IBM.ICU.Text.CollationElementIterator.NULLORDER
	                        || lastce == IBM.ICU.Text.CollationElementIterator.IGNORABLE) {
	                    lastce = targetce;
	                }
	                if (targetce == m_pattern_.m_CE_[patternceindex]) {
	                    // the first ce can be a contraction
	                    found = true;
	                    break;
	                }
	                if (m_colEIter_.m_CEBufferOffset_ <= 0) {
	                    found = false;
	                    break;
	                }
	            }
	
	            while (found && patternceindex > 0) {
	                targetce = m_colEIter_.Previous();
	                if (targetce == IBM.ICU.Text.CollationElementIterator.NULLORDER) {
	                    found = false;
	                    break;
	                }
	                targetce = GetCE(targetce);
	                if (targetce == IBM.ICU.Text.CollationElementIterator.IGNORABLE) {
	                    continue;
	                }
	
	                patternceindex--;
	                found = found && targetce == m_pattern_.m_CE_[patternceindex];
	            }
	
	            // initializing the rearranged accent array
	            if (hasPatternAccents && !found) {
	                found = DoNextCanonicalMatch(textoffset);
	            }
	
	            if (!found) {
	                textoffset = ShiftForward(textoffset, lastce, patternceindex);
	                // status checked at loop
	                patternceindex = m_pattern_.m_CELength_;
	                continue;
	            }
	
	            if (CheckNextCanonicalMatch(textoffset)) {
	                return;
	            }
	            textoffset = m_utilBuffer_[0];
	        }
	        SetMatchNotFound();
	    }
	
	    /// <summary>
	    /// Method that does the previous exact match
	    /// </summary>
	    ///
	    /// <param name="start">the offset to start shifting from and performing the previousexact match</param>
	    private void HandlePreviousExact(int start) {
	        int textoffset = ReverseShift(start,
	                IBM.ICU.Text.CollationElementIterator.NULLORDER, m_pattern_.m_CELength_);
	        while (textoffset >= m_textBeginOffset_) {
	            m_colEIter_.SetExactOffset(textoffset);
	            int patternceindex = 1;
	            int targetce = IBM.ICU.Text.CollationElementIterator.IGNORABLE;
	            bool found = false;
	            int firstce = IBM.ICU.Text.CollationElementIterator.NULLORDER;
	
	            while (true) {
	                // finding the first pattern ce match, imagine composite
	                // characters. for example: search for pattern \u0300 in text
	                // \u00C0, we'll have to skip A first before we get to
	                // \u0300 the grave accent
	                targetce = m_colEIter_.Next();
	                if (targetce == IBM.ICU.Text.CollationElementIterator.NULLORDER) {
	                    found = false;
	                    break;
	                }
	                targetce = GetCE(targetce);
	                if (firstce == IBM.ICU.Text.CollationElementIterator.NULLORDER
	                        || firstce == IBM.ICU.Text.CollationElementIterator.IGNORABLE) {
	                    firstce = targetce;
	                }
	                if (targetce == IBM.ICU.Text.CollationElementIterator.IGNORABLE
	                        && m_collator_.GetStrength() != IBM.ICU.Text.Collator.PRIMARY) {
	                    continue;
	                }
	                if (targetce == m_pattern_.m_CE_[0]) {
	                    found = true;
	                    break;
	                }
	                if (m_colEIter_.m_CEBufferOffset_ == -1
	                        || m_colEIter_.m_CEBufferOffset_ == m_colEIter_.m_CEBufferSize_) {
	                    // checking for accents in composite character
	                    found = false;
	                    break;
	                }
	            }
	
	            // targetce = firstce;
	
	            while (found && patternceindex < m_pattern_.m_CELength_) {
	                firstce = targetce;
	                targetce = m_colEIter_.Next();
	                if (targetce == IBM.ICU.Text.CollationElementIterator.NULLORDER) {
	                    found = false;
	                    break;
	                }
	                targetce = GetCE(targetce);
	                if (targetce == IBM.ICU.Text.CollationElementIterator.IGNORABLE) {
	                    continue;
	                }
	
	                found = found && targetce == m_pattern_.m_CE_[patternceindex];
	                patternceindex++;
	            }
	
	            targetce = firstce;
	
	            if (!found) {
	                textoffset = ReverseShift(textoffset, targetce, patternceindex);
	                patternceindex = 0;
	                continue;
	            }
	
	            if (CheckPreviousExactMatch(textoffset)) {
	                return;
	            }
	            textoffset = m_utilBuffer_[0];
	        }
	        SetMatchNotFound();
	    }
	
	    /// <summary>
	    /// Method that does the previous canonical match
	    /// </summary>
	    ///
	    /// <param name="start">the offset to start shifting from and performing the previouscanonical match</param>
	    private void HandlePreviousCanonical(int start) {
	        bool hasPatternAccents = m_pattern_.m_hasSuffixAccents_
	                || m_pattern_.m_hasPrefixAccents_;
	
	        // shifting it check for setting offset
	        // if setOffset is called previously or there was no previous match, we
	        // leave the offset as it is.
	        int textoffset = ReverseShift(start,
	                IBM.ICU.Text.CollationElementIterator.NULLORDER, m_pattern_.m_CELength_);
	        m_canonicalPrefixAccents_.Remove(0,m_canonicalPrefixAccents_.Length-(0));
	        m_canonicalSuffixAccents_.Remove(0,m_canonicalSuffixAccents_.Length-(0));
	
	        while (textoffset >= m_textBeginOffset_) {
	            m_colEIter_.SetExactOffset(textoffset);
	            int patternceindex = 1;
	            int targetce = IBM.ICU.Text.CollationElementIterator.IGNORABLE;
	            bool found = false;
	            int firstce = IBM.ICU.Text.CollationElementIterator.NULLORDER;
	
	            while (true) {
	                // finding the first pattern ce match, imagine composite
	                // characters. for example: search for pattern \u0300 in text
	                // \u00C0, we'll have to skip A first before we get to
	                // \u0300 the grave accent
	                targetce = m_colEIter_.Next();
	                if (targetce == IBM.ICU.Text.CollationElementIterator.NULLORDER) {
	                    found = false;
	                    break;
	                }
	                targetce = GetCE(targetce);
	                if (firstce == IBM.ICU.Text.CollationElementIterator.NULLORDER
	                        || firstce == IBM.ICU.Text.CollationElementIterator.IGNORABLE) {
	                    firstce = targetce;
	                }
	
	                if (targetce == m_pattern_.m_CE_[0]) {
	                    // the first ce can be a contraction
	                    found = true;
	                    break;
	                }
	                if (m_colEIter_.m_CEBufferOffset_ == -1
	                        || m_colEIter_.m_CEBufferOffset_ == m_colEIter_.m_CEBufferSize_) {
	                    // checking for accents in composite character
	                    found = false;
	                    break;
	                }
	            }
	
	            targetce = firstce;
	
	            while (found && patternceindex < m_pattern_.m_CELength_) {
	                targetce = m_colEIter_.Next();
	                if (targetce == IBM.ICU.Text.CollationElementIterator.NULLORDER) {
	                    found = false;
	                    break;
	                }
	                targetce = GetCE(targetce);
	                if (targetce == IBM.ICU.Text.CollationElementIterator.IGNORABLE) {
	                    continue;
	                }
	
	                found = found && targetce == m_pattern_.m_CE_[patternceindex];
	                patternceindex++;
	            }
	
	            // initializing the rearranged accent array
	            if (hasPatternAccents && !found) {
	                found = DoPreviousCanonicalMatch(textoffset);
	            }
	
	            if (!found) {
	                textoffset = ReverseShift(textoffset, targetce, patternceindex);
	                patternceindex = 0;
	                continue;
	            }
	
	            if (CheckPreviousCanonicalMatch(textoffset)) {
	                return;
	            }
	            textoffset = m_utilBuffer_[0];
	        }
	        SetMatchNotFound();
	    }
	
	    /// <summary>
	    /// Gets a substring out of a CharacterIterator
	    /// </summary>
	    ///
	    /// <param name="text">CharacterIterator</param>
	    /// <param name="start">start offset</param>
	    /// <param name="length">of substring</param>
	    /// <returns>substring from text starting at start and length length</returns>
	    private static String GetString(ICharacterIterator text, int start,
	            int length) {
	        StringBuilder result = new StringBuilder(length);
	        int offset = text.GetIndex();
	        text.SetIndex(start);
	        for (int i = 0; i < length; i++) {
	            result.Append(text.Current());
	            text.Next();
	        }
	        text.SetIndex(offset);
	        return result.ToString();
	    }
	
	    /// <summary>
	    /// Getting the mask for collation strength
	    /// </summary>
	    ///
	    /// <param name="strength">collation strength</param>
	    /// <returns>collation element mask</returns>
	    private static int GetMask(int strength) {
	        switch (strength) {
	        case IBM.ICU.Text.Collator.PRIMARY:
	            return IBM.ICU.Text.RuleBasedCollator.CE_PRIMARY_MASK_;
	        case IBM.ICU.Text.Collator.SECONDARY:
	            return IBM.ICU.Text.RuleBasedCollator.CE_SECONDARY_MASK_
	                    | IBM.ICU.Text.RuleBasedCollator.CE_PRIMARY_MASK_;
	        default:
	            return IBM.ICU.Text.RuleBasedCollator.CE_TERTIARY_MASK_
	                    | IBM.ICU.Text.RuleBasedCollator.CE_SECONDARY_MASK_
	                    | IBM.ICU.Text.RuleBasedCollator.CE_PRIMARY_MASK_;
	        }
	    }
	
	    /// <summary>
	    /// Sets match not found
	    /// </summary>
	    ///
	    private void SetMatchNotFound() {
	        // this method resets the match result regardless of the error status.
	        m_matchedIndex_ = IBM.ICU.Text.SearchIterator.DONE;
	        SetMatchLength(0);
	    }
	
	    /// <summary>
	    /// Check the boundaries of the match.
	    /// </summary>
	    ///
	    private int CheckBreakBoundary(int end) {
	        if (!m_charBreakIter_.IsBoundary(end)) {
	            end = m_charBreakIter_.Following(end);
	        }
	        return end;
	    }
	}
}
