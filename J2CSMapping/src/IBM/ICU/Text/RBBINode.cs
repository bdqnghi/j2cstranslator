// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:30 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// COPYRIGHT:
/// Copyright (c) 2001-2007, International Business Machines Corporation and
/// others. All Rights Reserved.
/// </summary>
///
namespace IBM.ICU.Text {
	
	using ILOG.J2CsMapping.Collections;
	using ILOG.J2CsMapping.Collections.Generics;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	
	/// <exclude/>
	/// <summary>
	/// This class represents a node in the parse tree created by the RBBI Rule
	/// compiler.
	/// </summary>
	///
	internal class RBBINode {
	
	    // enum NodeType {
	    internal const int setRef = 0;
	
	    internal const int uset = 1;
	
	    internal const int varRef = 2;
	
	    internal const int leafChar = 3;
	
	    internal const int lookAhead = 4;
	
	    internal const int tag = 5;
	
	    internal const int endMark = 6;
	
	    internal const int opStart = 7;
	
	    internal const int opCat = 8;
	
	    internal const int opOr = 9;
	
	    internal const int opStar = 10;
	
	    internal const int opPlus = 11;
	
	    internal const int opQuestion = 12;
	
	    internal const int opBreak = 13;
	
	    internal const int opReverse = 14;
	
	    internal const int opLParen = 15;
	
	    internal const int nodeTypeLimit = 16; // For Assertion checking only.
	
	    static internal readonly String[] nodeTypeNames = { "setRef", "uset", "varRef",
	            "leafChar", "lookAhead", "tag", "endMark", "opStart", "opCat",
	            "opOr", "opStar", "opPlus", "opQuestion", "opBreak", "opReverse",
	            "opLParen" };
	
	    // enum OpPrecedence {
	    internal const int precZero = 0;
	
	    internal const int precStart = 1;
	
	    internal const int precLParen = 2;
	
	    internal const int precOpOr = 3;
	
	    internal const int precOpCat = 4;
	
	    internal int fType; // enum NodeType
	
	    internal RBBINode fParent;
	
	    internal RBBINode fLeftChild;
	
	    internal RBBINode fRightChild;
	
	    internal UnicodeSet fInputSet; // For uset nodes only.
	
	    internal int fPrecedence; // enum OpPrecedence, For binary ops only.
	
	    internal String fText; // Text corresponding to this node.
	                  // May be lazily evaluated when (if) needed
	                  // for some node types.
	
	    internal int fFirstPos; // Position in the rule source string of the
	                   // first text associated with the node.
	                   // If there's a left child, this will be the same
	                   // as that child's left pos.
	
	    internal int fLastPos; // Last position in the rule source string
	                  // of any text associated with this node.
	                  // If there's a right child, this will be the same
	                  // as that child's last postion.
	
	    internal bool fNullable; // See Aho DFA table generation algorithm
	
	    internal int fVal; // For leafChar nodes, the value.
	              // Values are the character category,
	              // corresponds to columns in the final
	              // state transition table.
	
	    internal bool fLookAheadEnd; // For endMark nodes, set TRUE if
	                           // marking the end of a look-ahead rule.
	
	    internal ILOG.J2CsMapping.Collections.ISet fFirstPosSet; // See Aho DFA table generation algorithm
	
	    internal ILOG.J2CsMapping.Collections.ISet fLastPosSet; // See Aho.
	
	    internal ILOG.J2CsMapping.Collections.ISet fFollowPos; // See Aho.
	
	    internal int fSerialNum; // Debugging aids. Each node gets a unique serial number.
	
	    static internal int gLastSerial;
	
	    internal RBBINode(int t) {
	        this.fPrecedence = precZero;
	        IBM.ICU.Impl.Assert.Assrt(t < nodeTypeLimit);
	        fSerialNum = ++gLastSerial;
	        fType = t;
	
	        fFirstPosSet = new HashedSet();
	        fLastPosSet = new HashedSet();
	        fFollowPos = new HashedSet();
	        if (t == opCat) {
	            fPrecedence = precOpCat;
	        } else if (t == opOr) {
	            fPrecedence = precOpOr;
	        } else if (t == opStart) {
	            fPrecedence = precStart;
	        } else if (t == opLParen) {
	            fPrecedence = precLParen;
	        } else {
	            fPrecedence = precZero;
	        }
	    }
	
	    internal RBBINode(RBBINode other) {
	        this.fPrecedence = precZero;
	        fSerialNum = ++gLastSerial;
	        fType = other.fType;
	        fInputSet = other.fInputSet;
	        fPrecedence = other.fPrecedence;
	        fText = other.fText;
	        fFirstPos = other.fFirstPos;
	        fLastPos = other.fLastPos;
	        fNullable = other.fNullable;
	        fVal = other.fVal;
	        fFirstPosSet = new HashedSet(other.fFirstPosSet);
	        fLastPosSet = new HashedSet(other.fLastPosSet);
	        fFollowPos = new HashedSet(other.fFollowPos);
	    }
	
	    // -------------------------------------------------------------------------
	    //
	    // cloneTree Make a copy of the subtree rooted at this node.
	    // Discard any variable references encountered along the way,
	    // and replace with copies of the variable's definitions.
	    // Used to replicate the expression underneath variable
	    // references in preparation for generating the DFA tables.
	    //
	    // -------------------------------------------------------------------------
	    internal RBBINode CloneTree() {
	        RBBINode n;
	
	        if (fType == RBBINode.varRef) {
	            // If the current node is a variable reference, skip over it
	            // and clone the definition of the variable instead.
	            n = fLeftChild.CloneTree();
	        } else if (fType == RBBINode.uset) {
	            n = this;
	        } else {
	            n = new RBBINode(this);
	            if (fLeftChild != null) {
	                n.fLeftChild = fLeftChild.CloneTree();
	                n.fLeftChild.fParent = n;
	            }
	            if (fRightChild != null) {
	                n.fRightChild = fRightChild.CloneTree();
	                n.fRightChild.fParent = n;
	            }
	        }
	        return n;
	    }
	
	    // -------------------------------------------------------------------------
	    //
	    // flattenVariables Walk a parse tree, replacing any variable
	    // references with a copy of the variable's definition.
	    // Aside from variables, the tree is not changed.
	    //
	    // Return the root of the tree. If the root was not a variable
	    // reference, it remains unchanged - the root we started with
	    // is the root we return. If, however, the root was a variable
	    // reference, the root of the newly cloned replacement tree will
	    // be returned, and the original tree deleted.
	    //
	    // This function works by recursively walking the tree
	    // without doing anything until a variable reference is
	    // found, then calling cloneTree() at that point. Any
	    // nested references are handled by cloneTree(), not here.
	    //
	    // -------------------------------------------------------------------------
	    internal RBBINode FlattenVariables() {
	        if (fType == varRef) {
	            RBBINode retNode = fLeftChild.CloneTree();
	            // delete this;
	            return retNode;
	        }
	
	        if (fLeftChild != null) {
	            fLeftChild = fLeftChild.FlattenVariables();
	            fLeftChild.fParent = this;
	        }
	        if (fRightChild != null) {
	            fRightChild = fRightChild.FlattenVariables();
	            fRightChild.fParent = this;
	        }
	        return this;
	    }
	
	    // -------------------------------------------------------------------------
	    //
	    // flattenSets Walk the parse tree, replacing any nodes of type setRef
	    // with a copy of the expression tree for the set. A set's
	    // equivalent expression tree is precomputed and saved as
	    // the left child of the uset node.
	    //
	    // -------------------------------------------------------------------------
	    internal void FlattenSets() {
	        IBM.ICU.Impl.Assert.Assrt(fType != setRef);
	
	        if (fLeftChild != null) {
	            if (fLeftChild.fType == setRef) {
	                RBBINode setRefNode = fLeftChild;
	                RBBINode usetNode = setRefNode.fLeftChild;
	                RBBINode replTree = usetNode.fLeftChild;
	                fLeftChild = replTree.CloneTree();
	                fLeftChild.fParent = this;
	            } else {
	                fLeftChild.FlattenSets();
	            }
	        }
	
	        if (fRightChild != null) {
	            if (fRightChild.fType == setRef) {
	                RBBINode setRefNode_0 = fRightChild;
	                RBBINode usetNode_1 = setRefNode_0.fLeftChild;
	                RBBINode replTree_2 = usetNode_1.fLeftChild;
	                fRightChild = replTree_2.CloneTree();
	                fRightChild.fParent = this;
	                // delete setRefNode;
	            } else {
	                fRightChild.FlattenSets();
	            }
	        }
	    }
	
	    // -------------------------------------------------------------------------
	    //
	    // findNodes() Locate all the nodes of the specified type, starting
	    // at the specified root.
	    //
	    // -------------------------------------------------------------------------
	    internal void FindNodes(IList dest, int kind) {
	        if (fType == kind) {
	            ILOG.J2CsMapping.Collections.Generics.Collections.Add(dest,this);
	        }
	        if (fLeftChild != null) {
	            fLeftChild.FindNodes(dest, kind);
	        }
	        if (fRightChild != null) {
	            fRightChild.FindNodes(dest, kind);
	        }
	    }
	
	    // -------------------------------------------------------------------------
	    //
	    // print. Print out a single node, for debugging.
	    //
	    // -------------------------------------------------------------------------
	    // /CLOVER:OFF
	    static internal void PrintNode(RBBINode n) {
	
	        if (n == null) {
	            System.Console.Out.Write(" -- null --\n");
	        } else {
	            RBBINode.PrintInt(n.fSerialNum, 10);
	            RBBINode.PrintString(nodeTypeNames[n.fType], 11);
	            RBBINode.PrintInt((n.fParent == null) ? 0 : n.fParent.fSerialNum, 11);
	            RBBINode.PrintInt((n.fLeftChild == null) ? 0
	                    : n.fLeftChild.fSerialNum, 11);
	            RBBINode.PrintInt((n.fRightChild == null) ? 0
	                    : n.fRightChild.fSerialNum, 12);
	            RBBINode.PrintInt(n.fFirstPos, 12);
	            RBBINode.PrintInt(n.fVal, 7);
	
	            if (n.fType == varRef) {
	                System.Console.Out.Write(" " + n.fText);
	            }
	        }
	        System.Console.Out.WriteLine("");
	    }
	
	    // /CLOVER:ON
	
	    // Print a String in a fixed field size.
	    // Debugging function.
	    // /CLOVER:OFF
	    static internal void PrintString(String s, int minWidth) {
	        for (int i = minWidth; i < 0; i++) {
	            // negative width means pad leading spaces, not fixed width.
	            System.Console.Out.Write(' ');
	        }
	        for (int i_0 = s.Length; i_0 < minWidth; i_0++) {
	            System.Console.Out.Write(' ');
	        }
	        System.Console.Out.Write(s);
	    }
	
	    // /CLOVER:ON
	
	    //
	    // Print an int in a fixed size field.
	    // Debugging function.
	    //
	    // /CLOVER:OFF
	    static internal void PrintInt(int i, int minWidth) {
	        String s = ILOG.J2CsMapping.Util.IlNumber.ToString(i);
	        PrintString(s, Math.Max(minWidth,s.Length + 1));
	    }
	
	    // /CLOVER:ON
	
	    // /CLOVER:OFF
	    static internal void PrintHex(int i, int minWidth) {
	        String s = ILOG.J2CsMapping.Util.IlNumber.ToString(i,16);
	        String leadingZeroes = "00000".Substring(0,(Math.Max(0,5 - s.Length))-(0));
	        s = leadingZeroes + s;
	        PrintString(s, minWidth);
	    }
	
	    // /CLOVER:ON
	
	    // -------------------------------------------------------------------------
	    //
	    // print. Print out the tree of nodes rooted at "this"
	    //
	    // -------------------------------------------------------------------------
	    // /CLOVER:OFF
	    internal void PrintTree(bool printHeading) {
	        if (printHeading) {
	            System.Console.Out
	                    .WriteLine("-------------------------------------------------------------------");
	            System.Console.Out
	                    .WriteLine("    Serial       type     Parent  LeftChild  RightChild    position  value");
	        }
	        PrintNode(this);
	        // Only dump the definition under a variable reference if asked to.
	        // Unconditinally dump children of all other node types.
	        if (fType != varRef) {
	            if (fLeftChild != null) {
	                fLeftChild.PrintTree(false);
	            }
	
	            if (fRightChild != null) {
	                fRightChild.PrintTree(false);
	            }
	        }
	    }
	    // /CLOVER:ON
	
	}
}
