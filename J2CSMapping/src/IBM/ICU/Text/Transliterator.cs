/*
 *******************************************************************************
 * Copyright (C) 1996-2007, International Business Machines Corporation and    *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 */
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:30 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Text {
	
	using IBM.ICU.Impl;
	using IBM.ICU.Util;
	using ILOG.J2CsMapping.Collections;
	using ILOG.J2CsMapping.Collections.Generics;
	using ILOG.J2CsMapping.Text;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.Globalization;
	using System.IO;
	using System.Resources;
	using System.Runtime.CompilerServices;
	using System.Text;
     using ILOG.J2CsMapping.Util;
	
	/// <summary>
	/// <c>Transliterator</c> is an abstract class that transliterates text
	/// from one format to another. The most common kind of transliterator is a
	/// script, or alphabet, transliterator. For example, a Russian to Latin
	/// transliterator changes Russian text written in Cyrillic characters to
	/// phonetically equivalent Latin characters. It does not <em>translate</em>
	/// Russian to English! Transliteration, unlike translation, operates on
	/// characters, without reference to the meanings of words and sentences.
	/// <p>
	/// Although script conversion is its most common use, a transliterator can
	/// actually perform a more general class of tasks. In fact,
	/// <c>Transliterator</c> defines a very general API which specifies only
	/// that a segment of the input text is replaced by new text. The particulars of
	/// this conversion are determined entirely by subclasses of
	/// <c>Transliterator</c>.
	/// <p>
	/// <b>Transliterators are stateless</b>
	/// <p>
	/// <c>Transliterator</c> objects are <em>stateless</em>; they retain no
	/// information between calls to <c>transliterate()</c>. As a result,
	/// threads may share transliterators without synchronizing them. This might seem
	/// to limit the complexity of the transliteration operation. In practice,
	/// subclasses perform complex transliterations by delaying the replacement of
	/// text until it is known that no other replacements are possible. In other
	/// words, although the <c>Transliterator</c> objects are stateless, the
	/// source text itself embodies all the needed information, and delayed operation
	/// allows arbitrary complexity.
	/// <p>
	/// <b>Batch transliteration</b>
	/// <p>
	/// The simplest way to perform transliteration is all at once, on a string of
	/// existing text. This is referred to as <em>batch</em> transliteration. For
	/// example, given a string <c>input</c> and a transliterator
	/// <c>t</c>, the call
	/// <blockquote><code>String result = t.transliterate(input);
	/// </code></blockquote>
	/// will transliterate it and return the result. Other methods allow the client
	/// to specify a substring to be transliterated and to use <see cref="T:IBM.ICU.Text.Replaceable"/>objects instead of strings, in order to preserve out-of-band information
	/// (such as text styles).
	/// <p>
	/// <b>Keyboard transliteration</b>
	/// <p>
	/// Somewhat more involved is <em>keyboard</em>, or incremental transliteration.
	/// This is the transliteration of text that is arriving from some source
	/// (typically the user's keyboard) one character at a time, or in some other
	/// piecemeal fashion.
	/// <p>
	/// In keyboard transliteration, a <c>Replaceable</c> buffer stores the
	/// text. As text is inserted, as much as possible is transliterated on the fly.
	/// This means a GUI that displays the contents of the buffer may show text being
	/// modified as each new character arrives.
	/// <p>
	/// Consider the simple <c>RuleBasedTransliterator</c>:
	/// <blockquote><code>
	/// th&gt;{theta}<br>
	/// t&gt;{tau}
	/// </code></blockquote>
	/// When the user types 't', nothing will happen, since the transliterator is
	/// waiting to see if the next character is 'h'. To remedy this, we introduce the
	/// notion of a cursor, marked by a '|' in the output string:
	/// <blockquote><code>
	/// t&gt;|{tau}<br>
	/// {tau}h&gt;{theta}
	/// </code></blockquote>
	/// Now when the user types 't', tau appears, and if the next character is 'h',
	/// the tau changes to a theta. This is accomplished by maintaining a cursor
	/// position (independent of the insertion point, and invisible in the GUI)
	/// across calls to <c>transliterate()</c>. Typically, the cursor will be
	/// coincident with the insertion point, but in a case like the one above, it
	/// will precede the insertion point.
	/// <p>
	/// Keyboard transliteration methods maintain a set of three indices that are
	/// updated with each call to <c>transliterate()</c>, including the cursor,
	/// start, and limit. These indices are changed by the method, and they are
	/// passed in and out via a Position object. The <c>start</c> index marks
	/// the beginning of the substring that the transliterator will look at. It is
	/// advanced as text becomes committed (but it is not the committed index; that's
	/// the <c>cursor</c>). The <c>cursor</c> index, described above,
	/// marks the point at which the transliterator last stopped, either because it
	/// reached the end, or because it required more characters to disambiguate
	/// between possible inputs. The <c>cursor</c> can also be explicitly set
	/// by rules in a <c>RuleBasedTransliterator</c>. Any characters before the
	/// <c>cursor</c> index are frozen; future keyboard transliteration calls
	/// within this input sequence will not change them. New text is inserted at the
	/// <c>limit</c> index, which marks the end of the substring that the
	/// transliterator looks at.
	/// <p>
	/// Because keyboard transliteration assumes that more characters are to arrive,
	/// it is conservative in its operation. It only transliterates when it can do so
	/// unambiguously. Otherwise it waits for more characters to arrive. When the
	/// client code knows that no more characters are forthcoming, perhaps because
	/// the user has performed some input termination operation, then it should call
	/// <c>finishTransliteration()</c> to complete any pending
	/// transliterations.
	/// <p>
	/// <b>Inverses</b>
	/// <p>
	/// Pairs of transliterators may be inverses of one another. For example, if
	/// transliterator <b>A</b> transliterates characters by incrementing their
	/// Unicode value (so "abc" -> "def"), and transliterator <b>B</b> decrements
	/// character values, then <b>A</b> is an inverse of <b>B</b> and vice versa. If
	/// we compose <b>A</b> with <b>B</b> in a compound transliterator, the result is
	/// the indentity transliterator, that is, a transliterator that does not change
	/// its input text.
	/// The <c>Transliterator</c> method <c>getInverse()</c> returns a
	/// transliterator's inverse, if one exists, or <c>null</c> otherwise.
	/// However, the result of <c>getInverse()</c> usually will <em>not</em> be
	/// a true mathematical inverse. This is because true inverse transliterators are
	/// difficult to formulate. For example, consider two transliterators: <b>AB</b>,
	/// which transliterates the character 'A' to 'B', and <b>BA</b>, which
	/// transliterates 'B' to 'A'. It might seem that these are exact inverses, since
	/// <blockquote>"A" x <b>AB</b> -> "B"<br>
	/// "B" x <b>BA</b> -> "A"</blockquote>
	/// where 'x' represents transliteration. However,
	/// <blockquote>"ABCD" x <b>AB</b> -> "BBCD"<br>
	/// "BBCD" x <b>BA</b> -> "AACD"</blockquote>
	/// so <b>AB</b> composed with <b>BA</b> is not the identity. Nonetheless,
	/// <b>BA</b> may be usefully considered to be <b>AB</b>'s inverse, and it is on
	/// this basis that <b>AB</b><c>.getInverse()</c> could legitimately return
	/// <b>BA</b>.
	/// <p>
	/// <b>IDs and display names</b>
	/// <p>
	/// A transliterator is designated by a short identifier string or <em>ID</em>.
	/// IDs follow the format <em>source-destination</em>, where <em>source</em>
	/// describes the entity being replaced, and <em>destination</em> describes the
	/// entity replacing <em>source</em>. The entities may be the names of scripts,
	/// particular sequences of characters, or whatever else it is that the
	/// transliterator converts to or from. For example, a transliterator from
	/// Russian to Latin might be named "Russian-Latin". A transliterator from
	/// keyboard escape sequences to Latin-1 characters might be named
	/// "KeyboardEscape-Latin1". By convention, system entity names are in English,
	/// with the initial letters of words capitalized; user entity names may follow
	/// any format so long as they do not contain dashes.
	/// <p>
	/// In addition to programmatic IDs, transliterator objects have display names
	/// for presentation in user interfaces, returned by <see cref="M:IBM.ICU.Text.Transliterator.GetDisplayName(System.String)"/>.
	/// <p>
	/// <b>Factory methods and registration</b>
	/// <p>
	/// In general, client code should use the factory method
	/// <c>getInstance()</c> to obtain an instance of a transliterator given
	/// its ID. Valid IDs may be enumerated using <c>getAvailableIDs()</c>.
	/// Since transliterators are stateless, multiple calls to
	/// <c>getInstance()</c> with the same ID will return the same object.
	/// <p>
	/// In addition to the system transliterators registered at startup, user
	/// transliterators may be registered by calling <c>registerInstance()</c>
	/// at run time. To register a transliterator subclass without instantiating it
	/// (until it is needed), users may call <c>registerClass()</c>.
	/// <p>
	/// <b>Composed transliterators</b>
	/// <p>
	/// In addition to built-in system transliterators like "Latin-Greek", there are
	/// also built-in <em>composed</em> transliterators. These are implemented by
	/// composing two or more component transliterators. For example, if we have
	/// scripts "A", "B", "C", and "D", and we want to transliterate between all
	/// pairs of them, then we need to write 12 transliterators: "A-B", "A-C", "A-D",
	/// "B-A",..., "D-A", "D-B", "D-C". If it is possible to convert all scripts to
	/// an intermediate script "M", then instead of writing 12 rule sets, we only
	/// need to write 8: "A~M", "B~M", "C~M", "D~M", "M~A", "M~B", "M~C", "M~D".
	/// (This might not seem like a big win, but it's really 2<em>n</em> vs.
	/// <em>n</em><sup>2</sup> - <em>n</em>, so as <em>n</em> gets larger the gain
	/// becomes significant. With 9 scripts, it's 18 vs. 72 rule sets, a big
	/// difference.) Note the use of "~" rather than "-" for the script separator
	/// here; this indicates that the given transliterator is intended to be composed
	/// with others, rather than be used as is.
	/// <p>
	/// Composed transliterators can be instantiated as usual. For example, the
	/// system transliterator "Devanagari-Gujarati" is a composed transliterator
	/// built internally as "Devanagari~InterIndic;InterIndic~Gujarati". When this
	/// transliterator is instantiated, it appears externally to be a standard
	/// transliterator (e.g., getID() returns "Devanagari-Gujarati").
	/// <p>
	/// <b>Subclassing</b>
	/// <p>
	/// Subclasses must implement the abstract method
	/// <c>handleTransliterate()</c>.
	/// <p>
	/// Subclasses should override the <c>transliterate()</c> method taking a
	/// <c>Replaceable</c> and the <c>transliterate()</c> method taking a
	/// <c>String</c> and <c>StringBuffer</c> if the performance of these
	/// methods can be improved over the performance obtained by the default
	/// implementations in this class.
	/// <p>
	/// Copyright &copy; IBM Corporation 1999. All rights reserved.
	/// </summary>
	///
	/// @stable ICU 2.0
	public abstract class Transliterator : StringTransform {
	    /// <summary>
	    /// Direction constant indicating the forward direction in a transliterator,
	    /// e.g., the forward rules of a RuleBasedTransliterator. An "A-B"
	    /// transliterator transliterates A to B when operating in the forward
	    /// direction, and B to A when operating in the reverse direction.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public const int FORWARD = 0;
	
	    /// <summary>
	    /// Direction constant indicating the reverse direction in a transliterator,
	    /// e.g., the reverse rules of a RuleBasedTransliterator. An "A-B"
	    /// transliterator transliterates A to B when operating in the forward
	    /// direction, and B to A when operating in the reverse direction.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public const int REVERSE = 1;
	
	    /// <summary>
	    /// Position structure for incremental transliteration. This data structure
	    /// defines two substrings of the text being transliterated. The first
	    /// region, [contextStart, contextLimit), defines what characters the
	    /// transliterator will read as context. The second region, [start, limit),
	    /// defines what characters will actually be transliterated. The second
	    /// region should be a subset of the first.
	    /// <p>
	    /// After a transliteration operation, some of the indices in this structure
	    /// will be modified. See the field descriptions for details.
	    /// <p>
	    /// contextStart <= start <= limit <= contextLimit
	    /// <p>
	    /// Note: All index values in this structure must be at code point
	    /// boundaries. That is, none of them may occur between two code units of a
	    /// surrogate pair. If any index does split a surrogate pair, results are
	    /// unspecified.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public class Position {
	
	        /// <summary>
	        /// Beginning index, inclusive, of the context to be considered for a
	        /// transliteration operation. The transliterator will ignore anything
	        /// before this index. INPUT/OUTPUT parameter: This parameter is updated
	        /// by a transliteration operation to reflect the maximum amount of
	        /// antecontext needed by a transliterator.
	        /// </summary>
	        ///
	        /// @stable ICU 2.0
	        public int contextStart;
	
	        /// <summary>
	        /// Ending index, exclusive, of the context to be considered for a
	        /// transliteration operation. The transliterator will ignore anything at
	        /// or after this index. INPUT/OUTPUT parameter: This parameter is
	        /// updated to reflect changes in the length of the text, but points to
	        /// the same logical position in the text.
	        /// </summary>
	        ///
	        /// @stable ICU 2.0
	        public int contextLimit;
	
	        /// <summary>
	        /// Beginning index, inclusive, of the text to be transliteratd.
	        /// INPUT/OUTPUT parameter: This parameter is advanced past characters
	        /// that have already been transliterated by a transliteration operation.
	        /// </summary>
	        ///
	        /// @stable ICU 2.0
	        public int start;
	
	        /// <summary>
	        /// Ending index, exclusive, of the text to be transliteratd.
	        /// INPUT/OUTPUT parameter: This parameter is updated to reflect changes
	        /// in the length of the text, but points to the same logical position in
	        /// the text.
	        /// </summary>
	        ///
	        /// @stable ICU 2.0
	        public int limit;
	
	        /// <summary>
	        /// Constructs a Position object with start, limit, contextStart, and
	        /// contextLimit all equal to zero.
	        /// </summary>
	        ///
	        /// @stable ICU 2.0
	        public Position() : this(0, 0, 0, 0) {
	        }
	
	        /// <summary>
	        /// Constructs a Position object with the given start, contextStart, and
	        /// contextLimit. The limit is set to the contextLimit.
	        /// </summary>
	        ///
	        /// @stable ICU 2.0
	        public Position(int contextStart_0, int contextLimit_1, int start_2) : this(contextStart_0, contextLimit_1, start_2, contextLimit_1) {
	        }
	
	        /// <summary>
	        /// Constructs a Position object with the given start, limit,
	        /// contextStart, and contextLimit.
	        /// </summary>
	        ///
	        /// @stable ICU 2.0
	        public Position(int contextStart_0, int contextLimit_1, int start_2, int limit_3) {
	            this.contextStart = contextStart_0;
	            this.contextLimit = contextLimit_1;
	            this.start = start_2;
	            this.limit = limit_3;
	        }
	
	        /// <summary>
	        /// Constructs a Position object that is a copy of another.
	        /// </summary>
	        ///
	        /// @stable ICU 2.6
	        public Position(Transliterator.Position  pos) {
	            Set(pos);
	        }
	
	        /// <summary>
	        /// Copies the indices of this position from another.
	        /// </summary>
	        ///
	        /// @stable ICU 2.6
	        public void Set(Transliterator.Position  pos) {
	            contextStart = pos.contextStart;
	            contextLimit = pos.contextLimit;
	            start = pos.start;
	            limit = pos.limit;
	        }
	
	        /// <summary>
	        /// Returns true if this Position is equal to the given object.
	        /// </summary>
	        ///
	        /// @stable ICU 2.6
	        public override bool Equals(Object obj) {
	            if (obj  is  Transliterator.Position ) {
	                Transliterator.Position  pos = (Transliterator.Position ) obj;
	                return contextStart == pos.contextStart
	                        && contextLimit == pos.contextLimit
	                        && start == pos.start && limit == pos.limit;
	            }
	            return false;
	        }
	
	        /// <summary>
	        /// Returns a string representation of this Position.
	        /// </summary>
	        ///
	        /// @stable ICU 2.6
	        public override String ToString() {
	            return "[cs=" + contextStart + ", s=" + start + ", l=" + limit
	                    + ", cl=" + contextLimit + "]";
	        }
	
	        /// <summary>
	        /// Check all bounds. If they are invalid, throw an exception.
	        /// </summary>
	        ///
	        /// <param name="length">the length of the string this object applies to</param>
	        /// <exception cref="IllegalArgumentException">if any indices are out of bounds</exception>
	        /// @stable ICU 2.0
	        public void Validate(int length) {
	            if (contextStart < 0 || start < contextStart || limit < start
	                    || contextLimit < limit || length < contextLimit) {
	                throw new ArgumentException("Invalid Position {cs="
	                        + contextStart + ", s=" + start + ", l=" + limit
	                        + ", cl=" + contextLimit + "}, len=" + length);
	            }
	        }
	    }
	
	    /// <summary>
	    /// Programmatic name, e.g., "Latin-Arabic".
	    /// </summary>
	    ///
	    private String ID;
	
	    /// <summary>
	    /// This transliterator's filter. Any character for which
	    /// <tt>filter.contains()</tt> returns <tt>false</tt> will not be altered by
	    /// this transliterator. If <tt>filter</tt> is <tt>null</tt> then no
	    /// filtering is applied.
	    /// </summary>
	    ///
	    private UnicodeFilter filter;
	
	    private int maximumContextLength;
	
	    /// <summary>
	    /// System transliterator registry.
	    /// </summary>
	    ///
	    private static TransliteratorRegistry registry;
	
	    private static Hashtable displayNameCache;
	
	    /// <summary>
	    /// Prefix for resource bundle key for the display name for a transliterator.
	    /// The ID is appended to this to form the key. The resource bundle value
	    /// should be a String.
	    /// </summary>
	    ///
	    private const String RB_DISPLAY_NAME_PREFIX = "%Translit%%";
	
	    /// <summary>
	    /// Prefix for resource bundle key for the display name for a transliterator
	    /// SCRIPT. The ID is appended to this to form the key. The resource bundle
	    /// value should be a String.
	    /// </summary>
	    ///
	    private const String RB_SCRIPT_DISPLAY_NAME_PREFIX = "%Translit%";
	
	    /// <summary>
	    /// Resource bundle key for display name pattern. The resource bundle value
	    /// should be a String forming a MessageFormat pattern, e.g.:
	    /// "{0,choice,0#|1#{1} Transliterator|2#{1} to {2} Transliterator}".
	    /// </summary>
	    ///
	    private const String RB_DISPLAY_NAME_PATTERN = "TransliteratorNamePattern";
	
	    /// <exclude/>
	    /// <summary>
	    /// Delimiter between elements in a compound ID.
	    /// </summary>
	    ///
	    internal const char ID_DELIM = ';';
	
	    /// <exclude/>
	    /// <summary>
	    /// Delimiter before target in an ID.
	    /// </summary>
	    ///
	    internal const char ID_SEP = '-';
	
	    /// <exclude/>
	    /// <summary>
	    /// Delimiter before variant in an ID.
	    /// </summary>
	    ///
	    internal const char VARIANT_SEP = '/';
	
	    /// <summary>
	    /// To enable debugging output in the Transliterator component, set DEBUG to
	    /// true.
	    /// N.B. Make sure to recompile all of the com.ibm.icu.text package after
	    /// changing this. Easiest way to do this is 'ant clean core' ('ant' will NOT
	    /// pick up the dependency automatically).
	    /// <<This generates a lot of output.>>
	    /// </summary>
	    ///
	    internal const bool DEBUG = false;
	
	    /// <summary>
	    /// Default constructor.
	    /// </summary>
	    ///
	    /// <param name="ID_0">the string identifier for this transliterator</param>
	    /// <param name="filter_1">the filter. Any character for which <tt>filter.contains()</tt>returns <tt>false</tt> will not be altered by thistransliterator. If <tt>filter</tt> is <tt>null</tt> then nofiltering is applied.</param>
	    /// @stable ICU 2.0
	    protected internal Transliterator(String ID_0, UnicodeFilter filter_1) {
	        this.maximumContextLength = 0;
	        if (ID_0 == null) {
	            throw new NullReferenceException();
	        }
	        this.ID = ID_0;
	        this.filter = filter_1;
	    }
	
	    /// <summary>
	    /// Transliterates a segment of a string, with optional filtering.
	    /// </summary>
	    ///
	    /// <param name="text">the string to be transliterated</param>
	    /// <param name="start_0">the beginning index, inclusive; <code>0 <= start<= limit</code>.</param>
	    /// <param name="limit_1">the ending index, exclusive; <code>start <= limit<= text.length()</code>.</param>
	    /// <returns>The new limit index. The text previously occupying <code>[start,
	    /// limit)</code> has been transliterated, possibly to a string of a
	    /// different length, at <c>[start,</c><em>new-limit</em>
	    /// <c>)</c>, where <em>new-limit</em> is the return value. If
	    /// the input offsets are out of bounds, the returned value is -1 and
	    /// the input string remains unchanged.</returns>
	    /// @stable ICU 2.0
	    public int Transliterate(Replaceable text, int start_0, int limit_1) {
	        if (start_0 < 0 || limit_1 < start_0 || text.Length() < limit_1) {
	            return -1;
	        }
	
	        Transliterator.Position  pos = new Transliterator.Position (start_0, limit_1, start_0);
	        FilteredTransliterate(text, pos, false, true);
	        return pos.limit;
	    }
	
	    /// <summary>
	    /// Transliterates an entire string in place. Convenience method.
	    /// </summary>
	    ///
	    /// <param name="text">the string to be transliterated</param>
	    /// @stable ICU 2.0
	    public void Transliterate(Replaceable text) {
	        Transliterate(text, 0, text.Length());
	    }
	
	    /// <summary>
	    /// Transliterate an entire string and returns the result. Convenience
	    /// method.
	    /// </summary>
	    ///
	    /// <param name="text">the string to be transliterated</param>
	    /// <returns>The transliterated text</returns>
	    /// @stable ICU 2.0
	    public String Transliterate(String text) {
	        ReplaceableString result = new ReplaceableString(text);
	        Transliterate(result);
	        return result.ToString();
	    }
	
	    /// <summary>
	    /// Transliterates the portion of the text buffer that can be transliterated
	    /// unambiguosly after new text has been inserted, typically as a result of a
	    /// keyboard event. The new text in <c>insertion</c> will be inserted
	    /// into <c>text</c> at <c>index.contextLimit</c>, advancing
	    /// <c>index.contextLimit</c> by <c>insertion.length()</c>. Then
	    /// the transliterator will try to transliterate characters of
	    /// <c>text</c> between <c>index.start</c> and
	    /// <c>index.contextLimit</c>. Characters before
	    /// <c>index.start</c> will not be changed.
	    /// <p>
	    /// Upon return, values in <c>index</c> will be updated.
	    /// <c>index.contextStart</c> will be advanced to the first character
	    /// that future calls to this method will read. <c>index.start</c> and
	    /// <c>index.contextLimit</c> will be adjusted to delimit the range of
	    /// text that future calls to this method may change.
	    /// <p>
	    /// Typical usage of this method begins with an initial call with
	    /// <c>index.contextStart</c> and <c>index.contextLimit</c> set
	    /// to indicate the portion of <c>text</c> to be transliterated, and
	    /// <c>index.start == index.contextStart</c>. Thereafter,
	    /// <c>index</c> can be used without modification in future calls,
	    /// provided that all changes to <c>text</c> are made via this method.
	    /// <p>
	    /// This method assumes that future calls may be made that will insert new
	    /// text into the buffer. As a result, it only performs unambiguous
	    /// transliterations. After the last call to this method, there may be
	    /// untransliterated text that is waiting for more input to resolve an
	    /// ambiguity. In order to perform these pending transliterations, clients
	    /// should call <see cref="M:IBM.ICU.Text.Transliterator.FinishTransliteration(IBM.ICU.Text.Replaceable, null)"/> after the last call to this
	    /// method has been made.
	    /// </summary>
	    ///
	    /// <param name="text">the buffer holding transliterated and untransliterated text</param>
	    /// <param name="index">the start and limit of the text, the position of the cursor,and the start and limit of transliteration.</param>
	    /// <param name="insertion">text to be inserted and possibly transliterated into thetranslation buffer at <c>index.contextLimit</c>. If<c>null</c> then no text is inserted.</param>
	    /// <seealso cref="M:IBM.ICU.Text.Transliterator.HandleTransliterate(IBM.ICU.Text.Replaceable, null, System.Boolean)"/>
	    /// <exception cref="IllegalArgumentException">if <c>index</c> is invalid</exception>
	    /// @stable ICU 2.0
	    public void Transliterate(Replaceable text, Transliterator.Position  index,
	            String insertion) {
	        index.Validate(text.Length());
	
	        // int originalStart = index.contextStart;
	        if (insertion != null) {
	            text.Replace(index.limit, index.limit, insertion);
	            index.limit += insertion.Length;
	            index.contextLimit += insertion.Length;
	        }
	
	        if (index.limit > 0
	                && IBM.ICU.Text.UTF16.IsLeadSurrogate(text.CharAt(index.limit - 1))) {
	            // Oops, there is a dangling lead surrogate in the buffer.
	            // This will break most transliterators, since they will
	            // assume it is part of a pair. Don't transliterate until
	            // more text comes in.
	            return;
	        }
	
	        FilteredTransliterate(text, index, true, true);
	
	        // TODO
	        // This doesn't work once we add quantifier support. Need to rewrite
	        // this code to support quantifiers and 'use maximum backup <n>;'.
	        //
	        // index.contextStart = Math.max(index.start -
	        // getMaximumContextLength(),
	        // originalStart);
	    }
	
	    /// <summary>
	    /// Transliterates the portion of the text buffer that can be transliterated
	    /// unambiguosly after a new character has been inserted, typically as a
	    /// result of a keyboard event. This is a convenience method; see<see cref="M:IBM.ICU.Text.Transliterator.Transliterate(IBM.ICU.Text.Replaceable, IBM.ICU.Text.Position, System.String)"/> for
	    /// details.
	    /// </summary>
	    ///
	    /// <param name="text">the buffer holding transliterated and untransliterated text</param>
	    /// <param name="index">the start and limit of the text, the position of the cursor,and the start and limit of transliteration.</param>
	    /// <param name="insertion">text to be inserted and possibly transliterated into thetranslation buffer at <c>index.contextLimit</c>.</param>
	    /// <seealso cref="M:IBM.ICU.Text.Transliterator.Transliterate(IBM.ICU.Text.Replaceable, IBM.ICU.Text.Position, System.String)"/>
	    /// @stable ICU 2.0
	    public void Transliterate(Replaceable text, Transliterator.Position  index,
	            int insertion) {
	        Transliterate(text, index, IBM.ICU.Text.UTF16.ValueOf(insertion));
	    }
	
	    /// <summary>
	    /// Transliterates the portion of the text buffer that can be transliterated
	    /// unambiguosly. This is a convenience method; see<see cref="M:IBM.ICU.Text.Transliterator.Transliterate(IBM.ICU.Text.Replaceable, IBM.ICU.Text.Position, System.String)"/> for
	    /// details.
	    /// </summary>
	    ///
	    /// <param name="text">the buffer holding transliterated and untransliterated text</param>
	    /// <param name="index">the start and limit of the text, the position of the cursor,and the start and limit of transliteration.</param>
	    /// <seealso cref="M:IBM.ICU.Text.Transliterator.Transliterate(IBM.ICU.Text.Replaceable, IBM.ICU.Text.Position, System.String)"/>
	    /// @stable ICU 2.0
	    public void Transliterate(Replaceable text, Transliterator.Position  index) {
	        Transliterate(text, index, null);
	    }
	
	    /// <summary>
	    /// Finishes any pending transliterations that were waiting for more
	    /// characters. Clients should call this method as the last call after a
	    /// sequence of one or more calls to <c>transliterate()</c>.
	    /// </summary>
	    ///
	    /// <param name="text">the buffer holding transliterated and untransliterated text.</param>
	    /// <param name="index">the array of indices previously passed to<see cref="M:IBM.ICU.Text.Transliterator.Transliterate(IBM.ICU.Text.Replaceable, System.Int32, System.Int32)"/></param>
	    /// @stable ICU 2.0
	    public void FinishTransliteration(Replaceable text, Transliterator.Position  index) {
	        index.Validate(text.Length());
	        FilteredTransliterate(text, index, false, true);
	    }
	
	    /// <summary>
	    /// Abstract method that concrete subclasses define to implement their
	    /// transliteration algorithm. This method handles both incremental and
	    /// non-incremental transliteration. Let <c>originalStart</c> refer to
	    /// the value of <c>pos.start</c> upon entry.
	    /// <ul>
	    /// <li>If <c>incremental</c> is false, then this method should
	    /// transliterate all characters between <c>pos.start</c> and
	    /// <c>pos.limit</c>. Upon return <c>pos.start</c> must ==
	    /// <c>pos.limit</c>.</li>
	    /// <li>If <c>incremental</c> is true, then this method should
	    /// transliterate all characters between <c>pos.start</c> and
	    /// <c>pos.limit</c> that can be unambiguously transliterated,
	    /// regardless of future insertions of text at <c>pos.limit</c>. Upon
	    /// return, <c>pos.start</c> should be in the range [
	    /// <c>originalStart</c>, <c>pos.limit</c>).
	    /// <c>pos.start</c> should be positioned such that characters [
	    /// <c>originalStart</c>, <code>
	    /// pos.start</code>) will not be changed in the future by this
	    /// transliterator and characters [<c>pos.start</c>,
	    /// <c>pos.limit</c>) are unchanged.</li>
	    /// </ul>
	    /// <p>
	    /// Implementations of this method should also obey the following invariants:
	    /// </p>
	    /// <ul>
	    /// <li> <c>pos.limit</c> and <c>pos.contextLimit</c> should be
	    /// updated to reflect changes in length of the text between
	    /// <c>pos.start</c> and <c>pos.limit</c>. The difference
	    /// <c>pos.contextLimit - pos.limit</c> should not change.</li>
	    /// <li><c>pos.contextStart</c> should not change.</li>
	    /// <li>Upon return, neither <c>pos.start</c> nor
	    /// <c>pos.limit</c> should be less than <c>originalStart</c>.</li>
	    /// <li>Text before <c>originalStart</c> and text after
	    /// <c>pos.limit</c> should not change.</li>
	    /// <li>Text before <c>pos.contextStart</c> and text after
	    /// <c>pos.contextLimit</c> should be ignored.</li>
	    /// </ul>
	    /// <p>
	    /// Subclasses may safely assume that all characters in [
	    /// <c>pos.start</c>, <c>pos.limit</c>) are filtered. In other
	    /// words, the filter has already been applied by the time this method is
	    /// called. See <c>filteredTransliterate()</c>.
	    /// <p>
	    /// This method is <b>not</b> for public consumption. Calling this method
	    /// directly will transliterate [<c>pos.start</c>,
	    /// <c>pos.limit</c>) without applying the filter. End user code should
	    /// call <code>
	    /// transliterate()</code> instead of this method. Subclass code should call
	    /// <c>filteredTransliterate()</c> instead of this method.
	    /// <p>
	    /// </summary>
	    ///
	    /// <param name="text">the buffer holding transliterated and untransliterated text</param>
	    /// <param name="pos">the indices indicating the start, limit, context start, andcontext limit of the text.</param>
	    /// <param name="incremental">if true, assume more text may be inserted at<c>pos.limit</c> and act accordingly. Otherwise,transliterate all text between <c>pos.start</c> and<c>pos.limit</c> and move <c>pos.start</c> up to<c>pos.limit</c>.</param>
	    /// <seealso cref="M:IBM.ICU.Text.Transliterator.Transliterate(IBM.ICU.Text.Replaceable, System.Int32, System.Int32)"/>
	    /// @stable ICU 2.0
	    protected abstract internal void HandleTransliterate(Replaceable text, Transliterator.Position  pos,
	            bool incremental);
	
	    /// <summary>
	    /// Top-level transliteration method, handling filtering, incremental and
	    /// non-incremental transliteration, and rollback. All transliteration public
	    /// API methods eventually call this method with a rollback argument of TRUE.
	    /// Other entities may call this method but rollback should be FALSE.
	    /// <p>
	    /// If this transliterator has a filter, break up the input text into runs of
	    /// unfiltered characters. Pass each run to <subclass>.handleTransliterate().
	    /// <p>
	    /// In incremental mode, if rollback is TRUE, perform a special incremental
	    /// procedure in which several passes are made over the input text, adding
	    /// one character at a time, and committing successful transliterations as
	    /// they occur. Unsuccessful transliterations are rolled back and retried
	    /// with additional characters to give correct results.
	    /// </summary>
	    ///
	    /// <param name="text">the text to be transliterated</param>
	    /// <param name="index">the position indices</param>
	    /// <param name="incremental">if TRUE, then assume more characters may be inserted atindex.limit, and postpone processing to accomodate futureincoming characters</param>
	    /// <param name="rollback">if TRUE and if incremental is TRUE, then perform specialincremental processing, as described above, and undo partialtransliterations where necessary. If incremental is FALSE thenthis parameter is ignored.</param>
	    private void FilteredTransliterate(Replaceable text, Transliterator.Position  index,
	            bool incremental, bool rollback) {
	        // Short circuit path for transliterators with no filter in
	        // non-incremental mode.
	        if (filter == null && !rollback) {
	            HandleTransliterate(text, index, incremental);
	            return;
	        }
	
	        // ----------------------------------------------------------------------
	        // This method processes text in two groupings:
	        //
	        // RUNS -- A run is a contiguous group of characters which are contained
	        // in the filter for this transliterator (filter.contains(ch) == true).
	        // Text outside of runs may appear as context but it is not modified.
	        // The start and limit Position values are narrowed to each run.
	        //
	        // PASSES (incremental only) -- To make incremental mode work correctly,
	        // each run is broken up into n passes, where n is the length (in code
	        // points) of the run. Each pass contains the first n characters. If a
	        // pass is completely transliterated, it is committed, and further
	        // passes
	        // include characters after the committed text. If a pass is blocked,
	        // and does not transliterate completely, then this method rolls back
	        // the changes made during the pass, : the pass by one code point,
	        // and tries again.
	        // ----------------------------------------------------------------------
	
	        // globalLimit is the limit value for the entire operation. We
	        // set index.limit to the end of each unfiltered run before
	        // calling handleTransliterate(), so we need to maintain the real
	        // value of index.limit here. After each transliteration, we
	        // update globalLimit for insertions or deletions that have
	        // happened.
	        int globalLimit = index.limit;
	
	        // If there is a non-null filter, then break the input text up. Say the
	        // input text has the form:
	        // xxxabcxxdefxx
	        // where 'x' represents a filtered character (filter.contains('x') ==
	        // false). Then we break this up into:
	        // xxxabc xxdef xx
	        // Each pass through the loop consumes a run of filtered
	        // characters (which are ignored) and a subsequent run of
	        // unfiltered characters (which are transliterated).
	
	        StringBuilder log = null;
	        if (DEBUG) {
	            log = new StringBuilder();
	        }
	
	        for (;;) {
	
	            if (filter != null) {
	                // Narrow the range to be transliterated to the first run
	                // of unfiltered characters at or after index.start.
	
	                // Advance past filtered chars
	                int c;
	                while (index.start < globalLimit
	                        && !filter.Contains(c = text.Char32At(index.start))) {
	                    index.start += IBM.ICU.Text.UTF16.GetCharCount(c);
	                }
	
	                // Find the end of this run of unfiltered chars
	                index.limit = index.start;
	                while (index.limit < globalLimit
	                        && filter.Contains(c = text.Char32At(index.limit))) {
	                    index.limit += IBM.ICU.Text.UTF16.GetCharCount(c);
	                }
	            }
	
	            // Check to see if the unfiltered run is empty. This only
	            // happens at the end of the string when all the remaining
	            // characters are filtered.
	            if (index.start == index.limit) {
	                break;
	            }
	
	            // Is this run incremental? If there is additional
	            // filtered text (if limit < globalLimit) then we pass in
	            // an incremental value of FALSE to force the subclass to
	            // complete the transliteration for this run.
	            bool isIncrementalRun = ((index.limit < globalLimit) ? false
	                    : incremental);
	
	            int delta;
	
	            // Implement rollback. To understand the need for rollback,
	            // consider the following transliterator:
	            //
	            // "t" is "a > A;"
	            // "u" is "A > b;"
	            // "v" is a compound of "t; NFD; u" with a filter [:Ll:]
	            //
	            // Now apply "v" to the input text "a". The result is "b". But if
	            // the transliteration is done incrementally, then the NFD holds
	            // things up after "t" has already transformed "a" to "A". When
	            // finishTransliterate() is called, "A" is _not_ processed because
	            // it gets excluded by the [:Ll:] filter, and the end result is "A"
	            // -- incorrect. The problem is that the filter is applied to a
	            // partially-transliterated result, when we only want it to apply to
	            // input text. Although this example describes a compound
	            // transliterator containing NFD and a specific filter, it can
	            // happen with any transliterator which does a partial
	            // transformation in incremental mode into characters outside its
	            // filter.
	            //
	            // To handle this, when in incremental mode we supply characters to
	            // handleTransliterate() in several passes. Each pass adds one more
	            // input character to the input text. That is, for input "ABCD", we
	            // first try "A", then "AB", then "ABC", and finally "ABCD". If at
	            // any point we block (upon return, start < limit) then we roll
	            // back. If at any point we complete the run (upon return start ==
	            // limit) then we commit that run.
	
	            if (rollback && isIncrementalRun) {
	
	                if (DEBUG) {
	                    log.Length=0;
	                    System.Console.Out.WriteLine("filteredTransliterate{" + GetID()
	                            + "}i: IN="
	                            + IBM.ICU.Impl.UtilityExtensions.FormatInput(text, index));
	                }
	
	                int runStart = index.start;
	                int runLimit = index.limit;
	                int runLength = runLimit - runStart;
	
	                // Make a rollback copy at the end of the string
	                int rollbackOrigin = text.Length();
	                text.Copy(runStart, runLimit, rollbackOrigin);
	
	                // Variables reflecting the commitment of completely
	                // transliterated text. passStart is the runStart, advanced
	                // past committed text. rollbackStart is the rollbackOrigin,
	                // advanced past rollback text that corresponds to committed
	                // text.
	                int passStart = runStart;
	                int rollbackStart = rollbackOrigin;
	
	                // The limit for each pass; we advance by one code point with
	                // each iteration.
	                int passLimit = index.start;
	
	                // Total length, in 16-bit code units, of uncommitted text.
	                // This is the length to be rolled back.
	                int uncommittedLength = 0;
	
	                // Total delta (change in length) for all passes
	                int totalDelta = 0;
	
	                // PASS MAIN LOOP -- Start with a single character, and extend
	                // the text by one character at a time. Roll back partial
	                // transliterations and commit complete transliterations.
	                for (;;) {
	                    // Length of additional code point, either one or two
	                    int charLength = IBM.ICU.Text.UTF16.GetCharCount(text
	                            .Char32At(passLimit));
	                    passLimit += charLength;
	                    if (passLimit > runLimit) {
	                        break;
	                    }
	                    uncommittedLength += charLength;
	
	                    index.limit = passLimit;
	
	                    if (DEBUG) {
	                        log.Length=0;
	                        log.Append("filteredTransliterate{" + GetID() + "}i: ");
	                        IBM.ICU.Impl.UtilityExtensions.FormatInput(log, text, index);
	                    }
	
	                    // Delegate to subclass for actual transliteration. Upon
	                    // return, start will be updated to point after the
	                    // transliterated text, and limit and contextLimit will be
	                    // adjusted for length changes.
	                    HandleTransliterate(text, index, true);
	
	                    if (DEBUG) {
	                        log.Append(" => ");
	                        IBM.ICU.Impl.UtilityExtensions.FormatInput(log, text, index);
	                    }
	
	                    delta = index.limit - passLimit; // change in length
	
	                    // We failed to completely transliterate this pass.
	                    // Roll back the text. Indices remain unchanged; reset
	                    // them where necessary.
	                    if (index.start != index.limit) {
	                        // Find the rollbackStart, adjusted for length changes
	                        // and the deletion of partially transliterated text.
	                        int rs = rollbackStart + delta
	                                - (index.limit - passStart);
	
	                        // Delete the partially transliterated text
	                        text.Replace(passStart, index.limit, "");
	
	                        // Copy the rollback text back
	                        text.Copy(rs, rs + uncommittedLength, passStart);
	
	                        // Restore indices to their original values
	                        index.start = passStart;
	                        index.limit = passLimit;
	                        index.contextLimit -= delta;
	
	                        if (DEBUG) {
	                            log.Append(" (ROLLBACK)");
	                        }
	                    }
	
	                    // We did completely transliterate this pass. Update the
	                    // commit indices to record how far we got. Adjust indices
	                    // for length change.
	                    else {
	                        // Move the pass indices past the committed text.
	                        passStart = passLimit = index.start;
	
	                        // Adjust the rollbackStart for length changes and move
	                        // it past the committed text. All characters we've
	                        // processed to this point are committed now, so zero
	                        // out the uncommittedLength.
	                        rollbackStart += delta + uncommittedLength;
	                        uncommittedLength = 0;
	
	                        // Adjust indices for length changes.
	                        runLimit += delta;
	                        totalDelta += delta;
	                    }
	
	                    if (DEBUG) {
	                        System.Console.Out.WriteLine(IBM.ICU.Impl.Utility.Escape(log.ToString()));
	                    }
	                }
	
	                // Adjust overall limit and rollbackOrigin for insertions and
	                // deletions. Don't need to worry about contextLimit because
	                // handleTransliterate() maintains that.
	                rollbackOrigin += totalDelta;
	                globalLimit += totalDelta;
	
	                // Delete the rollback copy
	                text.Replace(rollbackOrigin, rollbackOrigin + runLength, "");
	
	                // Move start past committed text
	                index.start = passStart;
	            }
	
	            else {
	                // Delegate to subclass for actual transliteration.
	                if (DEBUG) {
	                    log.Length=0;
	                    log.Append("filteredTransliterate{" + GetID() + "}: ");
	                    IBM.ICU.Impl.UtilityExtensions.FormatInput(log, text, index);
	                }
	
	                int limit_0 = index.limit;
	                HandleTransliterate(text, index, isIncrementalRun);
	                delta = index.limit - limit_0; // change in length
	
	                if (DEBUG) {
	                    log.Append(" => ");
	                    IBM.ICU.Impl.UtilityExtensions.FormatInput(log, text, index);
	                }
	
	                // In a properly written transliterator, start == limit after
	                // handleTransliterate() returns when incremental is false.
	                // Catch cases where the subclass doesn't do this, and throw
	                // an exception. (Just pinning start to limit is a bad idea,
	                // because what's probably happening is that the subclass
	                // isn't transliterating all the way to the end, and it should
	                // in non-incremental mode.)
	                if (!isIncrementalRun && index.start != index.limit) {
	                    throw new Exception(
	                            "ERROR: Incomplete non-incremental transliteration by "
	                                    + GetID());
	                }
	
	                // Adjust overall limit for insertions/deletions. Don't need
	                // to worry about contextLimit because handleTransliterate()
	                // maintains that.
	                globalLimit += delta;
	
	                if (DEBUG) {
	                    System.Console.Out.WriteLine(IBM.ICU.Impl.Utility.Escape(log.ToString()));
	                }
	            }
	
	            if (filter == null || isIncrementalRun) {
	                break;
	            }
	
	            // If we did completely transliterate this
	            // run, then repeat with the next unfiltered run.
	        }
	
	        // Start is valid where it is. Limit needs to be put back where
	        // it was, modulo adjustments for deletions/insertions.
	        index.limit = globalLimit;
	
	        if (DEBUG) {
	            System.Console.Out.WriteLine("filteredTransliterate{" + GetID() + "}: OUT="
	                    + IBM.ICU.Impl.UtilityExtensions.FormatInput(text, index));
	        }
	    }
	
	    /// <summary>
	    /// Transliterate a substring of text, as specified by index, taking filters
	    /// into account. This method is for subclasses that need to delegate to
	    /// another transliterator, such as CompoundTransliterator.
	    /// </summary>
	    ///
	    /// <param name="text">the text to be transliterated</param>
	    /// <param name="index">the position indices</param>
	    /// <param name="incremental">if TRUE, then assume more characters may be inserted atindex.limit, and postpone processing to accomodate futureincoming characters</param>
	    /// @stable ICU 2.0
	    public void FilteredTransliterate(Replaceable text, Transliterator.Position  index,
	            bool incremental) {
	        FilteredTransliterate(text, index, incremental, false);
	    }
	
	    /// <summary>
	    /// Returns the length of the longest context required by this
	    /// transliterator. This is <em>preceding</em> context. The default value is
	    /// zero, but subclasses can change this by calling
	    /// <c>setMaximumContextLength()</c>. For example, if a transliterator
	    /// translates "ddd" (where d is any digit) to "555" when preceded by
	    /// "(ddd)", then the preceding context length is 5, the length of "(ddd)".
	    /// </summary>
	    ///
	    /// <returns>The maximum number of preceding context characters this
	    /// transliterator needs to examine</returns>
	    /// @stable ICU 2.0
	    public int GetMaximumContextLength() {
	        return maximumContextLength;
	    }
	
	    /// <summary>
	    /// Method for subclasses to use to set the maximum context length.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.Transliterator.GetMaximumContextLength"/>
	    /// @stable ICU 2.0
	    protected internal void SetMaximumContextLength(int a) {
	        if (a < 0) {
	            throw new ArgumentException("Invalid context length " + a);
	        }
	        maximumContextLength = a;
	    }
	
	    /// <summary>
	    /// Returns a programmatic identifier for this transliterator. If this
	    /// identifier is passed to <c>getInstance()</c>, it will return this
	    /// object, if it has been registered.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.Transliterator.RegisterClass(System.String, System.Type, System.String)"/>
	    /// <seealso cref="M:IBM.ICU.Text.Transliterator.GetAvailableIDs"/>
	    /// @stable ICU 2.0
	    public String GetID() {
	        return ID;
	    }
	
	    /// <summary>
	    /// Set the programmatic identifier for this transliterator. Only for use by
	    /// subclasses.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    protected internal void SetID(String id) {
	        ID = id;
	    }
	
	    /// <summary>
	    /// Returns a name for this transliterator that is appropriate for display to
	    /// the user in the default locale. See<see cref="M:IBM.ICU.Text.Transliterator.GetDisplayName(System.String, null)"/> for details.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public static String GetDisplayName(String ID_0) {
	        return GetDisplayName(ID_0, IBM.ICU.Util.ULocale.GetDefault());
	    }
	
	    /// <summary>
	    /// Returns a name for this transliterator that is appropriate for display to
	    /// the user in the given locale. This name is taken from the locale resource
	    /// data in the standard manner of the <c>java.text</c> package.
	    /// <p>
	    /// If no localized names exist in the system resource bundles, a name is
	    /// synthesized using a localized <c>MessageFormat</c> pattern from the
	    /// resource data. The arguments to this pattern are an integer followed by
	    /// one or two strings. The integer is the number of strings, either 1 or 2.
	    /// The strings are formed by splitting the ID for this transliterator at the
	    /// first '-'. If there is no '-', then the entire ID forms the only string.
	    /// </summary>
	    ///
	    /// <param name="inLocale">the Locale in which the display name should be localized.</param>
	    /// <seealso cref="T:ILOG.J2CsMapping.Text.MessageFormat"/>
	    /// @stable ICU 2.0
	    public static String GetDisplayName(String id, Locale inLocale) {
	        return GetDisplayName(id, IBM.ICU.Util.ULocale.ForLocale(inLocale));
	    }
	
	    /// <summary>
	    /// Returns a name for this transliterator that is appropriate for display to
	    /// the user in the given locale. This name is taken from the locale resource
	    /// data in the standard manner of the <c>java.text</c> package.
	    /// <p>
	    /// If no localized names exist in the system resource bundles, a name is
	    /// synthesized using a localized <c>MessageFormat</c> pattern from the
	    /// resource data. The arguments to this pattern are an integer followed by
	    /// one or two strings. The integer is the number of strings, either 1 or 2.
	    /// The strings are formed by splitting the ID for this transliterator at the
	    /// first '-'. If there is no '-', then the entire ID forms the only string.
	    /// </summary>
	    ///
	    /// <param name="inLocale">the ULocale in which the display name should be localized.</param>
	    /// <seealso cref="T:ILOG.J2CsMapping.Text.MessageFormat"/>
	    /// @stable ICU 3.2
	    public static String GetDisplayName(String id, ULocale inLocale) {
	
	        // Resource bundle containing display name keys and the
	        // RB_RULE_BASED_IDS array.
	        //
	        // If we ever integrate this with the Sun JDK, the resource bundle
	        // root will change to sun.text.resources.LocaleElements
	
	        ICUResourceBundle bundle = (ICUResourceBundle) IBM.ICU.Util.UResourceBundle
	                .GetBundleInstance(IBM.ICU.Impl.ICUResourceBundle.ICU_TRANSLIT_BASE_NAME,
	                        inLocale);
	
	        String[] stv = IBM.ICU.Text.TransliteratorIDParser.IDtoSTV(id);
	        if (stv == null) {
	            // No target; malformed id
	            return "";
	        }
	        String ID_0 = stv[0] + '-' + stv[1];
	        if (stv[2] != null && stv[2].Length > 0) {
	            ID_0 = ID_0 + '/' + stv[2];
	        }
	
	        // Use the registered display name, if any
	        String n = (String) displayNameCache[new CaseInsensitiveString(ID_0)];
	        if (n != null) {
	            return n;
	        }
	
	        // Use display name for the entire transliterator, if it
	        // exists.
	        try {
	            return bundle.GetString(RB_DISPLAY_NAME_PREFIX + ID_0);
	        } catch (MissingManifestResourceException e) {
	        }
	
	        try {
	            // Construct the formatter first; if getString() fails
	            // we'll exit the try block
	            MessageFormat format = new MessageFormat(
	                    bundle.GetString(RB_DISPLAY_NAME_PATTERN));
	            // Construct the argument array
	            Object[] args = new Object[] { ((int)(2)), stv[0], stv[1] };
	
	            // Use display names for the scripts, if they exist
	            for (int j = 1; j <= 2; ++j) {
	                try {
	                    args[j] = bundle.GetString(RB_SCRIPT_DISPLAY_NAME_PREFIX
	                            + (String) args[j]);
	                } catch (MissingManifestResourceException e_1) {
	                }
	            }
	
	            // Format it using the pattern in the resource
	            return (stv[2].Length > 0) ? (format.FormatObject(args) + '/' + stv[2])
	                    : format.FormatObject(args);
	        } catch (MissingManifestResourceException e2) {
	        }
	
	        // We should not reach this point unless there is something
	        // wrong with the build or the RB_DISPLAY_NAME_PATTERN has
	        // been deleted from the root RB_LOCALE_ELEMENTS resource.
	        throw new Exception();
	    }
	
	    /// <summary>
	    /// Returns the filter used by this transliterator, or <tt>null</tt> if this
	    /// transliterator uses no filter.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public UnicodeFilter GetFilter() {
	        return filter;
	    }
	
	    /// <summary>
	    /// Changes the filter used by this transliterator. If the filter is set to
	    /// <tt>null</tt> then no filtering will occur.
	    /// <p>
	    /// Callers must take care if a transliterator is in use by multiple threads.
	    /// The filter should not be changed by one thread while another thread may
	    /// be transliterating.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public void SetFilter(UnicodeFilter filter_0) {
	        this.filter = filter_0;
	    }
	
	    /// <summary>
	    /// Returns a <c>Transliterator</c> object given its ID. The ID must be
	    /// either a system transliterator ID or a ID registered using
	    /// <c>registerClass()</c>.
	    /// </summary>
	    ///
	    /// <param name="ID_0">a valid ID, as enumerated by <c>getAvailableIDs()</c></param>
	    /// <returns>A <c>Transliterator</c> object with the given ID</returns>
	    /// <exception cref="IllegalArgumentException">if the given ID is invalid.</exception>
	    /// @stable ICU 2.0
	    public static Transliterator GetInstance(String ID_0) {
	        return GetInstance(ID_0, FORWARD);
	    }
	
	    /// <summary>
	    /// Returns a <c>Transliterator</c> object given its ID. The ID must be
	    /// either a system transliterator ID or a ID registered using
	    /// <c>registerClass()</c>.
	    /// </summary>
	    ///
	    /// <param name="ID_0">a valid ID, as enumerated by <c>getAvailableIDs()</c></param>
	    /// <param name="dir">either FORWARD or REVERSE. If REVERSE then the inverse of thegiven ID is instantiated.</param>
	    /// <returns>A <c>Transliterator</c> object with the given ID</returns>
	    /// <exception cref="IllegalArgumentException">if the given ID is invalid.</exception>
	    /// <seealso cref="M:IBM.ICU.Text.Transliterator.RegisterClass(System.String, System.Type, System.String)"/>
	    /// <seealso cref="M:IBM.ICU.Text.Transliterator.GetAvailableIDs"/>
	    /// <seealso cref="M:IBM.ICU.Text.Transliterator.GetID"/>
	    /// @stable ICU 2.0
	    public static Transliterator GetInstance(String ID_0, int dir) {
	        StringBuilder canonID = new StringBuilder();
	        ArrayList list = new ArrayList();
	        UnicodeSet[] globalFilter = new UnicodeSet[1];
	        if (!IBM.ICU.Text.TransliteratorIDParser.ParseCompoundID(ID_0, dir, canonID, list,
	                globalFilter)) {
	            throw new ArgumentException("Invalid ID " + ID_0);
	        }
	
	        IBM.ICU.Text.TransliteratorIDParser.InstantiateList(list);
	
	        // assert(list.size() > 0);
	        Transliterator t = null;
	        if (list.Count > 1 || IBM.ICU.Impl.Utility.IndexOf(canonID, ";") >= 0) {
	            // [NOTE: If it's a compoundID, we instantiate a
	            // CompoundTransliterator even if it only
	            // has one child transliterator. This is so that toRules() will
	            // return the right thing
	            // (without any inactive ID), but our main ID still comes out
	            // correct. That is, if we
	            // instantiate "(Lower);Latin-Greek;", we want the rules to come out
	            // as "::Latin-Greek;"
	            // even though the ID is "(Lower);Latin-Greek;".
	            t = new CompoundTransliterator(list);
	        } else {
	            t = (Transliterator) list[0];
	        }
	
	        t.SetID(canonID.ToString());
	        if (globalFilter[0] != null) {
	            t.SetFilter(globalFilter[0]);
	        }
	        return t;
	    }
	
	    /// <summary>
	    /// Create a transliterator from a basic ID. This is an ID containing only
	    /// the forward direction source, target, and variant.
	    /// </summary>
	    ///
	    /// <param name="id">a basic ID of the form S-T or S-T/V.</param>
	    /// <param name="canonID">canonical ID to apply to the result, or null to leave the IDunchanged</param>
	    /// <returns>a newly created Transliterator or null if the ID is invalid.</returns>
	    static internal Transliterator GetBasicInstance(String id, String canonID) {
	        StringBuilder s = new StringBuilder();
	        Transliterator t = registry.Get(id, s);
	        if (s.Length != 0) {
	            // assert(t==0);
	            // Instantiate an alias
	            t = GetInstance(s.ToString(), FORWARD);
	        }
	        if (t != null && canonID != null) {
	            t.SetID(canonID);
	        }
	        return t;
	    }
	
	    /// <summary>
	    /// Returns a <c>Transliterator</c> object constructed from the given
	    /// rule string. This will be a RuleBasedTransliterator, if the rule string
	    /// contains only rules, or a CompoundTransliterator, if it contains ID
	    /// blocks, or a NullTransliterator, if it contains ID blocks which parse as
	    /// empty for the given direction.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public static Transliterator CreateFromRules(String ID_0, String rules,
	            int dir) {
	        Transliterator t = null;
	
	        TransliteratorParser parser = new TransliteratorParser();
	        parser.Parse(rules, dir);
	
	        // NOTE: The logic here matches that in TransliteratorRegistry.
	        if (parser.idBlockVector.Count == 0 && parser.dataVector.Count == 0) {
	            t = new NullTransliterator();
	        } else if (parser.idBlockVector.Count == 0
	                && parser.dataVector.Count == 1) {
	            t = new RuleBasedTransliterator(ID_0,
	                    (RuleBasedTransliterator.Data) parser.dataVector[0],
	                    null);
	        } else if (parser.idBlockVector.Count == 1
	                && parser.dataVector.Count == 0) {
	            // idBlock, no data -- this is an alias. The ID has
	            // been munged from reverse into forward mode, if
	            // necessary, so instantiate the ID in the forward
	            // direction.
	            if (parser.compoundFilter != null)
	                t = GetInstance(parser.compoundFilter.ToPattern(false) + ";"
	                        + (String) parser.idBlockVector[0]);
	            else
	                t = GetInstance((String) parser.idBlockVector[0]);
	
	            if (t != null) {
	                t.SetID(ID_0);
	            }
	        } else {
	            ArrayList transliterators = new ArrayList();
	            int passNumber = 1;
	
	            int limit_1 = Math.Max(parser.idBlockVector.Count,parser.dataVector.Count);
	            for (int i = 0; i < limit_1; i++) {
	                if (i < parser.idBlockVector.Count) {
	                    String idBlock = (String) parser.idBlockVector[i];
	                    if (idBlock.Length > 0) {
	                        Transliterator temp = GetInstance(idBlock);
	                        if (!(temp  is  NullTransliterator))
	                            transliterators.Add(GetInstance(idBlock));
	                    }
	                }
	                if (i < parser.dataVector.Count) {
	                    RuleBasedTransliterator.Data data = (RuleBasedTransliterator.Data) parser.dataVector[i];
	                    transliterators.Add(new RuleBasedTransliterator("%Pass"
	                            + passNumber++, data, null));
	                }
	            }
	
	            t = new CompoundTransliterator(transliterators, passNumber - 1);
	            t.SetID(ID_0);
	            if (parser.compoundFilter != null) {
	                t.SetFilter(parser.compoundFilter);
	            }
	        }
	
	        return t;
	    }
	
	    /// <summary>
	    /// Returns a rule string for this transliterator.
	    /// </summary>
	    ///
	    /// <param name="escapeUnprintable">if true, then unprintable characters will be converted toescape form backslash-'u' or backslash-'U'.</param>
	    /// @stable ICU 2.0
	    public virtual String ToRules(bool escapeUnprintable) {
	        return BaseToRules(escapeUnprintable);
	    }
	
	    /// <summary>
	    /// Returns a rule string for this transliterator. This is a non-overrideable
	    /// base class implementation that subclasses may call. It simply munges the
	    /// ID into the correct format, that is, "foo" => "::foo".
	    /// </summary>
	    ///
	    /// <param name="escapeUnprintable">if true, then unprintable characters will be converted toescape form backslash-'u' or backslash-'U'.</param>
	    /// @stable ICU 2.0
	    protected internal String BaseToRules(bool escapeUnprintable) {
	        // The base class implementation of toRules munges the ID into
	        // the correct format. That is: foo => ::foo
	        // KEEP in sync with rbt_pars
	        if (escapeUnprintable) {
	            StringBuilder rulesSource = new StringBuilder();
	            String id = GetID();
	            for (int i = 0; i < id.Length;) {
	                int c = IBM.ICU.Text.UTF16.CharAt(id, i);
	                if (!IBM.ICU.Impl.Utility.EscapeUnprintable(rulesSource, c)) {
	                    IBM.ICU.Text.UTF16.Append(rulesSource, c);
	                }
	                i += IBM.ICU.Text.UTF16.GetCharCount(c);
	            }
	            rulesSource.Insert(0, "::");
	            rulesSource.Append(ID_DELIM);
	            return rulesSource.ToString();
	        }
	        return "::" + GetID() + ID_DELIM;
	    }
	
	    /// <summary>
	    /// Return the elements that make up this transliterator. For example, if the
	    /// transliterator "NFD;Jamo-Latin;Latin-Greek" were created, the return
	    /// value of this method would be an array of the three transliterator
	    /// objects that make up that transliterator: [NFD, Jamo-Latin, Latin-Greek].
	    /// <p>
	    /// If this transliterator is not composed of other transliterators, then
	    /// this method will return an array of length one containing a reference to
	    /// this transliterator.
	    /// </summary>
	    ///
	    /// <returns>an array of one or more transliterators that make up this
	    /// transliterator</returns>
	    /// @stable ICU 3.0
	    public Transliterator[] GetElements() {
	        Transliterator[] result;
	        if (this  is  CompoundTransliterator) {
	            CompoundTransliterator cpd = (CompoundTransliterator) this;
	            result = new Transliterator[cpd.GetCount()];
	            for (int i = 0; i < result.Length; ++i) {
	                result[i] = cpd.GetTransliterator(i);
	            }
	        } else {
	            result = new Transliterator[] { this };
	        }
	        return result;
	    }
	
	    /// <summary>
	    /// Returns the set of all characters that may be modified in the input text
	    /// by this Transliterator. This incorporates this object's current filter;
	    /// if the filter is changed, the return value of this function will change.
	    /// The default implementation returns an empty set. Some subclasses may
	    /// override <see cref="M:IBM.ICU.Text.Transliterator.HandleGetSourceSet"/> to return a more precise result. The
	    /// return result is approximate in any case and is intended for use by
	    /// tests, tools, or utilities.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.Transliterator.GetTargetSet"/>
	    /// <seealso cref="M:IBM.ICU.Text.Transliterator.HandleGetSourceSet"/>
	    /// @stable ICU 2.2
	    public UnicodeSet GetSourceSet() {
	        UnicodeSet set = HandleGetSourceSet();
	        if (filter != null) {
	            UnicodeSet filterSet;
	            // Most, but not all filters will be UnicodeSets. Optimize for
	            // the high-runner case.
	            try {
	                filterSet = (UnicodeSet) filter;
	            } catch (InvalidCastException e) {
	                filterSet = new UnicodeSet();
	                filter.AddMatchSetTo(filterSet);
	            }
	            set.RetainAll(filterSet);
	        }
	        return set;
	    }
	
	    /// <summary>
	    /// Framework method that returns the set of all characters that may be
	    /// modified in the input text by this Transliterator, ignoring the effect of
	    /// this object's filter. The base class implementation returns the empty
	    /// set. Subclasses that wish to implement this should override this method.
	    /// </summary>
	    ///
	    /// <returns>the set of characters that this transliterator may modify. The
	    /// set may be modified, so subclasses should return a newly-created
	    /// object.</returns>
	    /// <seealso cref="M:IBM.ICU.Text.Transliterator.GetSourceSet"/>
	    /// <seealso cref="M:IBM.ICU.Text.Transliterator.GetTargetSet"/>
	    /// @stable ICU 2.2
	    protected internal virtual UnicodeSet HandleGetSourceSet() {
	        return new UnicodeSet();
	    }
	
	    /// <summary>
	    /// Returns the set of all characters that may be generated as replacement
	    /// text by this transliterator. The default implementation returns the empty
	    /// set. Some subclasses may override this method to return a more precise
	    /// result. The return result is approximate in any case and is intended for
	    /// use by tests, tools, or utilities requiring such meta-information.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.Transliterator.GetTargetSet"/>
	    /// @stable ICU 2.2
	    public virtual UnicodeSet GetTargetSet() {
	        return new UnicodeSet();
	    }
	
	    /// <summary>
	    /// Returns this transliterator's inverse. See the class documentation for
	    /// details. This implementation simply inverts the two entities in the ID
	    /// and attempts to retrieve the resulting transliterator. That is, if
	    /// <c>getID()</c> returns "A-B", then this method will return the
	    /// result of <c>getInstance("B-A")</c>, or <c>null</c> if that
	    /// call fails.
	    /// <p>
	    /// Subclasses with knowledge of their inverse may wish to override this
	    /// method.
	    /// </summary>
	    ///
	    /// <returns>a transliterator that is an inverse, not necessarily exact, of
	    /// this transliterator, or <c>null</c> if no such
	    /// transliterator is registered.</returns>
	    /// <seealso cref="M:IBM.ICU.Text.Transliterator.RegisterClass(System.String, System.Type, System.String)"/>
	    /// @stable ICU 2.0
	    public Transliterator GetInverse() {
	        return GetInstance(ID, REVERSE);
	    }
	
	    /// <summary>
	    /// Registers a subclass of <c>Transliterator</c> with the system. This
	    /// subclass must have a public constructor taking no arguments. When that
	    /// constructor is called, the resulting object must return the
	    /// <c>ID</c> passed to this method if its <c>getID()</c> method
	    /// is called.
	    /// </summary>
	    ///
	    /// <param name="ID_0">the result of <c>getID()</c> for this transliterator</param>
	    /// <param name="transClass">a subclass of <c>Transliterator</c></param>
	    /// <seealso cref="M:IBM.ICU.Text.Transliterator.Unregister(System.String)"/>
	    /// @stable ICU 2.0
	    public static void RegisterClass(String ID_0, Type transClass,
	            String displayName) {
	        registry.Put(ID_0, transClass, true);
	        if (displayName != null) {
	            ILOG.J2CsMapping.Collections.Collections.Put(displayNameCache,new CaseInsensitiveString(ID_0),displayName);
	        }
	    }
	
	    /// <summary>
	    /// Register a factory object with the given ID. The factory method should
	    /// return a new instance of the given transliterator.
	    /// </summary>
	    ///
	    /// <param name="ID_0">the ID of this transliterator</param>
	    /// <param name="factory">the factory object</param>
	    /// @stable ICU 2.0
	    public static void RegisterFactory(String ID_0, Transliterator.Factory  factory) {
	        registry.Put(ID_0, factory, true);
	    }
	
	    /// <summary>
	    /// Register a Transliterator object with the given ID.
	    /// </summary>
	    ///
	    /// <param name="trans">the Transliterator object</param>
	    /// @stable ICU 2.2
	    public static void RegisterInstance(Transliterator trans) {
	        registry.Put(trans.GetID(), trans, true);
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Register a Transliterator object with the given ID.
	    /// </summary>
	    ///
	    /// <param name="ID">the ID of this transliterator</param>
	    /// <param name="trans">the Transliterator object</param>
	    static internal void RegisterInstance(Transliterator trans, bool visible) {
	        registry.Put(trans.GetID(), trans, visible);
	    }
	
	    /// <summary>
	    /// Register an ID as an alias of another ID. Instantiating alias ID produces
	    /// the same result as instantiating the original ID. This is generally used
	    /// to create short aliases of compound IDs.
	    /// </summary>
	    ///
	    /// <param name="aliasID">The new ID being registered.</param>
	    /// <param name="realID">The existing ID that the new ID should be an alias of.</param>
	    /// @stable ICU 3.6
	    public static void RegisterAlias(String aliasID, String realID) {
	        registry.Put(aliasID, realID, true);
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Register two targets as being inverses of one another. For example,
	    /// calling registerSpecialInverse("NFC", "NFD", true) causes Transliterator
	    /// to form the following inverse relationships:
	    /// <pre>
	    /// NFC => NFD
	    /// Any-NFC => Any-NFD
	    /// NFD => NFC
	    /// Any-NFD => Any-NFC
	    /// </pre>
	    /// (Without the special inverse registration, the inverse of NFC would be
	    /// NFC-Any.) Note that NFD is shorthand for Any-NFD, but that the presence
	    /// or absence of "Any-" is preserved.
	    /// <p>
	    /// The relationship is symmetrical; registering (a, b) is equivalent to
	    /// registering (b, a).
	    /// <p>
	    /// The relevant IDs must still be registered separately as factories or
	    /// classes.
	    /// <p>
	    /// Only the targets are specified. Special inverses always have the form
	    /// Any-Target1 <=> Any-Target2. The target should have canonical casing (the
	    /// casing desired to be produced when an inverse is formed) and should
	    /// contain no whitespace or other extraneous characters.
	    /// </summary>
	    ///
	    /// <param name="target">the target against which to register the inverse</param>
	    /// <param name="inverseTarget">the inverse of target, that is Any-target.getInverse() =>Any-inverseTarget</param>
	    /// <param name="bidirectional">if true, register the reverse relation as well, that is,Any-inverseTarget.getInverse() => Any-target</param>
	    static internal void RegisterSpecialInverse(String target, String inverseTarget,
	            bool bidirectional) {
	        IBM.ICU.Text.TransliteratorIDParser.RegisterSpecialInverse(target, inverseTarget,
	                bidirectional);
	    }
	
	    /// <summary>
	    /// Unregisters a transliterator or class. This may be either a system
	    /// transliterator or a user transliterator or class.
	    /// </summary>
	    ///
	    /// <param name="ID_0">the ID of the transliterator or class</param>
	    /// <seealso cref="M:IBM.ICU.Text.Transliterator.RegisterClass(System.String, System.Type, System.String)"/>
	    /// @stable ICU 2.0
	    public static void Unregister(String ID_0) {
	        ILOG.J2CsMapping.Collections.Collections.Remove(displayNameCache,new CaseInsensitiveString(ID_0));
	        registry.Remove(ID_0);
	    }
	
	    /// <summary>
	    /// Returns an enumeration over the programmatic names of registered
	    /// <c>Transliterator</c> objects. This includes both system
	    /// transliterators and user transliterators registered using
	    /// <c>registerClass()</c>. The enumerated names may be passed to
	    /// <c>getInstance()</c>.
	    /// </summary>
	    ///
	    /// <returns>An <c>Enumeration</c> over <c>String</c> objects</returns>
	    /// <seealso cref="M:IBM.ICU.Text.Transliterator.GetInstance(System.String)"/>
	    /// <seealso cref="M:IBM.ICU.Text.Transliterator.RegisterClass(System.String, System.Type, System.String)"/>
	    /// @stable ICU 2.0
	    public static IIterator GetAvailableIDs() {
	        return registry.GetAvailableIDs();
	    }
	
	    /// <summary>
	    /// Returns an enumeration over the source names of registered
	    /// transliterators. Source names may be passed to getAvailableTargets() to
	    /// obtain available targets for each source.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public static IIterator GetAvailableSources() {
	        return registry.GetAvailableSources();
	    }
	
	    /// <summary>
	    /// Returns an enumeration over the target names of registered
	    /// transliterators having a given source name. Target names may be passed to
	    /// getAvailableVariants() to obtain available variants for each source and
	    /// target pair.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public static IIterator GetAvailableTargets(String source) {
	        return registry.GetAvailableTargets(source);
	    }
	
	    /// <summary>
	    /// Returns an enumeration over the variant names of registered
	    /// transliterators having a given source name and target name.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public static IIterator GetAvailableVariants(String source,
	            String target) {
	        return registry.GetAvailableVariants(source, target);
	    }
	
	    private const String INDEX = "index",
	            RB_RULE_BASED_IDS = "RuleBasedTransliteratorIDs";
	    /// <summary>
	    /// The factory interface for transliterators. Transliterator subclasses can
	    /// register factory objects for IDs using the registerFactory() method of
	    /// Transliterator. When invoked, the factory object will be passed the ID
	    /// being instantiated. This makes it possible to register one factory method
	    /// to more than one ID, or for a factory method to parameterize its result
	    /// based on the variant.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public interface Factory {
	        /// <summary>
	        /// Return a transliterator for the given ID.
	        /// </summary>
	        ///
	        /// @stable ICU 2.0
	        Transliterator GetInstance(String ID_0);
	    }
	
	    /// <summary>
	    /// Implements StringTransform via this method.
	    /// </summary>
	    ///
	    /// <param name="source">text to be transformed (eg lowercased)</param>
	    /// <returns>result</returns>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public virtual String Transform(String source) {
	        return Transliterate(source);
	    }
	
	    static Transliterator() {
	            registry = new TransliteratorRegistry();
	            displayNameCache = new Hashtable();
	            UResourceBundle bundle, transIDs, colBund;
	            bundle = IBM.ICU.Util.UResourceBundle.GetBundleInstance(
	                    IBM.ICU.Impl.ICUResourceBundle.ICU_TRANSLIT_BASE_NAME,
	                    INDEX);
	            transIDs = bundle.Get(RB_RULE_BASED_IDS);
	            int row, maxRows;
	            maxRows = transIDs.GetSize();
	            for (row = 0; row < maxRows; row++) {
	                colBund = transIDs.Get(row);
	                String ID_0 = colBund.GetKey();
	                UResourceBundle res = colBund.Get(0);
	                String type = res.GetKey();
	                if (type.Equals("file") || type.Equals("internal")) {
	                    String resString = res.GetString("resource");
	                    int dir;
	                    String direction = res.GetString("direction");
	                    switch ((int) direction[0]) {
	                    case 'F':
	                        dir = FORWARD;
	                        break;
	                    case 'R':
	                        dir = REVERSE;
	                        break;
	                    default:
	                        throw new Exception("Can't parse direction: "
	                                + direction);
	                    }
	                    registry.Put(ID_0, resString, "UTF-16", dir,
	                            !type.Equals("internal"));
	                } else if (type.Equals("alias")) {
	                    String resString = res.GetString();
	                    registry.Put(ID_0, resString, true);
	                } else {
	                    throw new Exception("Unknow type: " + type);
	                }
	            }
	            RegisterSpecialInverse(IBM.ICU.Text.NullTransliterator.SHORT_ID,
	                    IBM.ICU.Text.NullTransliterator.SHORT_ID, false);
	            RegisterClass(IBM.ICU.Text.NullTransliterator._ID,
	                    typeof(NullTransliterator), null);
	            IBM.ICU.Text.RemoveTransliterator.Register();
	            IBM.ICU.Text.EscapeTransliterator.Register();
	            IBM.ICU.Text.UnescapeTransliterator.Register();
	            IBM.ICU.Text.LowercaseTransliterator.Register();
	            IBM.ICU.Text.UppercaseTransliterator.Register();
	            IBM.ICU.Text.TitlecaseTransliterator.Register();
	            IBM.ICU.Text.UnicodeNameTransliterator.Register();
	            IBM.ICU.Text.NameUnicodeTransliterator.Register();
	            IBM.ICU.Text.NormalizationTransliterator.Register();
	            IBM.ICU.Text.BreakTransliterator.Register();
	            IBM.ICU.Text.AnyTransliterator.Register();
	        }
	}
}
