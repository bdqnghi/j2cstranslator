/*
 **********************************************************************
 *   Copyright (c) 2001-2004, International Business Machines
 *   Corporation and others.  All Rights Reserved.
 **********************************************************************
 *   Date        Name        Description
 *   11/19/2001  aliu        Creation.
 **********************************************************************
 */
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:30 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Text {
	
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	
	
	/// <summary>
	/// A transliterator that converts Unicode escape forms to the characters they
	/// represent. Escape forms have a prefix, a suffix, a radix, and minimum and
	/// maximum digit counts.
	/// <p>
	/// This class is package private. It registers several standard variants with
	/// the system which are then accessed via their IDs.
	/// </summary>
	///
	internal class UnescapeTransliterator : Transliterator {
	
	    public sealed class Anonymous_C6 : Transliterator.Factory {
	        public Transliterator GetInstance(String ID) {
	            return new UnescapeTransliterator("Hex-Any/Unicode",
                        new char[] { (char)2, (char)0, (char)16, (char)4, (char)6, 'U', '+', IBM.ICU.Text.UnescapeTransliterator.END });
	        }
	    }
	
	    public sealed class Anonymous_C5 : Transliterator.Factory {
	        public Transliterator GetInstance(String ID) {
	            return new UnescapeTransliterator("Hex-Any/Java",
                        new char[] { (char)2, (char)0, (char)16, (char)4, (char)4, '\\', 'u', IBM.ICU.Text.UnescapeTransliterator.END });
	        }
	    }
	
	    public sealed class Anonymous_C4 : Transliterator.Factory {
	        public Transliterator GetInstance(String ID) {
	            return new UnescapeTransliterator("Hex-Any/C",
                        new char[] { (char) 2, (char) 0, (char) 16, (char) 4, (char) 4, '\\', 'u', (char) 2, (char) 0,
	                            (char) 16, (char) 8, (char) 8, '\\', 'U', IBM.ICU.Text.UnescapeTransliterator.END });
	        }
	    }
	
	    public sealed class Anonymous_C3 : Transliterator.Factory {
	        public Transliterator GetInstance(String ID) {
	            return new UnescapeTransliterator("Hex-Any/XML",
                        new char[] { (char) 3, (char) 1, (char) 16, (char) 1,(char)  6, '&', '#', 'x',
	                            ';', IBM.ICU.Text.UnescapeTransliterator.END });
	        }
	    }
	
	    public sealed class Anonymous_C2 : Transliterator.Factory {
	        public Transliterator GetInstance(String ID) {
	            return new UnescapeTransliterator(
	                    "Hex-Any/XML10",
                        new char[] { (char)2, (char)1, (char)10, (char)1, (char)7, '&', '#', ';', IBM.ICU.Text.UnescapeTransliterator.END });
	        }
	    }
	
	    public sealed class Anonymous_C1 : Transliterator.Factory {
	        public Transliterator GetInstance(String ID) {
	            return new UnescapeTransliterator("Hex-Any/Perl",
                        new char[] { (char) 3, (char) 1, (char) 16, (char) 1, (char) 6, '\\', 'x', '{',
	                            '}', IBM.ICU.Text.UnescapeTransliterator.END });
	        }
	    }
	
	    public sealed class Anonymous_C0 : Transliterator.Factory {
	        public Transliterator GetInstance(String ID) {
                return new UnescapeTransliterator("Hex-Any", new char[] { (char) 2, (char) 0,
	                    (char) 16, (char) 4, (char) 6, 'U', '+', // Unicode
	                    (char) 2, (char) 0, (char) 16, (char) 4, (char) 4, '\\', 'u', // Java
	                    (char) 2, (char) 0, (char) 16, (char) 8, (char) 8, '\\', 'U', // C (surrogates)
	                    (char) 3, (char) 1, (char) 16,(char)  1, (char) 6, '&', '#', 'x', ';', // XML
	                    (char) 2, (char) 1, (char) 10, (char) 1, (char) 7, '&', '#', ';', // XML10
	                    (char) 3, (char) 1, (char) 16, (char) 1, (char) 6, '\\', 'x', '{', '}', // Perl
	                    IBM.ICU.Text.UnescapeTransliterator.END });
	        }
	    }
	
	    /// <summary>
	    /// The encoded pattern specification. The pattern consists of zero or more forms. Each form consists of a prefix, suffix, radix, minimum digit count, and maximum digit count. These values are stored as a five character header. That is, their numeric values are cast to 16-bit characters and stored in the string. Following these five characters, the prefix characters, then suffix characters are stored. Each form thus takes n+5 characters, where n is the total length of the prefix and suffix. The end is marked by a header of length one consisting of the character END.
	    /// </summary>
	    ///
	    private char[] spec;
	
	    /// <summary>
	    /// Special character marking the end of the spec[] array.
	    /// </summary>
	    ///
	    private const char END = (char) (0xFFFF);
	
	    /// <summary>
	    /// Registers standard variants with the system. Called by Transliterator
	    /// during initialization.
	    /// </summary>
	    ///
	    static internal void Register() {
	        // Unicode: "U+10FFFF" hex, min=4, max=6
	        IBM.ICU.Text.Transliterator.RegisterFactory("Hex-Any/Unicode",
	                new UnescapeTransliterator.Anonymous_C6 ());
	
	        // Java: "\\uFFFF" hex, min=4, max=4
	        IBM.ICU.Text.Transliterator.RegisterFactory("Hex-Any/Java",
	                new UnescapeTransliterator.Anonymous_C5 ());
	
	        // C: "\\uFFFF" hex, min=4, max=4; \\U0010FFFF hex, min=8, max=8
	        IBM.ICU.Text.Transliterator.RegisterFactory("Hex-Any/C",
	                new UnescapeTransliterator.Anonymous_C4 ());
	
	        // XML: "&#x10FFFF;" hex, min=1, max=6
	        IBM.ICU.Text.Transliterator.RegisterFactory("Hex-Any/XML",
	                new UnescapeTransliterator.Anonymous_C3 ());
	
	        // XML10: "&1114111;" dec, min=1, max=7 (not really "Hex-Any")
	        IBM.ICU.Text.Transliterator.RegisterFactory("Hex-Any/XML10",
	                new UnescapeTransliterator.Anonymous_C2 ());
	
	        // Perl: "\\x{263A}" hex, min=1, max=6
	        IBM.ICU.Text.Transliterator.RegisterFactory("Hex-Any/Perl",
	                new UnescapeTransliterator.Anonymous_C1 ());
	
	        // All: Java, C, Perl, XML, XML10, Unicode
	        IBM.ICU.Text.Transliterator.RegisterFactory("Hex-Any", new UnescapeTransliterator.Anonymous_C0 ());
	    }
	
	    /// <summary>
	    /// Package private constructor. Takes the encoded spec array.
	    /// </summary>
	    ///
	    internal UnescapeTransliterator(String ID, char[] spec_0) : base(ID, null) {
	        this.spec = spec_0;
	    }
	
	    /// <summary>
	    /// Implements <see cref="M:IBM.ICU.Text.Transliterator.HandleTransliterate(IBM.ICU.Text.Replaceable, null, System.Boolean)"/>.
	    /// </summary>
	    ///
	    protected internal override void HandleTransliterate(Replaceable text, Transliterator.Position  pos,
	            bool isIncremental) {
	        int start = pos.start;
	        int limit = pos.limit;
	        int i, j, ipat;
	
	        loop: {
	            while (start < limit) {
	                // Loop over the forms in spec[]. Exit this loop when we
	                // match one of the specs. Exit the outer loop if a
	                // partial match is detected and isIncremental is true.
	                for (j = 0, ipat = 0; spec[ipat] != END; ++j) {
	
	                    // Read the header
	                    int prefixLen = spec[ipat++];
	                    int suffixLen = spec[ipat++];
	                    int radix = spec[ipat++];
	                    int minDigits = spec[ipat++];
	                    int maxDigits = spec[ipat++];
	
	                    // s is a copy of start that is advanced over the
	                    // characters as we parse them.
	                    int s = start;
	                    bool match = true;
	
	                    for (i = 0; i < prefixLen; ++i) {
	                        if (s >= limit) {
	                            if (i > 0) {
	                                // We've already matched a character. This is
	                                // a partial match, so we return if in
	                                // incremental mode. In non-incremental mode,
	                                // go to the next spec.
	                                if (isIncremental) {
	                                    goto gotoloop;
	                                }
	                                match = false;
	                                break;
	                            }
	                        }
	                        char c = text.CharAt(s++);
	                        if (c != spec[ipat + i]) {
	                            match = false;
	                            break;
	                        }
	                    }
	
	                    if (match) {
	                        int u = 0;
	                        int digitCount = 0;
	                        for (;;) {
	                            if (s >= limit) {
	                                // Check for partial match in incremental mode.
	                                if (s > start && isIncremental) {
	                                    goto gotoloop;
	                                }
	                                break;
	                            }
	                            int ch = text.Char32At(s);
	                            int digit = IBM.ICU.Lang.UCharacter.Digit(ch, radix);
	                            if (digit < 0) {
	                                break;
	                            }
	                            s += IBM.ICU.Text.UTF16.GetCharCount(ch);
	                            u = (u * radix) + digit;
	                            if (++digitCount == maxDigits) {
	                                break;
	                            }
	                        }
	
	                        match = (digitCount >= minDigits);
	
	                        if (match) {
	                            for (i = 0; i < suffixLen; ++i) {
	                                if (s >= limit) {
	                                    // Check for partial match in incremental mode.
	                                    if (s > start && isIncremental) {
	                                        goto gotoloop;
	                                    }
	                                    match = false;
	                                    break;
	                                }
	                                char c_0 = text.CharAt(s++);
	                                if (c_0 != spec[ipat + prefixLen + i]) {
	                                    match = false;
	                                    break;
	                                }
	                            }
	
	                            if (match) {
	                                // At this point, we have a match
	                                String str = IBM.ICU.Text.UTF16.ValueOf(u);
	                                text.Replace(start, s, str);
	                                limit -= s - start - str.Length;
	                                // The following break statement leaves the
	                                // loop that is traversing the forms in
	                                // spec[]. We then parse the next input
	                                // character.
	                                break;
	                            }
	                        }
	                    }
	
	                    ipat += prefixLen + suffixLen;
	                }
	
	                if (start < limit) {
	                    start += IBM.ICU.Text.UTF16.GetCharCount(text.Char32At(start));
	                }
	            }
	        }
	        gotoloop:
	        ;
	
	        pos.contextLimit += limit - pos.limit;
	        pos.limit = limit;
	        pos.start = start;
	    }
	}
}
