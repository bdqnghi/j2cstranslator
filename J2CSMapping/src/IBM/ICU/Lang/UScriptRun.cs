/*
 *******************************************************************************
 *
 *   Copyright (C) 1999-2007, International Business Machines
 *   Corporation and others.  All Rights Reserved.
 *
 *******************************************************************************
 */

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 2:05 PM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Lang {
	
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	
	
	/// <exclude/>
	/// <summary>
	/// <c>UScriptRun</c> is used to find runs of characters in the same
	/// script, as defined in the <c>UScript</c> class. It implements a simple
	/// iterator over an array of characters. The iterator will assign
	/// <c>COMMON</c> and <c>INHERITED</c> characters to the same script
	/// as the preceeding characters. If the COMMON and INHERITED characters are
	/// first, they will be assigned to the same script as the following characters.
	/// The iterator will try to match paired punctuation. If it sees an opening
	/// punctuation character, it will remember the script that was assigned to that
	/// character, and assign the same script to the matching closing punctuation.
	/// No attempt is made to combine related scripts into a single run. In
	/// particular, Hiragana, Katakana, and Han characters will appear in separate
	/// runs.
	/// Here is an example of how to iterate over script runs:
	/// <pre>
	/// void printScriptRuns(char[] text) {
	/// UScriptRun scriptRun = new UScriptRun(text);
	/// while (scriptRun.next()) {
	/// int start = scriptRun.getScriptStart();
	/// int limit = scriptRun.getScriptLimit();
	/// int script = scriptRun.getScriptCode();
	/// System.out.println(&quot;Script \&quot;&quot; + UScript.getName(script) + &quot;\&quot; from &quot;
	/// + start + &quot; to &quot; + limit + &quot;.&quot;);
	/// }
	/// }
	/// </pre>
	/// </summary>
	///
	public sealed class UScriptRun {
	    /// <exclude/>
	    /// <summary>
	    /// Construct an empty <c>UScriptRun</c> object. The
	    /// <c>next()</c> method will return <c>false</c> the first time
	    /// it is called.
	    /// </summary>
	    ///
	    public UScriptRun() {
	        this.emptyCharArray = new char[] {};
	        this.parenSP = -1;
	        this.pushCount = 0;
	        this.fixupCount = 0;
	        char[] nullChars = null;
	
	        Reset(nullChars, 0, 0);
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Construct a <c>UScriptRun</c> object which iterates over the
	    /// characters in the given string.
	    /// </summary>
	    ///
	    /// <param name="text">the string of characters over which to iterate.</param>
	    public UScriptRun(String text) {
	        this.emptyCharArray = new char[] {};
	        this.parenSP = -1;
	        this.pushCount = 0;
	        this.fixupCount = 0;
	        Reset(text);
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Construct a <c>UScriptRun</c> object which iterates over a subrange
	    /// of the characetrs in the given string.
	    /// </summary>
	    ///
	    /// <param name="text">the string of characters over which to iterate.</param>
	    /// <param name="start">the index of the first character over which to iterate</param>
	    /// <param name="count">the number of characters over which to iterate</param>
	    public UScriptRun(String text, int start, int count) {
	        this.emptyCharArray = new char[] {};
	        this.parenSP = -1;
	        this.pushCount = 0;
	        this.fixupCount = 0;
	        Reset(text, start, count);
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Construct a <c>UScriptRun</c> object which iterates over the given
	    /// characetrs.
	    /// </summary>
	    ///
	    /// <param name="chars">the array of characters over which to iterate.</param>
	    public UScriptRun(char[] chars) {
	        this.emptyCharArray = new char[] {};
	        this.parenSP = -1;
	        this.pushCount = 0;
	        this.fixupCount = 0;
	        Reset(chars);
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Construct a <c>UScriptRun</c> object which iterates over a subrange
	    /// of the given characetrs.
	    /// </summary>
	    ///
	    /// <param name="chars">the array of characters over which to iterate.</param>
	    /// <param name="start">the index of the first character over which to iterate</param>
	    /// <param name="count">the number of characters over which to iterate</param>
	    public UScriptRun(char[] chars, int start, int count) {
	        this.emptyCharArray = new char[] {};
	        this.parenSP = -1;
	        this.pushCount = 0;
	        this.fixupCount = 0;
	        Reset(chars, start, count);
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Reset the iterator to the start of the text.
	    /// </summary>
	    ///
	    public void Reset() {
	        // empty any old parenStack contents.
	        // NOTE: this is not the most efficient way
	        // to do this, but it's the easiest to write...
	        while (StackIsNotEmpty()) {
	            Pop();
	        }
	
	        scriptStart = textStart;
	        scriptLimit = textStart;
	        scriptCode = IBM.ICU.Lang.UScript.INVALID_CODE;
	        parenSP = -1;
	        pushCount = 0;
	        fixupCount = 0;
	
	        textIndex = textStart;
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Reset the iterator to iterate over the given range of the text. Throws
	    /// IllegalArgumentException if the range is outside of the bounds of the
	    /// character array.
	    /// </summary>
	    ///
	    /// <param name="start">the index of the new first character over which to iterate</param>
	    /// <param name="count">the new number of characters over which to iterate.</param>
	    /// <exception cref="IllegalArgumentException"></exception>
	    public void Reset(int start, int count) {
	        int len = 0;
	
	        if (text != null) {
	            len = text.Length;
	        }
	
	        if (start < 0 || count < 0 || start > len - count) {
	            throw new ArgumentException();
	        }
	
	        textStart = start;
	        textLimit = start + count;
	
	        Reset();
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Reset the iterator to iterate over <c>count</c> characters in
	    /// <c>chars</c> starting at <c>start</c>. This allows clients to
	    /// reuse an iterator.
	    /// </summary>
	    ///
	    /// <param name="chars">the new array of characters over which to iterate.</param>
	    /// <param name="start">the index of the first character over which to iterate.</param>
	    /// <param name="count">the number of characters over which to iterate.</param>
	    public void Reset(char[] chars, int start, int count) {
	        if (chars == null) {
	            chars = emptyCharArray;
	        }
	
	        text = chars;
	
	        Reset(start, count);
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Reset the iterator to iterate over the characters in <c>chars</c>.
	    /// This allows clients to reuse an iterator.
	    /// </summary>
	    ///
	    /// <param name="chars">the new array of characters over which to iterate.</param>
	    public void Reset(char[] chars) {
	        int length = 0;
	
	        if (chars != null) {
	            length = chars.Length;
	        }
	
	        Reset(chars, 0, length);
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Reset the iterator to iterate over <c>count</c> characters in
	    /// <c>text</c> starting at <c>start</c>. This allows clients to
	    /// reuse an iterator.
	    /// </summary>
	    ///
	    /// <param name="text">the new string of characters over which to iterate.</param>
	    /// <param name="start">the index of the first character over which to iterate.</param>
	    /// <param name="count">the nuber of characters over which to iterate.</param>
	    public void Reset(String text, int start, int count) {
	        char[] chars = null;
	
	        if (text != null) {
	            chars = text.ToCharArray();
	        }
	
	        Reset(chars, start, count);
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Reset the iterator to iterate over the characters in <c>text</c>.
	    /// This allows clients to reuse an iterator.
	    /// </summary>
	    ///
	    /// <param name="text">the new string of characters over which to iterate.</param>
	    public void Reset(String text) {
	        int length = 0;
	
	        if (text != null) {
	            length = text.Length;
	        }
	
	        Reset(text, 0, length);
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Get the starting index of the current script run.
	    /// </summary>
	    ///
	    /// <returns>the index of the first character in the current script run.</returns>
	    public int GetScriptStart() {
	        return scriptStart;
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Get the index of the first character after the current script run.
	    /// </summary>
	    ///
	    /// <returns>the index of the first character after the current script run.</returns>
	    public int GetScriptLimit() {
	        return scriptLimit;
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Get the script code for the script of the current script run.
	    /// </summary>
	    ///
	    /// <returns>the script code for the script of the current script run.</returns>
	    /// <seealso cref="T:IBM.ICU.Lang.UScript"/>
	    public int GetScriptCode() {
	        return scriptCode;
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Find the next script run. Returns <c>false</c> if there isn't
	    /// another run, returns <c>true</c> if there is.
	    /// </summary>
	    ///
	    /// <returns><c>false</c> if there isn't another run, <c>true</c>
	    /// if there is.</returns>
	    public bool Next() {
	        // if we've fallen off the end of the text, we're done
	        if (scriptLimit >= textLimit) {
	            return false;
	        }
	
	        scriptCode = IBM.ICU.Lang.UScript.COMMON;
	        scriptStart = scriptLimit;
	
	        SyncFixup();
	
	        while (textIndex < textLimit) {
	            int ch = IBM.ICU.Text.UTF16.CharAt(text, textStart, textLimit, textIndex
	                    - textStart);
	            int codePointCount = IBM.ICU.Text.UTF16.GetCharCount(ch);
	            int sc = IBM.ICU.Lang.UScript.GetScript(ch);
	            int pairIndex = GetPairIndex(ch);
	
	            textIndex += codePointCount;
	
	            // Paired character handling:
	            //
	            // if it's an open character, push it onto the stack.
	            // if it's a close character, find the matching open on the
	            // stack, and use that script code. Any non-matching open
	            // characters above it on the stack will be poped.
	            if (pairIndex >= 0) {
	                if ((pairIndex & 1) == 0) {
	                    Push(pairIndex, scriptCode);
	                } else {
	                    int pi = pairIndex & ~1;
	
	                    while (StackIsNotEmpty() && Top().pairIndex != pi) {
	                        Pop();
	                    }
	
	                    if (StackIsNotEmpty()) {
	                        sc = Top().scriptCode;
	                    }
	                }
	            }
	
	            if (SameScript(scriptCode, sc)) {
	                if (scriptCode <= IBM.ICU.Lang.UScript.INHERITED && sc > IBM.ICU.Lang.UScript.INHERITED) {
	                    scriptCode = sc;
	
	                    Fixup(scriptCode);
	                }
	
	                // if this character is a close paired character,
	                // pop the matching open character from the stack
	                if (pairIndex >= 0 && (pairIndex & 1) != 0) {
	                    Pop();
	                }
	            } else {
	                // We've just seen the first character of
	                // the next run. Back over it so we'll see
	                // it again the next time.
	                textIndex -= codePointCount;
	                break;
	            }
	        }
	
	        scriptLimit = textIndex;
	        return true;
	    }
	
	    /// <summary>
	    /// Compare two script codes to see if they are in the same script. If one
	    /// script is a strong script, and the other is INHERITED or COMMON, it will
	    /// compare equal.
	    /// </summary>
	    ///
	    /// <param name="scriptOne">one of the script codes.</param>
	    /// <param name="scriptTwo">the other script code.</param>
	    /// <returns><c>true</c> if the two scripts are the same.</returns>
	    /// <seealso cref="T:IBM.ICU.Lang.UScript"/>
	    private static bool SameScript(int scriptOne, int scriptTwo) {
	        return scriptOne <= IBM.ICU.Lang.UScript.INHERITED || scriptTwo <= IBM.ICU.Lang.UScript.INHERITED
	                || scriptOne == scriptTwo;
	    }
	
	    /*
	     * An internal class which holds entries on the paren stack.
	     */
	    private sealed class ParenStackEntry {
	        internal int pairIndex;
	
	        internal int scriptCode;
	
	        public ParenStackEntry(int thePairIndex, int theScriptCode) {
	            pairIndex = thePairIndex;
	            scriptCode = theScriptCode;
	        }
	    }
	
	    private static int Mod(int sp) {
	        return sp % PAREN_STACK_DEPTH;
	    }
	
	    private static int Inc(int sp, int count) {
	        return Mod(sp + count);
	    }
	
	    private static int Inc(int sp) {
	        return Inc(sp, 1);
	    }
	
	    private static int Dec(int sp, int count) {
	        return Mod(sp + PAREN_STACK_DEPTH - count);
	    }
	
	    private static int Dec(int sp) {
	        return Dec(sp, 1);
	    }
	
	    private static int LimitInc(int count) {
	        if (count < PAREN_STACK_DEPTH) {
	            count += 1;
	        }
	
	        return count;
	    }
	
	    private bool StackIsEmpty() {
	        return pushCount <= 0;
	    }
	
	    private bool StackIsNotEmpty() {
	        return !StackIsEmpty();
	    }
	
	    private void Push(int pairIndex_0, int scriptCode_1) {
	        pushCount = LimitInc(pushCount);
	        fixupCount = LimitInc(fixupCount);
	
	        parenSP = Inc(parenSP);
	        parenStack[parenSP] = new UScriptRun.ParenStackEntry (pairIndex_0, scriptCode_1);
	    }
	
	    private void Pop() {
	
	        if (StackIsEmpty()) {
	            return;
	        }
	
	        parenStack[parenSP] = null;
	
	        if (fixupCount > 0) {
	            fixupCount -= 1;
	        }
	
	        pushCount -= 1;
	        parenSP = Dec(parenSP);
	
	        // If the stack is now empty, reset the stack
	        // pointers to their initial values.
	        if (StackIsEmpty()) {
	            parenSP = -1;
	        }
	    }
	
	    private UScriptRun.ParenStackEntry  Top() {
	        return parenStack[parenSP];
	    }
	
	    private void SyncFixup() {
	        fixupCount = 0;
	    }
	
	    private void Fixup(int scriptCode_0) {
	        int fixupSP = Dec(parenSP, fixupCount);
	
	        while (fixupCount-- > 0) {
	            fixupSP = Inc(fixupSP);
	            parenStack[fixupSP].scriptCode = scriptCode_0;
	        }
	    }
	
	    private char[] emptyCharArray;
	
	    private char[] text;
	
	    private int textIndex;
	
	    private int textStart;
	
	    private int textLimit;
	
	    private int scriptStart;
	
	    private int scriptLimit;
	
	    private int scriptCode;
	
	    private static int PAREN_STACK_DEPTH = 32;
	
	    private static UScriptRun.ParenStackEntry [] parenStack = new UScriptRun.ParenStackEntry [PAREN_STACK_DEPTH];
	
	    private int parenSP;
	
	    private int pushCount;
	
	    private int fixupCount;
	
	    /// <summary>
	    /// Find the highest bit that's set in a word. Uses a binary search through
	    /// the bits.
	    /// </summary>
	    ///
	    /// <param name="n">the word in which to find the highest bit that's set.</param>
	    /// <returns>the bit number (counting from the low order bit) of the highest
	    /// bit.</returns>
	    private static sbyte HighBit(int n) {
	        if (n <= 0) {
	            return -32;
	        }
	
	        sbyte bit = 0;
	
	        if (n >= 1 << 16) {
	            n >>= 16;
	            bit += 16;
	        }
	
	        if (n >= 1 << 8) {
	            n >>= 8;
	            bit += 8;
	        }
	
	        if (n >= 1 << 4) {
	            n >>= 4;
	            bit += 4;
	        }
	
	        if (n >= 1 << 2) {
	            n >>= 2;
	            bit += 2;
	        }
	
	        if (n >= 1 << 1) {
	            n >>= 1;
	            bit += 1;
	        }
	
	        return bit;
	    }
	
	    /// <summary>
	    /// Search the pairedChars array for the given character.
	    /// </summary>
	    ///
	    /// <param name="ch">the character for which to search.</param>
	    /// <returns>the index of the character in the table, or -1 if it's not there.</returns>
	    private static int GetPairIndex(int ch) {
	        int probe = pairedCharPower;
	        int index = 0;
	
	        if (ch >= pairedChars[pairedCharExtra]) {
	            index = pairedCharExtra;
	        }
	
	        while (probe > (1 << 0)) {
	            probe >>= 1;
	
	            if (ch >= pairedChars[index + probe]) {
	                index += probe;
	            }
	        }
	
	        if (pairedChars[index] != ch) {
	            index = -1;
	        }
	
	        return index;
	    }
	
	    private static int[] pairedChars = { 0x0028, 0x0029, 0x003c, 0x003e,
	            0x005b, 0x005d, 0x007b, 0x007d, 0x00ab, 0x00bb, 0x2018, 0x2019,
	            0x201c, 0x201d, 0x2039, 0x203a, 0x3008, 0x3009, 0x300a, 0x300b,
	            0x300c, 0x300d, 0x300e, 0x300f, 0x3010, 0x3011, 0x3014, 0x3015,
	            0x3016, 0x3017, 0x3018, 0x3019, 0x301a, 0x301b };
	
	    private static int pairedCharPower = 1 << HighBit(pairedChars.Length);
	
	    private static int pairedCharExtra = pairedChars.Length - pairedCharPower;
	}
}
