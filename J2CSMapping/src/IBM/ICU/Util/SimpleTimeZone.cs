/*
 *   Copyright (C) 1996-2007, International Business Machines
 *   Corporation and others.  All Rights Reserved.
 */

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:48 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Util {
	
	using ILOG.J2CsMapping.IO;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	
	/// <summary>
	/// <c>SimpleTimeZone</c> is a concrete subclass of <c>TimeZone</c>
	/// that represents a time zone for use with a Gregorian calendar. This class
	/// does not handle historical changes.
	/// <P>
	/// Use a negative value for <c>dayOfWeekInMonth</c> to indicate that
	/// <c>SimpleTimeZone</c> should count from the end of the month backwards.
	/// For example, Daylight Savings Time ends at the last (dayOfWeekInMonth = -1)
	/// Sunday in October, at 2 AM in standard time.
	/// </summary>
	///
	/// <seealso cref="T:IBM.ICU.Util.Calendar"/>
	/// <seealso cref="T:IBM.ICU.Util.GregorianCalendar"/>
	/// <seealso cref="T:IBM.ICU.Util.TimeZone"/>
	/// @stable ICU 2.0
	public class SimpleTimeZone : BasicTimeZone {
	    private const long serialVersionUID = -7034676239311322769L;
	
	    /// <summary>
	    /// Constant for a mode of start or end time specified as local wall time.
	    /// </summary>
	    ///
	    /// @stable ICU 3.8
	    public const int WALL_TIME = 0;
	
	    /// <summary>
	    /// Constant for a mode of start or end time specified as local standard
	    /// time.
	    /// </summary>
	    ///
	    /// @stable ICU 3.8
	    public const int STANDARD_TIME = 1;
	
	    /// <summary>
	    /// Constant for a mode of start or end time specified as UTC.
	    /// </summary>
	    ///
	    /// @stable ICU 3.8
	    public const int UTC_TIME = 2;
	
	    /// <summary>
	    /// Constructs a SimpleTimeZone with the given base time zone offset from GMT
	    /// and time zone ID. Timezone IDs can be obtained from
	    /// TimeZone.getAvailableIDs. Normally you should use TimeZone.getDefault to
	    /// construct a TimeZone.
	    /// </summary>
	    ///
	    /// <param name="rawOffset">The given base time zone offset to GMT.</param>
	    /// <param name="ID">The time zone ID which is obtained fromTimeZone.getAvailableIDs.</param>
	    /// @stable ICU 2.0
	    public SimpleTimeZone(int rawOffset, String ID) {
	        this.dst = 3600000;
	        this.xinfo = null;
	        Construct(rawOffset, 0, 0, 0, 0, WALL_TIME, 0, 0, 0, 0, WALL_TIME,
	                IBM.ICU.Impl.Grego.MILLIS_PER_HOUR);
	        base.SetID(ID);
	    }
	
	    /// <summary>
	    /// Construct a SimpleTimeZone with the given base time zone offset from GMT,
	    /// time zone ID, time to start and end the daylight time. Timezone IDs can
	    /// be obtained from TimeZone.getAvailableIDs. Normally you should use
	    /// TimeZone.getDefault to create a TimeZone. For a time zone that does not
	    /// use daylight saving time, do not use this constructor; instead you should
	    /// use SimpleTimeZone(rawOffset, ID).
	    /// By default, this constructor specifies day-of-week-in-month rules. That
	    /// is, if the startDay is 1, and the startDayOfWeek is SUNDAY, then this
	    /// indicates the first Sunday in the startMonth. A startDay of -1 likewise
	    /// indicates the last Sunday. However, by using negative or zero values for
	    /// certain parameters, other types of rules can be specified.
	    /// Day of month. To specify an exact day of the month, such as March 1, set
	    /// startDayOfWeek to zero.
	    /// Day of week after day of month. To specify the first day of the week
	    /// occurring on or after an exact day of the month, make the day of the week
	    /// negative. For example, if startDay is 5 and startDayOfWeek is -MONDAY,
	    /// this indicates the first Monday on or after the 5th day of the
	    /// startMonth.
	    /// Day of week before day of month. To specify the last day of the week
	    /// occurring on or before an exact day of the month, make the day of the
	    /// week and the day of the month negative. For example, if startDay is -21
	    /// and startDayOfWeek is -WEDNESDAY, this indicates the last Wednesday on or
	    /// before the 21st of the startMonth.
	    /// The above examples refer to the startMonth, startDay, and startDayOfWeek;
	    /// the same applies for the endMonth, endDay, and endDayOfWeek.
	    /// </summary>
	    ///
	    /// <param name="rawOffset">The given base time zone offset to GMT.</param>
	    /// <param name="ID">The time zone ID which is obtained fromTimeZone.getAvailableIDs.</param>
	    /// <param name="startMonth">The daylight savings starting month. Month is 0-based. eg, 0for January.</param>
	    /// <param name="startDay">The daylight savings starting day-of-week-in-month. Please seethe member description for an example.</param>
	    /// <param name="startDayOfWeek">The daylight savings starting day-of-week. Please see themember description for an example.</param>
	    /// <param name="startTime">The daylight savings starting time in local wall time, whichis standard time in this case. Please see the memberdescription for an example.</param>
	    /// <param name="endMonth">The daylight savings ending month. Month is 0-based. eg, 0 forJanuary.</param>
	    /// <param name="endDay">The daylight savings ending day-of-week-in-month. Please seethe member description for an example.</param>
	    /// <param name="endDayOfWeek">The daylight savings ending day-of-week. Please see the memberdescription for an example.</param>
	    /// <param name="endTime">The daylight savings ending time in local wall time, which isdaylight time in this case. Please see the member descriptionfor an example.</param>
	    /// <exception cref="IllegalArgumentException">the month, day, dayOfWeek, or time parameters are out ofrange for the start or end rule</exception>
	    /// @stable ICU 2.0
	    public SimpleTimeZone(int rawOffset, String ID, int startMonth,
	            int startDay, int startDayOfWeek, int startTime, int endMonth,
	            int endDay, int endDayOfWeek, int endTime) {
	        this.dst = 3600000;
	                this.xinfo = null;
	        Construct(rawOffset, startMonth, startDay, startDayOfWeek, startTime,
	                WALL_TIME, endMonth, endDay, endDayOfWeek, endTime, WALL_TIME,
	                IBM.ICU.Impl.Grego.MILLIS_PER_HOUR);
	        base.SetID(ID);
	    }
	
	    /// <summary>
	    /// Construct a SimpleTimeZone with the given base time zone offset from GMT,
	    /// time zone ID, time and its mode to start and end the daylight time. The
	    /// mode specifies either <see cref="F:IBM.ICU.Util.SimpleTimeZone.WALL_TIME"/> or <see cref="F:IBM.ICU.Util.SimpleTimeZone.STANDARD_TIME"/> or<see cref="F:IBM.ICU.Util.SimpleTimeZone.UTC_TIME"/>.
	    /// </summary>
	    ///
	    /// <param name="rawOffset">The given base time zone offset to GMT.</param>
	    /// <param name="ID">The time zone ID which is obtained fromTimeZone.getAvailableIDs.</param>
	    /// <param name="startMonth">The daylight savings starting month. Month is 0-based. eg, 0for January.</param>
	    /// <param name="startDay">The daylight savings starting day-of-week-in-month. Please seethe member description for an example.</param>
	    /// <param name="startDayOfWeek">The daylight savings starting day-of-week. Please see themember description for an example.</param>
	    /// <param name="startTime">The daylight savings starting time in local wall time, whichis standard time in this case. Please see the memberdescription for an example.</param>
	    /// <param name="startTimeMode">The mode of the start time specified by startTime.</param>
	    /// <param name="endMonth">The daylight savings ending month. Month is 0-based. eg, 0 forJanuary.</param>
	    /// <param name="endDay">The daylight savings ending day-of-week-in-month. Please seethe member description for an example.</param>
	    /// <param name="endDayOfWeek">The daylight savings ending day-of-week. Please see the memberdescription for an example.</param>
	    /// <param name="endTime">The daylight savings ending time in local wall time, which isdaylight time in this case. Please see the member descriptionfor an example.</param>
	    /// <param name="endTimeMode">The mode of the end time specified by endTime.</param>
	    /// <param name="dstSavings">The amount of time in ms saved during DST.</param>
	    /// <exception cref="IllegalArgumentException">the month, day, dayOfWeek, or time parameters are out ofrange for the start or end rule</exception>
	    /// @stable ICU 3.8
	    public SimpleTimeZone(int rawOffset, String ID, int startMonth,
	            int startDay, int startDayOfWeek, int startTime, int startTimeMode,
	            int endMonth, int endDay, int endDayOfWeek, int endTime,
	            int endTimeMode, int dstSavings) {
	        this.dst = 3600000;
	                this.xinfo = null;
	        Construct(rawOffset, startMonth, startDay, startDayOfWeek, startTime,
	                startTimeMode, endMonth, endDay, endDayOfWeek, endTime,
	                endTimeMode, dstSavings);
	        base.SetID(ID);
	    }
	
	    /// <summary>
	    /// Constructor. This constructor is identical to the 10-argument
	    /// constructor, but also takes a dstSavings parameter.
	    /// </summary>
	    ///
	    /// <param name="rawOffset">The given base time zone offset to GMT.</param>
	    /// <param name="ID">The time zone ID which is obtained fromTimeZone.getAvailableIDs.</param>
	    /// <param name="startMonth">The daylight savings starting month. Month is 0-based. eg, 0for January.</param>
	    /// <param name="startDay">The daylight savings starting day-of-week-in-month. Please seethe member description for an example.</param>
	    /// <param name="startDayOfWeek">The daylight savings starting day-of-week. Please see themember description for an example.</param>
	    /// <param name="startTime">The daylight savings starting time in local wall time, whichis standard time in this case. Please see the memberdescription for an example.</param>
	    /// <param name="endMonth">The daylight savings ending month. Month is 0-based. eg, 0 forJanuary.</param>
	    /// <param name="endDay">The daylight savings ending day-of-week-in-month. Please seethe member description for an example.</param>
	    /// <param name="endDayOfWeek">The daylight savings ending day-of-week. Please see the memberdescription for an example.</param>
	    /// <param name="endTime">The daylight savings ending time in local wall time, which isdaylight time in this case. Please see the member descriptionfor an example.</param>
	    /// <param name="dstSavings">The amount of time in ms saved during DST.</param>
	    /// <exception cref="IllegalArgumentException">the month, day, dayOfWeek, or time parameters are out ofrange for the start or end rule</exception>
	    /// @stable ICU 2.0
	    public SimpleTimeZone(int rawOffset, String ID, int startMonth,
	            int startDay, int startDayOfWeek, int startTime, int endMonth,
	            int endDay, int endDayOfWeek, int endTime, int dstSavings) {
	        this.dst = 3600000;
	                this.xinfo = null;
	        Construct(rawOffset, startMonth, startDay, startDayOfWeek, startTime,
	                WALL_TIME, endMonth, endDay, endDayOfWeek, endTime, WALL_TIME,
	                dstSavings);
	        base.SetID(ID);
	    }
	
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    /// @stable ICU 3.8
	    public override void SetID(String ID) {
	        base.SetID(ID);
	
	        transitionRulesInitialized = false;
	    }
	
	    /// <summary>
	    /// Overrides TimeZone Sets the base time zone offset to GMT. This is the
	    /// offset to add "to" UTC to get local time.
	    /// </summary>
	    ///
	    /// <param name="offsetMillis">the raw offset of the time zone</param>
	    /// @stable ICU 2.0
	    public override void SetRawOffset(int offsetMillis) {
	        raw = offsetMillis;
	
	        transitionRulesInitialized = false;
	    }
	
	    /// <summary>
	    /// Overrides TimeZone Gets the GMT offset for this time zone.
	    /// </summary>
	    ///
	    /// <returns>the raw offset</returns>
	    /// @stable ICU 2.0
	    public override int GetRawOffset() {
	        return raw;
	    }
	
	    /// <summary>
	    /// Sets the daylight savings starting year.
	    /// </summary>
	    ///
	    /// <param name="year">The daylight savings starting year.</param>
	    /// @stable ICU 2.0
	    public void SetStartYear(int year) {
	        // unwrapSTZ().setStartYear(year);
	
	        GetSTZInfo().sy = year;
	        this.startYear = year;
	
	        transitionRulesInitialized = false;
	    }
	
	    /// <summary>
	    /// Sets the daylight savings starting rule. For example, Daylight Savings
	    /// Time starts at the first Sunday in April, at 2 AM in standard time.
	    /// Therefore, you can set the start rule by calling:
	    /// setStartRule(TimeFields.APRIL, 1, TimeFields.SUNDAY, 2///60///60///1000);
	    /// </summary>
	    ///
	    /// <param name="month">The daylight savings starting month. Month is 0-based. eg, 0for January.</param>
	    /// <param name="dayOfWeekInMonth">The daylight savings starting day-of-week-in-month. Please seethe member description for an example.</param>
	    /// <param name="dayOfWeek">The daylight savings starting day-of-week. Please see themember description for an example.</param>
	    /// <param name="time">The daylight savings starting time in local wall time, whichis standard time in this case. Please see the memberdescription for an example.</param>
	    /// <exception cref="IllegalArgumentException">the month, dayOfWeekInMonth, dayOfWeek, or time parametersare out of range</exception>
	    /// @stable ICU 2.0
	    public void SetStartRule(int month, int dayOfWeekInMonth, int dayOfWeek,
	            int time) {
	        GetSTZInfo().SetStart(month, dayOfWeekInMonth, dayOfWeek, time, -1,
	                false);
	        SetStartRule(month, dayOfWeekInMonth, dayOfWeek, time, WALL_TIME);
	    }
	
	    /// <summary>
	    /// Sets the daylight savings starting rule. For example, in the U.S.,
	    /// Daylight Savings Time starts at the first Sunday in April, at 2 AM in
	    /// standard time. Therefore, you can set the start rule by calling:
	    /// setStartRule(TimeFields.APRIL, 1, TimeFields.SUNDAY, 2///60///60///1000); The
	    /// dayOfWeekInMonth and dayOfWeek parameters together specify how to
	    /// calculate the exact starting date. Their exact meaning depend on their
	    /// respective signs, allowing various types of rules to be constructed, as
	    /// follows:
	    /// <ul>
	    /// <li>If both dayOfWeekInMonth and dayOfWeek are positive, they specify the
	    /// day of week in the month (e.g., (2, WEDNESDAY) is the second Wednesday of
	    /// the month).
	    /// <li>If dayOfWeek is positive and dayOfWeekInMonth is negative, they
	    /// specify the day of week in the month counting backward from the end of
	    /// the month. (e.g., (-1, MONDAY) is the last Monday in the month)
	    /// <li>If dayOfWeek is zero and dayOfWeekInMonth is positive,
	    /// dayOfWeekInMonth specifies the day of the month, regardless of what day
	    /// of the week it is. (e.g., (10, 0) is the tenth day of the month)
	    /// <li>If dayOfWeek is zero and dayOfWeekInMonth is negative,
	    /// dayOfWeekInMonth specifies the day of the month counting backward from
	    /// the end of the month, regardless of what day of the week it is (e.g.,
	    /// (-2, 0) is the next-to-last day of the month).
	    /// <li>If dayOfWeek is negative and dayOfWeekInMonth is positive, they
	    /// specify the first specified day of the week on or after the specfied day
	    /// of the month. (e.g., (15, -SUNDAY) is the first Sunday after the 15th of
	    /// the month [or the 15th itself if the 15th is a Sunday].)
	    /// <li>If dayOfWeek and DayOfWeekInMonth are both negative, they specify the
	    /// last specified day of the week on or before the specified day of the
	    /// month. (e.g., (-20, -TUESDAY) is the last Tuesday before the 20th of the
	    /// month [or the 20th itself if the 20th is a Tuesday].)
	    /// </ul>
	    /// </summary>
	    ///
	    /// <param name="month">the daylight savings starting month. Month is 0-based. eg, 0for January.</param>
	    /// <param name="dayOfWeekInMonth">the daylight savings starting day-of-week-in-month. Please seethe member description for an example.</param>
	    /// <param name="dayOfWeek">the daylight savings starting day-of-week. Please see themember description for an example.</param>
	    /// <param name="time">the daylight savings starting time. Please see the memberdescription for an example.</param>
	
	    private void SetStartRule(int month, int dayOfWeekInMonth, int dayOfWeek,
	            int time, int mode) {
	        startMonth = month;
	        startDay = dayOfWeekInMonth;
	        startDayOfWeek = dayOfWeek;
	        startTime = time;
	        startTimeMode = mode;
	        DecodeStartRule();
	
	        transitionRulesInitialized = false;
	    }
	
	    /// <summary>
	    /// Sets the DST start rule to a fixed date within a month.
	    /// </summary>
	    ///
	    /// <param name="month">The month in which this rule occurs (0-based).</param>
	    /// <param name="dayOfMonth">The date in that month (1-based).</param>
	    /// <param name="time">The time of that day (number of millis after midnight) whenDST takes effect in local wall time, which is standard time inthis case.</param>
	    /// <exception cref="IllegalArgumentException">the month, dayOfMonth, or time parameters are out of range</exception>
	    /// @stable ICU 2.0
	    public void SetStartRule(int month, int dayOfMonth, int time) {
	        // unwrapSTZ().setStartRule(month, dayOfMonth, time);
	
	        GetSTZInfo().SetStart(month, -1, -1, time, dayOfMonth, false);
	        SetStartRule(month, dayOfMonth, 0, time, WALL_TIME);
	    }
	
	    /// <summary>
	    /// Sets the DST start rule to a weekday before or after a give date within a
	    /// month, e.g., the first Monday on or after the 8th.
	    /// </summary>
	    ///
	    /// <param name="month">The month in which this rule occurs (0-based).</param>
	    /// <param name="dayOfMonth">A date within that month (1-based).</param>
	    /// <param name="dayOfWeek">The day of the week on which this rule occurs.</param>
	    /// <param name="time">The time of that day (number of millis after midnight) whenDST takes effect in local wall time, which is standard time inthis case.</param>
	    /// <param name="after">If true, this rule selects the first dayOfWeek on or afterdayOfMonth. If false, this rule selects the last dayOfWeek onor before dayOfMonth.</param>
	    /// <exception cref="IllegalArgumentException">the month, dayOfMonth, dayOfWeek, or time parameters areout of range</exception>
	    /// @stable ICU 2.0
	    public void SetStartRule(int month, int dayOfMonth, int dayOfWeek,
	            int time, bool after) {
	        GetSTZInfo().SetStart(month, -1, dayOfWeek, time, dayOfMonth, after);
	        SetStartRule(month, (after) ? dayOfMonth : -dayOfMonth, -dayOfWeek, time,
	                WALL_TIME);
	    }
	
	    /// <summary>
	    /// Sets the daylight savings ending rule. For example, Daylight Savings Time
	    /// ends at the last (-1) Sunday in October, at 2 AM in standard time.
	    /// Therefore, you can set the end rule by calling:
	    /// setEndRule(TimeFields.OCTOBER, -1, TimeFields.SUNDAY, 2///60///60///1000);
	    /// </summary>
	    ///
	    /// <param name="month">The daylight savings ending month. Month is 0-based. eg, 0 forJanuary.</param>
	    /// <param name="dayOfWeekInMonth">The daylight savings ending day-of-week-in-month. Please seethe member description for an example.</param>
	    /// <param name="dayOfWeek">The daylight savings ending day-of-week. Please see the memberdescription for an example.</param>
	    /// <param name="time">The daylight savings ending time in local wall time, which isdaylight time in this case. Please see the member descriptionfor an example.</param>
	    /// <exception cref="IllegalArgumentException">the month, dayOfWeekInMonth, dayOfWeek, or time parametersare out of range</exception>
	    /// @stable ICU 2.0
	    public void SetEndRule(int month, int dayOfWeekInMonth, int dayOfWeek,
	            int time) {
	        GetSTZInfo()
	                .SetEnd(month, dayOfWeekInMonth, dayOfWeek, time, -1, false);
	        SetEndRule(month, dayOfWeekInMonth, dayOfWeek, time, WALL_TIME);
	    }
	
	    /// <summary>
	    /// Sets the DST end rule to a fixed date within a month.
	    /// </summary>
	    ///
	    /// <param name="month">The month in which this rule occurs (0-based).</param>
	    /// <param name="dayOfMonth">The date in that month (1-based).</param>
	    /// <param name="time">The time of that day (number of millis after midnight) whenDST ends in local wall time, which is daylight time in thiscase.</param>
	    /// <exception cref="IllegalArgumentException">the month, dayOfMonth, or time parameters are out of range</exception>
	    /// @stable ICU 2.0
	    public void SetEndRule(int month, int dayOfMonth, int time) {
	        GetSTZInfo().SetEnd(month, -1, -1, time, dayOfMonth, false);
	        SetEndRule(month, dayOfMonth, WALL_TIME, time);
	    }
	
	    /// <summary>
	    /// Sets the DST end rule to a weekday before or after a give date within a
	    /// month, e.g., the first Monday on or after the 8th.
	    /// </summary>
	    ///
	    /// <param name="month">The month in which this rule occurs (0-based).</param>
	    /// <param name="dayOfMonth">A date within that month (1-based).</param>
	    /// <param name="dayOfWeek">The day of the week on which this rule occurs.</param>
	    /// <param name="time">The time of that day (number of millis after midnight) whenDST ends in local wall time, which is daylight time in thiscase.</param>
	    /// <param name="after">If true, this rule selects the first dayOfWeek on or afterdayOfMonth. If false, this rule selects the last dayOfWeek onor before dayOfMonth.</param>
	    /// <exception cref="IllegalArgumentException">the month, dayOfMonth, dayOfWeek, or time parameters areout of range</exception>
	    /// @stable ICU 2.0
	    public void SetEndRule(int month, int dayOfMonth, int dayOfWeek, int time,
	            bool after) {
	        GetSTZInfo().SetEnd(month, -1, dayOfWeek, time, dayOfMonth, after);
	        SetEndRule(month, dayOfMonth, dayOfWeek, time, WALL_TIME, after);
	    }
	
	    private void SetEndRule(int month, int dayOfMonth, int dayOfWeek, int time,
	            int mode, bool after) {
	        SetEndRule(month, (after) ? dayOfMonth : -dayOfMonth, -dayOfWeek, time,
	                mode);
	    }
	
	    /// <summary>
	    /// Sets the daylight savings ending rule. For example, in the U.S., Daylight
	    /// Savings Time ends at the last (-1) Sunday in October, at 2 AM in standard
	    /// time. Therefore, you can set the end rule by calling:
	    /// setEndRule(TimeFields.OCTOBER, -1, TimeFields.SUNDAY, 2///60///60///1000);
	    /// Various other types of rules can be specified by manipulating the
	    /// dayOfWeek and dayOfWeekInMonth parameters. For complete details, see the
	    /// documentation for setStartRule().
	    /// </summary>
	    ///
	    /// <param name="month">the daylight savings ending month. Month is 0-based. eg, 0 forJanuary.</param>
	    /// <param name="dayOfWeekInMonth">the daylight savings ending day-of-week-in-month. SeesetStartRule() for a complete explanation.</param>
	    /// <param name="dayOfWeek">the daylight savings ending day-of-week. See setStartRule()for a complete explanation.</param>
	    /// <param name="time">the daylight savings ending time. Please see the memberdescription for an example.</param>
	    private void SetEndRule(int month, int dayOfWeekInMonth, int dayOfWeek,
	            int time, int mode) {
	        endMonth = month;
	        endDay = dayOfWeekInMonth;
	        endDayOfWeek = dayOfWeek;
	        endTime = time;
	        endTimeMode = mode;
	        DecodeEndRule();
	
	        transitionRulesInitialized = false;
	    }
	
	    /// <summary>
	    /// Sets the amount of time in ms that the clock is advanced during DST.
	    /// </summary>
	    ///
	    /// <param name="millisSavedDuringDST">the number of milliseconds the time is advanced with respectto standard time when the daylight savings rules are ineffect. A positive number, typically one hour (3600000).</param>
	    /// @stable ICU 2.0
	    public void SetDSTSavings(int millisSavedDuringDST) {
	        if (millisSavedDuringDST <= 0) {
	            throw new ArgumentException();
	        }
	        dst = millisSavedDuringDST;
	
	        transitionRulesInitialized = false;
	    }
	
	    /// <summary>
	    /// Returns the amount of time in ms that the clock is advanced during DST.
	    /// </summary>
	    ///
	    /// <returns>the number of milliseconds the time is advanced with respect to
	    /// standard time when the daylight savings rules are in effect. A
	    /// positive number, typically one hour (3600000).</returns>
	    /// @stable ICU 2.0
	    public override int GetDSTSavings() {
	        return dst;
	    }
	
	    /// <summary>
	    /// Returns the java.util.SimpleTimeZone that this class wraps.
	    /// java.util.SimpleTimeZone unwrapSTZ() { return (java.util.SimpleTimeZone)
	    /// unwrap(); }
	    /// </summary>
	    ///
	    // on JDK 1.4 and later, can't deserialize a SimpleTimeZone as a
	    // SimpleTimeZone...
	    private void ReadObject(IlObjectInputStream ins0) {
	        ins0.DefaultReadObject();
	        /*
	         * String id = getID(); if (id!=null && !(zone instanceof
	         * java.util.SimpleTimeZone && zone.getID().equals(id))) { //
	         * System.out.println("*** readjust " + zone.getClass().getName() + " "
	         * + zone.getID() + " ***"); java.util.SimpleTimeZone stz = new
	         * java.util.SimpleTimeZone(raw, id); if (dst != 0) {
	         * stz.setDSTSavings(dst); // if it is 0, then there shouldn't be
	         * start/end rules and the default // behavior should be no dst }
	         * 
	         * if (xinfo != null) { xinfo.applyTo(stz); } zoneJDK = stz; }
	         */
	        /*
	         * set all instance variables in this object to the values in zone
	         */
	        if (xinfo != null) {
	            xinfo.ApplyTo(this);
	        }
	
	    }
	
	    /// <summary>
	    /// Returns a string representation of this object.
	    /// </summary>
	    ///
	    /// <returns>a string representation of this object</returns>
	    /// @stable ICU 3.6
	    public override String ToString() {
	        return "SimpleTimeZone: " + GetID();
	    }
	
	    private STZInfo GetSTZInfo() {
	        if (xinfo == null) {
	            xinfo = new STZInfo();
	        }
	        return xinfo;
	    }
	
	    private static readonly byte[] staticMonthLength = { 31, 29, 31, 30, 31, 30,
	            31, 31, 30, 31, 30, 31 };
	
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public override int GetOffset(int era, int year, int month, int day, int dayOfWeek,
	            int millis) {
	        // Check the month before calling Grego.monthLength(). This
	        // duplicates the test that occurs in the 7-argument getOffset(),
	        // however, this is unavoidable. We don't mind because this method, in
	        // fact, should not be called; internal code should always call the
	        // 7-argument getOffset(), and outside code should use Calendar.get(int
	        // field) with fields ZONE_OFFSET and DST_OFFSET. We can't get rid of
	        // this method because it's public API. - liu 8/10/98
	        if (month < IBM.ICU.Util.Calendar.JANUARY || month > IBM.ICU.Util.Calendar.DECEMBER) {
	            throw new ArgumentException();
	        }
	
	        return GetOffset(era, year, month, day, dayOfWeek, millis,
	                IBM.ICU.Impl.Grego.MonthLength(year, month));
	    }
	
	    /// <exclude/>
	    public int GetOffset(int era, int year, int month, int day, int dayOfWeek,
	            int millis, int monthLength) {
	        // Check the month before calling Grego.monthLength(). This
	        // duplicates a test that occurs in the 9-argument getOffset(),
	        // however, this is unavoidable. We don't mind because this method, in
	        // fact, should not be called; internal code should always call the
	        // 9-argument getOffset(), and outside code should use Calendar.get(int
	        // field) with fields ZONE_OFFSET and DST_OFFSET. We can't get rid of
	        // this method because it's public API. - liu 8/10/98
	        if (month < IBM.ICU.Util.Calendar.JANUARY || month > IBM.ICU.Util.Calendar.DECEMBER) {
	            throw new ArgumentException();
	        }
	
	        return GetOffset(era, year, month, day, dayOfWeek, millis,
	                IBM.ICU.Impl.Grego.MonthLength(year, month),
	                IBM.ICU.Impl.Grego.PreviousMonthLength(year, month));
	    }
	
	    internal int GetOffset(int era, int year, int month, int day, int dayOfWeek,
	            int millis, int monthLength, int prevMonthLength) {
	
	        if (true) {
	            /*
	             * Use this parameter checking code for normal operation. Only one
	             * of these two blocks should actually get compiled into the class
	             * file.
	             */
	            if ((era != IBM.ICU.Util.GregorianCalendar.AD && era != IBM.ICU.Util.GregorianCalendar.BC)
	                    || month < IBM.ICU.Util.Calendar.JANUARY || month > IBM.ICU.Util.Calendar.DECEMBER
	                    || day < 1 || day > monthLength
	                    || dayOfWeek < IBM.ICU.Util.Calendar.SUNDAY
	                    || dayOfWeek > IBM.ICU.Util.Calendar.SATURDAY || millis < 0
	                    || millis >= IBM.ICU.Impl.Grego.MILLIS_PER_DAY || monthLength < 28
	                    || monthLength > 31 || prevMonthLength < 28
	                    || prevMonthLength > 31) {
	                throw new ArgumentException();
	            }
	        } else {
	            /*
	             * This parameter checking code is better for debugging, but
	             * overkill for normal operation. Only one of these two blocks
	             * should actually get compiled into the class file.
	             */
	            if (era != IBM.ICU.Util.GregorianCalendar.AD && era != IBM.ICU.Util.GregorianCalendar.BC) {
	                throw new ArgumentException("Illegal era " + era);
	            }
	            if (month < IBM.ICU.Util.Calendar.JANUARY || month > IBM.ICU.Util.Calendar.DECEMBER) {
	                throw new ArgumentException("Illegal month " + month);
	            }
	            if (day < 1 || day > monthLength) {
	                throw new ArgumentException("Illegal day " + day
	                        + " max month len: " + monthLength);
	            }
	            if (dayOfWeek < IBM.ICU.Util.Calendar.SUNDAY || dayOfWeek > IBM.ICU.Util.Calendar.SATURDAY) {
	                throw new ArgumentException("Illegal day of week "
	                        + dayOfWeek);
	            }
	            if (millis < 0 || millis >= IBM.ICU.Impl.Grego.MILLIS_PER_DAY) {
	                throw new ArgumentException("Illegal millis " + millis);
	            }
	            if (monthLength < 28 || monthLength > 31) {
	                throw new ArgumentException("Illegal month length "
	                        + monthLength);
	            }
	            if (prevMonthLength < 28 || prevMonthLength > 31) {
	                throw new ArgumentException(
	                        "Illegal previous month length " + prevMonthLength);
	            }
	        }
	
	        int result = raw;
	
	        // Bail out if we are before the onset of daylight savings time
	        if (!useDaylight || year < startYear || era != IBM.ICU.Util.GregorianCalendar.AD)
	            return result;
	
	        // Check for southern hemisphere. We assume that the start and end
	        // month are different.
	        bool southern = (startMonth > endMonth);
	
	        // Compare the date to the starting and ending rules.+1 = date>rule, -1
	        // = date<rule, 0 = date==rule.
	        int startCompare = CompareToRule(month, monthLength, prevMonthLength,
	                day, dayOfWeek, millis, (startTimeMode == UTC_TIME) ? -raw : 0,
	                startMode, startMonth, startDayOfWeek, startDay, startTime);
	        int endCompare = 0;
	
	        /*
	         * We don't always have to compute endCompare. For many instances,
	         * startCompare is enough to determine if we are in DST or not. In the
	         * northern hemisphere, if we are before the start rule, we can't have
	         * DST. In the southern hemisphere, if we are after the start rule, we
	         * must have DST. This is reflected in the way the next if statement
	         * (not the one immediately following) short circuits.
	         */
	        if (southern != (startCompare >= 0)) {
	            /*
	             * For the ending rule comparison, we add the dstSavings to the
	             * millis passed in to convert them from standard to wall time. We
	             * then must normalize the millis to the range 0..millisPerDay-1.
	             */
	            endCompare = CompareToRule(month, monthLength, prevMonthLength,
	                    day, dayOfWeek, millis, (endTimeMode == WALL_TIME) ? dst
	                            : ((endTimeMode == UTC_TIME) ? -raw : 0), endMode,
	                    endMonth, endDayOfWeek, endDay, endTime);
	        }
	
	        // Check for both the northern and southern hemisphere cases. We
	        // assume that in the northern hemisphere, the start rule is before the
	        // end rule within the calendar year, and vice versa for the southern
	        // hemisphere.
	        if ((!southern && (startCompare >= 0 && endCompare < 0))
	                || (southern && (startCompare >= 0 || endCompare < 0)))
	            result += dst;
	
	        return result;
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    public override void GetOffsetFromLocal(long date, int nonExistingTimeOpt,
	            int duplicatedTimeOpt, int[] offsets) {
	        offsets[0] = GetRawOffset();
	        int[] fields = new int[4];
	        long day = IBM.ICU.Util.TimeZone.FloorDivide(date, IBM.ICU.Impl.Grego.MILLIS_PER_DAY, fields);
	        int millis = fields[0];
	
	        IBM.ICU.Util.TimeZone.ComputeGregorianFields(day, fields);
	        offsets[1] = GetOffset(IBM.ICU.Util.GregorianCalendar.AD, fields[0], fields[1],
	                fields[2], fields[3], millis) - offsets[0];
	
	        bool recalc = false;
	
	        // Now, we need some adjustment
	        if (offsets[1] > 0) {
	            if ((nonExistingTimeOpt & IBM.ICU.Util.BasicTimeZone.STD_DST_MASK) == IBM.ICU.Util.BasicTimeZone.LOCAL_STD
	                    || (nonExistingTimeOpt & IBM.ICU.Util.BasicTimeZone.STD_DST_MASK) != IBM.ICU.Util.BasicTimeZone.LOCAL_DST
	                    && (nonExistingTimeOpt & IBM.ICU.Util.BasicTimeZone.FORMER_LATTER_MASK) != IBM.ICU.Util.BasicTimeZone.LOCAL_LATTER) {
	                date -= GetDSTSavings();
	                recalc = true;
	            }
	        } else {
	            if ((duplicatedTimeOpt & IBM.ICU.Util.BasicTimeZone.STD_DST_MASK) == IBM.ICU.Util.BasicTimeZone.LOCAL_DST
	                    || (duplicatedTimeOpt & IBM.ICU.Util.BasicTimeZone.STD_DST_MASK) != IBM.ICU.Util.BasicTimeZone.LOCAL_STD
	                    && (duplicatedTimeOpt & IBM.ICU.Util.BasicTimeZone.FORMER_LATTER_MASK) == IBM.ICU.Util.BasicTimeZone.LOCAL_FORMER) {
	                date -= GetDSTSavings();
	                recalc = true;
	            }
	        }
	
	        if (recalc) {
	            day = IBM.ICU.Util.TimeZone.FloorDivide(date, IBM.ICU.Impl.Grego.MILLIS_PER_DAY, fields);
	            millis = fields[0];
	            IBM.ICU.Util.TimeZone.ComputeGregorianFields(day, fields);
	            offsets[1] = GetOffset(IBM.ICU.Util.GregorianCalendar.AD, fields[0], fields[1],
	                    fields[2], fields[3], millis) - offsets[0];
	        }
	    }
	
	    private const int DOM_MODE = 1, DOW_IN_MONTH_MODE = 2,
	            DOW_GE_DOM_MODE = 3, DOW_LE_DOM_MODE = 4;
	
	    /// <summary>
	    /// Compare a given date in the year to a rule. Return 1, 0, or -1, depending
	    /// on whether the date is after, equal to, or before the rule date. The
	    /// millis are compared directly against the ruleMillis, so any
	    /// standard-daylight adjustments must be handled by the caller.
	    /// </summary>
	    ///
	    /// <returns>1 if the date is after the rule date, -1 if the date is before
	    /// the rule date, or 0 if the date is equal to the rule date.</returns>
	    private int CompareToRule(int month, int monthLen, int prevMonthLen,
	            int dayOfMonth, int dayOfWeek, int millis, int millisDelta,
	            int ruleMode, int ruleMonth, int ruleDayOfWeek, int ruleDay,
	            int ruleMillis) {
	        // Make adjustments for startTimeMode and endTimeMode
	
	        millis += millisDelta;
	
	        while (millis >= IBM.ICU.Impl.Grego.MILLIS_PER_DAY) {
	            millis -= IBM.ICU.Impl.Grego.MILLIS_PER_DAY;
	            ++dayOfMonth;
	            dayOfWeek = 1 + (dayOfWeek % 7); // dayOfWeek is one-based
	            if (dayOfMonth > monthLen) {
	                dayOfMonth = 1;
	                /*
	                 * When incrementing the month, it is desirable to overflow from
	                 * DECEMBER to DECEMBER+1, since we use the result to compare
	                 * against a real month. Wraparound of the value leads to bug
	                 * 4173604.
	                 */
	                ++month;
	            }
	        }
	        /*
	         * For some reasons, Sun Java 6 on Solaris/Linux has a problem with the
	         * while loop below (at least Java 6 up to build 1.6.0_02-b08). It looks
	         * the JRE messes up the variable 'millis' while executing the code in
	         * the while block. The problem is not reproduced with JVM option -Xint,
	         * that is, it is likely a bug of the HotSpot adaptive compiler. Moving
	         * 'millis += Grego.MILLIS_PER_DAY' to the end of this while block seems
	         * to resolve the problem. See ticket#5887 about the problem in detail.
	         */
	        while (millis < 0) {
	            // millis += Grego.MILLIS_PER_DAY;
	            --dayOfMonth;
	            dayOfWeek = 1 + ((dayOfWeek + 5) % 7); // dayOfWeek is one-based
	            if (dayOfMonth < 1) {
	                dayOfMonth = prevMonthLen;
	                --month;
	            }
	            millis += IBM.ICU.Impl.Grego.MILLIS_PER_DAY;
	        }
	
	        if (month < ruleMonth)
	            return -1;
	        else if (month > ruleMonth)
	            return 1;
	
	        int ruleDayOfMonth = 0;
	
	        // Adjust the ruleDay to the monthLen, for non-leap year February 29
	        // rule days.
	        if (ruleDay > monthLen) {
	            ruleDay = monthLen;
	        }
	
	        switch (ruleMode) {
	        case DOM_MODE:
	            ruleDayOfMonth = ruleDay;
	            break;
	        case DOW_IN_MONTH_MODE:
	            // In this case ruleDay is the day-of-week-in-month
	            if (ruleDay > 0)
	                ruleDayOfMonth = 1 + (ruleDay - 1) * 7
	                        + (7 + ruleDayOfWeek - (dayOfWeek - dayOfMonth + 1))
	                        % 7;
	            else // Assume ruleDay < 0 here
	            {
	                ruleDayOfMonth = monthLen
	                        + (ruleDay + 1)
	                        * 7
	                        - (7 + (dayOfWeek + monthLen - dayOfMonth) - ruleDayOfWeek)
	                        % 7;
	            }
	            break;
	        case DOW_GE_DOM_MODE:
	            ruleDayOfMonth = ruleDay
	                    + (49 + ruleDayOfWeek - ruleDay - dayOfWeek + dayOfMonth)
	                    % 7;
	            break;
	        case DOW_LE_DOM_MODE:
	            ruleDayOfMonth = ruleDay
	                    - (49 - ruleDayOfWeek + ruleDay + dayOfWeek - dayOfMonth)
	                    % 7;
	            // Note at this point ruleDayOfMonth may be <1, although it will
	            // be >=1 for well-formed rules.
	            break;
	        }
	
	        if (dayOfMonth < ruleDayOfMonth)
	            return -1;
	        else if (dayOfMonth > ruleDayOfMonth)
	            return 1;
	
	        if (millis < ruleMillis) {
	            return -1;
	        } else if (millis > ruleMillis) {
	            return 1;
	        } else {
	            return 0;
	        }
	    }
	
	    // data needed for streaming mutated SimpleTimeZones in JDK14
	    private int raw;// the TimeZone's raw GMT offset
	
	    private int dst;
	
	    private STZInfo xinfo;
	
	    private int startMonth, startDay, startDayOfWeek; // the month, day, DOW,
	                                                      // and time DST starts
	
	    private int startTime;
	
	    private int startTimeMode, endTimeMode; // Mode for startTime, endTime; see
	                                            // TimeMode
	
	    private int endMonth, endDay, endDayOfWeek; // the month, day, DOW, and time
	                                                // DST ends
	
	    private int endTime;
	
	    private int startYear; // the year these DST rules took effect
	
	    private bool useDaylight; // flag indicating whether this TimeZone uses
	                                 // DST
	
	    private int startMode, endMode; // flags indicating what kind of rules the
	                                    // DST rules are
	
	    /// <summary>
	    /// Overrides TimeZone Queries if this time zone uses Daylight Saving Time.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public override bool UseDaylightTime() {
	        return useDaylight;
	    }
	
	    /// <summary>
	    /// Overrides TimeZone Queries if the give date is in Daylight Saving Time.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public override bool InDaylightTime(DateTime date) {
	        GregorianCalendar gc = new GregorianCalendar(this);
	        gc.SetTime(date);
	        return gc.InDaylightTime();
	    }
	
	    /// <summary>
	    /// Internal construction method.
	    /// </summary>
	    ///
	    private void Construct(int raw_0, int startMonth_1, int startDay_2,
	            int startDayOfWeek_3, int startTime_4, int startTimeMode_5, int endMonth_6,
	            int endDay_7, int endDayOfWeek_8, int endTime_9, int endTimeMode_10, int dst_11) {
	        this.raw = raw_0;
	        this.startMonth = startMonth_1;
	        this.startDay = startDay_2;
	        this.startDayOfWeek = startDayOfWeek_3;
	        this.startTime = startTime_4;
	        this.startTimeMode = startTimeMode_5;
	        this.endMonth = endMonth_6;
	        this.endDay = endDay_7;
	        this.endDayOfWeek = endDayOfWeek_8;
	        this.endTime = endTime_9;
	        this.endTimeMode = endTimeMode_10;
	        this.dst = dst_11;
	        this.startYear = 0;
	        this.startMode = DOM_MODE;
	        this.endMode = DOM_MODE;
	
	        DecodeRules();
	
	        if (dst_11 <= 0) {
	            throw new ArgumentException();
	        }
	    }
	
	    private void DecodeRules() {
	        DecodeStartRule();
	        DecodeEndRule();
	    }
	
	    /// <summary>
	    /// Decode the start rule and validate the parameters. The parameters are
	    /// expected to be in encoded form, which represents the various rule modes
	    /// by negating or zeroing certain values. Representation formats are:
	    /// <p>
	    /// <pre>
	    /// DOW_IN_MONTH  DOM    DOW>=DOM  DOW<=DOM  no DST
	    /// ------------  -----  --------  --------  ----------
	    /// month       0..11        same    same      same     don't care
	    /// day        -5..5         1..31   1..31    -1..-31   0
	    /// dayOfWeek   1..7         0      -1..-7    -1..-7    don't care
	    /// time        0..ONEDAY    same    same      same     don't care
	    /// </pre>
	    /// The range for month does not include UNDECIMBER since this class is
	    /// really specific to GregorianCalendar, which does not use that month. The
	    /// range for time includes ONEDAY (vs. ending at ONEDAY-1) because the end
	    /// rule is an exclusive limit point. That is, the range of times that are in
	    /// DST include those >= the start and < the end. For this reason, it should
	    /// be possible to specify an end of ONEDAY in order to include the entire
	    /// day. Although this is equivalent to time 0 of the following day, it's not
	    /// always possible to specify that, for example, on December 31. While
	    /// arguably the start range should still be 0..ONEDAY-1, we keep the start
	    /// and end ranges the same for consistency.
	    /// </summary>
	    ///
	    private void DecodeStartRule() {
	
	        useDaylight = (bool) (((startDay != 0) && (endDay != 0)) ? true
	                : false);
	        if (useDaylight && dst == 0) {
	            dst = IBM.ICU.Impl.Grego.MILLIS_PER_DAY;
	        }
	        if (startDay != 0) {
	            if (startMonth < IBM.ICU.Util.Calendar.JANUARY || startMonth > IBM.ICU.Util.Calendar.DECEMBER) {
	                throw new ArgumentException();
	            }
	            if (startTime < 0 || startTime >= IBM.ICU.Impl.Grego.MILLIS_PER_DAY
	                    || startTimeMode < WALL_TIME || startTimeMode > UTC_TIME) {
	                throw new ArgumentException();
	            }
	            if (startDayOfWeek == 0) {
	                startMode = DOM_MODE;
	            } else {
	                if (startDayOfWeek > 0) {
	                    startMode = DOW_IN_MONTH_MODE;
	                } else {
	                    startDayOfWeek = (int) -startDayOfWeek;
	                    if (startDay > 0) {
	                        startMode = DOW_GE_DOM_MODE;
	                    } else {
	                        startDay = (int) -startDay;
	                        startMode = DOW_LE_DOM_MODE;
	                    }
	                }
	                if (startDayOfWeek > IBM.ICU.Util.Calendar.SATURDAY) {
	                    throw new ArgumentException();
	                }
	            }
	            if (startMode == DOW_IN_MONTH_MODE) {
	                if (startDay < -5 || startDay > 5) {
	                    throw new ArgumentException();
	                }
	            } else if (startDay < 1 || startDay > staticMonthLength[startMonth]) {
	                throw new ArgumentException();
	            }
	        }
	    }
	
	    /// <summary>
	    /// Decode the end rule and validate the parameters. This method is exactly
	    /// analogous to decodeStartRule().
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Util.SimpleTimeZone.DecodeStartRule"/>
	    private void DecodeEndRule() {
	        useDaylight = (bool) (((startDay != 0) && (endDay != 0)) ? true
	                : false);
	        if (useDaylight && dst == 0) {
	            dst = IBM.ICU.Impl.Grego.MILLIS_PER_DAY;
	        }
	        if (endDay != 0) {
	            if (endMonth < IBM.ICU.Util.Calendar.JANUARY || endMonth > IBM.ICU.Util.Calendar.DECEMBER) {
	                throw new ArgumentException();
	            }
	            if (endTime < 0 || endTime > IBM.ICU.Impl.Grego.MILLIS_PER_DAY
	                    || endTimeMode < WALL_TIME || endTimeMode > UTC_TIME) {
	                throw new ArgumentException();
	            }
	            if (endDayOfWeek == 0) {
	                endMode = DOM_MODE;
	            } else {
	                if (endDayOfWeek > 0) {
	                    endMode = DOW_IN_MONTH_MODE;
	                } else {
	                    endDayOfWeek = (int) -endDayOfWeek;
	                    if (endDay > 0) {
	                        endMode = DOW_GE_DOM_MODE;
	                    } else {
	                        endDay = (int) -endDay;
	                        endMode = DOW_LE_DOM_MODE;
	                    }
	                }
	                if (endDayOfWeek > IBM.ICU.Util.Calendar.SATURDAY) {
	                    throw new ArgumentException();
	                }
	            }
	            if (endMode == DOW_IN_MONTH_MODE) {
	                if (endDay < -5 || endDay > 5) {
	                    throw new ArgumentException();
	                }
	            } else if (endDay < 1 || endDay > staticMonthLength[endMonth]) {
	                throw new ArgumentException();
	            }
	        }
	    }
	
	    /// <summary>
	    /// Return true if obj is a SimpleTimeZone equivalent to this.
	    /// </summary>
	    ///
	    /// <returns>true if obj is a SimpleTimeZone equivalent to this</returns>
	    /// @stable ICU 3.6
	    public override bool Equals(Object obj) {
	        if ((Object) this == obj)
	            return true;
	        if (obj == null || (Object) GetType() != (Object) obj.GetType())
	            return false;
	        SimpleTimeZone that = (SimpleTimeZone) obj;
	        return raw == that.raw
	                && useDaylight == that.useDaylight
	                && IdEquals(GetID(), that.GetID())
	                && (!useDaylight
	                // Only check rules if using DST
	                || (dst == that.dst && startMode == that.startMode
	                        && startMonth == that.startMonth
	                        && startDay == that.startDay
	                        && startDayOfWeek == that.startDayOfWeek
	                        && startTime == that.startTime
	                        && startTimeMode == that.startTimeMode
	                        && endMode == that.endMode && endMonth == that.endMonth
	                        && endDay == that.endDay
	                        && endDayOfWeek == that.endDayOfWeek
	                        && endTime == that.endTime
	                        && endTimeMode == that.endTimeMode && startYear == that.startYear));
	
	    }
	
	    private bool IdEquals(String id1, String id2) {
	        if (id1 == null && id2 == null) {
	            return true;
	        }
	        if (id1 != null && id2 != null) {
	            return id1.Equals(id2);
	        }
	        return false;
	    }
	
	    /// <summary>
	    /// Return the hash code.
	    /// </summary>
	    ///
	    /// <returns>the hash code</returns>
	    /// @stable ICU 3.6
	    public override int GetHashCode() {
	        int ret = (int) (base.GetHashCode() + raw ^ ((int) (((uint) raw) >> 8))
	                + ((useDaylight) ? 0 : 1));
	        if (!useDaylight) {
	            ret += (int) (dst ^ ((int) (((uint) dst) >> 10)) + startMode ^ ((int) (((uint) startMode) >> 11))
	                    + startMonth ^ ((int) (((uint) startMonth) >> 12)) + startDay
	                    ^ ((int) (((uint) startDay) >> 13)) + startDayOfWeek
	                    ^ ((int) (((uint) startDayOfWeek) >> 14)) + startTime ^ ((int) (((uint) startTime) >> 15))
	                    + startTimeMode ^ ((int) (((uint) startTimeMode) >> 16)) + endMode
	                    ^ ((int) (((uint) endMode) >> 17)) + endMonth ^ ((int) (((uint) endMonth) >> 18)) + endDay
	                    ^ ((int) (((uint) endDay) >> 19)) + endDayOfWeek ^ ((int) (((uint) endDayOfWeek) >> 20))
	                    + endTime ^ ((int) (((uint) endTime) >> 21)) + endTimeMode
	                    ^ ((int) (((uint) endTimeMode) >> 22)) + startYear ^ ((int) (((uint) startYear) >> 23)));
	        }
	        return ret;
	    }
	
	    /// <summary>
	    /// Return a clone of this time zone.
	    /// </summary>
	    ///
	    /// <returns>a clone of this time zone</returns>
	    /// @stable ICU 3.6
	    public override Object Clone() {
	        return base.Clone();
	    }
	
	    /// <summary>
	    /// Return true if this zone has the same rules and offset as another zone.
	    /// </summary>
	    ///
	    /// <param name="othr">the TimeZone object to be compared with</param>
	    /// <returns>true if the given zone has the same rules and offset as this one</returns>
	    /// @stable ICU 2.0
	    public override bool HasSameRules(TimeZone othr) {
	        if (!(othr  is  SimpleTimeZone)) {
	            return false;
	        }
	        SimpleTimeZone other = (SimpleTimeZone) othr;
	        return other != null
	                && raw == other.raw
	                && useDaylight == other.useDaylight
	                && (!useDaylight
	                // Only check rules if using DST
	                || (dst == other.dst && startMode == other.startMode
	                        && startMonth == other.startMonth
	                        && startDay == other.startDay
	                        && startDayOfWeek == other.startDayOfWeek
	                        && startTime == other.startTime
	                        && startTimeMode == other.startTimeMode
	                        && endMode == other.endMode
	                        && endMonth == other.endMonth && endDay == other.endDay
	                        && endDayOfWeek == other.endDayOfWeek
	                        && endTime == other.endTime
	                        && endTimeMode == other.endTimeMode && startYear == other.startYear));
	    }
	
	    // BasicTimeZone methods
	
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public override TimeZoneTransition GetNextTransition(long bs, bool inclusive) {
	        if (startMonth == 0) {
	            return null;
	        }
	
	        InitTransitionRules();
	        long firstTransitionTime = firstTransition.GetTime();
	        if (bs < firstTransitionTime
	                || (inclusive && bs == firstTransitionTime)) {
	            return firstTransition;
	        }
	        DateTime stdDate = stdRule.GetNextStart(bs, dstRule.GetRawOffset(),
	                dstRule.GetDSTSavings(), inclusive);
	        DateTime dstDate = dstRule.GetNextStart(bs, stdRule.GetRawOffset(),
	                stdRule.GetDSTSavings(), inclusive);
	        if (stdDate != null && (dstDate == null || ILOG.J2CsMapping.Util.DateUtil.Before(stdDate,dstDate))) {
	            return new TimeZoneTransition((stdDate.Ticks/10000), dstRule, stdRule);
	        }
	        if (dstDate != null && (stdDate == null || ILOG.J2CsMapping.Util.DateUtil.Before(dstDate,stdDate))) {
	            return new TimeZoneTransition((dstDate.Ticks/10000), stdRule, dstRule);
	        }
	        return null;
	    }
	
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public override TimeZoneTransition GetPreviousTransition(long bs, bool inclusive) {
	        if (startMonth == 0) {
	            return null;
	        }
	
	        InitTransitionRules();
	        long firstTransitionTime = firstTransition.GetTime();
	        if (bs < firstTransitionTime
	                || (!inclusive && bs == firstTransitionTime)) {
	            return null;
	        }
	        DateTime stdDate = stdRule.GetPreviousStart(bs, dstRule.GetRawOffset(),
	                dstRule.GetDSTSavings(), inclusive);
	        DateTime dstDate = dstRule.GetPreviousStart(bs, stdRule.GetRawOffset(),
	                stdRule.GetDSTSavings(), inclusive);
	        if (stdDate != null && (dstDate == null || ILOG.J2CsMapping.Util.DateUtil.After(stdDate,dstDate))) {
	            return new TimeZoneTransition((stdDate.Ticks/10000), dstRule, stdRule);
	        }
	        if (dstDate != null && (stdDate == null || ILOG.J2CsMapping.Util.DateUtil.After(dstDate,stdDate))) {
	            return new TimeZoneTransition((dstDate.Ticks/10000), stdRule, dstRule);
	        }
	        return null;
	    }
	
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public override TimeZoneRule[] GetTimeZoneRules() {
	        InitTransitionRules();
	
	        int size = (startMonth == 0) ? 1 : 3;
	        TimeZoneRule[] rules = new TimeZoneRule[size];
	        rules[0] = initialRule;
	        if (startMonth != 0) {
	            rules[1] = stdRule;
	            rules[2] = dstRule;
	        }
	        return rules;
	    }
	
	    private bool transitionRulesInitialized;
	
	    private InitialTimeZoneRule initialRule;
	
	    private TimeZoneTransition firstTransition;
	
	    private AnnualTimeZoneRule stdRule;
	
	    private AnnualTimeZoneRule dstRule;
	
	    [MethodImpl(MethodImplOptions.Synchronized)]
	    private void InitTransitionRules() {
	        if (transitionRulesInitialized) {
	            return;
	        }
	        if (startMonth != 0) {
	            DateTimeRule dtRule = null;
	            int timeRuleType;
	            long firstStdStart, firstDstStart;
	
	            // Create a TimeZoneRule for daylight saving time
	            timeRuleType = (startTimeMode == STANDARD_TIME) ? IBM.ICU.Util.DateTimeRule.STANDARD_TIME
	                    : ((startTimeMode == UTC_TIME) ? IBM.ICU.Util.DateTimeRule.UTC_TIME
	                            : IBM.ICU.Util.DateTimeRule.WALL_TIME);
	            switch (startMode) {
	            case DOM_MODE:
	                dtRule = new DateTimeRule(startMonth, startDay, startTime,
	                        timeRuleType);
	                break;
	            case DOW_IN_MONTH_MODE:
	                dtRule = new DateTimeRule(startMonth, startDay, startDayOfWeek,
	                        startTime, timeRuleType);
	                break;
	            case DOW_GE_DOM_MODE:
	                dtRule = new DateTimeRule(startMonth, startDay, startDayOfWeek,
	                        true, startTime, timeRuleType);
	                break;
	            case DOW_LE_DOM_MODE:
	                dtRule = new DateTimeRule(startMonth, startDay, startDayOfWeek,
	                        false, startTime, timeRuleType);
	                break;
	            }
	            // For now, use ID + "(DST)" as the name
	            dstRule = new AnnualTimeZoneRule(GetID() + "(DST)", GetRawOffset(),
	                    GetDSTSavings(), dtRule, startYear,
	                    IBM.ICU.Util.AnnualTimeZoneRule.MAX_YEAR);
	
	            // Calculate the first DST start time
	            firstDstStart = (dstRule.GetFirstStart(GetRawOffset(), 0).Ticks/10000);
	
	            // Create a TimeZoneRule for standard time
	            timeRuleType = (endTimeMode == STANDARD_TIME) ? IBM.ICU.Util.DateTimeRule.STANDARD_TIME
	                    : ((endTimeMode == UTC_TIME) ? IBM.ICU.Util.DateTimeRule.UTC_TIME
	                            : IBM.ICU.Util.DateTimeRule.WALL_TIME);
	            switch (endMode) {
	            case DOM_MODE:
	                dtRule = new DateTimeRule(endMonth, endDay, endTime,
	                        timeRuleType);
	                break;
	            case DOW_IN_MONTH_MODE:
	                dtRule = new DateTimeRule(endMonth, endDay, endDayOfWeek,
	                        endTime, timeRuleType);
	                break;
	            case DOW_GE_DOM_MODE:
	                dtRule = new DateTimeRule(endMonth, endDay, endDayOfWeek, true,
	                        endTime, timeRuleType);
	                break;
	            case DOW_LE_DOM_MODE:
	                dtRule = new DateTimeRule(endMonth, endDay, endDayOfWeek,
	                        false, endTime, timeRuleType);
	                break;
	            }
	            // For now, use ID + "(STD)" as the name
	            stdRule = new AnnualTimeZoneRule(GetID() + "(STD)", GetRawOffset(),
	                    0, dtRule, startYear, IBM.ICU.Util.AnnualTimeZoneRule.MAX_YEAR);
	
	            // Calculate the first STD start time
	            firstStdStart = (stdRule.GetFirstStart(GetRawOffset(),
	                                dstRule.GetDSTSavings()).Ticks/10000);
	
	            // Create a TimeZoneRule for initial time
	            if (firstStdStart < firstDstStart) {
	                initialRule = new InitialTimeZoneRule(GetID() + "(DST)",
	                        GetRawOffset(), dstRule.GetDSTSavings());
	                firstTransition = new TimeZoneTransition(firstStdStart,
	                        initialRule, stdRule);
	            } else {
	                initialRule = new InitialTimeZoneRule(GetID() + "(STD)",
	                        GetRawOffset(), 0);
	                firstTransition = new TimeZoneTransition(firstDstStart,
	                        initialRule, dstRule);
	            }
	
	        } else {
	            // Create a TimeZoneRule for initial time
	            initialRule = new InitialTimeZoneRule(GetID(), GetRawOffset(), 0);
	        }
	        transitionRulesInitialized = true;
	    }
	}
}
