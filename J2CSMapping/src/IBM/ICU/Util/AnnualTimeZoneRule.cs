/*
 *******************************************************************************
 * Copyright (C) 2007, International Business Machines Corporation and         *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 */
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:48 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Util {
	
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Text;
	
	/// <summary>
	/// <c>AnnualTimeZoneRule</c> is a class used for representing a time zone
	/// rule which takes effect annually. Years used in this class are all Gregorian
	/// calendar years.
	/// </summary>
	///
	/// @draft ICU 3.8
	/// @provisional This API might change or be removed in a future release.
	public class AnnualTimeZoneRule : TimeZoneRule {
	
	    private const long serialVersionUID = -8870666707791230688L;
	
	    /// <summary>
	    /// The constant representing the maximum year used for designating a rule is
	    /// permanent.
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const int MAX_YEAR = Int32.MaxValue;
	
	    private readonly DateTimeRule dateTimeRule;
	
	    private readonly int startYear;
	
	    private readonly int endYear;
	
	    /// <summary>
	    /// Constructs a <c>AnnualTimeZoneRule</c> with the name, the GMT
	    /// offset of its standard time, the amount of daylight saving offset
	    /// adjustment, the annual start time rule and the start/until years.
	    /// </summary>
	    ///
	    /// <param name="name">The time zone name.</param>
	    /// <param name="rawOffset">The GMT offset of its standard time in milliseconds.</param>
	    /// <param name="dstSavings">The amount of daylight saving offset adjustment inmilliseconds. If this ia a rule for standard time, the valueof this argument is 0.</param>
	    /// <param name="dateTimeRule_0">The start date/time rule repeated annually.</param>
	    /// <param name="startYear_1">The first year when this rule takes effect.</param>
	    /// <param name="endYear_2">The last year when this rule takes effect. If this rule iseffective forever in future, specify MAX_YEAR.</param>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public AnnualTimeZoneRule(String name, int rawOffset, int dstSavings,
	            DateTimeRule dateTimeRule_0, int startYear_1, int endYear_2) : base(name, rawOffset, dstSavings) {
	        this.dateTimeRule = dateTimeRule_0;
	        this.startYear = startYear_1;
	        this.endYear = (endYear_2 > MAX_YEAR) ? MAX_YEAR : endYear_2;
	    }
	
	    /// <summary>
	    /// Gets the start date/time rule associated used by this rule.
	    /// </summary>
	    ///
	    /// <returns>An <c>AnnualDateTimeRule</c> which represents the start
	    /// date/time rule used by this time zone rule.</returns>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public DateTimeRule GetRule() {
	        return dateTimeRule;
	    }
	
	    /// <summary>
	    /// Gets the first year when this rule takes effect.
	    /// </summary>
	    ///
	    /// <returns>The start year of this rule. The year is in Gregorian calendar
	    /// with 0 == 1 BCE, -1 == 2 BCE, etc.</returns>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public int GetStartYear() {
	        return startYear;
	    }
	
	    /// <summary>
	    /// Gets the end year when this rule takes effect.
	    /// </summary>
	    ///
	    /// <returns>The end year of this rule (inclusive). The year is in Gregorian
	    /// calendar with 0 == 1 BCE, -1 == 2 BCE, etc.</returns>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public int GetEndYear() {
	        return endYear;
	    }
	
	    /// <summary>
	    /// Gets the time when this rule takes effect in the given year.
	    /// </summary>
	    ///
	    /// <param name="year">The Gregorian year, with 0 == 1 BCE, -1 == 2 BCE, etc.</param>
	    /// <param name="prevRawOffset">The standard time offset from UTC before this rule takeseffect in milliseconds.</param>
	    /// <param name="prevDSTSavings">The amount of daylight saving offset from the standard time.</param>
	    /// <returns>The time when this rule takes effect in the year, or null if this
	    /// rule is not applicable in the year.</returns>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public DateTime GetStartInYear(int year, int prevRawOffset, int prevDSTSavings) {
	        if (year < startYear || year > endYear) {
                return default(DateTime);
	        }
	
	        long ruleDay;
	        int type = dateTimeRule.GetDateRuleType();
	
	        if (type == IBM.ICU.Util.DateTimeRule.DOM) {
	            ruleDay = IBM.ICU.Impl.Grego.FieldsToDay(year, dateTimeRule.GetRuleMonth(),
	                    dateTimeRule.GetRuleDayOfMonth());
	        } else {
	            bool after = true;
	            if (type == IBM.ICU.Util.DateTimeRule.DOW) {
	                int weeks = dateTimeRule.GetRuleWeekInMonth();
	                if (weeks > 0) {
	                    ruleDay = IBM.ICU.Impl.Grego.FieldsToDay(year,
	                            dateTimeRule.GetRuleMonth(), 1);
	                    ruleDay += 7 * (weeks - 1);
	                } else {
	                    after = false;
	                    ruleDay = IBM.ICU.Impl.Grego.FieldsToDay(year, dateTimeRule
	                            .GetRuleMonth(), IBM.ICU.Impl.Grego.MonthLength(year,
	                            dateTimeRule.GetRuleMonth()));
	                    ruleDay += 7 * (weeks + 1);
	                }
	            } else {
	                int month = dateTimeRule.GetRuleMonth();
	                int dom = dateTimeRule.GetRuleDayOfMonth();
	                if (type == IBM.ICU.Util.DateTimeRule.DOW_LEQ_DOM) {
	                    after = false;
	                    // Handle Feb <=29
	                    if (month == IBM.ICU.Util.Calendar.FEBRUARY && dom == 29
	                            && !IBM.ICU.Impl.Grego.IsLeapYear(year)) {
	                        dom--;
	                    }
	                }
	                ruleDay = IBM.ICU.Impl.Grego.FieldsToDay(year, month, dom);
	            }
	
	            int dow = IBM.ICU.Impl.Grego.DayOfWeek(ruleDay);
	            int delta = dateTimeRule.GetRuleDayOfWeek() - dow;
	            if (after) {
	                delta = (delta < 0) ? delta + 7 : delta;
	            } else {
	                delta = (delta > 0) ? delta - 7 : delta;
	            }
	            ruleDay += delta;
	        }
	
	        long ruleTime = ruleDay * IBM.ICU.Impl.Grego.MILLIS_PER_DAY
	                + dateTimeRule.GetRuleMillisInDay();
	        if (dateTimeRule.GetTimeRuleType() != IBM.ICU.Util.DateTimeRule.UTC_TIME) {
	            ruleTime -= prevRawOffset;
	        }
	        if (dateTimeRule.GetTimeRuleType() == IBM.ICU.Util.DateTimeRule.WALL_TIME) {
	            ruleTime -= prevDSTSavings;
	        }
	        return new DateTime((ruleTime)*10000);
	    }
	
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public override DateTime GetFirstStart(int prevRawOffset, int prevDSTSavings) {
	        return GetStartInYear(startYear, prevRawOffset, prevDSTSavings);
	    }
	
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public override DateTime GetFinalStart(int prevRawOffset, int prevDSTSavings) {
	        if (endYear == MAX_YEAR) {
                return default(DateTime);
	        }
	        return GetStartInYear(endYear, prevRawOffset, prevDSTSavings);
	    }
	
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public override DateTime GetNextStart(long bs, int prevRawOffset, int prevDSTSavings,
	            bool inclusive) {
	        int[] fields = IBM.ICU.Impl.Grego.TimeToFields(bs, null);
	        int year = fields[0];
	        if (year < startYear) {
	            return GetFirstStart(prevRawOffset, prevDSTSavings);
	        }
	        DateTime d = GetStartInYear(year, prevRawOffset, prevDSTSavings);
	        if (d != null
	                && ((d.Ticks/10000) < bs || (!inclusive && ((d.Ticks/10000) == bs)))) {
	            d = GetStartInYear(year + 1, prevRawOffset, prevDSTSavings);
	        }
	        return d;
	    }
	
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public override DateTime GetPreviousStart(long bs, int prevRawOffset,
	            int prevDSTSavings, bool inclusive) {
	        int[] fields = IBM.ICU.Impl.Grego.TimeToFields(bs, null);
	        int year = fields[0];
	        if (year > endYear) {
	            return GetFinalStart(prevRawOffset, prevDSTSavings);
	        }
	        DateTime d = GetStartInYear(year, prevRawOffset, prevDSTSavings);
	        if (d != null
	                && ((d.Ticks/10000) > bs || (!inclusive && ((d.Ticks/10000) == bs)))) {
	            d = GetStartInYear(year - 1, prevRawOffset, prevDSTSavings);
	        }
	        return d;
	    }
	
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public override bool IsEquivalentTo(TimeZoneRule other) {
	        if (!(other  is  AnnualTimeZoneRule)) {
	            return false;
	        }
	        AnnualTimeZoneRule otherRule = (AnnualTimeZoneRule) other;
	        if (startYear == otherRule.startYear && endYear == otherRule.endYear
	                && dateTimeRule.Equals(otherRule.dateTimeRule)) {
	            return base.IsEquivalentTo(other);
	        }
	        return false;
	    }
	
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public override bool IsTransitionRule() {
	        return true;
	    }
	
	    /// <summary>
	    /// Returns a <c>String</c> representation of this
	    /// <c>AnnualTimeZoneRule</c> object. This method is used for debugging
	    /// purpose only. The string representation can be changed in future version
	    /// of ICU without any notice.
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public override String ToString() {
	        StringBuilder buf = new StringBuilder();
	        buf.Append(base.ToString());
	        buf.Append(", rule={" + dateTimeRule + "}");
	        buf.Append(", startYear=" + startYear);
	        buf.Append(", endYear=");
	        if (endYear == MAX_YEAR) {
	            buf.Append("max");
	        } else {
	            buf.Append(endYear);
	        }
	        return buf.ToString();
	    }
	}
}
