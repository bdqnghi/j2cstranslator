/*
 *******************************************************************************
 * Copyright (C) 2007, International Business Machines Corporation and         *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 */
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:48 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Util {
	
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Text;
	
	/// <summary>
	/// <c>TimeArrayTimeZoneRule</c> represents a time zone rule whose start
	/// times are defined by an array of milliseconds since the standard base time.
	/// </summary>
	///
	/// @draft ICU 3.8
	/// @provisional This API might change or be removed in a future release.
	public class TimeArrayTimeZoneRule : TimeZoneRule {
	
	    private const long serialVersionUID = -1117109130077415245L;
	
	    private readonly long[] startTimes;
	
	    private readonly int timeType;
	
	    /// <summary>
	    /// Constructs a <c>TimeArrayTimeZoneRule</c> with the name, the GMT
	    /// offset of its standard time, the amount of daylight saving offset
	    /// adjustment and the array of times when this rule takes effect.
	    /// </summary>
	    ///
	    /// <param name="name">The time zone name.</param>
	    /// <param name="rawOffset">The UTC offset of its standard time in milliseconds.</param>
	    /// <param name="dstSavings">The amount of daylight saving offset adjustment inmilliseconds. If this ia a rule for standard time, the valueof this argument is 0.</param>
	    /// <param name="startTimes_0">The start times in milliseconds since the base time (January1, 1970, 00:00:00).</param>
	    /// <param name="timeType_1">The time type of the start times, which is one of<c>DataTimeRule.WALL_TIME</c>,<c>STANDARD_TIME</c> and <c>UNIVERSAL_TIME</c>.</param>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public TimeArrayTimeZoneRule(String name, int rawOffset, int dstSavings,
	            long[] startTimes_0, int timeType_1) : base(name, rawOffset, dstSavings) {
	        if (startTimes_0 == null || startTimes_0.Length == 0) {
	            throw new ArgumentException("No start times are specified.");
	        } else {
	            this.startTimes = (long[]) startTimes_0.Clone();
	            System.Array.Sort(this.startTimes);
	        }
	        this.timeType = timeType_1;
	    }
	
	    /// <summary>
	    /// Gets the array of start times used by this rule.
	    /// </summary>
	    ///
	    /// <returns>An array of the start times in milliseconds since the base time
	    /// (January 1, 1970, 00:00:00 GMT).</returns>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public long[] GetStartTimes() {
	        return (long[]) startTimes.Clone();
	    }
	
	    /// <summary>
	    /// Gets the time type of the start times used by this rule. The return value
	    /// is either <c>DateTimeRule.WALL_TIME</c> or
	    /// <c>DateTimeRule.STANDARD_TIME</c> or
	    /// <c>DateTimeRule.UNIVERSAL_TIME</c>.
	    /// </summary>
	    ///
	    /// <returns>The time type used of the start times used by this rule.</returns>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public int GetTimeType() {
	        return timeType;
	    }
	
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public override DateTime GetFirstStart(int prevRawOffset, int prevDSTSavings) {
	        return new DateTime((GetUTC(startTimes[0], prevRawOffset, prevDSTSavings))*10000);
	    }
	
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public override DateTime GetFinalStart(int prevRawOffset, int prevDSTSavings) {
	        return new DateTime((GetUTC(startTimes[startTimes.Length - 1],
	                        prevRawOffset, prevDSTSavings))*10000);
	    }
	
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public override DateTime GetNextStart(long bs, int prevOffset, int prevDSTSavings,
	            bool inclusive) {
	        int i = startTimes.Length - 1;
	        for (; i >= 0; i--) {
	            long time = GetUTC(startTimes[i], prevOffset, prevDSTSavings);
	            if (time < bs || (!inclusive && time == bs)) {
	                break;
	            }
	        }
	        if (i == startTimes.Length - 1) {
                return default(DateTime);
	        }
	        return new DateTime((GetUTC(startTimes[i + 1], prevOffset, prevDSTSavings))*10000);
	    }
	
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public override DateTime GetPreviousStart(long bs, int prevOffset, int prevDSTSavings,
	            bool inclusive) {
	        int i = startTimes.Length - 1;
	        for (; i >= 0; i--) {
	            long time = GetUTC(startTimes[i], prevOffset, prevDSTSavings);
	            if (time < bs || (inclusive && time == bs)) {
	                return new DateTime((time)*10000);
	            }
	        }
            return default(DateTime);
	    }
	
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public override bool IsEquivalentTo(TimeZoneRule other) {
	        if (!(other  is  TimeArrayTimeZoneRule)) {
	            return false;
	        }
	        if (timeType == ((TimeArrayTimeZoneRule) other).timeType
	                && ILOG.J2CsMapping.Collections.Arrays.Equals(startTimes,((TimeArrayTimeZoneRule) other).startTimes)) {
	            return base.IsEquivalentTo(other);
	        }
	        return false;
	    }
	
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public override bool IsTransitionRule() {
	        return true;
	    }
	
	    /* Get UTC of the time with the raw/dst offset */
	    private long GetUTC(long time, int raw, int dst) {
	        if (timeType != IBM.ICU.Util.DateTimeRule.UTC_TIME) {
	            time -= raw;
	        }
	        if (timeType == IBM.ICU.Util.DateTimeRule.WALL_TIME) {
	            time -= dst;
	        }
	        return time;
	    }
	
	    /// <summary>
	    /// Returns a <c>String</c> representation of this
	    /// <c>TimeArrayTimeZoneRule</c> object. This method is used for
	    /// debugging purpose only. The string representation can be changed in
	    /// future version of ICU without any notice.
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public override String ToString() {
	        StringBuilder buf = new StringBuilder();
	        buf.Append(base.ToString());
	        buf.Append(", timeType=");
	        buf.Append(timeType);
	        buf.Append(", startTimes=[");
	        for (int i = 0; i < startTimes.Length; i++) {
	            if (i != 0) {
	                buf.Append(", ");
	            }
	            buf.Append(startTimes[i].ToString());
	        }
	        buf.Append("]");
	        return buf.ToString();
	    }
	}
}
