/*
 *******************************************************************************
 * Copyright (C) 2007, International Business Machines Corporation and         *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 */
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:48 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Util {
	
	using ILOG.J2CsMapping.Collections;
	using ILOG.J2CsMapping.Collections.Generics;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Resources;
	using System.Runtime.CompilerServices;
	using System.Text;
	
	/// <summary>
	/// <c>VTimeZone</c> is a class implementing RFC2445 VTIMEZONE. You can
	/// create a <c>VTimeZone</c> instance from a time zone ID supported by
	/// <c>TimeZone</c>. With the <c>VTimeZone</c> instance created from
	/// the ID, you can write out the rule in RFC2445 VTIMEZONE format. Also, you can
	/// create a <c>VTimeZone</c> instance from RFC2445 VTIMEZONE data stream,
	/// which allows you to calculate time zone offset by the rules defined by the
	/// data.<br>
	/// <br>
	/// Note: The consumer of this class reading or writing VTIMEZONE data is
	/// responsible to decode or encode Non-ASCII text. Methods reading/writing
	/// VTIMEZONE data in this class do nothing with MIME encoding.
	/// </summary>
	///
	/// @draft ICU 3.8
	/// @provisional This API might change or be removed in a future release.
	public class VTimeZone : BasicTimeZone {
	
	    private const long serialVersionUID = -6851467294127795902L;
	
	    /// <summary>
	    /// Create a <c>VTimeZone</c> instance by the time zone ID.
	    /// </summary>
	    ///
	    /// <param name="tzid">The time zone ID, such as America/New_York</param>
	    /// <returns>A <c>VTimeZone</c> initialized by the time zone ID, or null
	    /// when the ID is unknown.</returns>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public static VTimeZone Create(String tzid) {
	        VTimeZone vtz = new VTimeZone();
	        vtz.tz = (BasicTimeZone) IBM.ICU.Util.TimeZone.GetTimeZone(tzid);
	        vtz.olsonzid = vtz.tz.GetID();
	        vtz.SetID(tzid);
	
	        return vtz;
	    }
	
	    /// <summary>
	    /// Create a <c>VTimeZone</c> instance by RFC2445 VTIMEZONE data.
	    /// </summary>
	    ///
	    /// <param name="reader">The Reader for VTIMEZONE data input stream</param>
	    /// <returns>A <c>VTimeZone</c> initialized by the VTIMEZONE data or
	    /// null if failed to load the rule from the VTIMEZONE data.</returns>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public static VTimeZone Create(TextReader reader) {
	        VTimeZone vtz = new VTimeZone();
	        if (vtz.Load(reader)) {
	            return vtz;
	        }
	        return null;
	    }
	
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public override int GetOffset(int era, int year, int month, int day, int dayOfWeek,
	            int milliseconds) {
	        return tz.GetOffset(era, year, month, day, dayOfWeek, milliseconds);
	    }
	
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public override void GetOffset(long date, bool local, int[] offsets) {
	        tz.GetOffset(date, local, offsets);
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    public override void GetOffsetFromLocal(long date, int nonExistingTimeOpt,
	            int duplicatedTimeOpt, int[] offsets) {
	        tz.GetOffsetFromLocal(date, nonExistingTimeOpt, duplicatedTimeOpt,
	                offsets);
	    }
	
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public override int GetRawOffset() {
	        return tz.GetRawOffset();
	    }
	
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public override bool InDaylightTime(DateTime date) {
	        return tz.InDaylightTime(date);
	    }
	
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public override void SetRawOffset(int offsetMillis) {
	        tz.SetRawOffset(offsetMillis);
	    }
	
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public override bool UseDaylightTime() {
	        return tz.UseDaylightTime();
	    }
	
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public override bool HasSameRules(TimeZone other) {
	        return tz.HasSameRules(other);
	    }
	
	    /// <summary>
	    /// Gets the RFC2445 TZURL property value. When a <c>VTimeZone</c>
	    /// instance was created from VTIMEZONE data, the value is set by the TZURL
	    /// property value in the data. Otherwise, the initial value is null.
	    /// </summary>
	    ///
	    /// <returns>The RFC2445 TZURL property value</returns>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public String GetTZURL() {
	        return tzurl;
	    }
	
	    /// <summary>
	    /// Sets the RFC2445 TZURL property value.
	    /// </summary>
	    ///
	    /// <param name="url">The TZURL property value.</param>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public void SetTZURL(String url) {
	        tzurl = url;
	    }
	
	    /// <summary>
	    /// Gets the RFC2445 LAST-MODIFIED property value. When a
	    /// <c>VTimeZone</c> instance was created from VTIMEZONE data, the
	    /// value is set by the LAST-MODIFIED property value in the data. Otherwise,
	    /// the initial value is null.
	    /// </summary>
	    ///
	    /// <returns>The Date represents the RFC2445 LAST-MODIFIED date.</returns>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public DateTime GetLastModified() {
	        return lastmod;
	    }
	
	    /// <summary>
	    /// Sets the date used for RFC2445 LAST-MODIFIED property value.
	    /// </summary>
	    ///
	    /// <param name="date">The <c>Date</c> object represents the date for RFC2445LAST-MODIFIED property value.</param>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public void SetLastModified(DateTime date) {
	        lastmod = date;
	    }
	
	    /// <summary>
	    /// Writes RFC2445 VTIMEZONE data for this time zone
	    /// </summary>
	    ///
	    /// <param name="writer">A <c>Writer</c> used for the output</param>
	    /// <exception cref="IOException"></exception>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public void Write(TextWriter writer) {
            throw new NotImplementedException();
	        /*BufferedStream bw = new BufferedStream(writer);
	        if (vtzlines != null) {
	            IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(vtzlines.GetEnumerator());
	            while (it.HasNext()) {
	                String line = (String) it.Next();
	                if (line.StartsWith(ICAL_TZURL + COLON)) {
	                    if (tzurl != null) {
	                        bw.Write(ICAL_TZURL);
	                        bw.Write(COLON);
	                        bw.Write(tzurl);
	                        bw.Write(NEWLINE);
	                    }
	                } else if (line.StartsWith(ICAL_LASTMOD + COLON)) {
	                    if (lastmod != null) {
	                        bw.Write(ICAL_LASTMOD);
	                        bw.Write(COLON);
	                        bw.Write(GetUTCDateTimeString((lastmod.Ticks/10000)));
	                        bw.Write(NEWLINE);
	                    }
	                } else {
	                    bw.Write(line);
	                    bw.Write(NEWLINE);
	                }
	            }
	            bw.Flush();
	        } else {
	            String[] customProperties = null;
	            if (olsonzid != null && ICU_TZVERSION != null) {
	                customProperties = new String[1];
	                customProperties[0] = ICU_TZINFO_PROP + COLON + olsonzid + "["
	                        + ICU_TZVERSION + "]";
	            }
	            WriteZone(writer, tz, customProperties);
	        }*/
	    }
	
	    /// <summary>
	    /// Writes RFC2445 VTIMEZONE data applicable for dates after the specified
	    /// start time.
	    /// </summary>
	    ///
	    /// <param name="writer">The <c>Writer</c> used for the output</param>
	    /// <param name="start">The start time</param>
	    /// <exception cref="IOException"></exception>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public void Write(TextWriter writer, long start) {
	        // Extract rules applicable to dates after the start time
	        TimeZoneRule[] rules = tz.GetTimeZoneRules(start);
	
	        // Create a RuleBasedTimeZone with the subset rule
	        RuleBasedTimeZone rbtz = new RuleBasedTimeZone(tz.GetID(),
	                (InitialTimeZoneRule) rules[0]);
	        for (int i = 1; i < rules.Length; i++) {
	            rbtz.AddTransitionRule(rules[i]);
	        }
	        String[] customProperties = null;
	        if (olsonzid != null && ICU_TZVERSION != null) {
	            customProperties = new String[1];
	            customProperties[0] = ICU_TZINFO_PROP + COLON + olsonzid + "["
	                    + ICU_TZVERSION + "/Partial@" + start + "]";
	        }
	        WriteZone(writer, rbtz, customProperties);
	    }
	
	    /// <summary>
	    /// Writes RFC2445 VTIMEZONE data applicable near the specified date. Some
	    /// common iCalendar implementations can only handle a single time zone
	    /// property or a pair of standard and daylight time properties using BYDAY
	    /// rule with day of week (such as BYDAY=1SUN). This method produce the
	    /// VTIMEZONE data which can be handled these implementations. The rules
	    /// produced by this method can be used only for calculating time zone offset
	    /// around the specified date.
	    /// </summary>
	    ///
	    /// <param name="writer">The <c>Writer</c> used for the output</param>
	    /// <param name="time">The date</param>
	    /// <exception cref="IOException"></exception>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public void WriteSimple(TextWriter writer, long time) {
	        // Extract simple rules
	        TimeZoneRule[] rules = tz.GetSimpleTimeZoneRulesNear(time);
	
	        // Create a RuleBasedTimeZone with the subset rule
	        RuleBasedTimeZone rbtz = new RuleBasedTimeZone(tz.GetID(),
	                (InitialTimeZoneRule) rules[0]);
	        for (int i = 1; i < rules.Length; i++) {
	            rbtz.AddTransitionRule(rules[i]);
	        }
	        String[] customProperties = null;
	        if (olsonzid != null && ICU_TZVERSION != null) {
	            customProperties = new String[1];
	            customProperties[0] = ICU_TZINFO_PROP + COLON + olsonzid + "["
	                    + ICU_TZVERSION + "/Simple@" + time + "]";
	        }
	        WriteZone(writer, rbtz, customProperties);
	    }
	
	    // BasicTimeZone methods
	
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public override TimeZoneTransition GetNextTransition(long bs, bool inclusive) {
	        return tz.GetNextTransition(bs, inclusive);
	    }
	
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public override TimeZoneTransition GetPreviousTransition(long bs, bool inclusive) {
	        return tz.GetPreviousTransition(bs, inclusive);
	    }
	
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public override bool HasEquivalentTransitions(TimeZone other, long start, long end) {
	        return tz.HasEquivalentTransitions(other, start, end);
	    }
	
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public override TimeZoneRule[] GetTimeZoneRules() {
	        return tz.GetTimeZoneRules();
	    }
	
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public override TimeZoneRule[] GetTimeZoneRules(long start) {
	        return tz.GetTimeZoneRules(start);
	    }
	
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public override Object Clone() {
	        VTimeZone other = (VTimeZone) base.Clone();
	        other.tz = (BasicTimeZone) tz.Clone();
	        return other;
	    }
	
	    // private stuff ------------------------------------------------------
	
	    private BasicTimeZone tz;
	
	    private IList vtzlines;
	
	    private String olsonzid;
	
	    private String tzurl;
	
	    private DateTime lastmod;
	
	    private static String ICU_TZVERSION;
	
	    private const String ICU_TZINFO_PROP = "X-TZINFO";
	
	    // Default DST savings
	    private const int DEF_DSTSAVINGS = 60 * 60 * 1000; // 1 hour
	
	    // Default time start
	    private const long DEF_TZSTARTTIME = 0;
	
	    // minimum/max
	    private const long MIN_TIME = Int64.MinValue;
	
	    private const long MAX_TIME = Int64.MaxValue;
	
	    // Symbol characters used by RFC2445 VTIMEZONE
	    private const String COLON = ":";
	
	    private const String SEMICOLON = ";";
	
	    private const String EQUALS_SIGN = "=";
	
	    private const String COMMA = ",";
	
	    private const String NEWLINE = "\r\n"; // CRLF
	
	    // RFC2445 VTIMEZONE tokens
	    private const String ICAL_BEGIN_VTIMEZONE = "BEGIN:VTIMEZONE";
	
	    private const String ICAL_END_VTIMEZONE = "END:VTIMEZONE";
	
	    private const String ICAL_BEGIN = "BEGIN";
	
	    private const String ICAL_END = "END";
	
	    private const String ICAL_VTIMEZONE = "VTIMEZONE";
	
	    private const String ICAL_TZID = "TZID";
	
	    private const String ICAL_STANDARD = "STANDARD";
	
	    private const String ICAL_DAYLIGHT = "DAYLIGHT";
	
	    private const String ICAL_DTSTART = "DTSTART";
	
	    private const String ICAL_TZOFFSETFROM = "TZOFFSETFROM";
	
	    private const String ICAL_TZOFFSETTO = "TZOFFSETTO";
	
	    private const String ICAL_RDATE = "RDATE";
	
	    private const String ICAL_RRULE = "RRULE";
	
	    private const String ICAL_TZNAME = "TZNAME";
	
	    private const String ICAL_TZURL = "TZURL";
	
	    private const String ICAL_LASTMOD = "LAST-MODIFIED";
	
	    private const String ICAL_FREQ = "FREQ";
	
	    private const String ICAL_UNTIL = "UNTIL";
	
	    private const String ICAL_YEARLY = "YEARLY";
	
	    private const String ICAL_BYMONTH = "BYMONTH";
	
	    private const String ICAL_BYDAY = "BYDAY";
	
	    private const String ICAL_BYMONTHDAY = "BYMONTHDAY";
	
	    private static readonly String[] ICAL_DOW_NAMES = { "SU", "MO", "TU", "WE",
	            "TH", "FR", "SA" };
	
	    // Month length in regular year
	    private static readonly int[] MONTHLENGTH = { 31, 28, 31, 30, 31, 30, 31, 31,
	            30, 31, 30, 31 };
	
	    /* Hide the constructor */
	    private VTimeZone() {
	        this.olsonzid = null;
	        this.tzurl = null;
            this.lastmod = default(DateTime);
	    }
	
	    /*
	     * Read the input stream to locate the VTIMEZONE block and parse the
	     * contents to initialize this VTimeZone object. The reader skips other
	     * RFC2445 message headers. After the parse is completed, the reader points
	     * at the beginning of the header field just after the end of VTIMEZONE
	     * block. When VTIMEZONE block is found and this object is successfully
	     * initialized by the rules described in the data, this method returns true.
	     * Otherwise, returns false.
	     */
	    private bool Load(TextReader reader) {
	        // Read VTIMEZONE block into string array
	        try {
	            vtzlines = new LinkedList();
	            bool eol = false;
	            bool start = false;
	            bool success = false;
	            StringBuilder line = new StringBuilder();
	            while (true) {
	                int ch = reader.Read();
	                if (ch == -1) {
	                    // end of file
	                    if (start && line.ToString().StartsWith(ICAL_END_VTIMEZONE)) {
	                        ILOG.J2CsMapping.Collections.Generics.Collections.Add(vtzlines,line.ToString());
	                        success = true;
	                    }
	                    break;
	                }
	                if (ch == 0x0D) {
	                    // CR, must be followed by LF by the definition in RFC2445
	                    continue;
	                }
	
	                if (eol) {
	                    if (ch != 0x09 && ch != 0x20) {
	                        // NOT followed by TAB/SP -> new line
	                        if (start) {
	                            if (line.Length > 0) {
	                                ILOG.J2CsMapping.Collections.Generics.Collections.Add(vtzlines,line.ToString());
	                            }
	                        }
	                        line.Length=0;
	                        if (ch != 0x0A) {
	                            line.Append((char) ch);
	                        }
	                    }
	                    eol = false;
	                } else {
	                    if (ch == 0x0A) {
	                        // LF
	                        eol = true;
	                        if (start) {
	                            if (line.ToString().StartsWith(ICAL_END_VTIMEZONE)) {
	                                ILOG.J2CsMapping.Collections.Generics.Collections.Add(vtzlines,line.ToString());
	                                success = true;
	                                break;
	                            }
	                        } else {
	                            if (line.ToString().StartsWith(ICAL_BEGIN_VTIMEZONE)) {
	                                ILOG.J2CsMapping.Collections.Generics.Collections.Add(vtzlines,line.ToString());
	                                line.Length=0;
	                                start = true;
	                                eol = false;
	                            }
	                        }
	                    } else {
	                        line.Append((char) ch);
	                    }
	                }
	            }
	            if (!success) {
	                return false;
	            }
	        } catch (IOException ioe) {
	            // /CLOVER:OFF
	            return false;
	            // /CLOVER:ON
	        }
	        return Parse();
	    }
	
	    // parser state
	    private const int INI = 0; // Initial state
	
	    private const int VTZ = 1; // In VTIMEZONE
	
	    private const int TZI = 2; // In STANDARD or DAYLIGHT
	
	    private const int ERR = 3; // Error state
	
	    /*
	     * Parse VTIMEZONE data and create a RuleBasedTimeZone
	     */
	    private bool Parse() {
	        // /CLOVER:OFF
	        if (vtzlines == null || vtzlines.Count == 0) {
	            return false;
	        }
	        // /CLOVER:ON
	
	        // timezone ID
	        String tzid = null;
	
	        int state = INI;
	        bool dst = false; // current zone type
	        String from = null; // current zone from offset
	        String to = null; // current zone offset
	        String tzname = null; // current zone name
	        String dtstart = null; // current zone starts
	        bool isRRULE = false;// true if the rule is described by RRULE
	        IList dates = null; // list of RDATE or RRULE strings
	        IList rules = new LinkedList(); // rule list
	        int initialRawOffset = 0; // initial offset
	        int initialDSTSavings = 0; // initial offset
	        long firstStart = MAX_TIME; // the earliest rule start time
	
	        IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(vtzlines.GetEnumerator());
	
	        while (it.HasNext()) {
	            String line = (String) it.Next();
	
	            int valueSep = line.IndexOf(COLON);
	            if (valueSep < 0) {
	                continue;
	            }
	            String name = line.Substring(0,(valueSep)-(0));
	            String value_ren = line.Substring(valueSep + 1);
	
	            switch (state) {
	            case INI:
	                if (name.Equals(ICAL_BEGIN) && value_ren.Equals(ICAL_VTIMEZONE)) {
	                    state = VTZ;
	                }
	                break;
	            case VTZ:
	                if (name.Equals(ICAL_TZID)) {
	                    tzid = value_ren;
	                } else if (name.Equals(ICAL_TZURL)) {
	                    tzurl = value_ren;
	                } else if (name.Equals(ICAL_LASTMOD)) {
	                    // Always in 'Z' format, so the offset argument for the
	                    // parse method
	                    // can be any value.
	                    lastmod = new DateTime((ParseDateTimeString(value_ren, 0))*10000);
	                } else if (name.Equals(ICAL_BEGIN)) {
	                    bool isDST = value_ren.Equals(ICAL_DAYLIGHT);
	                    if (value_ren.Equals(ICAL_STANDARD) || isDST) {
	                        // tzid must be ready at this point
	                        if (tzid == null) {
	                            state = ERR;
	                            break;
	                        }
	                        // initialize current zone properties
	                        dates = null;
	                        isRRULE = false;
	                        from = null;
	                        to = null;
	                        tzname = null;
	                        dst = isDST;
	                        state = TZI;
	                    } else {
	                        // BEGIN property other than STANDARD/DAYLIGHT
	                        // must not be there.
	                        state = ERR;
	                        break;
	                    }
	                } else if (name.Equals(ICAL_END) /*
	                                                  * &&
	                                                  * value.equals(ICAL_VTIMEZONE)
	                                                  */) {
	                    break;
	                }
	                break;
	
	            case TZI:
	                if (name.Equals(ICAL_DTSTART)) {
	                    dtstart = value_ren;
	                } else if (name.Equals(ICAL_TZNAME)) {
	                    tzname = value_ren;
	                } else if (name.Equals(ICAL_TZOFFSETFROM)) {
	                    from = value_ren;
	                } else if (name.Equals(ICAL_TZOFFSETTO)) {
	                    to = value_ren;
	                } else if (name.Equals(ICAL_RDATE)) {
	                    // RDATE mixed with RRULE is not supported
	                    if (isRRULE) {
	                        state = ERR;
	                        break;
	                    }
	                    if (dates == null) {
	                        dates = new LinkedList();
	                    }
	                    // RDATE value may contain multiple date delimited
	                    // by comma
	                    StringTokenizer st = new StringTokenizer(value_ren, COMMA);
	                    while (st.HasMoreTokens()) {
	                        String date = st.NextToken();
	                        ILOG.J2CsMapping.Collections.Generics.Collections.Add(dates,date);
	                    }
	                } else if (name.Equals(ICAL_RRULE)) {
	                    // RRULE mixed with RDATE is not supported
	                    if (!isRRULE && dates != null) {
	                        state = ERR;
	                        break;
	                    } else if (dates == null) {
	                        dates = new LinkedList();
	                    }
	                    isRRULE = true;
	                    ILOG.J2CsMapping.Collections.Generics.Collections.Add(dates,value_ren);
	                } else if (name.Equals(ICAL_END)) {
	                    // Mandatory properties
	                    if (dtstart == null || from == null || to == null) {
	                        state = ERR;
	                        break;
	                    }
	                    // if tzname is not available, create one from tzid
	                    if (tzname == null) {
	                        tzname = GetDefaultTZName(tzid, dst);
	                    }
	
	                    // create a time zone rule
	                    TimeZoneRule rule = null;
	                    int fromOffset = 0;
	                    int toOffset = 0;
	                    int rawOffset = 0;
	                    int dstSavings = 0;
	                    long start = 0;
	                    try {
	                        // Parse TZOFFSETFROM/TZOFFSETTO
	                        fromOffset = OffsetStrToMillis(from);
	                        toOffset = OffsetStrToMillis(to);
	
	                        if (dst) {
	                            // If daylight, use the previous offset as rawoffset
	                            // if positive
	                            if (toOffset - fromOffset > 0) {
	                                rawOffset = fromOffset;
	                                dstSavings = toOffset - fromOffset;
	                            } else {
	                                // This is rare case.. just use 1 hour DST
	                                // savings
	                                rawOffset = toOffset - DEF_DSTSAVINGS;
	                                dstSavings = DEF_DSTSAVINGS;
	                            }
	                        } else {
	                            rawOffset = toOffset;
	                            dstSavings = 0;
	                        }
	
	                        // start time
	                        start = ParseDateTimeString(dtstart, fromOffset);
	
	                        // Create the rule
                            DateTime actualStart = default(DateTime);
	                        if (isRRULE) {
	                            rule = CreateRuleByRRULE(tzname, rawOffset,
	                                    dstSavings, start, dates, fromOffset);
	                        } else {
	                            rule = CreateRuleByRDATE(tzname, rawOffset,
	                                    dstSavings, start, dates, fromOffset);
	                        }
	                        if (rule != null) {
	                            actualStart = rule.GetFirstStart(fromOffset, 0);
	                            if ((actualStart.Ticks/10000) < firstStart) {
	                                // save from offset information for the earliest
	                                // rule
	                                firstStart = (actualStart.Ticks/10000);
	                                // If this is STD, assume the time before this
	                                // transtion
	                                // is DST when the difference is 1 hour. This
	                                // might not be
	                                // accurate, but VTIMEZONE data does not have
	                                // such info.
	                                if (dstSavings > 0) {
	                                    initialRawOffset = fromOffset;
	                                    initialDSTSavings = 0;
	                                } else {
	                                    if (fromOffset - toOffset == DEF_DSTSAVINGS) {
	                                        initialRawOffset = fromOffset
	                                                - DEF_DSTSAVINGS;
	                                        initialDSTSavings = DEF_DSTSAVINGS;
	                                    } else {
	                                        initialRawOffset = fromOffset;
	                                        initialDSTSavings = 0;
	                                    }
	                                }
	                            }
	                        }
	                    } catch (ArgumentException iae) {
	                        // bad format - rule == null..
	                    }
	
	                    if (rule == null) {
	                        state = ERR;
	                        break;
	                    }
	                    ILOG.J2CsMapping.Collections.Generics.Collections.Add(rules,rule);
	                    state = VTZ;
	                }
	                break;
	            }
	
	            if (state == ERR) {
	                vtzlines = null;
	                return false;
	            }
	        }
	
	        // Must have at least one rule
	        if (rules.Count == 0) {
	            return false;
	        }
	
	        // Create a initial rule
	        InitialTimeZoneRule initialRule = new InitialTimeZoneRule(
	                GetDefaultTZName(tzid, false), initialRawOffset,
	                initialDSTSavings);
	
	        // Finally, create the RuleBasedTimeZone
	        RuleBasedTimeZone rbtz = new RuleBasedTimeZone(tzid, initialRule);
	        IIterator rit = new ILOG.J2CsMapping.Collections.IteratorAdapter(rules.GetEnumerator());
	        while (rit.HasNext()) {
	            rbtz.AddTransitionRule((TimeZoneRule) rit.Next());
	        }
	        tz = rbtz;
	        SetID(tzid);
	        return true;
	    }
	
	    /*
	     * Create a default TZNAME from TZID
	     */
	    private static String GetDefaultTZName(String tzid, bool isDST) {
	        if (isDST) {
	            return tzid + "(DST)";
	        }
	        return tzid + "(STD)";
	    }
	
	    /*
	     * Create a TimeZoneRule by the RRULE definition
	     */
	    private static TimeZoneRule CreateRuleByRRULE(String tzname, int rawOffset,
	            int dstSavings, long start, IList dates, int fromOffset) {
	        if (dates == null || dates.Count == 0) {
	            return null;
	        }
	        // Parse the first rule
	        String rrule = (String) dates[0];
	
	        long[] until = new long[1];
	        int[] ruleFields = ParseRRULE(rrule, until);
	        if (ruleFields == null) {
	            // Invalid RRULE
	            return null;
	        }
	
	        int month = ruleFields[0];
	        int dayOfWeek = ruleFields[1];
	        int nthDayOfWeek = ruleFields[2];
	        int dayOfMonth = ruleFields[3];
	
	        if (dates.Count == 1) {
	            // No more rules
	            if (ruleFields.Length > 4) {
	                // Multiple BYMONTHDAY values
	
	                if (ruleFields.Length != 10 || month == -1 || dayOfWeek == 0) {
	                    // Only support the rule using 7 continuous days
	                    // BYMONTH and BYDAY must be set at the same time
	                    return null;
	                }
	                int firstDay = 31; // max possible number of dates in a month
	                int[] days = new int[7];
	                for (int i = 0; i < 7; i++) {
	                    days[i] = ruleFields[3 + i];
	                    // Resolve negative day numbers. A negative day number
	                    // should
	                    // not be used in February, but if we see such case, we use
	                    // 28
	                    // as the base.
	                    days[i] = (days[i] > 0) ? days[i] : MONTHLENGTH[month]
	                            + days[i] + 1;
	                    firstDay = (days[i] < firstDay) ? days[i] : firstDay;
	                }
	                // Make sure days are continuous
	                for (int i_0 = 1; i_0 < 7; i_0++) {
	                    bool found = false;
	                    for (int j = 0; j < 7; j++) {
	                        if (days[j] == firstDay + i_0) {
	                            found = true;
	                            break;
	                        }
	                    }
	                    if (!found) {
	                        // days are not continuous
	                        return null;
	                    }
	                }
	                // Use DOW_GEQ_DOM rule with firstDay as the start date
	                dayOfMonth = firstDay;
	            }
	        } else {
	            // Check if BYMONTH + BYMONTHDAY + BYDAY rule with multiple RRULE
	            // lines.
	            // Otherwise, not supported.
	            if (month == -1 || dayOfWeek == 0 || dayOfMonth == 0) {
	                // This is not the case
	                return null;
	            }
	            // Parse the rest of rules if number of rules is not exceeding 7.
	            // We can only support 7 continuous days starting from a day of
	            // month.
	            if (dates.Count > 7) {
	                return null;
	            }
	
	            // Note: To check valid date range across multiple rule is a little
	            // bit complicated. For now, this code is not doing strict range
	            // checking across month boundary
	
	            int earliestMonth = month;
	            int daysCount = ruleFields.Length - 3;
	            int earliestDay = 31;
	            for (int i_1 = 0; i_1 < daysCount; i_1++) {
	                int dom = ruleFields[3 + i_1];
	                dom = (dom > 0) ? dom : MONTHLENGTH[month] + dom + 1;
	                earliestDay = (dom < earliestDay) ? dom : earliestDay;
	            }
	
	            int anotherMonth = -1;
	            for (int i_2 = 1; i_2 < dates.Count; i_2++) {
	                rrule = (String) dates[i_2];
	                long[] unt = new long[1];
	                int[] fields = ParseRRULE(rrule, unt);
	
	                // If UNTIL is newer than previous one, use the one
	                if (unt[0] > until[0]) {
	                    until = unt;
	                }
	
	                // Check if BYMONTH + BYMONTHDAY + BYDAY rule
	                if (fields[0] == -1 || fields[1] == 0 || fields[3] == 0) {
	                    return null;
	                }
	                // Count number of BYMONTHDAY
	                int count = fields.Length - 3;
	                if (daysCount + count > 7) {
	                    // We cannot support BYMONTHDAY more than 7
	                    return null;
	                }
	                // Check if the same BYDAY is used. Otherwise, we cannot
	                // support the rule
	                if (fields[1] != dayOfWeek) {
	                    return null;
	                }
	                // Check if the month is same or right next to the primary month
	                if (fields[0] != month) {
	                    if (anotherMonth == -1) {
	                        int diff = fields[0] - month;
	                        if (diff == -11 || diff == -1) {
	                            // Previous month
	                            anotherMonth = fields[0];
	                            earliestMonth = anotherMonth;
	                            // Reset earliest day
	                            earliestDay = 31;
	                        } else if (diff == 11 || diff == 1) {
	                            // Next month
	                            anotherMonth = fields[0];
	                        } else {
	                            // The day range cannot exceed more than 2 months
	                            return null;
	                        }
	                    } else if (fields[0] != month && fields[0] != anotherMonth) {
	                        // The day range cannot exceed more than 2 months
	                        return null;
	                    }
	                }
	                // If ealier month, go through days to find the earliest day
	                if (fields[0] == earliestMonth) {
	                    for (int j_3 = 0; j_3 < count; j_3++) {
	                        int dom_4 = fields[3 + j_3];
	                        dom_4 = (dom_4 > 0) ? dom_4 : MONTHLENGTH[fields[0]] + dom_4 + 1;
	                        earliestDay = (dom_4 < earliestDay) ? dom_4 : earliestDay;
	                    }
	                }
	                daysCount += count;
	            }
	            if (daysCount != 7) {
	                // Number of BYMONTHDAY entries must be 7
	                return null;
	            }
	            month = earliestMonth;
	            dayOfMonth = earliestDay;
	        }
	
	        // Calculate start/end year and missing fields
	        int[] dfields = IBM.ICU.Impl.Grego.TimeToFields(start + fromOffset, null);
	        int startYear = dfields[0];
	        if (month == -1) {
	            // If MYMONTH is not set, use the month of DTSTART
	            month = dfields[1];
	        }
	        if (dayOfWeek == 0 && nthDayOfWeek == 0 && dayOfMonth == 0) {
	            // If only YEARLY is set, use the day of DTSTART as BYMONTHDAY
	            dayOfMonth = dfields[2];
	        }
	        int timeInDay = dfields[5];
	
	        int endYear = IBM.ICU.Util.AnnualTimeZoneRule.MAX_YEAR;
	        if (until[0] != MIN_TIME) {
	            IBM.ICU.Impl.Grego.TimeToFields(until[0], dfields);
	            endYear = dfields[0];
	        }
	
	        // Create the AnnualDateTimeRule
	        DateTimeRule adtr = null;
	        if (dayOfWeek == 0 && nthDayOfWeek == 0 && dayOfMonth != 0) {
	            // Day in month rule, for example, 15th day in the month
	            adtr = new DateTimeRule(month, dayOfMonth, timeInDay,
	                    IBM.ICU.Util.DateTimeRule.WALL_TIME);
	        } else if (dayOfWeek != 0 && nthDayOfWeek != 0 && dayOfMonth == 0) {
	            // Nth day of week rule, for example, last Sunday
	            adtr = new DateTimeRule(month, nthDayOfWeek, dayOfWeek, timeInDay,
	                    IBM.ICU.Util.DateTimeRule.WALL_TIME);
	        } else if (dayOfWeek != 0 && nthDayOfWeek == 0 && dayOfMonth != 0) {
	            // First day of week after day of month rule, for example,
	            // first Sunday after 15th day in the month
	            adtr = new DateTimeRule(month, dayOfMonth, dayOfWeek, true,
	                    timeInDay, IBM.ICU.Util.DateTimeRule.WALL_TIME);
	        } else {
	            // RRULE attributes are insufficient
	            return null;
	        }
	
	        return new AnnualTimeZoneRule(tzname, rawOffset, dstSavings, adtr,
	                startYear, endYear);
	    }
	
	    /*
	     * Parse individual RRULE
	     * 
	     * On return -
	     * 
	     * int[0] month calculated by BYMONTH - 1, or -1 when not found int[1] day
	     * of week in BYDAY, or 0 when not found int[2] day of week ordinal number
	     * in BYDAY, or 0 when not found int[i >= 3] day of month, which could be
	     * multiple values, or 0 when not found
	     * 
	     * or
	     * 
	     * null on any error cases, for exmaple, FREQ=YEARLY is not available
	     * 
	     * When UNTIL attribute is available, the time will be set to until[0],
	     * otherwise, MIN_TIME
	     */
	    private static int[] ParseRRULE(String rrule, long[] until) {
	        int month = -1;
	        int dayOfWeek = 0;
	        int nthDayOfWeek = 0;
	        int[] dayOfMonth = null;
	
	        long untilTime = MIN_TIME;
	        bool yearly = false;
	        bool parseError = false;
	        StringTokenizer st = new StringTokenizer(rrule, SEMICOLON);
	
	        while (st.HasMoreTokens()) {
	            String attr, value_ren;
	            String prop = st.NextToken();
	            int sep = prop.IndexOf(EQUALS_SIGN);
	            if (sep != -1) {
	                attr = prop.Substring(0,(sep)-(0));
	                value_ren = prop.Substring(sep + 1);
	            } else {
	                parseError = true;
	                break;
	            }
	
	            if (attr.Equals(ICAL_FREQ)) {
	                // only support YEARLY frequency type
	                if (value_ren.Equals(ICAL_YEARLY)) {
	                    yearly = true;
	                } else {
	                    parseError = true;
	                    break;
	                }
	            } else if (attr.Equals(ICAL_UNTIL)) {
	                // ISO8601 UTC format, for example, "20060315T020000Z"
	                try {
	                    untilTime = ParseDateTimeString(value_ren, 0);
	                } catch (ArgumentException iae) {
	                    parseError = true;
	                    break;
	                }
	            } else if (attr.Equals(ICAL_BYMONTH)) {
	                // Note: BYMONTH may contain multiple months, but only single
	                // month make sense for
	                // VTIMEZONE property.
	                if (value_ren.Length > 2) {
	                    parseError = true;
	                    break;
	                }
	                try {
	                    month = Int32.Parse(value_ren) - 1;
	                    if (month < 0 || month >= 12) {
	                        parseError = true;
	                        break;
	                    }
	                } catch (FormatException nfe) {
	                    parseError = true;
	                    break;
	                }
	            } else if (attr.Equals(ICAL_BYDAY)) {
	                // Note: BYDAY may contain multiple day of week separated by
	                // comma. It is unlikely used for
	                // VTIMEZONE property. We do not support the case.
	
	                // 2-letter format is used just for representing a day of week,
	                // for example, "SU" for Sunday
	                // 3 or 4-letter format is used for represeinging Nth day of
	                // week, for example, "-1SA" for last Saturday
	                int length = value_ren.Length;
	                if (length < 2 || length > 4) {
	                    parseError = true;
	                    break;
	                }
	                if (length > 2) {
	                    // Nth day of week
	                    int sign = 1;
	                    if (value_ren[0] == '+') {
	                        sign = 1;
	                    } else if (value_ren[0] == '-') {
	                        sign = -1;
	                    } else if (length == 4) {
	                        parseError = true;
	                        break;
	                    }
	                    try {
	                        int n = Int32.Parse(value_ren.Substring(length - 3,(length - 2)-(length - 3)));
	                        if (n == 0 || n > 4) {
	                            parseError = true;
	                            break;
	                        }
	                        nthDayOfWeek = n * sign;
	                    } catch (FormatException nfe_0) {
	                        parseError = true;
	                        break;
	                    }
	                    value_ren = value_ren.Substring(length - 2);
	                }
	                int wday;
	                for (wday = 0; wday < ICAL_DOW_NAMES.Length; wday++) {
	                    if (value_ren.Equals(ICAL_DOW_NAMES[wday])) {
	                        break;
	                    }
	                }
	                if (wday < ICAL_DOW_NAMES.Length) {
	                    // Sunday(1) - Saturday(7)
	                    dayOfWeek = wday + 1;
	                } else {
	                    parseError = true;
	                    break;
	                }
	            } else if (attr.Equals(ICAL_BYMONTHDAY)) {
	                // Note: BYMONTHDAY may contain multiple days delimited by comma
	                //
	                // A value of BYMONTHDAY could be negative, for example, -1
	                // means
	                // the last day in a month
	                StringTokenizer days = new StringTokenizer(value_ren, COMMA);
	                int count = days.CountTokens();
	                dayOfMonth = new int[count];
	                int index = 0;
	                while (days.HasMoreTokens()) {
	                    try {
	                        dayOfMonth[index++] = Int32.Parse(days.NextToken());
	                    } catch (FormatException nfe_1) {
	                        parseError = true;
	                        break;
	                    }
	                }
	            }
	        }
	
	        if (parseError) {
	            return null;
	        }
	        if (!yearly) {
	            // FREQ=YEARLY must be set
	            return null;
	        }
	
	        until[0] = untilTime;
	
	        int[] results;
	        if (dayOfMonth == null) {
	            results = new int[4];
	            results[3] = 0;
	        } else {
	            results = new int[3 + dayOfMonth.Length];
	            for (int i = 0; i < dayOfMonth.Length; i++) {
	                results[3 + i] = dayOfMonth[i];
	            }
	        }
	        results[0] = month;
	        results[1] = dayOfWeek;
	        results[2] = nthDayOfWeek;
	        return results;
	    }
	
	    /*
	     * Create a TimeZoneRule by the RDATE definition
	     */
	    private static TimeZoneRule CreateRuleByRDATE(String tzname, int rawOffset,
	            int dstSavings, long start, IList dates, int fromOffset) {
	        // Create an array of transition times
	        long[] times;
	        if (dates == null || dates.Count == 0) {
	            // When no RDATE line is provided, use start (DTSTART)
	            // as the transition time
	            times = new long[1];
	            times[0] = start;
	        } else {
	            times = new long[dates.Count];
	            IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(dates.GetEnumerator());
	            int idx = 0;
	            try {
	                while (it.HasNext()) {
	                    times[idx++] = ParseDateTimeString((String) it.Next(),
	                            fromOffset);
	                }
	            } catch (ArgumentException iae) {
	                return null;
	            }
	        }
	        return new TimeArrayTimeZoneRule(tzname, rawOffset, dstSavings, times,
	                IBM.ICU.Util.DateTimeRule.UTC_TIME);
	    }
	
	    /*
	     * Write the time zone rules in RFC2445 VTIMEZONE format
	     */
	    private void WriteZone(TextWriter w, BasicTimeZone basictz,
	            String[] customProperties) {
	        // Write the header
	        WriteHeader(w);
	
	        if (customProperties != null && customProperties.Length > 0) {
	            for (int i = 0; i < customProperties.Length; i++) {
	                if (customProperties[i] != null) {
	                    w.Write(customProperties[i]);
	                    w.Write(NEWLINE);
	                }
	            }
	        }
	
	        long t = MIN_TIME;
	        String dstName = null;
	        int dstFromOffset = 0;
	        int dstFromDSTSavings = 0;
	        int dstToOffset = 0;
	        int dstStartYear = 0;
	        int dstMonth = 0;
	        int dstDayOfWeek = 0;
	        int dstWeekInMonth = 0;
	        int dstMillisInDay = 0;
	        long dstStartTime = 0;
	        long dstUntilTime = 0;
	        int dstCount = 0;
	        AnnualTimeZoneRule finalDstRule = null;
	
	        String stdName = null;
	        int stdFromOffset = 0;
	        int stdFromDSTSavings = 0;
	        int stdToOffset = 0;
	        int stdStartYear = 0;
	        int stdMonth = 0;
	        int stdDayOfWeek = 0;
	        int stdWeekInMonth = 0;
	        int stdMillisInDay = 0;
	        long stdStartTime = 0;
	        long stdUntilTime = 0;
	        int stdCount = 0;
	        AnnualTimeZoneRule finalStdRule = null;
	
	        int[] dtfields = new int[6];
	        bool hasTransitions = false;
	
	        // Going through all transitions
	        while (true) {
	            TimeZoneTransition tzt = basictz.GetNextTransition(t, false);
	            if (tzt == null) {
	                break;
	            }
	            hasTransitions = true;
	            t = tzt.GetTime();
	            String name = tzt.GetTo().GetName();
	            bool isDst = (tzt.GetTo().GetDSTSavings() != 0);
	            int fromOffset = tzt.GetFrom().GetRawOffset()
	                    + tzt.GetFrom().GetDSTSavings();
	            int fromDSTSavings = tzt.GetFrom().GetDSTSavings();
	            int toOffset = tzt.GetTo().GetRawOffset()
	                    + tzt.GetTo().GetDSTSavings();
	            IBM.ICU.Impl.Grego.TimeToFields(tzt.GetTime() + fromOffset, dtfields);
	            int weekInMonth = IBM.ICU.Impl.Grego.GetDayOfWeekInMonth(dtfields[0],
	                    dtfields[1], dtfields[2]);
	            int year = dtfields[0];
	            bool sameRule = false;
	            if (isDst) {
	                if (finalDstRule == null
	                        && tzt.GetTo()  is  AnnualTimeZoneRule) {
	                    if (((AnnualTimeZoneRule) tzt.GetTo()).GetEndYear() == IBM.ICU.Util.AnnualTimeZoneRule.MAX_YEAR) {
	                        finalDstRule = (AnnualTimeZoneRule) tzt.GetTo();
	                    }
	                }
	                if (dstCount > 0) {
	                    if (year == dstStartYear + dstCount && name.Equals(dstName)
	                            && dstFromOffset == fromOffset
	                            && dstToOffset == toOffset
	                            && dstMonth == dtfields[1]
	                            && dstDayOfWeek == dtfields[3]
	                            && dstWeekInMonth == weekInMonth
	                            && dstMillisInDay == dtfields[5]) {
	                        // Update until time
	                        dstUntilTime = t;
	                        dstCount++;
	                        sameRule = true;
	                    }
	                    if (!sameRule) {
	                        if (dstCount == 1) {
	                            WriteZonePropsByTime(w, true, dstName,
	                                    dstFromOffset, dstToOffset, dstStartTime,
	                                    true);
	                        } else {
	                            WriteZonePropsByDOW(w, true, dstName,
	                                    dstFromOffset, dstToOffset, dstMonth,
	                                    dstWeekInMonth, dstDayOfWeek, dstStartTime,
	                                    dstUntilTime);
	                        }
	                    }
	                }
	                if (!sameRule) {
	                    // Reset this DST information
	                    dstName = name;
	                    dstFromOffset = fromOffset;
	                    dstFromDSTSavings = fromDSTSavings;
	                    dstToOffset = toOffset;
	                    dstStartYear = year;
	                    dstMonth = dtfields[1];
	                    dstDayOfWeek = dtfields[3];
	                    dstWeekInMonth = weekInMonth;
	                    dstMillisInDay = dtfields[5];
	                    dstStartTime = dstUntilTime = t;
	                    dstCount = 1;
	                }
	                if (finalStdRule != null && finalDstRule != null) {
	                    break;
	                }
	            } else {
	                if (finalStdRule == null
	                        && tzt.GetTo()  is  AnnualTimeZoneRule) {
	                    if (((AnnualTimeZoneRule) tzt.GetTo()).GetEndYear() == IBM.ICU.Util.AnnualTimeZoneRule.MAX_YEAR) {
	                        finalStdRule = (AnnualTimeZoneRule) tzt.GetTo();
	                    }
	                }
	                if (stdCount > 0) {
	                    if (year == stdStartYear + stdCount && name.Equals(stdName)
	                            && stdFromOffset == fromOffset
	                            && stdToOffset == toOffset
	                            && stdMonth == dtfields[1]
	                            && stdDayOfWeek == dtfields[3]
	                            && stdWeekInMonth == weekInMonth
	                            && stdMillisInDay == dtfields[5]) {
	                        // Update until time
	                        stdUntilTime = t;
	                        stdCount++;
	                        sameRule = true;
	                    }
	                    if (!sameRule) {
	                        if (stdCount == 1) {
	                            WriteZonePropsByTime(w, false, stdName,
	                                    stdFromOffset, stdToOffset, stdStartTime,
	                                    true);
	                        } else {
	                            WriteZonePropsByDOW(w, false, stdName,
	                                    stdFromOffset, stdToOffset, stdMonth,
	                                    stdWeekInMonth, stdDayOfWeek, stdStartTime,
	                                    stdUntilTime);
	                        }
	                    }
	                }
	                if (!sameRule) {
	                    // Reset this STD information
	                    stdName = name;
	                    stdFromOffset = fromOffset;
	                    stdFromDSTSavings = fromDSTSavings;
	                    stdToOffset = toOffset;
	                    stdStartYear = year;
	                    stdMonth = dtfields[1];
	                    stdDayOfWeek = dtfields[3];
	                    stdWeekInMonth = weekInMonth;
	                    stdMillisInDay = dtfields[5];
	                    stdStartTime = stdUntilTime = t;
	                    stdCount = 1;
	                }
	                if (finalStdRule != null && finalDstRule != null) {
	                    break;
	                }
	            }
	        }
	        if (!hasTransitions) {
	            // No transition - put a single non transition RDATE
	            int offset = basictz.GetOffset(0 /* any time */);
	            bool isDst_0 = (offset != basictz.GetRawOffset());
	            WriteZonePropsByTime(w, isDst_0,
	                    GetDefaultTZName(basictz.GetID(), isDst_0), offset, offset,
	                    DEF_TZSTARTTIME - offset, false);
	        } else {
	            if (dstCount > 0) {
	                if (finalDstRule == null) {
	                    if (dstCount == 1) {
	                        WriteZonePropsByTime(w, true, dstName, dstFromOffset,
	                                dstToOffset, dstStartTime, true);
	                    } else {
	                        WriteZonePropsByDOW(w, true, dstName, dstFromOffset,
	                                dstToOffset, dstMonth, dstWeekInMonth,
	                                dstDayOfWeek, dstStartTime, dstUntilTime);
	                    }
	                } else {
	                    if (dstCount == 1) {
	                        WriteFinalRule(w, true, finalDstRule, dstFromOffset
	                                - dstFromDSTSavings, dstFromDSTSavings,
	                                dstStartTime);
	                    } else {
	                        // Use a single rule if possible
	                        if (IsEquivalentDateRule(dstMonth, dstWeekInMonth,
	                                dstDayOfWeek, finalDstRule.GetRule())) {
	                            WriteZonePropsByDOW(w, true, dstName,
	                                    dstFromOffset, dstToOffset, dstMonth,
	                                    dstWeekInMonth, dstDayOfWeek, dstStartTime,
	                                    MAX_TIME);
	                        } else {
	                            // Not equivalent rule - write out two different
	                            // rules
	                            WriteZonePropsByDOW(w, true, dstName,
	                                    dstFromOffset, dstToOffset, dstMonth,
	                                    dstWeekInMonth, dstDayOfWeek, dstStartTime,
	                                    dstUntilTime);
	                            WriteFinalRule(w, true, finalDstRule, dstFromOffset
	                                    - dstFromDSTSavings, dstFromDSTSavings,
	                                    dstStartTime);
	                        }
	                    }
	                }
	            }
	            if (stdCount > 0) {
	                if (finalStdRule == null) {
	                    if (stdCount == 1) {
	                        WriteZonePropsByTime(w, false, stdName, stdFromOffset,
	                                stdToOffset, stdStartTime, true);
	                    } else {
	                        WriteZonePropsByDOW(w, false, stdName, stdFromOffset,
	                                stdToOffset, stdMonth, stdWeekInMonth,
	                                stdDayOfWeek, stdStartTime, stdUntilTime);
	                    }
	                } else {
	                    if (stdCount == 1) {
	                        WriteFinalRule(w, false, finalStdRule, stdFromOffset
	                                - stdFromDSTSavings, stdFromDSTSavings,
	                                stdStartTime);
	                    } else {
	                        // Use a single rule if possible
	                        if (IsEquivalentDateRule(stdMonth, stdWeekInMonth,
	                                stdDayOfWeek, finalStdRule.GetRule())) {
	                            WriteZonePropsByDOW(w, false, stdName,
	                                    stdFromOffset, stdToOffset, stdMonth,
	                                    stdWeekInMonth, stdDayOfWeek, stdStartTime,
	                                    MAX_TIME);
	                        } else {
	                            // Not equivalent rule - write out two different
	                            // rules
	                            WriteZonePropsByDOW(w, false, stdName,
	                                    stdFromOffset, stdToOffset, stdMonth,
	                                    stdWeekInMonth, stdDayOfWeek, stdStartTime,
	                                    stdUntilTime);
	                            WriteFinalRule(w, false, finalStdRule,
	                                    stdFromOffset - stdFromDSTSavings,
	                                    stdFromDSTSavings, stdStartTime);
	                        }
	                    }
	                }
	            }
	        }
	        WriteFooter(w);
	    }
	
	    /*
	     * Check if the DOW rule specified by month, weekInMonth and dayOfWeek is
	     * equivalent to the DateTimerule.
	     */
	    private static bool IsEquivalentDateRule(int month, int weekInMonth,
	            int dayOfWeek, DateTimeRule dtrule) {
	        if (month != dtrule.GetRuleMonth()
	                || dayOfWeek != dtrule.GetRuleDayOfWeek()) {
	            return false;
	        }
	        if (dtrule.GetTimeRuleType() != IBM.ICU.Util.DateTimeRule.WALL_TIME) {
	            // Do not try to do more intelligent comparison for now.
	            return false;
	        }
	        if (dtrule.GetDateRuleType() == IBM.ICU.Util.DateTimeRule.DOW
	                && dtrule.GetRuleWeekInMonth() == weekInMonth) {
	            return true;
	        }
	        int ruleDOM = dtrule.GetRuleDayOfMonth();
	        if (dtrule.GetDateRuleType() == IBM.ICU.Util.DateTimeRule.DOW_GEQ_DOM) {
	            if (ruleDOM % 7 == 1 && (ruleDOM + 6) / 7 == weekInMonth) {
	                return true;
	            }
	            if (month != IBM.ICU.Util.Calendar.FEBRUARY
	                    && (MONTHLENGTH[month] - ruleDOM) % 7 == 6
	                    && weekInMonth == -1
	                            * ((MONTHLENGTH[month] - ruleDOM + 1) / 7)) {
	                return true;
	            }
	        }
	        if (dtrule.GetDateRuleType() == IBM.ICU.Util.DateTimeRule.DOW_LEQ_DOM) {
	            if (ruleDOM % 7 == 0 && ruleDOM / 7 == weekInMonth) {
	                return true;
	            }
	            if (month != IBM.ICU.Util.Calendar.FEBRUARY
	                    && (MONTHLENGTH[month] - ruleDOM) % 7 == 0
	                    && weekInMonth == -1
	                            * ((MONTHLENGTH[month] - ruleDOM) / 7 + 1)) {
	                return true;
	            }
	        }
	        return false;
	    }
	
	    /*
	     * Write a single start time
	     */
	    private static void WriteZonePropsByTime(TextWriter writer, bool isDst,
	            String tzname, int fromOffset, int toOffset, long time,
	            bool withRDATE) {
	        BeginZoneProps(writer, isDst, tzname, fromOffset, toOffset, time);
	        if (withRDATE) {
	            writer.Write(ICAL_RDATE);
	            writer.Write(COLON);
	            writer.Write(GetDateTimeString(time + fromOffset));
	            writer.Write(NEWLINE);
	        }
	        EndZoneProps(writer, isDst);
	    }
	
	    /*
	     * Write start times defined by a DOM rule using VTIMEZONE RRULE
	     */
	    private static void WriteZonePropsByDOM(TextWriter writer, bool isDst,
	            String tzname, int fromOffset, int toOffset, int month,
	            int dayOfMonth, long startTime, long untilTime) {
	        BeginZoneProps(writer, isDst, tzname, fromOffset, toOffset, startTime);
	
	        BeginRRULE(writer, month);
	        writer.Write(ICAL_BYMONTHDAY);
	        writer.Write(EQUALS_SIGN);
	        writer.Write(ILOG.J2CsMapping.Util.IlNumber.ToString(dayOfMonth));
	
	        if (untilTime != MAX_TIME) {
	            AppendUNTIL(writer, GetDateTimeString(untilTime + fromOffset));
	        }
	        writer.Write(NEWLINE);
	
	        EndZoneProps(writer, isDst);
	    }
	
	    /*
	     * Write start times defined by a DOW rule using VTIMEZONE RRULE
	     */
	    private static void WriteZonePropsByDOW(TextWriter writer, bool isDst,
	            String tzname, int fromOffset, int toOffset, int month,
	            int weekInMonth, int dayOfWeek, long startTime, long untilTime) {
	        BeginZoneProps(writer, isDst, tzname, fromOffset, toOffset, startTime);
	
	        BeginRRULE(writer, month);
	        writer.Write(ICAL_BYDAY);
	        writer.Write(EQUALS_SIGN);
	        writer.Write(ILOG.J2CsMapping.Util.IlNumber.ToString(weekInMonth)); // -4, -3, -2, -1, 1, 2, 3,
	                                                     // 4
	        writer.Write(ICAL_DOW_NAMES[dayOfWeek - 1]); // SU, MO, TU...
	
	        if (untilTime != MAX_TIME) {
	            AppendUNTIL(writer, GetDateTimeString(untilTime + fromOffset));
	        }
	        writer.Write(NEWLINE);
	
	        EndZoneProps(writer, isDst);
	    }
	
	    /*
	     * Write start times defined by a DOW_GEQ_DOM rule using VTIMEZONE RRULE
	     */
	    private static void WriteZonePropsByDOW_GEQ_DOM(TextWriter writer,
	            bool isDst, String tzname, int fromOffset, int toOffset,
	            int month, int dayOfMonth, int dayOfWeek, long startTime,
	            long untilTime) {
	        // Check if this rule can be converted to DOW rule
	        if (dayOfMonth % 7 == 1) {
	            // Can be represented by DOW rule
	            WriteZonePropsByDOW(writer, isDst, tzname, fromOffset, toOffset,
	                    month, (dayOfMonth + 6) / 7, dayOfWeek, startTime,
	                    untilTime);
	        } else if (month != IBM.ICU.Util.Calendar.FEBRUARY
	                && (MONTHLENGTH[month] - dayOfMonth) % 7 == 6) {
	            // Can be represented by DOW rule with negative week number
	            WriteZonePropsByDOW(writer, isDst, tzname, fromOffset, toOffset,
	                    month, -1 * ((MONTHLENGTH[month] - dayOfMonth + 1) / 7),
	                    dayOfWeek, startTime, untilTime);
	        } else {
	            // Otherwise, use BYMONTHDAY to include all possible dates
	            BeginZoneProps(writer, isDst, tzname, fromOffset, toOffset,
	                    startTime);
	
	            // Check if all days are in the same month
	            int startDay = dayOfMonth;
	            int currentMonthDays = 7;
	
	            if (dayOfMonth <= 0) {
	                // The start day is in previous month
	                int prevMonthDays = 1 - dayOfMonth;
	                currentMonthDays -= prevMonthDays;
	
	                int prevMonth = ((month - 1) < 0) ? 11 : month - 1;
	
	                // Note: When a rule is separated into two, UNTIL attribute
	                // needs to be
	                // calculated for each of them. For now, we skip this, because
	                // we basically use this method
	                // only for final rules, which does not have the UNTIL attribute
	                WriteZonePropsByDOW_GEQ_DOM_sub(writer, prevMonth,
	                        -prevMonthDays, dayOfWeek, prevMonthDays, MAX_TIME /*
	                                                                            * Do
	                                                                            * not
	                                                                            * use
	                                                                            * UNTIL
	                                                                            */,
	                        fromOffset);
	
	                // Start from 1 for the rest
	                startDay = 1;
	            } else if (dayOfMonth + 6 > MONTHLENGTH[month]) {
	                // Note: This code does not actually work well in February. For
	                // now, days in month in
	                // non-leap year.
	                int nextMonthDays = dayOfMonth + 6 - MONTHLENGTH[month];
	                currentMonthDays -= nextMonthDays;
	
	                int nextMonth = ((month + 1) > 11) ? 0 : month + 1;
	
	                WriteZonePropsByDOW_GEQ_DOM_sub(writer, nextMonth, 1,
	                        dayOfWeek, nextMonthDays,
	                        MAX_TIME /* Do not use UNTIL */, fromOffset);
	            }
	            WriteZonePropsByDOW_GEQ_DOM_sub(writer, month, startDay, dayOfWeek,
	                    currentMonthDays, untilTime, fromOffset);
	            EndZoneProps(writer, isDst);
	        }
	    }
	
	    /*
	     * Called from writeZonePropsByDOW_GEQ_DOM
	     */
	    private static void WriteZonePropsByDOW_GEQ_DOM_sub(TextWriter writer,
	            int month, int dayOfMonth, int dayOfWeek, int numDays,
	            long untilTime, int fromOffset) {
	
	        int startDayNum = dayOfMonth;
	        bool isFeb = (month == IBM.ICU.Util.Calendar.FEBRUARY);
	        if (dayOfMonth < 0 && !isFeb) {
	            // Use positive number if possible
	            startDayNum = MONTHLENGTH[month] + dayOfMonth + 1;
	        }
	        BeginRRULE(writer, month);
	        writer.Write(ICAL_BYDAY);
	        writer.Write(EQUALS_SIGN);
	        writer.Write(ICAL_DOW_NAMES[dayOfWeek - 1]); // SU, MO, TU...
	        writer.Write(SEMICOLON);
	        writer.Write(ICAL_BYMONTHDAY);
	        writer.Write(EQUALS_SIGN);
	
	        writer.Write(ILOG.J2CsMapping.Util.IlNumber.ToString(startDayNum));
	        for (int i = 1; i < numDays; i++) {
	            writer.Write(COMMA);
	            writer.Write(ILOG.J2CsMapping.Util.IlNumber.ToString(startDayNum + i));
	        }
	
	        if (untilTime != MAX_TIME) {
	            AppendUNTIL(writer, GetDateTimeString(untilTime + fromOffset));
	        }
	        writer.Write(NEWLINE);
	    }
	
	    /*
	     * Write start times defined by a DOW_LEQ_DOM rule using VTIMEZONE RRULE
	     */
	    private static void WriteZonePropsByDOW_LEQ_DOM(TextWriter writer,
	            bool isDst, String tzname, int fromOffset, int toOffset,
	            int month, int dayOfMonth, int dayOfWeek, long startTime,
	            long untilTime) {
	        // Check if this rule can be converted to DOW rule
	        if (dayOfMonth % 7 == 0) {
	            // Can be represented by DOW rule
	            WriteZonePropsByDOW(writer, isDst, tzname, fromOffset, toOffset,
	                    month, dayOfMonth / 7, dayOfWeek, startTime, untilTime);
	        } else if (month != IBM.ICU.Util.Calendar.FEBRUARY
	                && (MONTHLENGTH[month] - dayOfMonth) % 7 == 0) {
	            // Can be represented by DOW rule with negative week number
	            WriteZonePropsByDOW(writer, isDst, tzname, fromOffset, toOffset,
	                    month, -1 * ((MONTHLENGTH[month] - dayOfMonth) / 7 + 1),
	                    dayOfWeek, startTime, untilTime);
	        } else if (month == IBM.ICU.Util.Calendar.FEBRUARY && dayOfMonth == 29) {
	            // Specical case for February
	            WriteZonePropsByDOW(writer, isDst, tzname, fromOffset, toOffset,
	                    IBM.ICU.Util.Calendar.FEBRUARY, -1, dayOfWeek, startTime, untilTime);
	        } else {
	            // Otherwise, convert this to DOW_GEQ_DOM rule
	            WriteZonePropsByDOW_GEQ_DOM(writer, isDst, tzname, fromOffset,
	                    toOffset, month, dayOfMonth - 6, dayOfWeek, startTime,
	                    untilTime);
	        }
	    }
	
	    /*
	     * Write the final time zone rule using RRULE, with no UNTIL attribute
	     */
	    private static void WriteFinalRule(TextWriter writer, bool isDst,
	            AnnualTimeZoneRule rule, int fromRawOffset, int fromDSTSavings,
	            long startTime) {
	        DateTimeRule dtrule = ToWallTimeRule(rule.GetRule(), fromRawOffset,
	                fromDSTSavings);
	        int toOffset = rule.GetRawOffset() + rule.GetDSTSavings();
	        switch (dtrule.GetDateRuleType()) {
	        case IBM.ICU.Util.DateTimeRule.DOM:
	            WriteZonePropsByDOM(writer, isDst, rule.GetName(), fromRawOffset
	                    + fromDSTSavings, toOffset, dtrule.GetRuleMonth(),
	                    dtrule.GetRuleDayOfMonth(), startTime, MAX_TIME);
	            break;
	        case IBM.ICU.Util.DateTimeRule.DOW:
	            WriteZonePropsByDOW(writer, isDst, rule.GetName(), fromRawOffset
	                    + fromDSTSavings, toOffset, dtrule.GetRuleMonth(),
	                    dtrule.GetRuleWeekInMonth(), dtrule.GetRuleDayOfWeek(),
	                    startTime, MAX_TIME);
	            break;
	        case IBM.ICU.Util.DateTimeRule.DOW_GEQ_DOM:
	            WriteZonePropsByDOW_GEQ_DOM(writer, isDst, rule.GetName(),
	                    fromRawOffset + fromDSTSavings, toOffset,
	                    dtrule.GetRuleMonth(), dtrule.GetRuleDayOfMonth(),
	                    dtrule.GetRuleDayOfWeek(), startTime, MAX_TIME);
	            break;
	        case IBM.ICU.Util.DateTimeRule.DOW_LEQ_DOM:
	            WriteZonePropsByDOW_LEQ_DOM(writer, isDst, rule.GetName(),
	                    fromRawOffset + fromDSTSavings, toOffset,
	                    dtrule.GetRuleMonth(), dtrule.GetRuleDayOfMonth(),
	                    dtrule.GetRuleDayOfWeek(), startTime, MAX_TIME);
	            break;
	        }
	    }
	
	    /*
	     * Convert the rule to its equivalent rule using WALL_TIME mode
	     */
	    private static DateTimeRule ToWallTimeRule(DateTimeRule rule,
	            int rawOffset, int dstSavings) {
	        if (rule.GetTimeRuleType() == IBM.ICU.Util.DateTimeRule.WALL_TIME) {
	            return rule;
	        }
	        int wallt = rule.GetRuleMillisInDay();
	        if (rule.GetTimeRuleType() == IBM.ICU.Util.DateTimeRule.UTC_TIME) {
	            wallt += (rawOffset + dstSavings);
	        } else if (rule.GetTimeRuleType() == IBM.ICU.Util.DateTimeRule.STANDARD_TIME) {
	            wallt += dstSavings;
	        }
	
	        int month = -1, dom = 0, dow = 0, dtype = -1;
	        int dshift = 0;
	        if (wallt < 0) {
	            dshift = -1;
	            wallt += IBM.ICU.Impl.Grego.MILLIS_PER_DAY;
	        } else if (wallt >= IBM.ICU.Impl.Grego.MILLIS_PER_DAY) {
	            dshift = 1;
	            wallt -= IBM.ICU.Impl.Grego.MILLIS_PER_DAY;
	        }
	
	        month = rule.GetRuleMonth();
	        dom = rule.GetRuleDayOfMonth();
	        dow = rule.GetRuleDayOfWeek();
	        dtype = rule.GetDateRuleType();
	
	        if (dshift != 0) {
	            if (dtype == IBM.ICU.Util.DateTimeRule.DOW) {
	                // Convert to DOW_GEW_DOM or DOW_LEQ_DOM rule first
	                int wim = rule.GetRuleWeekInMonth();
	                if (wim > 0) {
	                    dtype = IBM.ICU.Util.DateTimeRule.DOW_GEQ_DOM;
	                    dom = 7 * (wim - 1) + 1;
	                } else {
	                    dtype = IBM.ICU.Util.DateTimeRule.DOW_LEQ_DOM;
	                    dom = MONTHLENGTH[month] + 7 * (wim + 1);
	                }
	
	            }
	            // Shift one day before or after
	            dom += dshift;
	            if (dom == 0) {
	                month--;
	                month = (month < IBM.ICU.Util.Calendar.JANUARY) ? IBM.ICU.Util.Calendar.DECEMBER : month;
	                dom = MONTHLENGTH[month];
	            } else if (dom > MONTHLENGTH[month]) {
	                month++;
	                month = (month > IBM.ICU.Util.Calendar.DECEMBER) ? IBM.ICU.Util.Calendar.JANUARY : month;
	                dom = 1;
	            }
	            if (dtype != IBM.ICU.Util.DateTimeRule.DOM) {
	                // Adjust day of week
	                dow += dshift;
	                if (dow < IBM.ICU.Util.Calendar.SUNDAY) {
	                    dow = IBM.ICU.Util.Calendar.SATURDAY;
	                } else if (dow > IBM.ICU.Util.Calendar.SATURDAY) {
	                    dow = IBM.ICU.Util.Calendar.SUNDAY;
	                }
	            }
	        }
	        // Create a new rule
	        DateTimeRule modifiedRule;
	        if (dtype == IBM.ICU.Util.DateTimeRule.DOM) {
	            modifiedRule = new DateTimeRule(month, dom, wallt,
	                    IBM.ICU.Util.DateTimeRule.WALL_TIME);
	        } else {
	            modifiedRule = new DateTimeRule(month, dom, dow,
	                    (dtype == IBM.ICU.Util.DateTimeRule.DOW_GEQ_DOM), wallt,
	                    IBM.ICU.Util.DateTimeRule.WALL_TIME);
	        }
	        return modifiedRule;
	    }
	
	    /*
	     * Write the opening section of zone properties
	     */
	    private static void BeginZoneProps(TextWriter writer, bool isDst,
	            String tzname, int fromOffset, int toOffset, long startTime) {
	        writer.Write(ICAL_BEGIN);
	        writer.Write(COLON);
	        if (isDst) {
	            writer.Write(ICAL_DAYLIGHT);
	        } else {
	            writer.Write(ICAL_STANDARD);
	        }
	        writer.Write(NEWLINE);
	
	        // TZOFFSETTO
	        writer.Write(ICAL_TZOFFSETTO);
	        writer.Write(COLON);
	        writer.Write(MillisToOffset(toOffset));
	        writer.Write(NEWLINE);
	
	        // TZOFFSETFROM
	        writer.Write(ICAL_TZOFFSETFROM);
	        writer.Write(COLON);
	        writer.Write(MillisToOffset(fromOffset));
	        writer.Write(NEWLINE);
	
	        // TZNAME
	        writer.Write(ICAL_TZNAME);
	        writer.Write(COLON);
	        writer.Write(tzname);
	        writer.Write(NEWLINE);
	
	        // DTSTART
	        writer.Write(ICAL_DTSTART);
	        writer.Write(COLON);
	        writer.Write(GetDateTimeString(startTime + fromOffset));
	        writer.Write(NEWLINE);
	    }
	
	    /*
	     * Writes the closing section of zone properties
	     */
	    private static void EndZoneProps(TextWriter writer, bool isDst) {
	        // END:STANDARD or END:DAYLIGHT
	        writer.Write(ICAL_END);
	        writer.Write(COLON);
	        if (isDst) {
	            writer.Write(ICAL_DAYLIGHT);
	        } else {
	            writer.Write(ICAL_STANDARD);
	        }
	        writer.Write(NEWLINE);
	    }
	
	    /*
	     * Write the beginning part of RRULE line
	     */
	    private static void BeginRRULE(TextWriter writer, int month) {
	        writer.Write(ICAL_RRULE);
	        writer.Write(COLON);
	        writer.Write(ICAL_FREQ);
	        writer.Write(EQUALS_SIGN);
	        writer.Write(ICAL_YEARLY);
	        writer.Write(SEMICOLON);
	        writer.Write(ICAL_BYMONTH);
	        writer.Write(EQUALS_SIGN);
	        writer.Write(ILOG.J2CsMapping.Util.IlNumber.ToString(month + 1));
	        writer.Write(SEMICOLON);
	    }
	
	    /*
	     * Append the UNTIL attribute after RRULE line
	     */
	    private static void AppendUNTIL(TextWriter writer, String until) {
	        if (until != null) {
	            writer.Write(SEMICOLON);
	            writer.Write(ICAL_UNTIL);
	            writer.Write(EQUALS_SIGN);
	            writer.Write(until);
	        }
	    }
	
	    /*
	     * Write the opening section of the VTIMEZONE block
	     */
	    private void WriteHeader(TextWriter writer) {
	        writer.Write(ICAL_BEGIN);
	        writer.Write(COLON);
	        writer.Write(ICAL_VTIMEZONE);
	        writer.Write(NEWLINE);
	        writer.Write(ICAL_TZID);
	        writer.Write(COLON);
	        writer.Write(tz.GetID());
	        writer.Write(NEWLINE);
	        if (tzurl != null) {
	            writer.Write(ICAL_TZURL);
	            writer.Write(COLON);
	            writer.Write(tzurl);
	            writer.Write(NEWLINE);
	        }
	        if (lastmod != null) {
	            writer.Write(ICAL_LASTMOD);
	            writer.Write(COLON);
	            writer.Write(GetUTCDateTimeString((lastmod.Ticks/10000)));
	            writer.Write(NEWLINE);
	        }
	    }
	
	    /*
	     * Write the closing section of the VTIMEZONE definition block
	     */
	    private static void WriteFooter(TextWriter writer) {
	        writer.Write(ICAL_END);
	        writer.Write(COLON);
	        writer.Write(ICAL_VTIMEZONE);
	        writer.Write(NEWLINE);
	    }
	
	    /*
	     * Convert date/time to RFC2445 Date-Time form #1 DATE WITH LOCAL TIME
	     */
	    private static String GetDateTimeString(long time) {
	        int[] fields = IBM.ICU.Impl.Grego.TimeToFields(time, null);
	        StringBuilder sb = new StringBuilder(15);
	        sb.Append(NumToString(fields[0], 4));
	        sb.Append(NumToString(fields[1] + 1, 2));
	        sb.Append(NumToString(fields[2], 2));
	        sb.Append('T');
	
	        int t = fields[5];
	        int hour = t / IBM.ICU.Impl.Grego.MILLIS_PER_HOUR;
	        t %= IBM.ICU.Impl.Grego.MILLIS_PER_HOUR;
	        int min = t / IBM.ICU.Impl.Grego.MILLIS_PER_MINUTE;
	        t %= IBM.ICU.Impl.Grego.MILLIS_PER_MINUTE;
	        int sec = t / IBM.ICU.Impl.Grego.MILLIS_PER_SECOND;
	
	        sb.Append(NumToString(hour, 2));
	        sb.Append(NumToString(min, 2));
	        sb.Append(NumToString(sec, 2));
	        return sb.ToString();
	    }
	
	    /*
	     * Convert date/time to RFC2445 Date-Time form #2 DATE WITH UTC TIME
	     */
	    private static String GetUTCDateTimeString(long time) {
	        return GetDateTimeString(time) + "Z";
	    }
	
	    /*
	     * Parse RFC2445 Date-Time form #1 DATE WITH LOCAL TIME and #2 DATE WITH UTC
	     * TIME
	     */
	    private static long ParseDateTimeString(String str, int offset) {
	        int year = 0, month = 0, day = 0, hour = 0, min = 0, sec = 0;
	        bool isUTC = false;
	        bool isValid = false;
	        do {
	            if (str == null) {
	                break;
	            }
	
	            int length = str.Length;
	            if (length != 15 && length != 16) {
	                // FORM#1 15 characters, such as "20060317T142115"
	                // FORM#2 16 characters, such as "20060317T142115Z"
	                break;
	            }
	            if (str[8] != 'T') {
	                // charcter "T" must be used for separating date and time
	                break;
	            }
	            if (length == 16) {
	                if (str[15] != 'Z') {
	                    // invalid format
	                    break;
	                }
	                isUTC = true;
	            }
	
	            try {
	                year = Int32.Parse(str.Substring(0,(4)-(0)));
	                month = Int32.Parse(str.Substring(4,(6)-(4))) - 1; // 0-based
	                day = Int32.Parse(str.Substring(6,(8)-(6)));
	                hour = Int32.Parse(str.Substring(9,(11)-(9)));
	                min = Int32.Parse(str.Substring(11,(13)-(11)));
	                sec = Int32.Parse(str.Substring(13,(15)-(13)));
	            } catch (FormatException nfe) {
	                break;
	            }
	
	            // check valid range
	            int maxDayOfMonth = IBM.ICU.Impl.Grego.MonthLength(year, month);
	            if (year < 0 || month < 0 || month > 11 || day < 1
	                    || day > maxDayOfMonth || hour < 0 || hour >= 24 || min < 0
	                    || min >= 60 || sec < 0 || sec >= 60) {
	                break;
	            }
	
	            isValid = true;
	        } while (false);
	
	        if (!isValid) {
	            throw new ArgumentException(
	                    "Invalid date time string format");
	        }
	        // Calculate the time
	        long time = IBM.ICU.Impl.Grego.FieldsToDay(year, month, day) * IBM.ICU.Impl.Grego.MILLIS_PER_DAY;
	        time += (hour * IBM.ICU.Impl.Grego.MILLIS_PER_HOUR + min * IBM.ICU.Impl.Grego.MILLIS_PER_MINUTE + sec
	                * IBM.ICU.Impl.Grego.MILLIS_PER_SECOND);
	        if (!isUTC) {
	            time -= offset;
	        }
	        return time;
	    }
	
	    /*
	     * Convert RFC2445 utc-offset string to milliseconds
	     */
	    private static int OffsetStrToMillis(String str) {
	        bool isValid = false;
	        int sign = 0, hour = 0, min = 0, sec = 0;
	
	        do {
	            if (str == null) {
	                break;
	            }
	            int length = str.Length;
	            if (length != 5 && length != 7) {
	                // utf-offset must be 5 or 7 characters
	                break;
	            }
	            // sign
	            char s = str[0];
	            if (s == '+') {
	                sign = 1;
	            } else if (s == '-') {
	                sign = -1;
	            } else {
	                // utf-offset must start with "+" or "-"
	                break;
	            }
	
	            try {
	                hour = Int32.Parse(str.Substring(1,(3)-(1)));
	                min = Int32.Parse(str.Substring(3,(5)-(3)));
	                if (length == 7) {
	                    sec = Int32.Parse(str.Substring(5,(7)-(5)));
	                }
	            } catch (FormatException nfe) {
	                break;
	            }
	            isValid = true;
	        } while (false);
	
	        if (!isValid) {
	            throw new ArgumentException("Bad offset string");
	        }
	        int millis = sign * ((hour * 60 + min) * 60 + sec) * 1000;
	        return millis;
	    }
	
	    /*
	     * Convert milliseconds to RFC2445 utc-offset string
	     */
	    private static String MillisToOffset(int millis) {
	        StringBuilder sb = new StringBuilder(7);
	        if (millis >= 0) {
	            sb.Append('+');
	        } else {
	            sb.Append('-');
	            millis = -millis;
	        }
	        int hour, min, sec;
	        int t = millis / 1000;
	
	        sec = t % 60;
	        t = (t - sec) / 60;
	        min = t % 60;
	        hour = t / 60;
	
	        sb.Append(NumToString(hour, 2));
	        sb.Append(NumToString(min, 2));
	        sb.Append(NumToString(sec, 2));
	
	        return sb.ToString();
	    }
	
	    /*
	     * Format integer number
	     */
	    private static String NumToString(int num, int width) {
	        String str = ILOG.J2CsMapping.Util.IlNumber.ToString(num);
	        int len = str.Length;
	        if (len >= width) {
	            return str.Substring(len - width,(len)-(len - width));
	        }
	        StringBuilder sb = new StringBuilder(width);
	        for (int i = len; i < width; i++) {
	            sb.Append('0');
	        }
	        sb.Append(str);
	        return sb.ToString();
	    }
	
	    static VTimeZone() {
	            try {
	                UResourceBundle tzbundle = IBM.ICU.Util.UResourceBundle
	                        .GetBundleInstance("com/ibm/icu/impl/data/icudt"
	                                + IBM.ICU.Util.VersionInfo.ICU_DATA_VERSION,
	                                "zoneinfo");
	                ICU_TZVERSION = tzbundle.GetString("TZVersion");
	            } catch (MissingManifestResourceException e) {
	                ICU_TZVERSION = null;
	            }
	        }
	}
}
