/*
 *******************************************************************************
 * Copyright (C) 1996-2007, International Business Machines Corporation and    *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 */
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:48 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Util {
	
	using IBM.ICU.Impl;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.Globalization;
	using System.IO;
	using System.Runtime.CompilerServices;
     using ILOG.J2CsMapping.Util;
	
	/// <summary>
	/// <c>HebrewCalendar</c> is a subclass of <c>Calendar</c> that that
	/// implements the traditional Hebrew calendar. This is the civil calendar in
	/// Israel and the liturgical calendar of the Jewish faith worldwide.
	/// <p>
	/// The Hebrew calendar is lunisolar and thus has a number of interesting
	/// properties that distinguish it from the Gregorian. Months start on the day of
	/// (an arithmetic approximation of) each new moon. Since the solar year
	/// (approximately 365.24 days) is not an even multiple of the lunar month
	/// (approximately 29.53 days) an extra "leap month" is inserted in 7 out of
	/// every 19 years. To make matters even more interesting, the start of a year
	/// can be delayed by up to three days in order to prevent certain holidays from
	/// falling on the Sabbath and to prevent certain illegal year lengths. Finally,
	/// the lengths of certain months can vary depending on the number of days in the
	/// year.
	/// <p>
	/// The leap month is known as "Adar 1" and is inserted between the months of
	/// Shevat and Adar in leap years. Since the leap month does not come at the end
	/// of the year, calculations involving month numbers are particularly complex.
	/// Users of this class should make sure to use the <see cref="M:IBM.ICU.Util.HebrewCalendar.Roll roll"/> and<see cref="M:IBM.ICU.Util.HebrewCalendar.Add add"/> methods rather than attempting to perform date arithmetic by
	/// manipulating the fields directly.
	/// <p>
	/// <b>Note:</b> In the traditional Hebrew calendar, days start at sunset.
	/// However, in order to keep the time fields in this class synchronized with
	/// those of the other calendars and with local clock time, we treat days and
	/// months as beginning at midnight, roughly 6 hours after the corresponding
	/// sunset.
	/// <p>
	/// If you are interested in more information on the rules behind the Hebrew
	/// calendar, see one of the following references:
	/// <ul>
	/// <li>"<a href="http://www.amazon.com/exec/obidos/ASIN/0521564743
	/// ">Calendrical Calculations</a>", by Nachum Dershowitz & Edward Reingold,
	/// Cambridge University Press, 1997, pages 85-91.
	/// <li>Hebrew Calendar Science and Myths, <a
	/// href="http://www.geocities.com/Athens/1584/">
	/// http://www.geocities.com/Athens/1584/</a>
	/// <li>The Calendar FAQ, <a href="http://www.faqs.org/faqs/calendars/faq/">
	/// http://www.faqs.org/faqs/calendars/faq/</a>
	/// </ul>
	/// <p>
	/// This class should not be subclassed.
	/// </p>
	/// <p>
	/// HebrewCalendar usually should be instantiated using<see cref="M:IBM.ICU.Util.Calendar.GetInstance(IBM.ICU.Util.ULocale)"/> passing in a
	/// <c>ULocale</c> with the tag <c>"@calendar=hebrew"</c>.
	/// </p>
	/// </summary>
	///
	/// <seealso cref="T:IBM.ICU.Util.GregorianCalendar"/>
	/// <seealso cref="T:IBM.ICU.Util.Calendar"/>
	/// @stable ICU 2.8
	public class HebrewCalendar : Calendar {
	    // jdk1.4.2 serialver
	    private const long serialVersionUID = -1952524560588825816L;
	
	    // -------------------------------------------------------------------------
	    // Tons o' Constants...
	    // -------------------------------------------------------------------------
	
	    /// <summary>
	    /// Constant for Tishri, the 1st month of the Hebrew year.
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    public const int TISHRI = 0;
	
	    /// <summary>
	    /// Constant for Heshvan, the 2nd month of the Hebrew year.
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    public const int HESHVAN = 1;
	
	    /// <summary>
	    /// Constant for Kislev, the 3rd month of the Hebrew year.
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    public const int KISLEV = 2;
	
	    /// <summary>
	    /// Constant for Tevet, the 4th month of the Hebrew year.
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    public const int TEVET = 3;
	
	    /// <summary>
	    /// Constant for Shevat, the 5th month of the Hebrew year.
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    public const int SHEVAT = 4;
	
	    /// <summary>
	    /// Constant for Adar I, the 6th month of the Hebrew year (present in leap
	    /// years only). In non-leap years, the calendar jumps from Shevat (5th
	    /// month) to Adar (7th month).
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    public const int ADAR_1 = 5;
	
	    /// <summary>
	    /// Constant for the Adar, the 7th month of the Hebrew year.
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    public const int ADAR = 6;
	
	    /// <summary>
	    /// Constant for Nisan, the 8th month of the Hebrew year.
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    public const int NISAN = 7;
	
	    /// <summary>
	    /// Constant for Iyar, the 9th month of the Hebrew year.
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    public const int IYAR = 8;
	
	    /// <summary>
	    /// Constant for Sivan, the 10th month of the Hebrew year.
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    public const int SIVAN = 9;
	
	    /// <summary>
	    /// Constant for Tammuz, the 11th month of the Hebrew year.
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    public const int TAMUZ = 10;
	
	    /// <summary>
	    /// Constant for Av, the 12th month of the Hebrew year.
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    public const int AV = 11;
	
	    /// <summary>
	    /// Constant for Elul, the 13th month of the Hebrew year.
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    public const int ELUL = 12;
	
	    /// <summary>
	    /// The absolute date, in milliseconds since 1/1/1970 AD, Gregorian, of the start of the Hebrew calendar. In order to keep this calendar's time of day in sync with that of the Gregorian calendar, we use midnight, rather than sunset the day before.
	    /// </summary>
	    ///
	    private static readonly int[][] LIMITS = { new int[] { 0, 0, 0, 0 },
	            new int[] { 1, 1, 5000000, 5000000 }, new int[] { 0, 0, 12, 12 },
	            new int[] { 1, 1, 51, 56 }, new int[] { 0, 0, 4, 6 },
	            new int[] { 1, 1, 29, 30 }, new int[] { 1, 1, 353, 385 },
	            new int[] {}, new int[] { -1, -1, 5, 5 }, new int[] {},
	            new int[] {}, new int[] {}, new int[] {}, new int[] {},
	            new int[] {}, new int[] {}, new int[] {},
	            new int[] { -5000001, -5000001, 5000001, 5000001 }, new int[] {},
	            new int[] { -5000000, -5000000, 5000000, 5000000 }, new int[] {},
	            new int[] {} };
	
	    /// <summary>
	    /// The lengths of the Hebrew months. This is complicated, because there are three different types of years, or six if you count leap years. Due to the rules for postponing the start of the year to avoid having certain holidays fall on the sabbath, the year can end up being three different lengths, called "deficient", "normal", and "complete".
	    /// </summary>
	    ///
	    private static readonly int[][] MONTH_LENGTH = { new int[] { 30, 30, 30 },
	            new int[] { 29, 29, 30 }, new int[] { 29, 30, 30 },
	            new int[] { 29, 29, 29 }, new int[] { 30, 30, 30 },
	            new int[] { 30, 30, 30 }, new int[] { 29, 29, 29 },
	            new int[] { 30, 30, 30 }, new int[] { 29, 29, 29 },
	            new int[] { 30, 30, 30 }, new int[] { 29, 29, 29 },
	            new int[] { 30, 30, 30 }, new int[] { 29, 29, 29 } };
	
	    /// <summary>
	    /// The cumulative # of days to the end of each month in a non-leap year Although this can be calculated from the MONTH_LENGTH table, keeping it around separately makes some calculations a lot faster
	    /// </summary>
	    ///
	    private static readonly int[][] MONTH_START = { new int[] { 0, 0, 0 },
	            new int[] { 30, 30, 30 }, new int[] { 59, 59, 60 },
	            new int[] { 88, 89, 90 }, new int[] { 117, 118, 119 },
	            new int[] { 147, 148, 149 }, new int[] { 147, 148, 149 },
	            new int[] { 176, 177, 178 }, new int[] { 206, 207, 208 },
	            new int[] { 235, 236, 237 }, new int[] { 265, 266, 267 },
	            new int[] { 294, 295, 296 }, new int[] { 324, 325, 326 },
	            new int[] { 353, 354, 355 } };
	
	    /// <summary>
	    /// The cumulative # of days to the end of each month in a leap year
	    /// </summary>
	    ///
	    private static readonly int[][] LEAP_MONTH_START = { new int[] { 0, 0, 0 },
	            new int[] { 30, 30, 30 }, new int[] { 59, 59, 60 },
	            new int[] { 88, 89, 90 }, new int[] { 117, 118, 119 },
	            new int[] { 147, 148, 149 }, new int[] { 177, 178, 179 },
	            new int[] { 206, 207, 208 }, new int[] { 236, 237, 238 },
	            new int[] { 265, 266, 267 }, new int[] { 295, 296, 297 },
	            new int[] { 324, 325, 326 }, new int[] { 354, 355, 356 },
	            new int[] { 383, 384, 385 } };
	
	    // -------------------------------------------------------------------------
	    // Data Members...
	    // -------------------------------------------------------------------------
	
	    private static CalendarCache cache = new CalendarCache();
	
	    // -------------------------------------------------------------------------
	    // Constructors...
	    // -------------------------------------------------------------------------
	
	    /// <summary>
	    /// Constructs a default <c>HebrewCalendar</c> using the current time
	    /// in the default time zone with the default locale.
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    public HebrewCalendar() : this(IBM.ICU.Util.TimeZone.GetDefault(), IBM.ICU.Util.ULocale.GetDefault()) {
	    }
	
	    /// <summary>
	    /// Constructs a <c>HebrewCalendar</c> based on the current time in the
	    /// given time zone with the default locale.
	    /// </summary>
	    ///
	    /// <param name="zone">The time zone for the new calendar.</param>
	    /// @stable ICU 2.8
	    public HebrewCalendar(TimeZone zone) : this(zone, IBM.ICU.Util.ULocale.GetDefault()) {
	    }
	
	    /// <summary>
	    /// Constructs a <c>HebrewCalendar</c> based on the current time in the
	    /// default time zone with the given locale.
	    /// </summary>
	    ///
	    /// <param name="aLocale">The locale for the new calendar.</param>
	    /// @stable ICU 2.8
        public HebrewCalendar(Locale aLocale)
            : this(IBM.ICU.Util.TimeZone.GetDefault(), aLocale)
        {
	    }
	
	    /// <summary>
	    /// Constructs a <c>HebrewCalendar</c> based on the current time in the
	    /// default time zone with the given locale.
	    /// </summary>
	    ///
	    /// <param name="locale">The locale for the new calendar.</param>
	    /// @stable ICU 3.2
	    public HebrewCalendar(ULocale locale) : this(IBM.ICU.Util.TimeZone.GetDefault(), locale) {
	    }
	
	    /// <summary>
	    /// Constructs a <c>HebrewCalendar</c> based on the current time in the
	    /// given time zone with the given locale.
	    /// </summary>
	    ///
	    /// <param name="zone">The time zone for the new calendar.</param>
	    /// <param name="aLocale">The locale for the new calendar.</param>
	    /// @stable ICU 2.8
        public HebrewCalendar(TimeZone zone, Locale aLocale)
            : base(zone, aLocale)
        {
	        SetTimeInMillis(DateTime.Now.Millisecond);
	    }
	
	    /// <summary>
	    /// Constructs a <c>HebrewCalendar</c> based on the current time in the
	    /// given time zone with the given locale.
	    /// </summary>
	    ///
	    /// <param name="zone">The time zone for the new calendar.</param>
	    /// <param name="locale">The locale for the new calendar.</param>
	    /// @stable ICU 3.2
	    public HebrewCalendar(TimeZone zone, ULocale locale) : base(zone, locale) {
	        SetTimeInMillis(DateTime.Now.Millisecond);
	    }
	
	    /// <summary>
	    /// Constructs a <c>HebrewCalendar</c> with the given date set in the
	    /// default time zone with the default locale.
	    /// </summary>
	    ///
	    /// <param name="year">The value used to set the calendar's <see cref="M:IBM.ICU.Util.HebrewCalendar.YEAR YEAR"/> timefield.</param>
	    /// <param name="month">The value used to set the calendar's <see cref="M:IBM.ICU.Util.HebrewCalendar.MONTH MONTH"/> timefield. The value is 0-based. e.g., 0 for Tishri.</param>
	    /// <param name="date">The value used to set the calendar's <see cref="M:IBM.ICU.Util.HebrewCalendar.DATE DATE"/> timefield.</param>
	    /// @stable ICU 2.8
	    public HebrewCalendar(int year, int month, int date) : base(IBM.ICU.Util.TimeZone.GetDefault(), IBM.ICU.Util.ULocale.GetDefault()) {
	        this.Set(IBM.ICU.Util.Calendar.YEAR, year);
	        this.Set(IBM.ICU.Util.Calendar.MONTH, month);
	        this.Set(IBM.ICU.Util.Calendar.DATE, date);
	    }
	
	    /// <summary>
	    /// Constructs a <c>HebrewCalendar</c> with the given date set in the
	    /// default time zone with the default locale.
	    /// </summary>
	    ///
	    /// <param name="date">The date to which the new calendar is set.</param>
	    /// @stable ICU 2.8
	    public HebrewCalendar(DateTime date) : base(IBM.ICU.Util.TimeZone.GetDefault(), IBM.ICU.Util.ULocale.GetDefault()) {
	        this.SetTime(date);
	    }
	
	    /// <summary>
	    /// Constructs a <c>HebrewCalendar</c> with the given date and time set
	    /// for the default time zone with the default locale.
	    /// </summary>
	    ///
	    /// <param name="year">The value used to set the calendar's <see cref="M:IBM.ICU.Util.HebrewCalendar.YEAR YEAR"/> timefield.</param>
	    /// <param name="month">The value used to set the calendar's <see cref="M:IBM.ICU.Util.HebrewCalendar.MONTH MONTH"/> timefield. The value is 0-based. e.g., 0 for Tishri.</param>
	    /// <param name="date">The value used to set the calendar's <see cref="M:IBM.ICU.Util.HebrewCalendar.DATE DATE"/> timefield.</param>
	    /// <param name="hour">The value used to set the calendar's <see cref="M:IBM.ICU.Util.HebrewCalendar.HOUR_OF_DAYHOUR_OF_DAY"/> time field.</param>
	    /// <param name="minute">The value used to set the calendar's <see cref="M:IBM.ICU.Util.HebrewCalendar.MINUTE MINUTE"/>time field.</param>
	    /// <param name="second">The value used to set the calendar's <see cref="M:IBM.ICU.Util.HebrewCalendar.SECOND SECOND"/>time field.</param>
	    /// @stable ICU 2.8
	    public HebrewCalendar(int year, int month, int date, int hour, int minute,
	            int second) : base(IBM.ICU.Util.TimeZone.GetDefault(), IBM.ICU.Util.ULocale.GetDefault()) {
	        this.Set(IBM.ICU.Util.Calendar.YEAR, year);
	        this.Set(IBM.ICU.Util.Calendar.MONTH, month);
	        this.Set(IBM.ICU.Util.Calendar.DATE, date);
	        this.Set(IBM.ICU.Util.Calendar.HOUR_OF_DAY, hour);
	        this.Set(IBM.ICU.Util.Calendar.MINUTE, minute);
	        this.Set(IBM.ICU.Util.Calendar.SECOND, second);
	    }
	
	    // -------------------------------------------------------------------------
	    // Rolling and adding functions overridden from Calendar
	    //
	    // These methods call through to the default implementation in IBMCalendar
	    // for most of the fields and only handle the unusual ones themselves.
	    // -------------------------------------------------------------------------
	
	    /// <summary>
	    /// Add a signed amount to a specified field, using this calendar's rules.
	    /// For example, to add three days to the current date, you can call
	    /// <c>add(Calendar.DATE, 3)</c>.
	    /// <p>
	    /// When adding to certain fields, the values of other fields may conflict
	    /// and need to be changed. For example, when adding one to the<see cref="M:IBM.ICU.Util.HebrewCalendar.MONTH MONTH"/> field for the date "30 Av 5758", the<see cref="M:IBM.ICU.Util.HebrewCalendar.DAY_OF_MONTH DAY_OF_MONTH"/> field must be adjusted so that the
	    /// result is "29 Elul 5758" rather than the invalid "30 Elul 5758".
	    /// <p>
	    /// This method is able to add to all fields except for <see cref="M:IBM.ICU.Util.HebrewCalendar.ERA ERA"/>,<see cref="M:IBM.ICU.Util.HebrewCalendar.DST_OFFSET DST_OFFSET"/>, and <see cref="M:IBM.ICU.Util.HebrewCalendar.ZONE_OFFSET ZONE_OFFSET"/>.
	    /// <p>
	    /// <b>Note:</b> You should always use <see cref="M:IBM.ICU.Util.HebrewCalendar.Roll roll"/> and add rather than
	    /// attempting to perform arithmetic operations directly on the fields of a
	    /// <tt>HebrewCalendar</tt>. Since the <see cref="M:IBM.ICU.Util.HebrewCalendar.MONTH MONTH"/> field behaves
	    /// discontinuously in non-leap years, simple arithmetic can give invalid
	    /// results.
	    /// <p>
	    /// </summary>
	    ///
	    /// <param name="field">the time field.</param>
	    /// <param name="amount">the amount to add to the field.</param>
	    /// <exception cref="IllegalArgumentException">if the field is invalid or refers to a field that cannotbe handled by this method.</exception>
	    /// @stable ICU 2.8
	    public override void Add(int field, int amount) {
	        switch (field) {
	        case IBM.ICU.Util.Calendar.MONTH: {
	            // We can't just do a set(MONTH, get(MONTH) + amount). The
	            // reason is ADAR_1. Suppose amount is +2 and we land in
	            // ADAR_1 -- then we have to bump to ADAR_2 aka ADAR. But
	            // if amount is -2 and we land in ADAR_1, then we have to
	            // bump the other way -- down to SHEVAT. - Alan 11/00
	            int month = Get(IBM.ICU.Util.Calendar.MONTH);
	            int year = Get(IBM.ICU.Util.Calendar.YEAR);
	            bool acrossAdar1;
	            if (amount > 0) {
	                acrossAdar1 = (month < ADAR_1); // started before ADAR_1?
	                month += amount;
	                for (;;) {
	                    if (acrossAdar1 && month >= ADAR_1 && !IsLeapYear(year)) {
	                        ++month;
	                    }
	                    if (month <= ELUL) {
	                        break;
	                    }
	                    month -= ELUL + 1;
	                    ++year;
	                    acrossAdar1 = true;
	                }
	            } else {
	                acrossAdar1 = (month > ADAR_1); // started after ADAR_1?
	                month += amount;
	                for (;;) {
	                    if (acrossAdar1 && month <= ADAR_1 && !IsLeapYear(year)) {
	                        --month;
	                    }
	                    if (month >= 0) {
	                        break;
	                    }
	                    month += ELUL + 1;
	                    --year;
	                    acrossAdar1 = true;
	                }
	            }
	            Set(IBM.ICU.Util.Calendar.MONTH, month);
	            Set(IBM.ICU.Util.Calendar.YEAR, year);
	            PinField(IBM.ICU.Util.Calendar.DAY_OF_MONTH);
	            break;
	        }
	
	        default:
	            base.Add(field,amount);
	            break;
	        }
	    }
	
	    /// <summary>
	    /// Rolls (up/down) a specified amount time on the given field. For example,
	    /// to roll the current date up by three days, you can call
	    /// <c>roll(Calendar.DATE, 3)</c>. If the field is rolled past its
	    /// maximum allowable value, it will "wrap" back to its minimum and continue
	    /// rolling. For example, calling <c>roll(Calendar.DATE, 10)</c> on a
	    /// Hebrew calendar set to "25 Av 5758" will result in the date "5 Av 5758".
	    /// <p>
	    /// When rolling certain fields, the values of other fields may conflict and
	    /// need to be changed. For example, when rolling the <see cref="M:IBM.ICU.Util.HebrewCalendar.MONTH MONTH"/>field upward by one for the date "30 Av 5758", the <see cref="M:IBM.ICU.Util.HebrewCalendar.DAY_OF_MONTHDAY_OF_MONTH"/> field must be adjusted so that the result is "29 Elul 5758"
	    /// rather than the invalid "30 Elul".
	    /// <p>
	    /// This method is able to roll all fields except for <see cref="M:IBM.ICU.Util.HebrewCalendar.ERA ERA"/>,<see cref="M:IBM.ICU.Util.HebrewCalendar.DST_OFFSET DST_OFFSET"/>, and <see cref="M:IBM.ICU.Util.HebrewCalendar.ZONE_OFFSET ZONE_OFFSET"/>.
	    /// Subclasses may, of course, add support for additional fields in their
	    /// overrides of <c>roll</c>.
	    /// <p>
	    /// <b>Note:</b> You should always use roll and <see cref="M:IBM.ICU.Util.HebrewCalendar.Add add"/> rather than
	    /// attempting to perform arithmetic operations directly on the fields of a
	    /// <tt>HebrewCalendar</tt>. Since the <see cref="M:IBM.ICU.Util.HebrewCalendar.MONTH MONTH"/> field behaves
	    /// discontinuously in non-leap years, simple arithmetic can give invalid
	    /// results.
	    /// <p>
	    /// </summary>
	    ///
	    /// <param name="field">the time field.</param>
	    /// <param name="amount">the amount by which the field should be rolled.</param>
	    /// <exception cref="IllegalArgumentException">if the field is invalid or refers to a field that cannotbe handled by this method.</exception>
	    /// @stable ICU 2.8
	    public override void Roll(int field, int amount) {
	        switch (field) {
	        case IBM.ICU.Util.Calendar.MONTH: {
	            int month = Get(IBM.ICU.Util.Calendar.MONTH);
	            int year = Get(IBM.ICU.Util.Calendar.YEAR);
	
	            bool leapYear = IsLeapYear(year);
	            int yearLength = MonthsInYear(year);
	            int newMonth = month + (amount % yearLength);
	            //
	            // If it's not a leap year and we're rolling past the missing month
	            // of ADAR_1, we need to roll an extra month to make up for it.
	            //
	            if (!leapYear) {
	                if (amount > 0 && month < ADAR_1 && newMonth >= ADAR_1) {
	                    newMonth++;
	                } else if (amount < 0 && month > ADAR_1 && newMonth <= ADAR_1) {
	                    newMonth--;
	                }
	            }
	            Set(IBM.ICU.Util.Calendar.MONTH, (newMonth + 13) % 13);
	            PinField(IBM.ICU.Util.Calendar.DAY_OF_MONTH);
	            return;
	        }
	        default:
	            base.Roll(field,amount);
	            break;
	        }
	    }
	
	    // -------------------------------------------------------------------------
	    // Support methods
	    // -------------------------------------------------------------------------
	
	    // Hebrew date calculations are performed in terms of days, hours, and
	    // "parts" (or halakim), which are 1/1080 of an hour, or 3 1/3 seconds.
	    private const long HOUR_PARTS = 1080;
	
	    private const long DAY_PARTS = 24 * HOUR_PARTS;
	
	    // An approximate value for the length of a lunar month.
	    // It is used to calculate the approximate year and month of a given
	    // absolute date.
	    private const int MONTH_DAYS = 29;
	
	    private const long MONTH_FRACT = 12 * HOUR_PARTS + 793;
	
	    private const long MONTH_PARTS = MONTH_DAYS * DAY_PARTS
	            + MONTH_FRACT;
	
	    // The time of the new moon (in parts) on 1 Tishri, year 1 (the epoch)
	    // counting from noon on the day before. BAHARAD is an abbreviation of
	    // Bet (Monday), Hey (5 hours from sunset), Resh-Daled (204).
	    private const long BAHARAD = 11 * HOUR_PARTS + 204;
	
	    /// <summary>
	    /// Finds the day # of the first day in the given Hebrew year. To do this, we
	    /// want to calculate the time of the Tishri 1 new moon in that year.
	    /// <p>
	    /// The algorithm here is similar to ones described in a number of
	    /// references, including:
	    /// <ul>
	    /// <li>"Calendrical Calculations", by Nachum Dershowitz & Edward Reingold,
	    /// Cambridge University Press, 1997, pages 85-91.
	    /// <li>Hebrew Calendar Science and Myths, <a
	    /// href="http://www.geocities.com/Athens/1584/">
	    /// http://www.geocities.com/Athens/1584/</a>
	    /// <li>The Calendar FAQ, <a href="http://www.faqs.org/faqs/calendars/faq/">
	    /// http://www.faqs.org/faqs/calendars/faq/</a>
	    /// </ul>
	    /// </summary>
	    ///
	    private static long StartOfYear(int year) {
	        long day = cache.Get(year);
	
	        if (day == IBM.ICU.Impl.CalendarCache.EMPTY) {
	            int months = (235 * year - 234) / 19; // # of months before year
	
	            long frac = months * MONTH_FRACT + BAHARAD; // Fractional part of
	                                                        // day #
	            day = months * 29 + (frac / DAY_PARTS); // Whole # part of
	                                                    // calculation
	            frac = frac % DAY_PARTS; // Time of day
	
	            int wd = (int) (day % 7); // Day of week (0 == Monday)
	
	            if (wd == 2 || wd == 4 || wd == 6) {
	                // If the 1st is on Sun, Wed, or Fri, postpone to the next day
	                day += 1;
	                wd = (int) (day % 7);
	            }
	            if (wd == 1 && frac > 15 * HOUR_PARTS + 204 && !IsLeapYear(year)) {
	                // If the new moon falls after 3:11:20am (15h204p from the
	                // previous noon)
	                // on a Tuesday and it is not a leap year, postpone by 2 days.
	                // This prevents 356-day years.
	                day += 2;
	            } else if (wd == 0 && frac > 21 * HOUR_PARTS + 589
	                    && IsLeapYear(year - 1)) {
	                // If the new moon falls after 9:32:43 1/3am (21h589p from
	                // yesterday noon)
	                // on a Monday and *last* year was a leap year, postpone by 1
	                // day.
	                // Prevents 382-day years.
	                day += 1;
	            }
	            cache.Put(year, day);
	        }
	        return day;
	    }
	
	    /*
	     * Find the day of the week for a given day
	     * 
	     * @param day The # of days since the start of the Hebrew calendar, 1-based
	     * (i.e. 1/1/1 AM is day 1).
	     */
	    /*
	     * private static int absoluteDayToDayOfWeek(long day) { // We know that
	     * 1/1/1 AM is a Monday, which makes the math easy... return (int)(day % 7)
	     * + 1; }
	     */
	
	    /// <summary>
	    /// Returns the the type of a given year. 0 "Deficient" year with 353 or 383
	    /// days 1 "Normal" year with 354 or 384 days 2 "Complete" year with 355 or
	    /// 385 days
	    /// </summary>
	    ///
	    private int YearType(int year) {
	        int yearLength = HandleGetYearLength(year);
	
	        if (yearLength > 380) {
	            yearLength -= 30; // Subtract length of leap month.
	        }
	
	        int type = 0;
	
	        switch (yearLength) {
	        case 353:
	            type = 0;
	            break;
	        case 354:
	            type = 1;
	            break;
	        case 355:
	            type = 2;
	            break;
	        default:
	            throw new ArgumentException("Illegal year length "
	                    + yearLength + " in year " + year);
	
	        }
	        return type;
	    }
	
	    /// <summary>
	    /// Determine whether a given Hebrew year is a leap year
	    /// The rule here is that if (year % 19) == 0, 3, 6, 8, 11, 14, or 17. The
	    /// formula below performs the same test, believe it or not.
	    /// </summary>
	    ///
	    private static bool IsLeapYear(int year) {
	        // return (year * 12 + 17) % 19 >= 12;
	        int x = (year * 12 + 17) % 19;
	        return x >= ((x < 0) ? -7 : 12);
	    }
	
	    private static int MonthsInYear(int year) {
	        return (IsLeapYear(year)) ? 13 : 12;
	    }
	
	    // -------------------------------------------------------------------------
	    // Calendar framework
	    // -------------------------------------------------------------------------
	
	    
	    /// @stable ICU 2.8
	    protected internal override int HandleGetLimit(int field, int limitType) {
	        return LIMITS[field][limitType];
	    }
	
	    /// <summary>
	    /// Returns the length of the given month in the given year
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    protected internal override int HandleGetMonthLength(int extendedYear, int month) {
	        // Resolve out-of-range months. This is necessary in order to
	        // obtain the correct year. We correct to
	        // a 12- or 13-month year (add/subtract 12 or 13, depending
	        // on the year) but since we _always_ number from 0..12, and
	        // the leap year determines whether or not month 5 (Adar 1)
	        // is present, we allow 0..12 in any given year.
	        while (month < 0) {
	            month += MonthsInYear(--extendedYear);
	        }
	        // Careful: allow 0..12 in all years
	        while (month > 12) {
	            month -= MonthsInYear(extendedYear++);
	        }
	
	        switch (month) {
	        case HESHVAN:
	        case KISLEV:
	            // These two month lengths can vary
	            return MONTH_LENGTH[month][YearType(extendedYear)];
	
	        default:
	            // The rest are a fixed length
	            return MONTH_LENGTH[month][0];
	        }
	    }
	
	    /// <summary>
	    /// Returns the number of days in the given Hebrew year
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    protected internal override int HandleGetYearLength(int eyear) {
	        return (int) (StartOfYear(eyear + 1) - StartOfYear(eyear));
	    }
	
	    // -------------------------------------------------------------------------
	    // Functions for converting from milliseconds to field values
	    // -------------------------------------------------------------------------
	
	    /// <summary>
	    /// Subclasses may override this method to compute several fields specific to
	    /// each calendar system. These are:
	    /// <ul>
	    /// <li>ERA
	    /// <li>YEAR
	    /// <li>MONTH
	    /// <li>DAY_OF_MONTH
	    /// <li>DAY_OF_YEAR
	    /// <li>EXTENDED_YEAR
	    /// </ul>
	    /// Subclasses can refer to the DAY_OF_WEEK and DOW_LOCAL fields, which will
	    /// be set when this method is called. Subclasses can also call the
	    /// getGregorianXxx() methods to obtain Gregorian calendar equivalents for
	    /// the given Julian day.
	    /// <p>
	    /// In addition, subclasses should compute any subclass-specific fields, that
	    /// is, fields from BASE_FIELD_COUNT to getFieldCount() - 1.
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    protected internal override void HandleComputeFields(int julianDay) {
	        long d = julianDay - 347997;
	        long m = (d * DAY_PARTS) / MONTH_PARTS; // Months (approx)
	        int year = (int) ((19 * m + 234) / 235) + 1; // Years (approx)
	        long ys = StartOfYear(year); // 1st day of year
	        int dayOfYear = (int) (d - ys);
	
	        // Because of the postponement rules, it's possible to guess wrong. Fix
	        // it.
	        while (dayOfYear < 1) {
	            year--;
	            ys = StartOfYear(year);
	            dayOfYear = (int) (d - ys);
	        }
	
	        // Now figure out which month we're in, and the date within that month
	        int yearType = YearType(year);
	        int[][] monthStart = (IsLeapYear(year)) ? LEAP_MONTH_START : MONTH_START;
	
	        int month = 0;
	        while (dayOfYear > monthStart[month][yearType]) {
	            month++;
	        }
	        month--;
	        int dayOfMonth = dayOfYear - monthStart[month][yearType];
	
	        InternalSet(IBM.ICU.Util.Calendar.ERA, 0);
	        InternalSet(IBM.ICU.Util.Calendar.YEAR, year);
	        InternalSet(IBM.ICU.Util.Calendar.EXTENDED_YEAR, year);
	        InternalSet(IBM.ICU.Util.Calendar.MONTH, month);
	        InternalSet(IBM.ICU.Util.Calendar.DAY_OF_MONTH, dayOfMonth);
	        InternalSet(IBM.ICU.Util.Calendar.DAY_OF_YEAR, dayOfYear);
	    }
	
	    // -------------------------------------------------------------------------
	    // Functions for converting from field values to milliseconds
	    // -------------------------------------------------------------------------
	
	    
	    /// @stable ICU 2.8
	    protected internal override int HandleGetExtendedYear() {
	        int year;
	        if (NewerField(IBM.ICU.Util.Calendar.EXTENDED_YEAR, IBM.ICU.Util.Calendar.YEAR) == IBM.ICU.Util.Calendar.EXTENDED_YEAR) {
	            year = InternalGet(IBM.ICU.Util.Calendar.EXTENDED_YEAR, 1); // Default to year 1
	        } else {
	            year = InternalGet(IBM.ICU.Util.Calendar.YEAR, 1); // Default to year 1
	        }
	        return year;
	    }
	
	    /// <summary>
	    /// Return JD of start of given month/year.
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    protected internal override int HandleComputeMonthStart(int eyear, int month, bool useMonth) {
	
	        // Resolve out-of-range months. This is necessary in order to
	        // obtain the correct year. We correct to
	        // a 12- or 13-month year (add/subtract 12 or 13, depending
	        // on the year) but since we _always_ number from 0..12, and
	        // the leap year determines whether or not month 5 (Adar 1)
	        // is present, we allow 0..12 in any given year.
	        while (month < 0) {
	            month += MonthsInYear(--eyear);
	        }
	        // Careful: allow 0..12 in all years
	        while (month > 12) {
	            month -= MonthsInYear(eyear++);
	        }
	
	        long day = StartOfYear(eyear);
	
	        if (month != 0) {
	            if (IsLeapYear(eyear)) {
	                day += LEAP_MONTH_START[month][YearType(eyear)];
	            } else {
	                day += MONTH_START[month][YearType(eyear)];
	            }
	        }
	
	        return (int) (day + 347997);
	    }
	
	    /// <summary>
	    /// Return the current Calendar type.
	    /// </summary>
	    ///
	    /// <returns>type of calendar</returns>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public override String GetType() {
	        return "hebrew";
	    }
	
	    /*
	     * private static CalendarFactory factory; public static CalendarFactory
	     * factory() { if (factory == null) { factory = new CalendarFactory() {
	     * public Calendar create(TimeZone tz, ULocale loc) { return new
	     * HebrewCalendar(tz, loc); }
	     * 
	     * public String factoryName() { return "Hebrew"; } }; } return factory; }
	     */
	}
}
