// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:48 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2000-2007, International Business Machines
/// Corporation and others. All Rights Reserved.
/// </summary>
///
namespace IBM.ICU.Util {
	
	using IBM.ICU.Impl;
	using IBM.ICU.Text;
	using ILOG.J2CsMapping.IO;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.Globalization;
	using System.IO;
	using System.Runtime.CompilerServices;
    using ILOG.J2CsMapping.Util;
	
	/// <summary>
	/// <c>ChineseCalendar</c> is a concrete subclass of <see cref="T:IBM.ICU.Util.Calendar"/> that
	/// implements a traditional Chinese calendar. The traditional Chinese calendar
	/// is a lunisolar calendar: Each month starts on a new moon, and the months are
	/// numbered according to solar events, specifically, to guarantee that month 11
	/// always contains the winter solstice. In order to accomplish this, leap months
	/// are inserted in certain years. Leap months are numbered the same as the month
	/// they follow. The decision of which month is a leap month depends on the
	/// relative movements of the sun and moon.
	/// <p>
	/// This class defines one addition field beyond those defined by
	/// <c>Calendar</c>: The <c>IS_LEAP_MONTH</c> field takes the value
	/// of 0 for normal months, or 1 for leap months.
	/// <p>
	/// All astronomical computations are performed with respect to a time zone of
	/// GMT+8:00 and a longitude of 120 degrees east. Although some calendars
	/// implement a historically more accurate convention of using Beijing's local
	/// longitude (116 degrees 25 minutes east) and time zone (GMT+7:45:40) for dates
	/// before 1929, we do not implement this here.
	/// <p>
	/// Years are counted in two different ways in the Chinese calendar. The first
	/// method is by sequential numbering from the 61st year of the reign of Huang
	/// Di, 2637 BCE, which is designated year 1 on the Chinese calendar. The second
	/// method uses 60-year cycles from the same starting point, which is designated
	/// year 1 of cycle 1. In this class, the <c>EXTENDED_YEAR</c> field
	/// contains the sequential year count. The <c>ERA</c> field contains the
	/// cycle number, and the <c>YEAR</c> field contains the year of the cycle,
	/// a value between 1 and 60.
	/// <p>
	/// There is some variation in what is considered the starting point of the
	/// calendar, with some sources starting in the first year of the reign of Huang
	/// Di, rather than the 61st. This gives continuous year numbers 60 years greater
	/// and cycle numbers one greater than what this class implements.
	/// <p>
	/// Because <c>ChineseCalendar</c> defines an additional field and
	/// redefines the way the <c>ERA</c> field is used, it requires a new
	/// format class, <c>ChineseDateFormat</c>. As always, use the methods
	/// <c>DateFormat.getXxxInstance(Calendar cal,...)</c> to obtain a
	/// formatter for this calendar.
	/// <p>
	/// References:
	/// <ul>
	/// <li>Dershowitz and Reingold, <i>Calendrical Calculations</i>, Cambridge
	/// University Press, 1997</li>
	/// <li>Helmer Aslaksen's <a
	/// href="http://www.math.nus.edu.sg/aslaksen/calendar/chinese.shtml"> Chinese
	/// Calendar page</a></li>
	/// <li>The <a href="http://www.tondering.dk/claus/calendar.html"> Calendar
	/// FAQ</a></li>
	/// </ul>
	/// <p>
	/// This class should not be subclassed.
	/// </p>
	/// <p>
	/// ChineseCalendar usually should be instantiated using<see cref="M:IBM.ICU.Util.Calendar.GetInstance(IBM.ICU.Util.ULocale)"/> passing in a
	/// <c>ULocale</c> with the tag <c>"@calendar=chinese"</c>.
	/// </p>
	/// </summary>
	///
	/// <seealso cref="T:IBM.ICU.Util.ChineseDateFormat"/>
	/// <seealso cref="T:IBM.ICU.Util.Calendar"/>
	/// @stable ICU 2.8
	public class ChineseCalendar : Calendar {
	    // jdk1.4.2 serialver
	    private const long serialVersionUID = 7312110751940929420L;
	
	    // ------------------------------------------------------------------
	    // Developer Notes
	    //
	    // Time is represented as a scalar in two ways in this class. One is
	    // the usual UTC epoch millis, that is, milliseconds after January 1,
	    // 1970 Gregorian, 0:00:00.000 UTC. The other is in terms of 'local
	    // days.' This is the number of days after January 1, 1970 Gregorian,
	    // local to Beijing, China (since all computations of the Chinese
	    // calendar are done in Beijing). That is, 0 represents January 1,
	    // 1970 0:00 Asia/Shanghai. Conversion of local days to and from
	    // standard epoch milliseconds is accomplished by the daysToMillis()
	    // and millisToDays() methods.
	    //
	    // Several methods use caches to improve performance. Caches are at
	    // the object, not class level, under the assumption that typical
	    // usage will be to have one instance of ChineseCalendar at a time.
	
	    /// <summary>
	    /// We have one instance per object, and we don't synchronize it because
	    /// Calendar doesn't support multithreaded execution in the first place.
	    /// </summary>
	    ///
	    private CalendarAstronomer astro;
	
	    /// <summary>
	    /// Cache that maps Gregorian year to local days of winter solstice.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Util.ChineseCalendar.WinterSolstice(System.Int32)"/>
	    private CalendarCache winterSolsticeCache;
	
	    /// <summary>
	    /// Cache that maps Gregorian year to local days of Chinese new year.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Util.ChineseCalendar.NewYear(System.Int32)"/>
	    private CalendarCache newYearCache;
	
	    /// <summary>
	    /// True if the current year is a leap year. Updated with each time to fields
	    /// resolution.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Util.ChineseCalendar.ComputeChineseFields(System.Int32, System.Int32, System.Int32, System.Boolean)"/>
	    private bool isLeapYear;
	
	    // ------------------------------------------------------------------
	    // Constructors
	    // ------------------------------------------------------------------
	
	    /// <summary>
	    /// Construct a Chinese calendar with the default time zone and locale.
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    public ChineseCalendar() : base() {
	        this.astro = new CalendarAstronomer();
	        this.winterSolsticeCache = new CalendarCache();
	        this.newYearCache = new CalendarCache();
	        SetTimeInMillis(DateTime.Now.Millisecond);
	    }
	
	    /// <summary>
	    /// Construct a Chinese calendar with the given time zone and locale.
	    /// </summary>
	    ///
	    /// <param name="zone">time zone for this calendar</param>
	    /// <param name="locale">locale for this calendar</param>
	    /// @stable ICU 2.8
        public ChineseCalendar(TimeZone zone, Locale locale)
            : base(zone, locale)
        {
	        this.astro = new CalendarAstronomer();
	        this.winterSolsticeCache = new CalendarCache();
	        this.newYearCache = new CalendarCache();
	        SetTimeInMillis(DateTime.Now.Millisecond);
	    }
	
	    /// <summary>
	    /// Construct a Chinese calendar with the given time zone and locale.
	    /// </summary>
	    ///
	    /// <param name="zone">time zone for this calendar</param>
	    /// <param name="locale">ulocale for this calendar</param>
	    /// @stable ICU 3.2
	    public ChineseCalendar(TimeZone zone, ULocale locale) : base(zone, locale) {
	        this.astro = new CalendarAstronomer();
	        this.winterSolsticeCache = new CalendarCache();
	        this.newYearCache = new CalendarCache();
	        SetTimeInMillis(DateTime.Now.Millisecond);
	    }
	
	    // ------------------------------------------------------------------
	    // Public constants
	    // ------------------------------------------------------------------
	
	    /// <summary>
	    /// Field indicating whether or not the current month is a leap month. Should
	    /// have a value of 0 for non-leap months, and 1 for leap months.
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    public static int IS_LEAP_MONTH = IBM.ICU.Util.Calendar.BASE_FIELD_COUNT;
	
	    /// <summary>
	    /// Count of fields in this class.
	    /// </summary>
	    ///
	    private static readonly int FIELD_COUNT = IS_LEAP_MONTH + 1;
	
	    // ------------------------------------------------------------------
	    // Calendar framework
	    // ------------------------------------------------------------------
	
	    /// <summary>
	    /// Override Calendar to allocate our additional field.
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    protected internal override int[] HandleCreateFields() {
	        return new int[FIELD_COUNT];
	    }
	
	    /// <summary>
	    /// Array defining the limits of field values for this class. Field limits which are invariant with respect to calendar system and defined by Calendar are left blank. Notes: ERA 5000000 / 60 = 83333. MONTH There are 12 or 13 lunar months in a year. However, we always number them 0..11, with an intercalated, identically numbered leap month, when necessary. DAY_OF_YEAR In a non-leap year there are 353, 354, or 355 days. In a leap year there are 383, 384, or 385 days. WEEK_OF_YEAR The least maximum occurs if there are 353 days in the year, and the first 6 are the last week of the previous year. Then we have 49 full weeks and 4 days in the last week: 6 + 49///7 + 4 = 353. So the least maximum is 50. The maximum occurs if there are 385 days in the year, and WOY 1 extends 6 days into the prior year. Then there are 54 full weeks, and 6 days in the last week: 1 + 54///7 + 6 = 385. The 6 days of the last week will fall into WOY 1 of the next year. Maximum is 55. WEEK_OF_MONTH In a 29 day month, if the first 7 days make up week 1 that leaves 3 full weeks and 1 day at the end. The least maximum is thus 5. In a 30 days month, if the previous 6 days belong WOM 1 of this month, we have 4 full weeks and 1 days at the end (which technically will be WOM 1 of the next month, but will be reported by time->fields and hence by getActualMaximum as WOM 6 of this month). Maximum is 6. DAY_OF_WEEK_IN_MONTH In a 29 or 30 day month, there are 4 full weeks plus 1 or 2 days at the end, so the maximum is always 5.
	    /// </summary>
	    ///
	    private static readonly int[][] LIMITS = { new int[] { 1, 1, 83333, 83333 },
	            new int[] { 1, 1, 70, 70 }, new int[] { 0, 0, 11, 11 },
	            new int[] { 1, 1, 50, 55 }, new int[] { 1, 1, 4, 6 },
	            new int[] { 1, 1, 29, 30 }, new int[] { 1, 1, 353, 385 },
	            new int[] {}, new int[] { -1, -1, 5, 5 }, new int[] {},
	            new int[] {}, new int[] {}, new int[] {}, new int[] {},
	            new int[] {}, new int[] {}, new int[] {},
	            new int[] { -5000001, -5000001, 5000001, 5000001 }, new int[] {},
	            new int[] { -5000000, -5000000, 5000000, 5000000 }, new int[] {},
	            new int[] {}, new int[] { 0, 0, 1, 1 } };
	
	    /// <summary>
	    /// Override Calendar to return the limit value for the given field.
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    protected internal override int HandleGetLimit(int field, int limitType) {
	        return LIMITS[field][limitType];
	    }
	
	    /// <summary>
	    /// Implement abstract Calendar method to return the extended year defined by
	    /// the current fields. This will use either the ERA and YEAR field as the
	    /// cycle and year-of-cycle, or the EXTENDED_YEAR field as the continuous
	    /// year count, depending on which is newer.
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    protected internal override int HandleGetExtendedYear() {
	        int year;
	        if (NewestStamp(IBM.ICU.Util.Calendar.ERA, IBM.ICU.Util.Calendar.YEAR, IBM.ICU.Util.Calendar.UNSET) <= GetStamp(IBM.ICU.Util.Calendar.EXTENDED_YEAR)) {
	            year = InternalGet(IBM.ICU.Util.Calendar.EXTENDED_YEAR, 1); // Default to year 1
	        } else {
	            int cycle = InternalGet(IBM.ICU.Util.Calendar.ERA, 1) - 1; // 0-based cycle
	            year = cycle * 60 + InternalGet(IBM.ICU.Util.Calendar.YEAR, 1);
	        }
	        return year;
	    }
	
	    /// <summary>
	    /// Override Calendar method to return the number of days in the given
	    /// extended year and month.
	    /// <p>
	    /// Note: This method also reads the IS_LEAP_MONTH field to determine whether
	    /// or not the given month is a leap month.
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    protected internal override int HandleGetMonthLength(int extendedYear, int month) {
	        int thisStart = HandleComputeMonthStart(extendedYear, month, true)
	                - IBM.ICU.Util.Calendar.EPOCH_JULIAN_DAY + 1; // Julian day -> local days
	        int nextStart = NewMoonNear(thisStart + SYNODIC_GAP, true);
	        return nextStart - thisStart;
	    }
	
	    /// <summary>
	    /// Framework method to create a calendar-specific DateFormat object using
	    /// the the given pattern. This method is responsible for creating the
	    /// calendar- specific DateFormat and DateFormatSymbols objects as needed.
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    protected internal override IBM.ICU.Text.DateFormat HandleGetDateFormat(String pattern, ULocale locale) {
	        return new ChineseDateFormat(pattern, locale);
	    }
	
	    /// <summary>
	    /// Field resolution table that incorporates IS_LEAP_MONTH.
	    /// </summary>
	    ///
	    static internal readonly int[][][] CHINESE_DATE_PRECEDENCE = {
	            new int[][] { new int[]
	                    { IBM.ICU.Util.Calendar.DAY_OF_MONTH },
	                   new int[] { IBM.ICU.Util.Calendar.WEEK_OF_YEAR,
	                            IBM.ICU.Util.Calendar.DAY_OF_WEEK },
	                    new int[]{ IBM.ICU.Util.Calendar.WEEK_OF_MONTH,
	                            IBM.ICU.Util.Calendar.DAY_OF_WEEK },
	                    new int[]{ IBM.ICU.Util.Calendar.DAY_OF_WEEK_IN_MONTH,
	                            IBM.ICU.Util.Calendar.DAY_OF_WEEK },
	                    new int[]{ IBM.ICU.Util.Calendar.WEEK_OF_YEAR,
	                            IBM.ICU.Util.Calendar.DOW_LOCAL },
	                    new int[]{ IBM.ICU.Util.Calendar.WEEK_OF_MONTH,
	                            IBM.ICU.Util.Calendar.DOW_LOCAL },
	                   new int[] { IBM.ICU.Util.Calendar.DAY_OF_WEEK_IN_MONTH,
	                            IBM.ICU.Util.Calendar.DOW_LOCAL },
	                    new int[]{ IBM.ICU.Util.Calendar.DAY_OF_YEAR },
	                   new int[] {
	                            IBM.ICU.Util.Calendar.RESOLVE_REMAP
	                                    | IBM.ICU.Util.Calendar.DAY_OF_MONTH,
	                            IS_LEAP_MONTH } },
	            new int[][] { new int[]
	                    { IBM.ICU.Util.Calendar.WEEK_OF_YEAR },
	                    new int[]{ IBM.ICU.Util.Calendar.WEEK_OF_MONTH },
	                    new int[]{ IBM.ICU.Util.Calendar.DAY_OF_WEEK_IN_MONTH },
	                   new int[] {
	                            IBM.ICU.Util.Calendar.RESOLVE_REMAP
	                                    | IBM.ICU.Util.Calendar.DAY_OF_WEEK_IN_MONTH,
	                            IBM.ICU.Util.Calendar.DAY_OF_WEEK },
	                    new int[]{
	                            IBM.ICU.Util.Calendar.RESOLVE_REMAP
	                                    | IBM.ICU.Util.Calendar.DAY_OF_WEEK_IN_MONTH,
	                            IBM.ICU.Util.Calendar.DOW_LOCAL } } };
	
	    /// <summary>
	    /// Override Calendar to add IS_LEAP_MONTH to the field resolution table.
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    protected internal override int[][][] GetFieldResolutionTable() {
	        return CHINESE_DATE_PRECEDENCE;
	    }
	
	    /// <summary>
	    /// Adjust this calendar to be delta months before or after a given start
	    /// position, pinning the day of month if necessary. The start position is
	    /// given as a local days number for the start of the month and a
	    /// day-of-month. Used by add() and roll().
	    /// </summary>
	    ///
	    /// <param name="newMoon">the local days of the first day of the month of the startposition (days after January 1, 1970 0:00 Asia/Shanghai)</param>
	    /// <param name="dom">the 1-based day-of-month of the start position</param>
	    /// <param name="delta">the number of months to move forward or backward from thestart position</param>
	    private void OffsetMonth(int newMoon, int dom, int delta) {
	        // Move to the middle of the month before our target month.
	        newMoon += (int) (IBM.ICU.Impl.CalendarAstronomer.SYNODIC_MONTH * (delta - 0.5d));
	
	        // Search forward to the target month's new moon
	        newMoon = NewMoonNear(newMoon, true);
	
	        // Find the target dom
	        int jd = newMoon + IBM.ICU.Util.Calendar.EPOCH_JULIAN_DAY - 1 + dom;
	
	        // Pin the dom. In this calendar all months are 29 or 30 days
	        // so pinning just means handling dom 30.
	        if (dom > 29) {
	            Set(IBM.ICU.Util.Calendar.JULIAN_DAY, jd - 1);
	            // TODO Fix this. We really shouldn't ever have to
	            // explicitly call complete(). This is either a bug in
	            // this method, in ChineseCalendar, or in
	            // Calendar.getActualMaximum(). I suspect the last.
	            Complete();
	            if (GetActualMaximum(IBM.ICU.Util.Calendar.DAY_OF_MONTH) >= dom) {
	                Set(IBM.ICU.Util.Calendar.JULIAN_DAY, jd);
	            }
	        } else {
	            Set(IBM.ICU.Util.Calendar.JULIAN_DAY, jd);
	        }
	    }
	
	    /// <summary>
	    /// Override Calendar to handle leap months properly.
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    public override void Add(int field, int amount) {
	        switch (field) {
	        case IBM.ICU.Util.Calendar.MONTH:
	            if (amount != 0) {
	                int dom = Get(IBM.ICU.Util.Calendar.DAY_OF_MONTH);
	                int day = Get(IBM.ICU.Util.Calendar.JULIAN_DAY) - IBM.ICU.Util.Calendar.EPOCH_JULIAN_DAY; // Get local day
	                int moon = day - dom + 1; // New moon
	                OffsetMonth(moon, dom, amount);
	            }
	            break;
	        default:
	            base.Add(field,amount);
	            break;
	        }
	    }
	
	    /// <summary>
	    /// Override Calendar to handle leap months properly.
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    public override void Roll(int field, int amount) {
	        switch (field) {
	        case IBM.ICU.Util.Calendar.MONTH:
	            if (amount != 0) {
	                int dom = Get(IBM.ICU.Util.Calendar.DAY_OF_MONTH);
	                int day = Get(IBM.ICU.Util.Calendar.JULIAN_DAY) - IBM.ICU.Util.Calendar.EPOCH_JULIAN_DAY; // Get local day
	                int moon = day - dom + 1; // New moon (start of this month)
	
	                // Note throughout the following: Months 12 and 1 are never
	                // followed by a leap month (D&R p. 185).
	
	                // Compute the adjusted month number m. This is zero-based
	                // value from 0..11 in a non-leap year, and from 0..12 in a
	                // leap year.
	                int m = Get(IBM.ICU.Util.Calendar.MONTH); // 0-based month
	                if (isLeapYear) { // (member variable)
	                    if (Get(IS_LEAP_MONTH) == 1) {
	                        ++m;
	                    } else {
	                        // Check for a prior leap month. (In the
	                        // following, month 0 is the first month of the
	                        // year.) Month 0 is never followed by a leap
	                        // month, and we know month m is not a leap month.
	                        // moon1 will be the start of month 0 if there is
	                        // no leap month between month 0 and month m;
	                        // otherwise it will be the start of month 1.
	                        int moon1 = moon
	                                - (int) (IBM.ICU.Impl.CalendarAstronomer.SYNODIC_MONTH * (m - 0.5d));
	                        moon1 = NewMoonNear(moon1, true);
	                        if (IsLeapMonthBetween(moon1, moon)) {
	                            ++m;
	                        }
	                    }
	                }
	
	                // Now do the standard roll computation on m, with the
	                // allowed range of 0..n-1, where n is 12 or 13.
	                int n = (isLeapYear) ? 13 : 12; // Months in this year
	                int newM = (m + amount) % n;
	                if (newM < 0) {
	                    newM += n;
	                }
	
	                if (newM != m) {
	                    OffsetMonth(moon, dom, newM - m);
	                }
	            }
	            break;
	        default:
	            base.Roll(field,amount);
	            break;
	        }
	    }
	
	    // ------------------------------------------------------------------
	    // Support methods and constants
	    // ------------------------------------------------------------------
	
	    /// <summary>
	    /// The start year of the Chinese calendar, the 61st year of the reign of
	    /// Huang Di. Some sources use the first year of his reign, resulting in
	    /// EXTENDED_YEAR values 60 years greater and ERA (cycle) values one greater.
	    /// </summary>
	    ///
	    private const int CHINESE_EPOCH_YEAR = -2636; // Gregorian year
	
	    /// <summary>
	    /// The offset from GMT in milliseconds at which we perform astronomical
	    /// computations. Some sources use a different historically accurate offset
	    /// of GMT+7:45:40 for years before 1929; we do not do this.
	    /// </summary>
	    ///
	    private const long CHINA_OFFSET = 8 * IBM.ICU.Util.Calendar.ONE_HOUR;
	
	    /// <summary>
	    /// Value to be added or subtracted from the local days of a new moon to get
	    /// close to the next or prior new moon, but not cross it. Must be >= 1 and <
	    /// CalendarAstronomer.SYNODIC_MONTH.
	    /// </summary>
	    ///
	    private const int SYNODIC_GAP = 25;
	
	    /// <summary>
	    /// Convert local days to UTC epoch milliseconds.
	    /// </summary>
	    ///
	    /// <param name="days">days after January 1, 1970 0:00 Asia/Shanghai</param>
	    /// <returns>milliseconds after January 1, 1970 0:00 GMT</returns>
	    private static long DaysToMillis(int days) {
	        return (days * IBM.ICU.Util.Calendar.ONE_DAY) - CHINA_OFFSET;
	    }
	
	    /// <summary>
	    /// Convert UTC epoch milliseconds to local days.
	    /// </summary>
	    ///
	    /// <param name="millis">milliseconds after January 1, 1970 0:00 GMT</param>
	    /// <returns>days after January 1, 1970 0:00 Asia/Shanghai</returns>
	    private static int MillisToDays(long millis) {
	        return (int) IBM.ICU.Util.Calendar.FloorDivide(millis + CHINA_OFFSET, IBM.ICU.Util.Calendar.ONE_DAY);
	    }
	
	    // ------------------------------------------------------------------
	    // Astronomical computations
	    // ------------------------------------------------------------------
	
	    /// <summary>
	    /// Return the major solar term on or after December 15 of the given
	    /// Gregorian year, that is, the winter solstice of the given year.
	    /// Computations are relative to Asia/Shanghai time zone.
	    /// </summary>
	    ///
	    /// <param name="gyear">a Gregorian year</param>
	    /// <returns>days after January 1, 1970 0:00 Asia/Shanghai of the winter
	    /// solstice of the given year</returns>
	    private int WinterSolstice(int gyear) {
	
	        long cacheValue = winterSolsticeCache.Get(gyear);
	
	        if (cacheValue == IBM.ICU.Impl.CalendarCache.EMPTY) {
	            // In books December 15 is used, but it fails for some years
	            // using our algorithms, e.g.: 1298 1391 1492 1553 1560. That
	            // is, winterSolstice(1298) starts search at Dec 14 08:00:00
	            // PST 1298 with a final result of Dec 14 10:31:59 PST 1299.
	            long ms = DaysToMillis(ComputeGregorianMonthStart(gyear, IBM.ICU.Util.Calendar.DECEMBER)
	                    + 1 - IBM.ICU.Util.Calendar.EPOCH_JULIAN_DAY);
	            astro.SetTime(ms);
	
	            // Winter solstice is 270 degrees solar longitude aka Dongzhi
	            long solarLong = astro.GetSunTime(
	                    IBM.ICU.Impl.CalendarAstronomer.WINTER_SOLSTICE, true);
	            cacheValue = MillisToDays(solarLong);
	            winterSolsticeCache.Put(gyear, cacheValue);
	        }
	        return (int) cacheValue;
	    }
	
	    /// <summary>
	    /// Return the closest new moon to the given date, searching either forward
	    /// or backward in time.
	    /// </summary>
	    ///
	    /// <param name="days">days after January 1, 1970 0:00 Asia/Shanghai</param>
	    /// <param name="after">if true, search for a new moon on or after the given date;otherwise, search for a new moon before it</param>
	    /// <returns>days after January 1, 1970 0:00 Asia/Shanghai of the nearest new
	    /// moon after or before <c>days</c></returns>
	    private int NewMoonNear(int days, bool after) {
	
	        astro.SetTime(DaysToMillis(days));
	        long newMoon = astro.GetMoonTime(IBM.ICU.Impl.CalendarAstronomer.NEW_MOON, after);
	
	        return MillisToDays(newMoon);
	    }
	
	    /// <summary>
	    /// Return the nearest integer number of synodic months between two dates.
	    /// </summary>
	    ///
	    /// <param name="day1">days after January 1, 1970 0:00 Asia/Shanghai</param>
	    /// <param name="day2">days after January 1, 1970 0:00 Asia/Shanghai</param>
	    /// <returns>the nearest integer number of months between day1 and day2</returns>
	    private int SynodicMonthsBetween(int day1, int day2) {
	        return (int) Math.Round((day2 - day1)
	                        / IBM.ICU.Impl.CalendarAstronomer.SYNODIC_MONTH,MidpointRounding.AwayFromZero);
	    }
	
	    /// <summary>
	    /// Return the major solar term on or before a given date. This will be an
	    /// integer from 1..12, with 1 corresponding to 330 degrees, 2 to 0 degrees,
	    /// 3 to 30 degrees,..., and 12 to 300 degrees.
	    /// </summary>
	    ///
	    /// <param name="days">days after January 1, 1970 0:00 Asia/Shanghai</param>
	    private int MajorSolarTerm(int days) {
	
	        astro.SetTime(DaysToMillis(days));
	
	        // Compute (floor(solarLongitude / (pi/6)) + 2) % 12
	        int term = ((int) Math.Floor(6 * astro.GetSunLongitude() / System.Math.PI) + 2) % 12;
	        if (term < 1) {
	            term += 12;
	        }
	        return term;
	    }
	
	    /// <summary>
	    /// Return true if the given month lacks a major solar term.
	    /// </summary>
	    ///
	    /// <param name="newMoon">days after January 1, 1970 0:00 Asia/Shanghai of a new moon</param>
	    private bool HasNoMajorSolarTerm(int newMoon) {
	
	        int mst = MajorSolarTerm(newMoon);
	        int nmn = NewMoonNear(newMoon + SYNODIC_GAP, true);
	        int mstt = MajorSolarTerm(nmn);
	        return mst == mstt;
	        /*
	         * return majorSolarTerm(newMoon) == majorSolarTerm(newMoonNear(newMoon
	         * + SYNODIC_GAP, true));
	         */
	    }
	
	    // ------------------------------------------------------------------
	    // Time to fields
	    // ------------------------------------------------------------------
	
	    /// <summary>
	    /// Return true if there is a leap month on or after month newMoon1 and at or
	    /// before month newMoon2.
	    /// </summary>
	    ///
	    /// <param name="newMoon1">days after January 1, 1970 0:00 Asia/Shanghai of a new moon</param>
	    /// <param name="newMoon2">days after January 1, 1970 0:00 Asia/Shanghai of a new moon</param>
	    private bool IsLeapMonthBetween(int newMoon1, int newMoon2) {
	
	        // This is only needed to debug the timeOfAngle divergence bug.
	        // Remove this later. Liu 11/9/00
	        // DEBUG
	        if (SynodicMonthsBetween(newMoon1, newMoon2) >= 50) {
	            throw new ArgumentException("isLeapMonthBetween(" + newMoon1
	                    + ", " + newMoon2 + "): Invalid parameters");
	        }
	
	        return (newMoon2 >= newMoon1)
	                && (IsLeapMonthBetween(newMoon1,
	                        NewMoonNear(newMoon2 - SYNODIC_GAP, false)) || HasNoMajorSolarTerm(newMoon2));
	    }
	
	    /// <summary>
	    /// Override Calendar to compute several fields specific to the Chinese
	    /// calendar system. These are:
	    /// <ul>
	    /// <li>ERA
	    /// <li>YEAR
	    /// <li>MONTH
	    /// <li>DAY_OF_MONTH
	    /// <li>DAY_OF_YEAR
	    /// <li>EXTENDED_YEAR
	    /// </ul>
	    /// The DAY_OF_WEEK and DOW_LOCAL fields are already set when this method is
	    /// called. The getGregorianXxx() methods return Gregorian calendar
	    /// equivalents for the given Julian day.
	    /// <p>
	    /// Compute the ChineseCalendar-specific field IS_LEAP_MONTH.
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    protected internal override void HandleComputeFields(int julianDay) {
	
	        ComputeChineseFields(julianDay - IBM.ICU.Util.Calendar.EPOCH_JULIAN_DAY, // local days
	                GetGregorianYear(), GetGregorianMonth(), true); // set all
	                                                                // fields
	    }
	
	    /// <summary>
	    /// Compute fields for the Chinese calendar system. This method can either
	    /// set all relevant fields, as required by
	    /// <c>handleComputeFields()</c>, or it can just set the MONTH and
	    /// IS_LEAP_MONTH fields, as required by
	    /// <c>handleComputeMonthStart()</c>.
	    /// <p>
	    /// As a side effect, this method sets <see cref="F:IBM.ICU.Util.ChineseCalendar.isLeapYear"/>.
	    /// </summary>
	    ///
	    /// <param name="days">days after January 1, 1970 0:00 Asia/Shanghai of the date tocompute fields for</param>
	    /// <param name="gyear">the Gregorian year of the given date</param>
	    /// <param name="gmonth">the Gregorian month of the given date</param>
	    /// <param name="setAllFields">if true, set the EXTENDED_YEAR, ERA, YEAR, DAY_OF_MONTH, andDAY_OF_YEAR fields. In either case set the MONTH andIS_LEAP_MONTH fields.</param>
	    private void ComputeChineseFields(int days, int gyear, int gmonth,
	            bool setAllFields) {
	
	        // Find the winter solstices before and after the target date.
	        // These define the boundaries of this Chinese year, specifically,
	        // the position of month 11, which always contains the solstice.
	        // We want solsticeBefore <= date < solsticeAfter.
	        int solsticeBefore;
	        int solsticeAfter = WinterSolstice(gyear);
	        if (days < solsticeAfter) {
	            solsticeBefore = WinterSolstice(gyear - 1);
	        } else {
	            solsticeBefore = solsticeAfter;
	            solsticeAfter = WinterSolstice(gyear + 1);
	        }
	
	        // Find the start of the month after month 11. This will be either
	        // the prior month 12 or leap month 11 (very rare). Also find the
	        // start of the following month 11.
	        int firstMoon = NewMoonNear(solsticeBefore + 1, true);
	        int lastMoon = NewMoonNear(solsticeAfter + 1, false);
	        int thisMoon = NewMoonNear(days + 1, false); // Start of this month
	        // Note: isLeapYear is a member variable
	        isLeapYear = SynodicMonthsBetween(firstMoon, lastMoon) == 12;
	
	        int month = SynodicMonthsBetween(firstMoon, thisMoon);
	        if (isLeapYear && IsLeapMonthBetween(firstMoon, thisMoon)) {
	            month--;
	        }
	        if (month < 1) {
	            month += 12;
	        }
	
	        bool isLeapMonth = isLeapYear
	                && HasNoMajorSolarTerm(thisMoon)
	                && !IsLeapMonthBetween(firstMoon,
	                        NewMoonNear(thisMoon - SYNODIC_GAP, false));
	
	        InternalSet(IBM.ICU.Util.Calendar.MONTH, month - 1); // Convert from 1-based to 0-based
	        InternalSet(IS_LEAP_MONTH, (isLeapMonth) ? 1 : 0);
	
	        if (setAllFields) {
	
	            int year = gyear - CHINESE_EPOCH_YEAR;
	            if (month < 11 || gmonth >= IBM.ICU.Util.Calendar.JULY) {
	                year++;
	            }
	            int dayOfMonth = days - thisMoon + 1;
	
	            InternalSet(IBM.ICU.Util.Calendar.EXTENDED_YEAR, year);
	
	            // 0->0,60 1->1,1 60->1,60 61->2,1 etc.
	            int[] yearOfCycle = new int[1];
	            int cycle = IBM.ICU.Util.Calendar.FloorDivide(year - 1, 60, yearOfCycle);
	            InternalSet(IBM.ICU.Util.Calendar.ERA, cycle + 1);
	            InternalSet(IBM.ICU.Util.Calendar.YEAR, yearOfCycle[0] + 1);
	
	            InternalSet(IBM.ICU.Util.Calendar.DAY_OF_MONTH, dayOfMonth);
	
	            // Days will be before the first new year we compute if this
	            // date is in month 11, leap 11, 12. There is never a leap 12.
	            // New year computations are cached so this should be cheap in
	            // the long run.
	            int newYear = NewYear(gyear);
	            if (days < newYear) {
	                newYear = NewYear(gyear - 1);
	            }
	            InternalSet(IBM.ICU.Util.Calendar.DAY_OF_YEAR, days - newYear + 1);
	        }
	    }
	
	    // ------------------------------------------------------------------
	    // Fields to time
	    // ------------------------------------------------------------------
	
	    /// <summary>
	    /// Return the Chinese new year of the given Gregorian year.
	    /// </summary>
	    ///
	    /// <param name="gyear">a Gregorian year</param>
	    /// <returns>days after January 1, 1970 0:00 Asia/Shanghai of the Chinese new
	    /// year of the given year (this will be a new moon)</returns>
	    private int NewYear(int gyear) {
	
	        long cacheValue = newYearCache.Get(gyear);
	
	        if (cacheValue == IBM.ICU.Impl.CalendarCache.EMPTY) {
	
	            int solsticeBefore = WinterSolstice(gyear - 1);
	            int solsticeAfter = WinterSolstice(gyear);
	            int newMoon1 = NewMoonNear(solsticeBefore + 1, true);
	            int newMoon2 = NewMoonNear(newMoon1 + SYNODIC_GAP, true);
	            int newMoon11 = NewMoonNear(solsticeAfter + 1, false);
	
	            if (SynodicMonthsBetween(newMoon1, newMoon11) == 12
	                    && (HasNoMajorSolarTerm(newMoon1) || HasNoMajorSolarTerm(newMoon2))) {
	                cacheValue = NewMoonNear(newMoon2 + SYNODIC_GAP, true);
	            } else {
	                cacheValue = newMoon2;
	            }
	
	            newYearCache.Put(gyear, cacheValue);
	        }
	        return (int) cacheValue;
	    }
	
	    /// <summary>
	    /// Return the Julian day number of day before the first day of the given
	    /// month in the given extended year.
	    /// <p>
	    /// Note: This method reads the IS_LEAP_MONTH field to determine whether the
	    /// given month is a leap month.
	    /// </summary>
	    ///
	    /// <param name="eyear">the extended year</param>
	    /// <param name="month">the zero-based month. The month is also determined by readingthe IS_LEAP_MONTH field.</param>
	    /// <returns>the Julian day number of the day before the first day of the
	    /// given month and year</returns>
	    /// @stable ICU 2.8
	    protected internal override int HandleComputeMonthStart(int eyear, int month, bool useMonth) {
	
	        // If the month is out of range, adjust it into range, and
	        // modify the extended year value accordingly.
	        if (month < 0 || month > 11) {
	            int[] rem = new int[1];
	            eyear += IBM.ICU.Util.Calendar.FloorDivide(month, 12, rem);
	            month = rem[0];
	        }
	
	        int gyear = eyear + CHINESE_EPOCH_YEAR - 1; // Gregorian year
	        int newYear = NewYear(gyear);
	        int newMoon = NewMoonNear(newYear + month * 29, true);
	
	        int julianDay = newMoon + IBM.ICU.Util.Calendar.EPOCH_JULIAN_DAY;
	
	        // Save fields for later restoration
	        int saveMonth = InternalGet(IBM.ICU.Util.Calendar.MONTH);
	        int saveIsLeapMonth = InternalGet(IS_LEAP_MONTH);
	
	        // Ignore IS_LEAP_MONTH field if useMonth is false
	        int isLeapMonth = (useMonth) ? saveIsLeapMonth : 0;
	
	        ComputeGregorianFields(julianDay);
	
	        // This will modify the MONTH and IS_LEAP_MONTH fields (only)
	        ComputeChineseFields(newMoon, GetGregorianYear(), GetGregorianMonth(),
	                false);
	
	        if (month != InternalGet(IBM.ICU.Util.Calendar.MONTH)
	                || isLeapMonth != InternalGet(IS_LEAP_MONTH)) {
	            newMoon = NewMoonNear(newMoon + SYNODIC_GAP, true);
	            julianDay = newMoon + IBM.ICU.Util.Calendar.EPOCH_JULIAN_DAY;
	        }
	
	        InternalSet(IBM.ICU.Util.Calendar.MONTH, saveMonth);
	        InternalSet(IS_LEAP_MONTH, saveIsLeapMonth);
	
	        return julianDay - 1;
	    }
	
	    /// <summary>
	    /// Return the current Calendar type.
	    /// </summary>
	    ///
	    /// <returns>type of calendar</returns>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public override String GetType() {
	        return "chinese";
	    }
	
	    /// <summary>
	    /// Override readObject.
	    /// </summary>
	    ///
	    private void ReadObject(IlObjectInputStream stream) {
	        stream.DefaultReadObject();
	
	        /* set up the transient caches... */
	        astro = new CalendarAstronomer();
	        winterSolsticeCache = new CalendarCache();
	        newYearCache = new CalendarCache();
	    }
	
	    /*
	     * private static CalendarFactory factory; public static CalendarFactory
	     * factory() { if (factory == null) { factory = new CalendarFactory() {
	     * public Calendar create(TimeZone tz, ULocale loc) { return new
	     * ChineseCalendar(tz, loc); }
	     * 
	     * public String factoryName() { return "Chinese"; } }; } return factory; }
	     */
	}
}
