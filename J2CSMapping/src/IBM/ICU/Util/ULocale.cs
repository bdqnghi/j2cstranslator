/*
 ******************************************************************************
 * Copyright (C) 2003-2007, International Business Machines Corporation and   *
 * others. All Rights Reserved.                                               *
 ******************************************************************************
 */

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:47 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Util {
	
	using IBM.ICU.Impl;
	using ILOG.J2CsMapping.Collections;
	using ILOG.J2CsMapping.Collections.Generics;
	using ILOG.J2CsMapping.Util;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.Globalization;
	using System.IO;
	using System.Resources;
	using System.Runtime.CompilerServices;
	using System.Runtime.Serialization;
	using System.Text;
     using ILOG.J2CsMapping.Util.Culture;
     using ILOG.J2CsMapping.Util;
	
	/// <summary>
	/// A class analogous to <see cref="T:System.Globalization.CultureInfo"/> that provides additional
	/// support for ICU protocol. In ICU 3.0 this class is enhanced to support RFC
	/// 3066 language identifiers.
	/// <p>
	/// Many classes and services in ICU follow a factory idiom, in which a factory
	/// method or object responds to a client request with an object. The request
	/// includes a locale (the <i>requested</i> locale), and the returned object is
	/// constructed using data for that locale. The system may lack data for the
	/// requested locale, in which case the locale fallback mechanism will be invoked
	/// until a populated locale is found (the <i>valid</i> locale). Furthermore,
	/// even when a populated locale is found (the <i>valid</i> locale), further
	/// fallback may be required to reach a locale containing the specific data
	/// required by the service (the <i>actual</i> locale).
	/// <p>
	/// ULocale performs <b>'normalization'</b> and <b>'canonicalization'</b> of
	/// locale ids. Normalization 'cleans up' ICU locale ids as follows:
	/// <ul>
	/// <li>language, script, country, variant, and keywords are properly cased<br>
	/// (lower, title, upper, upper, and lower case respectively)</li>
	/// <li>hyphens used as separators are converted to underscores</li>
	/// <li>three-letter language and country ids are converted to two-letter
	/// equivalents where available</li>
	/// <li>surrounding spaces are removed from keywords and values</li>
	/// <li>if there are multiple keywords, they are put in sorted order</li>
	/// </ul>
	/// Canonicalization additionally performs the following:
	/// <ul>
	/// <li>POSIX ids are converted to ICU format IDs</li>
	/// <li>'grandfathered' 3066 ids are converted to ICU standard form</li>
	/// <li>'PREEURO' and 'EURO' variants are converted to currency keyword form,
	/// with the currency id appropriate to the country of the locale (for PREEURO)
	/// or EUR (for EURO).
	/// </ul>
	/// All ULocale constructors automatically normalize the locale id. To handle
	/// POSIX ids, <c>canonicalize</c> can be called to convert the id to
	/// canonical form, or the <c>canonicalInstance</c> factory method can be
	/// called.
	/// </p>
	/// <p>
	/// This class provides selectors <see cref="F:IBM.ICU.Util.ULocale.VALID_LOCALE"/> and<see cref="F:IBM.ICU.Util.ULocale.ACTUAL_LOCALE"/> intended for use in methods named <tt>getLocale()</tt>
	/// . These methods exist in several ICU classes, including<see cref="T:IBM.ICU.Util.Calendar"/>, <see cref="T:IBM.ICU.Util.Currency"/>,<see cref="T:IBM.ICU.Util.UFormat"/>, <see cref="T:IBM.ICU.Util.BreakIterator"/>,<see cref="T:IBM.ICU.Util.Collator"/>, <see cref="T:IBM.ICU.Util.DateFormatSymbols"/>, and <see cref="T:IBM.ICU.Util.DecimalFormatSymbols"/> and their subclasses, if
	/// any. Once an object of one of these classes has been created,
	/// <tt>getLocale()</tt> may be called on it to determine the valid and actual
	/// locale arrived at during the object's construction.
	/// <p>
	/// Note: The <tt>getLocale()</tt> method will be implemented in ICU 3.0; ICU 2.8
	/// contains a partial preview implementation. The <i>actual</i> locale is
	/// returned correctly, but the <i>valid</i> locale is not, in most cases.
	/// </summary>
	///
	/// <seealso cref="T:System.Globalization.CultureInfo"/>
	/// @stable ICU 2.8
	[Serializable]
	public sealed class ULocale {
	    // using serialver from jdk1.4.2_05
	    private const long serialVersionUID = 3715177670352309217L;

        private static WeakReference nameCacheRef = new WeakReference(
	            ILOG.J2CsMapping.Collections.Generics.Collections.SynchronizedMap(new Hashtable()));

	    /// <summary>
	    /// Useful constant for language.
	    /// </summary>
	    ///
	    /// @stable ICU 3.0
        public static readonly ULocale ENGLISH = new ULocale("en", Locale.ENGLISH);
	
	    /// <summary>
	    /// Useful constant for language.
	    /// </summary>
	    ///
	    /// @stable ICU 3.0
        public static readonly ULocale FRENCH = new ULocale("fr", Locale.FRENCH);
	
	    /// <summary>
	    /// Useful constant for language.
	    /// </summary>
	    ///
	    /// @stable ICU 3.0
        public static readonly ULocale GERMAN = new ULocale("de", Locale.GERMAN);
	
	    /// <summary>
	    /// Useful constant for language.
	    /// </summary>
	    ///
	    /// @stable ICU 3.0
        public static readonly ULocale ITALIAN = new ULocale("it", Locale.ITALIAN);
	
	    /// <summary>
	    /// Useful constant for language.
	    /// </summary>
	    ///
	    /// @stable ICU 3.0
        public static readonly ULocale JAPANESE = new ULocale("ja", Locale.JAPANESE);
	
	    /// <summary>
	    /// Useful constant for language.
	    /// </summary>
	    ///
	    /// @stable ICU 3.0
        public static readonly ULocale KOREAN = new ULocale("ko", Locale.KOREAN);
	
	    /// <summary>
	    /// Useful constant for language.
	    /// </summary>
	    ///
	    /// @stable ICU 3.0
        public static readonly ULocale CHINESE = new ULocale("zh", Locale.CHINESE);
	
	    /// <summary>
	    /// Useful constant for language.
	    /// </summary>
	    ///
	    /// @stable ICU 3.0
	    public static readonly ULocale SIMPLIFIED_CHINESE = new ULocale("zh_Hans",
                Locale.CHINESE);
	
	    /// <summary>
	    /// Useful constant for language.
	    /// </summary>
	    ///
	    /// @stable ICU 3.0
	    public static readonly ULocale TRADITIONAL_CHINESE = new ULocale("zh_Hant",
                Locale.CHINESE);
	
	    /// <summary>
	    /// Useful constant for country/region.
	    /// </summary>
	    ///
	    /// @stable ICU 3.0
        public static readonly ULocale FRANCE = new ULocale("fr_FR", Locale.FRANCE);
	
	    /// <summary>
	    /// Useful constant for country/region.
	    /// </summary>
	    ///
	    /// @stable ICU 3.0
        public static readonly ULocale GERMANY = new ULocale("de_DE", Locale.GERMANY);
	
	    /// <summary>
	    /// Useful constant for country/region.
	    /// </summary>
	    ///
	    /// @stable ICU 3.0
        public static readonly ULocale ITALY = new ULocale("it_IT", Locale.ITALY);
	
	    /// <summary>
	    /// Useful constant for country/region.
	    /// </summary>
	    ///
	    /// @stable ICU 3.0
        public static readonly ULocale JAPAN = new ULocale("ja_JP", Locale.JAPAN);
	
	    /// <summary>
	    /// Useful constant for country/region.
	    /// </summary>
	    ///
	    /// @stable ICU 3.0
        public static readonly ULocale KOREA = new ULocale("ko_KR", Locale.KOREA);
	
	    /// <summary>
	    /// Useful constant for country/region.
	    /// </summary>
	    ///
	    /// @stable ICU 3.0
        public static readonly ULocale CHINA = new ULocale("zh_Hans_CN", Locale.CHINA);
	
	    /// <summary>
	    /// Useful constant for country/region.
	    /// </summary>
	    ///
	    /// @stable ICU 3.0
	    public static readonly ULocale PRC = CHINA;
	
	    /// <summary>
	    /// Useful constant for country/region.
	    /// </summary>
	    ///
	    /// @stable ICU 3.0
	    public static readonly ULocale TAIWAN = new ULocale("zh_Hant_TW",
                Locale.TAIWAN);
	
	    /// <summary>
	    /// Useful constant for country/region.
	    /// </summary>
	    ///
	    /// @stable ICU 3.0
        public static readonly ULocale UK = new ULocale("en_GB", Locale.UK);
	
	    /// <summary>
	    /// Useful constant for country/region.
	    /// </summary>
	    ///
	    /// @stable ICU 3.0
        public static readonly ULocale US = new ULocale("en_US", Locale.US);
	
	    /// <summary>
	    /// Useful constant for country/region.
	    /// </summary>
	    ///
	    /// @stable ICU 3.0
        public static readonly ULocale CANADA = new ULocale("en_CA", Locale.CANADA);
	
	    /// <summary>
	    /// Useful constant for country/region.
	    /// </summary>
	    ///
	    /// @stable ICU 3.0
	    public static readonly ULocale CANADA_FRENCH = new ULocale("fr_CA",
                Locale.CANADA_FRENCH);
	
	    /// <summary>
	    /// Handy constant.
	    /// </summary>
	    ///
	    private const String EMPTY_STRING = "";
	
	    // Used in both ULocale and IDParser, so moved up here.
	    private const char UNDERSCORE = '_';
	
	    // default empty locale
        private static readonly Locale EMPTY_LOCALE = new Locale("", "");
	
	    /// <summary>
	    /// The root ULocale.
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    public static readonly ULocale ROOT = new ULocale("root", EMPTY_LOCALE);
	
	    private static readonly SimpleCache CACHE = new SimpleCache();
	
	    /// <summary>
	    /// Cache the locale.
	    /// </summary>
	    ///
        private Locale locale;
	
	    /// <summary>
	    /// The raw localeID that we were passed in.
	    /// </summary>
	    ///
	    private String localeID;
	
	    /// <summary>
	    /// Tables used in normalizing portions of the id.
	    /// </summary>
	    ///
	    /*
	     * tables updated per http://lcweb.loc.gov/standards/iso639-2/ to include
	     * the revisions up to 2001/7/27 *CWB
	     */
	    /*
	     * The 3 character codes are the terminology codes like RFC 3066. This is
	     * compatible with prior ICU codes
	     */
	    /*
	     * "in" "iw" "ji" "jw" & "sh" have been withdrawn but are still in the table
	     * but now at the end of the table because 3 character codes are duplicates.
	     * This avoids bad searches going from 3 to 2 character codes.
	     */
	    /* The range qaa-qtz is reserved for local use. */
	
	    private static String[] _languages;
	
	    private static String[] _replacementLanguages;
	
	    private static String[] _obsoleteLanguages;
	
	    private static String[] _languages3;
	
	    private static String[] _obsoleteLanguages3;
	
	    // Avoid initializing languages tables unless we have to.
	    private static void InitLanguageTables() {
	        if (_languages == null) {
	
	            /*
	             * This list MUST be in sorted order, and MUST contain the
	             * two-letter codes if one exists otherwise use the three letter
	             * code
	             */
	            String[] tempLanguages = { "aa", "ab", "ace", "ach", "ada", "ady",
	                    "ae", "af", "afa", "afh", "ak", "akk", "ale", "alg", "am",
	                    "an", "ang", "apa", "ar", "arc", "arn", "arp", "art",
	                    "arw", "as", "ast", "ath", "aus", "av", "awa", "ay", "az",
	                    "ba", "bad", "bai", "bal", "ban", "bas", "bat", "be",
	                    "bej", "bem", "ber", "bg", "bh", "bho", "bi", "bik", "bin",
	                    "bla", "bm", "bn", "bnt", "bo", "br", "bra", "bs", "btk",
	                    "bua", "bug", "byn", "ca", "cad", "cai", "car", "cau",
	                    "ce", "ceb", "cel", "ch", "chb", "chg", "chk", "chm",
	                    "chn", "cho", "chp", "chr", "chy", "cmc", "co", "cop",
	                    "cpe", "cpf", "cpp", "cr", "crh", "crp", "cs", "csb", "cu",
	                    "cus", "cv", "cy", "da", "dak", "dar", "day", "de", "del",
	                    "den", "dgr", "din", "doi", "dra", "dsb", "dua", "dum",
	                    "dv", "dyu", "dz", "ee", "efi", "egy", "eka", "el", "elx",
	                    "en", "enm", "eo", "es", "et", "eu", "ewo", "fa", "fan",
	                    "fat", "ff", "fi", "fiu", "fj", "fo", "fon", "fr", "frm",
	                    "fro", "fur", "fy", "ga", "gaa", "gay", "gba", "gd", "gem",
	                    "gez", "gil", "gl", "gmh", "gn", "goh", "gon", "gor",
	                    "got", "grb", "grc", "gu", "gv", "gwi", "ha", "hai", "haw",
	                    "he", "hi", "hil", "him", "hit", "hmn", "ho", "hr", "hsb",
	                    "ht", "hu", "hup", "hy", "hz", "ia", "iba", "id", "ie",
	                    "ig", "ii", "ijo", "ik", "ilo", "inc", "ine", "inh", "io",
	                    "ira", "iro", "is", "it", "iu", "ja", "jbo", "jpr", "jrb",
	                    "jv", "ka", "kaa", "kab", "kac", "kam", "kar", "kaw",
	                    "kbd", "kg", "kha", "khi", "kho", "ki", "kj", "kk", "kl",
	                    "km", "kmb", "kn", "ko", "kok", "kos", "kpe", "kr", "krc",
	                    "kro", "kru", "ks", "ku", "kum", "kut", "kv", "kw", "ky",
	                    "la", "lad", "lah", "lam", "lb", "lez", "lg", "li", "ln",
	                    "lo", "lol", "loz", "lt", "lu", "lua", "lui", "lun", "luo",
	                    "lus", "lv", "mad", "mag", "mai", "mak", "man", "map",
	                    "mas", "mdf", "mdr", "men", "mg", "mga", "mh", "mi", "mic",
	                    "min", "mis", "mk", "mkh", "ml", "mn", "mnc", "mni", "mno",
	                    "mo", "moh", "mos", "mr", "ms", "mt", "mul", "mun", "mus",
	                    "mwr", "my", "myn", "myv", "na", "nah", "nai", "nap", "nb",
	                    "nd", "nds", "ne", "new", "ng", "nia", "nic", "niu", "nl",
	                    "nn", "no", "nog", "non", "nr", "nso", "nub", "nv", "nwc",
	                    "ny", "nym", "nyn", "nyo", "nzi", "oc", "oj", "om", "or",
	                    "os", "osa", "ota", "oto", "pa", "paa", "pag", "pal",
	                    "pam", "pap", "pau", "peo", "phi", "phn", "pi", "pl",
	                    "pon", "pra", "pro", "ps", "pt", "qu", "raj", "rap", "rar",
	                    "rm", "rn", "ro", "roa", "rom", "ru", "rup", "rw", "sa",
	                    "sad", "sah", "sai", "sal", "sam", "sas", "sat", "sc",
	                    "sco", "sd", "se", "sel", "sem", "sg", "sga", "sgn", "shn",
	                    "si", "sid", "sio", "sit", "sk", "sl", "sla", "sm", "sma",
	                    "smi", "smj", "smn", "sms", "sn", "snk", "so", "sog",
	                    "son", "sq", "sr", "srr", "ss", "ssa", "st", "su", "suk",
	                    "sus", "sux", "sv", "sw", "syr", "ta", "tai", "te", "tem",
	                    "ter", "tet", "tg", "th", "ti", "tig", "tiv", "tk", "tkl",
	                    "tl", "tlh", "tli", "tmh", "tn", "to", "tog", "tpi", "tr",
	                    "ts", "tsi", "tt", "tum", "tup", "tut", "tvl", "tw", "ty",
	                    "tyv", "udm", "ug", "uga", "uk", "umb", "und", "ur", "uz",
	                    "vai", "ve", "vi", "vo", "vot", "wa", "wak", "wal", "war",
	                    "was", "wen", "wo", "xal", "xh", "yao", "yap", "yi", "yo",
	                    "ypk", "za", "zap", "zen", "zh", "znd", "zu", "zun", };
	
	            String[] tempReplacementLanguages = { "id", "he", "yi", "jv", "sr",
	                    "nb",/* replacement language codes */
	            };
	
	            String[] tempObsoleteLanguages = { "in", "iw", "ji", "jw", "sh",
	                    "no", /* obsolete language codes */
	            };
	
	            /*
	             * This list MUST contain a three-letter code for every two-letter
	             * code in the list above, and they MUST ne in the same order (i.e.,
	             * the same language must be in the same place in both lists)!
	             */
	            String[] tempLanguages3 = {
	            /* "aa", "ab", "ace", "ach", "ada", "ady", "ae", "af", "afa", */
	            "aar", "abk", "ace", "ach", "ada", "ady", "ave", "afr", "afa",
	            /* "afh", "ak", "akk", "ale", "alg", "am", "an", "ang", "apa", */
	            "afh", "aka", "akk", "ale", "alg", "amh", "arg", "ang", "apa",
	            /* "ar", "arc", "arn", "arp", "art", "arw", "as", "ast", */
	            "ara", "arc", "arn", "arp", "art", "arw", "asm", "ast",
	            /* "ath", "aus", "av", "awa", "ay", "az", "ba", "bad", */
	            "ath", "aus", "ava", "awa", "aym", "aze", "bak", "bad",
	            /* "bai", "bal", "ban", "bas", "bat", "be", "bej", */
	            "bai", "bal", "ban", "bas", "bat", "bel", "bej",
	            /* "bem", "ber", "bg", "bh", "bho", "bi", "bik", "bin", */
	            "bem", "ber", "bul", "bih", "bho", "bis", "bik", "bin",
	            /* "bla", "bm", "bn", "bnt", "bo", "br", "bra", "bs", */
	            "bla", "bam", "ben", "bnt", "bod", "bre", "bra", "bos",
	            /* "btk", "bua", "bug", "byn", "ca", "cad", "cai", "car", "cau", */
	            "btk", "bua", "bug", "byn", "cat", "cad", "cai", "car", "cau",
	            /* "ce", "ceb", "cel", "ch", "chb", "chg", "chk", "chm", */
	            "che", "ceb", "cel", "cha", "chb", "chg", "chk", "chm",
	            /* "chn", "cho", "chp", "chr", "chy", "cmc", "co", "cop", */
	            "chn", "cho", "chp", "chr", "chy", "cmc", "cos", "cop",
	            /*
	             * "cpe", "cpf", "cpp", "cr", "crh", "crp", "cs", "csb", "cu",
	             * "cus",
	             */
	            "cpe", "cpf", "cpp", "cre", "crh", "crp", "ces", "csb", "chu",
	                    "cus",
	                    /*
	                     * "cv", "cy", "da", "dak", "dar", "day", "de", "del",
	                     * "den",
	                     */
	                    "chv", "cym", "dan", "dak", "dar", "day", "deu", "del",
	                    "den",
	                    /*
	                     * "dgr", "din", "doi", "dra", "dsb", "dua", "dum", "dv",
	                     * "dyu",
	                     */
	                    "dgr", "din", "doi", "dra", "dsb", "dua", "dum", "div",
	                    "dyu",
	                    /* "dz", "ee", "efi", "egy", "eka", "el", "elx", "en", */
	                    "dzo", "ewe", "efi", "egy", "eka", "ell", "elx", "eng",
	                    /* "enm", "eo", "es", "et", "eu", "ewo", "fa", */
	                    "enm", "epo", "spa", "est", "eus", "ewo", "fas",
	                    /* "fan", "fat", "ff", "fi", "fiu", "fj", "fo", "fon", */
	                    "fan", "fat", "ful", "fin", "fiu", "fij", "fao", "fon",
	                    /* "fr", "frm", "fro", "fur", "fy", "ga", "gaa", "gay", */
	                    "fra", "frm", "fro", "fur", "fry", "gle", "gaa", "gay",
	                    /* "gba", "gd", "gem", "gez", "gil", "gl", "gmh", "gn", */
	                    "gba", "gla", "gem", "gez", "gil", "glg", "gmh", "grn",
	                    /* "goh", "gon", "gor", "got", "grb", "grc", "gu", "gv", */
	                    "goh", "gon", "gor", "got", "grb", "grc", "guj", "glv",
	                    /* "gwi", "ha", "hai", "haw", "he", "hi", "hil", "him", */
	                    "gwi", "hau", "hai", "haw", "heb", "hin", "hil", "him",
	                    /*
	                     * "hit", "hmn", "ho", "hr", "hsb", "ht", "hu", "hup", "hy",
	                     * "hz",
	                     */
	                    "hit", "hmn", "hmo", "hrv", "hsb", "hat", "hun", "hup",
	                    "hye", "her",
	                    /* "ia", "iba", "id", "ie", "ig", "ii", "ijo", "ik", */
	                    "ina", "iba", "ind", "ile", "ibo", "iii", "ijo", "ipk",
	                    /*
	                     * "ilo", "inc", "ine", "inh", "io", "ira", "iro", "is",
	                     * "it",
	                     */
	                    "ilo", "inc", "ine", "inh", "ido", "ira", "iro", "isl",
	                    "ita",
	                    /*
	                     * "iu", "ja", "jbo", "jpr", "jrb", "jv", "ka", "kaa",
	                     * "kab",
	                     */
	                    "iku", "jpn", "jbo", "jpr", "jrb", "jaw", "kat", "kaa",
	                    "kab",
	                    /* "kac", "kam", "kar", "kaw", "kbd", "kg", "kha", "khi", */
	                    "kac", "kam", "kar", "kaw", "kbd", "kon", "kha", "khi",
	                    /* "kho", "ki", "kj", "kk", "kl", "km", "kmb", "kn", */
	                    "kho", "kik", "kua", "kaz", "kal", "khm", "kmb", "kan",
	                    /*
	                     * "ko", "kok", "kos", "kpe", "kr", "krc", "kro", "kru",
	                     * "ks",
	                     */
	                    "kor", "kok", "kos", "kpe", "kau", "krc", "kro", "kru",
	                    "kas",
	                    /* "ku", "kum", "kut", "kv", "kw", "ky", "la", "lad", */
	                    "kur", "kum", "kut", "kom", "cor", "kir", "lat", "lad",
	                    /* "lah", "lam", "lb", "lez", "lg", "li", "ln", "lo", "lol", */
	                    "lah", "lam", "ltz", "lez", "lug", "lim", "lin", "lao",
	                    "lol",
	                    /* "loz", "lt", "lu", "lua", "lui", "lun", "luo", "lus", */
	                    "loz", "lit", "lub", "lua", "lui", "lun", "luo", "lus",
	                    /* "lv", "mad", "mag", "mai", "mak", "man", "map", "mas", */
	                    "lav", "mad", "mag", "mai", "mak", "man", "map", "mas",
	                    /*
	                     * "mdf", "mdr", "men", "mg", "mga", "mh", "mi", "mic",
	                     * "min",
	                     */
	                    "mdf", "mdr", "men", "mlg", "mga", "mah", "mri", "mic",
	                    "min",
	                    /* "mis", "mk", "mkh", "ml", "mn", "mnc", "mni", "mno", */
	                    "mis", "mkd", "mkh", "mal", "mon", "mnc", "mni", "mno",
	                    /* "mo", "moh", "mos", "mr", "ms", "mt", "mul", "mun", */
	                    "mol", "moh", "mos", "mar", "msa", "mlt", "mul", "mun",
	                    /*
	                     * "mus", "mwr", "my", "myn", "myv", "na", "nah", "nai",
	                     * "nap",
	                     */
	                    "mus", "mwr", "mya", "myn", "myv", "nau", "nah", "nai",
	                    "nap",
	                    /* "nb", "nd", "nds", "ne", "new", "ng", "nia", "nic", */
	                    "nob", "nde", "nds", "nep", "new", "ndo", "nia", "nic",
	                    /*
	                     * "niu", "nl", "nn", "no", "nog", "non", "nr", "nso",
	                     * "nub",
	                     */
	                    "niu", "nld", "nno", "nor", "nog", "non", "nbl", "nso",
	                    "nub",
	                    /*
	                     * "nv", "nwc", "ny", "nym", "nyn", "nyo", "nzi", "oc",
	                     * "oj",
	                     */
	                    "nav", "nwc", "nya", "nym", "nyn", "nyo", "nzi", "oci",
	                    "oji",
	                    /* "om", "or", "os", "osa", "ota", "oto", "pa", "paa", */
	                    "orm", "ori", "oss", "osa", "ota", "oto", "pan", "paa",
	                    /* "pag", "pal", "pam", "pap", "pau", "peo", "phi", "phn", */
	                    "pag", "pal", "pam", "pap", "pau", "peo", "phi", "phn",
	                    /* "pi", "pl", "pon", "pra", "pro", "ps", "pt", "qu", */
	                    "pli", "pol", "pon", "pra", "pro", "pus", "por", "que",
	                    /* "raj", "rap", "rar", "rm", "rn", "ro", "roa", "rom", */
	                    "raj", "rap", "rar", "roh", "run", "ron", "roa", "rom",
	                    /*
	                     * "ru", "rup", "rw", "sa", "sad", "sah", "sai", "sal",
	                     * "sam",
	                     */
	                    "rus", "rup", "kin", "san", "sad", "sah", "sai", "sal",
	                    "sam",
	                    /* "sas", "sat", "sc", "sco", "sd", "se", "sel", "sem", */
	                    "sas", "sat", "srd", "sco", "snd", "sme", "sel", "sem",
	                    /* "sg", "sga", "sgn", "shn", "si", "sid", "sio", "sit", */
	                    "sag", "sga", "sgn", "shn", "sin", "sid", "sio", "sit",
	                    /* "sk", "sl", "sla", "sm", "sma", "smi", "smj", "smn", */
	                    "slk", "slv", "sla", "smo", "sma", "smi", "smj", "smn",
	                    /* "sms", "sn", "snk", "so", "sog", "son", "sq", "sr", */
	                    "sms", "sna", "snk", "som", "sog", "son", "sqi", "srp",
	                    /* "srr", "ss", "ssa", "st", "su", "suk", "sus", "sux", */
	                    "srr", "ssw", "ssa", "sot", "sun", "suk", "sus", "sux",
	                    /* "sv", "sw", "syr", "ta", "tai", "te", "tem", "ter", */
	                    "swe", "swa", "syr", "tam", "tai", "tel", "tem", "ter",
	                    /* "tet", "tg", "th", "ti", "tig", "tiv", "tk", "tkl", */
	                    "tet", "tgk", "tha", "tir", "tig", "tiv", "tuk", "tkl",
	                    /*
	                     * "tl", "tlh", "tli", "tmh", "tn", "to", "tog", "tpi",
	                     * "tr",
	                     */
	                    "tgl", "tlh", "tli", "tmh", "tsn", "ton", "tog", "tpi",
	                    "tur",
	                    /* "ts", "tsi", "tt", "tum", "tup", "tut", "tvl", "tw", */
	                    "tso", "tsi", "tat", "tum", "tup", "tut", "tvl", "twi",
	                    /*
	                     * "ty", "tyv", "udm", "ug", "uga", "uk", "umb", "und",
	                     * "ur",
	                     */
	                    "tah", "tyv", "udm", "uig", "uga", "ukr", "umb", "und",
	                    "urd",
	                    /* "uz", "vai", "ve", "vi", "vo", "vot", "wa", "wak", */
	                    "uzb", "vai", "ven", "vie", "vol", "vot", "wln", "wak",
	                    /*
	                     * "wal", "war", "was", "wen", "wo", "xal", "xh", "yao",
	                     * "yap",
	                     */
	                    "wal", "war", "was", "wen", "wol", "xal", "xho", "yao",
	                    "yap",
	                    /* "yi", "yo", "ypk", "za", "zap", "zen", "zh", "znd", */
	                    "yid", "yor", "ypk", "zha", "zap", "zen", "zho", "znd",
	                    /* "zu", "zun", */
	                    "zul", "zun", };
	
	            String[] tempObsoleteLanguages3 = {
	            /* "in", "iw", "ji", "jw", "sh", */
	            "ind", "heb", "yid", "jaw", "srp", };
	
	             lock (typeof(ULocale)) {
	                            if (_languages == null) {
	                                _languages = tempLanguages;
	                                _replacementLanguages = tempReplacementLanguages;
	                                _obsoleteLanguages = tempObsoleteLanguages;
	                                _languages3 = tempLanguages3;
	                                _obsoleteLanguages3 = tempObsoleteLanguages3;
	                            }
	                        }
	        }
	    }
	
	    private static String[] _countries;
	
	    private static String[] _deprecatedCountries;
	
	    private static String[] _replacementCountries;
	
	    private static String[] _obsoleteCountries;
	
	    private static String[] _countries3;
	
	    private static String[] _obsoleteCountries3;
	
	    // Avoid initializing country tables unless we have to.
	    private static void InitCountryTables() {
	        if (_countries == null) {
	            /*
	             * ZR(ZAR) is now CD(COD) and FX(FXX) is PS(PSE) as per
	             * http://www.evertype.com/standards/iso3166/iso3166-1-en.html added
	             * new codes keeping the old ones for compatibility updated to
	             * include 1999/12/03 revisions *CWB
	             */
	
	            /*
	             * RO(ROM) is now RO(ROU) according to
	             * http://www.iso.org/iso/en/prods
	             * -services/iso3166ma/03updates-on-iso-3166/nlv3e-rou.html
	             */
	
	            /*
	             * This list MUST be in sorted order, and MUST contain only
	             * two-letter codes!
	             */
	            String[] tempCountries = { "AD", "AE", "AF", "AG", "AI", "AL",
	                    "AM", "AN", "AO", "AQ", "AR", "AS", "AT", "AU", "AW", "AX",
	                    "AZ", "BA", "BB", "BD", "BE", "BF", "BG", "BH", "BI", "BJ",
	                    "BL", "BM", "BN", "BO", "BR", "BS", "BT", "BV", "BW", "BY",
	                    "BZ", "CA", "CC", "CD", "CF", "CG", "CH", "CI", "CK", "CL",
	                    "CM", "CN", "CO", "CR", "CU", "CV", "CX", "CY", "CZ", "DE",
	                    "DJ", "DK", "DM", "DO", "DZ", "EC", "EE", "EG", "EH", "ER",
	                    "ES", "ET", "FI", "FJ", "FK", "FM", "FO", "FR", "GA", "GB",
	                    "GD", "GE", "GF", "GG", "GH", "GI", "GL", "GM", "GN", "GP",
	                    "GQ", "GR", "GS", "GT", "GU", "GW", "GY", "HK", "HM", "HN",
	                    "HR", "HT", "HU", "ID", "IE", "IL", "IM", "IN", "IO", "IQ",
	                    "IR", "IS", "IT", "JE", "JM", "JO", "JP", "KE", "KG", "KH",
	                    "KI", "KM", "KN", "KP", "KR", "KW", "KY", "KZ", "LA", "LB",
	                    "LC", "LI", "LK", "LR", "LS", "LT", "LU", "LV", "LY", "MA",
	                    "MC", "MD", "ME", "MF", "MG", "MH", "MK", "ML", "MM", "MN",
	                    "MO", "MP", "MQ", "MR", "MS", "MT", "MU", "MV", "MW", "MX",
	                    "MY", "MZ", "NA", "NC", "NE", "NF", "NG", "NI", "NL", "NO",
	                    "NP", "NR", "NU", "NZ", "OM", "PA", "PE", "PF", "PG", "PH",
	                    "PK", "PL", "PM", "PN", "PR", "PS", "PT", "PW", "PY", "QA",
	                    "RE", "RO", "RS", "RU", "RW", "SA", "SB", "SC", "SD", "SE",
	                    "SG", "SH", "SI", "SJ", "SK", "SL", "SM", "SN", "SO", "SR",
	                    "ST", "SV", "SY", "SZ", "TC", "TD", "TF", "TG", "TH", "TJ",
	                    "TK", "TL", "TM", "TN", "TO", "TR", "TT", "TV", "TW", "TZ",
	                    "UA", "UG", "UM", "US", "UY", "UZ", "VA", "VC", "VE", "VG",
	                    "VI", "VN", "VU", "WF", "WS", "YE", "YT", "ZA", "ZM", "ZW", };
	
	            /* this table is used for 3 letter codes */
	            String[] tempObsoleteCountries = { "FX", "CS", "RO", "TP", "YU",
	                    "ZR", /* obsolete country codes */
	            };
	
	            String[] tempDeprecatedCountries = { "BU", "CS", "DY", "FX", "HV",
	                    "NH", "RH", "TP", "YU", "ZR" /* deprecated country list */
	            };
	            String[] tempReplacementCountries = {
	            /* "BU", "CS", "DY", "FX", "HV", "NH", "RH", "TP", "YU", "ZR" */
	            "MM", "RS", "BJ", "FR", "BF", "VU", "ZW", "TL", "RS", "CD", /*
	                                                                         * replacement
	                                                                         * country
	                                                                         * codes
	                                                                         */
	            };
	
	            /*
	             * This list MUST contain a three-letter code for every two-letter
	             * code in the above list, and they MUST be listed in the same
	             * order!
	             */
	            String[] tempCountries3 = {
	            /* "AD", "AE", "AF", "AG", "AI", "AL", "AM", "AN", */
	            "AND", "ARE", "AFG", "ATG", "AIA", "ALB", "ARM", "ANT",
	            /* "AO", "AQ", "AR", "AS", "AT", "AU", "AW", "AX", "AZ", */
	            "AGO", "ATA", "ARG", "ASM", "AUT", "AUS", "ABW", "ALA", "AZE",
	            /* "BA", "BB", "BD", "BE", "BF", "BG", "BH", "BI", */
	            "BIH", "BRB", "BGD", "BEL", "BFA", "BGR", "BHR", "BDI",
	            /* "BJ", "BL", "BM", "BN", "BO", "BR", "BS", "BT", "BV", */
	            "BEN", "BLM", "BMU", "BRN", "BOL", "BRA", "BHS", "BTN", "BVT",
	            /* "BW", "BY", "BZ", "CA", "CC", "CD", "CF", "CG", */
	            "BWA", "BLR", "BLZ", "CAN", "CCK", "COD", "CAF", "COG",
	            /* "CH", "CI", "CK", "CL", "CM", "CN", "CO", "CR", */
	            "CHE", "CIV", "COK", "CHL", "CMR", "CHN", "COL", "CRI",
	            /* "CU", "CV", "CX", "CY", "CZ", "DE", "DJ", "DK", */
	            "CUB", "CPV", "CXR", "CYP", "CZE", "DEU", "DJI", "DNK",
	            /* "DM", "DO", "DZ", "EC", "EE", "EG", "EH", "ER", */
	            "DMA", "DOM", "DZA", "ECU", "EST", "EGY", "ESH", "ERI",
	            /* "ES", "ET", "FI", "FJ", "FK", "FM", "FO", "FR", */
	            "ESP", "ETH", "FIN", "FJI", "FLK", "FSM", "FRO", "FRA",
	            /* "GA", "GB", "GD", "GE", "GF", "GG", "GH", "GI", "GL", */
	            "GAB", "GBR", "GRD", "GEO", "GUF", "GGY", "GHA", "GIB", "GRL",
	            /* "GM", "GN", "GP", "GQ", "GR", "GS", "GT", "GU", */
	            "GMB", "GIN", "GLP", "GNQ", "GRC", "SGS", "GTM", "GUM",
	            /* "GW", "GY", "HK", "HM", "HN", "HR", "HT", "HU", */
	            "GNB", "GUY", "HKG", "HMD", "HND", "HRV", "HTI", "HUN",
	            /* "ID", "IE", "IL", "IM", "IN", "IO", "IQ", "IR", "IS" */
	            "IDN", "IRL", "ISR", "IMN", "IND", "IOT", "IRQ", "IRN", "ISL",
	            /* "IT", "JE", "JM", "JO", "JP", "KE", "KG", "KH", "KI", */
	            "ITA", "JEY", "JAM", "JOR", "JPN", "KEN", "KGZ", "KHM", "KIR",
	            /* "KM", "KN", "KP", "KR", "KW", "KY", "KZ", "LA", */
	            "COM", "KNA", "PRK", "KOR", "KWT", "CYM", "KAZ", "LAO",
	            /* "LB", "LC", "LI", "LK", "LR", "LS", "LT", "LU", */
	            "LBN", "LCA", "LIE", "LKA", "LBR", "LSO", "LTU", "LUX",
	            /* "LV", "LY", "MA", "MC", "MD", "ME", "MF", "MG", "MH", "MK", */
	            "LVA", "LBY", "MAR", "MCO", "MDA", "MNE", "MAF", "MDG", "MHL",
	                    "MKD",
	                    /* "ML", "MM", "MN", "MO", "MP", "MQ", "MR", "MS", */
	                    "MLI", "MMR", "MNG", "MAC", "MNP", "MTQ", "MRT", "MSR",
	                    /* "MT", "MU", "MV", "MW", "MX", "MY", "MZ", "NA", */
	                    "MLT", "MUS", "MDV", "MWI", "MEX", "MYS", "MOZ", "NAM",
	                    /* "NC", "NE", "NF", "NG", "NI", "NL", "NO", "NP", */
	                    "NCL", "NER", "NFK", "NGA", "NIC", "NLD", "NOR", "NPL",
	                    /* "NR", "NU", "NZ", "OM", "PA", "PE", "PF", "PG", */
	                    "NRU", "NIU", "NZL", "OMN", "PAN", "PER", "PYF", "PNG",
	                    /* "PH", "PK", "PL", "PM", "PN", "PR", "PS", "PT", */
	                    "PHL", "PAK", "POL", "SPM", "PCN", "PRI", "PSE", "PRT",
	                    /* "PW", "PY", "QA", "RE", "RO", "RS", "RU", "RW", "SA", */
	                    "PLW", "PRY", "QAT", "REU", "ROU", "SRB", "RUS", "RWA",
	                    "SAU",
	                    /* "SB", "SC", "SD", "SE", "SG", "SH", "SI", "SJ", */
	                    "SLB", "SYC", "SDN", "SWE", "SGP", "SHN", "SVN", "SJM",
	                    /* "SK", "SL", "SM", "SN", "SO", "SR", "ST", "SV", */
	                    "SVK", "SLE", "SMR", "SEN", "SOM", "SUR", "STP", "SLV",
	                    /* "SY", "SZ", "TC", "TD", "TF", "TG", "TH", "TJ", */
	                    "SYR", "SWZ", "TCA", "TCD", "ATF", "TGO", "THA", "TJK",
	                    /* "TK", "TL", "TM", "TN", "TO", "TR", "TT", "TV", */
	                    "TKL", "TLS", "TKM", "TUN", "TON", "TUR", "TTO", "TUV",
	                    /* "TW", "TZ", "UA", "UG", "UM", "US", "UY", "UZ", */
	                    "TWN", "TZA", "UKR", "UGA", "UMI", "USA", "URY", "UZB",
	                    /* "VA", "VC", "VE", "VG", "VI", "VN", "VU", "WF", */
	                    "VAT", "VCT", "VEN", "VGB", "VIR", "VNM", "VUT", "WLF",
	                    /* "WS", "YE", "YT", "ZA", "ZM", "ZW" */
	                    "WSM", "YEM", "MYT", "ZAF", "ZMB", "ZWE", };
	
	            String[] tempObsoleteCountries3 = {
	            /* "FX", "CS", "RO", "TP", "YU", "ZR", */
	            "FXX", "SCG", "ROM", "TMP", "YUG", "ZAR", };
	
	             lock (typeof(ULocale)) {
	                            if (_countries == null) {
	                                _countries = tempCountries;
	                                _deprecatedCountries = tempDeprecatedCountries;
	                                _replacementCountries = tempReplacementCountries;
	                                _obsoleteCountries = tempObsoleteCountries;
	                                _countries3 = tempCountries3;
	                                _obsoleteCountries3 = tempObsoleteCountries3;
	                            }
	                        }
	        }
	    }
	
	    private static String[][] _variantsToKeywords;
	
	    private static void InitVariantsTable() {
	        if (_variantsToKeywords == null) {
	            /**
	             * This table lists pairs of locale ids for canonicalization. The
	             * The first item is the normalized id, the second item is the
	             * canonicalized id.
	             */
	            String[][] tempVariantsToKeywords = {
	                    new String[] { "C", "en_US_POSIX", null, null },
	                    new String[] { "art_LOJBAN", "jbo", null, null },
	                    new String[] { "az_AZ_CYRL", "az_Cyrl_AZ", null, null },
	                    new String[] { "az_AZ_LATN", "az_Latn_AZ", null, null },
	                    new String[] { "ca_ES_PREEURO", "ca_ES", "currency", "ESP" },
	                    new String[] { "cel_GAULISH", "cel__GAULISH", null, null },
	                    new String[] { "de_1901", "de__1901", null, null },
	                    new String[] { "de_1906", "de__1906", null, null },
	                    new String[] { "de__PHONEBOOK", "de", "collation",
	                            "phonebook" },
	                    new String[] { "de_AT_PREEURO", "de_AT", "currency", "ATS" },
	                    new String[] { "de_DE_PREEURO", "de_DE", "currency", "DEM" },
	                    new String[] { "de_LU_PREEURO", "de_LU", "currency", "EUR" },
	                    new String[] { "el_GR_PREEURO", "el_GR", "currency", "GRD" },
	                    new String[] { "en_BOONT", "en__BOONT", null, null },
	                    new String[] { "en_SCOUSE", "en__SCOUSE", null, null },
	                    new String[] { "en_BE_PREEURO", "en_BE", "currency", "BEF" },
	                    new String[] { "en_IE_PREEURO", "en_IE", "currency", "IEP" },
	                    new String[] { "es__TRADITIONAL", "es", "collation",
	                            "traditional" },
	                    new String[] { "es_ES_PREEURO", "es_ES", "currency", "ESP" },
	                    new String[] { "eu_ES_PREEURO", "eu_ES", "currency", "ESP" },
	                    new String[] { "fi_FI_PREEURO", "fi_FI", "currency", "FIM" },
	                    new String[] { "fr_BE_PREEURO", "fr_BE", "currency", "BEF" },
	                    new String[] { "fr_FR_PREEURO", "fr_FR", "currency", "FRF" },
	                    new String[] { "fr_LU_PREEURO", "fr_LU", "currency", "LUF" },
	                    new String[] { "ga_IE_PREEURO", "ga_IE", "currency", "IEP" },
	                    new String[] { "gl_ES_PREEURO", "gl_ES", "currency", "ESP" },
	                    new String[] { "hi__DIRECT", "hi", "collation", "direct" },
	                    new String[] { "it_IT_PREEURO", "it_IT", "currency", "ITL" },
	                    new String[] { "ja_JP_TRADITIONAL", "ja_JP", "calendar",
	                            "japanese" },
	                    new String[] { "nl_BE_PREEURO", "nl_BE", "currency", "BEF" },
	                    new String[] { "nl_NL_PREEURO", "nl_NL", "currency", "NLG" },
	                    new String[] { "pt_PT_PREEURO", "pt_PT", "currency", "PTE" },
	                    new String[] { "sl_ROZAJ", "sl__ROZAJ", null, null },
	                    new String[] { "sr_SP_CYRL", "sr_Cyrl_CS", null, null },
	                    new String[] { "sr_SP_LATN", "sr_Latn_CS", null, null },
	                    new String[] { "sr_YU_CYRILLIC", "sr_Cyrl_CS", null, null },
	                    new String[] { "uz_UZ_CYRILLIC", "uz_Cyrl_UZ", null, null },
	                    new String[] { "uz_UZ_CYRL", "uz_Cyrl_UZ", null, null },
	                    new String[] { "uz_UZ_LATN", "uz_Latn_UZ", null, null },
	                    new String[] { "zh_CHS", "zh_Hans", null, null },
	                    new String[] { "zh_CHT", "zh_Hant", null, null },
	                    new String[] { "zh_GAN", "zh__GAN", null, null },
	                    new String[] { "zh_GUOYU", "zh", null, null },
	                    new String[] { "zh_HAKKA", "zh__HAKKA", null, null },
	                    new String[] { "zh_MIN", "zh__MIN", null, null },
	                    new String[] { "zh_MIN_NAN", "zh__MINNAN", null, null },
	                    new String[] { "zh_WUU", "zh__WUU", null, null },
	                    new String[] { "zh_XIANG", "zh__XIANG", null, null },
	                    new String[] { "zh_YUE", "zh__YUE", null, null },
	                    new String[] { "th_TH_TRADITIONAL", "th_TH", "calendar",
	                            "buddhist" },
	                    new String[] { "hi_IN_TRADITIONAL", "hi_IN", "calendar",
	                            "indian" },
	                    new String[] { "zh_TW_STROKE", "zh_TW", "collation",
	                            "stroke" },
	                    new String[] { "zh__PINYIN", "zh", "collation", "pinyin" } };
	
	             lock (typeof(ULocale)) {
	                            if (_variantsToKeywords == null) {
	                                _variantsToKeywords = tempVariantsToKeywords;
	                            }
	                        }
	        }
	    }
	
	    /*
	     * This table is used for mapping between ICU and special Java locales. When
	     * an ICU locale matches <minumum base> with <keyword>/<value>, the ICU
	     * locale is mapped to <Java> locale. For example, both
	     * ja_JP@calendar=japanese and ja@calendar=japanese are mapped to Java
	     * locale "ja_JP_JP". ICU locale "nn" is mapped to Java locale "no_NO_NY".
	     */
	    private static readonly String[][] _javaLocaleMap = { new String[] { "ja_JP_JP", "ja_JP", "calendar", "japanese", "ja" },
	            new String[] { "no_NO_NY", "nn_NO", null, null, "nn" } };
	
	    /// <summary>
	    /// Private constructor used by static initializers.
	    /// </summary>
	    ///
        private ULocale(String localeID_0, Locale locale_1)
        {
	        this.localeID = localeID_0;
	        this.locale = locale_1;
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Construct a ULocale object from a <see cref="T:System.Globalization.CultureInfo"/>.
	    /// </summary>
	    ///
	    /// <param name="loc">a JDK locale</param>
	    /// @stable ICU 2.8
        private ULocale(Locale loc)
        {
	        this.localeID = GetName(ForLocale(loc).ToString());
	        this.locale = loc;
	    }
	
	    /// <summary>
	    /// Return a ULocale object for a <see cref="T:System.Globalization.CultureInfo"/>. The ULocale is
	    /// canonicalized.
	    /// </summary>
	    ///
	    /// <param name="loc">a JDK locale</param>
	    /// @stable ICU 3.2
        public static ULocale ForLocale(Locale loc)
        {
	        if (loc == null) {
	            return null;
	        }
	        ULocale result = (ULocale) CACHE.Get(loc);
	        if (result == null) {
	            if (defaultULocale != null && loc == defaultULocale.locale) {
	                result = defaultULocale;
	            } else {
	                String locStr = loc.ToString();
	                if (locStr.Length == 0) {
	                    result = ROOT;
	                } else {
	                    for (int i = 0; i < _javaLocaleMap.Length; i++) {
	                        if (_javaLocaleMap[i][0].Equals(locStr)) {
	                            ULocale.IDParser  p = new ULocale.IDParser (_javaLocaleMap[i][1]);
	                            p.SetKeywordValue(_javaLocaleMap[i][2],
	                                    _javaLocaleMap[i][3]);
	                            locStr = p.GetName();
	                            break;
	                        }
	                    }
	                    result = new ULocale(locStr, loc);
	                }
	            }
	            CACHE.Put(loc, result);
	        }
	        return result;
	    }
	
	    /// <summary>
	    /// Construct a ULocale from a RFC 3066 locale ID. The locale ID consists of
	    /// optional language, script, country, and variant fields in that order,
	    /// separated by underscores, followed by an optional keyword list. The
	    /// script, if present, is four characters long-- this distinguishes it from
	    /// a country code, which is two characters long. Other fields are
	    /// distinguished by position as indicated by the underscores. The start of
	    /// the keyword list is indicated by '@', and consists of one or more
	    /// keyword/value pairs separated by commas.
	    /// <p>
	    /// This constructor does not canonicalize the localeID.
	    /// </summary>
	    ///
	    /// <param name="localeID_0">string representation of the locale, e.g: "en_US","sy_Cyrl_YU", "zh__pinyin","es_ES@currency=EUR,collation=traditional"</param>
	    /// @stable ICU 2.8
	    public ULocale(String localeID_0) {
	        this.localeID = GetName(localeID_0);
	    }
	
	    /// <summary>
	    /// Convenience overload of ULocale(String, String, String) for compatibility
	    /// with java.util.Locale.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Util.ULocale.ULocale(System.String, System.String, System.String)"/>
	    /// @stable ICU 3.4
	    public ULocale(String a, String b) : this(a, b, null) {
	    }
	
	    /// <summary>
	    /// Construct a ULocale from a localeID constructed from the three 'fields'
	    /// a, b, and c. These fields are concatenated using underscores to form a
	    /// localeID of the form a_b_c, which is then handled like the localeID
	    /// passed to <c>ULocale(String localeID)</c>.
	    /// <p>
	    /// Java locale strings consisting of language, country, and variant will be
	    /// handled by this form, since the country code (being shorter than four
	    /// letters long) will not be interpreted as a script code. If a script code
	    /// is present, the final argument ('c') will be interpreted as the country
	    /// code. It is recommended that this constructor only be used to ease
	    /// porting, and that clients instead use the single-argument constructor
	    /// when constructing a ULocale from a localeID.
	    /// </summary>
	    ///
	    /// <param name="a">first component of the locale id</param>
	    /// <param name="b">second component of the locale id</param>
	    /// <param name="c">third component of the locale id</param>
	    /// <seealso cref="M:IBM.ICU.Util.ULocale.ULocale(System.String)"/>
	    /// @stable ICU 3.0
	    public ULocale(String a, String b, String c) {
	        localeID = GetName(LscvToID(a, b, c, EMPTY_STRING));
	    }
	
	    /// <summary>
	    /// Create a ULocale from the id by first canonicalizing the id.
	    /// </summary>
	    ///
	    /// <param name="nonCanonicalID">the locale id to canonicalize</param>
	    /// <returns>the locale created from the canonical version of the ID.</returns>
	    /// @stable ICU 3.0
	    public static ULocale CreateCanonical(String nonCanonicalID) {
            return new ULocale(Canonicalize(nonCanonicalID), (Locale)null);
	    }
	
	    private static String LscvToID(String lang, String script, String country,
	            String variant) {
	        StringBuilder buf = new StringBuilder();
	
	        if (lang != null && lang.Length > 0) {
	            buf.Append(lang);
	        }
	        if (script != null && script.Length > 0) {
	            buf.Append(UNDERSCORE);
	            buf.Append(script);
	        }
	        if (country != null && country.Length > 0) {
	            buf.Append(UNDERSCORE);
	            buf.Append(country);
	        }
	        if (variant != null && variant.Length > 0) {
	            if (country == null || country.Length == 0) {
	                buf.Append(UNDERSCORE);
	            }
	            buf.Append(UNDERSCORE);
	            buf.Append(variant);
	        }
	        return buf.ToString();
	    }
	
	    /// <summary>
	    /// Convert this ULocale object to a <see cref="T:System.Globalization.CultureInfo"/>.
	    /// </summary>
	    ///
	    /// <returns>a JDK locale that either exactly represents this object or is the
	    /// closest approximation.</returns>
	    /// @stable ICU 2.8
        public Locale ToLocale()
        {
	        if (locale == null) {
	            ULocale.IDParser  p = new ULocale.IDParser (localeID);
	            String bs = p.GetBaseName();
	            for (int i = 0; i < _javaLocaleMap.Length; i++) {
	                if (bs.Equals(_javaLocaleMap[i][1])
	                        || bs.Equals(_javaLocaleMap[i][4])) {
	                    if (_javaLocaleMap[i][2] != null) {
	                        String val = p.GetKeywordValue(_javaLocaleMap[i][2]);
	                        if (val != null && val.Equals(_javaLocaleMap[i][3])) {
	                            p = new ULocale.IDParser (_javaLocaleMap[i][0]);
	                            break;
	                        }
	                    } else {
	                        p = new ULocale.IDParser (_javaLocaleMap[i][0]);
	                        break;
	                    }
	                }
	            }
	            String[] names = p.GetLanguageScriptCountryVariant();
	            locale = new Locale(names[0], names[2], names[3]);
	        }
	        return locale;
	    }
	


	    /// <summary>
	    /// Keep our own default ULocale.
	    /// </summary>
	    ///
        private static Locale defaultLocale = Locale.GetDefault();
	
	    private static ULocale defaultULocale = new ULocale(defaultLocale);
	
	    /// <summary>
	    /// Returns the current default ULocale.
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    public static ULocale GetDefault() {
	         lock (typeof(ULocale)) {
                 Locale currentDefault = Locale.GetDefault();
	                    if (defaultLocale != currentDefault) {
	                        defaultLocale = currentDefault;
	                        defaultULocale = new ULocale(defaultLocale);
	                    }
	                    return defaultULocale;
	                }
	    }
	
	    /// <summary>
	    /// Sets the default ULocale. This also sets the default Locale. If the
	    /// caller does not have write permission to the user.language property, a
	    /// security exception will be thrown, and the default ULocale will remain
	    /// unchanged.
	    /// </summary>
	    ///
	    /// <param name="newLocale">the new default locale</param>
	    /// <exception cref="SecurityException">if a security manager exists and its<c>checkPermission</c> method doesn't allow theoperation.</exception>
	    /// <exception cref="NullPointerException">if <c>newLocale</c> is null</exception>
	    /// <seealso cref="null"/>
	    /// <seealso cref="T:IBM.ICU.Util.PropertyPermission"/>
	    /// @stable ICU 3.0
	    [MethodImpl(MethodImplOptions.Synchronized)]
	    public static void SetDefault(ULocale newLocale) {
            Locale.SetDefault(newLocale.ToLocale());
	        defaultULocale = newLocale;
	    }
	
	    /// <summary>
	    /// This is for compatibility with Locale-- in actuality, since ULocale is
	    /// immutable, there is no reason to clone it, so this API returns 'this'.
	    /// </summary>
	    ///
	    /// @stable ICU 3.0
	    public Object Clone() {
	        return this;
	    }
	
	    /// <summary>
	    /// Returns the hashCode.
	    /// </summary>
	    ///
	    /// @stable ICU 3.0
	    public override int GetHashCode() {
	        return localeID.GetHashCode();
	    }
	
	    /// <summary>
	    /// Returns true if the other object is another ULocale with the same full
	    /// name, or is a String localeID that matches the full name. Note that since
	    /// names are not canonicalized, two ULocales that function identically might
	    /// not compare equal.
	    /// </summary>
	    ///
	    /// <returns>true if this Locale is equal to the specified object.</returns>
	    /// @stable ICU 3.0
	    public override bool Equals(Object obj) {
	        if ((Object) this == obj) {
	            return true;
	        }
	        if (obj  is  String) {
	            return localeID.Equals((String) obj);
	        }
	        if (obj  is  ULocale) {
	            return localeID.Equals(((ULocale) obj).localeID);
	        }
	        return false;
	    }
	
	    /// <summary>
	    /// Returns a list of all installed locales.
	    /// </summary>
	    ///
	    /// @stable ICU 3.0
	    public static ULocale[] GetAvailableLocales() {
	        return IBM.ICU.Impl.ICUResourceBundle.GetAvailableULocales();
	    }
	
	    /// <summary>
	    /// Returns a list of all 2-letter country codes defined in ISO 3166. Can be
	    /// used to create Locales.
	    /// </summary>
	    ///
	    /// @stable ICU 3.0
	    public static String[] GetISOCountries() {
	        InitCountryTables();
	        return (String[]) _countries.Clone();
	    }
	
	    /// <summary>
	    /// Returns a list of all 2-letter language codes defined in ISO 639. Can be
	    /// used to create Locales. [NOTE: ISO 639 is not a stable standard-- some
	    /// languages' codes have changed. The list this function returns includes
	    /// both the new and the old codes for the languages whose codes have
	    /// changed.]
	    /// </summary>
	    ///
	    /// @stable ICU 3.0
	    public static String[] GetISOLanguages() {
	        InitLanguageTables();
	        return (String[]) _languages.Clone();
	    }
	
	    /// <summary>
	    /// Returns the language code for this locale, which will either be the empty
	    /// string or a lowercase ISO 639 code.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Util.ULocale.GetDisplayLanguage"/>
	    /// <seealso cref="M:IBM.ICU.Util.ULocale.GetDisplayLanguage(IBM.ICU.Util.ULocale)"/>
	    /// @stable ICU 3.0
	    public String GetLanguage() {
	        return GetLanguage(localeID);
	    }
	
	    /// <summary>
	    /// Returns the language code for the locale ID, which will either be the
	    /// empty string or a lowercase ISO 639 code.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Util.ULocale.GetDisplayLanguage"/>
	    /// <seealso cref="M:IBM.ICU.Util.ULocale.GetDisplayLanguage(IBM.ICU.Util.ULocale)"/>
	    /// @stable ICU 3.0
	    public static String GetLanguage(String localeID_0) {
	        return new ULocale.IDParser (localeID_0).GetLanguage();
	    }
	
	    /// <summary>
	    /// Returns the script code for this locale, which might be the empty string.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Util.ULocale.GetDisplayScript"/>
	    /// <seealso cref="M:IBM.ICU.Util.ULocale.GetDisplayScript(IBM.ICU.Util.ULocale)"/>
	    /// @stable ICU 3.0
	    public String GetScript() {
	        return GetScript(localeID);
	    }
	
	    /// <summary>
	    /// Returns the script code for the specified locale, which might be the
	    /// empty string.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Util.ULocale.GetDisplayScript"/>
	    /// <seealso cref="M:IBM.ICU.Util.ULocale.GetDisplayScript(IBM.ICU.Util.ULocale)"/>
	    /// @stable ICU 3.0
	    public static String GetScript(String localeID_0) {
	        return new ULocale.IDParser (localeID_0).GetScript();
	    }
	
	    /// <summary>
	    /// Returns the country/region code for this locale, which will either be the
	    /// empty string or an uppercase ISO 3166 2-letter code.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Util.ULocale.GetDisplayCountry"/>
	    /// <seealso cref="M:IBM.ICU.Util.ULocale.GetDisplayCountry(IBM.ICU.Util.ULocale)"/>
	    /// @stable ICU 3.0
	    public String GetCountry() {
	        return GetCountry(localeID);
	    }
	
	    /// <summary>
	    /// Returns the country/region code for this locale, which will either be the
	    /// empty string or an uppercase ISO 3166 2-letter code.
	    /// </summary>
	    ///
	    /// <param name="localeID_0"></param>
	    /// <seealso cref="M:IBM.ICU.Util.ULocale.GetDisplayCountry"/>
	    /// <seealso cref="M:IBM.ICU.Util.ULocale.GetDisplayCountry(IBM.ICU.Util.ULocale)"/>
	    /// @stable ICU 3.0
	    public static String GetCountry(String localeID_0) {
	        return new ULocale.IDParser (localeID_0).GetCountry();
	    }
	
	    /// <summary>
	    /// Returns the variant code for this locale, which might be the empty
	    /// string.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Util.ULocale.GetDisplayVariant"/>
	    /// <seealso cref="M:IBM.ICU.Util.ULocale.GetDisplayVariant(IBM.ICU.Util.ULocale)"/>
	    /// @stable ICU 3.0
	    public String GetVariant() {
	        return GetVariant(localeID);
	    }
	
	    /// <summary>
	    /// Returns the variant code for the specified locale, which might be the
	    /// empty string.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Util.ULocale.GetDisplayVariant"/>
	    /// <seealso cref="M:IBM.ICU.Util.ULocale.GetDisplayVariant(IBM.ICU.Util.ULocale)"/>
	    /// @stable ICU 3.0
	    public static String GetVariant(String localeID_0) {
	        return new ULocale.IDParser (localeID_0).GetVariant();
	    }
	
	    /// <summary>
	    /// Returns the fallback locale for the specified locale, which might be the
	    /// empty string.
	    /// </summary>
	    ///
	    /// @stable ICU 3.2
	    public static String GetFallback(String localeID_0) {
	        return GetFallbackString(GetName(localeID_0));
	    }
	
	    /// <summary>
	    /// Returns the fallback locale for this locale. If this locale is root,
	    /// returns null.
	    /// </summary>
	    ///
	    /// @stable ICU 3.2
	    public ULocale GetFallback() {
	        if (localeID.Length == 0 || localeID[0] == '@') {
	            return null;
	        }
            return new ULocale(GetFallbackString(localeID), (Locale)null);
	    }
	
	    /// <summary>
	    /// Return the given (canonical) locale id minus the last part before the
	    /// tags.
	    /// </summary>
	    ///
	    private static String GetFallbackString(String fallback) {
	        int limit = fallback.IndexOf('@');
	        if (limit == -1) {
	            limit = fallback.Length;
	        }
	        int start = fallback.LastIndexOf('_', limit);
	        if (start == -1) {
	            start = 0;
	        }
	        return fallback.Substring(0,(start)-(0)) + fallback.Substring(limit);
	    }
	
	    /// <summary>
	    /// Returns the (normalized) base name for this locale.
	    /// </summary>
	    ///
	    /// <returns>the base name as a String.</returns>
	    /// @stable ICU 3.0
	    public String GetBaseName() {
	        return GetBaseName(localeID);
	    }
	
	    /// <summary>
	    /// Returns the (normalized) base name for the specified locale.
	    /// </summary>
	    ///
	    /// <param name="localeID_0">the locale ID as a string</param>
	    /// <returns>the base name as a String.</returns>
	    /// @stable ICU 3.0
	    public static String GetBaseName(String localeID_0) {
	        if (localeID_0.IndexOf('@') == -1) {
	            return localeID_0;
	        }
	        return new ULocale.IDParser (localeID_0).GetBaseName();
	    }
	
	    /// <summary>
	    /// Returns the (normalized) full name for this locale.
	    /// </summary>
	    ///
	    /// <returns>String the full name of the localeID</returns>
	    /// @stable ICU 3.0
	    public String GetName() {
	        return localeID; // always normalized
	    }
	
	    /// <summary>
	    /// Returns the (normalized) full name for the specified locale.
	    /// </summary>
	    ///
	    /// <param name="localeID_0">the localeID as a string</param>
	    /// <returns>String the full name of the localeID</returns>
	    /// @stable ICU 3.0
	    public static String GetName(String localeID_0) {
	        IDictionary cache = (IDictionary) nameCacheRef.Target;
	        if (cache == null) {
	            cache = ILOG.J2CsMapping.Collections.Generics.Collections.SynchronizedMap(new Hashtable());
	            nameCacheRef = new WeakReference(cache);
	        }
	        String name = (String) ILOG.J2CsMapping.Collections.Collections.Get(cache,localeID_0);
	        if (name == null) {
	            name = new ULocale.IDParser (localeID_0).GetName();
	            ILOG.J2CsMapping.Collections.Collections.Put(cache,localeID_0,name);
	        }
	        return name;
	    }
	
	    /// <summary>
	    /// Returns a string representation of this object.
	    /// </summary>
	    ///
	    /// @stable ICU 3.0
	    public override String ToString() {
	        return localeID;
	    }
	
	    /// <summary>
	    /// Returns an iterator over keywords for this locale. If there are no
	    /// keywords, returns null.
	    /// </summary>
	    ///
	    /// <returns>iterator over keywords, or null if there are no keywords.</returns>
	    /// @stable ICU 3.0
	    public IIterator GetKeywords() {
	        return GetKeywords(localeID);
	    }
	
	    /// <summary>
	    /// Returns an iterator over keywords for the specified locale. If there are
	    /// no keywords, returns null.
	    /// </summary>
	    ///
	    /// <returns>an iterator over the keywords in the specified locale, or null if
	    /// there are no keywords.</returns>
	    /// @stable ICU 3.0
	    public static IIterator GetKeywords(String localeID_0) {
	        return new ULocale.IDParser (localeID_0).GetKeywords();
	    }
	
	    /// <summary>
	    /// Returns the value for a keyword in this locale. If the keyword is not
	    /// defined, returns null.
	    /// </summary>
	    ///
	    /// <param name="keywordName">name of the keyword whose value is desired. Case insensitive.</param>
	    /// <returns>the value of the keyword, or null.</returns>
	    /// @stable ICU 3.0
	    public String GetKeywordValue(String keywordName) {
	        return GetKeywordValue(localeID, keywordName);
	    }
	
	    /// <summary>
	    /// Returns the value for a keyword in the specified locale. If the keyword
	    /// is not defined, returns null. The locale name does not need to be
	    /// normalized.
	    /// </summary>
	    ///
	    /// <param name="keywordName">name of the keyword whose value is desired. Case insensitive.</param>
	    /// <returns>String the value of the keyword as a string</returns>
	    /// @stable ICU 3.0
	    public static String GetKeywordValue(String localeID_0, String keywordName) {
	        return new ULocale.IDParser (localeID_0).GetKeywordValue(keywordName);
	    }
	
	    /// <summary>
	    /// Utility class to parse and normalize locale ids (including POSIX style)
	    /// </summary>
	    ///
	    private sealed class IDParser {
	        public sealed class Anonymous_C0 : IComparer {
	            public int Compare(Object lhs, Object rhs) {
	                return String.CompareOrdinal(((String) lhs),(String) rhs);
	            }
	        }
	
	        private char[] id;
	
	        private int index;
	
	        private char[] buffer;
	
	        private int blen;
	
	        // um, don't handle POSIX ids unless we request it. why not? well...
	        // because.
	        private bool canonicalize;
	
	        private bool hadCountry;
	
	        // used when canonicalizing
	        internal IDictionary keywords;
	
	        internal String baseName;
	
	        /// <summary>
	        /// Parsing constants.
	        /// </summary>
	        ///
	        private const char KEYWORD_SEPARATOR = '@';
	
	        private const char HYPHEN = '-';
	
	        private const char KEYWORD_ASSIGN = '=';
	
	        private const char COMMA = ',';
	
	        private const char ITEM_SEPARATOR = ';';
	
	        private const char DOT = '.';
	
	        public IDParser(String localeID_0) : this(localeID_0, false) {
	        }
	
	        public IDParser(String localeID_0, bool canonicalize_1) {
	            id = localeID_0.ToCharArray();
	            index = 0;
	            buffer = new char[id.Length + 5];
	            blen = 0;
	            this.canonicalize = canonicalize_1;
	        }
	
	        public void Reset() {
	            index = blen = 0;
	        }
	
	        // utilities for working on text in the buffer
	
	        /// <summary>
	        /// Append c to the buffer.
	        /// </summary>
	        ///
	        public void Append(char c) {
	            try {
	                buffer[blen] = c;
	            } catch (IndexOutOfRangeException e) {
	                if (buffer.Length > 512) {
	                    // something is seriously wrong, let this go
	                    throw e;
	                }
	                char[] nbuffer = new char[buffer.Length * 2];
	                System.Array.Copy((Array)(buffer),0,(Array)(nbuffer),0,buffer.Length);
	                nbuffer[blen] = c;
	                buffer = nbuffer;
	            }
	            ++blen;
	        }
	
	        public void AddSeparator() {
	            Append(IBM.ICU.Util.ULocale.UNDERSCORE);
	        }
	
	        /// <summary>
	        /// Returns the text in the buffer from start to blen as a String.
	        /// </summary>
	        ///
	        public String GetString(int start) {
	            if (start == blen) {
	                return IBM.ICU.Util.ULocale.EMPTY_STRING;
	            }
	            return new String(buffer, start, blen - start);
	        }
	
	        /// <summary>
	        /// Set the length of the buffer to pos, then append the string.
	        /// </summary>
	        ///
	        public void Set(int pos, String s) {
	            this.blen = pos; // no safety
	            Append(s);
	        }
	
	        /// <summary>
	        /// Append the string to the buffer.
	        /// </summary>
	        ///
	        public void Append(String s) {
	            for (int i = 0; i < s.Length; ++i) {
	                Append(s[i]);
	            }
	        }
	
	        // utilities for parsing text out of the id
	
	        /// <summary>
	        /// Character to indicate no more text is available in the id.
	        /// </summary>
	        ///
	        private const char DONE = '\uffff';
	
	        /// <summary>
	        /// Returns the character at index in the id, and advance index. The
	        /// returned character is DONE if index was at the limit of the buffer.
	        /// The index is advanced regardless so that decrementing the index will
	        /// always 'unget' the last character returned.
	        /// </summary>
	        ///
	        public char Next() {
	            if (index == id.Length) {
	                index++;
	                return DONE;
	            }
	
	            return id[index++];
	        }
	
	        /// <summary>
	        /// Advance index until the next terminator or id separator, and leave it
	        /// there.
	        /// </summary>
	        ///
	        public void SkipUntilTerminatorOrIDSeparator() {
	            while (!IsTerminatorOrIDSeparator(Next())) {
	            }
	            --index;
	        }
	
	        /// <summary>
	        /// Returns true if the character at index in the id is a terminator.
	        /// </summary>
	        ///
	        public bool AtTerminator() {
	            return index >= id.Length || IsTerminator(id[index]);
	        }
	
	        /*
	         * Returns true if the character is an id separator (underscore or
	         * hyphen).
	         */
	        /*
	         * private boolean isIDSeparator(char c) { return c == UNDERSCORE || c
	         * == HYPHEN; }
	         */
	
	        /// <summary>
	        /// Returns true if the character is a terminator (keyword separator,
	        /// dot, or DONE). Dot is a terminator because of the POSIX form, where
	        /// dot precedes the codepage.
	        /// </summary>
	        ///
	        public bool IsTerminator(char c) {
	            // always terminate at DOT, even if not handling POSIX. It's an
	            // error...
	            return c == KEYWORD_SEPARATOR || c == DONE || c == DOT;
	        }
	
	        /// <summary>
	        /// Returns true if the character is a terminator or id separator.
	        /// </summary>
	        ///
	        public bool IsTerminatorOrIDSeparator(char c) {
	            return c == KEYWORD_SEPARATOR || c == IBM.ICU.Util.ULocale.UNDERSCORE || c == HYPHEN
	                    || c == DONE || c == DOT;
	        }
	
	        /// <summary>
	        /// Returns true if the start of the buffer has an experimental or
	        /// private language prefix, the pattern '[ixIX][-_].' shows the syntax
	        /// checked.
	        /// </summary>
	        ///
	        public bool HaveExperimentalLanguagePrefix() {
	            if (id.Length > 2) {
	                char c = id[1];
	                if (c == HYPHEN || c == IBM.ICU.Util.ULocale.UNDERSCORE) {
	                    c = id[0];
	                    return c == 'x' || c == 'X' || c == 'i' || c == 'I';
	                }
	            }
	            return false;
	        }
	
	        /// <summary>
	        /// Returns true if a value separator occurs at or after index.
	        /// </summary>
	        ///
	        public bool HaveKeywordAssign() {
	            // assume it is safe to start from index
	            for (int i = index; i < id.Length; ++i) {
	                if (id[i] == KEYWORD_ASSIGN) {
	                    return true;
	                }
	            }
	            return false;
	        }
	
	        /// <summary>
	        /// Advance index past language, and accumulate normalized language code
	        /// in buffer. Index must be at 0 when this is called. Index is left at a
	        /// terminator or id separator. Returns the start of the language code in
	        /// the buffer.
	        /// </summary>
	        ///
	        public int ParseLanguage() {
	            if (HaveExperimentalLanguagePrefix()) {
	                Append(Char.ToLower(id[0]));
	                Append(HYPHEN);
	                index = 2;
	            }
	
	            char c;
	            while (!IsTerminatorOrIDSeparator(c = Next())) {
	                Append(Char.ToLower(c));
	            }
	            --index; // unget
	
	            if (blen == 3) {
	                IBM.ICU.Util.ULocale.InitLanguageTables();
	
	                /* convert 3 character code to 2 character code if possible *CWB */
	                String lang = GetString(0);
	                int offset = IBM.ICU.Util.ULocale.FindIndex(IBM.ICU.Util.ULocale._languages3, lang);
	                if (offset >= 0) {
	                    Set(0, IBM.ICU.Util.ULocale._languages[offset]);
	                } else {
	                    offset = IBM.ICU.Util.ULocale.FindIndex(IBM.ICU.Util.ULocale._obsoleteLanguages3, lang);
	                    if (offset >= 0) {
	                        Set(0, IBM.ICU.Util.ULocale._obsoleteLanguages[offset]);
	                    }
	                }
	            }
	
	            return 0;
	        }
	
	        /// <summary>
	        /// Advance index past language. Index must be at 0 when this is called.
	        /// Index is left at a terminator or id separator.
	        /// </summary>
	        ///
	        public void SkipLanguage() {
	            if (HaveExperimentalLanguagePrefix()) {
	                index = 2;
	            }
	            SkipUntilTerminatorOrIDSeparator();
	        }
	
	        /// <summary>
	        /// Advance index past script, and accumulate normalized script in
	        /// buffer. Index must be immediately after the language. If the item at
	        /// this position is not a script (is not four characters long) leave
	        /// index and buffer unchanged. Otherwise index is left at a terminator
	        /// or id separator. Returns the start of the script code in the buffer
	        /// (this may be equal to the buffer length, if there is no script).
	        /// </summary>
	        ///
	        public int ParseScript() {
	            if (!AtTerminator()) {
	                int oldIndex = index; // save original index
	                ++index;
	
	                int oldBlen = blen; // get before append hyphen, if we truncate
	                                    // everything is undone
	                char c;
	                while (!IsTerminatorOrIDSeparator(c = Next())) {
	                    if (blen == oldBlen) { // first pass
	                        AddSeparator();
	                        Append(Char.ToUpper(c));
	                    } else {
	                        Append(Char.ToLower(c));
	                    }
	                }
	                --index; // unget
	
	                /*
	                 * If it's not exactly 4 characters long, then it's not a
	                 * script.
	                 */
	                if (index - oldIndex != 5) { // +1 to account for separator
	                    index = oldIndex;
	                    blen = oldBlen;
	                } else {
	                    oldBlen++; // index past hyphen, for clients who want to
	                               // extract just the script
	                }
	
	                return oldBlen;
	            }
	            return blen;
	        }
	
	        /// <summary>
	        /// Advance index past script. Index must be immediately after the
	        /// language and IDSeparator. If the item at this position is not a
	        /// script (is not four characters long) leave index. Otherwise index is
	        /// left at a terminator or id separator.
	        /// </summary>
	        ///
	        public void SkipScript() {
	            if (!AtTerminator()) {
	                int oldIndex = index;
	                ++index;
	
	                SkipUntilTerminatorOrIDSeparator();
	                if (index - oldIndex != 5) { // +1 to account for separator
	                    index = oldIndex;
	                }
	            }
	        }
	
	        /// <summary>
	        /// Advance index past country, and accumulate normalized country in
	        /// buffer. Index must be immediately after the script (if there is one,
	        /// else language) and IDSeparator. Return the start of the country code
	        /// in the buffer.
	        /// </summary>
	        ///
	        public int ParseCountry() {
	            if (!AtTerminator()) {
	                ++index;
	
	                int oldBlen = blen;
	                char c;
	                while (!IsTerminatorOrIDSeparator(c = Next())) {
	                    if (oldBlen == blen) { // first, add hyphen
	                        hadCountry = true; // we have a country, let variant
	                                           // parsing know
	                        AddSeparator();
	                        ++oldBlen; // increment past hyphen
	                    }
	                    Append(Char.ToUpper(c));
	                }
	                --index; // unget
	
	                if (blen - oldBlen == 3) {
	                    IBM.ICU.Util.ULocale.InitCountryTables();
	
	                    /*
	                     * convert 3 character code to 2 character code if possible
	                     * *CWB
	                     */
	                    int offset = IBM.ICU.Util.ULocale.FindIndex(IBM.ICU.Util.ULocale._countries3, GetString(oldBlen));
	                    if (offset >= 0) {
	                        Set(oldBlen, IBM.ICU.Util.ULocale._countries[offset]);
	                    } else {
	                        offset = IBM.ICU.Util.ULocale.FindIndex(IBM.ICU.Util.ULocale._obsoleteCountries3,
	                                GetString(oldBlen));
	                        if (offset >= 0) {
	                            Set(oldBlen, IBM.ICU.Util.ULocale._obsoleteCountries[offset]);
	                        }
	                    }
	                }
	
	                return oldBlen;
	            }
	
	            return blen;
	        }
	
	        /// <summary>
	        /// Advance index past country. Index must be immediately after the
	        /// script (if there is one, else language) and IDSeparator.
	        /// </summary>
	        ///
	        public void SkipCountry() {
	            if (!AtTerminator()) {
	                ++index;
	                SkipUntilTerminatorOrIDSeparator();
	            }
	        }
	
	        /// <summary>
	        /// Advance index past variant, and accumulate normalized variant in
	        /// buffer. This ignores the codepage information from POSIX ids. Index
	        /// must be immediately after the country or script. Index is left at the
	        /// keyword separator or at the end of the text. Return the start of the
	        /// variant code in the buffer.
	        /// In standard form, we can have the following forms: ll__VVVV
	        /// ll_CC_VVVV ll_Ssss_VVVV ll_Ssss_CC_VVVV
	        /// This also handles POSIX ids, which can have the following forms (pppp
	        /// is code page id): ll_CC.pppp --> ll_CC ll_CC.pppp@VVVV --> ll_CC_VVVV
	        /// ll_CC@VVVV --> ll_CC_VVVV
	        /// We identify this use of '@' in POSIX ids by looking for an '='
	        /// following the '@'. If there is one, we consider '@' to start a
	        /// keyword list, instead of being part of a POSIX id.
	        /// Note: since it was decided that we want an option to not handle POSIX
	        /// ids, this becomes a bit more complex.
	        /// </summary>
	        ///
	        public int ParseVariant() {
	            int oldBlen = blen;
	
	            bool start = true;
	            bool needSeparator = true;
	            bool skipping = false;
	            char c;
	            while ((c = Next()) != DONE) {
	                if (c == DOT) {
	                    start = false;
	                    skipping = true;
	                } else if (c == KEYWORD_SEPARATOR) {
	                    if (HaveKeywordAssign()) {
	                        break;
	                    }
	                    skipping = false;
	                    start = false;
	                    needSeparator = true; // add another underscore if we have
	                                          // more text
	                } else if (start) {
	                    start = false;
	                } else if (!skipping) {
	                    if (needSeparator) {
	                        bool incOldBlen = blen == oldBlen; // need to skip
	                                                              // separators
	                        needSeparator = false;
	                        if (incOldBlen && !hadCountry) { // no country, we'll
	                                                         // need two
	                            AddSeparator();
	                            ++oldBlen; // for sure
	                        }
	                        AddSeparator();
	                        if (incOldBlen) { // only for the first separator
	                            ++oldBlen;
	                        }
	                    }
	                    c = Char.ToUpper(c);
	                    if (c == HYPHEN || c == COMMA) {
	                        c = IBM.ICU.Util.ULocale.UNDERSCORE;
	                    }
	                    Append(c);
	                }
	            }
	            --index; // unget
	
	            return oldBlen;
	        }
	
	        // no need for skipvariant, to get the keywords we'll just scan directly
	        // for
	        // the keyword separator
	
	        /// <summary>
	        /// Returns the normalized language id, or the empty string.
	        /// </summary>
	        ///
	        public String GetLanguage() {
	            Reset();
	            return GetString(ParseLanguage());
	        }
	
	        /// <summary>
	        /// Returns the normalized script id, or the empty string.
	        /// </summary>
	        ///
	        public String GetScript() {
	            Reset();
	            SkipLanguage();
	            return GetString(ParseScript());
	        }
	
	        /// <summary>
	        /// return the normalized country id, or the empty string.
	        /// </summary>
	        ///
	        public String GetCountry() {
	            Reset();
	            SkipLanguage();
	            SkipScript();
	            return GetString(ParseCountry());
	        }
	
	        /// <summary>
	        /// Returns the normalized variant id, or the empty string.
	        /// </summary>
	        ///
	        public String GetVariant() {
	            Reset();
	            SkipLanguage();
	            SkipScript();
	            SkipCountry();
	            return GetString(ParseVariant());
	        }
	
	        /// <summary>
	        /// Returns the language, script, country, and variant as separate
	        /// strings.
	        /// </summary>
	        ///
	        public String[] GetLanguageScriptCountryVariant() {
	            Reset();
	            return new String[] { GetString(ParseLanguage()),
	                    GetString(ParseScript()), GetString(ParseCountry()),
	                    GetString(ParseVariant()) };
	        }
	
	        public void SetBaseName(String baseName_0) {
	            this.baseName = baseName_0;
	        }
	
	        public void ParseBaseName() {
	            if (baseName != null) {
	                Set(0, baseName);
	            } else {
	                Reset();
	                ParseLanguage();
	                ParseScript();
	                ParseCountry();
	                ParseVariant();
	
	                // catch unwanted trailing underscore after country if there was
	                // no variant
	                if (blen > 1 && buffer[blen - 1] == IBM.ICU.Util.ULocale.UNDERSCORE) {
	                    --blen;
	                }
	            }
	        }
	
	        /// <summary>
	        /// Returns the normalized base form of the locale id. The base form does
	        /// not include keywords.
	        /// </summary>
	        ///
	        public String GetBaseName() {
	            if (baseName != null) {
	                return baseName;
	            }
	            ParseBaseName();
	            return GetString(0);
	        }
	
	        /// <summary>
	        /// Returns the normalized full form of the locale id. The full form
	        /// includes keywords if they are present.
	        /// </summary>
	        ///
	        public String GetName() {
	            ParseBaseName();
	            ParseKeywords();
	            return GetString(0);
	        }
	
	        // keyword utilities
	
	        /// <summary>
	        /// If we have keywords, advance index to the start of the keywords and
	        /// return true, otherwise return false.
	        /// </summary>
	        ///
	        public bool SetToKeywordStart() {
	            for (int i = index; i < id.Length; ++i) {
	                if (id[i] == KEYWORD_SEPARATOR) {
	                    if (canonicalize) {
	                        for (int j = ++i; j < id.Length; ++j) { // increment i
	                                                                // past
	                                                                // separator for
	                                                                // return
	                            if (id[j] == KEYWORD_ASSIGN) {
	                                index = i;
	                                return true;
	                            }
	                        }
	                    } else {
	                        if (++i < id.Length) {
	                            index = i;
	                            return true;
	                        }
	                    }
	                    break;
	                }
	            }
	            return false;
	        }
	
	        public static bool IsDoneOrKeywordAssign(char c) {
	            return c == DONE || c == KEYWORD_ASSIGN;
	        }
	
	        public static bool IsDoneOrItemSeparator(char c) {
	            return c == DONE || c == ITEM_SEPARATOR;
	        }
	
	        public String GetKeyword() {
	            int start = index;
	            while (!IsDoneOrKeywordAssign(Next())) {
	            }
	            --index;
	            return new String(id, start, index - start).Trim().ToLower();
	        }
	
	        public String GetValue() {
	            int start = index;
	            while (!IsDoneOrItemSeparator(Next())) {
	            }
	            --index;
	            return new String(id, start, index - start).Trim(); // leave case
	                                                                // alone
	        }
	
	        public IComparer GetKeyComparator() {
	            IComparer comp = new IBM.ICU.Util.ULocale.IDParser.Anonymous_C0 ();
	            return comp;
	        }
	
	        /// <summary>
	        /// Returns a map of the keywords and values, or null if there are none.
	        /// </summary>
	        ///
	        public IDictionary GetKeywordMap() {
	            if (keywords == null) {
	                SortedList m = null;
	                if (SetToKeywordStart()) {
	                    // trim spaces and convert to lower case, both keywords and
	                    // values.
	                    do {
	                        String key = GetKeyword();
	                        if (key.Length == 0) {
	                            break;
	                        }
	                        char c = Next();
	                        if (c != KEYWORD_ASSIGN) {
	                            // throw new IllegalArgumentException("key '" + key
	                            // + "' missing a value.");
	                            if (c == DONE) {
	                                break;
	                            } else {
	                                continue;
	                            }
	                        }
	                        String value_ren = GetValue();
	                        if (value_ren.Length == 0) {
	                            // throw new IllegalArgumentException("key '" + key
	                            // + "' missing a value.");
	                            continue;
	                        }
	                        if (m == null) {
	                            m = new SortedList(GetKeyComparator());
	                        } else if (m.Contains(key)) {
	                            // throw new IllegalArgumentException("key '" + key
	                            // + "' already has a value.");
	                            continue;
	                        }
	                        ILOG.J2CsMapping.Collections.Collections.Put(m,key,value_ren);
	                    } while (Next() == ITEM_SEPARATOR);
	                }
	                keywords = (m != null) ? (IDictionary) (m) : (IDictionary) (ILOG.J2CsMapping.Collections.Generics.Collections.EMPTY_MAP);
	            }
	
	            return keywords;
	        }
	
	        /// <summary>
	        /// Parse the keywords and return start of the string in the buffer.
	        /// </summary>
	        ///
	        public int ParseKeywords() {
	            int oldBlen = blen;
	            IDictionary m = GetKeywordMap();
	            if (!(m.Count==0)) {
	                IIterator iter = new ILOG.J2CsMapping.Collections.IteratorAdapter(m.GetEnumerator());
	                bool first = true;
	                while (iter.HasNext()) {
	                    Append((first) ? KEYWORD_SEPARATOR : ITEM_SEPARATOR);
	                    first = false;
	                    DictionaryEntry e = (DictionaryEntry) iter.Next();
	                    Append((String) ((DictionaryEntry) e).Key);
	                    Append(KEYWORD_ASSIGN);
	                    Append((String) ((DictionaryEntry) e).Value);
	                }
	                if (blen != oldBlen) {
	                    ++oldBlen;
	                }
	            }
	            return oldBlen;
	        }
	
	        /// <summary>
	        /// Returns an iterator over the keywords, or null if we have an empty
	        /// map.
	        /// </summary>
	        ///
	        public IIterator GetKeywords() {
	            IDictionary m = GetKeywordMap();
	            return ((m.Count==0)) ? null : new ILOG.J2CsMapping.Collections.IteratorAdapter(new ILOG.J2CsMapping.Collections.ListSet(m.Keys).GetEnumerator());
	        }
	
	        /// <summary>
	        /// Returns the value for the named keyword, or null if the keyword is
	        /// not present.
	        /// </summary>
	        ///
	        public String GetKeywordValue(String keywordName) {
	            IDictionary m = GetKeywordMap();
	            return ((m.Count==0)) ? null : (String) ILOG.J2CsMapping.Collections.Collections.Get(m,keywordName.Trim()
	                                .ToLower());
	        }
	
	        /// <summary>
	        /// Set the keyword value only if it is not already set to something
	        /// else.
	        /// </summary>
	        ///
	        public void DefaultKeywordValue(String keywordName, String value_ren) {
	            SetKeywordValue(keywordName, value_ren, false);
	        }
	
	        /// <summary>
	        /// Set the value for the named keyword, or unset it if value is null. If
	        /// keywordName itself is null, unset all keywords. If keywordName is not
	        /// null, value must not be null.
	        /// </summary>
	        ///
	        public void SetKeywordValue(String keywordName, String value_ren) {
	            SetKeywordValue(keywordName, value_ren, true);
	        }
	
	        /// <summary>
	        /// Set the value for the named keyword, or unset it if value is null. If
	        /// keywordName itself is null, unset all keywords. If keywordName is not
	        /// null, value must not be null. If reset is true, ignore any previous
	        /// value for the keyword, otherwise do not change the keyword (including
	        /// removal of one or all keywords).
	        /// </summary>
	        ///
	        public void SetKeywordValue(String keywordName, String value_ren,
	                bool reset) {
	            if (keywordName == null) {
	                if (reset) {
	                    // force new map, ignore value
	                    keywords = ILOG.J2CsMapping.Collections.Generics.Collections.EMPTY_MAP;
	                }
	            } else {
	                keywordName = keywordName.Trim().ToLower();
	                if (keywordName.Length == 0) {
	                    throw new ArgumentException(
	                            "keyword must not be empty");
	                }
	                if (value_ren != null) {
	                    value_ren = value_ren.Trim();
	                    if (value_ren.Length == 0) {
	                        throw new ArgumentException(
	                                "value must not be empty");
	                    }
	                }
	                IDictionary m = GetKeywordMap();
	                if ((m.Count==0)) { // it is EMPTY_MAP
	                    if (value_ren != null) {
	                        // force new map
	                        keywords = new SortedList(GetKeyComparator());
	                        ILOG.J2CsMapping.Collections.Collections.Put(keywords,keywordName,value_ren.Trim());
	                    }
	                } else {
	                    if (reset || !m.Contains(keywordName)) {
	                        if (value_ren != null) {
	                            ILOG.J2CsMapping.Collections.Collections.Put(m,keywordName,value_ren);
	                        } else {
	                            ILOG.J2CsMapping.Collections.Collections.Remove(m,keywordName);
	                            if ((m.Count==0)) {
	                                // force new map
	                                keywords = ILOG.J2CsMapping.Collections.Generics.Collections.EMPTY_MAP;
	                            }
	                        }
	                    }
	                }
	            }
	        }
	    }
	
	    /// <summary>
	    /// linear search of the string array. the arrays are unfortunately ordered
	    /// by the two-letter target code, not the three-letter search code, which
	    /// seems backwards.
	    /// </summary>
	    ///
	    private static int FindIndex(String[] array, String target) {
	        for (int i = 0; i < array.Length; i++) {
	            if (target.Equals(array[i])) {
	                return i;
	            }
	        }
	        return -1;
	    }
	
	    /// <summary>
	    /// Returns the canonical name for the specified locale ID. This is used to
	    /// convert POSIX and other grandfathered IDs to standard ICU form.
	    /// </summary>
	    ///
	    /// <param name="localeID_0">the locale id</param>
	    /// <returns>the canonicalized id</returns>
	    /// @stable ICU 3.0
	    public static String Canonicalize(String localeID_0) {
	        ULocale.IDParser  parser = new ULocale.IDParser (localeID_0, true);
	        String baseName_1 = parser.GetBaseName();
	        bool foundVariant = false;
	
	        // formerly, we always set to en_US_POSIX if the basename was empty, but
	        // now we require that the entire id be empty, so that "@foo=bar"
	        // will pass through unchanged.
	        // {dlf} I'd rather keep "" unchanged.
	        if (localeID_0.Equals("")) {
	            return "";
	            // return "en_US_POSIX";
	        }
	
	        // we have an ID in the form xx_Yyyy_ZZ_KKKKK
	
	        InitVariantsTable();
	
	        /* See if this is an already known locale */
	        for (int i = 0; i < _variantsToKeywords.Length; i++) {
	            if (_variantsToKeywords[i][0].Equals(baseName_1)) {
	                foundVariant = true;
	
	                String[] vals = _variantsToKeywords[i];
	                parser.SetBaseName(vals[1]);
	                if (vals[2] != null) {
	                    parser.DefaultKeywordValue(vals[2], vals[3]);
	                }
	                break;
	            }
	        }
	
	        /* convert the Euro variant to appropriate ID */
	        if (!foundVariant) {
	            int idx = baseName_1.IndexOf("_EURO");
	            if (idx > -1) {
	                parser.SetBaseName(baseName_1.Substring(0,(idx)-(0)));
	                parser.DefaultKeywordValue("currency", "EUR");
	            }
	        }
	
	        /*
	         * total mondo hack for Norwegian, fortunately the main NY case is
	         * handled earlier
	         */
	        if (!foundVariant) {
	            if (parser.GetLanguage().Equals("nb")
	                    && parser.GetVariant().Equals("NY")) {
	                parser.SetBaseName(LscvToID("nn", parser.GetScript(),
	                        parser.GetCountry(), null));
	            }
	        }
	
	        return parser.GetName();
	    }
	
	    /// <summary>
	    /// Given a keyword and a value, return a new locale with an updated keyword
	    /// and value. If keyword is null, this removes all keywords from the locale
	    /// id. Otherwise, if the value is null, this removes the value for this
	    /// keyword from the locale id. Otherwise, this adds/replaces the value for
	    /// this keyword in the locale id. The keyword and value must not be empty.
	    /// </summary>
	    ///
	    /// <param name="keyword">the keyword to add/remove, or null to remove all keywords.</param>
	    /// <param name="value">the value to add/set, or null to remove this particularkeyword.</param>
	    /// <returns>the updated locale</returns>
	    /// @stable ICU 3.2
	    public ULocale SetKeywordValue(String keyword, String value_ren) {
	        return new ULocale(SetKeywordValue(localeID, keyword, value_ren),
                    (Locale)null);
	    }
	
	    /// <summary>
	    /// Given a locale id, a keyword, and a value, return a new locale id with an
	    /// updated keyword and value. If keyword is null, this removes all keywords
	    /// from the locale id. Otherwise, if the value is null, this removes the
	    /// value for this keyword from the locale id. Otherwise, this adds/replaces
	    /// the value for this keyword in the locale id. The keyword and value must
	    /// not be empty.
	    /// </summary>
	    ///
	    /// <param name="localeID_0">the locale id to modify</param>
	    /// <param name="keyword">the keyword to add/remove, or null to remove all keywords.</param>
	    /// <param name="value">the value to add/set, or null to remove this particularkeyword.</param>
	    /// <returns>the updated locale id</returns>
	    /// @stable ICU 3.2
	    public static String SetKeywordValue(String localeID_0, String keyword,
	            String value_ren) {
	        ULocale.IDParser  parser = new ULocale.IDParser (localeID_0);
	        parser.SetKeywordValue(keyword, value_ren);
	        return parser.GetName();
	    }
	
	    /*
	     * Given a locale id, a keyword, and a value, return a new locale id with an
	     * updated keyword and value, if the keyword does not already have a value.
	     * The keyword and value must not be null or empty.
	     * 
	     * @param localeID the locale id to modify
	     * 
	     * @param keyword the keyword to add, if not already present
	     * 
	     * @param value the value to add, if not already present
	     * 
	     * @return the updated locale id
	     * 
	     * @internal
	     */
	    /*
	     * private static String defaultKeywordValue(String localeID, String
	     * keyword, String value) { IDParser parser = new IDParser(localeID);
	     * parser.defaultKeywordValue(keyword, value); return parser.getName(); }
	     */
	
	    /// <summary>
	    /// Returns a three-letter abbreviation for this locale's language. If the
	    /// locale doesn't specify a language, returns the empty string. Otherwise,
	    /// returns a lowercase ISO 639-2/T language code. The ISO 639-2 language
	    /// codes can be found on-line at <a
	    /// href="ftp://dkuug.dk/i18n/iso-639-2.txt">
	    /// <code>ftp://dkuug.dk/i18n/iso-639-2.txt</code></a>
	    /// </summary>
	    ///
	    /// <exception cref="MissingResourceException">Throws MissingResourceException if the three-letterlanguage abbreviation is not available for this locale.</exception>
	    /// @stable ICU 3.0
	    public String GetISO3Language() {
	        return GetISO3Language(localeID);
	    }
	
	    /// <summary>
	    /// Returns a three-letter abbreviation for this locale's language. If the
	    /// locale doesn't specify a language, returns the empty string. Otherwise,
	    /// returns a lowercase ISO 639-2/T language code. The ISO 639-2 language
	    /// codes can be found on-line at <a
	    /// href="ftp://dkuug.dk/i18n/iso-639-2.txt">
	    /// <code>ftp://dkuug.dk/i18n/iso-639-2.txt</code></a>
	    /// </summary>
	    ///
	    /// <exception cref="MissingResourceException">Throws MissingResourceException if the three-letterlanguage abbreviation is not available for this locale.</exception>
	    /// @stable ICU 3.0
	    public static String GetISO3Language(String localeID_0) {
	        InitLanguageTables();
	
	        String language = GetLanguage(localeID_0);
	        int offset = FindIndex(_languages, language);
	        if (offset >= 0) {
	            return _languages3[offset];
	        } else {
	            offset = FindIndex(_obsoleteLanguages, language);
	            if (offset >= 0) {
	                return _obsoleteLanguages3[offset];
	            }
	        }
	        return EMPTY_STRING;
	    }
	
	    /// <summary>
	    /// Returns a three-letter abbreviation for this locale's country/region. If
	    /// the locale doesn't specify a country, returns the empty string.
	    /// Otherwise, returns an uppercase ISO 3166 3-letter country code.
	    /// </summary>
	    ///
	    /// <exception cref="MissingResourceException">Throws MissingResourceException if the three-lettercountry abbreviation is not available for this locale.</exception>
	    /// @stable ICU 3.0
	    public String GetISO3Country() {
	        return GetISO3Country(localeID);
	    }
	
	    /// <summary>
	    /// Returns a three-letter abbreviation for this locale's country/region. If
	    /// the locale doesn't specify a country, returns the empty string.
	    /// Otherwise, returns an uppercase ISO 3166 3-letter country code.
	    /// </summary>
	    ///
	    /// <exception cref="MissingResourceException">Throws MissingResourceException if the three-lettercountry abbreviation is not available for this locale.</exception>
	    /// @stable ICU 3.0
	    public static String GetISO3Country(String localeID_0) {
	        InitCountryTables();
	
	        String country = GetCountry(localeID_0);
	        int offset = FindIndex(_countries, country);
	        if (offset >= 0) {
	            return _countries3[offset];
	        } else {
	            offset = FindIndex(_obsoleteCountries, country);
	            if (offset >= 0) {
	                return _obsoleteCountries3[offset];
	            }
	        }
	        return EMPTY_STRING;
	    }
	
	    // display names
	
	    /// <summary>
	    /// Utility to fetch locale display data from resource bundle tables.
	    /// </summary>
	    ///
	    private static String GetTableString(String tableName, String subtableName,
	            String item, String displayLocaleID) {
	        if (item.Length > 0) {
	            try {
	                ICUResourceBundle bundle = (ICUResourceBundle) IBM.ICU.Util.UResourceBundle
	                        .GetBundleInstance(IBM.ICU.Impl.ICUResourceBundle.ICU_BASE_NAME,
	                                displayLocaleID);
	                return GetTableString(tableName, subtableName, item, bundle);
	            } catch (Exception e) {
	                // System.out.println("gtsu: " + e.getMessage());
	            }
	        }
	        return item;
	    }
	
	    /// <summary>
	    /// Utility to fetch locale display data from resource bundle tables.
	    /// </summary>
	    ///
	    private static String GetTableString(String tableName, String subtableName,
	            String item, ICUResourceBundle bundle) {
	        // System.out.println("gts table: " + tableName +
	        // " subtable: " + subtableName +
	        // " item: " + item +
	        // " bundle: " + bundle.getULocale());
	        try {
	            for (;;) {
	                // special case currency
	                if ("currency".Equals(subtableName)) {
	                    ICUResourceBundle table = bundle
	                            .GetWithFallback("Currencies");
	                    table = table.GetWithFallback(item);
	                    return table.GetString(1);
	                } else {
	                    ICUResourceBundle table_0 = bundle.GetWithFallback(tableName);
	                    try {
	                        if (subtableName != null) {
	                            table_0 = table_0.GetWithFallback(subtableName);
	                        }
	                        return table_0.GetStringWithFallback(item);
	                    } catch (MissingManifestResourceException e) {
	
	                        if (subtableName == null) {
	                            try {
	                                // may be a deprecated code
	                                String currentName = null;
	                                if (tableName.Equals("Countries")) {
	                                    currentName = GetCurrentCountryID(item);
	                                } else if (tableName.Equals("Languages")) {
	                                    currentName = GetCurrentLanguageID(item);
	                                }
	                                return table_0.GetStringWithFallback(currentName);
	                            } catch (MissingManifestResourceException ex) {/*
	                                                                    * fall
	                                                                    * through
	                                                                    */
	                            }
	                        }
	
	                        // still can't figure out ?.. try the fallback mechanism
	                        String fallbackLocale = table_0.GetWithFallback(
	                                "Fallback").GetString();
	                        if (fallbackLocale.Length == 0) {
	                            fallbackLocale = "root";
	                        }
	                        // System.out.println("bundle: " + bundle.getULocale() +
	                        // " fallback: " + fallbackLocale);
	                        if (fallbackLocale.Equals(table_0.GetULocale().localeID)) {
	                            return item;
	                        }
	                        bundle = (ICUResourceBundle) IBM.ICU.Util.UResourceBundle
	                                .GetBundleInstance(
	                                        IBM.ICU.Impl.ICUResourceBundle.ICU_BASE_NAME,
	                                        fallbackLocale);
	                        // System.out.println("fallback from " +
	                        // table.getULocale() + " to " + fallbackLocale +
	                        // ", got bundle " + bundle.getULocale());
	                    }
	                }
	            }
	        } catch (Exception e_1) {
	            // System.out.println("gtsi: " + e.getMessage());
	        }
	        return item;
	    }
	
	    /// <summary>
	    /// Returns this locale's language localized for display in the default
	    /// locale.
	    /// </summary>
	    ///
	    /// <returns>the localized language name.</returns>
	    /// @stable ICU 3.0
	    public String GetDisplayLanguage() {
	        return GetDisplayLanguageInternal(localeID, GetDefault().localeID);
	    }
	
	    /// <summary>
	    /// Returns this locale's language localized for display in the provided
	    /// locale.
	    /// </summary>
	    ///
	    /// <param name="displayLocale">the locale in which to display the name.</param>
	    /// <returns>the localized language name.</returns>
	    /// @stable ICU 3.0
	    public String GetDisplayLanguage(ULocale displayLocale) {
	        return GetDisplayLanguageInternal(localeID, displayLocale.localeID);
	    }
	
	    /// <summary>
	    /// Returns a locale's language localized for display in the provided locale.
	    /// This is a cover for the ICU4C API.
	    /// </summary>
	    ///
	    /// <param name="localeID_0">the id of the locale whose language will be displayed</param>
	    /// <param name="displayLocaleID">the id of the locale in which to display the name.</param>
	    /// <returns>the localized language name.</returns>
	    /// @stable ICU 3.0
	    public static String GetDisplayLanguage(String localeID_0,
	            String displayLocaleID) {
	        return GetDisplayLanguageInternal(localeID_0, GetName(displayLocaleID));
	    }
	
	    /// <summary>
	    /// Returns a locale's language localized for display in the provided locale.
	    /// This is a cover for the ICU4C API.
	    /// </summary>
	    ///
	    /// <param name="localeID_0">the id of the locale whose language will be displayed.</param>
	    /// <param name="displayLocale">the locale in which to display the name.</param>
	    /// <returns>the localized language name.</returns>
	    /// @stable ICU 3.0
	    public static String GetDisplayLanguage(String localeID_0,
	            ULocale displayLocale) {
	        return GetDisplayLanguageInternal(localeID_0, displayLocale.localeID);
	    }
	
	    static internal String GetCurrentCountryID(String oldID) {
	        InitCountryTables();
	        int offset = FindIndex(_deprecatedCountries, oldID);
	        if (offset >= 0) {
	            return _replacementCountries[offset];
	        }
	        return oldID;
	    }
	
	    static internal String GetCurrentLanguageID(String oldID) {
	        InitLanguageTables();
	        int offset = FindIndex(_obsoleteLanguages, oldID);
	        if (offset >= 0) {
	            return _replacementLanguages[offset];
	        }
	        return oldID;
	    }
	
	    // displayLocaleID is canonical, localeID need not be since parsing will fix
	    // this.
	    private static String GetDisplayLanguageInternal(String localeID_0,
	            String displayLocaleID) {
	        return GetTableString("Languages", null,
	                new ULocale.IDParser (localeID_0).GetLanguage(), displayLocaleID);
	    }
	
	    /// <summary>
	    /// Returns this locale's script localized for display in the default locale.
	    /// </summary>
	    ///
	    /// <returns>the localized script name.</returns>
	    /// @stable ICU 3.0
	    public String GetDisplayScript() {
	        return GetDisplayScriptInternal(localeID, GetDefault().localeID);
	    }
	
	    /// <summary>
	    /// Returns this locale's script localized for display in the provided
	    /// locale.
	    /// </summary>
	    ///
	    /// <param name="displayLocale">the locale in which to display the name.</param>
	    /// <returns>the localized script name.</returns>
	    /// @stable ICU 3.0
	    public String GetDisplayScript(ULocale displayLocale) {
	        return GetDisplayScriptInternal(localeID, displayLocale.localeID);
	    }
	
	    /// <summary>
	    /// Returns a locale's script localized for display in the provided locale.
	    /// This is a cover for the ICU4C API.
	    /// </summary>
	    ///
	    /// <param name="localeID_0">the id of the locale whose script will be displayed</param>
	    /// <param name="displayLocaleID">the id of the locale in which to display the name.</param>
	    /// <returns>the localized script name.</returns>
	    /// @stable ICU 3.0
	    public static String GetDisplayScript(String localeID_0,
	            String displayLocaleID) {
	        return GetDisplayScriptInternal(localeID_0, GetName(displayLocaleID));
	    }
	
	    /// <summary>
	    /// Returns a locale's script localized for display in the provided locale.
	    /// </summary>
	    ///
	    /// <param name="localeID_0">the id of the locale whose script will be displayed.</param>
	    /// <param name="displayLocale">the locale in which to display the name.</param>
	    /// <returns>the localized script name.</returns>
	    /// @stable ICU 3.0
	    public static String GetDisplayScript(String localeID_0, ULocale displayLocale) {
	        return GetDisplayScriptInternal(localeID_0, displayLocale.localeID);
	    }
	
	    // displayLocaleID is canonical, localeID need not be since parsing will fix
	    // this.
	    private static String GetDisplayScriptInternal(String localeID_0,
	            String displayLocaleID) {
	        return GetTableString("Scripts", null,
	                new ULocale.IDParser (localeID_0).GetScript(), displayLocaleID);
	    }
	
	    /// <summary>
	    /// Returns this locale's country localized for display in the default
	    /// locale.
	    /// </summary>
	    ///
	    /// <returns>the localized country name.</returns>
	    /// @stable ICU 3.0
	    public String GetDisplayCountry() {
	        return GetDisplayCountryInternal(localeID, GetDefault().localeID);
	    }
	
	    /// <summary>
	    /// Returns this locale's country localized for display in the provided
	    /// locale.
	    /// </summary>
	    ///
	    /// <param name="displayLocale">the locale in which to display the name.</param>
	    /// <returns>the localized country name.</returns>
	    /// @stable ICU 3.0
	    public String GetDisplayCountry(ULocale displayLocale) {
	        return GetDisplayCountryInternal(localeID, displayLocale.localeID);
	    }
	
	    /// <summary>
	    /// Returns a locale's country localized for display in the provided locale.
	    /// This is a cover for the ICU4C API.
	    /// </summary>
	    ///
	    /// <param name="localeID_0">the id of the locale whose country will be displayed</param>
	    /// <param name="displayLocaleID">the id of the locale in which to display the name.</param>
	    /// <returns>the localized country name.</returns>
	    /// @stable ICU 3.0
	    public static String GetDisplayCountry(String localeID_0,
	            String displayLocaleID) {
	        return GetDisplayCountryInternal(localeID_0, GetName(displayLocaleID));
	    }
	
	    /// <summary>
	    /// Returns a locale's country localized for display in the provided locale.
	    /// This is a cover for the ICU4C API.
	    /// </summary>
	    ///
	    /// <param name="localeID_0">the id of the locale whose country will be displayed.</param>
	    /// <param name="displayLocale">the locale in which to display the name.</param>
	    /// <returns>the localized country name.</returns>
	    /// @stable ICU 3.0
	    public static String GetDisplayCountry(String localeID_0,
	            ULocale displayLocale) {
	        return GetDisplayCountryInternal(localeID_0, displayLocale.localeID);
	    }
	
	    // displayLocaleID is canonical, localeID need not be since parsing will fix
	    // this.
	    private static String GetDisplayCountryInternal(String localeID_0,
	            String displayLocaleID) {
	        return GetTableString("Countries", null,
	                new ULocale.IDParser (localeID_0).GetCountry(), displayLocaleID);
	    }
	
	    /// <summary>
	    /// Returns this locale's variant localized for display in the default
	    /// locale.
	    /// </summary>
	    ///
	    /// <returns>the localized variant name.</returns>
	    /// @stable ICU 3.0
	    public String GetDisplayVariant() {
	        return GetDisplayVariantInternal(localeID, GetDefault().localeID);
	    }
	
	    /// <summary>
	    /// Returns this locale's variant localized for display in the provided
	    /// locale.
	    /// </summary>
	    ///
	    /// <param name="displayLocale">the locale in which to display the name.</param>
	    /// <returns>the localized variant name.</returns>
	    /// @stable ICU 3.0
	    public String GetDisplayVariant(ULocale displayLocale) {
	        return GetDisplayVariantInternal(localeID, displayLocale.localeID);
	    }
	
	    /// <summary>
	    /// Returns a locale's variant localized for display in the provided locale.
	    /// This is a cover for the ICU4C API.
	    /// </summary>
	    ///
	    /// <param name="localeID_0">the id of the locale whose variant will be displayed</param>
	    /// <param name="displayLocaleID">the id of the locale in which to display the name.</param>
	    /// <returns>the localized variant name.</returns>
	    /// @stable ICU 3.0
	    public static String GetDisplayVariant(String localeID_0,
	            String displayLocaleID) {
	        return GetDisplayVariantInternal(localeID_0, GetName(displayLocaleID));
	    }
	
	    /// <summary>
	    /// Returns a locale's variant localized for display in the provided locale.
	    /// This is a cover for the ICU4C API.
	    /// </summary>
	    ///
	    /// <param name="localeID_0">the id of the locale whose variant will be displayed.</param>
	    /// <param name="displayLocale">the locale in which to display the name.</param>
	    /// <returns>the localized variant name.</returns>
	    /// @stable ICU 3.0
	    public static String GetDisplayVariant(String localeID_0,
	            ULocale displayLocale) {
	        return GetDisplayVariantInternal(localeID_0, displayLocale.localeID);
	    }
	
	    // displayLocaleID is canonical, localeID need not be since parsing will fix
	    // this.
	    private static String GetDisplayVariantInternal(String localeID_0,
	            String displayLocaleID) {
	        return GetTableString("Variants", null,
	                new ULocale.IDParser (localeID_0).GetVariant(), displayLocaleID);
	    }
	
	    /// <summary>
	    /// Returns a keyword localized for display in the default locale.
	    /// </summary>
	    ///
	    /// <param name="keyword">the keyword to be displayed.</param>
	    /// <returns>the localized keyword name.</returns>
	    /// <seealso cref="M:IBM.ICU.Util.ULocale.GetKeywords"/>
	    /// @stable ICU 3.0
	    public static String GetDisplayKeyword(String keyword) {
	        return GetDisplayKeywordInternal(keyword, GetDefault().localeID);
	    }
	
	    /// <summary>
	    /// Returns a keyword localized for display in the specified locale.
	    /// </summary>
	    ///
	    /// <param name="keyword">the keyword to be displayed.</param>
	    /// <param name="displayLocaleID">the id of the locale in which to display the keyword.</param>
	    /// <returns>the localized keyword name.</returns>
	    /// <seealso cref="M:IBM.ICU.Util.ULocale.GetKeywords(System.String)"/>
	    /// @stable ICU 3.0
	    public static String GetDisplayKeyword(String keyword,
	            String displayLocaleID) {
	        return GetDisplayKeywordInternal(keyword, GetName(displayLocaleID));
	    }
	
	    /// <summary>
	    /// Returns a keyword localized for display in the specified locale.
	    /// </summary>
	    ///
	    /// <param name="keyword">the keyword to be displayed.</param>
	    /// <param name="displayLocale">the locale in which to display the keyword.</param>
	    /// <returns>the localized keyword name.</returns>
	    /// <seealso cref="M:IBM.ICU.Util.ULocale.GetKeywords(System.String)"/>
	    /// @stable ICU 3.0
	    public static String GetDisplayKeyword(String keyword, ULocale displayLocale) {
	        return GetDisplayKeywordInternal(keyword, displayLocale.localeID);
	    }
	
	    // displayLocaleID is canonical, localeID need not be since parsing will fix
	    // this.
	    private static String GetDisplayKeywordInternal(String keyword,
	            String displayLocaleID) {
	        return GetTableString("Keys", null, keyword.Trim().ToLower(),
	                displayLocaleID);
	    }
	
	    /// <summary>
	    /// Returns a keyword value localized for display in the default locale.
	    /// </summary>
	    ///
	    /// <param name="keyword">the keyword whose value is to be displayed.</param>
	    /// <returns>the localized value name.</returns>
	    /// @stable ICU 3.0
	    public String GetDisplayKeywordValue(String keyword) {
	        return GetDisplayKeywordValueInternal(localeID, keyword,
	                GetDefault().localeID);
	    }
	
	    /// <summary>
	    /// Returns a keyword value localized for display in the specified locale.
	    /// </summary>
	    ///
	    /// <param name="keyword">the keyword whose value is to be displayed.</param>
	    /// <param name="displayLocale">the locale in which to display the value.</param>
	    /// <returns>the localized value name.</returns>
	    /// @stable ICU 3.0
	    public String GetDisplayKeywordValue(String keyword, ULocale displayLocale) {
	        return GetDisplayKeywordValueInternal(localeID, keyword,
	                displayLocale.localeID);
	    }
	
	    /// <summary>
	    /// Returns a keyword value localized for display in the specified locale.
	    /// This is a cover for the ICU4C API.
	    /// </summary>
	    ///
	    /// <param name="localeID_0">the id of the locale whose keyword value is to be displayed.</param>
	    /// <param name="keyword">the keyword whose value is to be displayed.</param>
	    /// <param name="displayLocaleID">the id of the locale in which to display the value.</param>
	    /// <returns>the localized value name.</returns>
	    /// @stable ICU 3.0
	    public static String GetDisplayKeywordValue(String localeID_0,
	            String keyword, String displayLocaleID) {
	        return GetDisplayKeywordValueInternal(localeID_0, keyword,
	                GetName(displayLocaleID));
	    }
	
	    /// <summary>
	    /// Returns a keyword value localized for display in the specified locale.
	    /// This is a cover for the ICU4C API.
	    /// </summary>
	    ///
	    /// <param name="localeID_0">the id of the locale whose keyword value is to be displayed.</param>
	    /// <param name="keyword">the keyword whose value is to be displayed.</param>
	    /// <param name="displayLocale">the id of the locale in which to display the value.</param>
	    /// <returns>the localized value name.</returns>
	    /// @stable ICU 3.0
	    public static String GetDisplayKeywordValue(String localeID_0,
	            String keyword, ULocale displayLocale) {
	        return GetDisplayKeywordValueInternal(localeID_0, keyword,
	                displayLocale.localeID);
	    }
	
	    // displayLocaleID is canonical, localeID need not be since parsing will fix
	    // this.
	    private static String GetDisplayKeywordValueInternal(String localeID_0,
	            String keyword, String displayLocaleID) {
	        keyword = keyword.Trim().ToLower();
	        String value_ren = new ULocale.IDParser (localeID_0).GetKeywordValue(keyword);
	        return GetTableString("Types", keyword, value_ren, displayLocaleID);
	    }
	
	    /// <summary>
	    /// Returns this locale name localized for display in the default locale.
	    /// </summary>
	    ///
	    /// <returns>the localized locale name.</returns>
	    /// @stable ICU 3.0
	    public String GetDisplayName() {
	        return GetDisplayNameInternal(localeID, GetDefault().localeID);
	    }
	
	    /// <summary>
	    /// Returns this locale name localized for display in the provided locale.
	    /// </summary>
	    ///
	    /// <param name="displayLocale">the locale in which to display the locale name.</param>
	    /// <returns>the localized locale name.</returns>
	    /// @stable ICU 3.0
	    public String GetDisplayName(ULocale displayLocale) {
	        return GetDisplayNameInternal(localeID, displayLocale.localeID);
	    }
	
	    /// <summary>
	    /// Returns the locale ID localized for display in the provided locale. This
	    /// is a cover for the ICU4C API.
	    /// </summary>
	    ///
	    /// <param name="localeID_0">the locale whose name is to be displayed.</param>
	    /// <param name="displayLocaleID">the id of the locale in which to display the locale name.</param>
	    /// <returns>the localized locale name.</returns>
	    /// @stable ICU 3.0
	    public static String GetDisplayName(String localeID_0, String displayLocaleID) {
	        return GetDisplayNameInternal(localeID_0, GetName(displayLocaleID));
	    }
	
	    /// <summary>
	    /// Returns the locale ID localized for display in the provided locale. This
	    /// is a cover for the ICU4C API.
	    /// </summary>
	    ///
	    /// <param name="localeID_0">the locale whose name is to be displayed.</param>
	    /// <param name="displayLocale">the locale in which to display the locale name.</param>
	    /// <returns>the localized locale name.</returns>
	    /// @stable ICU 3.0
	    public static String GetDisplayName(String localeID_0, ULocale displayLocale) {
	        return GetDisplayNameInternal(localeID_0, displayLocale.localeID);
	    }
	
	    // displayLocaleID is canonical, localeID need not be since parsing will fix
	    // this.
	    private static String GetDisplayNameInternal(String localeID_0,
	            String displayLocaleID) {
	        // lang
	        // lang (script, country, variant, keyword=value, ...)
	        // script, country, variant, keyword=value, ...
	
	        String[] tableNames = { "Languages", "Scripts", "Countries",
	                "Variants" };
	
	        ICUResourceBundle bundle = (ICUResourceBundle) IBM.ICU.Util.UResourceBundle
	                .GetBundleInstance(IBM.ICU.Impl.ICUResourceBundle.ICU_BASE_NAME,
	                        displayLocaleID);
	
	        StringBuilder buf = new StringBuilder();
	
	        ULocale.IDParser  parser = new ULocale.IDParser (localeID_0);
	        String[] names = parser.GetLanguageScriptCountryVariant();
	
	        bool haveLanguage = names[0].Length > 0;
	        bool openParen = false;
	        for (int i = 0; i < names.Length; ++i) {
	            String name = names[i];
	            if (name.Length > 0) {
	                name = GetTableString(tableNames[i], null, name, bundle);
	                if (buf.Length > 0) { // need a separator
	                    if (haveLanguage & !openParen) {
	                        buf.Append(" (");
	                        openParen = true;
	                    } else {
	                        buf.Append(", ");
	                    }
	                }
	                buf.Append(name);
	            }
	        }
	
	        IDictionary m = parser.GetKeywordMap();
	        if (!(m.Count==0)) {
	            IIterator keys = new ILOG.J2CsMapping.Collections.IteratorAdapter(m.GetEnumerator());
	            while (keys.HasNext()) {
	                if (buf.Length > 0) {
	                    if (haveLanguage & !openParen) {
	                        buf.Append(" (");
	                        openParen = true;
	                    } else {
	                        buf.Append(", ");
	                    }
	                }
	                DictionaryEntry e = (DictionaryEntry) keys.Next();
	                String key = (String) ((DictionaryEntry) e).Key;
	                String val = (String) ((DictionaryEntry) e).Value;
	                buf.Append(GetTableString("Keys", null, key, bundle));
	                buf.Append("=");
	                buf.Append(GetTableString("Types", key, val, bundle));
	            }
	        }
	
	        if (openParen) {
	            buf.Append(")");
	        }
	
	        return buf.ToString();
	    }
	
	    /// <summary>
	    /// Selector for <tt>getLocale()</tt> indicating the locale of the resource
	    /// containing the data. This is always at or above the valid locale. If the
	    /// valid locale does not contain the specific data being requested, then the
	    /// actual locale will be above the valid locale. If the object was not
	    /// constructed from locale data, then the valid locale is <i>null</i>.
	    /// </summary>
	    ///
	    /// @draft ICU 2.8 (retain)
	    /// @provisional This API might change or be removed in a future release.
	    public static ULocale.Type  ACTUAL_LOCALE = new ULocale.Type (0);
	
	    /// <summary>
	    /// Selector for <tt>getLocale()</tt> indicating the most specific locale for
	    /// which any data exists. This is always at or above the requested locale,
	    /// and at or below the actual locale. If the requested locale does not
	    /// correspond to any resource data, then the valid locale will be above the
	    /// requested locale. If the object was not constructed from locale data,
	    /// then the actual locale is <i>null</i>.
	    /// <p>
	    /// Note: The valid locale will be returned correctly in ICU 3.0 or later. In
	    /// ICU 2.8, it is not returned correctly.
	    /// </summary>
	    ///
	    /// @draft ICU 2.8 (retain)
	    /// @provisional This API might change or be removed in a future release.
	    public static ULocale.Type  VALID_LOCALE = new ULocale.Type (1);
	
	    /// <summary>
	    /// Opaque selector enum for <tt>getLocale()</tt>.
	    /// </summary>
	    ///
	    /// <seealso cref="T:IBM.ICU.Util.ULocale"/>
	    /// <seealso cref="M:IBM.ICU.Util.ULocale.ACTUAL_LOCALE"/>
	    /// <seealso cref="M:IBM.ICU.Util.ULocale.VALID_LOCALE"/>
	    /// @draft ICU 2.8 (retainAll)
	    /// @provisional This API might change or be removed in a future release.
	    public sealed class Type {
	        private int localeType;
	
	        public Type(int type) {
	            localeType = type;
	        }
	    }
	
	    /// <summary>
	    /// Based on a HTTP formatted list of acceptable locales, determine an
	    /// available locale for the user. NullPointerException is thrown if
	    /// acceptLanguageList or availableLocales is null. If fallback is non-null,
	    /// it will contain true if a fallback locale (one not in the
	    /// acceptLanguageList) was returned. The value on entry is ignored. ULocale
	    /// will be one of the locales in availableLocales, or the ROOT ULocale if if
	    /// a ROOT locale was used as a fallback (because nothing else in
	    /// availableLocales matched). No ULocale array element should be null;
	    /// behavior is undefined if this is the case.
	    /// </summary>
	    ///
	    /// <param name="acceptLanguageList">list in HTTP "Accept-Language:" format of acceptable locales</param>
	    /// <param name="availableLocales">list of available locales. One of these will be returned.</param>
	    /// <param name="fallback">if non-null, a 1-element array containing a boolean to be setwith the fallback status</param>
	    /// <returns>one of the locales from the availableLocales list, or null if
	    /// none match</returns>
	    /// @stable ICU 3.4
	
	    public static ULocale AcceptLanguage(String acceptLanguageList,
	            ULocale[] availableLocales, bool[] fallback) {
	        if (acceptLanguageList == null) {
	            throw new NullReferenceException();
	        }
	        ULocale[] acceptList = null;
	        try {
	            acceptList = ParseAcceptLanguage(acceptLanguageList, true);
	        } catch (ILOG.J2CsMapping.Util.ParseException pe) {
	            acceptList = null;
	        }
	        if (acceptList == null) {
	            return null;
	        }
	        return AcceptLanguage(acceptList, availableLocales, fallback);
	    }
	
	    /// <summary>
	    /// Based on a list of acceptable locales, determine an available locale for
	    /// the user. NullPointerException is thrown if acceptLanguageList or
	    /// availableLocales is null. If fallback is non-null, it will contain true
	    /// if a fallback locale (one not in the acceptLanguageList) was returned.
	    /// The value on entry is ignored. ULocale will be one of the locales in
	    /// availableLocales, or the ROOT ULocale if if a ROOT locale was used as a
	    /// fallback (because nothing else in availableLocales matched). No ULocale
	    /// array element should be null; behavior is undefined if this is the case.
	    /// </summary>
	    ///
	    /// <param name="acceptLanguageList">list of acceptable locales</param>
	    /// <param name="availableLocales">list of available locales. One of these will be returned.</param>
	    /// <param name="fallback">if non-null, a 1-element array containing a boolean to be setwith the fallback status</param>
	    /// <returns>one of the locales from the availableLocales list, or null if
	    /// none match</returns>
	    /// @stable ICU 3.4
	
	    public static ULocale AcceptLanguage(ULocale[] acceptLanguageList,
	            ULocale[] availableLocales, bool[] fallback) {
	        // fallbacklist
	        int i, j;
	        if (fallback != null) {
	            fallback[0] = true;
	        }
	        for (i = 0; i < acceptLanguageList.Length; i++) {
	            ULocale aLocale = acceptLanguageList[i];
	            bool[] setFallback = fallback;
	            do {
	                for (j = 0; j < availableLocales.Length; j++) {
	                    if (availableLocales[j].Equals(aLocale)) {
	                        if (setFallback != null) {
	                            setFallback[0] = false; // first time with this
	                                                    // locale - not a fallback.
	                        }
	                        return availableLocales[j];
	                    }
	                }
                    Locale loc = aLocale.ToLocale();
                    Locale parent = IBM.ICU.Impl.LocaleUtility.Fallback(loc);
	                if (parent != null) {
	                    aLocale = new ULocale(parent);
	                } else {
	                    aLocale = null;
	                }
	                setFallback = null; // Do not set fallback in later iterations
	            } while (aLocale != null);
	        }
	        return null;
	    }
	
	    /// <summary>
	    /// Based on a HTTP formatted list of acceptable locales, determine an
	    /// available locale for the user. NullPointerException is thrown if
	    /// acceptLanguageList or availableLocales is null. If fallback is non-null,
	    /// it will contain true if a fallback locale (one not in the
	    /// acceptLanguageList) was returned. The value on entry is ignored. ULocale
	    /// will be one of the locales in availableLocales, or the ROOT ULocale if if
	    /// a ROOT locale was used as a fallback (because nothing else in
	    /// availableLocales matched). No ULocale array element should be null;
	    /// behavior is undefined if this is the case. This function will choose a
	    /// locale from the ULocale.getAvailableLocales() list as available.
	    /// </summary>
	    ///
	    /// <param name="acceptLanguageList">list in HTTP "Accept-Language:" format of acceptable locales</param>
	    /// <param name="fallback">if non-null, a 1-element array containing a boolean to be setwith the fallback status</param>
	    /// <returns>one of the locales from the ULocale.getAvailableLocales() list,
	    /// or null if none match</returns>
	    /// @stable ICU 3.4
	
	    public static ULocale AcceptLanguage(String acceptLanguageList,
	            bool[] fallback) {
	        return AcceptLanguage(acceptLanguageList,
	                ULocale.GetAvailableLocales(), fallback);
	    }
	
	    /// <summary>
	    /// Based on an ordered array of acceptable locales, determine an available
	    /// locale for the user. NullPointerException is thrown if acceptLanguageList
	    /// or availableLocales is null. If fallback is non-null, it will contain
	    /// true if a fallback locale (one not in the acceptLanguageList) was
	    /// returned. The value on entry is ignored. ULocale will be one of the
	    /// locales in availableLocales, or the ROOT ULocale if if a ROOT locale was
	    /// used as a fallback (because nothing else in availableLocales matched). No
	    /// ULocale array element should be null; behavior is undefined if this is
	    /// the case. This function will choose a locale from the
	    /// ULocale.getAvailableLocales() list as available.
	    /// </summary>
	    ///
	    /// <param name="acceptLanguageList">ordered array of acceptable locales (preferred are listedfirst)</param>
	    /// <param name="fallback">if non-null, a 1-element array containing a boolean to be setwith the fallback status</param>
	    /// <returns>one of the locales from the ULocale.getAvailableLocales() list,
	    /// or null if none match</returns>
	    /// @stable ICU 3.4
	
	    public static ULocale AcceptLanguage(ULocale[] acceptLanguageList,
	            bool[] fallback) {
	        return AcceptLanguage(acceptLanguageList,
	                ULocale.GetAvailableLocales(), fallback);
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Package local method used for parsing Accept-Language string
	    /// </summary>
	    ///
	    static internal ULocale[] ParseAcceptLanguage(String acceptLanguage,
	            bool isLenient) {
	        
	
	        // parse out the acceptLanguage into an array
	        SortedList map = new SortedList();
	        StringBuilder languageRangeBuf = new StringBuilder();
	        StringBuilder qvalBuf = new StringBuilder();
	        int state = 0;
	        acceptLanguage += ","; // append comma to simplify the parsing code
	        int n;
	        bool subTag = false;
	        bool q1 = false;
	        for (n = 0; n < acceptLanguage.Length; n++) {
	            bool gotLanguageQ = false;
	            char c = acceptLanguage[n];
	            switch (state) {
	            case 0: // before language-range start
	                if (('A' <= c && c <= 'Z') || ('a' <= c && c <= 'z')) {
	                    // in language-range
	                    languageRangeBuf.Append(c);
	                    state = 1;
	                    subTag = false;
	                } else if (c == '*') {
	                    languageRangeBuf.Append(c);
	                    state = 2;
	                } else if (c != ' ' && c != '\t') {
	                    // invalid character
	                    state = -1;
	                }
	                break;
	            case 1: // in language-range
	                if (('A' <= c && c <= 'Z') || ('a' <= c && c <= 'z')) {
	                    languageRangeBuf.Append(c);
	                } else if (c == '-') {
	                    subTag = true;
	                    languageRangeBuf.Append(c);
	                } else if (c == '_') {
	                    if (isLenient) {
	                        subTag = true;
	                        languageRangeBuf.Append(c);
	                    } else {
	                        state = -1;
	                    }
	                } else if ('0' <= c && c <= '9') {
	                    if (subTag) {
	                        languageRangeBuf.Append(c);
	                    } else {
	                        // DIGIT is allowed only in language sub tag
	                        state = -1;
	                    }
	                } else if (c == ',') {
	                    // language-q end
	                    gotLanguageQ = true;
	                } else if (c == ' ' || c == '\t') {
	                    // language-range end
	                    state = 3;
	                } else if (c == ';') {
	                    // before q
	                    state = 4;
	                } else {
	                    // invalid character for language-range
	                    state = -1;
	                }
	                break;
	            case 2: // saw wild card range
	                if (c == ',') {
	                    // language-q end
	                    gotLanguageQ = true;
	                } else if (c == ' ' || c == '\t') {
	                    // language-range end
	                    state = 3;
	                } else if (c == ';') {
	                    // before q
	                    state = 4;
	                } else {
	                    // invalid
	                    state = -1;
	                }
	                break;
	            case 3: // language-range end
	                if (c == ',') {
	                    // language-q end
	                    gotLanguageQ = true;
	                } else if (c == ';') {
	                    // before q
	                    state = 4;
	                } else if (c != ' ' && c != '\t') {
	                    // invalid
	                    state = -1;
	                }
	                break;
	            case 4: // before q
	                if (c == 'q') {
	                    // before equal
	                    state = 5;
	                } else if (c != ' ' && c != '\t') {
	                    // invalid
	                    state = -1;
	                }
	                break;
	            case 5: // before equal
	                if (c == '=') {
	                    // before q value
	                    state = 6;
	                } else if (c != ' ' && c != '\t') {
	                    // invalid
	                    state = -1;
	                }
	                break;
	            case 6: // before q value
	                if (c == '0') {
	                    // q value start with 0
	                    q1 = false;
	                    qvalBuf.Append(c);
	                    state = 7;
	                } else if (c == '1') {
	                    // q value start with 1
	                    qvalBuf.Append(c);
	                    state = 7;
	                } else if (c == '.') {
	                    if (isLenient) {
	                        qvalBuf.Append(c);
	                        state = 8;
	                    } else {
	                        state = -1;
	                    }
	                } else if (c != ' ' && c != '\t') {
	                    // invalid
	                    state = -1;
	                }
	                break;
	            case 7: // q value start
	                if (c == '.') {
	                    // before q value fraction part
	                    qvalBuf.Append(c);
	                    state = 8;
	                } else if (c == ',') {
	                    // language-q end
	                    gotLanguageQ = true;
	                } else if (c == ' ' || c == '\t') {
	                    // after q value
	                    state = 10;
	                } else {
	                    // invalid
	                    state = -1;
	                }
	                break;
	            case 8: // before q value fraction part
	                if ('0' <= c || c <= '9') {
	                    if (q1 && c != '0' && !isLenient) {
	                        // if q value starts with 1, the fraction part must be 0
	                        state = -1;
	                    } else {
	                        // in q value fraction part
	                        qvalBuf.Append(c);
	                        state = 9;
	                    }
	                } else {
	                    // invalid
	                    state = -1;
	                }
	                break;
	            case 9: // in q value fraction part
	                if ('0' <= c && c <= '9') {
	                    if (q1 && c != '0') {
	                        // if q value starts with 1, the fraction part must be 0
	                        state = -1;
	                    } else {
	                        qvalBuf.Append(c);
	                    }
	                } else if (c == ',') {
	                    // language-q end
	                    gotLanguageQ = true;
	                } else if (c == ' ' || c == '\t') {
	                    // after q value
	                    state = 10;
	                } else {
	                    // invalid
	                    state = -1;
	                }
	                break;
	            case 10: // after q value
	                if (c == ',') {
	                    // language-q end
	                    gotLanguageQ = true;
	                } else if (c != ' ' && c != '\t') {
	                    // invalid
	                    state = -1;
	                }
	                break;
	            }
	            if (state == -1) {
	                // error state
	                throw new ILOG.J2CsMapping.Util.ParseException("Invalid Accept-Language"+n);
	            }
	            if (gotLanguageQ) {
	                double q = 1.0d;
	                if (qvalBuf.Length != 0) {
	                    try {
	                        q = ((Double )Double.Parse(qvalBuf.ToString(),ILOG.J2CsMapping.Util.NumberFormatProvider.NumberFormat));
	                    } catch (FormatException nfe) {
	                        // Already validated, so it should never happen
	                        q = 1.0d;
	                    }
	                    if (q > 1.0d) {
	                        q = 1.0d;
	                    }
	                }
	                if (languageRangeBuf[0] != '*') {
	                    int serial = map.Count;
	                    ULocale.ULocaleAcceptLanguageQ  entry = new ULocale.ULocaleAcceptLanguageQ (
	                            q, serial);
	                    ILOG.J2CsMapping.Collections.Collections.Put(map,entry,new ULocale(Canonicalize(languageRangeBuf
	                                                        .ToString()))); // sort in reverse order..
	                                                    // 1.0, 0.9, 0.8 .. etc
	                }
	
	                // reset buffer and parse state
	                languageRangeBuf.Length=0;
	                qvalBuf.Length=0;
	                state = 0;
	            }
	        }
	        if (state != 0) {
	            // Well, the parser should handle all cases. So just in case.
	            throw new ILOG.J2CsMapping.Util.ParseException("Invalid AcceptlLanguage"+n);
	        }
	
	        ULocale[] acceptList = (ULocale[]) ILOG.J2CsMapping.Collections.Generics.Collections.ToArray(map.Values,new ULocale[map.Count]);
	        return acceptList;
	    }
	
	    private static Hashtable _likelySubtagMaximizeMap;
	
	    private static void InitLikelySubtagMaximizeMap() {
	        if (_likelySubtagMaximizeMap != null) {
	            return;
	        }
	        // We should use CLDR data which will be introduced in CLDR1.5.1.
	        // For now, use the hardcoded table below.
	        String[][] likelySubtagTable = { new String[] { "aa", "aa_Latn_ET" },
	                new String[] { "af", "af_Latn_ZA" },
	                new String[] { "ak", "ak_Latn_GH" },
	                new String[] { "am", "am_Ethi_ET" },
	                new String[] { "ar", "ar_Arab_EG" },
	                new String[] { "as", "as_Beng_IN" },
	                new String[] { "az", "az_Latn_AZ" },
	                new String[] { "be", "be_Cyrl_BY" },
	                new String[] { "bg", "bg_Cyrl_BG" },
	                new String[] { "bn", "bn_Beng_BD" },
	                new String[] { "bo", "bo_Tibt_CN" },
	                new String[] { "bs", "bs_Latn_BA" },
	                new String[] { "byn", "byn_Ethi_ER" },
	                new String[] { "ca", "ca_Latn_ES" },
	                new String[] { "cch", "cch_Latn_NG" },
	                new String[] { "ch", "ch_Latn_GU" },
	                new String[] { "chk", "chk_Latn_FM" },
	                new String[] { "cop", "cop_Arab_EG" },
	                new String[] { "cs", "cs_Latn_CZ" },
	                new String[] { "cy", "cy_Latn_GB" },
	                new String[] { "da", "da_Latn_DK" },
	                new String[] { "de", "de_Latn_DE" },
	                new String[] { "dv", "dv_Thaa_MV" },
	                new String[] { "dz", "dz_Tibt_BT" },
	                new String[] { "ee", "ee_Latn_GH" },
	                new String[] { "el", "el_Grek_GR" },
	                new String[] { "en", "en_Latn_US" },
	                new String[] { "es", "es_Latn_ES" },
	                new String[] { "et", "et_Latn_EE" },
	                new String[] { "eu", "eu_Latn_ES" },
	                new String[] { "fa", "fa_Arab_IR" },
	                new String[] { "fi", "fi_Latn_FI" },
	                new String[] { "fil", "fil_Latn_PH" },
	                new String[] { "fj", "fj_Latn_FJ" },
	                new String[] { "fo", "fo_Latn_FO" },
	                new String[] { "fr", "fr_Latn_FR" },
	                new String[] { "fur", "fur_Latn_IT" },
	                new String[] { "ga", "ga_Latn_IE" },
	                new String[] { "gaa", "gaa_Latn_GH" },
	                new String[] { "gez", "gez_Ethi_ER" },
	                new String[] { "gl", "gl_Latn_ES" },
	                new String[] { "gn", "gn_Latn_PY" },
	                new String[] { "gu", "gu_Gujr_IN" },
	                new String[] { "gv", "gv_Latn_GB" },
	                new String[] { "ha", "ha_Latn_NG" },
	                new String[] { "haw", "haw_Latn_US" },
	                new String[] { "he", "he_Hebr_IL" },
	                new String[] { "hi", "hi_Deva_IN" },
	                new String[] { "hr", "hr_Latn_HR" },
	                new String[] { "ht", "ht_Latn_HT" },
	                new String[] { "hu", "hu_Latn_HU" },
	                new String[] { "hy", "hy_Armn_AM" },
	                new String[] { "id", "id_Latn_ID" },
	                new String[] { "ig", "ig_Latn_NG" },
	                new String[] { "ii", "ii_Yiii_CN" },
	                new String[] { "is", "is_Latn_IS" },
	                new String[] { "it", "it_Latn_IT" },
	                new String[] { "iu", "iu_Cans_CA" },
	                new String[] { "ja", "ja_Jpan_JP" },
	                new String[] { "ka", "ka_Geor_GE" },
	                new String[] { "kaj", "kaj_Latn_NG" },
	                new String[] { "kam", "kam_Latn_KE" },
	                new String[] { "kcg", "kcg_Latn_NG" },
	                new String[] { "kfo", "kfo_Latn_NG" },
	                new String[] { "kk", "kk_Cyrl_KZ" },
	                new String[] { "kl", "kl_Latn_GL" },
	                new String[] { "km", "km_Khmr_KH" },
	                new String[] { "kn", "kn_Knda_IN" },
	                new String[] { "ko", "ko_Kore_KR" },
	                new String[] { "kok", "kok_Deva_IN" },
	                new String[] { "kpe", "kpe_Latn_LR" },
	                new String[] { "ku", "ku_Latn_TR" },
	                new String[] { "kw", "kw_Latn_GB" },
	                new String[] { "ky", "ky_Cyrl_KG" },
	                new String[] { "la", "la_Latn_VA" },
	                new String[] { "ln", "ln_Latn_CD" },
	                new String[] { "lo", "lo_Laoo_LA" },
	                new String[] { "lt", "lt_Latn_LT" },
	                new String[] { "lv", "lv_Latn_LV" },
	                new String[] { "mg", "mg_Latn_MG" },
	                new String[] { "mh", "mh_Latn_MH" },
	                new String[] { "mk", "mk_Cyrl_MK" },
	                new String[] { "ml", "ml_Mlym_IN" },
	                new String[] { "mn", "mn_Cyrl_MN" },
	                new String[] { "mr", "mr_Deva_IN" },
	                new String[] { "ms", "ms_Latn_MY" },
	                new String[] { "mt", "mt_Latn_MT" },
	                new String[] { "my", "my_Mymr_MM" },
	                new String[] { "na", "na_Latn_NR" },
	                new String[] { "nb", "nb_Latn_NO" },
	                new String[] { "ne", "ne_Deva_NP" },
	                new String[] { "niu", "niu_Latn_NU" },
	                new String[] { "nl", "nl_Latn_NL" },
	                new String[] { "nn", "nn_Latn_NO" },
	                new String[] { "nr", "nr_Latn_ZA" },
	                new String[] { "nso", "nso_Latn_ZA" },
	                new String[] { "ny", "ny_Latn_MW" },
	                new String[] { "om", "om_Latn_ET" },
	                new String[] { "or", "or_Orya_IN" },
	                new String[] { "pa", "pa_Guru_IN" },
	                new String[] { "pa_Arab", "pa_Arab_PK" },
	                new String[] { "pa_PK", "pa_Arab_PK" },
	                new String[] { "pap", "pap_Latn_AN" },
	                new String[] { "pau", "pau_Latn_PW" },
	                new String[] { "pl", "pl_Latn_PL" },
	                new String[] { "ps", "ps_Arab_AF" },
	                new String[] { "pt", "pt_Latn_BR" },
	                new String[] { "rn", "rn_Latn_BI" },
	                new String[] { "ro", "ro_Latn_RO" },
	                new String[] { "ru", "ru_Cyrl_RU" },
	                new String[] { "rw", "rw_Latn_RW" },
	                new String[] { "sa", "sa_Deva_IN" },
	                new String[] { "se", "se_Latn_NO" },
	                new String[] { "sg", "sg_Latn_CF" },
	                new String[] { "sh", "sr_Latn_RS" },
	                new String[] { "si", "si_Sinh_LK" },
	                new String[] { "sid", "sid_Latn_ET" },
	                new String[] { "sk", "sk_Latn_SK" },
	                new String[] { "sl", "sl_Latn_SI" },
	                new String[] { "sm", "sm_Latn_AS" },
	                new String[] { "so", "so_Latn_SO" },
	                new String[] { "sq", "sq_Latn_AL" },
	                new String[] { "sr", "sr_Cyrl_RS" },
	                new String[] { "ss", "ss_Latn_ZA" },
	                new String[] { "st", "st_Latn_ZA" },
	                new String[] { "sv", "sv_Latn_SE" },
	                new String[] { "sw", "sw_Latn_TZ" },
	                new String[] { "syr", "syr_Syrc_SY" },
	                new String[] { "ta", "ta_Taml_IN" },
	                new String[] { "te", "te_Telu_IN" },
	                new String[] { "tet", "tet_Latn_TL" },
	                new String[] { "tg", "tg_Cyrl_TJ" },
	                new String[] { "th", "th_Thai_TH" },
	                new String[] { "ti", "ti_Ethi_ET" },
	                new String[] { "tig", "tig_Ethi_ER" },
	                new String[] { "tk", "tk_Latn_TM" },
	                new String[] { "tkl", "tkl_Latn_TK" },
	                new String[] { "tn", "tn_Latn_ZA" },
	                new String[] { "to", "to_Latn_TO" },
	                new String[] { "tpi", "tpi_Latn_PG" },
	                new String[] { "tr", "tr_Latn_TR" },
	                new String[] { "ts", "ts_Latn_ZA" },
	                new String[] { "tt", "tt_Cyrl_RU" },
	                new String[] { "tvl", "tvl_Latn_TV" },
	                new String[] { "ty", "ty_Latn_PF" },
	                new String[] { "uk", "uk_Cyrl_UA" },
	                new String[] { "ur", "ur_Arab_IN" },
	                new String[] { "uz", "uz_Cyrl_UZ" },
	                new String[] { "uz_AF", "uz_Arab_AF" },
	                new String[] { "uz_Arab", "uz_Arab_AF" },
	                new String[] { "ve", "ve_Latn_ZA" },
	                new String[] { "vi", "vi_Latn_VN" },
	                new String[] { "wal", "wal_Ethi_ET" },
	                new String[] { "wo", "wo_Arab_SN" },
	                new String[] { "wo_SN", "wo_Latn_SN" },
	                new String[] { "xh", "xh_Latn_ZA" },
	                new String[] { "yo", "yo_Latn_NG" },
	                new String[] { "zh", "zh_Hans_CN" },
	                new String[] { "zh_Hani", "zh_Hans_CN" },
	                new String[] { "zh_Hant", "zh_Hant_TW" },
	                new String[] { "zh_HK", "zh_Hant_HK" },
	                new String[] { "zh_MO", "zh_Hant_MO" },
	                new String[] { "zh_TW", "zh_Hant_TW" },
	                new String[] { "zu", "zu_Latn_ZA" },
	                new String[] { "und", "en_Latn_US" },
	                new String[] { "und_AD", "ca_Latn_AD" },
	                new String[] { "und_AE", "ar_Arab_AE" },
	                new String[] { "und_AF", "fa_Arab_AF" },
	                new String[] { "und_AL", "sq_Latn_AL" },
	                new String[] { "und_AM", "hy_Armn_AM" },
	                new String[] { "und_AN", "pap_Latn_AN" },
	                new String[] { "und_AO", "pt_Latn_AO" },
	                new String[] { "und_AR", "es_Latn_AR" },
	                new String[] { "und_Arab", "ar_Arab_EG" },
	                new String[] { "und_Arab_IN", "ur_Arab_IN" },
	                new String[] { "und_Arab_PK", "pa_Arab_PK" },
	                new String[] { "und_Arab_SN", "wo_Arab_SN" },
	                new String[] { "und_Armn", "hy_Armn_AM" },
	                new String[] { "und_AS", "sm_Latn_AS" },
	                new String[] { "und_AT", "de_Latn_AT" },
	                new String[] { "und_AW", "nl_Latn_AW" },
	                new String[] { "und_AX", "sv_Latn_AX" },
	                new String[] { "und_AZ", "az_Latn_AZ" },
	                new String[] { "und_BA", "bs_Latn_BA" },
	                new String[] { "und_BD", "bn_Beng_BD" },
	                new String[] { "und_BE", "nl_Latn_BE" },
	                new String[] { "und_Beng", "bn_Beng_BD" },
	                new String[] { "und_Beng_IN", "as_Beng_IN" },
	                new String[] { "und_BF", "fr_Latn_BF" },
	                new String[] { "und_BG", "bg_Cyrl_BG" },
	                new String[] { "und_BH", "ar_Arab_BH" },
	                new String[] { "und_BI", "rn_Latn_BI" },
	                new String[] { "und_BJ", "fr_Latn_BJ" },
	                new String[] { "und_BN", "ms_Latn_BN" },
	                new String[] { "und_BO", "es_Latn_BO" },
	                new String[] { "und_BR", "pt_Latn_BR" },
	                new String[] { "und_BT", "dz_Tibt_BT" },
	                new String[] { "und_BY", "be_Cyrl_BY" },
	                new String[] { "und_Cans", "iu_Cans_CA" },
	                new String[] { "und_CD", "fr_Latn_CD" },
	                new String[] { "und_CF", "sg_Latn_CF" },
	                new String[] { "und_CG", "ln_Latn_CG" },
	                new String[] { "und_CH", "de_Latn_CH" },
	                new String[] { "und_CI", "fr_Latn_CI" },
	                new String[] { "und_CL", "es_Latn_CL" },
	                new String[] { "und_CM", "fr_Latn_CM" },
	                new String[] { "und_CN", "zh_Hans_CN" },
	                new String[] { "und_CO", "es_Latn_CO" },
	                new String[] { "und_CR", "es_Latn_CR" },
	                new String[] { "und_CU", "es_Latn_CU" },
	                new String[] { "und_CV", "pt_Latn_CV" },
	                new String[] { "und_CY", "el_Grek_CY" },
	                new String[] { "und_Cyrl", "ru_Cyrl_RU" },
	                new String[] { "und_Cyrl_KZ", "kk_Cyrl_KZ" },
	                new String[] { "und_CZ", "cs_Latn_CZ" },
	                new String[] { "und_DE", "de_Latn_DE" },
	                new String[] { "und_Deva", "hi_Deva_IN" },
	                new String[] { "und_DJ", "ar_Arab_DJ" },
	                new String[] { "und_DK", "da_Latn_DK" },
	                new String[] { "und_DO", "es_Latn_DO" },
	                new String[] { "und_DZ", "ar_Arab_DZ" },
	                new String[] { "und_EC", "es_Latn_EC" },
	                new String[] { "und_EE", "et_Latn_EE" },
	                new String[] { "und_EG", "ar_Arab_EG" },
	                new String[] { "und_EH", "ar_Arab_EH" },
	                new String[] { "und_ER", "ti_Ethi_ER" },
	                new String[] { "und_ES", "es_Latn_ES" },
	                new String[] { "und_ET", "am_Ethi_ET" },
	                new String[] { "und_Ethi", "am_Ethi_ET" },
	                new String[] { "und_Ethi_ER", "byn_Ethi_ER" },
	                new String[] { "und_FI", "fi_Latn_FI" },
	                new String[] { "und_FJ", "fj_Latn_FJ" },
	                new String[] { "und_FM", "chk_Latn_FM" },
	                new String[] { "und_FO", "fo_Latn_FO" },
	                new String[] { "und_FR", "fr_Latn_FR" },
	                new String[] { "und_GA", "fr_Latn_GA" },
	                new String[] { "und_GE", "ka_Geor_GE" },
	                new String[] { "und_Geor", "ka_Geor_GE" },
	                new String[] { "und_GF", "fr_Latn_GF" },
	                new String[] { "und_GL", "kl_Latn_GL" },
	                new String[] { "und_GN", "fr_Latn_GN" },
	                new String[] { "und_GP", "fr_Latn_GP" },
	                new String[] { "und_GQ", "fr_Latn_GQ" },
	                new String[] { "und_GR", "el_Grek_GR" },
	                new String[] { "und_Grek", "el_Grek_GR" },
	                new String[] { "und_GT", "es_Latn_GT" },
	                new String[] { "und_GU", "ch_Latn_GU" },
	                new String[] { "und_Gujr", "gu_Gujr_IN" },
	                new String[] { "und_Guru", "pa_Guru_IN" },
	                new String[] { "und_GW", "pt_Latn_GW" },
	                new String[] { "und_Hani", "zh_Hans_CN" },
	                new String[] { "und_Hans", "zh_Hans_CN" },
	                new String[] { "und_Hant", "zh_Hant_HK" },
	                new String[] { "und_Hebr", "he_Hebr_IL" },
	                new String[] { "und_HK", "zh_Hant_HK" },
	                new String[] { "und_HN", "es_Latn_HN" },
	                new String[] { "und_HR", "hr_Latn_HR" },
	                new String[] { "und_HT", "ht_Latn_HT" },
	                new String[] { "und_HU", "hu_Latn_HU" },
	                new String[] { "und_ID", "id_Latn_ID" },
	                new String[] { "und_IL", "he_Hebr_IL" },
	                new String[] { "und_IN", "hi_Deva_IN" },
	                new String[] { "und_IQ", "ar_Arab_IQ" },
	                new String[] { "und_IR", "fa_Arab_IR" },
	                new String[] { "und_IS", "is_Latn_IS" },
	                new String[] { "und_IT", "it_Latn_IT" },
	                new String[] { "und_JO", "ar_Arab_JO" },
	                new String[] { "und_JP", "ja_Jpan_JP" },
	                new String[] { "und_Jpan", "ja_Jpan_JP" },
	                new String[] { "und_KG", "ky_Cyrl_KG" },
	                new String[] { "und_KH", "km_Khmr_KH" },
	                new String[] { "und_Khmr", "km_Khmr_KH" },
	                new String[] { "und_KM", "ar_Arab_KM" },
	                new String[] { "und_Knda", "kn_Knda_IN" },
	                new String[] { "und_Kore", "ko_Kore_KR" },
	                new String[] { "und_KP", "ko_Kore_KP" },
	                new String[] { "und_KR", "ko_Kore_KR" },
	                new String[] { "und_KW", "ar_Arab_KW" },
	                new String[] { "und_KZ", "ru_Cyrl_KZ" },
	                new String[] { "und_LA", "lo_Laoo_LA" },
	                new String[] { "und_Laoo", "lo_Laoo_LA" },
	                new String[] { "und_Latn_ES", "ca_Latn_ES" },
	                new String[] { "und_Latn_ET", "aa_Latn_ET" },
	                new String[] { "und_Latn_GB", "cy_Latn_GB" },
	                new String[] { "und_Latn_GH", "ak_Latn_GH" },
	                new String[] { "und_Latn_IT", "fur_Latn_IT" },
	                new String[] { "und_Latn_NG", "cch_Latn_NG" },
	                new String[] { "und_Latn_TR", "ku_Latn_TR" },
	                new String[] { "und_Latn_ZA", "af_Latn_ZA" },
	                new String[] { "und_LB", "ar_Arab_LB" },
	                new String[] { "und_LI", "de_Latn_LI" },
	                new String[] { "und_LK", "si_Sinh_LK" },
	                new String[] { "und_LS", "st_Latn_LS" },
	                new String[] { "und_LT", "lt_Latn_LT" },
	                new String[] { "und_LU", "fr_Latn_LU" },
	                new String[] { "und_LV", "lv_Latn_LV" },
	                new String[] { "und_LY", "ar_Arab_LY" },
	                new String[] { "und_MA", "ar_Arab_MA" },
	                new String[] { "und_MC", "fr_Latn_MC" },
	                new String[] { "und_MD", "ro_Latn_MD" },
	                new String[] { "und_ME", "sr_Cyrl_ME" },
	                new String[] { "und_MG", "mg_Latn_MG" },
	                new String[] { "und_MH", "mh_Latn_MH" },
	                new String[] { "und_MK", "mk_Cyrl_MK" },
	                new String[] { "und_ML", "fr_Latn_ML" },
	                new String[] { "und_Mlym", "ml_Mlym_IN" },
	                new String[] { "und_MM", "my_Mymr_MM" },
	                new String[] { "und_MN", "mn_Cyrl_MN" },
	                new String[] { "und_MO", "zh_Hant_MO" },
	                new String[] { "und_MQ", "fr_Latn_MQ" },
	                new String[] { "und_MR", "ar_Arab_MR" },
	                new String[] { "und_MT", "mt_Latn_MT" },
	                new String[] { "und_MV", "dv_Thaa_MV" },
	                new String[] { "und_MW", "ny_Latn_MW" },
	                new String[] { "und_MX", "es_Latn_MX" },
	                new String[] { "und_MY", "ms_Latn_MY" },
	                new String[] { "und_Mymr", "my_Mymr_MM" },
	                new String[] { "und_MZ", "pt_Latn_MZ" },
	                new String[] { "und_NC", "fr_Latn_NC" },
	                new String[] { "und_NE", "fr_Latn_NE" },
	                new String[] { "und_NG", "ha_Latn_NG" },
	                new String[] { "und_NI", "es_Latn_NI" },
	                new String[] { "und_NL", "nl_Latn_NL" },
	                new String[] { "und_NO", "nb_Latn_NO" },
	                new String[] { "und_NP", "ne_Deva_NP" },
	                new String[] { "und_NR", "na_Latn_NR" },
	                new String[] { "und_NU", "niu_Latn_NU" },
	                new String[] { "und_OM", "ar_Arab_OM" },
	                new String[] { "und_Orya", "or_Orya_IN" },
	                new String[] { "und_PA", "es_Latn_PA" },
	                new String[] { "und_PE", "es_Latn_PE" },
	                new String[] { "und_PF", "ty_Latn_PF" },
	                new String[] { "und_PG", "tpi_Latn_PG" },
	                new String[] { "und_PH", "fil_Latn_PH" },
	                new String[] { "und_PL", "pl_Latn_PL" },
	                new String[] { "und_PM", "fr_Latn_PM" },
	                new String[] { "und_PR", "es_Latn_PR" },
	                new String[] { "und_PS", "ar_Arab_PS" },
	                new String[] { "und_PT", "pt_Latn_PT" },
	                new String[] { "und_PW", "pau_Latn_PW" },
	                new String[] { "und_PY", "gn_Latn_PY" },
	                new String[] { "und_QA", "ar_Arab_QA" },
	                new String[] { "und_RE", "fr_Latn_RE" },
	                new String[] { "und_RO", "ro_Latn_RO" },
	                new String[] { "und_RS", "sr_Cyrl_RS" },
	                new String[] { "und_RU", "ru_Cyrl_RU" },
	                new String[] { "und_RW", "rw_Latn_RW" },
	                new String[] { "und_SA", "ar_Arab_SA" },
	                new String[] { "und_SD", "ar_Arab_SD" },
	                new String[] { "und_SE", "sv_Latn_SE" },
	                new String[] { "und_SG", "zh_Hans_SG" },
	                new String[] { "und_SI", "sl_Latn_SI" },
	                new String[] { "und_Sinh", "si_Sinh_LK" },
	                new String[] { "und_SJ", "nb_Latn_SJ" },
	                new String[] { "und_SK", "sk_Latn_SK" },
	                new String[] { "und_SM", "it_Latn_SM" },
	                new String[] { "und_SN", "fr_Latn_SN" },
	                new String[] { "und_SO", "so_Latn_SO" },
	                new String[] { "und_SR", "nl_Latn_SR" },
	                new String[] { "und_ST", "pt_Latn_ST" },
	                new String[] { "und_SV", "es_Latn_SV" },
	                new String[] { "und_SY", "ar_Arab_SY" },
	                new String[] { "und_Syrc", "syr_Syrc_SY" },
	                new String[] { "und_Taml", "ta_Taml_IN" },
	                new String[] { "und_TD", "ar_Arab_TD" },
	                new String[] { "und_Telu", "te_Telu_IN" },
	                new String[] { "und_TG", "fr_Latn_TG" },
	                new String[] { "und_TH", "th_Thai_TH" },
	                new String[] { "und_Thaa", "dv_Thaa_MV" },
	                new String[] { "und_Thai", "th_Thai_TH" },
	                new String[] { "und_Tibt", "bo_Tibt_CN" },
	                new String[] { "und_TJ", "tg_Cyrl_TJ" },
	                new String[] { "und_TK", "tkl_Latn_TK" },
	                new String[] { "und_TL", "tet_Latn_TL" },
	                new String[] { "und_TM", "tk_Latn_TM" },
	                new String[] { "und_TN", "ar_Arab_TN" },
	                new String[] { "und_TO", "to_Latn_TO" },
	                new String[] { "und_TR", "tr_Latn_TR" },
	                new String[] { "und_TV", "tvl_Latn_TV" },
	                new String[] { "und_TW", "zh_Hant_TW" },
	                new String[] { "und_UA", "uk_Cyrl_UA" },
	                new String[] { "und_UY", "es_Latn_UY" },
	                new String[] { "und_UZ", "uz_Cyrl_UZ" },
	                new String[] { "und_VA", "la_Latn_VA" },
	                new String[] { "und_VE", "es_Latn_VE" },
	                new String[] { "und_VN", "vi_Latn_VN" },
	                new String[] { "und_VU", "fr_Latn_VU" },
	                new String[] { "und_WF", "fr_Latn_WF" },
	                new String[] { "und_WS", "sm_Latn_WS" },
	                new String[] { "und_YE", "ar_Arab_YE" },
	                new String[] { "und_Yiii", "ii_Yiii_CN" },
	                new String[] { "und_YT", "fr_Latn_YT" } };
	
	        Hashtable tmpMap = new Hashtable();
	        for (int i = 0; i < likelySubtagTable.Length; i++) {
	            ULocale loc = new ULocale(likelySubtagTable[i][1]);
	            ILOG.J2CsMapping.Collections.Collections.Put(tmpMap,likelySubtagTable[i][0],loc);
	        }
	
	         lock (typeof(ULocale)) {
	                    if (_likelySubtagMaximizeMap == null) {
	                        _likelySubtagMaximizeMap = tmpMap;
	                    }
	                }
	    }
	
	    private const String UNDEFINED_LANGUAGE = "und";
	
	    private const String UNDEFINED_SCRIPT = "Zzzz";
	
	    private const String UNDEFINED_REGION = "ZZ";
	
	    /// <exclude/>
	    /// <summary>
	    /// Supply most likely subtags to the given locale
	    /// </summary>
	    ///
	    /// <param name="loc">The input locale</param>
	    /// <returns>A ULocale with most likely subtags filled in.</returns>
	    public static ULocale AddLikelySubtag(ULocale loc) {
	        InitLikelySubtagMaximizeMap();
	
	        // Replace any deprecated subtags with their canonical values.
	        // TODO: not yet implemented.
	
	        // If the tag is grandfathered, then return it.
	        // TODO: not yet implemented.
	
	        // Remove the script Zzzz and the region ZZ if they occur;
	        // change an empty language subtag to 'und'.
	
	        String language = loc.GetLanguage();
	        String script = loc.GetScript();
	        String region = loc.GetCountry();
	
	        if (language.Length == 0) {
	            language = UNDEFINED_LANGUAGE;
	        }
	        if (script.Equals(UNDEFINED_SCRIPT)) {
	            script = EMPTY_STRING;
	        }
	        if (region.Equals(UNDEFINED_REGION)) {
	            region = EMPTY_STRING;
	        }
	
	        // Lookup
	        bool hasScript = script.Length != 0;
	        bool hasRegion = region.Length != 0;
	        ULocale match;
	        bool bDone = false;
	
	        if (hasScript && hasRegion) {
	            // Lookup language_script_region
	            match = (ULocale) ILOG.J2CsMapping.Collections.Collections.Get(_likelySubtagMaximizeMap,language + "_"
	                                + script + "_" + region);
	            if (match != null) {
	                language = match.GetLanguage();
	                script = match.GetScript();
	                region = match.GetCountry();
	                bDone = true;
	            }
	        }
	        if (!bDone && hasScript) {
	            // Lookup language_script
	            match = (ULocale) ILOG.J2CsMapping.Collections.Collections.Get(_likelySubtagMaximizeMap,language + "_"
	                                + script);
	            if (match != null) {
	                language = match.GetLanguage();
	                script = match.GetScript();
	                if (!hasRegion) {
	                    region = match.GetCountry();
	                }
	                bDone = true;
	            }
	        }
	        if (!bDone && hasRegion) {
	            // Lookup language_region
	            match = (ULocale) ILOG.J2CsMapping.Collections.Collections.Get(_likelySubtagMaximizeMap,language + "_"
	                                + region);
	            if (match != null) {
	                language = match.GetLanguage();
	                region = match.GetCountry();
	                if (!hasScript) {
	                    script = match.GetScript();
	                }
	                bDone = true;
	            }
	        }
	        if (!bDone) {
	            // Lookup language
	            match = (ULocale) ILOG.J2CsMapping.Collections.Collections.Get(_likelySubtagMaximizeMap,language);
	            if (match != null) {
	                language = match.GetLanguage();
	                if (!hasScript) {
	                    script = match.GetScript();
	                }
	                if (!hasRegion) {
	                    region = match.GetCountry();
	                }
	                bDone = true;
	            }
	        }
	
	        ULocale result = null;
	
	        if (bDone) {
	            // Check if we need to create a new locale instance
	            if (language.Equals(loc.GetLanguage())
	                    && script.Equals(loc.GetScript())
	                    && region.Equals(loc.GetCountry())) {
	                // Nothing had changed - return the input locale
	                result = loc;
	            } else {
	                StringBuilder buf = new StringBuilder();
	                buf.Append(language);
	                if (script.Length != 0) {
	                    buf.Append(UNDERSCORE);
	                    buf.Append(script);
	                }
	                if (region.Length != 0) {
	                    buf.Append(UNDERSCORE);
	                    buf.Append(region);
	                }
	                String variant = loc.GetVariant();
	                if (variant.Length != 0) {
	                    buf.Append(UNDERSCORE);
	                    buf.Append(variant);
	                }
	                int keywordsIdx = loc.localeID.IndexOf('@');
	                if (keywordsIdx >= 0) {
	                    buf.Append(loc.localeID.Substring(keywordsIdx));
	                }
	                result = new ULocale(buf.ToString());
	            }
	        } else {
	            if (hasScript && hasRegion && language != UNDEFINED_LANGUAGE) {
	                // If non of these succeed, if the original had language, region
	                // and script, return it.
	                result = loc;
	            } else {
	                // Otherwise, signal an error.
	                // TODO: For now, we just return the input locale.
	                result = loc;
	            }
	        }
	
	        return result;
	    }
	
	    /// <exclude/>
	    internal class ULocaleAcceptLanguageQ : IComparable {
	        private double q;
	
	        private double serial;
	
	        public ULocaleAcceptLanguageQ(double theq, int theserial) {
	            q = theq;
	            serial = theserial;
	        }
	
	        public virtual int CompareTo(Object o) {
	            ULocale.ULocaleAcceptLanguageQ  other = (ULocale.ULocaleAcceptLanguageQ ) o;
	            if (q > other.q) { // reverse - to sort in descending order
	                return -1;
	            } else if (q < other.q) {
	                return 1;
	            }
	            if (serial < other.serial) {
	                return -1;
	            } else if (serial > other.serial) {
	                return 1;
	            } else {
	                return 0; // same object
	            }
	        }
	    }
	}
}
