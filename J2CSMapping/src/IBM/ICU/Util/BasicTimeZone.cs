/*
 *******************************************************************************
 * Copyright (C) 2007, International Business Machines Corporation and         *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 */
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:48 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Util {
	
	using ILOG.J2CsMapping.Collections;
	using ILOG.J2CsMapping.Collections.Generics;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	
	/// <summary>
	/// <c>BasicTimeZone</c> is an abstract class extending
	/// <c>TimeZone</c>. This class provides some additional methods to access
	/// time zone transitions and rules. All ICU <c>TimeZone</c> concrete
	/// subclasses extend this class.
	/// </summary>
	///
	/// <seealso cref="T:IBM.ICU.Util.TimeZoneRule"/>
	/// <seealso cref="T:IBM.ICU.Util.TimeZoneTransition"/>
	/// @draft ICU 3.8
	/// @provisional This API might change or be removed in a future release.
	public abstract class BasicTimeZone : TimeZone {
	
	    private const long MILLIS_PER_YEAR = 365 * 24 * 60 * 60 * 1000L;
	
	    /// <summary>
	    /// Gets the first time zone transition after the base time.
	    /// </summary>
	    ///
	    /// <param name="base">The base time.</param>
	    /// <param name="inclusive">Whether the base time is inclusive or not.</param>
	    /// <returns>A <c>Date</c> holding the first time zone transition time
	    /// after the given base time, or null if no time zone transitions
	    /// are available after the base time.</returns>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public abstract TimeZoneTransition GetNextTransition(long bs,
	            bool inclusive);
	
	    /// <summary>
	    /// Gets the last time zone transition before the base time.
	    /// </summary>
	    ///
	    /// <param name="base">The base time.</param>
	    /// <param name="inclusive">Whether the base time is inclusive or not.</param>
	    /// <returns>A <c>Date</c> holding the last time zone transition time
	    /// before the given base time, or null if no time zone transitions
	    /// are available before the base time.</returns>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public abstract TimeZoneTransition GetPreviousTransition(long bs,
	            bool inclusive);
	
	    /// <summary>
	    /// Checks if the time zone has equivalent transitions in the time range.
	    /// This method returns true when all of transition times, from/to standard
	    /// offsets and DST savings used by this time zone match the other in the
	    /// time range.
	    /// </summary>
	    ///
	    /// <param name="tz">The instance of <c>TimeZone</c></param>
	    /// <param name="start">The start time of the evaluated time range (inclusive)</param>
	    /// <param name="end">The end time of the evaluated time range (inclusive)</param>
	    /// <returns>true if the other time zone has the equivalent transitions in the
	    /// time range. When tz is not a <c>BasicTimeZone</c>, this
	    /// method returns false.</returns>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public virtual bool HasEquivalentTransitions(TimeZone tz, long start, long end) {
	        return HasEquivalentTransitions(tz, start, end, false);
	    }
	
	    /// <summary>
	    /// Checks if the time zone has equivalent transitions in the time range.
	    /// This method returns true when all of transition times, from/to standard
	    /// offsets and DST savings used by this time zone match the other in the
	    /// time range.
	    /// </summary>
	    ///
	    /// <param name="tz">The instance of <c>TimeZone</c></param>
	    /// <param name="start">The start time of the evaluated time range (inclusive)</param>
	    /// <param name="end">The end time of the evaluated time range (inclusive)</param>
	    /// <param name="ignoreDstAmount">When true, any transitions with only daylight saving amountchanges will be ignored, except either of them is zero. Forexample, a transition from rawoffset 3:00/dstsavings 1:00 torawoffset 2:00/dstsavings 2:00 is excluded from thecomparison, but a transtion from rawoffset 2:00/dstsavings1:00 to rawoffset 3:00/dstsavings 0:00 is included.</param>
	    /// <returns>true if the other time zone has the equivalent transitions in the
	    /// time range. When tz is not a <c>BasicTimeZone</c>, this
	    /// method returns false.</returns>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public bool HasEquivalentTransitions(TimeZone tz, long start, long end,
	            bool ignoreDstAmount) {
	        if (HasSameRules(tz)) {
	            return true;
	        }
	        if (!(tz  is  BasicTimeZone)) {
	            return false;
	        }
	
	        // Check the offsets at the start time
	        int[] offsets1 = new int[2];
	        int[] offsets2 = new int[2];
	
	        GetOffset(start, false, offsets1);
	        tz.GetOffset(start, false, offsets2);
	
	        if (ignoreDstAmount) {
	            if ((offsets1[0] + offsets1[1] != offsets2[0] + offsets2[1])
	                    || (offsets1[1] != 0 && offsets2[1] == 0)
	                    || (offsets1[1] == 0 && offsets2[1] != 0)) {
	                return false;
	            }
	        } else {
	            if (offsets1[0] != offsets2[0] || offsets1[1] != offsets2[1]) {
	                return false;
	            }
	        }
	
	        // Check transitions in the range
	        long time = start;
	        while (true) {
	            TimeZoneTransition tr1 = GetNextTransition(time, false);
	            TimeZoneTransition tr2 = ((BasicTimeZone) tz).GetNextTransition(
	                    time, false);
	
	            if (ignoreDstAmount) {
	                // Skip a transition which only differ the amount of DST savings
	                if (tr1 != null
	                        && (tr1.GetFrom().GetRawOffset()
	                                + tr1.GetFrom().GetDSTSavings() == tr1.GetTo()
	                                .GetRawOffset() + tr1.GetTo().GetDSTSavings())
	                        && (tr1.GetFrom().GetDSTSavings() != 0 && tr1.GetTo()
	                                .GetDSTSavings() != 0)) {
	                    tr1 = GetNextTransition(tr1.GetTime(), false);
	                }
	                if (tr2 != null
	                        && (tr2.GetFrom().GetRawOffset()
	                                + tr2.GetFrom().GetDSTSavings() == tr2.GetTo()
	                                .GetRawOffset() + tr2.GetTo().GetDSTSavings())
	                        && (tr2.GetFrom().GetDSTSavings() != 0 && tr2.GetTo()
	                                .GetDSTSavings() != 0)) {
	                    tr2 = GetNextTransition(tr2.GetTime(), false);
	                }
	            }
	
	            bool inRange1 = false;
	            bool inRange2 = false;
	            if (tr1 != null) {
	                if (tr1.GetTime() <= end) {
	                    inRange1 = true;
	                }
	            }
	            if (tr2 != null) {
	                if (tr2.GetTime() <= end) {
	                    inRange2 = true;
	                }
	            }
	            if (!inRange1 && !inRange2) {
	                // No more transition in the range
	                break;
	            }
	            if (!inRange1 || !inRange2) {
	                return false;
	            }
	            if (tr1.GetTime() != tr2.GetTime()) {
	                return false;
	            }
	            if (ignoreDstAmount) {
	                if (tr1.GetTo().GetRawOffset() + tr1.GetTo().GetDSTSavings() != tr2
	                        .GetTo().GetRawOffset() + tr2.GetTo().GetDSTSavings()
	                        || tr1.GetTo().GetDSTSavings() != 0
	                        && tr2.GetTo().GetDSTSavings() == 0
	                        || tr1.GetTo().GetDSTSavings() == 0
	                        && tr2.GetTo().GetDSTSavings() != 0) {
	                    return false;
	                }
	            } else {
	                if (tr1.GetTo().GetRawOffset() != tr2.GetTo().GetRawOffset()
	                        || tr1.GetTo().GetDSTSavings() != tr2.GetTo()
	                                .GetDSTSavings()) {
	                    return false;
	                }
	            }
	            time = tr1.GetTime();
	        }
	        return true;
	    }
	
	    /// <summary>
	    /// Gets the array of <c>TimeZoneRule</c> which represents the rule of
	    /// this time zone object. The first element in the result array will be the
	    /// <c>InitialTimeZoneRule</c> instance for the initial rule. The rest
	    /// will be either <c>AnnualTimeZoneRule</c> or
	    /// <c>TimeArrayTimeZoneRule</c> instances representing transitions.
	    /// </summary>
	    ///
	    /// <returns>The array of <c>TimeZoneRule</c> which represents this time
	    /// zone.</returns>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public abstract TimeZoneRule[] GetTimeZoneRules();
	
	    /// <summary>
	    /// Gets the array of <c>TimeZoneRule</c> which represents the rule of
	    /// this time zone object since the specified start time. The first element
	    /// in the result array will be the <c>InitialTimeZoneRule</c> instance
	    /// for the initial rule. The rest will be either
	    /// <c>AnnualTimeZoneRule</c> or <c>TimeArrayTimeZoneRule</c>
	    /// instances representing transitions.
	    /// </summary>
	    ///
	    /// <param name="start">The start time (inclusive).</param>
	    /// <returns>The array of <c>TimeZoneRule</c> which represents this time
	    /// zone since the start time.</returns>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public virtual TimeZoneRule[] GetTimeZoneRules(long start) {
	        TimeZoneRule[] all = GetTimeZoneRules();
	        TimeZoneTransition tzt = GetPreviousTransition(start, true);
	        if (tzt == null) {
	            // No need to filter out rules only applicable to time before the
	            // start
	            return all;
	        }
	
	        BitSet isProcessed = new BitSet(all.Length);
	        IList filteredRules = new LinkedList();
	
	        // Create initial rule
	        TimeZoneRule initial = new InitialTimeZoneRule(tzt.GetTo().GetName(),
	                tzt.GetTo().GetRawOffset(), tzt.GetTo().GetDSTSavings());
	        ILOG.J2CsMapping.Collections.Generics.Collections.Add(filteredRules,initial);
	        isProcessed.Set(0);
	
	        // Mark rules which does not need to be processed
	        for (int i = 1; i < all.Length; i++) {
	            DateTime d = all[i].GetNextStart(start, initial.GetRawOffset(),
	                    initial.GetDSTSavings(), false);
	            if (d == null) {
	                isProcessed.Set(i);
	            }
	        }
	
	        long time = start;
	        bool bFinalStd = false, bFinalDst = false;
	        while (!bFinalStd || !bFinalDst) {
	            tzt = GetNextTransition(time, false);
	            if (tzt == null) {
	                break;
	            }
	            time = tzt.GetTime();
	
	            TimeZoneRule toRule = tzt.GetTo();
	            int ruleIdx = 1;
	            for (; ruleIdx < all.Length; ruleIdx++) {
	                if (all[ruleIdx].Equals(toRule)) {
	                    break;
	                }
	            }
	            if (ruleIdx >= all.Length) {
	                throw new InvalidOperationException("The rule was not found");
	            }
	            if (isProcessed.Get(ruleIdx)) {
	                continue;
	            }
	            if (toRule  is  TimeArrayTimeZoneRule) {
	                TimeArrayTimeZoneRule tar = (TimeArrayTimeZoneRule) toRule;
	
	                // Get the previous raw offset and DST savings before the very
	                // first start time
	                long t = start;
	                while (true) {
	                    tzt = GetNextTransition(t, false);
	                    if (tzt == null) {
	                        break;
	                    }
	                    if (tzt.GetTo().Equals(tar)) {
	                        break;
	                    }
	                    t = tzt.GetTime();
	                }
	                if (tzt != null) {
	                    // Check if the entire start times to be added
	                    DateTime firstStart = tar.GetFirstStart(tzt.GetFrom()
	                            .GetRawOffset(), tzt.GetFrom().GetDSTSavings());
	                    if ((firstStart.Ticks/10000) > start) {
	                        // Just add the rule as is
	                        ILOG.J2CsMapping.Collections.Generics.Collections.Add(filteredRules,tar);
	                    } else {
	                        // Collect transitions after the start time
	                        long[] times = tar.GetStartTimes();
	                        int timeType = tar.GetTimeType();
	                        int idx;
	                        for (idx = 0; idx < times.Length; idx++) {
	                            t = times[idx];
	                            if (timeType == IBM.ICU.Util.DateTimeRule.STANDARD_TIME) {
	                                t -= tzt.GetFrom().GetRawOffset();
	                            }
	                            if (timeType == IBM.ICU.Util.DateTimeRule.WALL_TIME) {
	                                t -= tzt.GetFrom().GetDSTSavings();
	                            }
	                            if (t > start) {
	                                break;
	                            }
	                        }
	                        int asize = times.Length - idx;
	                        if (asize > 0) {
	                            long[] newtimes = new long[asize];
	                            System.Array.Copy((Array)(times),idx,(Array)(newtimes),0,asize);
	                            TimeArrayTimeZoneRule newtar = new TimeArrayTimeZoneRule(
	                                    tar.GetName(), tar.GetRawOffset(),
	                                    tar.GetDSTSavings(), newtimes,
	                                    tar.GetTimeType());
	                            ILOG.J2CsMapping.Collections.Generics.Collections.Add(filteredRules,newtar);
	                        }
	                    }
	                }
	            } else if (toRule  is  AnnualTimeZoneRule) {
	                AnnualTimeZoneRule ar = (AnnualTimeZoneRule) toRule;
	                DateTime firstStart_0 = ar.GetFirstStart(
	                        tzt.GetFrom().GetRawOffset(), tzt.GetFrom()
	                                .GetDSTSavings());
	                if ((firstStart_0.Ticks/10000) == tzt.GetTime()) {
	                    // Just add the rule as is
	                    ILOG.J2CsMapping.Collections.Generics.Collections.Add(filteredRules,ar);
	                } else {
	                    // Calculate the transition year
	                    int[] dfields = new int[6];
	                    IBM.ICU.Impl.Grego.TimeToFields(tzt.GetTime(), dfields);
	                    // Recreate the rule
	                    AnnualTimeZoneRule newar = new AnnualTimeZoneRule(
	                            ar.GetName(), ar.GetRawOffset(),
	                            ar.GetDSTSavings(), ar.GetRule(), dfields[0],
	                            ar.GetEndYear());
	                    ILOG.J2CsMapping.Collections.Generics.Collections.Add(filteredRules,newar);
	                }
	                // Check if this is a final rule
	                if (ar.GetEndYear() == IBM.ICU.Util.AnnualTimeZoneRule.MAX_YEAR) {
	                    // After both final standard and dst rule are processed,
	                    // exit this while loop.
	                    if (ar.GetDSTSavings() == 0) {
	                        bFinalStd = true;
	                    } else {
	                        bFinalDst = true;
	                    }
	                }
	            }
	            isProcessed.Set(ruleIdx);
	        }
	        TimeZoneRule[] rules = new TimeZoneRule[filteredRules.Count];
	        ILOG.J2CsMapping.Collections.Collections.ToArray(filteredRules,rules);
	        return rules;
	    }
	
	    /// <summary>
	    /// Gets the array of <c>TimeZoneRule</c> which represents the rule of
	    /// this time zone object near the specified date. Some applications are not
	    /// capable to handle historic time zone rule changes. Also some applications
	    /// can only handle certain type of rule definitions. This method returns
	    /// either a single <c>InitialTimeZoneRule</c> if this time zone does
	    /// not have any daylight saving time within 1 year from the specified time,
	    /// or a pair of <c>AnnualTimeZoneRule</c> whose rule type is
	    /// <c>DateTimeRule.DOW</c> for date and
	    /// <c>DateTimeRule.WALL_TIME</c> for time with a single
	    /// <c>InitialTimeZoneRule</c> representing the initial time, when this
	    /// time zone observes daylight saving time near the specified date. Thus,
	    /// the result may be only valid for dates around the specified date.
	    /// </summary>
	    ///
	    /// <param name="date">The date to be used for <c>TimeZoneRule</c> extraction.</param>
	    /// <returns>The array of <c>TimeZoneRule</c>, either a single
	    /// <c>InitialTimeZoneRule</c> object, or a pair of
	    /// <c>AnnualTimeZoneRule</c> with a single
	    /// <c>InitialTimeZoneRule</c>. The first element in the array
	    /// is always a <c>InitialTimeZoneRule</c>.</returns>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public TimeZoneRule[] GetSimpleTimeZoneRulesNear(long date) {
	        AnnualTimeZoneRule[] annualRules = null;
	        TimeZoneRule initialRule = null;
	        // Get the next transition
	        TimeZoneTransition tr = GetNextTransition(date, false);
	        if (tr != null) {
	            String initialName = tr.GetFrom().GetName();
	            int initialRaw = tr.GetFrom().GetRawOffset();
	            int initialDst = tr.GetFrom().GetDSTSavings();
	
	            // Check if the next transition is either DST->STD or STD->DST and
	            // within roughly 1 year from the specified date
	            long nextTransitionTime = tr.GetTime();
	            if (((tr.GetFrom().GetDSTSavings() == 0 && tr.GetTo()
	                    .GetDSTSavings() != 0) || (tr.GetFrom().GetDSTSavings() != 0 && tr
	                    .GetTo().GetDSTSavings() == 0))
	                    && date + MILLIS_PER_YEAR > nextTransitionTime) {
	                // Get the next next transition
	                annualRules = new AnnualTimeZoneRule[2];
	                int[] dtfields = IBM.ICU.Impl.Grego.TimeToFields(
	                        nextTransitionTime + tr.GetFrom().GetRawOffset()
	                                + tr.GetFrom().GetDSTSavings(), null);
	                int weekInMonth = IBM.ICU.Impl.Grego.GetDayOfWeekInMonth(dtfields[0],
	                        dtfields[1], dtfields[2]);
	                // Create DOW rule
	                DateTimeRule dtr = new DateTimeRule(dtfields[1], weekInMonth,
	                        dtfields[3], dtfields[5], IBM.ICU.Util.DateTimeRule.WALL_TIME);
	                annualRules[0] = new AnnualTimeZoneRule(tr.GetTo().GetName(),
	                        tr.GetTo().GetRawOffset(), tr.GetTo().GetDSTSavings(),
	                        dtr, dtfields[0], IBM.ICU.Util.AnnualTimeZoneRule.MAX_YEAR);
	
	                tr = GetNextTransition(nextTransitionTime, false);
	                AnnualTimeZoneRule secondRule = null;
	                if (tr != null) {
	                    // Check if the next next transition is either DST->STD or
	                    // STD->DST
	                    // and within roughly 1 year from the next transition
	                    if (((tr.GetFrom().GetDSTSavings() == 0 && tr.GetTo()
	                            .GetDSTSavings() != 0) || (tr.GetFrom()
	                            .GetDSTSavings() != 0 && tr.GetTo().GetDSTSavings() == 0))
	                            && nextTransitionTime + MILLIS_PER_YEAR > tr
	                                    .GetTime()) {
	                        // Generate another DOW rule
	                        dtfields = IBM.ICU.Impl.Grego.TimeToFields(tr.GetTime()
	                                + tr.GetFrom().GetRawOffset()
	                                + tr.GetFrom().GetDSTSavings(), dtfields);
	                        weekInMonth = IBM.ICU.Impl.Grego.GetDayOfWeekInMonth(dtfields[0],
	                                dtfields[1], dtfields[2]);
	                        dtr = new DateTimeRule(dtfields[1], weekInMonth,
	                                dtfields[3], dtfields[5],
	                                IBM.ICU.Util.DateTimeRule.WALL_TIME);
	                        secondRule = new AnnualTimeZoneRule(tr.GetTo()
	                                .GetName(), tr.GetTo().GetRawOffset(), tr
	                                .GetTo().GetDSTSavings(), dtr, dtfields[0] - 1,
	                                IBM.ICU.Util.AnnualTimeZoneRule.MAX_YEAR);
	                        // Make sure this rule can be applied to the specified
	                        // date
	                        DateTime d = secondRule.GetPreviousStart(date, tr.GetFrom()
	                                .GetRawOffset(), tr.GetFrom().GetDSTSavings(),
	                                true);
	                        if (d != null && (d.Ticks/10000) <= date
	                                && initialRaw == tr.GetTo().GetRawOffset()
	                                && initialDst == tr.GetTo().GetDSTSavings()) {
	                            // We can use this rule as the second transition
	                            // rule
	                            annualRules[1] = secondRule;
	                        }
	                    }
	                }
	                if (annualRules[1] == null) {
	                    // Try previous transition
	                    tr = GetPreviousTransition(date, true);
	                    if (tr != null) {
	                        // Check if the previous transition is either DST->STD
	                        // or STD->DST.
	                        // The actual transition time does not matter here.
	                        if ((tr.GetFrom().GetDSTSavings() == 0 && tr.GetTo()
	                                .GetDSTSavings() != 0)
	                                || (tr.GetFrom().GetDSTSavings() != 0 && tr
	                                        .GetTo().GetDSTSavings() == 0)) {
	                            // Generate another DOW rule
	                            dtfields = IBM.ICU.Impl.Grego.TimeToFields(tr.GetTime()
	                                    + tr.GetFrom().GetRawOffset()
	                                    + tr.GetFrom().GetDSTSavings(), dtfields);
	                            weekInMonth = IBM.ICU.Impl.Grego.GetDayOfWeekInMonth(
	                                    dtfields[0], dtfields[1], dtfields[2]);
	                            dtr = new DateTimeRule(dtfields[1], weekInMonth,
	                                    dtfields[3], dtfields[5],
	                                    IBM.ICU.Util.DateTimeRule.WALL_TIME);
	                            secondRule = new AnnualTimeZoneRule(tr.GetTo()
	                                    .GetName(), tr.GetTo().GetRawOffset(), tr
	                                    .GetTo().GetDSTSavings(), dtr,
	                                    annualRules[0].GetStartYear() - 1,
	                                    IBM.ICU.Util.AnnualTimeZoneRule.MAX_YEAR);
	                            // Check if this rule start after the first rule
	                            // after the specified date
	                            DateTime d_0 = secondRule.GetNextStart(date, tr.GetFrom()
	                                    .GetRawOffset(), tr.GetFrom()
	                                    .GetDSTSavings(), false);
	                            if ((d_0.Ticks/10000) > nextTransitionTime) {
	                                // We can use this rule as the second transition
	                                // rule
	                                annualRules[1] = secondRule;
	                            }
	                        }
	                    }
	                }
	                if (annualRules[1] == null) {
	                    // Cannot generate a good pair of AnnualTimeZoneRule
	                    annualRules = null;
	                } else {
	                    // The initial rule should represent the rule before the
	                    // previous transition
	                    initialName = annualRules[0].GetName();
	                    initialRaw = annualRules[0].GetRawOffset();
	                    initialDst = annualRules[0].GetDSTSavings();
	                }
	            }
	            initialRule = new InitialTimeZoneRule(initialName, initialRaw,
	                    initialDst);
	        } else {
	            // Try the previous one
	            tr = GetPreviousTransition(date, true);
	            if (tr != null) {
	                initialRule = new InitialTimeZoneRule(tr.GetTo().GetName(), tr
	                        .GetTo().GetRawOffset(), tr.GetTo().GetDSTSavings());
	            } else {
	                // No transitions in the past. Just use the current offsets
	                int[] offsets = new int[2];
	                GetOffset(date, false, offsets);
	                initialRule = new InitialTimeZoneRule(GetID(), offsets[0],
	                        offsets[1]);
	            }
	        }
	
	        TimeZoneRule[] result = null;
	        if (annualRules == null) {
	            result = new TimeZoneRule[1];
	            result[0] = initialRule;
	        } else {
	            result = new TimeZoneRule[3];
	            result[0] = initialRule;
	            result[1] = annualRules[0];
	            result[2] = annualRules[1];
	        }
	
	        return result;
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// The time type option for standard time used by<see cref="M:IBM.ICU.Util.BasicTimeZone.GetOffsetFromLocal(System.Int64, System.Int32, System.Int32, null)"/>
	    /// </summary>
	    ///
	    public const int LOCAL_STD = 0x01;
	
	    /// <exclude/>
	    /// <summary>
	    /// The time type option for daylight saving time used by<see cref="M:IBM.ICU.Util.BasicTimeZone.GetOffsetFromLocal(System.Int64, System.Int32, System.Int32, null)"/>
	    /// </summary>
	    ///
	    public const int LOCAL_DST = 0x03;
	
	    /// <exclude/>
	    /// <summary>
	    /// The option designate former time to be used by<see cref="M:IBM.ICU.Util.BasicTimeZone.GetOffsetFromLocal(System.Int64, System.Int32, System.Int32, null)"/>
	    /// </summary>
	    ///
	    public const int LOCAL_FORMER = 0x04;
	
	    /// <exclude/>
	    /// <summary>
	    /// The option designate latter time to be used by<see cref="M:IBM.ICU.Util.BasicTimeZone.GetOffsetFromLocal(System.Int64, System.Int32, System.Int32, null)"/>
	    /// </summary>
	    ///
	    public const int LOCAL_LATTER = 0x0C;
	
	    /// <exclude/>
	    /// <summary>
	    /// The bit mask for the time type option used by<see cref="M:IBM.ICU.Util.BasicTimeZone.GetOffsetFromLocal(System.Int64, System.Int32, System.Int32, null)"/>
	    /// </summary>
	    ///
	    protected internal const int STD_DST_MASK = 0x03;
	
	    /// <exclude/>
	    /// <summary>
	    /// The bit mask for the former/latter option used by<see cref="M:IBM.ICU.Util.BasicTimeZone.GetOffsetFromLocal(System.Int64, System.Int32, System.Int32, null)"/>
	    /// </summary>
	    ///
	    protected internal const int FORMER_LATTER_MASK = 0x0C;
	
	    /// <exclude/>
	    /// <summary>
	    /// Get time zone offsets from local wall time.
	    /// </summary>
	    ///
	    public virtual void GetOffsetFromLocal(long date, int nonExistingTimeOpt,
	            int duplicatedTimeOpt, int[] offsets) {
	        throw new InvalidOperationException("Not implemented");
	    }
	
	    /// <summary>
	    /// Protected no arg constructor.
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    protected internal BasicTimeZone() {
	    }
	}
}
