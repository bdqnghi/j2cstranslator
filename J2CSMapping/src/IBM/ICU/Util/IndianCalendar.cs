/*
 *******************************************************************************
 * Copyright (C) 1996-2007, International Business Machines Corporation and    *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 */

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:48 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Util {
	
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.Globalization;
	using System.IO;
	using System.Runtime.CompilerServices;
     using ILOG.J2CsMapping.Util;
	
	/// <summary>
	/// <c>IndianCalendar</c> is a subclass of <c>GregorianCalendar</c>
	/// that numbers years since the birth of the Buddha. This is the civil calendar
	/// which is accepted by government of India as Indian National Calendar. The two
	/// calendars most widely used in India today are the Vikrama calendar followed
	/// in North India and the Shalivahana or Saka calendar which is followed in
	/// South India and Maharashtra.
	/// A variant of the Shalivahana Calendar was reformed and standardized as the
	/// Indian National calendar in 1957.
	/// <p>
	/// Some details of Indian National Calendar (to be implemented) : The Months
	/// Month Length Start date (Gregorian)
	/// ================================================= 1 Chaitra 30/31 March 22/// 2
	/// Vaisakha 31 April 21 3 Jyaistha 31 May 22 4 Asadha 31 June 22 5 Sravana 31
	/// July 23 6 Bhadra 31 August 23 7 Asvina 30 September 23 8 Kartika 30 October
	/// 23 9 Agrahayana 30 November 22 10 Pausa 30 December 22 11 Magha 30 January 21
	/// 12 Phalguna 30 February 20
	/// In leap years, Chaitra has 31 days and starts on March 21 instead. The leap
	/// years of Gregorian calendar and Indian National Calendar are in
	/// synchornization. So When its a leap year in Gregorian calendar then Chaitra
	/// has 31 days.
	/// The Years Years are counted in the Saka Era, which starts its year 0 in 78AD
	/// (by gregorian calendar). So for eg. 9th June 2006 by Gregorian Calendar, is
	/// same as 19th of Jyaistha in 1928 of Saka era by Indian National Calendar.
	/// <p>
	/// The Indian Calendar has only one allowable era: <c>Saka Era</c>. If the
	/// calendar is not in lenient mode (see <c>setLenient</c>), dates before
	/// 1/1/1 Saka Era are rejected with an <c>IllegalArgumentException</c>.
	/// <p>
	/// This class should not be subclassed.
	/// </p>
	/// <p>
	/// IndianCalendar usually should be instantiated using<see cref="M:IBM.ICU.Util.Calendar.GetInstance(IBM.ICU.Util.ULocale)"/> passing in a
	/// <c>ULocale</c> with the tag <c>"@calendar=Indian"</c>.
	/// </p>
	/// </summary>
	///
	/// <seealso cref="T:IBM.ICU.Util.Calendar"/>
	/// <seealso cref="T:IBM.ICU.Util.GregorianCalendar"/>
	/// @draft ICU 3.8
	/// @provisional This API might change or be removed in a future release.
	public class IndianCalendar : Calendar {
	    // jdk1.4.2 serialver
	    private const long serialVersionUID = 3617859668165014834L;
	
	    /// <summary>
	    /// Constant for Chaitra, the 1st month of the Indian year.
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const int CHAITRA = 0;
	
	    /// <summary>
	    /// Constant for Vaisakha, the 2nd month of the Indian year.
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const int VAISAKHA = 1;
	
	    /// <summary>
	    /// Constant for Jyaistha, the 3rd month of the Indian year.
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const int JYAISTHA = 2;
	
	    /// <summary>
	    /// Constant for Asadha, the 4th month of the Indian year.
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const int ASADHA = 3;
	
	    /// <summary>
	    /// Constant for Sravana, the 5th month of the Indian year.
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const int SRAVANA = 4;
	
	    /// <summary>
	    /// Constant for Bhadra, the 6th month of the Indian year.
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const int BHADRA = 5;
	
	    /// <summary>
	    /// Constant for Asvina, the 7th month of the Indian year.
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const int ASVINA = 6;
	
	    /// <summary>
	    /// Constant for Kartika, the 8th month of the Indian year.
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const int KARTIKA = 7;
	
	    /// <summary>
	    /// Constant for Agrahayana, the 9th month of the Indian year.
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const int AGRAHAYANA = 8;
	
	    /// <summary>
	    /// Constant for Pausa, the 10th month of the Indian year.
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const int PAUSA = 9;
	
	    /// <summary>
	    /// Constant for Magha, the 11th month of the Indian year.
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const int MAGHA = 10;
	
	    /// <summary>
	    /// Constant for Phalguna, the 12th month of the Indian year.
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const int PHALGUNA = 11;
	
	    // -------------------------------------------------------------------------
	    // Constructors...
	    // -------------------------------------------------------------------------
	
	    /// <summary>
	    /// Constant for the Indian Era. This is the only allowable <c>ERA</c>
	    /// value for the Indian calendar.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.ERA"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const int IE = 0;
	
	    /// <summary>
	    /// Constructs a <c>IndianCalendar</c> using the current time in the
	    /// default time zone with the default locale.
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public IndianCalendar() : this(IBM.ICU.Util.TimeZone.GetDefault(), IBM.ICU.Util.ULocale.GetDefault()) {
	    }
	
	    /// <summary>
	    /// Constructs a <c>IndianCalendar</c> based on the current time in the
	    /// given time zone with the default locale.
	    /// </summary>
	    ///
	    /// <param name="zone">the given time zone.</param>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public IndianCalendar(TimeZone zone) : this(zone, IBM.ICU.Util.ULocale.GetDefault()) {
	    }
	
	    /// <summary>
	    /// Constructs a <c>IndianCalendar</c> based on the current time in the
	    /// default time zone with the given locale.
	    /// </summary>
	    ///
	    /// <param name="aLocale">the given locale.</param>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
        public IndianCalendar(Locale aLocale)
            : this(IBM.ICU.Util.TimeZone.GetDefault(), aLocale)
        {
	    }
	
	    /// <summary>
	    /// Constructs a <c>IndianCalendar</c> based on the current time in the
	    /// default time zone with the given locale.
	    /// </summary>
	    ///
	    /// <param name="locale">the given ulocale.</param>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public IndianCalendar(ULocale locale) : this(IBM.ICU.Util.TimeZone.GetDefault(), locale) {
	    }
	
	    /// <summary>
	    /// Constructs a <c>IndianCalendar</c> based on the current time in the
	    /// given time zone with the given locale.
	    /// </summary>
	    ///
	    /// <param name="zone">the given time zone.</param>
	    /// <param name="aLocale">the given locale.</param>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
        public IndianCalendar(TimeZone zone, Locale aLocale)
            : base(zone, aLocale)
        {
	        SetTimeInMillis(DateTime.Now.Millisecond);
	    }
	
	    /// <summary>
	    /// Constructs a <c>IndianCalendar</c> based on the current time in the
	    /// given time zone with the given locale.
	    /// </summary>
	    ///
	    /// <param name="zone">the given time zone.</param>
	    /// <param name="locale">the given ulocale.</param>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public IndianCalendar(TimeZone zone, ULocale locale) : base(zone, locale) {
	        SetTimeInMillis(DateTime.Now.Millisecond);
	    }
	
	    /// <summary>
	    /// Constructs a <c>IndianCalendar</c> with the given date set in the
	    /// default time zone with the default locale.
	    /// </summary>
	    ///
	    /// <param name="date">The date to which the new calendar is set.</param>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public IndianCalendar(DateTime date) : base(IBM.ICU.Util.TimeZone.GetDefault(), IBM.ICU.Util.ULocale.GetDefault()) {
	        this.SetTime(date);
	    }
	
	    /// <summary>
	    /// Constructs a <c>IndianCalendar</c> with the given date set in the
	    /// default time zone with the default locale.
	    /// </summary>
	    ///
	    /// <param name="year">The value used to set the calendar's <see cref="M:IBM.ICU.Util.IndianCalendar.YEAR YEAR"/> timefield.</param>
	    /// <param name="month">The value used to set the calendar's <see cref="M:IBM.ICU.Util.IndianCalendar.MONTH MONTH"/> timefield. The value is 0-based. e.g., 0 for January.</param>
	    /// <param name="date">The value used to set the calendar's <see cref="M:IBM.ICU.Util.IndianCalendar.DATE DATE"/> timefield.</param>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public IndianCalendar(int year, int month, int date) : base(IBM.ICU.Util.TimeZone.GetDefault(), IBM.ICU.Util.ULocale.GetDefault()) {
	        this.Set(IBM.ICU.Util.Calendar.YEAR, year);
	        this.Set(IBM.ICU.Util.Calendar.MONTH, month);
	        this.Set(IBM.ICU.Util.Calendar.DATE, date);
	
	    }
	
	    /// <summary>
	    /// Constructs a IndianCalendar with the given date and time set for the
	    /// default time zone with the default locale.
	    /// </summary>
	    ///
	    /// <param name="year">The value used to set the calendar's <see cref="M:IBM.ICU.Util.IndianCalendar.YEAR YEAR"/> timefield.</param>
	    /// <param name="month">The value used to set the calendar's <see cref="M:IBM.ICU.Util.IndianCalendar.MONTH MONTH"/> timefield. The value is 0-based. e.g., 0 for January.</param>
	    /// <param name="date">The value used to set the calendar's <see cref="M:IBM.ICU.Util.IndianCalendar.DATE DATE"/> timefield.</param>
	    /// <param name="hour">The value used to set the calendar's <see cref="M:IBM.ICU.Util.IndianCalendar.HOUR_OF_DAYHOUR_OF_DAY"/> time field.</param>
	    /// <param name="minute">The value used to set the calendar's <see cref="M:IBM.ICU.Util.IndianCalendar.MINUTE MINUTE"/>time field.</param>
	    /// <param name="second">The value used to set the calendar's <see cref="M:IBM.ICU.Util.IndianCalendar.SECOND SECOND"/>time field.</param>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public IndianCalendar(int year, int month, int date, int hour, int minute,
	            int second) : base(IBM.ICU.Util.TimeZone.GetDefault(), IBM.ICU.Util.ULocale.GetDefault()) {
	        this.Set(IBM.ICU.Util.Calendar.YEAR, year);
	        this.Set(IBM.ICU.Util.Calendar.MONTH, month);
	        this.Set(IBM.ICU.Util.Calendar.DATE, date);
	        this.Set(IBM.ICU.Util.Calendar.HOUR_OF_DAY, hour);
	        this.Set(IBM.ICU.Util.Calendar.MINUTE, minute);
	        this.Set(IBM.ICU.Util.Calendar.SECOND, second);
	    }
	
	    // -------------------------------------------------------------------------
	    // The only practical difference from a Gregorian calendar is that years
	    // are numbered since the Saka Era. A couple of overrides will
	    // take care of that....
	    // -------------------------------------------------------------------------
	
	    // Starts in 78 AD,
	    private const int INDIAN_ERA_START = 78;
	
	    // The Indian year starts 80 days later than the Gregorian year.
	    private const int INDIAN_YEAR_START = 80;
	
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    protected internal override int HandleGetExtendedYear() {
	        int year;
	
	        if (NewerField(IBM.ICU.Util.Calendar.EXTENDED_YEAR, IBM.ICU.Util.Calendar.YEAR) == IBM.ICU.Util.Calendar.EXTENDED_YEAR) {
	            year = InternalGet(IBM.ICU.Util.Calendar.EXTENDED_YEAR, 1);
	        } else {
	            // Ignore the era, as there is only one
	            year = InternalGet(IBM.ICU.Util.Calendar.YEAR, 1);
	        }
	
	        return year;
	    }
	
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    protected internal override int HandleGetYearLength(int extendedYear) {
	        return base.HandleGetYearLength(extendedYear);
	    }
	
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    protected internal override int HandleGetMonthLength(int extendedYear, int month) {
	        if (IsGregorianLeap(extendedYear) && month == 0) {
	            return 31;
	        }
	
	        if (month >= 1 && month <= 5) {
	            return 31;
	        }
	
	        return 30;
	    }
	
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    protected internal override void HandleComputeFields(int julianDay) {
	        double jdAtStartOfGregYear;
	        int leapMonth, IndianYear, yday, IndianMonth, IndianDayOfMonth, mday;
	        int[] gregorianDay; // Stores gregorian date corresponding to Julian
	                            // day;
	
	        gregorianDay = JdToGregorian(julianDay); // Gregorian date for Julian
	                                                 // day
	        IndianYear = gregorianDay[0] - INDIAN_ERA_START; // Year in Saka era
	        jdAtStartOfGregYear = GregorianToJD(gregorianDay[0], 1, 1); // JD at
	                                                                    // start of
	                                                                    // Gregorian
	                                                                    // year
	        yday = (int) (julianDay - jdAtStartOfGregYear); // Day number in
	                                                        // Gregorian year
	                                                        // (starting from 0)
	        leapMonth = (IsGregorianLeap(gregorianDay[0])) ? 31 : 30; // Days in
	                                                                // leapMonth
	                                                                // this year
	
	        if (yday < INDIAN_YEAR_START) {
	            // Day is at the end of the preceding Saka year
	            IndianYear -= 1;
	            yday += leapMonth + (31 * 5) + (30 * 3) + 10 + INDIAN_YEAR_START;
	        }
	
	        yday -= INDIAN_YEAR_START;
	        if (yday < leapMonth) {
	            IndianMonth = 0;
	            IndianDayOfMonth = yday + 1;
	        } else {
	            mday = yday - leapMonth;
	            if (mday < (31 * 5)) {
	                IndianMonth = (int) Math.Floor((double)mday / 31) + 1;
	                IndianDayOfMonth = (mday % 31) + 1;
	            } else {
	                mday -= 31 * 5;
	                IndianMonth = (int) Math.Floor((double)mday / 30) + 6;
	                IndianDayOfMonth = (mday % 30) + 1;
	            }
	        }
	
	        InternalSet(IBM.ICU.Util.Calendar.ERA, 0);
	        InternalSet(IBM.ICU.Util.Calendar.EXTENDED_YEAR, IndianYear);
	        InternalSet(IBM.ICU.Util.Calendar.YEAR, IndianYear);
	        InternalSet(IBM.ICU.Util.Calendar.MONTH, IndianMonth);
	        InternalSet(IBM.ICU.Util.Calendar.DAY_OF_MONTH, IndianDayOfMonth);
	    }
	
	    private static readonly int[][] LIMITS = { new int[] { 0, 0, 0, 0 },
	            new int[] { 1, 1, 5000000, 5000000 }, new int[] { 0, 0, 11, 11 },
	            new int[] { 1, 1, 52, 53 }, new int[] { 0, 0, 4, 6 },
	            new int[] { 1, 1, 30, 31 }, new int[] { 1, 1, 365, 366 },
	            new int[] {}, new int[] { -1, -1, 5, 5 }, new int[] {},
	            new int[] {}, new int[] {}, new int[] {}, new int[] {},
	            new int[] {}, new int[] {}, new int[] {},
	            new int[] { -5000001, -5000001, 5000001, 5000001 }, new int[] {},
	            new int[] { -5000000, -5000000, 5000000, 5000000 }, new int[] {},
	            new int[] {} };
	
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    protected internal override int HandleGetLimit(int field, int limitType) {
	        return LIMITS[field][limitType];
	    }
	
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    protected internal override int HandleComputeMonthStart(int year, int month, bool useMonth) {
	
	        // month is 0 based; converting it to 1-based
	        int imonth;
	
	        if (month == 12) {
	            imonth = 1;
	        } else {
	            imonth = month + 1;
	        }
	
	        double jd = IndianToJD(year, imonth, 1);
	
	        return (int) jd;
	    }
	
	    /*
	     * This routine converts an Indian date to the corresponding Julian date"
	     * 
	     * @param year The year in Saka Era according to Indian calendar.
	     * 
	     * @param month The month according to Indian calendar (between 1 to 12)
	     * 
	     * @param date The date in month
	     */
	    private static double IndianToJD(int year, int month, int date) {
	        int leapMonth, gyear, m;
	        double start, jd;
	
	        gyear = year + INDIAN_ERA_START;
	
	        if (IsGregorianLeap(gyear)) {
	            leapMonth = 31;
	            start = GregorianToJD(gyear, 3, 21);
	        } else {
	            leapMonth = 30;
	            start = GregorianToJD(gyear, 3, 22);
	        }
	
	        if (month == 1) {
	            jd = start + (date - 1);
	        } else {
	            jd = start + leapMonth;
	            m = month - 2;
	            m = Math.Min(m,5);
	            jd += m * 31;
	            if (month >= 8) {
	                m = month - 7;
	                jd += m * 30;
	            }
	            jd += date - 1;
	        }
	
	        return jd;
	    }
	
	    /*
	     * The following function is not needed for basic calendar functioning. This
	     * routine converts a gregorian date to the corresponding Julian date"
	     * 
	     * @param year The year in standard Gregorian calendar (AD/BC) .
	     * 
	     * @param month The month according to Gregorian calendar (between 0 to 11)
	     * 
	     * @param date The date in month
	     */
	    private static double GregorianToJD(int year, int month, int date) {
	        double JULIAN_EPOCH = 1721425.5d;
	        double jd = (JULIAN_EPOCH - 1)
	                + (365 * (year - 1))
	                + Math.Floor((double)(year - 1) / 4)
                    + (-Math.Floor((double)(year - 1) / 100))
                    + Math.Floor((double)(year - 1) / 400)
                    + Math.Floor((double)(((367 * month) - 362) / 12)
	                                        + ((month <= 2) ? 0 : ((IsGregorianLeap(year)) ? -1 : -2))
	                                        + date);
	
	        return jd;
	    }
	
	    /*
	     * The following function is not needed for basic calendar functioning. This
	     * routine converts a julian day (jd) to the corresponding date in Gregorian
	     * calendar"
	     * 
	     * @param jd The Julian date in Julian Calendar which is to be converted to
	     * Indian date"
	     */
	    private static int[] JdToGregorian(double jd) {
	        double JULIAN_EPOCH = 1721425.5d;
	        double wjd, depoch, quadricent, dqc, cent, dcent, quad, dquad, yindex, yearday, leapadj;
	        int year, month, day;
	
	        wjd = Math.Floor(jd - 0.5d) + 0.5d;
	        depoch = wjd - JULIAN_EPOCH;
	        quadricent = Math.Floor(depoch / 146097);
	        dqc = depoch % 146097;
	        cent = Math.Floor(dqc / 36524);
	        dcent = dqc % 36524;
	        quad = Math.Floor(dcent / 1461);
	        dquad = dcent % 1461;
	        yindex = Math.Floor(dquad / 365);
	        year = (int) ((quadricent * 400) + (cent * 100) + (quad * 4) + yindex);
	
	        if (!((cent == 4) || (yindex == 4))) {
	            year++;
	        }
	
	        yearday = wjd - GregorianToJD(year, 1, 1);
	        leapadj = ((wjd < GregorianToJD(year, 3, 1)) ? 0
	                : ((IsGregorianLeap(year)) ? 1 : 2));
	
	        month = (int) Math.Floor((((yearday + leapadj) * 12) + 373) / 367);
	        day = (int) (wjd - GregorianToJD(year, month, 1)) + 1;
	
	        int[] julianDate = new int[3];
	
	        julianDate[0] = year;
	        julianDate[1] = month;
	        julianDate[2] = day;
	
	        return julianDate;
	    }
	
	    /*
	     * The following function is not needed for basic calendar functioning. This
	     * routine checks if the Gregorian year is a leap year"
	     * 
	     * @param year The year in Gregorian Calendar
	     */
	    private static bool IsGregorianLeap(int year) {
	        return ((year % 4) == 0)
	                && (!(((year % 100) == 0) && ((year % 400) != 0)));
	    }
	
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public override String GetType() {
	        return "indian";
	    }
	}
}
