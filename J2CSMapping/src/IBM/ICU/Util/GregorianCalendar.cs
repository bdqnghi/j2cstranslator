/*
 * Copyright (C) 1996-2007, International Business Machines
 * Corporation and others.  All Rights Reserved.
 */

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:48 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Util {
	
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.Globalization;
	using System.IO;
	using System.Runtime.CompilerServices;
     using ILOG.J2CsMapping.Util;
     using ILOG.J2CsMapping.Util;
	
	/// <summary>
	/// <c>GregorianCalendar</c> is a concrete subclass of <see cref="T:IBM.ICU.Util.Calendar"/> and
	/// provides the standard calendar used by most of the world.
	/// <p>
	/// The standard (Gregorian) calendar has 2 eras, BC and AD.
	/// <p>
	/// This implementation handles a single discontinuity, which corresponds by
	/// default to the date the Gregorian calendar was instituted (October 15, 1582
	/// in some countries, later in others). The cutover date may be changed by the
	/// caller by calling <c>setGregorianChange()</c>.
	/// <p>
	/// Historically, in those countries which adopted the Gregorian calendar first,
	/// October 4, 1582 was thus followed by October 15, 1582. This calendar models
	/// this correctly. Before the Gregorian cutover, <c>GregorianCalendar</c>
	/// implements the Julian calendar. The only difference between the Gregorian and
	/// the Julian calendar is the leap year rule. The Julian calendar specifies leap
	/// years every four years, whereas the Gregorian calendar omits century years
	/// which are not divisible by 400.
	/// <p>
	/// <c>GregorianCalendar</c> implements <em>proleptic</em> Gregorian and
	/// Julian calendars. That is, dates are computed by extrapolating the current
	/// rules indefinitely far backward and forward in time. As a result,
	/// <c>GregorianCalendar</c> may be used for all years to generate
	/// meaningful and consistent results. However, dates obtained using
	/// <c>GregorianCalendar</c> are historically accurate only from March 1, 4
	/// AD onward, when modern Julian calendar rules were adopted. Before this date,
	/// leap year rules were applied irregularly, and before 45 BC the Julian
	/// calendar did not even exist.
	/// <p>
	/// Prior to the institution of the Gregorian calendar, New Year's Day was March
	/// 25. To avoid confusion, this calendar always uses January 1. A manual
	/// adjustment may be made if desired for dates that are prior to the Gregorian
	/// changeover and which fall between January 1 and March 24.
	/// <p>
	/// Values calculated for the <c>WEEK_OF_YEAR</c> field range from 1 to 53.
	/// Week 1 for a year is the earliest seven day period starting on
	/// <c>getFirstDayOfWeek()</c> that contains at least
	/// <c>getMinimalDaysInFirstWeek()</c> days from that year. It thus depends
	/// on the values of <c>getMinimalDaysInFirstWeek()</c>,
	/// <c>getFirstDayOfWeek()</c>, and the day of the week of January 1. Weeks
	/// between week 1 of one year and week 1 of the following year are numbered
	/// sequentially from 2 to 52 or 53 (as needed).
	/// <p>
	/// For example, January 1, 1998 was a Thursday. If
	/// <c>getFirstDayOfWeek()</c> is <c>MONDAY</c> and
	/// <c>getMinimalDaysInFirstWeek()</c> is 4 (these are the values
	/// reflecting ISO 8601 and many national standards), then week 1 of 1998 starts
	/// on December 29, 1997, and ends on January 4, 1998. If, however,
	/// <c>getFirstDayOfWeek()</c> is <c>SUNDAY</c>, then week 1 of 1998
	/// starts on January 4, 1998, and ends on January 10, 1998; the first three days
	/// of 1998 then are part of week 53 of 1997.
	/// <p>
	/// Values calculated for the <c>WEEK_OF_MONTH</c> field range from 0 or 1
	/// to 4 or 5. Week 1 of a month (the days with <code>WEEK_OF_MONTH =
	/// 1</code>) is the earliest set of at least
	/// <c>getMinimalDaysInFirstWeek()</c> contiguous days in that month,
	/// ending on the day before <c>getFirstDayOfWeek()</c>. Unlike week 1 of a
	/// year, week 1 of a month may be shorter than 7 days, need not start on
	/// <c>getFirstDayOfWeek()</c>, and will not include days of the previous
	/// month. Days of a month before week 1 have a <c>WEEK_OF_MONTH</c> of 0.
	/// <p>
	/// For example, if <c>getFirstDayOfWeek()</c> is <c>SUNDAY</c> and
	/// <c>getMinimalDaysInFirstWeek()</c> is 4, then the first week of January
	/// 1998 is Sunday, January 4 through Saturday, January 10. These days have a
	/// <c>WEEK_OF_MONTH</c> of 1. Thursday, January 1 through Saturday,
	/// January 3 have a <c>WEEK_OF_MONTH</c> of 0. If
	/// <c>getMinimalDaysInFirstWeek()</c> is changed to 3, then January 1
	/// through January 3 have a <c>WEEK_OF_MONTH</c> of 1.
	/// <p>
	/// <strong>Example:</strong> <blockquote>
	/// <pre>
	/// // get the supported ids for GMT-08:00 (Pacific Standard Time)
	/// String[] ids = TimeZone.getAvailableIDs(-8/// 60/// 60/// 1000);
	/// // if no ids were returned, something is wrong. get out.
	/// if (ids.length == 0)
	/// System.exit(0);
	/// // begin output
	/// System.out.println(&quot;Current Time&quot;);
	/// // create a Pacific Standard Time time zone
	/// SimpleTimeZone pdt = new SimpleTimeZone(-8/// 60/// 60/// 1000, ids[0]);
	/// // set up rules for daylight savings time
	/// pdt.setStartRule(Calendar.APRIL, 1, Calendar.SUNDAY, 2/// 60/// 60/// 1000);
	/// pdt.setEndRule(Calendar.OCTOBER, -1, Calendar.SUNDAY, 2/// 60/// 60/// 1000);
	/// // create a GregorianCalendar with the Pacific Daylight time zone
	/// // and the current date and time
	/// Calendar calendar = new GregorianCalendar(pdt);
	/// Date trialTime = new Date();
	/// calendar.setTime(trialTime);
	/// // print out a bunch of interesting things
	/// System.out.println(&quot;ERA: &quot; + calendar.get(Calendar.ERA));
	/// System.out.println(&quot;YEAR: &quot; + calendar.get(Calendar.YEAR));
	/// System.out.println(&quot;MONTH: &quot; + calendar.get(Calendar.MONTH));
	/// System.out.println(&quot;WEEK_OF_YEAR: &quot; + calendar.get(Calendar.WEEK_OF_YEAR));
	/// System.out.println(&quot;WEEK_OF_MONTH: &quot; + calendar.get(Calendar.WEEK_OF_MONTH));
	/// System.out.println(&quot;DATE: &quot; + calendar.get(Calendar.DATE));
	/// System.out.println(&quot;DAY_OF_MONTH: &quot; + calendar.get(Calendar.DAY_OF_MONTH));
	/// System.out.println(&quot;DAY_OF_YEAR: &quot; + calendar.get(Calendar.DAY_OF_YEAR));
	/// System.out.println(&quot;DAY_OF_WEEK: &quot; + calendar.get(Calendar.DAY_OF_WEEK));
	/// System.out.println(&quot;DAY_OF_WEEK_IN_MONTH: &quot;
	/// + calendar.get(Calendar.DAY_OF_WEEK_IN_MONTH));
	/// System.out.println(&quot;AM_PM: &quot; + calendar.get(Calendar.AM_PM));
	/// System.out.println(&quot;HOUR: &quot; + calendar.get(Calendar.HOUR));
	/// System.out.println(&quot;HOUR_OF_DAY: &quot; + calendar.get(Calendar.HOUR_OF_DAY));
	/// System.out.println(&quot;MINUTE: &quot; + calendar.get(Calendar.MINUTE));
	/// System.out.println(&quot;SECOND: &quot; + calendar.get(Calendar.SECOND));
	/// System.out.println(&quot;MILLISECOND: &quot; + calendar.get(Calendar.MILLISECOND));
	/// System.out.println(&quot;ZONE_OFFSET: &quot;
	/// + (calendar.get(Calendar.ZONE_OFFSET) / (60/// 60/// 1000)));
	/// System.out.println(&quot;DST_OFFSET: &quot;
	/// + (calendar.get(Calendar.DST_OFFSET) / (60/// 60/// 1000)));
	/// System.out.println(&quot;Current Time, with hour reset to 3&quot;);
	/// calendar.clear(Calendar.HOUR_OF_DAY); // so doesn't override
	/// calendar.set(Calendar.HOUR, 3);
	/// System.out.println(&quot;ERA: &quot; + calendar.get(Calendar.ERA));
	/// System.out.println(&quot;YEAR: &quot; + calendar.get(Calendar.YEAR));
	/// System.out.println(&quot;MONTH: &quot; + calendar.get(Calendar.MONTH));
	/// System.out.println(&quot;WEEK_OF_YEAR: &quot; + calendar.get(Calendar.WEEK_OF_YEAR));
	/// System.out.println(&quot;WEEK_OF_MONTH: &quot; + calendar.get(Calendar.WEEK_OF_MONTH));
	/// System.out.println(&quot;DATE: &quot; + calendar.get(Calendar.DATE));
	/// System.out.println(&quot;DAY_OF_MONTH: &quot; + calendar.get(Calendar.DAY_OF_MONTH));
	/// System.out.println(&quot;DAY_OF_YEAR: &quot; + calendar.get(Calendar.DAY_OF_YEAR));
	/// System.out.println(&quot;DAY_OF_WEEK: &quot; + calendar.get(Calendar.DAY_OF_WEEK));
	/// System.out.println(&quot;DAY_OF_WEEK_IN_MONTH: &quot;
	/// + calendar.get(Calendar.DAY_OF_WEEK_IN_MONTH));
	/// System.out.println(&quot;AM_PM: &quot; + calendar.get(Calendar.AM_PM));
	/// System.out.println(&quot;HOUR: &quot; + calendar.get(Calendar.HOUR));
	/// System.out.println(&quot;HOUR_OF_DAY: &quot; + calendar.get(Calendar.HOUR_OF_DAY));
	/// System.out.println(&quot;MINUTE: &quot; + calendar.get(Calendar.MINUTE));
	/// System.out.println(&quot;SECOND: &quot; + calendar.get(Calendar.SECOND));
	/// System.out.println(&quot;MILLISECOND: &quot; + calendar.get(Calendar.MILLISECOND));
	/// System.out.println(&quot;ZONE_OFFSET: &quot;
	/// + (calendar.get(Calendar.ZONE_OFFSET) / (60/// 60/// 1000))); // in hours
	/// System.out.println(&quot;DST_OFFSET: &quot;
	/// + (calendar.get(Calendar.DST_OFFSET) / (60/// 60/// 1000))); // in hours
	/// </pre>
	/// </blockquote>
	/// <p>
	/// GregorianCalendar usually should be instantiated using<see cref="M:IBM.ICU.Util.Calendar.GetInstance(IBM.ICU.Util.ULocale)"/> passing in a
	/// <c>ULocale</c> with the tag <c>"@calendar=gregorian"</c>.
	/// </p>
	/// </summary>
	///
	/// <seealso cref="T:IBM.ICU.Util.Calendar"/>
	/// <seealso cref="T:IBM.ICU.Util.TimeZone"/>
	/// @stable ICU 2.0
	public class GregorianCalendar : Calendar {
	    // jdk1.4.2 serialver
	    private const long serialVersionUID = 9199388694351062137L;
	
	    /*
	     * Implementation Notes
	     * 
	     * The Julian day number, as used here, is a modified number which has its
	     * onset at midnight, rather than noon.
	     * 
	     * The epoch is the number of days or milliseconds from some defined
	     * starting point. The epoch for java.util.Date is used here; that is,
	     * milliseconds from January 1, 1970 (Gregorian), midnight UTC. Other epochs
	     * which are used are January 1, year 1 (Gregorian), which is day 1 of the
	     * Gregorian calendar, and December 30, year 0 (Gregorian), which is day 1
	     * of the Julian calendar.
	     * 
	     * We implement the proleptic Julian and Gregorian calendars. This means we
	     * implement the modern definition of the calendar even though the
	     * historical usage differs. For example, if the Gregorian change is set to
	     * new Date(Long.MIN_VALUE), we have a pure Gregorian calendar which labels
	     * dates preceding the invention of the Gregorian calendar in 1582 as if the
	     * calendar existed then.
	     * 
	     * Likewise, with the Julian calendar, we assume a consistent 4-year leap
	     * rule, even though the historical pattern of leap years is irregular,
	     * being every 3 years from 45 BC through 9 BC, then every 4 years from 8 AD
	     * onwards, with no leap years in-between. Thus date computations and
	     * functions such as isLeapYear() are not intended to be historically
	     * accurate.
	     * 
	     * Given that milliseconds are a long, day numbers such as Julian day
	     * numbers, Gregorian or Julian calendar days, or epoch days, are also
	     * longs. Years can fit into an int.
	     */
	
	    // ////////////////
	    // Class Variables
	    // ////////////////
	
	    /// <summary>
	    /// Value of the <c>ERA</c> field indicating the period before the
	    /// common era (before Christ), also known as BCE. The sequence of years at
	    /// the transition from <c>BC</c> to <c>AD</c> is ..., 2 BC, 1
	    /// BC, 1 AD, 2 AD,...
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.ERA"/>
	    /// @stable ICU 2.0
	    public const int BC = 0;
	
	    /// <summary>
	    /// Value of the <c>ERA</c> field indicating the common era (Anno
	    /// Domini), also known as CE. The sequence of years at the transition from
	    /// <c>BC</c> to <c>AD</c> is ..., 2 BC, 1 BC, 1 AD, 2 AD,...
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.ERA"/>
	    /// @stable ICU 2.0
	    public const int AD = 1;
	
	    private const int EPOCH_YEAR = 1970;
	
	    private static readonly int[][] MONTH_COUNT = { new int[] { 31, 31, 0, 0 }, new int[] { 28, 29, 31, 31 },
	            new int[] { 31, 31, 59, 60 }, new int[] { 30, 30, 90, 91 },
	            new int[] { 31, 31, 120, 121 }, new int[] { 30, 30, 151, 152 },
	            new int[] { 31, 31, 181, 182 }, new int[] { 31, 31, 212, 213 },
	            new int[] { 30, 30, 243, 244 }, new int[] { 31, 31, 273, 274 },
	            new int[] { 30, 30, 304, 305 }, new int[] { 31, 31, 334, 335 } };
	
	    /// <summary>
	    /// Old year limits were least max 292269054, max 292278994.
	    /// </summary>
	    ///
	    private static readonly int[][] LIMITS = { new int[] { 0, 0, 1, 1 },
	            new int[] { 1, 1, 5828963, 5838270 }, new int[] { 0, 0, 11, 11 },
	            new int[] { 1, 1, 52, 53 }, new int[] { 0, 0, 4, 6 },
	            new int[] { 1, 1, 28, 31 }, new int[] { 1, 1, 365, 366 },
	            new int[] {}, new int[] { -1, -1, 4, 5 }, new int[] {},
	            new int[] {}, new int[] {}, new int[] {}, new int[] {},
	            new int[] {}, new int[] {}, new int[] {},
	            new int[] { -5838270, -5838270, 5828964, 5838271 }, new int[] {},
	            new int[] { -5838269, -5838269, 5828963, 5838270 }, new int[] {},
	            new int[] {} };
	
	    
	    /// @stable ICU 2.0
	    protected internal override int HandleGetLimit(int field, int limitType) {
	        return LIMITS[field][limitType];
	    }
	
	    // ///////////////////
	    // Instance Variables
	    // ///////////////////
	
	    /// <summary>
	    /// The point at which the Gregorian calendar rules are used, measured in
	    /// milliseconds from the standard epoch. Default is October 15, 1582
	    /// (Gregorian) 00:00:00 UTC or -12219292800000L. For this value, October 4,
	    /// 1582 (Julian) is followed by October 15, 1582 (Gregorian). This
	    /// corresponds to Julian day number 2299161.
	    /// </summary>
	    ///
	    /// @serial
	    private long gregorianCutover;
	
	    /// <summary>
	    /// Julian day number of the Gregorian cutover.
	    /// </summary>
	    ///
	    private int cutoverJulianDay;
	
	    /// <summary>
	    /// The year of the gregorianCutover, with 0 representing 1 BC, -1
	    /// representing 2 BC, etc.
	    /// </summary>
	    ///
	    private int gregorianCutoverYear;
	
	    /// <summary>
	    /// Used by handleComputeJulianDay() and handleComputeMonthStart().
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    protected internal bool isGregorian;
	
	    /// <summary>
	    /// Used by handleComputeJulianDay() and handleComputeMonthStart().
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    protected internal bool invertGregorian;
	
	    // /////////////
	    // Constructors
	    // /////////////
	
	    /// <summary>
	    /// Constructs a default GregorianCalendar using the current time in the
	    /// default time zone with the default locale.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public GregorianCalendar() : this(IBM.ICU.Util.TimeZone.GetDefault(), IBM.ICU.Util.ULocale.GetDefault()) {
	    }
	
	    /// <summary>
	    /// Constructs a GregorianCalendar based on the current time in the given
	    /// time zone with the default locale.
	    /// </summary>
	    ///
	    /// <param name="zone">the given time zone.</param>
	    /// @stable ICU 2.0
	    public GregorianCalendar(TimeZone zone) : this(zone, IBM.ICU.Util.ULocale.GetDefault()) {
	    }
	
	    /// <summary>
	    /// Constructs a GregorianCalendar based on the current time in the default
	    /// time zone with the given locale.
	    /// </summary>
	    ///
	    /// <param name="aLocale">the given locale.</param>
	    /// @stable ICU 2.0
        public GregorianCalendar(Locale aLocale)
            : this(IBM.ICU.Util.TimeZone.GetDefault(), aLocale)
        {
	    }
	
	    /// <summary>
	    /// Constructs a GregorianCalendar based on the current time in the default
	    /// time zone with the given locale.
	    /// </summary>
	    ///
	    /// <param name="locale">the given ulocale.</param>
	    /// @stable ICU 3.2
	    public GregorianCalendar(ULocale locale) : this(IBM.ICU.Util.TimeZone.GetDefault(), locale) {
	    }
	
	    /// <summary>
	    /// Constructs a GregorianCalendar based on the current time in the given
	    /// time zone with the given locale.
	    /// </summary>
	    ///
	    /// <param name="zone">the given time zone.</param>
	    /// <param name="aLocale">the given locale.</param>
	    /// @stable ICU 2.0
        public GregorianCalendar(TimeZone zone, Locale aLocale)
            : base(zone, aLocale)
        {
	        this.gregorianCutover = -12219292800000L;
	        this.cutoverJulianDay = 2299161;
	        this.gregorianCutoverYear = 1582;
	        SetTimeInMillis(DateTime.Now.Millisecond);
	    }
	
	    /// <summary>
	    /// Constructs a GregorianCalendar based on the current time in the given
	    /// time zone with the given locale.
	    /// </summary>
	    ///
	    /// <param name="zone">the given time zone.</param>
	    /// <param name="locale">the given ulocale.</param>
	    /// @stable ICU 3.2
	    public GregorianCalendar(TimeZone zone, ULocale locale) : base(zone, locale) {
	        this.gregorianCutover = -12219292800000L;
	        this.cutoverJulianDay = 2299161;
	        this.gregorianCutoverYear = 1582;
	        SetTimeInMillis(DateTime.Now.Millisecond);
	    }
	
	    /// <summary>
	    /// Constructs a GregorianCalendar with the given date set in the default
	    /// time zone with the default locale.
	    /// </summary>
	    ///
	    /// <param name="year">the value used to set the YEAR time field in the calendar.</param>
	    /// <param name="month">the value used to set the MONTH time field in the calendar.Month value is 0-based. e.g., 0 for January.</param>
	    /// <param name="date">the value used to set the DATE time field in the calendar.</param>
	    /// @stable ICU 2.0
	    public GregorianCalendar(int year, int month, int date) : base(IBM.ICU.Util.TimeZone.GetDefault(), IBM.ICU.Util.ULocale.GetDefault()) {
	        this.gregorianCutover = -12219292800000L;
	        this.cutoverJulianDay = 2299161;
	        this.gregorianCutoverYear = 1582;
	        Set(IBM.ICU.Util.Calendar.ERA, AD);
	        Set(IBM.ICU.Util.Calendar.YEAR, year);
	        Set(IBM.ICU.Util.Calendar.MONTH, month);
	        Set(IBM.ICU.Util.Calendar.DATE, date);
	    }
	
	    /// <summary>
	    /// Constructs a GregorianCalendar with the given date and time set for the
	    /// default time zone with the default locale.
	    /// </summary>
	    ///
	    /// <param name="year">the value used to set the YEAR time field in the calendar.</param>
	    /// <param name="month">the value used to set the MONTH time field in the calendar.Month value is 0-based. e.g., 0 for January.</param>
	    /// <param name="date">the value used to set the DATE time field in the calendar.</param>
	    /// <param name="hour">the value used to set the HOUR_OF_DAY time field in thecalendar.</param>
	    /// <param name="minute">the value used to set the MINUTE time field in the calendar.</param>
	    /// @stable ICU 2.0
	    public GregorianCalendar(int year, int month, int date, int hour, int minute) : base(IBM.ICU.Util.TimeZone.GetDefault(), IBM.ICU.Util.ULocale.GetDefault()) {
	        this.gregorianCutover = -12219292800000L;
	        this.cutoverJulianDay = 2299161;
	        this.gregorianCutoverYear = 1582;
	        Set(IBM.ICU.Util.Calendar.ERA, AD);
	        Set(IBM.ICU.Util.Calendar.YEAR, year);
	        Set(IBM.ICU.Util.Calendar.MONTH, month);
	        Set(IBM.ICU.Util.Calendar.DATE, date);
	        Set(IBM.ICU.Util.Calendar.HOUR_OF_DAY, hour);
	        Set(IBM.ICU.Util.Calendar.MINUTE, minute);
	    }
	
	    /// <summary>
	    /// Constructs a GregorianCalendar with the given date and time set for the
	    /// default time zone with the default locale.
	    /// </summary>
	    ///
	    /// <param name="year">the value used to set the YEAR time field in the calendar.</param>
	    /// <param name="month">the value used to set the MONTH time field in the calendar.Month value is 0-based. e.g., 0 for January.</param>
	    /// <param name="date">the value used to set the DATE time field in the calendar.</param>
	    /// <param name="hour">the value used to set the HOUR_OF_DAY time field in thecalendar.</param>
	    /// <param name="minute">the value used to set the MINUTE time field in the calendar.</param>
	    /// <param name="second">the value used to set the SECOND time field in the calendar.</param>
	    /// @stable ICU 2.0
	    public GregorianCalendar(int year, int month, int date, int hour,
	            int minute, int second) : base(IBM.ICU.Util.TimeZone.GetDefault(), IBM.ICU.Util.ULocale.GetDefault()) {
	        this.gregorianCutover = -12219292800000L;
	        this.cutoverJulianDay = 2299161;
	        this.gregorianCutoverYear = 1582;
	        Set(IBM.ICU.Util.Calendar.ERA, AD);
	        Set(IBM.ICU.Util.Calendar.YEAR, year);
	        Set(IBM.ICU.Util.Calendar.MONTH, month);
	        Set(IBM.ICU.Util.Calendar.DATE, date);
	        Set(IBM.ICU.Util.Calendar.HOUR_OF_DAY, hour);
	        Set(IBM.ICU.Util.Calendar.MINUTE, minute);
	        Set(IBM.ICU.Util.Calendar.SECOND, second);
	    }
	
	    // ///////////////
	    // Public methods
	    // ///////////////

        public override DateTime GetTime()
        {
            return DateUtil.DateFromJavaMillis(GetTimeInMillis()); // new DateTime((GetTimeInMillis() + DateUtil.deltaNET_ICU) * TimeSpan.TicksPerMillisecond);
           /* int year = fields[YEAR];
            int month = fields[MONTH];
            if (month == 0)
                month = 1; // DUMB !
            int day = fields[DAY_OF_MONTH];
            int hour = fields[HOUR];
            int minutes = fields[MINUTE];
            int seconds = fields[SECOND];
            int era = (year > 0)?1:0;
            return new System.Globalization.GregorianCalendar(GregorianCalendarTypes.USEnglish).ToDateTime(year, month, day, hour, minutes, seconds, era);*/
        }

        public override void SetTime(DateTime date)
        {
            /*fields[YEAR] = date.Year;
            fields[MONTH] = date.Minute;
            fields[DAY_OF_MONTH] = date.Day;
            fields[HOUR] = date.Hour;
            fields[MINUTE] = date.Minute;
            fields[SECOND] = date.Second;
           // SetTimeInMillis((date.Ticks / TimeSpan.TicksPerMillisecond));
            areFieldsSet = areAllFieldsSet = areFieldsVirtuallySet = true;
            //ComputeTime();
            isTimeSet = true;*/
            SetTimeInMillis(DateUtil.DotNetDateToJavaMillis(date)); // (date.Ticks / TimeSpan.TicksPerMillisecond) + deltaICU_NET);
        }
	
	    /// <summary>
	    /// Sets the GregorianCalendar change date. This is the point when the switch
	    /// from Julian dates to Gregorian dates occurred. Default is October 15,
	    /// 1582. Previous to this, dates will be in the Julian calendar.
	    /// <p>
	    /// To obtain a pure Julian calendar, set the change date to
	    /// <c>Date(Long.MAX_VALUE)</c>. To obtain a pure Gregorian calendar,
	    /// set the change date to <c>Date(Long.MIN_VALUE)</c>.
	    /// </summary>
	    ///
	    /// <param name="date">the given Gregorian cutover date.</param>
	    /// @stable ICU 2.0
	    public void SetGregorianChange(DateTime date) {
	        gregorianCutover = (date.Ticks/10000);
	
	        // If the cutover has an extreme value, then create a pure
	        // Gregorian or pure Julian calendar by giving the cutover year and
	        // JD extreme values.
	        if (gregorianCutover <= IBM.ICU.Util.Calendar.MIN_MILLIS) {
	            gregorianCutoverYear = cutoverJulianDay = Int32.MinValue;
	        } else if (gregorianCutover >= IBM.ICU.Util.Calendar.MAX_MILLIS) {
	            gregorianCutoverYear = cutoverJulianDay = Int32.MaxValue;
	        } else {
	            // Precompute two internal variables which we use to do the actual
	            // cutover computations. These are the Julian day of the cutover
	            // and the cutover year.
	            cutoverJulianDay = (int) IBM.ICU.Util.Calendar.FloorDivide(gregorianCutover, IBM.ICU.Util.Calendar.ONE_DAY);
	
	            // Convert cutover millis to extended year
	            GregorianCalendar cal = new GregorianCalendar(GetTimeZone());
	            cal.SetTime(date);
	            gregorianCutoverYear = cal.Get(IBM.ICU.Util.Calendar.EXTENDED_YEAR);
	        }
	    }
	
	    /// <summary>
	    /// Gets the Gregorian Calendar change date. This is the point when the
	    /// switch from Julian dates to Gregorian dates occurred. Default is October
	    /// 15, 1582. Previous to this, dates will be in the Julian calendar.
	    /// </summary>
	    ///
	    /// <returns>the Gregorian cutover date for this calendar.</returns>
	    /// @stable ICU 2.0
	    public DateTime GetGregorianChange() {
	        return DateUtil.DateFromJavaMillis(gregorianCutover);
	    }
	
	    /// <summary>
	    /// Determines if the given year is a leap year. Returns true if the given
	    /// year is a leap year.
	    /// </summary>
	    ///
	    /// <param name="year">the given year.</param>
	    /// <returns>true if the given year is a leap year; false otherwise.</returns>
	    /// @stable ICU 2.0
	    public bool IsLeapYear(int year) {
	        return (year >= gregorianCutoverYear) ? ((year % 4 == 0) && ((year % 100 != 0) || (year % 400 == 0)))
	                : // Gregorian
	                (year % 4 == 0); // Julian
	    }
	
	    /// <summary>
	    /// Returns true if the given Calendar object is equivalent to this one.
	    /// Calendar override.
	    /// </summary>
	    ///
	    /// <param name="other">the Calendar to be compared with this Calendar</param>
	    /// @stable ICU 2.4
	    public override bool IsEquivalentTo(Calendar other) {
	        return base.IsEquivalentTo(other)
	                && gregorianCutover == ((GregorianCalendar) other).gregorianCutover;
	    }
	
	    /// <summary>
	    /// Override hashCode. Generates the hash code for the GregorianCalendar
	    /// object
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public override int GetHashCode() {
	        return base.GetHashCode() ^ (int) gregorianCutover;
	    }
	
	    /// <summary>
	    /// Roll a field by a signed amount.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public override void Roll(int field, int amount) {
	
	        switch (field) {
	        case IBM.ICU.Util.Calendar.WEEK_OF_YEAR: {
	            // Unlike WEEK_OF_MONTH, WEEK_OF_YEAR never shifts the day of the
	            // week. Also, rolling the week of the year can have seemingly
	            // strange effects simply because the year of the week of year
	            // may be different from the calendar year. For example, the
	            // date Dec 28, 1997 is the first day of week 1 of 1998 (if
	            // weeks start on Sunday and the minimal days in first week is
	            // <= 3).
	            int woy = Get(IBM.ICU.Util.Calendar.WEEK_OF_YEAR);
	            // Get the ISO year, which matches the week of year. This
	            // may be one year before or after the calendar year.
	            int isoYear = Get(IBM.ICU.Util.Calendar.YEAR_WOY);
	            int isoDoy = InternalGet(IBM.ICU.Util.Calendar.DAY_OF_YEAR);
	            if (InternalGet(IBM.ICU.Util.Calendar.MONTH) == IBM.ICU.Util.Calendar.JANUARY) {
	                if (woy >= 52) {
	                    isoDoy += HandleGetYearLength(isoYear);
	                }
	            } else {
	                if (woy == 1) {
	                    isoDoy -= HandleGetYearLength(isoYear - 1);
	                }
	            }
	            woy += amount;
	            // Do fast checks to avoid unnecessary computation:
	            if (woy < 1 || woy > 52) {
	                // Determine the last week of the ISO year.
	                // We do this using the standard formula we use
	                // everywhere in this file. If we can see that the
	                // days at the end of the year are going to fall into
	                // week 1 of the next year, we drop the last week by
	                // subtracting 7 from the last day of the year.
	                int lastDoy = HandleGetYearLength(isoYear);
	                int lastRelDow = (lastDoy - isoDoy + InternalGet(IBM.ICU.Util.Calendar.DAY_OF_WEEK) - GetFirstDayOfWeek()) % 7;
	                if (lastRelDow < 0)
	                    lastRelDow += 7;
	                if ((6 - lastRelDow) >= GetMinimalDaysInFirstWeek())
	                    lastDoy -= 7;
	                int lastWoy = WeekNumber(lastDoy, lastRelDow + 1);
	                woy = ((woy + lastWoy - 1) % lastWoy) + 1;
	            }
	            Set(IBM.ICU.Util.Calendar.WEEK_OF_YEAR, woy);
	            Set(IBM.ICU.Util.Calendar.YEAR, isoYear); // Why not YEAR_WOY? - Alan 11/6/00
	            return;
	        }
	
	        default:
	            base.Roll(field,amount);
	            return;
	        }
	    }
	
	    /// <summary>
	    /// Return the minimum value that this field could have, given the current
	    /// date. For the Gregorian calendar, this is the same as getMinimum() and
	    /// getGreatestMinimum().
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public override int GetActualMinimum(int field) {
	        return GetMinimum(field);
	    }
	
	    /// <summary>
	    /// Return the maximum value that this field could have, given the current
	    /// date. For example, with the date "Feb 3, 1997" and the DAY_OF_MONTH
	    /// field, the actual maximum would be 28; for "Feb 3, 1996" it s 29.
	    /// Similarly for a Hebrew calendar, for some years the actual maximum for
	    /// MONTH is 12, and for others 13.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public override int GetActualMaximum(int field) {
	        /*
	         * It is a known limitation that the code here (and in getActualMinimum)
	         * won't behave properly at the extreme limits of GregorianCalendar's
	         * representable range (except for the code that handles the YEAR
	         * field). That's because the ends of the representable range are at odd
	         * spots in the year. For calendars with the default Gregorian cutover,
	         * these limits are Sun Dec 02 16:47:04 GMT 292269055 BC to Sun Aug 17
	         * 07:12:55 GMT 292278994 AD, somewhat different for non-GMT zones. As a
	         * result, if the calendar is set to Aug 1 292278994 AD, the actual
	         * maximum of DAY_OF_MONTH is 17, not 30. If the date is Mar 31 in that
	         * year, the actual maximum month might be Jul, whereas is the date is
	         * Mar 15, the actual maximum might be Aug -- depending on the precise
	         * semantics that are desired. Similar considerations affect all fields.
	         * Nonetheless, this effect is sufficiently arcane that we permit it,
	         * rather than complicating the code to handle such intricacies. - liu
	         * 8/20/98
	         * 
	         * UPDATE: No longer true, since we have pulled in the limit values on
	         * the year. - Liu 11/6/00
	         */
	
	        switch (field) {
	
	        case IBM.ICU.Util.Calendar.YEAR:
	            /*
	             * The year computation is no different, in principle, from the
	             * others, however, the range of possible maxima is large. In
	             * addition, the way we know we've exceeded the range is different.
	             * For these reasons, we use the special case code below to handle
	             * this field.
	             * 
	             * The actual maxima for YEAR depend on the type of calendar:
	             * 
	             * Gregorian = May 17, 292275056 BC - Aug 17, 292278994 AD Julian =
	             * Dec 2, 292269055 BC - Jan 3, 292272993 AD Hybrid = Dec 2,
	             * 292269055 BC - Aug 17, 292278994 AD
	             * 
	             * We know we've exceeded the maximum when either the month, date,
	             * time, or era changes in response to setting the year. We don't
	             * check for month, date, and time here because the year and era are
	             * sufficient to detect an invalid year setting. NOTE: If code is
	             * added to check the month and date in the future for some reason,
	             * Feb 29 must be allowed to shift to Mar 1 when setting the year.
	             */
	        {
	            Calendar cal = (Calendar) Clone();
	            cal.SetLenient(true);
	
	            int era = cal.Get(IBM.ICU.Util.Calendar.ERA);
	            DateTime d = cal.GetTime();
	
	            /*
	             * Perform a binary search, with the invariant that lowGood is a
	             * valid year, and highBad is an out of range year.
	             */
	            int lowGood = LIMITS[IBM.ICU.Util.Calendar.YEAR][1];
	            int highBad = LIMITS[IBM.ICU.Util.Calendar.YEAR][2] + 1;
	            while ((lowGood + 1) < highBad) {
	                int y = (lowGood + highBad) / 2;
	                cal.Set(IBM.ICU.Util.Calendar.YEAR, y);
	                if (cal.Get(IBM.ICU.Util.Calendar.YEAR) == y && cal.Get(IBM.ICU.Util.Calendar.ERA) == era) {
	                    lowGood = y;
	                } else {
	                    highBad = y;
	                    cal.SetTime(d); // Restore original fields
	                }
	            }
	
	            return lowGood;
	        }
	
	        default:
	            return base.GetActualMaximum(field);
	        }
	    }
	
	    // ////////////////////
	    // Proposed public API
	    // ////////////////////
	
	    /// <summary>
	    /// Return true if the current time for this Calendar is in Daylignt Savings
	    /// Time.
	    /// </summary>
	    ///
	    internal bool InDaylightTime() {
	        if (!GetTimeZone().UseDaylightTime())
	            return false;
	        Complete(); // Force update of DST_OFFSET field
	        return InternalGet(IBM.ICU.Util.Calendar.DST_OFFSET) != 0;
	    }
	
	    // ///////////////////
	    // Calendar framework
	    // ///////////////////
	
	    
	    /// @stable ICU 2.0
	    protected internal override int HandleGetMonthLength(int extendedYear, int month) {
	        // If the month is out of range, adjust it into range, and
	        // modify the extended year value accordingly.
	        if (month < 0 || month > 11) {
	            int[] rem = new int[1];
	            extendedYear += IBM.ICU.Util.Calendar.FloorDivide(month, 12, rem);
	            month = rem[0];
	        }
	
	        return MONTH_COUNT[month][(IsLeapYear(extendedYear)) ? 1 : 0];
	    }
	
	    
	    /// @stable ICU 2.0
	    protected internal override int HandleGetYearLength(int eyear) {
	        return (IsLeapYear(eyear)) ? 366 : 365;
	    }
	
	    // ///////////////////////////
	    // Time => Fields computation
	    // ///////////////////////////
	
	    /// <summary>
	    /// Override Calendar to compute several fields specific to the hybrid
	    /// Gregorian-Julian calendar system. These are:
	    /// <ul>
	    /// <li>ERA
	    /// <li>YEAR
	    /// <li>MONTH
	    /// <li>DAY_OF_MONTH
	    /// <li>DAY_OF_YEAR
	    /// <li>EXTENDED_YEAR
	    /// </ul>
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    protected internal override void HandleComputeFields(int julianDay) {
	        int eyear, month, dayOfMonth, dayOfYear;
	
	        if (julianDay >= cutoverJulianDay) {
	            month = GetGregorianMonth();
	            dayOfMonth = GetGregorianDayOfMonth();
	            dayOfYear = GetGregorianDayOfYear();
	            eyear = GetGregorianYear();
	        } else {
	            // The Julian epoch day (not the same as Julian Day)
	            // is zero on Saturday December 30, 0 (Gregorian).
	            long julianEpochDay = julianDay - (IBM.ICU.Util.Calendar.JAN_1_1_JULIAN_DAY - 2);
	            eyear = (int) IBM.ICU.Util.Calendar.FloorDivide(4 * julianEpochDay + 1464, 1461);
	
	            // Compute the Julian calendar day number for January 1, eyear
	            long january1 = 365 * (eyear - 1) + IBM.ICU.Util.Calendar.FloorDivide(eyear - 1, 4);
	            dayOfYear = (int) (julianEpochDay - january1); // 0-based
	
	            // Julian leap years occurred historically every 4 years starting
	            // with 8 AD. Before 8 AD the spacing is irregular; every 3 years
	            // from 45 BC to 9 BC, and then none until 8 AD. However, we don't
	            // implement this historical detail; instead, we implement the
	            // computatinally cleaner proleptic calendar, which assumes
	            // consistent 4-year cycles throughout time.
	            bool isLeap = ((eyear & 0x3) == 0); // equiv. to (eyear%4 == 0)
	
	            // Common Julian/Gregorian calculation
	            int correction = 0;
	            int march1 = (isLeap) ? 60 : 59; // zero-based DOY for March 1
	            if (dayOfYear >= march1) {
	                correction = (isLeap) ? 1 : 2;
	            }
	            month = (12 * (dayOfYear + correction) + 6) / 367; // zero-based
	                                                               // month
	            dayOfMonth = dayOfYear - MONTH_COUNT[month][(isLeap) ? 3 : 2] + 1; // one-based
	                                                                             // DOM
	            ++dayOfYear;
	        }
	        InternalSet(IBM.ICU.Util.Calendar.MONTH, month);
	        InternalSet(IBM.ICU.Util.Calendar.DAY_OF_MONTH, dayOfMonth);
	        InternalSet(IBM.ICU.Util.Calendar.DAY_OF_YEAR, dayOfYear);
	        InternalSet(IBM.ICU.Util.Calendar.EXTENDED_YEAR, eyear);
	        int era = AD;
	        if (eyear < 1) {
	            era = BC;
	            eyear = 1 - eyear;
	        }
	        InternalSet(IBM.ICU.Util.Calendar.ERA, era);
	        InternalSet(IBM.ICU.Util.Calendar.YEAR, eyear);
	    }
	
	    // ///////////////////////////
	    // Fields => Time computation
	    // ///////////////////////////
	
	    
	    /// @stable ICU 2.0
	    protected internal override int HandleGetExtendedYear() {
	        int year;
	        if (NewerField(IBM.ICU.Util.Calendar.EXTENDED_YEAR, IBM.ICU.Util.Calendar.YEAR) == IBM.ICU.Util.Calendar.EXTENDED_YEAR) {
	            year = InternalGet(IBM.ICU.Util.Calendar.EXTENDED_YEAR, EPOCH_YEAR);
	        } else {
	            // The year defaults to the epoch start, the era to AD
	            int era = InternalGet(IBM.ICU.Util.Calendar.ERA, AD);
	            if (era == BC) {
	                year = 1 - InternalGet(IBM.ICU.Util.Calendar.YEAR, 1); // Convert to extended year
	            } else {
	                year = InternalGet(IBM.ICU.Util.Calendar.YEAR, EPOCH_YEAR);
	            }
	        }
	        return year;
	    }
	
	    
	    /// @stable ICU 2.0
	    protected internal override int HandleComputeJulianDay(int bestField) {
	
	        invertGregorian = false;
	
	        int jd = base.HandleComputeJulianDay(bestField);
	
	        // The following check handles portions of the cutover year BEFORE the
	        // cutover itself happens.
	        if (isGregorian != (jd >= cutoverJulianDay)) {
	            invertGregorian = true;
	            jd = base.HandleComputeJulianDay(bestField);
	        }
	
	        return jd;
	    }
	
	    /// <summary>
	    /// Return JD of start of given month/year
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    protected internal override int HandleComputeMonthStart(int eyear, int month, bool useMonth) {
	
	        // If the month is out of range, adjust it into range, and
	        // modify the extended year value accordingly.
	        if (month < 0 || month > 11) {
	            int[] rem = new int[1];
	            eyear += IBM.ICU.Util.Calendar.FloorDivide(month, 12, rem);
	            month = rem[0];
	        }
	
	        bool isLeap = eyear % 4 == 0;
	        int y = eyear - 1;
	        int julianDay = 365 * y + IBM.ICU.Util.Calendar.FloorDivide(y, 4) + (IBM.ICU.Util.Calendar.JAN_1_1_JULIAN_DAY - 3);
	
	        isGregorian = (eyear >= gregorianCutoverYear);
	        if (invertGregorian) {
	            isGregorian = !isGregorian;
	        }
	        if (isGregorian) {
	            isLeap = isLeap && ((eyear % 100 != 0) || (eyear % 400 == 0));
	            // Add 2 because Gregorian calendar starts 2 days after
	            // Julian calendar
	            julianDay += IBM.ICU.Util.Calendar.FloorDivide(y, 400) - IBM.ICU.Util.Calendar.FloorDivide(y, 100) + 2;
	        }
	
	        // At this point julianDay indicates the day BEFORE the first
	        // day of January 1, <eyear> of either the Julian or Gregorian
	        // calendar.
	
	        if (month != 0) {
	            julianDay += MONTH_COUNT[month][(isLeap) ? 3 : 2];
	        }
	
	        return julianDay;
	    }
	
	    /// <summary>
	    /// Return the current Calendar type.
	    /// </summary>
	    ///
	    /// <returns>type of calendar</returns>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public override String GetType() {
	        return "gregorian";
	    }
	
	    /*
	     * private static CalendarFactory factory; public static CalendarFactory
	     * factory() { if (factory == null) { factory = new CalendarFactory() {
	     * public Calendar create(TimeZone tz, ULocale loc) { return new
	     * GregorianCalendar(tz, loc); }
	     * 
	     * public String factoryName() { return "Gregorian"; } }; } return factory;
	     * }
	     */
	}
}
