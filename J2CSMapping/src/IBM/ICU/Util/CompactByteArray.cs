/*
 *******************************************************************************
 * Copyright (C) 1996-2007, International Business Machines Corporation and    *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 */
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:47 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Util {
	
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	
	
	/// <exclude/>
	/// <summary>
	/// class CompactATypeArray : use only on primitive data types Provides a compact
	/// way to store information that is indexed by Unicode values, such as character
	/// properties, types, keyboard values, etc.This is very useful when you have a
	/// block of Unicode data that contains significant values while the rest of the
	/// Unicode data is unused in the application or when you have a lot of
	/// redundance, such as where all 21,000 Han ideographs have the same value.
	/// However, lookup is much faster than a hash table. A compact array of any
	/// primitive data type serves two purposes:
	/// <UL type = round>
	/// <LI>Fast access of the indexed values.
	/// <LI>Smaller memory footprint.
	/// </UL>
	/// A compact array is composed of a index array and value array. The index array
	/// contains the indicies of Unicode characters to the value array.
	/// </summary>
	///
	/// <seealso cref="T:IBM.ICU.Util.CompactCharArray"/>
	public sealed class CompactByteArray : ICloneable {
	
	    /// <exclude/>
	    /// <summary>
	    /// The total number of Unicode characters.
	    /// </summary>
	    ///
	    public const int UNICODECOUNT = 65536;
	
	    /// <exclude/>
	    /// <summary>
	    /// Default constructor for CompactByteArray, the default value of the
	    /// compact array is 0.
	    /// </summary>
	    ///
	    public CompactByteArray() : this((sbyte)0) {
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Constructor for CompactByteArray.
	    /// </summary>
	    ///
	    /// <param name="defaultValue">the default value of the compact array.</param>
	    public CompactByteArray(sbyte defaultValue) {
	        int i;
	        values = new sbyte[UNICODECOUNT];
	        indices = new char[INDEXCOUNT];
	        hashes = new int[INDEXCOUNT];
	        for (i = 0; i < UNICODECOUNT; ++i) {
	            values[i] = defaultValue;
	        }
	        for (i = 0; i < INDEXCOUNT; ++i) {
	            indices[i] = (char) (i << BLOCKSHIFT);
	            hashes[i] = 0;
	        }
	        isCompact = false;
	
	        this.defaultValue = defaultValue;
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Constructor for CompactByteArray.
	    /// </summary>
	    ///
	    /// <param name="indexArray">the indicies of the compact array.</param>
	    /// <param name="newValues">the values of the compact array.</param>
	    /// <exception cref="IllegalArgumentException">If the index is out of range.</exception>
	    public CompactByteArray(char[] indexArray, sbyte[] newValues) {
	        int i;
	        if (indexArray.Length != INDEXCOUNT)
	            throw new ArgumentException("Index out of bounds.");
	        for (i = 0; i < INDEXCOUNT; ++i) {
	            char index = indexArray[i];
	            if ((index < 0) || (index >= newValues.Length + BLOCKCOUNT))
	                throw new ArgumentException("Index out of bounds.");
	        }
	        indices = indexArray;
	        values = newValues;
	        isCompact = true;
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Constructor for CompactByteArray.
	    /// </summary>
	    ///
	    /// <param name="indexArray">the RLE-encoded indicies of the compact array.</param>
	    /// <param name="valueArray">the RLE-encoded values of the compact array.</param>
	    /// <exception cref="IllegalArgumentException">if the index or value array is the wrong size.</exception>
	    public CompactByteArray(String indexArray, String valueArray) : this(IBM.ICU.Impl.Utility.RLEStringToCharArray(indexArray), IBM.ICU.Impl.Utility.RLEStringToByteArray(valueArray)) {
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Get the mapped value of a Unicode character.
	    /// </summary>
	    ///
	    /// <param name="index">the character to get the mapped value with</param>
	    /// <returns>the mapped value of the given character</returns>
	    public sbyte ElementAt(char index) {
	        return (values[(indices[index >> BLOCKSHIFT] & 0xFFFF)
	                + (index & BLOCKMASK)]);
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Set a new value for a Unicode character. Set automatically expands the
	    /// array if it is compacted.
	    /// </summary>
	    ///
	    /// <param name="index">the character to set the mapped value with</param>
	    /// <param name="value">the new mapped value</param>
	    public void SetElementAt(char index, sbyte value_ren) {
	        if (isCompact)
	            Expand();
	        values[(int) index] = value_ren;
	        TouchBlock(index >> BLOCKSHIFT, value_ren);
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Set new values for a range of Unicode character.
	    /// </summary>
	    ///
	    /// <param name="start">the starting offset of the range</param>
	    /// <param name="end">the ending offset of the range</param>
	    /// <param name="value">the new mapped value</param>
	    public void SetElementAt(char start, char end, sbyte value_ren) {
	        int i;
	        if (isCompact) {
	            Expand();
	        }
	        for (i = start; i <= end; ++i) {
	            values[i] = value_ren;
	            TouchBlock(i >> BLOCKSHIFT, value_ren);
	        }
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Compact the array.
	    /// </summary>
	    ///
	    public void Compact() {
	        Compact(false);
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Compact the array.
	    /// </summary>
	    ///
	    public void Compact(bool exhaustive) {
	        if (!isCompact) {
	            int limitCompacted = 0;
	            int iBlockStart = 0;
	            char iUntouched = (char) (0xFFFF);
	
	            for (int i = 0; i < indices.Length; ++i, iBlockStart += BLOCKCOUNT) {
	                indices[i] = ((Char)0xFFFF);
	                bool touched = BlockTouched(i);
	                if (!touched && iUntouched != 0xFFFF) {
	                    // If no values in this block were set, we can just set its
	                    // index to be the same as some other block with no values
	                    // set, assuming we've seen one yet.
	                    indices[i] = iUntouched;
	                } else {
	                    int jBlockStart = 0;
	                    int j = 0;
	                    for (j = 0; j < limitCompacted; ++j, jBlockStart += BLOCKCOUNT) {
	                        if (hashes[i] == hashes[j]
	                                && ArrayRegionMatches(values, iBlockStart,
	                                        values, jBlockStart, BLOCKCOUNT)) {
	                            indices[i] = (char) jBlockStart;
	                            break;
	                        }
	                    }
	                    if (indices[i] == 0xFFFF) {
	                        // we didn't match, so copy & update
	                        System.Array.Copy((Array)(values),iBlockStart,(Array)(values),jBlockStart,BLOCKCOUNT);
	                        indices[i] = (char) jBlockStart;
	                        hashes[j] = hashes[i];
	                        ++limitCompacted;
	
	                        if (!touched) {
	                            // If this is the first untouched block we've seen,
	                            // remember its index.
	                            iUntouched = (char) jBlockStart;
	                        }
	                    }
	                }
	            }
	            // we are done compacting, so now make the array shorter
	            int newSize = limitCompacted * BLOCKCOUNT;
	            sbyte[] result = new sbyte[newSize];
	            System.Array.Copy((Array)(values),0,(Array)(result),0,newSize);
	            values = result;
	            isCompact = true;
	            hashes = null;
	        }
	    }
	
	    /// <summary>
	    /// Convenience utility to compare two arrays of doubles.
	    /// </summary>
	    ///
	    /// <param name="len">the length to compare. The start indices and start+len must bevalid.</param>
	    static internal bool ArrayRegionMatches(sbyte[] source, int sourceStart,
	            sbyte[] target, int targetStart, int len) {
	        int sourceEnd = sourceStart + len;
	        int delta = targetStart - sourceStart;
	        for (int i = sourceStart; i < sourceEnd; i++) {
	            if (source[i] != target[i + delta])
	                return false;
	        }
	        return true;
	    }
	
	    /// <summary>
	    /// Remember that a specified block was "touched", i.e. had a value set.
	    /// Untouched blocks can be skipped when compacting the array
	    /// </summary>
	    ///
	    private void TouchBlock(int i, int value_ren) {
	        hashes[i] = (hashes[i] + (value_ren << 1)) | 1;
	    }
	
	    /// <summary>
	    /// Query whether a specified block was "touched", i.e. had a value set.
	    /// Untouched blocks can be skipped when compacting the array
	    /// </summary>
	    ///
	    private bool BlockTouched(int i) {
	        return hashes[i] != 0;
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// For internal use only. Do not modify the result, the behavior of modified
	    /// results are undefined.
	    /// </summary>
	    ///
	    public char[] GetIndexArray() {
	        return indices;
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// For internal use only. Do not modify the result, the behavior of modified
	    /// results are undefined.
	    /// </summary>
	    ///
	    public sbyte[] GetValueArray() {
	        return values;
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Overrides Cloneable
	    /// </summary>
	    ///
	    public Object Clone() {
	        try {
	            CompactByteArray other = (CompactByteArray) base.MemberwiseClone();
	            other.values = (sbyte[]) values.Clone();
	            other.indices = (char[]) indices.Clone();
	            if (hashes != null)
	                other.hashes = (int[]) hashes.Clone();
	            return other;
	        } catch (Exception e) {
	            throw new InvalidOperationException();
	        }
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Compares the equality of two compact array objects.
	    /// </summary>
	    ///
	    /// <param name="obj">the compact array object to be compared with this.</param>
	    /// <returns>true if the current compact array object is the same as the
	    /// compact array object obj; false otherwise.</returns>
	    public override bool Equals(Object obj) {
	        if (obj == null)
	            return false;
	        if ((Object) this == obj) // quick check
	            return true;
	        if ((Object) GetType() != (Object) obj.GetType()) // same class?
	            return false;
	        CompactByteArray other = (CompactByteArray) obj;
	        for (int i = 0; i < UNICODECOUNT; i++) {
	            // could be sped up later
	            if (ElementAt((char) i) != other.ElementAt((char) i))
	                return false;
	        }
	        return true; // we made it through the guantlet.
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Generates the hash code for the compact array object
	    /// </summary>
	    ///
	    public override int GetHashCode() {
	        int result = 0;
	        int increment = Math.Min(3,values.Length / 16);
	        for (int i = 0; i < values.Length; i += increment) {
	            result = result * 37 + values[i];
	        }
	        return result;
	    }
	
	    // --------------------------------------------------------------
	    // private
	    // --------------------------------------------------------------
	
	    /// <summary>
	    /// Expanding takes the array back to a 65536 element array.
	    /// </summary>
	    ///
	    private void Expand() {
	        int i;
	        if (isCompact) {
	            sbyte[] tempArray;
	            hashes = new int[INDEXCOUNT];
	            tempArray = new sbyte[UNICODECOUNT];
	            for (i = 0; i < UNICODECOUNT; ++i) {
	                sbyte value_ren = ElementAt((char) i);
	                tempArray[i] = value_ren;
	                TouchBlock(i >> BLOCKSHIFT, value_ren);
	            }
	            for (i = 0; i < INDEXCOUNT; ++i) {
	                indices[i] = (char) (i << BLOCKSHIFT);
	            }
	            values = null;
	            values = tempArray;
	            isCompact = false;
	        }
	    }
	
	    private const int BLOCKSHIFT = 7;
	
	    private const int BLOCKCOUNT = (1 << BLOCKSHIFT);
	
	    private const int INDEXSHIFT = (16 - BLOCKSHIFT);
	
	    private const int INDEXCOUNT = (1 << INDEXSHIFT);
	
	    private const int BLOCKMASK = BLOCKCOUNT - 1;
	
	    private sbyte[] values;
	
	    private char[] indices;
	
	    private int[] hashes;
	
	    private bool isCompact;
	
	    internal sbyte defaultValue;
	}
}
