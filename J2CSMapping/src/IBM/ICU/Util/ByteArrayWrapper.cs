//##header J2SE15
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:47 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 1996-2006, International Business Machines Corporation and    
/// others. All Rights Reserved.                                                
/// </summary>
///
namespace IBM.ICU.Util {
	
	using ILOG.J2CsMapping.NIO;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Text;
	
	/// <summary>
	/// <p>
	/// A simple utility class to wrap a byte array.
	/// </p>
	/// <p>
	/// Generally passed as an argument object into a method. The method takes
	/// responsibility of writing into the internal byte array and increasing its
	/// size when necessary.
	/// </p>
	/// </summary>
	///
	/// @stable ICU 2.8
	public class ByteArrayWrapper : IComparable {
	    // public data member ------------------------------------------------
	
	    /// <summary>
	    /// Internal byte array.
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    public byte[] bytes;
	
	    /// <summary>
	    /// Size of the internal byte array used. Different from bytes.length, size
	    /// will be &lt;= bytes.length. Semantics of size is similar to
	    /// java.util.Vector.size().
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    public int size;
	
	    // public constructor ------------------------------------------------
	
	    /// <summary>
	    /// Construct a new ByteArrayWrapper with no data.
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    public ByteArrayWrapper() {
	        // leave bytes null, don't allocate twice
	    }
	
	    /// <summary>
	    /// Construct a new ByteArrayWrapper from a byte array and size
	    /// </summary>
	    ///
	    /// <param name="bytesToAdopt">the byte array to adopt</param>
	    /// <param name="size_0">the length of valid data in the byte array</param>
	    /// <exception cref="IndexOutOfBoundsException">if bytesToAdopt == null and size != 0, or size < 0, or size >bytesToAdopt.length.</exception>
	    /// @draft ICU 3.2
	    /// @provisional This API might change or be removed in a future release.
	    public ByteArrayWrapper(byte[] bytesToAdopt, int size_0) {
	        if ((bytesToAdopt == null && size_0 != 0) || size_0 < 0
	                || size_0 > bytesToAdopt.Length) {
	            throw new IndexOutOfRangeException("illegal size: " + size_0.ToString());
	        }
	        this.bytes = bytesToAdopt;
	        this.size = size_0;
	    }
	
	    /// <summary>
	    /// Construct a new ByteArrayWrapper from the contents of a ByteBuffer.
	    /// </summary>
	    ///
	    /// <param name="source">the ByteBuffer from which to get the data.</param>
	    /// @draft ICU 3.2
	    /// @provisional This API might change or be removed in a future release.
	    public ByteArrayWrapper(ByteBuffer source) {
            size = 0; // source.Limit();
	        bytes = new byte[size];
	        bytes = source.GetBytes(); //, 0, size);
	    }
	
	    /**
	     * Create from ByteBuffer
	     * 
	     * @param byteBuffer
	     *            public ByteArrayWrapper(ByteArrayWrapper source) { size =
	     *            source.size; bytes = new byte[size]; copyBytes(source.bytes,
	     *            0, bytes, 0, size); }
	     */
	
	    /**
	     * create from byte buffer
	     * 
	     * @param src
	     * @param start
	     * @param limit
	     *            public ByteArrayWrapper(byte[] src, int start, int limit) {
	     *            size = limit - start; bytes = new byte[size]; copyBytes(src,
	     *            start, bytes, 0, size); }
	     */
	
	    // public methods ----------------------------------------------------
	
	    /// <summary>
	    /// Ensure that the internal byte array is at least of length capacity. If
	    /// the byte array is null or its length is less than capacity, a new byte
	    /// array of length capacity will be allocated. The contents of the array
	    /// (between 0 and size) remain unchanged.
	    /// </summary>
	    ///
	    /// <param name="capacity">minimum length of internal byte array.</param>
	    /// <returns>this ByteArrayWrapper</returns>
	    /// @draft ICU 3.2
	    /// @provisional This API might change or be removed in a future release.
	    public ByteArrayWrapper EnsureCapacity(int capacity) {
	        if (bytes == null || bytes.Length < capacity) {
	            byte[] newbytes = new byte[capacity];
	            CopyBytes(bytes, 0, newbytes, 0, size);
	            bytes = newbytes;
	        }
	        return this;
	    }
	
	    /// <summary>
	    /// Set the internal byte array from offset 0 to (limit - start) with the
	    /// contents of src from offset start to limit. If the byte array is null or
	    /// its length is less than capacity, a new byte array of length (limit -
	    /// start) will be allocated. This resets the size of the internal byte array
	    /// to (limit - start).
	    /// </summary>
	    ///
	    /// <param name="src">source byte array to copy from</param>
	    /// <param name="start">start offset of src to copy from</param>
	    /// <param name="limit">end + 1 offset of src to copy from</param>
	    /// <returns>this ByteArrayWrapper</returns>
	    /// @draft ICU 3.2
	    /// @provisional This API might change or be removed in a future release.
	    public ByteArrayWrapper Set(byte[] src, int start, int limit) {
	        size = 0;
	        Append(src, start, limit);
	        return this;
	    }
	
	    /*
	     * public final ByteArrayWrapper get(byte[] target, int start, int limit) {
	     * int len = limit - start; if (len > size) throw new
	     * IllegalArgumentException("limit too long"); copyBytes(bytes, 0, target,
	     * start, len); return this; }
	     */
	
	    /// <summary>
	    /// Appends the internal byte array from offset size with the contents of src
	    /// from offset start to limit. This increases the size of the internal byte
	    /// array to (size + limit - start).
	    /// </summary>
	    ///
	    /// <param name="src">source byte array to copy from</param>
	    /// <param name="start">start offset of src to copy from</param>
	    /// <param name="limit">end + 1 offset of src to copy from</param>
	    /// <returns>this ByteArrayWrapper</returns>
	    /// @draft ICU 3.2
	    /// @provisional This API might change or be removed in a future release.
	    public ByteArrayWrapper Append(byte[] src, int start, int limit) {
	        int len = limit - start;
	        EnsureCapacity(size + len);
	        CopyBytes(src, start, bytes, size, len);
	        size += len;
	        return this;
	    }
	
	    /*
	     * public final ByteArrayWrapper append(ByteArrayWrapper other) { return
	     * append(other.bytes, 0, other.size); }
	     */
	
	    /// <summary>
	    /// Releases the internal byte array to the caller, resets the internal byte
	    /// array to null and its size to 0.
	    /// </summary>
	    ///
	    /// <returns>internal byte array.</returns>
	    /// @stable ICU 2.8
	    public byte[] ReleaseBytes() {
	        byte[] result = bytes;
	        bytes = null;
	        size = 0;
	        return result;
	    }
	
	    // Boilerplate ----------------------------------------------------
	
	    /// <summary>
	    /// Returns string value for debugging
	    /// </summary>
	    ///
	    /// @draft ICU 3.2
	    /// @provisional This API might change or be removed in a future release.
	    public override String ToString() {
	        StringBuilder result = new StringBuilder();
	        for (int i = 0; i < size; ++i) {
	            if (i != 0)
	                result.Append(" ");
	            result.Append(IBM.ICU.Impl.Utility.Hex(bytes[i] & 0xFF, 2));
	        }
	        return result.ToString();
	    }
	
	    /// <summary>
	    /// Return true if the bytes in each wrapper are equal.
	    /// </summary>
	    ///
	    /// <param name="other">the object to compare to.</param>
	    /// <returns>true if the two objects are equal.</returns>
	    /// @draft ICU 3.2
	    /// @provisional This API might change or be removed in a future release.
	    public override bool Equals(Object other) {
	        if ((Object) this == other)
	            return true;
	        if (other == null)
	            return false;
	        try {
	            ByteArrayWrapper that = (ByteArrayWrapper) other;
	            if (size != that.size)
	                return false;
	            for (int i = 0; i < size; ++i) {
	                if (bytes[i] != that.bytes[i])
	                    return false;
	            }
	            return true;
	        } catch (InvalidCastException e) {
	        }
	        return false;
	    }
	
	    /// <summary>
	    /// Return the hashcode.
	    /// </summary>
	    ///
	    /// <returns>the hashcode.</returns>
	    /// @draft ICU 3.2
	    /// @provisional This API might change or be removed in a future release.
	    public override int GetHashCode() {
	        int result = bytes.Length;
	        for (int i = 0; i < size; ++i) {
	            result = 37 * result + bytes[i];
	        }
	        return result;
	    }
	
	    /// <summary>
	    /// Compare this object to another ByteArrayWrapper, which must not be null.
	    /// </summary>
	    ///
	    /// <param name="other">the object to compare to.</param>
	    /// <returns>a value <0, 0, or >0 as this compares less than, equal to, or
	    /// greater than other.</returns>
	    /// <exception cref="ClassCastException">if the other object is not a ByteArrayWrapper</exception>
	    /// @draft ICU 3.2
	    /// @provisional This API might change or be removed in a future release.
	    public virtual int CompareTo(Object other) {
	        if ((Object) this == other)
	            return 0;
	        ByteArrayWrapper that = (ByteArrayWrapper) other;
	        int minSize = (size < that.size) ? size : that.size;
	        for (int i = 0; i < minSize; ++i) {
	            if (bytes[i] != that.bytes[i]) {
	                return (bytes[i] & 0xFF) - (that.bytes[i] & 0xFF);
	            }
	        }
	        return size - that.size;
	    }
	
	    // private methods -----------------------------------------------------
	
	    /// <summary>
	    /// Copies the contents of src byte array from offset srcoff to the target of
	    /// tgt byte array at the offset tgtoff.
	    /// </summary>
	    ///
	    /// <param name="src">source byte array to copy from</param>
	    /// <param name="srcoff">start offset of src to copy from</param>
	    /// <param name="tgt">target byte array to copy to</param>
	    /// <param name="tgtoff">start offset of tgt to copy to</param>
	    /// <param name="length">size of contents to copy</param>
	    private static void CopyBytes(byte[] src, int srcoff, byte[] tgt,
	            int tgtoff, int length) {
	        if (length < 64) {
	            for (int i = srcoff, n = tgtoff; --length >= 0; ++i, ++n) {
	                tgt[n] = src[i];
	            }
	        } else {
	            System.Array.Copy((Array)(src),srcoff,(Array)(tgt),tgtoff,length);
	        }
	    }
	}
}
