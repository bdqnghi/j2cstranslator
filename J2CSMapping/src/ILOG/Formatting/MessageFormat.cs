/* 
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/1/10 3:36 PM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
namespace ILOG.J2CsMapping.Formatting
{

    using ILOG.J2CsMapping.Collections.Generics;
    using ILOG.J2CsMapping.IO;
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.Globalization;
    using System.IO;
    using System.Runtime.CompilerServices;
    using System.Text;
    using ILOG.J2CsMapping.Util;
    using ILOG.J2CsMapping.Formatting;
    using ILOG.J2CsMapping.Text;

    /// <summary>
    /// MessageFormat is used to format and parse arguments based on a pattern. The
    /// pattern specifies how each argument will be formatted and concatenated with
    /// other text to produce the formatted output.
    /// </summary>
    ///
    public class MessageFormat : Format
    {

        private const long serialVersionUID = 6479157306784022952L;

        private Locale locale;

        private String[] strings;

        private int[] argumentNumbers;

        private Format[] formats;

        private int maxOffset;

        private int maxArgumentIndex;

        /// <summary>
        /// Constructs a new MessageFormat using the specified pattern and the
        /// specified Locale for Formats.
        /// </summary>
        ///
        /// <param name="template">the pattern</param>
        /// <param name="locale_0">the locale</param>
        /// <exception cref="IllegalArgumentException">when the pattern cannot be parsed</exception>
        public MessageFormat(String template, Locale locale_0)
        {
            this.locale = Locale.GetDefault();
            this.locale = locale_0;
            ApplyPattern(template);
        }

        /// <summary>
        /// Constructs a new MessageFormat using the specified pattern and the
        /// default Locale for Formats.
        /// </summary>
        ///
        /// <param name="template">the pattern</param>
        /// <exception cref="IllegalArgumentException">when the pattern cannot be parsed</exception>
        public MessageFormat(String template)
        {
            this.locale = Locale.GetDefault();
            ApplyPattern(template);
        }

        /// <summary>
        /// Changes this MessageFormat to use the specified pattern.
        /// </summary>
        ///
        /// <param name="template">the pattern</param>
        /// <exception cref="IllegalArgumentException">when the pattern cannot be parsed</exception>
        public void ApplyPattern(String template)
        {
            int length = template.Length;
            StringBuilder buffer = new StringBuilder();
            ParsePosition position = new ParsePosition(0);
            List<String> localStrings = new List<String>();
            int argCount = 0;
            int[] args = new int[10];
            int maxArg = -1;
            List<Format> localFormats = new List<Format>();
            while (position.GetIndex() < length)
            {
                if (ILOG.J2CsMapping.Formatting.Format.UpTo(template, position, buffer, '{'))
                {
                    int arg = 0;
                    int offset = position.GetIndex();
                    if (offset >= length)
                    {
                        // text.19=Invalid argument number
                        throw new ArgumentException("text.19"); //$NON-NLS-1$
                    }
                    // Get argument number
                    char ch;
                    while ((ch = template[offset++]) != '}' && ch != ',')
                    {
                        if (ch < '0' && ch > '9')
                        {
                            // text.19=Invalid argument number
                            throw new ArgumentException("text.19"); //$NON-NLS-1$
                        }

                        arg = arg * 10 + (ch - '0');

                        if (arg < 0 || offset >= length)
                        {
                            // text.19=Invalid argument number
                            throw new ArgumentException("text.19"); //$NON-NLS-1$
                        }
                    }
                    offset--;
                    position.SetIndex(offset);
                    localFormats.Add(ParseVariable(template, position));
                    if (argCount >= args.Length)
                    {
                        int[] newArgs = new int[args.Length * 2];
                        System.Array.Copy((Array)(args), 0, (Array)(newArgs), 0, args.Length);
                        args = newArgs;
                    }
                    args[argCount++] = arg;
                    if (arg > maxArg)
                    {
                        maxArg = arg;
                    }
                }
                localStrings.Add(buffer.ToString());
                buffer.Length = 0;
            }
            this.strings = new String[localStrings.Count];
            for (int i = 0; i < localStrings.Count; i++)
            {
                this.strings[i] = localStrings[i];
            }
            argumentNumbers = args;
            this.formats = new Format[argCount];
            for (int i_0 = 0; i_0 < argCount; i_0++)
            {
                this.formats[i_0] = localFormats[i_0];
            }
            maxOffset = argCount - 1;
            maxArgumentIndex = maxArg;
        }

        /// <summary>
        /// Answers a new instance of MessageFormat with the same pattern and Formats
        /// as this MessageFormat.
        /// </summary>
        ///
        /// <returns>a shallow copy of this MessageFormat</returns>
        /// <seealso cref="T:System.ICloneable"/>
        public Object Clone()
        {
            MessageFormat clone = (MessageFormat)base.Clone();
            Format[] array = new Format[formats.Length];
            for (int i = formats.Length; --i >= 0; )
            {
                if (formats[i] != null)
                {
                    array[i] = (Format)formats[i].Clone();
                }
            }
            clone.formats = array;
            return clone;
        }

        /// <summary>
        /// Compares the specified object to this MessageFormat and answer if they
        /// are equal. The object must be an instance of MessageFormat and have the
        /// same pattern.
        /// </summary>
        ///
        /// <param name="object">the object to compare with this object</param>
        /// <returns>true if the specified object is equal to this MessageFormat,
        /// false otherwise</returns>
        /// <seealso cref="M:ILOG.J2CsMapping.Text.MessageFormat.HashCode"/>
        public override bool Equals(Object obj0)
        {
            if ((Object)this == obj0)
            {
                return true;
            }
            if (!(obj0 is MessageFormat))
            {
                return false;
            }
            MessageFormat format = (MessageFormat)obj0;
            if (maxOffset != format.maxOffset)
            {
                return false;
            }
            // Must use a loop since the lengths may be different due
            // to serialization cross-loading
            for (int i = 0; i <= maxOffset; i++)
            {
                if (argumentNumbers[i] != format.argumentNumbers[i])
                {
                    return false;
                }
            }
            return locale.Equals(format.locale)
                    && ILOG.J2CsMapping.Collections.Arrays.Equals(strings, format.strings)
                    && ILOG.J2CsMapping.Collections.Arrays.Equals(formats, format.formats);
        }

        /// <summary>
        /// Formats the specified object using the rules of this MessageFormat and
        /// returns an AttributedCharacterIterator with the formatted message and
        /// attributes. The AttributedCharacterIterator returned also includes the
        /// attributes from the formats of this MessageFormat.
        /// </summary>
        ///
        /// <param name="object">the object to format</param>
        /// <returns>an AttributedCharacterIterator with the formatted message and
        /// attributes</returns>
        /// <exception cref="IllegalArgumentException">when the arguments in the object array cannot be formattedby this Format</exception>
        public override ILOG.J2CsMapping.Text.AttributedCharacterIterator FormatToCharacterIterator(Object obj0)
        {
            if (obj0 == null)
            {
                throw new NullReferenceException();
            }

            StringBuilder buffer = new StringBuilder();
            List<FieldContainer> fields = new List<FieldContainer>();

            // format the message, and find fields
            FormatImpl((Object[])obj0, buffer, new FieldPosition(0), fields);

            // create an AttributedString with the formatted buffer
            ILOG.J2CsMapping.Text.AttributedString // create an AttributedString with the formatted buffer
                    al = new ILOG.J2CsMapping.Text.AttributedString(buffer.ToString());

            // add MessageFormat field attributes and values to the AttributedString
            for (int i = 0; i < fields.Count; i++)
            {
                MessageFormat.FieldContainer fc = fields[i];
                al.AddAttribute(fc.attribute, fc.value_ren, fc.start, fc.end);
            }

            // return the CharacterIterator from AttributedString
            return al.GetIterator();
        }

        /// <summary>
        /// Formats the Object arguments into the specified StringBuffer using the
        /// pattern of this MessageFormat.
        /// <p>
        /// If Field Attribute of the FieldPosition supplied is
        /// MessageFormat.Field.ARGUMENT, then begin and end index of this field
        /// position is set to the location of the first occurrence of a message
        /// format argument. Otherwise the FieldPosition is ignored
        /// <p>
        /// </summary>
        ///
        /// <param name="objects">the array of Objects to format</param>
        /// <param name="buffer">the StringBuffer</param>
        /// <param name="field">a FieldPosition.</param>
        /// <returns>the StringBuffer parameter <c>buffer</c></returns>
        public StringBuilder Format(Object[] objects, StringBuilder buffer,
                FieldPosition field)
        {
            return FormatImpl(objects, buffer, field, null);
        }

        private StringBuilder FormatImpl(Object[] objects, StringBuilder buffer,
                FieldPosition position, List<FieldContainer> fields)
        {
            FieldPosition passedField = new FieldPosition(0);
            for (int i = 0; i <= maxOffset; i++)
            {
                buffer.Append(strings[i]);
                int begin = buffer.Length;
                Object arg;
                if (objects != null && argumentNumbers[i] < objects.Length)
                {
                    arg = objects[argumentNumbers[i]];
                }
                else
                {
                    buffer.Append('{');
                    buffer.Append(argumentNumbers[i]);
                    buffer.Append('}');
                    HandleArgumentField(begin, buffer.Length, argumentNumbers[i],
                            position, fields);
                    continue;
                }
                Format format = formats[i];
                if (format == null || arg == null)
                {
                    if (arg is object)
                    {
                        format = NumberFormat.GetInstance();
                    }
                    else if (arg is DateTime)
                    {
                        format = DateFormat.GetInstance();
                    }
                    else
                    {
                        buffer.Append(arg);
                        HandleArgumentField(begin, buffer.Length,
                                argumentNumbers[i], position, fields);
                        continue;
                    }
                }
                if (format is ChoiceFormat)
                {
                    String result = format.FormatObject(arg);
                    MessageFormat mf = new MessageFormat(result);
                    mf.SetLocale(locale);
                    mf.Format(objects, buffer, passedField);
                    HandleArgumentField(begin, buffer.Length, argumentNumbers[i],
                            position, fields);
                    Handleformat(format, arg, begin, fields);
                }
                else
                {
                    format.FormatObject(arg, buffer, passedField);
                    HandleArgumentField(begin, buffer.Length, argumentNumbers[i],
                            position, fields);
                    Handleformat(format, arg, begin, fields);
                }
            }
            if (maxOffset + 1 < strings.Length)
            {
                buffer.Append(strings[maxOffset + 1]);
            }
            return buffer;
        }

        /// <summary>
        /// Adds a new FieldContainer with MessageFormat.Field.ARGUMENT field,
        /// argnumber, begin and end index to the fields vector, or sets the
        /// position's begin and end index if it has MessageFormat.Field.ARGUMENT as
        /// its field attribute.
        /// </summary>
        ///
        /// <param name="begin"></param>
        /// <param name="end"></param>
        /// <param name="argnumber"></param>
        /// <param name="position"></param>
        /// <param name="fields"></param>
        private void HandleArgumentField(int begin, int end, int argnumber,
                FieldPosition position, List<FieldContainer> fields)
        {
            if (fields != null)
            {
                fields.Add(new MessageFormat.FieldContainer(begin, end, MessageFormat.Field.ARGUMENT,
                        ((int)(argnumber))));
            }
            else
            {
                if (position != null
                        && (Object)position.GetFieldAttribute() == (Object)MessageFormat.Field.ARGUMENT
                        && position.GetEndIndex() == 0)
                {
                    position.SetBeginIndex(begin);
                    position.SetEndIndex(end);
                }
            }
        }

        /// <summary>
        /// An inner class to store attributes, values, start and end indices.
        /// Instances of this inner class are used as elements for the fields vector
        /// </summary>
        ///
        private class FieldContainer
        {
            internal int start, end;

            internal ILOG.J2CsMapping.Text.AttributedCharacterIterator_Constants.Attribute attribute;

            internal Object value_ren;

            public FieldContainer(int start_0, int end_1,
                    ILOG.J2CsMapping.Text.AttributedCharacterIterator_Constants.Attribute attribute_2, Object value_ren)
            {
                this.start = start_0;
                this.end = end_1;
                this.attribute = attribute_2;
                this.value_ren = value_ren;
            }
        }

        /// <summary>
        /// If fields vector is not null, find and add the fields of this format to
        /// the fields vector by iterating through its AttributedCharacterIterator
        /// </summary>
        ///
        /// <param name="format">the format to find fields for</param>
        /// <param name="arg">object to format</param>
        /// <param name="begin">the index where the string this format has formatted begins</param>
        /// <param name="fields">fields vector, each entry in this vector are of typeFieldContainer.</param>
        private void Handleformat(Format format, Object arg, int begin,
                List<FieldContainer> fields)
        {
            if (fields != null)
            {
                AttributedCharacterIterator iterator = format
                        .FormatToCharacterIterator(arg);
                while (iterator.GetIndex() != iterator.GetEndIndex())
                {
                    int start_0 = iterator.GetRunStart();
                    int end_1 = iterator.GetRunLimit();

                    IIterator<ILOG.J2CsMapping.Text.AttributedCharacterIterator_Constants.Attribute> it = new ILOG.J2CsMapping.Collections.Generics.IteratorAdapter<ILOG.J2CsMapping.Text.AttributedCharacterIterator_Constants.Attribute>(new ILOG.J2CsMapping.Collections.Generics.ListSet<ILOG.J2CsMapping.Text.AttributedCharacterIterator_Constants.Attribute>(iterator.GetAttributes().Keys).GetEnumerator());
                    while (it.HasNext())
                    {
                        AttributedCharacterIterator_Constants.Attribute attribute_2 = (AttributedCharacterIterator_Constants.Attribute)it
                                .Next();
                        Object value_ren = iterator.GetAttribute(attribute_2);
                        fields.Add(new MessageFormat.FieldContainer(begin + start_0, begin + end_1,
                                attribute_2, value_ren));
                    }
                    iterator.SetIndex(end_1);
                }
            }
        }

        /// <summary>
        /// Formats the specified object into the specified StringBuffer using the
        /// pattern of this MessageFormat.
        /// </summary>
        ///
        /// <param name="object">the object to format, must be an array of Object</param>
        /// <param name="buffer">the StringBuffer</param>
        /// <param name="field">a FieldPosition which is ignored</param>
        /// <returns>the StringBuffer parameter <c>buffer</c></returns>
        /// <exception cref="ClassCastException">when <c>object</c> is not an array of Object</exception>
        public sealed override StringBuilder FormatObject(Object obj0, StringBuilder buffer,
                FieldPosition field)
        {
            return Format((Object[])obj0, buffer, field);
        }

        /// <summary>
        /// Formats the Object arguments using the specified MessageFormat pattern.
        /// </summary>
        ///
        /// <param name="template">the pattern</param>
        /// <param name="objects">the array of Objects to format</param>
        /// <returns>the formatted result</returns>
        /// <exception cref="IllegalArgumentException">when the pattern cannot be parsed</exception>
        public static String Format(String template, params Object[] objects)
        {
            if (objects != null)
            {
                for (int i = 0; i < objects.Length; i++)
                {
                    if (objects[i] == null)
                    {
                        objects[i] = "null";
                    }
                }
            }
            return IBM.ICU.Text.MessageFormat.Format(template, objects);
        }

        /// <summary>
        /// Answers the Formats of this MessageFormat.
        /// </summary>
        ///
        /// <returns>an array of Format</returns>
        public Format[] GetFormats()
        {
            return formats;
        }

        /// <summary>
        /// Answers the formats used for each argument index. If an argument is
        /// placed more than once in the pattern string, than returns the format of
        /// the last one.
        /// </summary>
        ///
        /// <returns>an array of formats, ordered by argument index</returns>
        public Format[] GetFormatsByArgumentIndex()
        {
            Format[] answer = new Format[maxArgumentIndex + 1];
            for (int i = 0; i < maxOffset + 1; i++)
            {
                answer[argumentNumbers[i]] = formats[i];
            }
            return answer;
        }

        /// <summary>
        /// Sets the format used for argument at index <c>argIndex</c>to
        /// <c>format</c>
        /// </summary>
        ///
        /// <param name="argIndex"></param>
        /// <param name="format"></param>
        public void SetFormatByArgumentIndex(int argIndex, Format format)
        {
            for (int i = 0; i < maxOffset + 1; i++)
            {
                if (argumentNumbers[i] == argIndex)
                {
                    formats[i] = format;
                }
            }
        }

        /// <summary>
        /// Sets the formats used for each argument <c>The formats</c> array
        /// elements should be in the order of the argument indices.
        /// </summary>
        ///
        /// <param name="formats_0"></param>
        public void SetFormatsByArgumentIndex(Format[] formats_0)
        {
            for (int j = 0; j < formats_0.Length; j++)
            {
                for (int i = 0; i < maxOffset + 1; i++)
                {
                    if (argumentNumbers[i] == j)
                    {
                        this.formats[i] = formats_0[j];
                    }
                }
            }
        }

        /// <summary>
        /// Answers the Locale used when creating Formats.
        /// </summary>
        ///
        /// <returns>the Locale used to create Formats</returns>
        public Locale GetLocale()
        {
            return locale;
        }

        /// <summary>
        /// Answers an integer hash code for the receiver. Objects which are equal
        /// answer the same value for this method.
        /// </summary>
        ///
        /// <returns>the receiver's hash</returns>
        /// <seealso cref="M:ILOG.J2CsMapping.Text.MessageFormat.Equals(System.Object)"/>
        public override int GetHashCode()
        {
            int hashCode = 0;
            for (int i = 0; i <= maxOffset; i++)
            {
                hashCode += argumentNumbers[i] + strings[i].GetHashCode();
                if (formats[i] != null)
                {
                    hashCode += formats[i].GetHashCode();
                }
            }
            if (maxOffset + 1 < strings.Length)
            {
                hashCode += strings[maxOffset + 1].GetHashCode();
            }
            if (locale != null)
            {
                return hashCode + locale.GetHashCode();
            }
            return hashCode;
        }

        /// <summary>
        /// Parse the message arguments from the specified String using the rules of
        /// this MessageFormat.
        /// </summary>
        ///
        /// <param name="string">the String to parse</param>
        /// <returns>the array of Object arguments resulting from the parse</returns>
        /// <exception cref="ParseException">when an error occurs during parsing</exception>
        public Object[] Parse(String str0)
        {
            ParsePosition position = new ParsePosition(0);
            Object[] result = Parse(str0, position);
            if (position.GetErrorIndex() != -1 || position.GetIndex() == 0)
            {
                throw new ILOG.J2CsMapping.Util.ParseException(null, position.GetErrorIndex());
            }
            return result;
        }

        /// <summary>
        /// Parse the message argument from the specified String starting at the
        /// index specified by the ParsePosition. If the string is successfully
        /// parsed, the index of the ParsePosition is updated to the index following
        /// the parsed text.
        /// </summary>
        ///
        /// <param name="string">the String to parse</param>
        /// <param name="position">the ParsePosition, updated on return with the index followingthe parsed text, or on error the index is unchanged and theerror index is set to the index where the error occurred</param>
        /// <returns>the array of Object arguments resulting from the parse, or null
        /// if there is an error</returns>
        public Object[] Parse(String str0, ParsePosition position)
        {
            if (str0 == null)
            {
                return new Object[0];
            }
            ParsePosition internalPos = new ParsePosition(0);
            int offset = position.GetIndex();
            Object[] result = new Object[maxArgumentIndex + 1];
            for (int i = 0; i <= maxOffset; i++)
            {
                String sub = strings[i];
                if (!ILOG.J2CsMapping.Util.StringUtil.StartsWith(str0, sub, offset))
                {
                    position.SetErrorIndex(offset);
                    return null;
                }
                offset += sub.Length;
                Object parse;
                Format format = formats[i];
                if (format == null)
                {
                    if (i + 1 < strings.Length)
                    {
                        int next = ILOG.J2CsMapping.Util.StringUtil.IndexOf(str0, strings[i + 1], offset);
                        if (next == -1)
                        {
                            position.SetErrorIndex(offset);
                            return null;
                        }
                        parse = str0.Substring(offset, (next) - (offset));
                        offset = next;
                    }
                    else
                    {
                        parse = str0.Substring(offset);
                        offset = str0.Length;
                    }
                }
                else
                {
                    internalPos.SetIndex(offset);
                    parse = format.ParseObject(str0, internalPos);
                    if (internalPos.GetErrorIndex() != -1)
                    {
                        position.SetErrorIndex(offset);
                        return null;
                    }
                    offset = internalPos.GetIndex();
                }
                result[argumentNumbers[i]] = parse;
            }
            if (maxOffset + 1 < strings.Length)
            {
                String sub_0 = strings[maxOffset + 1];
                if (!ILOG.J2CsMapping.Util.StringUtil.StartsWith(str0, sub_0, offset))
                {
                    position.SetErrorIndex(offset);
                    return null;
                }
                offset += sub_0.Length;
            }
            position.SetIndex(offset);
            return result;
        }

        /// <summary>
        /// Parse the message argument from the specified String starting at the
        /// index specified by the ParsePosition. If the string is successfully
        /// parsed, the index of the ParsePosition is updated to the index following
        /// the parsed text.
        /// </summary>
        ///
        /// <param name="string">the String to parse</param>
        /// <param name="position">the ParsePosition, updated on return with the index followingthe parsed text, or on error the index is unchanged and theerror index is set to the index where the error occurred</param>
        /// <returns>the array of Object arguments resulting from the parse, or null
        /// if there is an error</returns>
        public override Object ParseObject(String str0, ParsePosition position)
        {
            return Parse(str0, position);
        }

        private int Match(String str0, ParsePosition position, bool last,
                String[] tokens)
        {
            int length = str0.Length, offset = position.GetIndex(), token = -1;
            while (offset < length && Char.IsWhiteSpace(str0[offset]))
            {
                offset++;
            }
            for (int i = tokens.Length; --i >= 0; )
            {
                if (StringUtil.RegionMatches(str0, true, offset, tokens[i], 0,
                        tokens[i].Length))
                {
                    token = i;
                    break;
                }
            }
            if (token == -1)
            {
                return -1;
            }
            offset += tokens[token].Length;
            while (offset < length && Char.IsWhiteSpace(str0[offset]))
            {
                offset++;
            }
            char ch;
            if (offset < length
                    && ((ch = str0[offset]) == '}' || (!last && ch == ',')))
            {
                position.SetIndex(offset + 1);
                return token;
            }
            return -1;
        }

        private Format ParseVariable(String str0, ParsePosition position)
        {
            int length = str0.Length, offset = position.GetIndex();
            char ch;
            if (offset >= length
                    || ((ch = str0[offset++]) != '}' && ch != ','))
            {
                // text.15=Missing element format
                throw new ArgumentException("text.15"); //$NON-NLS-1$
            }
            position.SetIndex(offset);
            if (ch == '}')
            {
                return null;
            }
            int type = Match(str0, position, false, new String[] { "time", //$NON-NLS-1$
					"date", "number", "choice" }); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
            if (type == -1)
            {
                // text.16=Unknown element format
                throw new ArgumentException("text.16"); //$NON-NLS-1$
            }
            StringBuilder buffer = new StringBuilder();
            ch = str0[position.GetIndex() - 1];
            switch (type)
            {
                case 0: // time
                case 1: // date
                    if (ch == '}')
                    {
                        return (type == 1) ? DateFormat.GetDateInstance(
                                DateFormat.DEFAULT, locale) : DateFormat
                                .GetTimeInstance(DateFormat.DEFAULT, locale);
                    }
                    int dateStyle = Match(str0, position, true, new String[] {
						"full", "long", "medium", "short" }); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$ //$NON-NLS-4$
                    if (dateStyle == -1)
                    {
                        ILOG.J2CsMapping.Formatting.Format.UpToWithQuotes(str0, position, buffer, '}', '{');
                        return new SimpleDateFormat(buffer.ToString(), locale);
                    }
                    switch (dateStyle)
                    {
                        case 0:
                            dateStyle = DateFormat.FULL;
                            break;
                        case 1:
                            dateStyle = DateFormat.LONG;
                            break;
                        case 2:
                            dateStyle = DateFormat.MEDIUM;
                            break;
                        case 3:
                            dateStyle = DateFormat.SHORT;
                            break;
                    }
                    return (type == 1) ? DateFormat.GetDateInstance(dateStyle, locale)
                            : DateFormat.GetTimeInstance(dateStyle, locale);
                case 2: // number
                    if (ch == '}')
                    {
                        return NumberFormat.GetInstance();
                    }
                    int numberStyle = Match(str0, position, true, new String[] {
						"currency", "percent", "integer" }); //$NON-NLS-1$ //$NON-NLS-2$ //$NON-NLS-3$
                    if (numberStyle == -1)
                    {
                        ILOG.J2CsMapping.Formatting.Format.UpToWithQuotes(str0, position, buffer, '}', '{');
                        return new DecimalFormat(buffer.ToString(),
                                new DecimalFormatSymbols(locale));
                    }
                    switch (numberStyle)
                    {
                        case 0: // currency
                            return NumberFormat.GetCurrencyInstance(locale);
                        case 1: // percent
                            return NumberFormat.GetPercentInstance(locale);
                    }
                    return NumberFormat.GetIntegerInstance(locale);
            }
            // choice
            try
            {
                ILOG.J2CsMapping.Formatting.Format.UpToWithQuotes(str0, position, buffer, '}', '{');
            }
            catch (ArgumentException e)
            {
                // ignored
            }
            return new ChoiceFormat(buffer.ToString());
        }

        /// <summary>
        /// Sets the specified Format used by this MessageFormat.
        /// </summary>
        ///
        /// <param name="offset">the format to change</param>
        /// <param name="format">the Format</param>
        public void SetFormat(int offset, Format format)
        {
            formats[offset] = format;
        }

        /// <summary>
        /// Sets the Formats used by this MessageFormat.
        /// </summary>
        ///
        /// <param name="formats_0">an array of Format</param>
        public void SetFormats(Format[] formats_0)
        {
            int min = this.formats.Length;
            if (formats_0.Length < min)
            {
                min = formats_0.Length;
            }
            for (int i = 0; i < min; i++)
            {
                this.formats[i] = formats_0[i];
            }
        }

        /// <summary>
        /// Sets the Locale to use when creating Formats.
        /// </summary>
        ///
        /// <param name="locale_0">the Locale</param>
        public void SetLocale(Locale locale_0)
        {
            this.locale = locale_0;
            for (int i = 0; i <= maxOffset; i++)
            {
                Format format = formats[i];
                if (format is DecimalFormat)
                {
                    formats[i] = new DecimalFormat(
                            ((DecimalFormat)format).ToPattern(),
                            new DecimalFormatSymbols(locale_0));
                }
                else if (format is SimpleDateFormat)
                {
                    formats[i] = new SimpleDateFormat(
                            ((SimpleDateFormat)format).ToPattern(), locale_0);
                }

            }
        }

        private String DecodeDecimalFormat(StringBuilder buffer, Format format)
        {
            buffer.Append(",number"); //$NON-NLS-1$
            if (format.Equals(NumberFormat.GetNumberInstance(locale)))
            {
                // Empty block
            }
            else if (format.Equals(NumberFormat.GetIntegerInstance(locale)))
            {
                buffer.Append(",integer"); //$NON-NLS-1$
            }
            else if (format.Equals(NumberFormat.GetCurrencyInstance(locale)))
            {
                buffer.Append(",currency"); //$NON-NLS-1$
            }
            else if (format.Equals(NumberFormat.GetPercentInstance(locale)))
            {
                buffer.Append(",percent"); //$NON-NLS-1$
            }
            else
            {
                buffer.Append(',');
                return ((DecimalFormat)format).ToPattern();
            }
            return null;
        }

        private String DecodeSimpleDateFormat(StringBuilder buffer, Format format)
        {
            if (format.Equals(DateFormat
                    .GetTimeInstance(DateFormat.DEFAULT, locale)))
            {
                buffer.Append(",time"); //$NON-NLS-1$
            }
            else if (format.Equals(DateFormat.GetDateInstance(DateFormat.DEFAULT,
                    locale)))
            {
                buffer.Append(",date"); //$NON-NLS-1$
            }
            else if (format.Equals(DateFormat.GetTimeInstance(DateFormat.SHORT,
                  locale)))
            {
                buffer.Append(",time,short"); //$NON-NLS-1$
            }
            else if (format.Equals(DateFormat.GetDateInstance(DateFormat.SHORT,
                  locale)))
            {
                buffer.Append(",date,short"); //$NON-NLS-1$
            }
            else if (format.Equals(DateFormat.GetTimeInstance(DateFormat.LONG,
                  locale)))
            {
                buffer.Append(",time,long"); //$NON-NLS-1$
            }
            else if (format.Equals(DateFormat.GetDateInstance(DateFormat.LONG,
                  locale)))
            {
                buffer.Append(",date,long"); //$NON-NLS-1$
            }
            else if (format.Equals(DateFormat.GetTimeInstance(DateFormat.FULL,
                  locale)))
            {
                buffer.Append(",time,full"); //$NON-NLS-1$
            }
            else if (format.Equals(DateFormat.GetDateInstance(DateFormat.FULL,
                  locale)))
            {
                buffer.Append(",date,full"); //$NON-NLS-1$
            }
            else
            {
                buffer.Append(",date,"); //$NON-NLS-1$
                return ((SimpleDateFormat)format).ToPattern();
            }
            return null;
        }

        /// <summary>
        /// Answers the pattern of this MessageFormat.
        /// </summary>
        ///
        /// <returns>the pattern</returns>
        public String ToPattern()
        {
            StringBuilder buffer = new StringBuilder();
            for (int i = 0; i <= maxOffset; i++)
            {
                AppendQuoted(buffer, strings[i]);
                buffer.Append('{');
                buffer.Append(argumentNumbers[i]);
                Format format = formats[i];
                String pattern = null;
                if (format is ChoiceFormat)
                {
                    buffer.Append(",choice,"); //$NON-NLS-1$
                    pattern = ((ChoiceFormat)format).ToPattern();
                }
                else if (format is DecimalFormat)
                {
                    pattern = DecodeDecimalFormat(buffer, format);
                }
                else if (format is SimpleDateFormat)
                {
                    pattern = DecodeSimpleDateFormat(buffer, format);
                }
                else if (format != null)
                {
                    // text.17=Unknown format
                    throw new ArgumentException("text.17"); //$NON-NLS-1$
                }
                if (pattern != null)
                {
                    bool quote = false;
                    int index = 0, length = pattern.Length, count = 0;
                    while (index < length)
                    {
                        char ch = pattern[index++];
                        if (ch == '\'')
                        {
                            quote = !quote;
                        }
                        if (!quote)
                        {
                            if (ch == '{')
                            {
                                count++;
                            }
                            if (ch == '}')
                            {
                                if (count > 0)
                                {
                                    count--;
                                }
                                else
                                {
                                    buffer.Append("'}"); //$NON-NLS-1$
                                    ch = '\'';
                                }
                            }
                        }
                        buffer.Append(ch);
                    }
                }
                buffer.Append('}');
            }
            if (maxOffset + 1 < strings.Length)
            {
                AppendQuoted(buffer, strings[maxOffset + 1]);
            }
            return buffer.ToString();
        }

        private void AppendQuoted(StringBuilder buffer, String str0)
        {
            int length = str0.Length;
            for (int i = 0; i < length; i++)
            {
                char ch = str0[i];
                if (ch == '{' || ch == '}')
                {
                    buffer.Append('\'');
                    buffer.Append(ch);
                    buffer.Append('\'');
                }
                else
                {
                    buffer.Append(ch);
                }
            }
        }

        /*private static readonly ObjectStreamField[] serialPersistentFields = {
                new ObjectStreamField("argumentNumbers", typeof(int[])), //$NON-NLS-1$
                new ObjectStreamField("formats", typeof(Format[])), //$NON-NLS-1$
                new ObjectStreamField("locale", typeof(CultureInfo)), //$NON-NLS-1$
                new ObjectStreamField("maxOffset", typeof(Int32)), //$NON-NLS-1$
                new ObjectStreamField("offsets", typeof(int[])), //$NON-NLS-1$
                new ObjectStreamField("pattern", typeof(String)), }; //$NON-NLS-1$*/

        private void WriteObject(IlObjectOutputStream stream)
        {
            /*ObjectOutputStream.PutField fields = stream.PutFields();
            fields.Put("argumentNumbers", argumentNumbers); //$NON-NLS-1$
            Format[] compatibleFormats = formats;
            fields.Put("formats", compatibleFormats); //$NON-NLS-1$
            fields.Put("locale", locale); //$NON-NLS-1$
            fields.Put("maxOffset", maxOffset); //$NON-NLS-1$
            int offset = 0;
            int offsetsLength = maxOffset + 1;
            int[] offsets = new int[offsetsLength];
            StringBuilder pattern = new StringBuilder();
            for (int i = 0; i <= maxOffset; i++) {
                offset += strings[i].Length;
                offsets[i] = offset;
                pattern.Append(strings[i]);
            }
            if (maxOffset + 1 < strings.Length) {
                pattern.Append(strings[maxOffset + 1]);
            }
            fields.Put("offsets", offsets); //$NON-NLS-1$
            fields.Put("pattern", pattern.ToString()); //$NON-NLS-1$
            stream.WriteFields();*/
        }

        private void ReadObject(IlObjectInputStream stream)
        {
            /*ObjectInputStream.GetField fields = stream.ReadFields();
            argumentNumbers = (int[]) fields.Get("argumentNumbers", null); //$NON-NLS-1$
            formats = (Format[]) fields.Get("formats", null); //$NON-NLS-1$
            locale = (CultureInfo) fields.Get("locale", null); //$NON-NLS-1$
            maxOffset = fields.Get("maxOffset", 0); //$NON-NLS-1$
            int[] offsets = (int[]) fields.Get("offsets", null); //$NON-NLS-1$
            String pattern = (String) fields.Get("pattern", null); //$NON-NLS-1$
            int length;
            if (maxOffset < 0) {
                length = (pattern.Length > 0) ? 1 : 0;
            } else {
                length = maxOffset
                        + ((offsets[maxOffset] == pattern.Length) ? 1 : 2);
            }
            strings = new String[length];
            int last = 0;
            for (int i = 0; i <= maxOffset; i++) {
                strings[i] = pattern.Substring(last,(offsets[i])-(last));
                last = offsets[i];
            }
            if (maxOffset + 1 < strings.Length) {
                strings[strings.Length - 1] = pattern.Substring(last,(pattern.Length)-(last));
            }*/
        }

        /// <summary>
        /// The instances of this inner class are used as attribute keys in
        /// AttributedCharacterIterator that
        /// MessageFormat.formatToCharacterIterator() method returns.
        /// <p>
        /// There is no public constructor to this class, the only instances are the
        /// constants defined here.
        /// </summary>
        ///
        public class Field : Format.Field
        {

            private const long serialVersionUID = 7899943957617360810L;

            public static readonly MessageFormat.Field ARGUMENT = new MessageFormat.Field("message argument field"); //$NON-NLS-1$

            /// <summary>
            /// Constructs a new instance of MessageFormat.Field with the given field
            /// name.
            /// </summary>
            ///
            protected internal Field(String fieldName)
                : base(fieldName)
            {
            }

            /// <summary>
            /// serialization method resolve instances to the constant
            /// MessageFormat.Field values
            /// </summary>
            ///
            protected internal override Object ReadResolve()
            {
                String name = this.GetName();
                if (name == null)
                {
                    // text.18=Not a valid {0}, subclass should override
                    // readResolve()
                    throw new IOException(
                            "text.18" + "MessageFormat.Field"); //$NON-NLS-1$ //$NON-NLS-2$
                }

                if (name.Equals(ARGUMENT.GetName()))
                {
                    return ARGUMENT;
                }
                // text.18=Not a valid {0}, subclass should override readResolve()
                throw new IOException("text.18" + "MessageFormat.Field"); //$NON-NLS-1$ //$NON-NLS-2$
            }
        }

    }
}
