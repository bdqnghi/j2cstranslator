/* 
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/1/10 3:36 PM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace ILOG.J2CsMapping.Formatting {
	
	using ILOG.J2CsMapping.IO;
	using ILOG.J2CsMapping.Text;
     using Locale = ILOG.J2CsMapping.Util.Locale;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.Globalization;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Text;
     using ILOG.J2CsMapping.Formatting;
	
	/// <summary>
	/// NumberFormat is the abstract superclass of Formats which format and parse
	/// Numbers.
	/// </summary>
	///
	public abstract class NumberFormat : Format {
	
		private const long serialVersionUID = -2308460125733713944L;
	
		/// <summary>
		/// Field constant.
		/// </summary>
		///
		public const int INTEGER_FIELD = 0;
	
		/// <summary>
		/// Field constant.
		/// </summary>
		///
		public const int FRACTION_FIELD = 1;
	
		private bool groupingUsed, parseIntegerOnly;
	
		private int maximumIntegerDigits, minimumIntegerDigits,
				maximumFractionDigits, minimumFractionDigits;
	
		/// <summary>
		/// Constructs a new instance of DateFormat.
		/// </summary>
		///
		public NumberFormat() {
			this.groupingUsed = true;
			this.parseIntegerOnly = false;
			this.maximumIntegerDigits = 40;
			this.minimumIntegerDigits = 1;
			this.maximumFractionDigits = 3;
			this.minimumFractionDigits = 0;
		}
	
		/// <summary>
		/// Answers a new NumberFormat with the same properties as this NumberFormat.
		/// </summary>
		///
		/// <returns>a shallow copy of this NumberFormat</returns>
		/// <seealso cref="T:System.ICloneable"/>
		public virtual Object Clone() {
			return base.Clone();
		}
	
		/// <summary>
		/// Compares the specified object to this NumberFormat and answer if they are
		/// equal. The object must be an instance of NumberFormat and have the same
		/// properties.
		/// </summary>
		///
		/// <param name="object">the object to compare with this object</param>
		/// <returns>true if the specified object is equal to this NumberFormat, false
		/// otherwise</returns>
		/// <seealso cref="M:ILOG.J2CsMapping.Text.NumberFormat.HashCode"/>
		public override bool Equals(Object obj0) {
			if (obj0 == (Object) this) {
				return true;
			}
			if (!(obj0   is  NumberFormat)) {
				return false;
			}
			NumberFormat obj = (NumberFormat) obj0;
			return groupingUsed == obj.groupingUsed
					&& parseIntegerOnly == obj.parseIntegerOnly
					&& maximumFractionDigits == obj.maximumFractionDigits
					&& maximumIntegerDigits == obj.maximumIntegerDigits
					&& minimumFractionDigits == obj.minimumFractionDigits
					&& minimumIntegerDigits == obj.minimumIntegerDigits;
		}
	
		/// <summary>
		/// Formats the specified double using the rules of this NumberFormat.
		/// </summary>
		///
		/// <param name="value">the double to format</param>
		/// <returns>the formatted String</returns>
		public String Format(double value_ren) {
			return Format(value_ren, new StringBuilder(), new FieldPosition(0))
					.ToString();
		}
	
		/// <summary>
		/// Formats the double value into the specified StringBuffer using the rules
		/// of this NumberFormat. If the field specified by the FieldPosition is
		/// formatted, set the begin and end index of the formatted field in the
		/// FieldPosition.
		/// </summary>
		///
		/// <param name="value">the double to format</param>
		/// <param name="buffer">the StringBuffer</param>
		/// <param name="field">the FieldPosition</param>
		/// <returns>the StringBuffer parameter <c>buffer</c></returns>
		public abstract StringBuilder Format(double value_ren, StringBuilder buffer,
				FieldPosition field);
	
		/// <summary>
		/// Formats the specified long using the rules of this NumberFormat.
		/// </summary>
		///
		/// <param name="value">the long to format</param>
		/// <returns>the formatted String</returns>
		public String Format(long value_ren) {
			return Format(value_ren, new StringBuilder(), new FieldPosition(0))
					.ToString();
		}
	
		/// <summary>
		/// Formats the long value into the specified StringBuffer using the rules of
		/// this NumberFormat. If the field specified by the FieldPosition is
		/// formatted, set the begin and end index of the formatted field in the
		/// FieldPosition.
		/// </summary>
		///
		/// <param name="value">the long to format</param>
		/// <param name="buffer">the StringBuffer</param>
		/// <param name="field">the FieldPosition</param>
		/// <returns>the StringBuffer parameter <c>buffer</c></returns>
		public abstract StringBuilder Format(long value_ren, StringBuilder buffer,
				FieldPosition field);
	
		/// <summary>
		/// Formats the specified object into the specified StringBuffer using the
		/// rules of this DateFormat. If the field specified by the FieldPosition is
		/// formatted, set the begin and end index of the formatted field in the
		/// FieldPosition.
		/// </summary>
		///
		/// <param name="object">the object to format, must be a Number</param>
		/// <param name="buffer">the StringBuffer</param>
		/// <param name="field">the FieldPosition</param>
		/// <returns>the StringBuffer parameter <c>buffer</c></returns>
		/// <exception cref="IllegalArgumentException">when the object is not a Number</exception>
		public override StringBuilder FormatObject(Object obj0, StringBuilder buffer,
				FieldPosition field) {
			if (obj0   is  ValueType) {
				double dv = Convert.ToDouble(((object) obj0));
				long lv = Convert.ToInt64(((object) obj0));
				if (dv == lv) {
					return Format(lv, buffer, field);
				}
				return Format(dv, buffer, field);
			}
			throw new ArgumentException();
		}
	
		/// <summary>
		/// Gets the list of installed Locales which support NumberFormat.
		/// </summary>
		///
		/// <returns>an array of Locale</returns>
		public static CultureInfo[] GetAvailableLocales() {
			return System.Globalization.CultureInfo.GetCultures(CultureTypes.AllCultures);
		}
	
		/// <summary>
		/// Answers the currency used by this number format
		/// <p>
		/// This implementation throws UnsupportedOperationException, concrete sub
		/// classes should override if they support currency formatting.
		/// <p>
		/// </summary>
		///
		/// <returns>currency currency that was set in getInstance() or in
		/// setCurrency(), or null</returns>
		/// <exception cref="System.NotSupportedException"></exception>
        public virtual IBM.ICU.Util.Currency GetCurrency()
        {
			throw new NotSupportedException();
		}
	
		/// <summary>
		/// Answers a NumberFormat for formatting and parsing currency for the
		/// default Locale.
		/// </summary>
		///
		/// <returns>a NumberFormat</returns>
		public static NumberFormat GetCurrencyInstance() {
            return GetCurrencyInstance(Locale.GetDefault());
		}
	
		/// <summary>
		/// Answers a NumberFormat for formatting and parsing currency for the
		/// specified Locale.
		/// </summary>
		///
		/// <param name="locale">the Locale</param>
		/// <returns>a NumberFormat</returns>
        public static NumberFormat GetCurrencyInstance(Locale locale)
        {
            IBM.ICU.Text.DecimalFormat icuFormat = (IBM.ICU.Text.DecimalFormat)IBM.ICU.Text.NumberFormat
					.GetCurrencyInstance(locale);
			String pattern = icuFormat.ToPattern();
            return new DecimalFormat(pattern, new DecimalFormatSymbols(locale));
		}
	
		/// <summary>
		/// Answers a NumberFormat for formatting and parsing integers for the
		/// default Locale.
		/// </summary>
		///
		/// <returns>a NumberFormat</returns>
		public static NumberFormat GetIntegerInstance() {
            return GetIntegerInstance(Locale.GetDefault());
		}
	
		/// <summary>
		/// Answers a NumberFormat for formatting and parsing integers for the
		/// specified Locale.
		/// </summary>
		///
		/// <param name="locale">the Locale</param>
		/// <returns>a NumberFormat</returns>
        public static NumberFormat GetIntegerInstance(Locale locale)
        {
            IBM.ICU.Text.DecimalFormat icuFormat = (IBM.ICU.Text.DecimalFormat)IBM.ICU.Text.NumberFormat
					.GetIntegerInstance(locale);
			String pattern = icuFormat.ToPattern();
            DecimalFormat format = new DecimalFormat(pattern,
                    new DecimalFormatSymbols(locale));
			format.SetParseIntegerOnly(true);
			return format;
	
		}
	
		/// <summary>
		/// Answers a NumberFormat for formatting and parsing numbers for the default
		/// Locale.
		/// </summary>
		///
		/// <returns>a NumberFormat</returns>
		public static NumberFormat GetInstance() {
			return GetNumberInstance();
		}
	
		/// <summary>
		/// Answers a NumberFormat for formatting and parsing numbers for the
		/// specified Locale.
		/// </summary>
		///
		/// <param name="locale">the Locale</param>
		/// <returns>a NumberFormat</returns>
        public static NumberFormat GetInstance(Locale locale)
        {
			return GetNumberInstance(locale);
		}
	
		/// <summary>
		/// Answers the maximum number of fraction digits that are printed when
		/// formatting. If the maximum is less than the number of fraction digits,
		/// the least significant digits are truncated.
		/// </summary>
		///
		/// <returns>the maximum number of fraction digits</returns>
		public int GetMaximumFractionDigits() {
			return maximumFractionDigits;
		}
	
		/// <summary>
		/// Answers the maximum number of integer digits that are printed when
		/// formatting. If the maximum is less than the number of integer digits, the
		/// most significant digits are truncated.
		/// </summary>
		///
		/// <returns>the maximum number of integer digits</returns>
		public int GetMaximumIntegerDigits() {
			return maximumIntegerDigits;
		}
	
		/// <summary>
		/// Answers the minimum number of fraction digits that are printed when
		/// formatting.
		/// </summary>
		///
		/// <returns>the minimum number of fraction digits</returns>
		public int GetMinimumFractionDigits() {
			return minimumFractionDigits;
		}
	
		/// <summary>
		/// Answers the minimum number of integer digits that are printed when
		/// formatting.
		/// </summary>
		///
		/// <returns>the minimum number of integer digits</returns>
		public int GetMinimumIntegerDigits() {
			return minimumIntegerDigits;
		}
	
		/// <summary>
		/// Answers a NumberFormat for formatting and parsing numbers for the default
		/// Locale.
		/// </summary>
		///
		/// <returns>a NumberFormat</returns>
		public static NumberFormat GetNumberInstance() {
            return GetNumberInstance(Locale.GetDefault());
		}
	
		/// <summary>
		/// Answers a NumberFormat for formatting and parsing numbers for the
		/// specified Locale.
		/// </summary>
		///
		/// <param name="locale">the Locale</param>
		/// <returns>a NumberFormat</returns>
        public static NumberFormat GetNumberInstance(Locale locale)
        {
            IBM.ICU.Text.DecimalFormat icuFormat = (IBM.ICU.Text.DecimalFormat)IBM.ICU.Text.NumberFormat
					.GetNumberInstance(locale);
			String pattern = icuFormat.ToPattern();
            return new DecimalFormat(pattern, new DecimalFormatSymbols(locale));
		}
	
		/// <summary>
		/// Answers a NumberFormat for formatting and parsing percentages for the
		/// default Locale.
		/// </summary>
		///
		/// <returns>a NumberFormat</returns>
		public static NumberFormat GetPercentInstance() {
            return GetPercentInstance(Locale.GetDefault());
		}
	
		/// <summary>
		/// Answers a NumberFormat for formatting and parsing percentages for the
		/// specified Locale.
		/// </summary>
		///
		/// <param name="locale">the Locale</param>
		/// <returns>a NumberFormat</returns>
        public static NumberFormat GetPercentInstance(Locale locale)
        {
            IBM.ICU.Text.DecimalFormat icuFormat = (IBM.ICU.Text.DecimalFormat)IBM.ICU.Text.NumberFormat
					.GetPercentInstance(locale);
			String pattern = icuFormat.ToPattern();
            return new DecimalFormat(pattern, new DecimalFormatSymbols(locale));
		}
	
		/// <summary>
		/// Answers an integer hash code for the receiver. Objects which are equal
		/// answer the same value for this method.
		/// </summary>
		///
		/// <returns>the receiver's hash</returns>
		/// <seealso cref="M:ILOG.J2CsMapping.Text.NumberFormat.Equals(System.Object)"/>
		public override int GetHashCode() {
			return ((groupingUsed) ? 1231 : 1237) + ((parseIntegerOnly) ? 1231 : 1237)
					+ maximumFractionDigits + maximumIntegerDigits
					+ minimumFractionDigits + minimumIntegerDigits;
		}
	
		/// <summary>
		/// Answers whether this NumberFormat formats and parses numbers using a
		/// grouping separator.
		/// </summary>
		///
		/// <returns>true when a grouping separator is used, false otherwise</returns>
		public virtual bool IsGroupingUsed() {
			return groupingUsed;
		}
	
		/// <summary>
		/// Answers whether this NumberFormat only parses integer numbers. Parsing
		/// stops if a decimal separator is encountered.
		/// </summary>
		///
		/// <returns>true if this NumberFormat only parses integers, false for parsing
		/// integers or fractions</returns>
		public virtual bool IsParseIntegerOnly() {
			return parseIntegerOnly;
		}
	
		/// <summary>
		/// Parse a Number from the specified String using the rules of this
		/// NumberFormat.
		/// </summary>
		///
		/// <param name="string">the String to parse</param>
		/// <returns>the Number resulting from the parse</returns>
		/// <exception cref="ParseException">when an error occurs during parsing</exception>
		public object Parse(String str0) {
			ParsePosition pos = new ParsePosition(0);
			object number = Parse(str0, pos);
			if (pos.GetErrorIndex() != -1 || pos.GetIndex() == 0) {
				throw new ILOG.J2CsMapping.Util.ParseException(null,pos.GetErrorIndex());
			}
			return number;
		}
	
		/// <summary>
		/// Parse a Number from the specified String starting at the index specified
		/// by the ParsePosition. If the string is successfully parsed, the index of
		/// the ParsePosition is updated to the index following the parsed text.
		/// </summary>
		///
		/// <param name="string">the String to parse</param>
		/// <param name="position">the ParsePosition, updated on return with the index followingthe parsed text, or on error the index is unchanged and theerror index is set to the index where the error occurred</param>
		/// <returns>the Number resulting from the parse, or null if there is an error</returns>
		public abstract object Parse(String str0, ParsePosition position);
	
		/// <summary>
		/// Parse a Number from the specified String starting at the index specified
		/// by the ParsePosition. If the string is successfully parsed, the index of
		/// the ParsePosition is updated to the index following the parsed text.
		/// </summary>
		///
		/// <param name="string">the String to parse</param>
		/// <param name="position">the ParsePosition, updated on return with the index followingthe parsed text, or on error the index is unchanged and theerror index is set to the index where the error occurred</param>
		/// <returns>the Number resulting from the parse, or null if there is an error</returns>
		public sealed override Object ParseObject(String str0, ParsePosition position) {
			if (position == null) {
				// text.1A=position is null
				throw new NullReferenceException("text.1A"); //$NON-NLS-1$
			}
	
			try {
				return Parse(str0, position);
			} catch (Exception e) {
				return null;
			}
		}
	
		/// <summary>
		/// Sets the currency used by this number format when formatting currency
		/// values.
		/// <p>
		/// The min and max fraction digits remain the same.
		/// <p>
		/// This implementation throws UnsupportedOperationException, concrete sub
		/// classes should override if they support currency formatting.
		/// <p>
		/// </summary>
		///
		/// <param name="currency">the new Currency</param>
		/// <exception cref="System.NotSupportedException"></exception>
        public virtual void SetCurrency(IBM.ICU.Util.Currency currency)
        {
			throw new NotSupportedException();
		}
	
		/// <summary>
		/// Sets whether this NumberFormat formats and parses numbers using a
		/// grouping separator.
		/// </summary>
		///
		/// <param name="value">true when a grouping separator is used, false otherwise</param>
		public virtual void SetGroupingUsed(bool value_ren) {
			groupingUsed = value_ren;
		}
	
		/// <summary>
		/// Sets the maximum number of fraction digits that are printed when
		/// formatting. If the maximum is less than the number of fraction digits,
		/// the least significant digits are truncated.
		/// </summary>
		///
		/// <param name="value">the maximum number of fraction digits</param>
		public virtual void SetMaximumFractionDigits(int value_ren) {
			maximumFractionDigits = (value_ren < 0) ? 0 : value_ren;
			if (maximumFractionDigits < minimumFractionDigits) {
				minimumFractionDigits = maximumFractionDigits;
			}
		}
	
		/// <summary>
		/// Used to specify the new maximum count of integer digits that are printed
		/// when formatting. If the maximum is less than the number of integer
		/// digits, the most significant digits are truncated.
		/// </summary>
		///
		/// <param name="value">the new maximum number of integer numerals for display</param>
		public virtual void SetMaximumIntegerDigits(int value_ren) {
			maximumIntegerDigits = (value_ren < 0) ? 0 : value_ren;
			if (maximumIntegerDigits < minimumIntegerDigits) {
				minimumIntegerDigits = maximumIntegerDigits;
			}
		}
	
		/// <summary>
		/// Sets the minimum number of fraction digits that are printed when
		/// formatting.
		/// </summary>
		///
		/// <param name="value">the minimum number of fraction digits</param>
		public virtual void SetMinimumFractionDigits(int value_ren) {
			minimumFractionDigits = (value_ren < 0) ? 0 : value_ren;
			if (maximumFractionDigits < minimumFractionDigits) {
				maximumFractionDigits = minimumFractionDigits;
			}
		}
	
		/// <summary>
		/// Sets the minimum number of integer digits that are printed when
		/// formatting.
		/// </summary>
		///
		/// <param name="value">the minimum number of integer digits</param>
		public virtual void SetMinimumIntegerDigits(int value_ren) {
			minimumIntegerDigits = (value_ren < 0) ? 0 : value_ren;
			if (maximumIntegerDigits < minimumIntegerDigits) {
				maximumIntegerDigits = minimumIntegerDigits;
			}
		}
	
		/// <summary>
		/// Specifies if this NumberFormat should only parse numbers as integers or
		/// else as any kind of number. If this is called with a <c>true</c>
		/// value then subsequent parsing attempts will stop if a decimal separator
		/// is encountered.
		/// </summary>
		///
		/// <param name="value"><c>true</c> to only parse integers, <c>false</c>to parse integers and fractions</param>
		public virtual void SetParseIntegerOnly(bool value_ren) {
			parseIntegerOnly = value_ren;
		}
	
		/*private static readonly ObjectStreamField[] serialPersistentFields = {
				new ObjectStreamField("groupingUsed", typeof(Boolean)), //$NON-NLS-1$
				new ObjectStreamField("maxFractionDigits", typeof(Byte)), //$NON-NLS-1$
				new ObjectStreamField("maximumFractionDigits", typeof(Int32)), //$NON-NLS-1$
				new ObjectStreamField("maximumIntegerDigits", typeof(Int32)), //$NON-NLS-1$
				new ObjectStreamField("maxIntegerDigits", typeof(Byte)), //$NON-NLS-1$
				new ObjectStreamField("minFractionDigits", typeof(Byte)), //$NON-NLS-1$
				new ObjectStreamField("minimumFractionDigits", typeof(Int32)), //$NON-NLS-1$
				new ObjectStreamField("minimumIntegerDigits", typeof(Int32)), //$NON-NLS-1$
				new ObjectStreamField("minIntegerDigits", typeof(Byte)), //$NON-NLS-1$
				new ObjectStreamField("parseIntegerOnly", typeof(Boolean)), //$NON-NLS-1$
				new ObjectStreamField("serialVersionOnStream", typeof(Int32)), }; //$NON-NLS-1$*/
	
		private void WriteObject(IlObjectOutputStream stream) {
			/*ObjectOutputStream.PutField fields = stream.PutFields();
			fields.Put("groupingUsed", groupingUsed); //$NON-NLS-1$
			fields.Put(
					"maxFractionDigits", //$NON-NLS-1$
					(maximumFractionDigits < Byte.MaxValue) ? (byte) maximumFractionDigits
							: Byte.MaxValue);
			fields.Put("maximumFractionDigits", maximumFractionDigits); //$NON-NLS-1$
			fields.Put("maximumIntegerDigits", maximumIntegerDigits); //$NON-NLS-1$
			fields.Put(
					"maxIntegerDigits", //$NON-NLS-1$
					(maximumIntegerDigits < Byte.MaxValue) ? (byte) maximumIntegerDigits
							: Byte.MaxValue);
			fields.Put(
					"minFractionDigits", //$NON-NLS-1$
					(minimumFractionDigits < Byte.MaxValue) ? (byte) minimumFractionDigits
							: Byte.MaxValue);
			fields.Put("minimumFractionDigits", minimumFractionDigits); //$NON-NLS-1$
			fields.Put("minimumIntegerDigits", minimumIntegerDigits); //$NON-NLS-1$
			fields.Put(
					"minIntegerDigits", //$NON-NLS-1$
					(minimumIntegerDigits < Byte.MaxValue) ? (byte) minimumIntegerDigits
							: Byte.MaxValue);
			fields.Put("parseIntegerOnly", parseIntegerOnly); //$NON-NLS-1$
			fields.Put("serialVersionOnStream", 1); //$NON-NLS-1$
			stream.WriteFields();*/
		}
	
		private void ReadObject(IlObjectInputStream stream) {
			/*ObjectInputStream.GetField fields = stream.ReadFields();
			groupingUsed = fields.Get("groupingUsed", true); //$NON-NLS-1$
			parseIntegerOnly = fields.Get("parseIntegerOnly", false); //$NON-NLS-1$
			if (fields.Get("serialVersionOnStream", 0) == 0) { //$NON-NLS-1$
				maximumFractionDigits = fields.Get("maxFractionDigits", (byte) 3); //$NON-NLS-1$
				maximumIntegerDigits = fields.Get("maxIntegerDigits", (byte) 40); //$NON-NLS-1$
				minimumFractionDigits = fields.Get("minFractionDigits", (byte) 0); //$NON-NLS-1$
				minimumIntegerDigits = fields.Get("minIntegerDigits", (byte) 1); //$NON-NLS-1$
			} else {
				maximumFractionDigits = fields.Get("maximumFractionDigits", 3); //$NON-NLS-1$
				maximumIntegerDigits = fields.Get("maximumIntegerDigits", 40); //$NON-NLS-1$
				minimumFractionDigits = fields.Get("minimumFractionDigits", 0); //$NON-NLS-1$
				minimumIntegerDigits = fields.Get("minimumIntegerDigits", 1); //$NON-NLS-1$
			}
			if (minimumIntegerDigits > maximumIntegerDigits
					|| minimumFractionDigits > maximumFractionDigits) {
				// text.00=min digits greater than max digits
				throw new IOException("text.00"); //$NON-NLS-1$
			}
			if (minimumIntegerDigits < 0 || maximumIntegerDigits < 0
					|| minimumFractionDigits < 0 || maximumFractionDigits < 0) {
				// text.01=min or max digits negative
				throw new IOException("text.01"); //$NON-NLS-1$
			}*/
		}
	
		/// <summary>
		/// The instances of this inner class are used as attribute keys and values
		/// in AttributedCharacterIterator that
		/// NumberFormat.formatToCharacterIterator() method returns.
		/// <p>
		/// There is no public constructor to this class, the only instances are the
		/// constants defined here.
		/// <p>
		/// </summary>
		///
		public class Field : Format.Field {
	
			private const long serialVersionUID = 7494728892700160890L;
	
			public static readonly NumberFormat.Field  SIGN = new NumberFormat.Field ("sign"); //$NON-NLS-1$
	
			public static readonly NumberFormat.Field  INTEGER = new NumberFormat.Field ("integer"); //$NON-NLS-1$
	
			public static readonly NumberFormat.Field  FRACTION = new NumberFormat.Field ("fraction"); //$NON-NLS-1$
	
			public static readonly NumberFormat.Field  EXPONENT = new NumberFormat.Field ("exponent"); //$NON-NLS-1$
	
			public static readonly NumberFormat.Field  EXPONENT_SIGN = new NumberFormat.Field ("exponent sign"); //$NON-NLS-1$
	
			public static readonly NumberFormat.Field  EXPONENT_SYMBOL = new NumberFormat.Field ("exponent symbol"); //$NON-NLS-1$
	
			public static readonly NumberFormat.Field  DECIMAL_SEPARATOR = new NumberFormat.Field (
					"decimal separator"); //$NON-NLS-1$
	
			public static readonly NumberFormat.Field  GROUPING_SEPARATOR = new NumberFormat.Field (
					"grouping separator"); //$NON-NLS-1$
	
			public static readonly NumberFormat.Field  PERCENT = new NumberFormat.Field ("percent"); //$NON-NLS-1$
	
			public static readonly NumberFormat.Field  PERMILLE = new NumberFormat.Field ("per mille"); //$NON-NLS-1$
	
			public static readonly NumberFormat.Field  CURRENCY = new NumberFormat.Field ("currency"); //$NON-NLS-1$
	
			/// <summary>
			/// Constructs a new instance of NumberFormat.Field with the given field
			/// name.
			/// </summary>
			///
			protected internal Field(String fieldName) : base(fieldName) {
			}
	
			/// <summary>
			/// serialization method resolve instances to the constant
			/// NumberFormat.Field values
			/// </summary>
			///
			protected internal override Object ReadResolve() {
				if (this.Equals(INTEGER)) {
					return INTEGER;
				}
				if (this.Equals(FRACTION)) {
					return FRACTION;
				}
				if (this.Equals(EXPONENT)) {
					return EXPONENT;
				}
				if (this.Equals(EXPONENT_SIGN)) {
					return EXPONENT_SIGN;
				}
				if (this.Equals(EXPONENT_SYMBOL)) {
					return EXPONENT_SYMBOL;
				}
				if (this.Equals(CURRENCY)) {
					return CURRENCY;
				}
				if (this.Equals(DECIMAL_SEPARATOR)) {
					return DECIMAL_SEPARATOR;
				}
				if (this.Equals(GROUPING_SEPARATOR)) {
					return GROUPING_SEPARATOR;
				}
				if (this.Equals(PERCENT)) {
					return PERCENT;
				}
				if (this.Equals(PERMILLE)) {
					return PERMILLE;
				}
				if (this.Equals(SIGN)) {
					return SIGN;
				}
				// text.02=Unknown attribute
				throw new IOException("text.02"); //$NON-NLS-1$
			}
		}
	
	}
}
