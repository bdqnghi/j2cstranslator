/* 
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/1/10 3:36 PM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace ILOG.J2CsMapping.Formatting {
	
	using ILOG.J2CsMapping.IO;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.Globalization;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Runtime.Serialization;
     using IBM.ICU.Util;
	
	/// <summary>
	/// DecimalFormatSymbols holds the symbols used in the formating and parsing of
	/// numbers.
	/// </summary>
	///
	[Serializable]
	public class DecimalFormatSymbols : ICloneable {
	
		private const long serialVersionUID = 5772796243397350300L;
	
		private readonly int ZeroDigit, Digit, DecimalSeparator,
				GroupingSeparator, PatternSeparator, Percent,
				PerMill, Exponent, MonetaryDecimalSeparator,
				MinusSign;
	
		internal char[] patternChars;
	
		private Currency currency;

        private ILOG.J2CsMapping.Util.Locale locale;
	
		private String infinity, NaN, currencySymbol, intlCurrencySymbol;
	
		/// <summary>
		/// Constructs a new DecimalFormatSymbols containing the symbols for the
		/// default Locale.
		/// </summary>
		///
        public DecimalFormatSymbols()
            : this(ILOG.J2CsMapping.Util.Locale.GetDefault())
        {
		}
	
		/// <summary>
		/// Constructs a new DecimalFormatSymbols containing the symbols for the
		/// specified Locale.
		/// </summary>
		///
		/// <param name="locale_0">the Locale</param>
        public DecimalFormatSymbols(ILOG.J2CsMapping.Util.Locale locale_0)
        {
			this.ZeroDigit = 0;
			this.Digit = 1;
			this.DecimalSeparator = 2;
			this.GroupingSeparator = 3;
			this.PatternSeparator = 4;
			this.Percent = 5;
			this.PerMill = 6;
			this.Exponent = 7;
			this.MonetaryDecimalSeparator = 8;
			this.MinusSign = 9;
            IBM.ICU.Text.DecimalFormatSymbols icuSymbols = new IBM.ICU.Text.DecimalFormatSymbols(
					locale_0);
			infinity = icuSymbols.GetInfinity();
			NaN = icuSymbols.GetNaN();
			this.locale = locale_0;
			currencySymbol = icuSymbols.GetCurrencySymbol();
			intlCurrencySymbol = icuSymbols.GetInternationalCurrencySymbol();
            if (locale_0.GetCountry().Length == 0)
            {
				currency = Currency.GetInstance("XXX");
			} else {
				currency = Currency.GetInstance(locale_0);
			}
			patternChars = new char[10];
			patternChars[ZeroDigit] = icuSymbols.GetZeroDigit();
			patternChars[Digit] = icuSymbols.GetDigit();
			patternChars[DecimalSeparator] = icuSymbols.GetDecimalSeparator();
			patternChars[GroupingSeparator] = icuSymbols.GetGroupingSeparator();
			patternChars[PatternSeparator] = icuSymbols.GetPatternSeparator();
			patternChars[Percent] = icuSymbols.GetPercent();
			patternChars[PerMill] = icuSymbols.GetPerMill();
			patternChars[Exponent] = icuSymbols.GetExponentSeparator()[0];
			patternChars[MonetaryDecimalSeparator] = icuSymbols
					.GetMonetaryDecimalSeparator();
			patternChars[MinusSign] = icuSymbols.GetMinusSign();
	
		}
	
		/// <summary>
		/// Answers a new DecimalFormatSymbols with the same symbols as this
		/// DecimalFormatSymbols.
		/// </summary>
		///
		/// <returns>a shallow copy of this DecimalFormatSymbols</returns>
		/// <seealso cref="T:System.ICloneable"/>
		public Object Clone() {
			try {
                DecimalFormatSymbols symbols = (DecimalFormatSymbols)base.MemberwiseClone();
				symbols.patternChars = (char[]) patternChars.Clone();
				return symbols;
			} catch (Exception e) {
				return null;
			}
		}
	
		/// <summary>
		/// Compares the specified object to this DecimalFormatSymbols and answer if
		/// they are equal. The object must be an instance of DecimalFormatSymbols
		/// with the same symbols.
		/// </summary>
		///
		/// <param name="object">the object to compare with this object</param>
		/// <returns>true if the specified object is equal to this
		/// DecimalFormatSymbols, false otherwise</returns>
		/// <seealso cref="M:System.Globalization.NumberFormatInfo.HashCode"/>
		public override bool Equals(Object obj0) {
			if ((Object) this == obj0) {
				return true;
			}
			if (!(obj0   is  NumberFormatInfo)) {
				return false;
			}
            DecimalFormatSymbols obj = (DecimalFormatSymbols)obj0;
			return ILOG.J2CsMapping.Collections.Arrays.Equals(patternChars,obj.patternChars)
					&& infinity.Equals(obj.infinity) && NaN.Equals(obj.NaN)
					&& currencySymbol.Equals(obj.currencySymbol)
					&& intlCurrencySymbol.Equals(obj.intlCurrencySymbol);
		}
	
		/// <summary>
		/// Answers the currency.
		/// <p>
		/// <code>null<code> is returned
		/// if <c>setInternationalCurrencySymbol()</c> has been previously called
		/// with a value that is not a valid ISO 4217 currency code.
		/// <p>
		/// </summary>
		///
		/// <returns>the currency that was set in the constructor, <c>setCurrency()</c>,
		/// or <c>setInternationalCurrencySymbol()</c>, or </code>null</code></returns>
		/// <seealso cref="M:System.Globalization.NumberFormatInfo.SetCurrency(null)"/>
		/// <seealso cref="M:System.Globalization.NumberFormatInfo.SetInternationalCurrencySymbol(System.String)"/>
		public Currency GetCurrency() {
			return currency;
		}
	
		/// <summary>
		/// Answers the international currency symbol.
		/// </summary>
		///
		/// <returns>a String</returns>
		public String GetInternationalCurrencySymbol() {
			return intlCurrencySymbol;
		}
	
		/// <summary>
		/// Answers the currency symbol.
		/// </summary>
		///
		/// <returns>a String</returns>
		public String GetCurrencySymbol() {
			return currencySymbol;
		}
	
		/// <summary>
		/// Answers the character which represents the decimal point in a number.
		/// </summary>
		///
		/// <returns>a char</returns>
		public char GetDecimalSeparator() {
			return patternChars[DecimalSeparator];
		}
	
		/// <summary>
		/// Answers the character which represents a single digit in a format
		/// pattern.
		/// </summary>
		///
		/// <returns>a char</returns>
		public char GetDigit() {
			return patternChars[Digit];
		}
	
		/// <summary>
		/// Answers the character used as the thousands separator in a number.
		/// </summary>
		///
		/// <returns>a char</returns>
		public char GetGroupingSeparator() {
			return patternChars[GroupingSeparator];
		}
	
		/// <summary>
		/// Answers the String which represents infinity.
		/// </summary>
		///
		/// <returns>a String</returns>
		public String GetInfinity() {
			return infinity;
		}
	
		internal String GetLocalPatternChars() {
			// Don't include the MonetaryDecimalSeparator or the MinusSign
			return new String(patternChars, 0, patternChars.Length - 2);
		}
	
		/// <summary>
		/// Answers the minus sign character.
		/// </summary>
		///
		/// <returns>a char</returns>
		public char GetMinusSign() {
			return patternChars[MinusSign];
		}
	
		/// <summary>
		/// Answers the character which represents the decimal point in a monetary
		/// value.
		/// </summary>
		///
		/// <returns>a char</returns>
		public char GetMonetaryDecimalSeparator() {
			return patternChars[MonetaryDecimalSeparator];
		}
	
		/// <summary>
		/// Answers the String which represents NaN.
		/// </summary>
		///
		/// <returns>a String</returns>
		public String GetNaN() {
			return NaN;
		}
	
		/// <summary>
		/// Answers the character which separates the positive and negative patterns
		/// in a format pattern.
		/// </summary>
		///
		/// <returns>a char</returns>
		public char GetPatternSeparator() {
			return patternChars[PatternSeparator];
		}
	
		/// <summary>
		/// Answers the percent character.
		/// </summary>
		///
		/// <returns>a char</returns>
		public char GetPercent() {
			return patternChars[Percent];
		}
	
		/// <summary>
		/// Answers the mille percent sign character.
		/// </summary>
		///
		/// <returns>a char</returns>
		public char GetPerMill() {
			return patternChars[PerMill];
		}
	
		/// <summary>
		/// Answers the character which represents zero.
		/// </summary>
		///
		/// <returns>a char</returns>
		public char GetZeroDigit() {
			return patternChars[ZeroDigit];
		}
	
		internal char GetExponential() {
			return patternChars[Exponent];
		}
	
		/// <summary>
		/// Answers an integer hash code for the receiver. Objects which are equal
		/// answer the same value for this method.
		/// </summary>
		///
		/// <returns>the receiver's hash</returns>
		/// <seealso cref="M:System.Globalization.NumberFormatInfo.Equals(System.Object)"/>
		public override int GetHashCode() {
			return ILOG.J2CsMapping.Util.StringUtil.NewString(patternChars).GetHashCode() + infinity.GetHashCode()
					+ NaN.GetHashCode() + currencySymbol.GetHashCode()
					+ intlCurrencySymbol.GetHashCode();
		}
	
		/// <summary>
		/// Sets the currency.
		/// <p>
		/// The international currency symbol and currency symbol are updated, but
		/// the min and max number of fraction digits stay the same.
		/// <p>
		/// </summary>
		///
		/// <param name="currency_0">the new currency</param>
		/// <exception cref="System.NullReferenceException">if currency is null</exception>
		public void SetCurrency(Currency currency_0) {
			if (currency_0 == null) {
				throw new NullReferenceException();
			}
			if (currency_0 == this.currency) {
				return;
			}
			this.currency = currency_0;
			intlCurrencySymbol = currency_0.GetCurrencyCode();
			currencySymbol = currency_0.GetSymbol(locale);
		}
	
		/// <summary>
		/// Sets the international currency symbol.
		/// <p>
		/// currency and currency symbol also are updated, if <c>value</c> is
		/// a valid ISO4217 currency code.
		/// <p>
		/// The min and max number of fraction digits stay the same.
		/// </summary>
		///
		/// <param name="value">currency code</param>
		public void SetInternationalCurrencySymbol(String value_ren) {
			if (value_ren == null) {
				currency = null;
				intlCurrencySymbol = null;
				return;
			}
	
			if (value_ren.Equals(intlCurrencySymbol)) {
				return;
			}
	
			try {
				currency = Currency.GetInstance(value_ren);
				currencySymbol = currency.GetSymbol(locale);
			} catch (ArgumentException e) {
				currency = null;
			}
			intlCurrencySymbol = value_ren;
		}
	
		/// <summary>
		/// Sets the currency symbol.
		/// </summary>
		///
		/// <param name="value">a String</param>
		public void SetCurrencySymbol(String value_ren) {
			currencySymbol = value_ren;
		}
	
		/// <summary>
		/// Sets the character which represents the decimal point in a number.
		/// </summary>
		///
		/// <param name="value">the decimal separator character</param>
		public void SetDecimalSeparator(char value_ren) {
			patternChars[DecimalSeparator] = value_ren;
		}
	
		/// <summary>
		/// Sets the character which represents a single digit in a format pattern.
		/// </summary>
		///
		/// <param name="value">the digit character</param>
		public void SetDigit(char value_ren) {
			patternChars[Digit] = value_ren;
		}
	
		/// <summary>
		/// Sets the character used as the thousands separator in a number.
		/// </summary>
		///
		/// <param name="value">the grouping separator character</param>
		public void SetGroupingSeparator(char value_ren) {
			patternChars[GroupingSeparator] = value_ren;
		}
	
		/// <summary>
		/// Sets the String which represents infinity.
		/// </summary>
		///
		/// <param name="value">the String</param>
		public void SetInfinity(String value_ren) {
			infinity = value_ren;
		}
	
		/// <summary>
		/// Sets the minus sign character.
		/// </summary>
		///
		/// <param name="value">the minus sign character</param>
		public void SetMinusSign(char value_ren) {
			patternChars[MinusSign] = value_ren;
		}
	
		/// <summary>
		/// Sets the character which represents the decimal point in a monetary
		/// value.
		/// </summary>
		///
		/// <param name="value">the monetary decimal separator character</param>
		public void SetMonetaryDecimalSeparator(char value_ren) {
			patternChars[MonetaryDecimalSeparator] = value_ren;
		}
	
		/// <summary>
		/// Sets the String which represents NaN.
		/// </summary>
		///
		/// <param name="value">the String</param>
		public void SetNaN(String value_ren) {
			NaN = value_ren;
		}
	
		/// <summary>
		/// Sets the character which separates the positive and negative patterns in
		/// a format pattern.
		/// </summary>
		///
		/// <param name="value">the pattern separator character</param>
		public void SetPatternSeparator(char value_ren) {
			patternChars[PatternSeparator] = value_ren;
		}
	
		/// <summary>
		/// Sets the percent character.
		/// </summary>
		///
		/// <param name="value">the percent character</param>
		public void SetPercent(char value_ren) {
			patternChars[Percent] = value_ren;
		}
	
		/// <summary>
		/// Sets the mille percent sign character.
		/// </summary>
		///
		/// <param name="value">the mille percent character</param>
		public void SetPerMill(char value_ren) {
			patternChars[PerMill] = value_ren;
		}
	
		/// <summary>
		/// Sets the character which represents zero.
		/// </summary>
		///
		/// <param name="value">the zero digit character</param>
		public void SetZeroDigit(char value_ren) {
			patternChars[ZeroDigit] = value_ren;
		}
	
		internal void SetExponential(char value_ren) {
			patternChars[Exponent] = value_ren;
		}
	
		/*private static readonly ObjectStreamField[] serialPersistentFields = {
				new ObjectStreamField("currencySymbol", typeof(String)), //$NON-NLS-1$
				new ObjectStreamField("decimalSeparator", typeof(Char)), //$NON-NLS-1$
				new ObjectStreamField("digit", typeof(Char)), //$NON-NLS-1$
				new ObjectStreamField("exponential", typeof(Char)), //$NON-NLS-1$
				new ObjectStreamField("groupingSeparator", typeof(Char)), //$NON-NLS-1$
				new ObjectStreamField("infinity", typeof(String)), //$NON-NLS-1$
				new ObjectStreamField("intlCurrencySymbol", typeof(String)), //$NON-NLS-1$
				new ObjectStreamField("minusSign", typeof(Char)), //$NON-NLS-1$
				new ObjectStreamField("monetarySeparator", typeof(Char)), //$NON-NLS-1$
				new ObjectStreamField("NaN", typeof(String)), //$NON-NLS-1$
				new ObjectStreamField("patternSeparator", typeof(Char)), //$NON-NLS-1$
				new ObjectStreamField("percent", typeof(Char)), //$NON-NLS-1$
				new ObjectStreamField("perMill", typeof(Char)), //$NON-NLS-1$
				new ObjectStreamField("serialVersionOnStream", typeof(Int32)), //$NON-NLS-1$
				new ObjectStreamField("zeroDigit", typeof(Char)), //$NON-NLS-1$
				new ObjectStreamField("locale", typeof(CultureInfo)), }; //$NON-NLS-1$*/
	
		private void WriteObject(IlObjectOutputStream stream) {
			/*ObjectOutputStream.PutField fields = stream.PutFields();
			fields.Put("currencySymbol", currencySymbol); //$NON-NLS-1$
			fields.Put("decimalSeparator", this.NumberDecimalSeparator[0]); //$NON-NLS-1$
			fields.Put("digit", GetDigit()); //$NON-NLS-1$
			fields.Put("exponential", GetExponential()); //$NON-NLS-1$
			fields.Put("groupingSeparator", this.NumberGroupSeparator[0]); //$NON-NLS-1$
			fields.Put("infinity", infinity); //$NON-NLS-1$
			fields.Put("intlCurrencySymbol", intlCurrencySymbol); //$NON-NLS-1$
			fields.Put("minusSign", GetMinusSign()); //$NON-NLS-1$
			fields.Put("monetarySeparator", GetMonetaryDecimalSeparator()); //$NON-NLS-1$
			fields.Put("NaN", NaN); //$NON-NLS-1$
			fields.Put("patternSeparator", GetPatternSeparator()); //$NON-NLS-1$
			fields.Put("percent", GetPercent()); //$NON-NLS-1$
			fields.Put("perMill", GetPerMill()); //$NON-NLS-1$
			fields.Put("serialVersionOnStream", 1); //$NON-NLS-1$
			fields.Put("zeroDigit", GetZeroDigit()); //$NON-NLS-1$
			fields.Put("locale", locale); //$NON-NLS-1$
			stream.WriteFields();*/
		}
	
		private void ReadObject(IlObjectInputStream stream) {
			/*ObjectInputStream.GetField fields = stream.ReadFields();
			patternChars = new char[10];
			currencySymbol = (String) fields.Get("currencySymbol", ""); //$NON-NLS-1$ //$NON-NLS-2$
			SetDecimalSeparator(fields.Get("decimalSeparator", '.')); //$NON-NLS-1$
			SetDigit(fields.Get("digit", '#')); //$NON-NLS-1$
			SetGroupingSeparator(fields.Get("groupingSeparator", ',')); //$NON-NLS-1$
			infinity = (String) fields.Get("infinity", ""); //$NON-NLS-1$ //$NON-NLS-2$
			intlCurrencySymbol = (String) fields.Get("intlCurrencySymbol", ""); //$NON-NLS-1$ //$NON-NLS-2$
			SetMinusSign(fields.Get("minusSign", '-')); //$NON-NLS-1$
			NaN = (String) fields.Get("NaN", ""); //$NON-NLS-1$ //$NON-NLS-2$
			SetPatternSeparator(fields.Get("patternSeparator", ';')); //$NON-NLS-1$
			SetPercent(fields.Get("percent", '%')); //$NON-NLS-1$
			SetPerMill(fields.Get("perMill", '\u2030')); //$NON-NLS-1$
			SetZeroDigit(fields.Get("zeroDigit", '0')); //$NON-NLS-1$
			locale = (CultureInfo) fields.Get("locale", null); //$NON-NLS-1$
			if (fields.Get("serialVersionOnStream", 0) == 0) { //$NON-NLS-1$
				SetMonetaryDecimalSeparator(this.NumberDecimalSeparator[0]);
				SetExponential('E');
			} else {
				SetMonetaryDecimalSeparator(fields.Get("monetarySeparator", '.')); //$NON-NLS-1$
				SetExponential(fields.Get("exponential", 'E')); //$NON-NLS-1$
	
			}
			try {
				currency = System.Collections.Currency.GetInstance(intlCurrencySymbol);
			} catch (ArgumentException e) {
				currency = null;
			}*/
		}

        internal ILOG.J2CsMapping.Util.Locale GetLocale()
        {
			return locale;
		}
	}
}
