/*
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 11/30/10 3:38 PM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace ILOG.J2CsMapping.RegEx {
	
	using ILOG.J2CsMapping.Text;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	
	
	/// <summary>
	/// Match result implementation
	/// Note: probably it might make sense to combine this class with Matcher.
	/// </summary>
	///
	internal class MatchResultImpl : MatchResult {
	
		private int[] groupBounds;
	
		private int[] consumers;
	
		private int[] compQuantCounters;
	
		private String str0;
	
		private int groupCount;
	
		private bool valid;
	
		private int leftBound;
	
		private int rightBound;
	
		internal int startIndex;
	
		private bool transparentBounds;
	
		private bool anchoringBounds;
	
		internal bool hitEnd;
	
		internal bool requireEnd;
	
		internal int previousMatch;
	
		private int mode;
	
		internal MatchResultImpl(String str0, int leftBound_0, int rightBound_1,
				int groupCount_2, int compQuantCount, int consumersCount) {
			this.groupBounds = null;
					this.consumers = null;
					this.compQuantCounters = null;
					this.str0 = null;
					this.groupCount = 0;
					this.valid = false;
					this.transparentBounds = false;
					this.anchoringBounds = false;
					this.hitEnd = false;
					this.requireEnd = false;
					this.previousMatch = -1;
			this.groupCount = ++groupCount_2;
			this.groupBounds = new int[groupCount_2 * 2];
	
			this.consumers = new int[consumersCount];
			ILOG.J2CsMapping.Collections.Arrays.Fill(consumers,-1);
	
			if (compQuantCount > 0)
				this.compQuantCounters = new int[compQuantCount];
			ILOG.J2CsMapping.Collections.Arrays.Fill(groupBounds,-1);
			Reset(str0, leftBound_0, rightBound_1);
		}
	
		internal MatchResult CloneImpl() {
			MatchResultImpl res = new MatchResultImpl(this.str0, this.leftBound,
					this.rightBound, this.groupCount - 1, 0, 0);
	
			res.valid = valid;
			if (valid) {
				System.Array.Copy((Array)(groupBounds),0,(Array)(res.groupBounds),0,this.groupBounds.Length);
			}
			return res;
		}
	
		public void SetConsumed(int counter, int value_ren) {
			this.consumers[counter] = value_ren;
		}
	
		public int GetConsumed(int counter) {
			return this.consumers[counter];
		}
	
		public virtual int End() {
			return End(0);
		}
	
		public virtual int End(int group) {
			CheckGroup(group);
			return groupBounds[group * 2 + 1];
		}
	
		internal void SetStart(int group, int offset) {
			groupBounds[group * 2] = offset;
		}
	
		internal void SetEnd(int group, int offset) {
			groupBounds[group * 2 + 1] = offset;
		}
	
		internal int GetStart(int group) {
			return groupBounds[group * 2];
		}
	
		internal int GetEnd(int group) {
			return groupBounds[group * 2 + 1];
		}
	
		public virtual String Group() {
			return Group(0);
		}
	
		public virtual String Group(int group) {
			if (Start(group) < 0)
				return null;
			return str0.Substring(Start(group), End(group) - Start(group)).ToString();
		}
	
		internal String GetGroupNoCheck(int group) {
			int st = GetStart(group);
			int end = GetEnd(group);
			if ((end | st | (end - st)) < 0 || end > str0.Length)
				return null;

            return str0.Substring(st, end - st).ToString();
		}
	
		public virtual int GroupCount() {
			return groupCount - 1;
		}
	
		public virtual int Start() {
			return Start(0);
		}
	
		public virtual int Start(int group) {
			CheckGroup(group);
			return groupBounds[group * 2];
		}
	
		/*
		 * This method being called after any successful match; For now it's being
		 * used to check zero group for empty match;
		 */
		public void FinalizeMatch() {
			if (this.groupBounds[0] == -1) {
				this.groupBounds[0] = this.startIndex;
				this.groupBounds[1] = this.startIndex;
			}
	
			previousMatch = End();
		}
	
		public int GetEnterCounter(int setCounter) {
			return compQuantCounters[setCounter];
		}
	
		public void SetEnterCounter(int setCounter, int value_ren) {
			compQuantCounters[setCounter] = value_ren;
		}
	
		private void CheckGroup(int group) {
			if (!valid) {
				throw new InvalidOperationException("regex.05"); //$NON-NLS-1$
			}
	
			if (group < 0 || group > groupCount) {
				throw new IndexOutOfRangeException("regex.06" + group.ToString()); //$NON-NLS-1$
			}
		}
	
		internal void UpdateGroup(int index, int srtOffset, int endOffset) {
			CheckGroup(index);
			groupBounds[index * 2] = srtOffset;
			groupBounds[index * 2 + 1] = endOffset;
		}
	
		protected internal void SetValid() {
			this.valid = true;
		}
	
		protected internal bool IsValid() {
			return this.valid;
		}
	
		protected internal void Reset(String newSequence, int leftBound_0, int rightBound_1) {
			valid = false;
			mode = Matcher.MODE_MATCH;
			ILOG.J2CsMapping.Collections.Arrays.Fill(groupBounds,-1);
			ILOG.J2CsMapping.Collections.Arrays.Fill(consumers,-1);
	
			if (newSequence != null)
				this.str0 = newSequence;
			if (leftBound_0 >= 0)
				this.SetBounds(leftBound_0, rightBound_1);
			this.startIndex = this.leftBound;
		}
	
		protected internal void Reset() {
			Reset(null, -1, -1);
		}
	
		private void SetBounds(int leftBound_0, int rightBound_1) {
			this.leftBound = leftBound_0;
			this.rightBound = rightBound_1;
		}
	
		protected internal void SetStartIndex(int startIndex_0) {
			this.startIndex = startIndex_0;
			previousMatch = (previousMatch >= 0) ? previousMatch : startIndex_0;
		}
	
		public int GetLeftBound() {
			return this.leftBound;
		}
	
		public int GetRightBound() {
			return this.rightBound;
		}
	
		protected internal void SetMode(int mode_0) {
			this.mode = mode_0;
		}
	
		protected internal int Mode() {
			return mode;
		}
	
		protected internal void UseAnchoringBounds(bool value_ren) {
			this.anchoringBounds = value_ren;
		}
	
		protected internal bool HasAnchoringBounds() {
			return this.anchoringBounds;
		}
	
		protected internal void UseTransparentBounds(bool value_ren) {
			this.transparentBounds = value_ren;
		}
	
		protected internal bool HasTransparentBounds() {
			return this.transparentBounds;
		}
	
		internal int GetPreviousMatchEnd() {
			return previousMatch;
		}
	}
}
