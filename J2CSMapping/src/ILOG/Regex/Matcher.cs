/*
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 11/30/10 3:38 PM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace ILOG.J2CsMapping.RegEx {
	
	using ILOG.J2CsMapping.Text;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Text;
	
	/// <summary>
	/// Note: main functionality of this class is hidden into nodes match methods. 
	/// </summary>
	///
	public class Matcher : MatchResult {
	
		public sealed class Anonymous_C0 {
				private readonly Matcher outer_Matcher;
				private readonly int gr;
				private readonly int grN;
		
				public Anonymous_C0(Matcher paramouter_Matcher, int gr_0) {
					this.gr = gr_0;
					this.outer_Matcher = paramouter_Matcher;
					grN = gr_0;
				}
		
				public override String ToString() {
					return outer_Matcher.Group(grN);
				}
			}
	
		static internal int MODE_FIND = 1 << 0;
	
		static internal int MODE_MATCH = 1 << 1;
	
		private Pattern pat;
	
		private AbstractSet start;
	
		private String str0;
	
		private MatchResultImpl matchResult;
	
		// bounds
		private int leftBound;
	
		private int rightBound;
	
		// replacements
		private int appendPos;
	
		private String replacement;
	
		private String processedRepl;
	
		private ArrayList replacementParts;
	
		
		/// @com.intel.drl.spec_ref
		public Matcher AppendReplacement(StringBuilder sb, String replacement_0) {
			processedRepl = ProcessReplacement(replacement_0);
            sb.Append(str0.Substring(appendPos, Start() - appendPos));
			sb.Append(processedRepl);
			appendPos = End();
			return this;
		}
	
		/// <summary>
		/// Parses replacement string and creates pattern
		/// </summary>
		///
		private String ProcessReplacement(String replacement_0) {
			if (this.replacement != null && this.replacement.Equals(replacement_0)) {
				if (replacementParts == null) {
					return processedRepl;
				} else {
					StringBuilder sb = new StringBuilder();
					for (int i = 0; i < replacementParts.Count; i++) {
						sb.Append(replacementParts[i]);
					}
	
					return sb.ToString();
				}
			} else {
				this.replacement = replacement_0;
				char[] repl = replacement_0.ToCharArray();
				StringBuilder res = new StringBuilder();
				replacementParts = null;
	
				int index = 0;
				int replacementPos = 0;
				bool nextBackSlashed = false;
	
				while (index < repl.Length) {
	
					if (repl[index] == '\\' && !nextBackSlashed) {
						nextBackSlashed = true;
						index++;
					}
	
					if (nextBackSlashed) {
						res.Append(repl[index]);
						nextBackSlashed = false;
					} else {
						if (repl[index] == '$') {
							if (replacementParts == null) {
								replacementParts = new ArrayList();
							}
							try {
								int gr_1 = Int32.Parse(new String(repl,
																	++index, 1));
	
								if (replacementPos != res.Length) {
                                    ILOG.J2CsMapping.Collections.Generics.Collections.Add(replacementParts, res.ToString().Substring(
                                                                            replacementPos, res.Length - replacementPos));
									replacementPos = res.Length;
								}
	
								ILOG.J2CsMapping.Collections.Generics.Collections.Add(replacementParts,new Matcher.Anonymous_C0 (this, gr_1));
								String group = this.Group(gr_1);
								replacementPos += group.Length;
								res.Append(group);
	
							} catch (IndexOutOfRangeException iob) {
								throw iob;
							} catch (Exception e) {
								throw new ArgumentException("regex.00"); //$NON-NLS-1$
							}
						} else {
							res.Append(repl[index]);
						}
					}
	
					index++;
				}
	
				if (replacementParts != null && replacementPos != res.Length) {
                    ILOG.J2CsMapping.Collections.Generics.Collections.Add(replacementParts, res.ToString().Substring(replacementPos,
                                            res.Length - replacementPos));
				}
				return res.ToString();
			}
		}
	
		
		/// @com.intel.drl.spec_ref
		public Matcher Reset(String newSequence) {
			if (newSequence == null) {
				throw new NullReferenceException("regex.01"); //$NON-NLS-1$
			}
			this.str0 = newSequence;
			return Reset();
		}
	
		
		/// @com.intel.drl.spec_ref
		public Matcher Reset() {
			this.leftBound = 0;
			this.rightBound = str0.Length;
			matchResult.Reset(str0, leftBound, rightBound);
			appendPos = 0;
			replacement = null;
			matchResult.previousMatch = -1;
			return this;
		}
	
		
		/// @com.intel.drl.spec_ref
		public Matcher Region(int leftBound_0, int rightBound_1) {
	
			if (leftBound_0 > rightBound_1 || leftBound_0 < 0 || rightBound_1 < 0
					|| leftBound_0 > str0.Length || rightBound_1 > str0.Length) {
				throw new IndexOutOfRangeException("regex.02 "
									+ ILOG.J2CsMapping.Util.IlNumber.ToString(leftBound_0)
									+ ILOG.J2CsMapping.Util.IlNumber.ToString(rightBound_1).ToString());
			}
	
			this.leftBound = leftBound_0;
			this.rightBound = rightBound_1;
			matchResult.Reset(null, leftBound_0, rightBound_1);
			appendPos = 0;
			replacement = null;
	
			return this;
		}
	
		/// <summary>
		/// TODO: appendTail(StringBuffer) javadoc
		/// </summary>
		///
		/// <param name="sb"></param>
		/// <returns></returns>
		public StringBuilder AppendTail(StringBuilder sb) {
            return sb.Append(str0.Substring(appendPos, str0.Length - appendPos));
		}
	
		/// <summary>
		/// This is very similar to replaceAll except only the first occurrence of a
		/// sequence matching the pattern is replaced.
		/// </summary>
		///
		/// <param name="replacement_0">A string to replace occurrences of character sequencesmatching the pattern.</param>
		/// <returns>A new string with replacements inserted</returns>
		public String ReplaceFirst(String replacement_0) {
			Reset();
			if (this.Find()) {
				StringBuilder sb = new StringBuilder();
				AppendReplacement(sb, replacement_0);
				return AppendTail(sb).ToString();
			}
	
			return str0.ToString();
	
		}
	
		/// <summary>
		/// Replace all occurrences of character sequences which match the pattern
		/// with the given replacement string. The replacement string may refer to
		/// capturing groups using the syntax "$<group number>".
		/// </summary>
		///
		/// <param name="replacement_0">A string to replace occurrences of character sequencesmatching the pattern.</param>
		/// <returns>A new string with replacements inserted</returns>
		public String ReplaceAll(String replacement_0) {
			StringBuilder sb = new StringBuilder();
			Reset();
			while (this.Find()) {
				AppendReplacement(sb, replacement_0);
			}
	
			return AppendTail(sb).ToString();
		}
	
		/// <summary>
		/// Return a reference to the pattern used by this Matcher.
		/// </summary>
		///
		/// <returns>A reference to the pattern used by this Matcher.</returns>
		public Pattern Pattern() {
			return pat;
		}
	
		
		/// @com.intel.drl.spec_ref
		public String Group(int groupIndex) {
			return matchResult.Group(groupIndex);
		}
	
		
		/// @com.intel.drl.spec_ref
		public String Group() {
			return this.Group(0);
		}
	
		
		/// @com.intel.drl.spec_ref
		public bool Find(int startIndex) {
			int stringLength = str0.Length;
			if (startIndex < 0 || startIndex > stringLength)
				throw new IndexOutOfRangeException("regex.03" + //$NON-NLS-1$ 
									((int)(startIndex)).ToString());
	
			startIndex = FindAt(startIndex);
			if (startIndex >= 0 && matchResult.IsValid()) {
				matchResult.FinalizeMatch();
				return true;
			}
			matchResult.startIndex = -1;
			return false;
		}
	
		private int FindAt(int startIndex) {
			matchResult.Reset();
			matchResult.SetMode(Matcher.MODE_FIND);
			matchResult.SetStartIndex(startIndex);
			int foundIndex = start.Find(startIndex, str0, matchResult);
			if (foundIndex == -1) {
				matchResult.hitEnd = true;
			}
			return foundIndex;
		}
	
		/// <summary>
		/// The find() method matches the pattern against the character sequence
		/// beginning at the character after the last match or at the beginning of
		/// the sequence if called immediately after reset(). The method returns true
		/// if and only if a match is found.
		/// </summary>
		///
		/// <returns>A boolean indicating if the pattern was matched.</returns>
		public bool Find() {
			int length = str0.Length;
			if (!HasTransparentBounds())
				length = rightBound;
			if (matchResult.startIndex >= 0
					&& matchResult.Mode() == Matcher.MODE_FIND) {
				matchResult.startIndex = matchResult.End();
				if (matchResult.End() == matchResult.Start()) {
					matchResult.startIndex++;
				}
	
				return (matchResult.startIndex <= length) ? Find(matchResult.startIndex)
						: false;
			} else {
				return Find(leftBound);
			}
		}
	
		
		/// @com.intel.drl.spec_ref
		public int Start(int groupIndex) {
			return matchResult.Start(groupIndex);
		}
	
		
		/// @com.intel.drl.spec_ref
		public int End(int groupIndex) {
			return matchResult.End(groupIndex);
		}
	
		/// <summary>
		/// This method is identical in function to the Pattern.matches() method. It
		/// returns true if and only if the regular expression pattern matches the
		/// entire input character sequence.
		/// </summary>
		///
		/// <returns>A boolean indicating if the pattern matches the entire input
		/// character sequence.</returns>
		public bool Matches() {
			return LookingAt(leftBound, Matcher.MODE_MATCH);
		}
	
		
		/// @com.intel.drl.spec_ref
		public static String QuoteReplacement(String str0) {
			// first check whether we have smth to quote
			if (str0.IndexOf('\\') < 0 && str0.IndexOf('$') < 0)
				return str0;
			StringBuilder res = new StringBuilder(str0.Length * 2);
			char ch;
			int len = str0.Length;
	
			for (int i = 0; i < len; i++) {
	
				switch (str0[i]) {
				case '$':
					res.Append('\\');
					res.Append('$');
					break;
				case '\\':
					res.Append('\\');
					res.Append('\\');
					break;
				default:
                    ch = str0[i];
					res.Append(ch);
					break;
				}
			}
	
			return res.ToString();
		}
	
		/// <summary>
		/// Runs match starting from <c>set</c> specified against input
		/// sequence starting at <c>index</c> specified; Result of the match
		/// will be stored into matchResult instance;
		/// </summary>
		///
		private bool RunMatch(AbstractSet set, int index,
				MatchResultImpl matchResult_0) {
	
			if (set.Matches(index, str0, matchResult_0) >= 0) {
				matchResult_0.FinalizeMatch();
				return true;
			}
	
			return false;
		}
	
		/// <summary>
		/// This method attempts to match the pattern against the character sequence
		/// starting at the beginning. If the pattern matches even a prefix of the
		/// input character sequence, lookingAt() will return true. Otherwise it will
		/// return false.
		/// </summary>
		///
		/// <returns>A boolean indicating if the pattern matches a prefix of the input
		/// character sequence.</returns>
		public bool LookingAt() {
			return LookingAt(leftBound, Matcher.MODE_FIND);
		}
	
		private bool LookingAt(int startIndex, int mode) {
			matchResult.Reset();
			matchResult.SetMode(mode);
			matchResult.SetStartIndex(startIndex);
			return RunMatch(start, startIndex, matchResult);
		}
	
		
		/// @com.intel.drl.spec_ref
		public int Start() {
			return Start(0);
		}
	
		/// <summary>
		/// Return the number of capturing groups in the pattern.
		/// </summary>
		///
		/// <returns>The number of capturing groups in the pattern.</returns>
		public int GroupCount() {
			return matchResult.GroupCount();
		}
	
		
		/// @com.intel.drl.spec_ref
		public int End() {
			return End(0);
		}
	
		
		/// @com.intel.drl.spec_ref
		public MatchResult ToMatchResult() {
			return this.matchResult.CloneImpl();
		}
	
		
		/// @com.intel.drl.spec_ref
		public Matcher UseAnchoringBounds(bool value_ren) {
			matchResult.UseAnchoringBounds(value_ren);
			return this;
		}
	
		
		/// @com.intel.drl.spec_ref
		public bool HasAnchoringBounds() {
			return matchResult.HasAnchoringBounds();
		}
	
		
		/// @com.intel.drl.spec_ref
		public Matcher UseTransparentBounds(bool value_ren) {
			matchResult.UseTransparentBounds(value_ren);
			return this;
		}
	
		
		/// @com.intel.drl.spec_ref
		public bool HasTransparentBounds() {
			return matchResult.HasTransparentBounds();
		}
	
		
		/// @com.intel.drl.spec_ref
		public int RegionStart() {
			return matchResult.GetLeftBound();
		}
	
		
		/// @com.intel.drl.spec_ref
		public int RegionEnd() {
			return matchResult.GetRightBound();
		}
	
		
		/// @com.intel.drl.spec_ref
		public bool RequireEnd() {
			return matchResult.requireEnd;
		}
	
		
		/// @com.intel.drl.spec_ref
		public bool HitEnd() {
			return matchResult.hitEnd;
		}
	
		
		/// @com.intel.drl.spec_ref
		public Matcher UsePattern(Pattern pat_0) {
			if (pat_0 == null) {
				throw new ArgumentException("regex.1B");
			}
			int startIndex = matchResult.GetPreviousMatchEnd();
			int mode = matchResult.Mode();
			this.pat = pat_0;
			this.start = pat_0.start;
			matchResult = new MatchResultImpl(this.str0, leftBound, rightBound,
					pat_0.GroupCount(), pat_0.CompCount(), pat_0.ConsCount());
			matchResult.SetStartIndex(startIndex);
			matchResult.SetMode(mode);
			return this;
		}
	
		internal Matcher(Pattern pat_0, String cs) {
			this.pat = null;
			this.start = null;
			this.str0 = null;
			this.matchResult = null;
			this.leftBound = -1;
			this.rightBound = -1;
			this.appendPos = 0;
			this.replacement = null;
			this.processedRepl = null;
			this.replacementParts = null;
			this.pat = pat_0;
			this.start = pat_0.start;
			this.str0 = cs;
			this.leftBound = 0;
			this.rightBound = str0.Length;
			matchResult = new MatchResultImpl(cs, leftBound, rightBound,
					pat_0.GroupCount(), pat_0.CompCount(), pat_0.ConsCount());
		}
	}
}
