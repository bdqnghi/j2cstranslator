/*
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 11/30/10 3:38 PM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace ILOG.J2CsMapping.RegEx {
	
	using ILOG.J2CsMapping.IO;
	using ILOG.J2CsMapping.Text;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Runtime.Serialization;
	using System.Text;
     using ILOG.J2CsMapping.Util;
	
	/// <summary>
	/// Pattern implements a compiler for regular expressions as defined by the J2SE
	/// specification. The regular expression syntax is largely similar to the syntax
	/// defined by Perl 5 but has both omissions and extensions. A formal and
	/// complete definition of the regular expression syntax is not provided by the
	/// J2SE speTBD (TODO)
	/// </summary>
	///
	[Serializable]
	public class Pattern {
	
		private const long serialVersionUID = 5073258162644648461L;
	
		internal const bool _DEBUG_ = false;
	
		
		/// @com.intel.drl.spec_ref
		public const int UNIX_LINES = 1 << 0;
	
		
		/// @com.intel.drl.spec_ref
		public const int CASE_INSENSITIVE = 1 << 1;
	
		
		/// @com.intel.drl.spec_ref
		public const int COMMENTS = 1 << 2;
	
		
		/// @com.intel.drl.spec_ref
		public const int MULTILINE = 1 << 3;
	
		
		/// @com.intel.drl.spec_ref
		public const int LITERAL = 1 << 4;
	
		
		/// @com.intel.drl.spec_ref
		public const int DOTALL = 1 << 5;
	
		
		/// @com.intel.drl.spec_ref
		public const int UNICODE_CASE = 1 << 6;
	
		
		/// @com.intel.drl.spec_ref
		public const int CANON_EQ = 1 << 7;
	
		internal const int BACK_REF_NUMBER = 10;
	
		/// <summary>
		/// Bit mask that includes all defined match flags
		/// </summary>
		///
        internal const int flagsBitMask = ILOG.J2CsMapping.RegEx.Pattern.UNIX_LINES
                | ILOG.J2CsMapping.RegEx.Pattern.CASE_INSENSITIVE | ILOG.J2CsMapping.RegEx.Pattern.COMMENTS | ILOG.J2CsMapping.RegEx.Pattern.MULTILINE
                | ILOG.J2CsMapping.RegEx.Pattern.LITERAL | ILOG.J2CsMapping.RegEx.Pattern.DOTALL | ILOG.J2CsMapping.RegEx.Pattern.UNICODE_CASE
                | ILOG.J2CsMapping.RegEx.Pattern.CANON_EQ;
	
		/// <summary>
		/// Current <c>pattern</c> to be compiled;
		/// </summary>
		///
		private Lexer lexemes;
	
		/// <summary>
		/// Pattern compile flags;
		/// </summary>
		///
		private int flags;
	
		private String pattern;
	
		private FSet[] backRefs;
	
		/*
		 * Is true if backreferenced sets replacement is needed
		 */
		private bool needsBackRefReplacement;
	
		private int groupIndex;
	
		private int globalGroupIndex;
	
		private int compCount;
	
		private int consCount;
	
		internal AbstractSet start;
	
		/// <summary>
		/// Create a matcher for this pattern and a given input character sequence
		/// </summary>
		///
		/// <param name="cs">The input character sequence</param>
		/// <returns>A new matcher</returns>
		public Matcher Matcher(String cs) {
			return new Matcher(this, cs);
		}
	
		/// <summary>
		/// Split an input string using the pattern as a token separator.
		/// </summary>
		///
		/// <param name="input">Input sequence to tokenize</param>
		/// <param name="limit">If positive, the maximum number of tokens to return. Ifnegative, an indefinite number of tokens are returned. Ifzero, an indefinite number of tokens are returned but trailingempty tokens are excluded.</param>
		/// <returns>A sequence of tokens split out of the input string.</returns>
		public String[] Split(String input, int limit) {
			ArrayList res = new ArrayList();
			Matcher mat = this.Matcher(input);
			int index = 0;
			int curPos = 0;
	
			if (input.Length == 0) {
				return new String[] { "" }; //$NON-NLS-1$
			} else {
				while (mat.Find() && (index + 1 < limit || limit <= 0)) {
                    ILOG.J2CsMapping.Collections.Generics.Collections.Add(res, input.Substring(curPos, mat.Start() - curPos).ToString());
					curPos = mat.End();
					index++;
				}

                ILOG.J2CsMapping.Collections.Generics.Collections.Add(res, input.Substring(curPos, input.Length - curPos).ToString());
				index++;
	
				/*
				 * discard trailing empty strings
				 */
				if (limit == 0) {
					while (--index >= 0 && res[index].ToString().Length == 0) {
						ILOG.J2CsMapping.Collections.Collections.RemoveAt(res,index);
					}
				}
			}
			return (String[]) ILOG.J2CsMapping.Collections.Generics.Collections.ToArray(res,new String[(index >= 0) ? index : 0]);
		}
	
		
		/// @com.intel.drl.spec_ref
		public String[] Split(String input) {
			return Split(input, 0);
		}
	
		/// <summary>
		/// Returns the pattern string passed to the compile method
		/// </summary>
		///
		/// <returns>A string representation of the pattern</returns>
		public String PatternString() {
			return lexemes.ToString();
		}
	
		/// <summary>
		/// Return a textual representation of the pattern.
		/// </summary>
		///
		/// <returns>The regular expression string</returns>
		public override String ToString() {
			return this.PatternString();
		}
	
		/// <summary>
		/// Return the mask of flags used to compile the pattern
		/// </summary>
		///
		/// <returns>A mask of flags used to compile the pattern.</returns>
		public int Flags() {
			return this.flags;
		}
	
		/// <summary>
		/// Return a compiled pattern corresponding to the input regular expression
		/// string.
		/// The input <c>flags</c> is a mask of the following flags:
		/// <dl>
		/// <dt><c>UNIX_LINES</c> (0x0001)
		/// <dd>Enables UNIX lines mode where only \n is recognized as a line
		/// terminator. The default setting of this flag is <em>off</em> indicating
		/// that all of the following character sequences are recognized as line
		/// terminators: \n, \r, \r\n, NEL (&#92;u0085), &#92;u2028 and &#92;u2029.
		/// <dt><c>CASE_INSENSITIVE</c> (0x0002)
		/// <dd>Directs matching to be done in a way that ignores differences in
		/// case. If input character sequences are encoded in character sets other
		/// than ASCII, then the UNICODE_CASE must also be set to enable Unicode case
		/// detection.
		/// <dt><c>UNICODE_CASE</c> (0x0040)
		/// <dd>Enables Unicode case folding if used in conjunction with the
		/// <c>CASE_INSENSITIVE</c> flag. If <c>CASE_INSENSITIVE</c>
		/// is not set, then this flag has no effect.
		/// <dt><c>COMMENTS</c> (0x0004)
		/// <dd>Directs the pattern compiler to ignore whitespace and comments in
		/// the pattern. Whitespace consists of sequences including only these
		/// characters: SP (&#92;u0020), HT (\t or &#92;u0009), LF (\n or ), VT
		/// (&#92;u000b), FF (\f or &#92;u000c), and CR (\r or ). A comment is any
		/// sequence of characters beginning with the "#" (&#92;u0023) character and
		/// ending in a LF character.
		/// <dt><c>MULTILINE</c> (0x0008)
		/// <dd>Turns on multiple line mode for matching of character sequences. By
		/// default, this mode is off so that the character "^" (&#92;u005e) matches
		/// the beginning of the entire input sequence and the character "$"
		/// (&#92;u0024) matches the end of the input character sequence. In multiple
		/// line mode, the character "^" matches any character in the input sequence
		/// which immediately follows a line terminator and the character "$" matches
		/// any character in the input sequence which immediately precedes a line
		/// terminator.
		/// <dt><c>DOTALL</c> (0x0020)
		/// <dd>Enables the DOT (".") character in regular expressions to match line
		/// terminators. By default, line terminators are not matched by DOT.
		/// <dt><c>CANON_EQ</c> (0x0080)
		/// <dd>Enables matching of character sequences which are canonically
		/// equivalent according to the Unicode standard. Canonical equivalence is
		/// described here: http://www.unicode.org/reports/tr15/. By default,
		/// canonical equivalence is not detected while matching.
		/// </dl>
		/// </summary>
		///
		/// <param name="regex">A regular expression string.</param>
		/// <param name="flags_0">A set of flags to control the compilation of the pattern.</param>
		/// <returns>A compiled pattern</returns>
		/// <exception cref="PatternSyntaxException">If the input regular expression does not match the requiredgrammar.</exception>
		public static Pattern Compile(String regex, int flags_0) {
	
			if ((flags_0 != 0) && ((flags_0 | flagsBitMask) != flagsBitMask)) {
	
				throw new ArgumentException("regex.1C");
			}
	
			ILOG.J2CsMapping.RegEx.AbstractSet.counter = 1;
	
			return new Pattern().CompileImpl(regex, flags_0);
		}
	
		
		/// <param name="pattern">-Regular expression to be compiled</param>
		/// <param name="flags_0">-The bit mask including CASE_INSENSITIVE, MULTILINE, DOTALL,UNICODE_CASE, and CANON_EQ</param>
		/// <returns>Compiled pattern</returns>
		private Pattern CompileImpl(String regex, int flags_0) {
			this.lexemes = new Lexer(regex, flags_0);
			this.flags = flags_0;
			this.pattern = regex;
	
			start = ProcessExpression(-1, this.flags, null);
			if (!lexemes.IsEmpty()) {
				throw new PatternSyntaxException("regex.08", lexemes.ToString(), //$NON-NLS-1$
						lexemes.GetIndex());
			}
			FinalizeCompile();
			return this;
		}
	
		/// <summary>
		/// A->(a|)+
		/// </summary>
		///
		private AbstractSet ProcessAlternations(AbstractSet last) {
            CharClass auxRange = new CharClass(HasFlag(ILOG.J2CsMapping.RegEx.Pattern.CASE_INSENSITIVE),
                    HasFlag(ILOG.J2CsMapping.RegEx.Pattern.UNICODE_CASE));
			while (!lexemes.IsEmpty()
					&& lexemes.IsLetter()
					&& (lexemes.LookAhead() == 0
							|| lexemes.LookAhead() == ILOG.J2CsMapping.RegEx.Lexer.CHAR_VERTICAL_BAR || lexemes
							.LookAhead() == ILOG.J2CsMapping.RegEx.Lexer.CHAR_RIGHT_PARENTHESIS)) {
				auxRange.Add(lexemes.Next());
				if (lexemes.Peek() == ILOG.J2CsMapping.RegEx.Lexer.CHAR_VERTICAL_BAR)
					lexemes.Next();
			}
			AbstractSet rangeSet = ProcessRangeSet(auxRange);
			rangeSet.SetNext(last);
	
			return rangeSet;
		}
	
		/// <summary>
		/// E->AE; E->S|E; E->S; A->(a|)+ E->S(|S)
		/// </summary>
		///
		private AbstractSet ProcessExpression(int ch, int newFlags, AbstractSet last) {
			ArrayList children = new ArrayList();
			AbstractSet child;
			int saveFlags = flags;
			FSet fSet;
			bool saveChangedFlags = false;
	
			if (newFlags != flags) {
				flags = newFlags;
			}
	
			switch (ch) {
			case ILOG.J2CsMapping.RegEx.Lexer.CHAR_NONCAP_GROUP:
				fSet = new NonCapFSet(++consCount);
				break;
	
			case ILOG.J2CsMapping.RegEx.Lexer.CHAR_POS_LOOKAHEAD:
				/* falls through */
	
			case ILOG.J2CsMapping.RegEx.Lexer.CHAR_NEG_LOOKAHEAD:
				fSet = new AheadFSet();
				break;
	
			case ILOG.J2CsMapping.RegEx.Lexer.CHAR_POS_LOOKBEHIND:
				/* falls through */
	
			case ILOG.J2CsMapping.RegEx.Lexer.CHAR_NEG_LOOKBEHIND:
				fSet = new BehindFSet(++consCount);
				break;
	
			case ILOG.J2CsMapping.RegEx.Lexer.CHAR_ATOMIC_GROUP:
				fSet = new AtomicFSet(++consCount);
				break;
	
			default:
				globalGroupIndex++;
				if (last == null) {
	
					// expr = new StartSet();
					fSet = new FinalSet();
					saveChangedFlags = true;
				} else {
	
					// expr = new JointSet(globalGroupIndex);
					fSet = new FSet(globalGroupIndex);
				}
				if (globalGroupIndex > -1 && globalGroupIndex < 10) {
					backRefs[globalGroupIndex] = fSet;
				}
				break;
			}
	
			do {
				if (lexemes.IsLetter()
						&& lexemes.LookAhead() == ILOG.J2CsMapping.RegEx.Lexer.CHAR_VERTICAL_BAR) {
					child = ProcessAlternations(fSet);
				} else if (lexemes.Peek() == ILOG.J2CsMapping.RegEx.Lexer.CHAR_VERTICAL_BAR) {
					child = new EmptySet(fSet);
					lexemes.Next();
				} else {
					child = ProcessSubExpression(fSet);
					if (lexemes.Peek() == ILOG.J2CsMapping.RegEx.Lexer.CHAR_VERTICAL_BAR) {
						lexemes.Next();
					}
				}
				if (child != null) {
	
					//expr.addChild(child);
					ILOG.J2CsMapping.Collections.Generics.Collections.Add(children,child);
				}
			} while (!(lexemes.IsEmpty() || (lexemes.Peek() == ILOG.J2CsMapping.RegEx.Lexer.CHAR_RIGHT_PARENTHESIS)));
	
			if (lexemes.Back() == ILOG.J2CsMapping.RegEx.Lexer.CHAR_VERTICAL_BAR) {
				ILOG.J2CsMapping.Collections.Generics.Collections.Add(children,new EmptySet(fSet));
			}
	
			if (flags != saveFlags && !saveChangedFlags) {
				flags = saveFlags;
				lexemes.RestoreFlags(flags);
			}
	
			switch (ch) {
			case ILOG.J2CsMapping.RegEx.Lexer.CHAR_NONCAP_GROUP:
				return new NonCapJointSet(children, fSet);
	
			case ILOG.J2CsMapping.RegEx.Lexer.CHAR_POS_LOOKAHEAD:
				return new PositiveLookAhead(children, fSet);
	
			case ILOG.J2CsMapping.RegEx.Lexer.CHAR_NEG_LOOKAHEAD:
				return new NegativeLookAhead(children, fSet);
	
			case ILOG.J2CsMapping.RegEx.Lexer.CHAR_POS_LOOKBEHIND:
				return new PositiveLookBehind(children, fSet);
	
			case ILOG.J2CsMapping.RegEx.Lexer.CHAR_NEG_LOOKBEHIND:
				return new NegativeLookBehind(children, fSet);
	
			case ILOG.J2CsMapping.RegEx.Lexer.CHAR_ATOMIC_GROUP:
				return new AtomicJointSet(children, fSet);
	
			default:
				switch (children.Count) {
				case 0:
					return new EmptySet(fSet);
	
				case 1:
					return new SingleSet((AbstractSet) children[0], fSet);
	
				default:
					return new JointSet(children, fSet);
				}
				break;
			}
		}
	
		/// <summary>
		/// T->a+
		/// </summary>
		///
		private AbstractSet ProcessSequence(AbstractSet last) {
			StringBuilder substring = new StringBuilder();
	
			while (!lexemes.IsEmpty()
					&& lexemes.IsLetter()
					&& !lexemes.IsHighSurrogate()
					&& !lexemes.IsLowSurrogate()
					&& ((!lexemes.IsNextSpecial() && lexemes.LookAhead() == 0) // end
							// of
							// pattern
							|| (!lexemes.IsNextSpecial() && ILOG.J2CsMapping.RegEx.Lexer.IsLetter(lexemes
									.LookAhead()))
							|| lexemes.LookAhead() == ILOG.J2CsMapping.RegEx.Lexer.CHAR_RIGHT_PARENTHESIS
							|| (lexemes.LookAhead() & -2147418113) == ILOG.J2CsMapping.RegEx.Lexer.CHAR_LEFT_PARENTHESIS
							|| lexemes.LookAhead() == ILOG.J2CsMapping.RegEx.Lexer.CHAR_VERTICAL_BAR || lexemes
							.LookAhead() == ILOG.J2CsMapping.RegEx.Lexer.CHAR_DOLLAR)) {
				int ch = lexemes.Next();

                if (Character.IsSupplementaryCodePoint(ch))
                {
                    substring.Append(Character.ToChars(ch));
				} else {
					substring.Append((char) ch);
				}
			}
            if (!HasFlag(ILOG.J2CsMapping.RegEx.Pattern.CASE_INSENSITIVE))
            {
				return new SequenceSet(substring);
            }
            else if (!HasFlag(ILOG.J2CsMapping.RegEx.Pattern.UNICODE_CASE))
            {
				return new CISequenceSet(substring);
			} else {
				return new UCISequenceSet(substring);
			}
		}
	
		/// <summary>
		/// D->a
		/// </summary>
		///
		private AbstractSet ProcessDecomposedChar(AbstractSet last) {
			int[] codePoints = new int[ILOG.J2CsMapping.RegEx.Lexer.MAX_DECOMPOSITION_LENGTH];
			char[] codePointsHangul;
			int readCodePoints = 0;
			int curSymb = -1;
			int curSymbIndex = -1;
	
			if (!lexemes.IsEmpty() && lexemes.IsLetter()) {
				curSymb = lexemes.Next();
				codePoints[readCodePoints] = curSymb;
				curSymbIndex = curSymb - ILOG.J2CsMapping.RegEx.Lexer.LBase;
			}
	
			/*
			 * We process decomposed Hangul syllable LV or LVT or process jamo L.
			 * See http://www.unicode.org/versions/Unicode4.0.0/ch03.pdf
			 * "3.12 Conjoining Jamo Behavior"
			 */
			if ((curSymbIndex >= 0) && (curSymbIndex < ILOG.J2CsMapping.RegEx.Lexer.LCount)) {
				codePointsHangul = new char[ILOG.J2CsMapping.RegEx.Lexer.MAX_HANGUL_DECOMPOSITION_LENGTH];
				codePointsHangul[readCodePoints++] = (char) curSymb;
	
				curSymb = lexemes.Peek();
				curSymbIndex = curSymb - ILOG.J2CsMapping.RegEx.Lexer.VBase;
				if ((curSymbIndex >= 0) && (curSymbIndex < ILOG.J2CsMapping.RegEx.Lexer.VCount)) {
					codePointsHangul[readCodePoints++] = (char) curSymb;
					lexemes.Next();
					curSymb = lexemes.Peek();
					curSymbIndex = curSymb - ILOG.J2CsMapping.RegEx.Lexer.TBase;
					if ((curSymbIndex >= 0) && (curSymbIndex < ILOG.J2CsMapping.RegEx.Lexer.TCount)) {
						codePointsHangul[readCodePoints++] = (char) curSymb;
						lexemes.Next();
	
						//LVT syllable
						return new HangulDecomposedCharSet(codePointsHangul, 3);
					} else {
	
						//LV syllable
						return new HangulDecomposedCharSet(codePointsHangul, 2);
					}
				} else {
	
					//L jamo
                    if (!HasFlag(ILOG.J2CsMapping.RegEx.Pattern.CASE_INSENSITIVE))
                    {
						return new CharSet(codePointsHangul[0]);
                    }
                    else if (!HasFlag(ILOG.J2CsMapping.RegEx.Pattern.UNICODE_CASE))
                    {
						return new CICharSet(codePointsHangul[0]);
					} else {
						return new UCICharSet(codePointsHangul[0]);
					}
				}
	
				/*
				 * We process single codepoint or decomposed codepoint.
				 * We collect decomposed codepoint and obtain 
				 * one DecomposedCharSet.
				 */
			} else {
				readCodePoints++;
	
				while ((readCodePoints < ILOG.J2CsMapping.RegEx.Lexer.MAX_DECOMPOSITION_LENGTH)
						&& !lexemes.IsEmpty() && lexemes.IsLetter()
						&& !ILOG.J2CsMapping.RegEx.Lexer.IsDecomposedCharBoundary(lexemes.Peek())) {
					codePoints[readCodePoints++] = lexemes.Next();
				}
	
				/*
				 * We have read an ordinary symbol.
				 */
				if (readCodePoints == 1
						&& !ILOG.J2CsMapping.RegEx.Lexer.HasSingleCodepointDecomposition(codePoints[0])) {
					return ProcessCharSet(codePoints[0]);
				} else {
                    if (!HasFlag(ILOG.J2CsMapping.RegEx.Pattern.CASE_INSENSITIVE))
                    {
						return new DecomposedCharSet(codePoints, readCodePoints);
                    }
                    else if (!HasFlag(ILOG.J2CsMapping.RegEx.Pattern.UNICODE_CASE))
                    {
						return new CIDecomposedCharSet(codePoints, readCodePoints);
					} else {
						return new UCIDecomposedCharSet(codePoints, readCodePoints);
					}
				}
			}
		}
	
		/// <summary>
		/// S->BS; S->QS; S->Q; B->a+
		/// </summary>
		///
		private AbstractSet ProcessSubExpression(AbstractSet last) {
			AbstractSet cur;
			if (lexemes.IsLetter() && !lexemes.IsNextSpecial()
					&& ILOG.J2CsMapping.RegEx.Lexer.IsLetter(lexemes.LookAhead())) {
                        if (HasFlag(ILOG.J2CsMapping.RegEx.Pattern.CANON_EQ))
                        {
					cur = ProcessDecomposedChar(last);
					if (!lexemes.IsEmpty()
	
							/* && !pattern.isQuantifier() */
							&& (lexemes.Peek() != ILOG.J2CsMapping.RegEx.Lexer.CHAR_RIGHT_PARENTHESIS || last  is  FinalSet)
							&& lexemes.Peek() != ILOG.J2CsMapping.RegEx.Lexer.CHAR_VERTICAL_BAR
							&& !lexemes.IsLetter()) {
						cur = ProcessQuantifier(last, cur);
					}
				} else if (lexemes.IsHighSurrogate() || lexemes.IsLowSurrogate()) {
					AbstractSet term = ProcessTerminal(last);
					cur = ProcessQuantifier(last, term);
				} else {
					cur = ProcessSequence(last);
				}
			} else if (lexemes.Peek() == ILOG.J2CsMapping.RegEx.Lexer.CHAR_RIGHT_PARENTHESIS) {
				if (last  is  FinalSet) {
					throw new PatternSyntaxException(
							"regex.09", lexemes.ToString(), //$NON-NLS-1$
							lexemes.GetIndex());
				} else {
					cur = new EmptySet(last);
				}
			} else {
				AbstractSet term_0 = ProcessTerminal(last);
				cur = ProcessQuantifier(last, term_0);
			}
	
			if (!lexemes.IsEmpty()
					// && !pattern.isQuantifier()
					&& (lexemes.Peek() != ILOG.J2CsMapping.RegEx.Lexer.CHAR_RIGHT_PARENTHESIS || last  is  FinalSet)
					&& lexemes.Peek() != ILOG.J2CsMapping.RegEx.Lexer.CHAR_VERTICAL_BAR) {
				AbstractSet next = ProcessSubExpression(last);
				if (cur  is  LeafQuantifierSet
						// TODO create personal UnifiedQuantifierSet for composite
						// quantifiers
						// to take into account Quantifier counters
						// ////
						&& !(cur  is  CompositeQuantifierSet)
						&& !(cur  is  GroupQuantifierSet)
						&& !(cur  is  AltQuantifierSet)
						&& !next.First(((LeafQuantifierSet) cur).GetInnerSet())) {
					cur = new UnifiedQuantifierSet((LeafQuantifierSet) cur);
				}
				if (((char) next.GetType()) == '+') {
					cur.SetNext(((LeafQuantifierSet) next).GetInnerSet());
				} else {
					cur.SetNext(next);
				}
			} else if (cur != null) {
				cur.SetNext(last);
			} else {
				return null;
			}
	
			if (((char) cur.GetType()) == '+') {
				return ((QuantifierSet) cur).GetInnerSet();
			} else {
				return cur;
			}
		}
	
		/// <summary>
		/// Q->T(///|+|?...) also do some optimizations.
		/// </summary>
		///
		private AbstractSet ProcessQuantifier(AbstractSet last, AbstractSet term) {
			int quant = lexemes.Peek();
	
			if (term != null && !(term  is  LeafSet)) {
				switch (quant) {
				case ILOG.J2CsMapping.RegEx.Lexer.QUANT_STAR:
				case ILOG.J2CsMapping.RegEx.Lexer.QUANT_PLUS: {
					QuantifierSet q;
	
					lexemes.Next();
					if (term.GetType() == ILOG.J2CsMapping.RegEx.AbstractSet.TYPE_DOTSET) {
                        if (!HasFlag(ILOG.J2CsMapping.RegEx.Pattern.DOTALL))
                        {
							q = new DotQuantifierSet(term, last, quant,
									ILOG.J2CsMapping.RegEx.AbstractLineTerminator.GetInstance(flags));
						} else {
							q = new DotAllQuantifierSet(term, last, quant);
						}
					} else {
						q = new GroupQuantifierSet(term, last, quant);
					}
					term.SetNext(q);
					return q;
				}
	
				case ILOG.J2CsMapping.RegEx.Lexer.QUANT_STAR_R:
				case ILOG.J2CsMapping.RegEx.Lexer.QUANT_PLUS_R: {
					lexemes.Next();
					GroupQuantifierSet q_0 = new ReluctantGroupQuantifierSet(term,
							last, quant);
					term.SetNext(q_0);
					return q_0;
				}
	
				case ILOG.J2CsMapping.RegEx.Lexer.QUANT_PLUS_P: {
					lexemes.Next();
					// possessive plus will be handled by unique class
					// and should not be postprocessed to point previous set
					// to the inner one.
					// //
					return new PosPlusGroupQuantifierSet(term, last,
							ILOG.J2CsMapping.RegEx.Lexer.QUANT_STAR_P);
				}
	
				case ILOG.J2CsMapping.RegEx.Lexer.QUANT_STAR_P: {
					lexemes.Next();
					return new PossessiveGroupQuantifierSet(term, last, quant);
				}
	
				case ILOG.J2CsMapping.RegEx.Lexer.QUANT_ALT: {
					lexemes.Next();
					AltGroupQuantifierSet q_1 = new AltGroupQuantifierSet(term, last,
							ILOG.J2CsMapping.RegEx.Lexer.QUANT_ALT);
					term.SetNext(last);
					return q_1;
				}
	
				case ILOG.J2CsMapping.RegEx.Lexer.QUANT_ALT_P: {
					lexemes.Next();
					return new PosAltGroupQuantifierSet(term, last, ILOG.J2CsMapping.RegEx.Lexer.QUANT_ALT);
				}
	
				case ILOG.J2CsMapping.RegEx.Lexer.QUANT_ALT_R: {
					lexemes.Next();
					RelAltGroupQuantifierSet q_2 = new RelAltGroupQuantifierSet(term,
							last, ILOG.J2CsMapping.RegEx.Lexer.QUANT_ALT);
					term.SetNext(last);
					return q_2;
				}
	
				case ILOG.J2CsMapping.RegEx.Lexer.QUANT_COMP: {
					CompositeGroupQuantifierSet q_3 = new CompositeGroupQuantifierSet(
							(Quantifier) lexemes.NextSpecial(), term, last,
							ILOG.J2CsMapping.RegEx.Lexer.QUANT_ALT, ++compCount);
					term.SetNext(q_3);
					return q_3;
				}
	
				case ILOG.J2CsMapping.RegEx.Lexer.QUANT_COMP_P: {
					return new PosCompositeGroupQuantifierSet(
							(Quantifier) lexemes.NextSpecial(), term, last,
							ILOG.J2CsMapping.RegEx.Lexer.QUANT_ALT, ++compCount);
				}
	
				case ILOG.J2CsMapping.RegEx.Lexer.QUANT_COMP_R: {
					RelCompositeGroupQuantifierSet q_4 = new RelCompositeGroupQuantifierSet(
							(Quantifier) lexemes.NextSpecial(), term, last,
							ILOG.J2CsMapping.RegEx.Lexer.QUANT_ALT, ++compCount);
					term.SetNext(q_4);
					return q_4;
				}
	
				default:
					return term;
				}
			} else {
				LeafSet leaf = null;
				if (term != null)
					leaf = (LeafSet) term;
				switch (quant) {
				case ILOG.J2CsMapping.RegEx.Lexer.QUANT_STAR:
				case ILOG.J2CsMapping.RegEx.Lexer.QUANT_PLUS: {
					lexemes.Next();
					LeafQuantifierSet q_5 = new LeafQuantifierSet(leaf, last, quant);
					leaf.SetNext(q_5);
					return q_5;
				}
	
				case ILOG.J2CsMapping.RegEx.Lexer.QUANT_STAR_R:
				case ILOG.J2CsMapping.RegEx.Lexer.QUANT_PLUS_R: {
					lexemes.Next();
					ReluctantQuantifierSet q_6 = new ReluctantQuantifierSet(leaf,
							last, quant);
					leaf.SetNext(q_6);
					return q_6;
				}
	
				case ILOG.J2CsMapping.RegEx.Lexer.QUANT_PLUS_P:
				case ILOG.J2CsMapping.RegEx.Lexer.QUANT_STAR_P: {
					lexemes.Next();
					PossessiveQuantifierSet q_7 = new PossessiveQuantifierSet(leaf,
							last, quant);
					leaf.SetNext(q_7);
					return q_7;
				}
	
				case ILOG.J2CsMapping.RegEx.Lexer.QUANT_ALT: {
					lexemes.Next();
					return new AltQuantifierSet(leaf, last, ILOG.J2CsMapping.RegEx.Lexer.QUANT_ALT);
				}
	
				case ILOG.J2CsMapping.RegEx.Lexer.QUANT_ALT_P: {
					lexemes.Next();
					return new PossessiveAltQuantifierSet(leaf, last,
							ILOG.J2CsMapping.RegEx.Lexer.QUANT_ALT_P);
				}
	
				case ILOG.J2CsMapping.RegEx.Lexer.QUANT_ALT_R: {
					lexemes.Next();
					return new ReluctantAltQuantifierSet(leaf, last,
							ILOG.J2CsMapping.RegEx.Lexer.QUANT_ALT_R);
				}
	
				case ILOG.J2CsMapping.RegEx.Lexer.QUANT_COMP: {
					return new CompositeQuantifierSet(
							(Quantifier) lexemes.NextSpecial(), leaf, last,
							ILOG.J2CsMapping.RegEx.Lexer.QUANT_COMP);
				}
	
				case ILOG.J2CsMapping.RegEx.Lexer.QUANT_COMP_P: {
					return new PossessiveCompositeQuantifierSet(
							(Quantifier) lexemes.NextSpecial(), leaf, last,
							ILOG.J2CsMapping.RegEx.Lexer.QUANT_COMP_P);
				}
				case ILOG.J2CsMapping.RegEx.Lexer.QUANT_COMP_R: {
					return new ReluctantCompositeQuantifierSet(
							(Quantifier) lexemes.NextSpecial(), leaf, last,
							ILOG.J2CsMapping.RegEx.Lexer.QUANT_COMP_R);
				}
	
				default:
					return term;
				}
			}
		}
	
		/// <summary>
		/// T-> letter|[range]|{char-class}|(E)
		/// </summary>
		///
		private AbstractSet ProcessTerminal(AbstractSet last) {
			int ch;
			AbstractSet term = null;
			do {
				ch = lexemes.Peek();
				if ((ch & -2147418113) == ILOG.J2CsMapping.RegEx.Lexer.CHAR_LEFT_PARENTHESIS) {
					int newFlags;
					lexemes.Next();
					newFlags = (ch & 0x00ff0000) >> 16;
					ch = ch & -16711681;
					if (ch == ILOG.J2CsMapping.RegEx.Lexer.CHAR_FLAGS) {
						flags = newFlags;
					} else {
						newFlags = (ch == ILOG.J2CsMapping.RegEx.Lexer.CHAR_NONCAP_GROUP) ? newFlags
								: flags;
						term = ProcessExpression(ch, newFlags, last);
						if (lexemes.Peek() != ILOG.J2CsMapping.RegEx.Lexer.CHAR_RIGHT_PARENTHESIS) {
							throw new PatternSyntaxException(
									"regex.0A", lexemes.ToString(), //$NON-NLS-1$
									lexemes.GetIndex());
						}
						lexemes.Next();
					}
				} else
					switch (ch) {
					case ILOG.J2CsMapping.RegEx.Lexer.CHAR_LEFT_SQUARE_BRACKET: {
						lexemes.Next();
						bool negative = false;
						if (lexemes.Peek() == ILOG.J2CsMapping.RegEx.Lexer.CHAR_CARET) {
							negative = true;
							lexemes.Next();
						}
	
						term = ProcessRange(negative, last);
						if (lexemes.Peek() != ILOG.J2CsMapping.RegEx.Lexer.CHAR_RIGHT_SQUARE_BRACKET)
							throw new PatternSyntaxException(
									"regex.0B", lexemes.ToString(), //$NON-NLS-1$
									lexemes.GetIndex());
						lexemes.SetMode(ILOG.J2CsMapping.RegEx.Lexer.MODE_PATTERN);
						lexemes.Next();
						break;
					}
	
					case ILOG.J2CsMapping.RegEx.Lexer.CHAR_DOT: {
						lexemes.Next();

                        if (!HasFlag(ILOG.J2CsMapping.RegEx.Pattern.DOTALL))
                        {
							term = new DotSet(
									ILOG.J2CsMapping.RegEx.AbstractLineTerminator.GetInstance(flags));
						} else {
							term = new DotAllSet();
						}
	
						break;
					}
	
					case ILOG.J2CsMapping.RegEx.Lexer.CHAR_CARET: {
						lexemes.Next();
						consCount++;
                        if (!HasFlag(ILOG.J2CsMapping.RegEx.Pattern.MULTILINE))
                        {
							term = new SOLSet();
						} else {
							term = new MultiLineSOLSet(
									ILOG.J2CsMapping.RegEx.AbstractLineTerminator.GetInstance(flags));
						}
	
						break;
					}
	
					case ILOG.J2CsMapping.RegEx.Lexer.CHAR_DOLLAR: {
						lexemes.Next();
						consCount++;
                        if (!HasFlag(ILOG.J2CsMapping.RegEx.Pattern.MULTILINE))
                        {
                            if (!HasFlag(ILOG.J2CsMapping.RegEx.Pattern.UNIX_LINES))
                            {
								term = new EOLSet(consCount);
							} else {
								term = new UEOLSet(consCount);
							}
						} else {
                            if (!HasFlag(ILOG.J2CsMapping.RegEx.Pattern.UNIX_LINES))
                            {
								term = new MultiLineEOLSet(consCount);
							} else {
								term = new UMultiLineEOLSet(consCount);
							}
						}
	
						break;
					}
	
					case ILOG.J2CsMapping.RegEx.Lexer.CHAR_WORD_BOUND: {
						lexemes.Next();
						term = new WordBoundary(true);
						break;
					}
	
					case ILOG.J2CsMapping.RegEx.Lexer.CHAR_NONWORD_BOUND: {
						lexemes.Next();
						term = new WordBoundary(false);
						break;
					}
	
					case ILOG.J2CsMapping.RegEx.Lexer.CHAR_END_OF_INPUT: {
						lexemes.Next();
						term = new EOISet();
						break;
					}
	
					case ILOG.J2CsMapping.RegEx.Lexer.CHAR_END_OF_LINE: {
						lexemes.Next();
						term = new EOLSet(++consCount);
						break;
					}
	
					case ILOG.J2CsMapping.RegEx.Lexer.CHAR_START_OF_INPUT: {
						lexemes.Next();
						term = new SOLSet();
						break;
					}
	
					case ILOG.J2CsMapping.RegEx.Lexer.CHAR_PREVIOUS_MATCH: {
						lexemes.Next();
						term = new PreviousMatch();
						break;
					}
	
					case -2147483648 | '1':
					case -2147483648 | '2':
					case -2147483648 | '3':
					case -2147483648 | '4':
					case -2147483648 | '5':
					case -2147483648 | '6':
					case -2147483648 | '7':
					case -2147483648 | '8':
					case -2147483648 | '9': {
						int number = (ch & 0x7FFFFFFF) - '0';
						if (globalGroupIndex >= number) {
							lexemes.Next();
							consCount++;
                            if (!HasFlag(ILOG.J2CsMapping.RegEx.Pattern.CASE_INSENSITIVE))
                            {
								term = new BackReferenceSet(number, consCount);
                            }
                            else if (!HasFlag(ILOG.J2CsMapping.RegEx.Pattern.UNICODE_CASE))
                            {
								term = new CIBackReferenceSet(number, consCount);
							} else {
								term = new UCIBackReferenceSet(number, consCount);
							}
							(backRefs[number]).isBackReferenced = true;
							needsBackRefReplacement = true;
							break;
						} else {
							throw new PatternSyntaxException("regex.0C" //$NON-NLS-1$
									, lexemes.ToString(), lexemes.GetIndex());
						}
					}
	
						break;
					case 0: {
						AbstractCharClass cc = null;
						if ((cc = (AbstractCharClass) lexemes.PeekSpecial()) != null) {
							term = ProcessRangeSet(cc);
						} else if (!lexemes.IsEmpty()) {
	
							//ch == 0
							term = new CharSet((char) ch);
						} else {
							term = new EmptySet(last);
							break;
						}
						lexemes.Next();
						break;
					}
	
					default: {
						if (ch >= 0 && !lexemes.IsSpecial()) {
							term = ProcessCharSet(ch);
							lexemes.Next();
						} else if (ch == ILOG.J2CsMapping.RegEx.Lexer.CHAR_VERTICAL_BAR) {
							term = new EmptySet(last);
						} else if (ch == ILOG.J2CsMapping.RegEx.Lexer.CHAR_RIGHT_PARENTHESIS) {
							if (last  is  FinalSet) {
								throw new PatternSyntaxException(
										"regex.09", lexemes.ToString(), //$NON-NLS-1$
										lexemes.GetIndex());
							} else {
								term = new EmptySet(last);
							}
						} else {
							throw new PatternSyntaxException("regex.0D" + //$NON-NLS-1$
									((lexemes.IsSpecial()) ? lexemes.PeekSpecial()
											.ToString()
											: System.Char.ToString((char) ch)),
									lexemes.ToString(), lexemes.GetIndex());
						}
					}
						break;
					}
			} while (ch == ILOG.J2CsMapping.RegEx.Lexer.CHAR_FLAGS);
			return term;
		}
	
		private AbstractSet ProcessRange(bool negative, AbstractSet last) {
			AbstractCharClass res = ProcessRangeExpression(negative);
			AbstractSet rangeSet = ProcessRangeSet(res);
			rangeSet.SetNext(last);
	
			return rangeSet;
		}
	
		/// <summary>
		/// process [...] ranges
		/// </summary>
		///
		private CharClass ProcessRangeExpression(bool alt) {
            CharClass res = new CharClass(alt, HasFlag(ILOG.J2CsMapping.RegEx.Pattern.CASE_INSENSITIVE),
                    HasFlag(ILOG.J2CsMapping.RegEx.Pattern.UNICODE_CASE));
			int buffer = -1;
			bool intersection = false;
			bool notClosed = false;
			bool firstInClass = true;
	
			while (!lexemes.IsEmpty()
					&& (notClosed = (lexemes.Peek()) != ILOG.J2CsMapping.RegEx.Lexer.CHAR_RIGHT_SQUARE_BRACKET
							|| firstInClass)) {
				switch (lexemes.Peek()) {
	
				case ILOG.J2CsMapping.RegEx.Lexer.CHAR_RIGHT_SQUARE_BRACKET: {
					if (buffer >= 0)
						res.Add(buffer);
					buffer = ']';
					lexemes.Next();
					break;
				}
				case ILOG.J2CsMapping.RegEx.Lexer.CHAR_LEFT_SQUARE_BRACKET: {
					if (buffer >= 0) {
						res.Add(buffer);
						buffer = -1;
					}
					lexemes.Next();
					bool negative = false;
					if (lexemes.Peek() == ILOG.J2CsMapping.RegEx.Lexer.CHAR_CARET) {
						lexemes.Next();
						negative = true;
					}
	
					if (intersection)
						res.Intersection(ProcessRangeExpression(negative));
					else
						res.Union(ProcessRangeExpression(negative));
					intersection = false;
					lexemes.Next();
					break;
				}
	
				case ILOG.J2CsMapping.RegEx.Lexer.CHAR_AMPERSAND: {
					if (buffer >= 0)
						res.Add(buffer);
					buffer = lexemes.Next();
	
					/*
					 * if there is a start for subrange we will do an intersection
					 * otherwise treat '&' as a normal character
					 */
					if (lexemes.Peek() == ILOG.J2CsMapping.RegEx.Lexer.CHAR_AMPERSAND) {
						if (lexemes.LookAhead() == ILOG.J2CsMapping.RegEx.Lexer.CHAR_LEFT_SQUARE_BRACKET) {
							lexemes.Next();
							intersection = true;
							buffer = -1;
						} else {
							lexemes.Next();
							if (firstInClass) {
	
								//skip "&&" at "[&&...]" or "[^&&...]"
								res = ProcessRangeExpression(false);
							} else {
	
								//ignore "&&" at "[X&&]" ending where X != empty string
								if (!(lexemes.Peek() == ILOG.J2CsMapping.RegEx.Lexer.CHAR_RIGHT_SQUARE_BRACKET)) {
									res.Intersection(ProcessRangeExpression(false));
								}
							}
	
						}
					} else {
	
						//treat '&' as a normal character
						buffer = '&';
					}
	
					break;
				}
	
				case ILOG.J2CsMapping.RegEx.Lexer.CHAR_HYPHEN: {
					if (firstInClass
							|| lexemes.LookAhead() == ILOG.J2CsMapping.RegEx.Lexer.CHAR_RIGHT_SQUARE_BRACKET
							|| lexemes.LookAhead() == ILOG.J2CsMapping.RegEx.Lexer.CHAR_LEFT_SQUARE_BRACKET
							|| buffer < 0) {
						// treat hypen as normal character
						if (buffer >= 0)
							res.Add(buffer);
						buffer = '-';
						lexemes.Next();
						// range
					} else {
						lexemes.Next();
						int cur = lexemes.Peek();
	
						if (!lexemes.IsSpecial()
								&& (cur >= 0
										|| lexemes.LookAhead() == ILOG.J2CsMapping.RegEx.Lexer.CHAR_RIGHT_SQUARE_BRACKET
										|| lexemes.LookAhead() == ILOG.J2CsMapping.RegEx.Lexer.CHAR_LEFT_SQUARE_BRACKET || buffer < 0)) {
	
							try {
								if (!ILOG.J2CsMapping.RegEx.Lexer.IsLetter(cur)) {
									cur = cur & 0xFFFF;
								}
								res.Add(buffer, cur);
							} catch (Exception e) {
								throw new PatternSyntaxException("regex.0E", //$NON-NLS-1$
										PatternString(), lexemes.GetIndex());
							}
							lexemes.Next();
							buffer = -1;
						} else {
							throw new PatternSyntaxException("regex.0E", //$NON-NLS-1$
									PatternString(), lexemes.GetIndex());
						}
					}
	
					break;
				}
	
				case ILOG.J2CsMapping.RegEx.Lexer.CHAR_CARET: {
					if (buffer >= 0)
						res.Add(buffer);
					buffer = '^';
					lexemes.Next();
					break;
				}
	
				case 0: {
					if (buffer >= 0)
						res.Add(buffer);
					AbstractCharClass cs = (AbstractCharClass) lexemes
							.PeekSpecial();
					if (cs != null) {
						res.Add(cs);
						buffer = -1;
					} else {
						buffer = 0;
					}
	
					lexemes.Next();
					break;
				}
	
				default: {
					if (buffer >= 0)
						res.Add(buffer);
					buffer = lexemes.Next();
					break;
				}
				}
	
				firstInClass = false;
			}
			if (notClosed) {
				throw new PatternSyntaxException("regex.0F", //$NON-NLS-1$
						PatternString(), lexemes.GetIndex() - 1);
			}
			if (buffer >= 0)
				res.Add(buffer);
			return res;
		}
	
		private AbstractSet ProcessCharSet(int ch) {
            bool isSupplCodePoint = Character.IsSupplementaryCodePoint(ch);

            if (HasFlag(ILOG.J2CsMapping.RegEx.Pattern.CASE_INSENSITIVE))
            {
	
				if ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z')) {
					return new CICharSet((char) ch);
                }
                else if (HasFlag(ILOG.J2CsMapping.RegEx.Pattern.UNICODE_CASE) && ch > 128)
                {
					if (isSupplCodePoint) {
						return new UCISupplCharSet(ch);
					} else if (ILOG.J2CsMapping.RegEx.Lexer.IsLowSurrogate(ch)) {
	
						//we need no UCILowSurrogateCharSet
						return new LowSurrogateCharSet((char) ch);
					} else if (ILOG.J2CsMapping.RegEx.Lexer.IsHighSurrogate(ch)) {
	
						//we need no UCIHighSurrogateCharSet
						return new HighSurrogateCharSet((char) ch);
					} else {
						return new UCICharSet((char) ch);
					}
				}
			}
	
			if (isSupplCodePoint) {
				return new SupplCharSet(ch);
			} else if (ILOG.J2CsMapping.RegEx.Lexer.IsLowSurrogate(ch)) {
				return new LowSurrogateCharSet((char) ch);
			} else if (ILOG.J2CsMapping.RegEx.Lexer.IsHighSurrogate(ch)) {
				return new HighSurrogateCharSet((char) ch);
			} else {
				return new CharSet((char) ch);
			}
		}
	
		private AbstractSet ProcessRangeSet(AbstractCharClass charClass) {
			if (charClass.HasLowHighSurrogates()) {
				AbstractCharClass surrogates = charClass.GetSurrogates();
				LowHighSurrogateRangeSet lowHighSurrRangeSet = new LowHighSurrogateRangeSet(
						surrogates);
	
				if (charClass.MayContainSupplCodepoints()) {
					if (!charClass.HasUCI()) {
						return new CompositeRangeSet(new SupplRangeSet(
								charClass.GetWithoutSurrogates()),
								lowHighSurrRangeSet);
					} else {
						return new CompositeRangeSet(new UCISupplRangeSet(
								charClass.GetWithoutSurrogates()),
								lowHighSurrRangeSet);
					}
				}
	
				if (!charClass.HasUCI()) {
					return new CompositeRangeSet(new RangeSet(
							charClass.GetWithoutSurrogates()), lowHighSurrRangeSet);
				} else {
					return new CompositeRangeSet(new UCIRangeSet(
							charClass.GetWithoutSurrogates()), lowHighSurrRangeSet);
				}
			}
	
			if (charClass.MayContainSupplCodepoints()) {
				if (!charClass.HasUCI()) {
					return new SupplRangeSet(charClass);
				} else {
					return new UCISupplRangeSet(charClass);
				}
			}
	
			if (!charClass.HasUCI()) {
				return new RangeSet(charClass);
			} else {
				return new UCIRangeSet(charClass);
			}
		}
	
		
		/// @com.intel.drl.spec_ref
		public static Pattern Compile(String pattern_0) {
			return Compile(pattern_0, 0);
		}
	
		/*
		 * This method do traverses of
		 * automata to finish compilation.
		 */
		private void FinalizeCompile() {
	
			/*
			 * Processing second pass
			 */
			if (needsBackRefReplacement) { //|| needsReason1 || needsReason2) {
				start.ProcessSecondPass();
			}
	
		}
	
		
		/// @com.intel.drl.spec_ref
		public static bool Matches(String regex, String input) {
			return Pattern.Compile(regex).Matcher(input).Matches();
		}
	
		public static String Quote(String s) {
			StringBuilder sb = new StringBuilder().Append("\\Q"); //$NON-NLS-1$
			int apos = 0;
			int k;
			while ((k = ILOG.J2CsMapping.Util.StringUtil.IndexOf(s,"\\E",apos)) >= 0) { //$NON-NLS-1$
				sb.Append(s.Substring(apos,(k + 2)-(apos))).Append("\\\\E\\Q"); //$NON-NLS-1$
				apos = k + 2;
			}
	
			return sb.Append(s.Substring(apos)).Append("\\E").ToString(); //$NON-NLS-1$
		}
	
		/// <summary>
		/// return number of groups found at compile time
		/// </summary>
		///
		internal int GroupCount() {
			return globalGroupIndex;
		}
	
		internal int CompCount() {
			return this.compCount + 1;
		}
	
		internal int ConsCount() {
			return this.consCount + 1;
		}
	
		/// <summary>
		/// Returns supplementary character. At this time only for ASCII chars.
		/// </summary>
		///
		static internal char GetSupplement(char ch) {
			char res = ch;
			if (ch >= 'a' && ch <= 'z') {
				res -= ((Char)32);
			} else if (ch >= 'A' && ch <= 'Z') {
				res += ((Char)32);
			}
	
			return res;
		}
	
		
		/// <returns>true if pattern has specified flag</returns>
		private bool HasFlag(int flag) {
			return (flags & flag) == flag;
		}
	
		/// <summary>
		/// Dismiss public constructor.
		/// </summary>
		///
		private Pattern() {
			this.lexemes = null;
			this.flags = 0;
			this.pattern = null;
			this.backRefs = new FSet[BACK_REF_NUMBER];
			this.needsBackRefReplacement = false;
			this.groupIndex = -1;
			this.globalGroupIndex = -1;
			this.compCount = -1;
			this.consCount = -1;
			this.start = null;
		}
	
		/// <summary>
		/// Serialization support
		/// </summary>
		///
		private void ReadObject(IlObjectInputStream s) {
			s.DefaultReadObject();
			ILOG.J2CsMapping.RegEx.AbstractSet.counter = 1;
			groupIndex = -1;
			globalGroupIndex = -1;
			compCount = -1;
			consCount = -1;
			backRefs = new FSet[BACK_REF_NUMBER];
	
			CompileImpl(pattern, flags);
	
		}
	}
}
