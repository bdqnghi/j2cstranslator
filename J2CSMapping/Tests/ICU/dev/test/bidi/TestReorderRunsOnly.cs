/*
 *******************************************************************************
 *   Copyright (C) 2001-2007, International Business Machines
 *   Corporation and others.  All Rights Reserved.
 *******************************************************************************
 */

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/13/10 10:46 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Charset {
	
	using IBM.ICU.Text;
	using NUnit;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	
	/// <summary>
	/// Regression test for variants to the UBA.
	/// </summary>
	///
	
	[NUnit.Framework.TestFixture]
	public class TestReorderRunsOnly : BidiTest {
	
	    internal class TestCase {
	        internal String textIn;
	
	        internal String[][] textOut;
	
	        internal int[] noroundtrip;
	
	        internal TestCase(String ins0, String[][] xout, int[] nrd) {
	            this.textIn = ins0;
	            this.textOut = xout;
	            this.noroundtrip = nrd;
	        }
	    }
	
	    static internal readonly TestReorderRunsOnly.TestCase [] testCases = {
	            new TestReorderRunsOnly.TestCase ("ab 234 896 de", new String[][] {
	                    new String[]{ "de 896 ab 234", "de 896 ab 234" },
	                    new String[]{ "ab 234 @896@ de", "de 896 ab 234" } },
	                    new int[] { 0, 0 }),
	            new TestReorderRunsOnly.TestCase ("abcGHI", new String[][] { new String[]{ "GHIabc", "GHIabc" },
	                    new String[]{ "GHIabc", "GHIabc" } }, new int[] { 0, 0 }),
	            new TestReorderRunsOnly.TestCase ("a.>67->", new String[][] { new String[]{ "<-67<.a", "<-67<.a" },
	                    new String[]{ "<-67<.a", "<-67<.a" } }, new int[] { 0, 0 }),
	            new TestReorderRunsOnly.TestCase ("-=%$123/ *", new String[][] {
	                    new String[]{ "* /%$123=-", "* /%$123=-" },
	                    new String[]{ "* /%$123=-", "* /%$123=-" } }, new int[] { 0, 0 }),
	            new TestReorderRunsOnly.TestCase ("abc->12..>JKL", new String[][] {
	                    new String[]{ "JKL<..12<-abc", "JKL<..abc->12" },
	                    new String[]{ "JKL<..12<-abc", "JKL<..abc->12" } }, new int[] { 0, 0 }),
	            new TestReorderRunsOnly.TestCase ("JKL->12..>abc", new String[][] {
	                    new String[]{ "abc<..JKL->12", "abc<..12<-JKL" },
	                    new String[]{ "abc<..JKL->12", "abc<..12<-JKL" } }, new int[] { 0, 0 }),
	            new TestReorderRunsOnly.TestCase ("123->abc", new String[][] {
	                    new String[]{ "abc<-123", "abc<-123" }, new String[]{ "abc&<-123", "abc<-123" } },
	                    new int[] { 1, 0 }),
	            new TestReorderRunsOnly.TestCase ("123->JKL", new String[][] {
	                    new String[]{ "JKL<-123", "123->JKL" }, new String[]{ "JKL<-123", "JKL<-@123" } },
	                    new int[] { 0, 1 }),
	            new TestReorderRunsOnly.TestCase ("*>12.>34->JKL", new String[][] {
	                    new String[]{ "JKL<-34<.12<*", "12.>34->JKL<*" },
	                    new String[]{ "JKL<-34<.12<*", "JKL<-@34<.12<*" } }, new int[] { 0, 1 }),
	            new TestReorderRunsOnly.TestCase ("*>67.>89->JKL", new String[][] {
	                    new String[]{ "67.>89->JKL<*", "67.>89->JKL<*" },
	                    new String[]{ "67.>89->JKL<*", "67.>89->JKL<*" } }, new int[] { 0, 0 }),
	            new TestReorderRunsOnly.TestCase ("* /abc-=$%123", new String[][] {
	                    new String[]{ "$%123=-abc/ *", "abc-=$%123/ *" },
	                    new String[]{ "$%123=-abc/ *", "abc-=$%123/ *" } }, new int[] { 0, 0 }),
	            new TestReorderRunsOnly.TestCase ("* /$%def-=123", new String[][] {
	                    new String[]{ "123=-def%$/ *", "def-=123%$/ *" },
	                    new String[]{ "123=-def%$/ *", "def-=123%$/ *" } }, new int[] { 0, 0 }),
	            new TestReorderRunsOnly.TestCase ("-=GHI* /123%$", new String[][] {
	                    new String[]{ "GHI* /123%$=-", "123%$/ *GHI=-" },
	                    new String[]{ "GHI* /123%$=-", "123%$/ *GHI=-" } }, new int[] { 0, 0 }),
	            new TestReorderRunsOnly.TestCase ("-=%$JKL* /123", new String[][] {
	                    new String[]{ "JKL* /%$123=-", "123/ *JKL$%=-" },
	                    new String[]{ "JKL* /%$123=-", "123/ *JKL$%=-" } }, new int[] { 0, 0 }),
	            new TestReorderRunsOnly.TestCase ("ab =#CD *?450", new String[][] {
	                    new String[]{ "CD *?450#= ab", "450?* CD#= ab" },
	                    new String[]{ "CD *?450#= ab", "450?* CD#= ab" } }, new int[] { 0, 0 }),
	            new TestReorderRunsOnly.TestCase ("ab 234 896 de", new String[][] {
	                    new String[]{ "de 896 ab 234", "de 896 ab 234" },
	                    new String[]{ "ab 234 @896@ de", "de 896 ab 234" } },
	                    new int[] { 0, 0 }),
	            new TestReorderRunsOnly.TestCase ("abc-=%$LMN* /123", new String[][] {
	                    new String[]{ "LMN* /%$123=-abc", "123/ *LMN$%=-abc" },
	                    new String[]{ "LMN* /%$123=-abc", "123/ *LMN$%=-abc" } }, new int[] {
	                    0, 0 }),
	            new TestReorderRunsOnly.TestCase ("123->JKL&MN&P", new String[][] {
	                    new String[]{ "JKLMNP<-123", "123->JKLMNP" },
	                    new String[]{ "JKLMNP<-123", "JKLMNP<-@123" } }, new int[] { 0, 1 }),
	            new TestReorderRunsOnly.TestCase ("123", new String[][] { new String[]{ "123", "123" },
	                    new String[]{ "123", "123" } }, new int[] { 0, 0 }) };
	
	    [NUnit.Framework.Test]
	    public void TestReorderRunsOnly2() {
	
	        Bidi bidi = new Bidi();
	        Bidi bidiL2V = new Bidi();
	        String src, dest, visual1, visual2;
	        String srcU16, destU16, visual1U16, visual2U16;
	        int option, i, j, nCases;
	        sbyte level;
	
	        Logln("\nEntering TestReorderRunsOnly\n");
	        bidi.SetReorderingMode(IBM.ICU.Text.Bidi.REORDER_RUNS_ONLY);
	        bidiL2V.SetReorderingOptions(IBM.ICU.Text.Bidi.OPTION_REMOVE_CONTROLS);
	
	        for (option = 0; option < 2; option++) {
	            bidi.SetReorderingOptions((option == 0) ? IBM.ICU.Text.Bidi.OPTION_REMOVE_CONTROLS
	                    : IBM.ICU.Text.Bidi.OPTION_INSERT_MARKS);
	            for (i = 0, nCases = testCases.Length; i < nCases; i++) {
	                src = testCases[i].textIn;
	                srcU16 = IBM.ICU.Charset.BidiTest.PseudoToU16(src);
	                for (j = 0; j < 2; j++) {
	                    Logln("Now doing test for option " + option + ", case " + i
	                            + ", level " + j);
	                    level = (sbyte) j;
	                    bidi.SetPara(srcU16, level, null);
	                    destU16 = bidi.WriteReordered(IBM.ICU.Text.Bidi.DO_MIRRORING);
	                    dest = IBM.ICU.Charset.BidiTest.U16ToPseudo(destU16);
	                    CheckWhatYouCan(bidi, src, dest);
	                    AssertEquals("Reorder runs only failed for case " + i,
	                            testCases[i].textOut[option][level], dest, src,
	                            null, null, level.ToString());
	
	                    if ((option == 0) && (testCases[i].noroundtrip[level] > 0)) {
	                        continue;
	                    }
	                    bidiL2V.SetPara(srcU16, level, null);
	                    visual1U16 = bidiL2V.WriteReordered(IBM.ICU.Text.Bidi.DO_MIRRORING);
	                    visual1 = IBM.ICU.Charset.BidiTest.U16ToPseudo(visual1U16);
	                    CheckWhatYouCan(bidiL2V, src, visual1);
	                    bidiL2V.SetPara(destU16, (sbyte) (level ^ 1), null);
	                    visual2U16 = bidiL2V.WriteReordered(IBM.ICU.Text.Bidi.DO_MIRRORING);
	                    visual2 = IBM.ICU.Charset.BidiTest.U16ToPseudo(visual2U16);
	                    CheckWhatYouCan(bidiL2V, dest, visual2);
	                    AssertEquals("Round trip failed for case " + i, visual1,
	                            visual2, src, "REORDER_RUNS_ONLY (2)",
	                            (option == 0) ? "0" : "OPTION_INSERT_MARKS",
	                            level.ToString());
	                }
	            }
	        }
	
	        /* test with null or empty text */
	        int paras;
	        bidi.SetPara((String) null, IBM.ICU.Text.Bidi.LTR, null);
	        paras = bidi.CountParagraphs();
	        AssertEquals("\nInvalid number of paras #1 (should be 0): ", 0, paras);
	        bidi.SetPara((char[]) null, IBM.ICU.Text.Bidi.LTR, null);
	        paras = bidi.CountParagraphs();
	        AssertEquals("\nInvalid number of paras #2 (should be 0): ", 0, paras);
	        bidi.SetPara("", IBM.ICU.Text.Bidi.LTR, null);
	        paras = bidi.CountParagraphs();
	        AssertEquals("\nInvalid number of paras #3 (should be 0): ", 0, paras);
	        bidi.SetPara(new char[0], IBM.ICU.Text.Bidi.LTR, null);
	        paras = bidi.CountParagraphs();
	        AssertEquals("\nInvalid number of paras #4 (should be 0): ", 0, paras);
	
	        Logln("\nExiting TestReorderRunsOnly\n");
	    }
	
	    public static void Main(String[] args) {
	        try {
	            new TestReorderRunsOnly().Run(args);
	        } catch (Exception e) {
	            System.Console.Out.WriteLine(e);
	        }
	    }
	
	}
}
