/*
 *******************************************************************************
 *   Copyright (C) 2001-2007, International Business Machines
 *   Corporation and others.  All Rights Reserved.
 *******************************************************************************
 */

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/13/10 10:46 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Charset {
	
	using IBM.ICU.Text;
	using IBM.ICU.Util;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Text;
	
	/// <summary>
	/// A base class for the Bidi test suite.
	/// </summary>
	///
	
	public class BidiTest : TestFmwk {
	
	    protected static internal readonly char[] charFromDirProp = {
	    /* L R EN ES ET AN CS B S WS ON */
	    (char) 0x61, (char) 0x5d0, (char) 0x30, (char) 0x2f, (char) 0x25, (char) 0x660, (char) 0x2c, (char) 0xa, (char) 0x9,(char)  0x20, (char) 0x26,
	    /* LRE LRO AL RLE RLO PDF NSM BN */
	    (char) 0x202a, (char) 0x202d, (char) 0x627, (char) 0x202b, (char) 0x202e, (char) 0x202c, (char) 0x308, (char) 0x200c };
	
	    private static void InitCharFromDirProps() {
	        VersionInfo ucd401 = IBM.ICU.Util.VersionInfo.GetInstance(4, 0, 1, 0);
	        VersionInfo ucdVersion = IBM.ICU.Util.VersionInfo.GetInstance(0, 0, 0, 0);
	
	        /* lazy initialization */
	        if (ucdVersion.GetMajor() > 0) {
	            return;
	
	        }
	        ucdVersion = IBM.ICU.Lang.UCharacter.GetUnicodeVersion();
	        if (ucdVersion.CompareTo(ucd401) >= 0) {
	            /* Unicode 4.0.1 changes bidi classes for +-/ */
	            /* change ES character from / to + */
	            charFromDirProp[IBM.ICU.Charset.TestData.ES] = ((Char)0x2b);
	        }
	    }
	
	    protected internal bool AssertEquals(String message, String expected,
	            String actual, String src, String mode, String option, String level) {
	        if (expected == null || actual == null) {
	            return base.AssertEquals(message,expected,actual);
	        }
	        if (expected.Equals(actual)) {
	            return true;
	        }
	        Errln("");
	        Errcontln(message);
	        if (src != null) {
	            Errcontln("source            : \"" + IBM.ICU.Impl.Utility.Escape(src) + "\"");
	        }
	        Errcontln("expected          : \"" + IBM.ICU.Impl.Utility.Escape(expected) + "\"");
	        Errcontln("actual            : \"" + IBM.ICU.Impl.Utility.Escape(actual) + "\"");
	        if (mode != null) {
	            Errcontln("reordering mode   : " + mode);
	        }
	        if (option != null) {
	            Errcontln("reordering option : " + option);
	        }
	        if (level != null) {
	            Errcontln("paragraph level   : " + level);
	        }
	        return false;
	    }
	
	    protected static internal String ValueOf(int[] array) {
	        StringBuilder result = new StringBuilder(array.Length * 4);
	        for (int i = 0; i < array.Length; i++) {
	            result.Append(' ');
	            result.Append(array[i]);
	        }
	        return result.ToString();
	    }
	
	    private static readonly String[] modeDescriptions = { "REORDER_DEFAULT",
	            "REORDER_NUMBERS_SPECIAL", "REORDER_GROUP_NUMBERS_WITH_R",
	            "REORDER_RUNS_ONLY", "REORDER_INVERSE_NUMBERS_AS_L",
	            "REORDER_INVERSE_LIKE_DIRECT",
	            "REORDER_INVERSE_FOR_NUMBERS_SPECIAL" };
	
	    protected static internal String ModeToString(int mode) {
	        if (mode < IBM.ICU.Text.Bidi.REORDER_DEFAULT
	                || mode > IBM.ICU.Text.Bidi.REORDER_INVERSE_FOR_NUMBERS_SPECIAL) {
	            return "INVALID";
	        }
	        return modeDescriptions[mode];
	    }
	
	    private const short SETPARA_MASK = IBM.ICU.Text.Bidi.OPTION_INSERT_MARKS
	            | IBM.ICU.Text.Bidi.OPTION_REMOVE_CONTROLS | IBM.ICU.Text.Bidi.OPTION_STREAMING;
	
	    private static readonly String[] setParaDescriptions = {
	            "OPTION_INSERT_MARKS", "OPTION_REMOVE_CONTROLS", "OPTION_STREAMING" };
	
	    protected static internal String SpOptionsToString(int option) {
	        return OptionToString(option, SETPARA_MASK, setParaDescriptions);
	    }
	
	    private const int MAX_WRITE_REORDERED_OPTION = IBM.ICU.Text.Bidi.OUTPUT_REVERSE;
	
	    private const int REORDER_MASK = (MAX_WRITE_REORDERED_OPTION << 1) - 1;
	
	    private static readonly String[] writeReorderedDescriptions = {
	            "KEEP_BASE_COMBINING", // 1
	            "DO_MIRRORING", // 2
	            "INSERT_LRM_FOR_NUMERIC", // 4
	            "REMOVE_BIDI_CONTROLS", // 8
	            "OUTPUT_REVERSE" // 16
	    };
	
	    public static String WrOptionsToString(int option) {
	        return OptionToString(option, REORDER_MASK, writeReorderedDescriptions);
	    }
	
	    public static String OptionToString(int option, int mask,
	            String[] descriptions) {
	        StringBuilder desc = new StringBuilder(50);
	
	        if ((option &= mask) == 0) {
	            return "0";
	        }
	        desc.Length=0;
	
	        for (int i = 0; option > 0; i++, option >>= 1) {
	            if ((option & 1) != 0) {
	                if (desc.Length > 0) {
	                    desc.Append(" | ");
	                }
	                desc.Append(descriptions[i]);
	            }
	        }
	        return desc.ToString();
	    }
	
	    internal const String columnString = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
	
	    static internal readonly char[] columns = columnString.ToCharArray();
	
	    private const int TABLE_SIZE = 256;
	
	    private static bool tablesInitialized = false;
	
	    private static char[] pseudoToUChar;
	
	    private static char[] UCharToPseudo; /* used for Unicode chars < 0x0100 */
	
	    private static char[] UCharToPseud2; /* used for Unicode chars >=0x0100 */
	
	    static internal void BuildPseudoTables()
	    /*
	     * The rules for pseudo-Bidi are as follows: - [ == LRE - ] == RLE - { ==
	     * LRO - } == RLO - ^ == PDF - @ == LRM - & == RLM - A-F == Arabic Letters
	     * 0631-0636 - G-V == Hebrew letters 05d7-05ea - W-Z == Unassigned RTL
	     * 08d0-08d3 - 0-5 == western digits 0030-0035 - 6-9 == Arabic-Indic digits
	     * 0666-0669 - ` == Combining Grave Accent 0300 (NSM) - ~ == Delete 007f
	     * (BN) - | == Paragraph Separator 2029 (B) - _ == Info Separator 1 001f (S)
	     * All other characters represent themselves as Latin-1, with the
	     * corresponding Bidi properties.
	     */
	    {
	        int i;
	        char uchar;
	        char c;
	
	        /* initialize all tables to unknown */
	        pseudoToUChar = new char[TABLE_SIZE];
	        UCharToPseudo = new char[TABLE_SIZE];
	        UCharToPseud2 = new char[TABLE_SIZE];
	        for (i = 0; i < TABLE_SIZE; i++) {
	            pseudoToUChar[i] = ((Char)0xFFFD);
	            UCharToPseudo[i] = '?';
	            UCharToPseud2[i] = '?';
	        }
	        /* initialize non letters or digits */
	        pseudoToUChar[0] = ((Char)0x0000);
	        UCharToPseudo[0x00] = ((Char)0);
	        pseudoToUChar[' '] = ((Char)0x0020);
	        UCharToPseudo[0x20] = ' ';
	        pseudoToUChar['!'] = ((Char)0x0021);
	        UCharToPseudo[0x21] = '!';
	        pseudoToUChar['"'] = ((Char)0x0022);
	        UCharToPseudo[0x22] = '"';
	        pseudoToUChar['#'] = ((Char)0x0023);
	        UCharToPseudo[0x23] = '#';
	        pseudoToUChar['$'] = ((Char)0x0024);
	        UCharToPseudo[0x24] = '$';
	        pseudoToUChar['%'] = ((Char)0x0025);
	        UCharToPseudo[0x25] = '%';
	        pseudoToUChar['\''] = ((Char)0x0027);
	        UCharToPseudo[0x27] = '\'';
	        pseudoToUChar['('] = ((Char)0x0028);
	        UCharToPseudo[0x28] = '(';
	        pseudoToUChar[')'] = ((Char)0x0029);
	        UCharToPseudo[0x29] = ')';
	        pseudoToUChar['*'] = ((Char)0x002A);
	        UCharToPseudo[0x2A] = '*';
	        pseudoToUChar['+'] = ((Char)0x002B);
	        UCharToPseudo[0x2B] = '+';
	        pseudoToUChar[','] = ((Char)0x002C);
	        UCharToPseudo[0x2C] = ',';
	        pseudoToUChar['-'] = ((Char)0x002D);
	        UCharToPseudo[0x2D] = '-';
	        pseudoToUChar['.'] = ((Char)0x002E);
	        UCharToPseudo[0x2E] = '.';
	        pseudoToUChar['/'] = ((Char)0x002F);
	        UCharToPseudo[0x2F] = '/';
	        pseudoToUChar[':'] = ((Char)0x003A);
	        UCharToPseudo[0x3A] = ':';
	        pseudoToUChar[';'] = ((Char)0x003B);
	        UCharToPseudo[0x3B] = ';';
	        pseudoToUChar['<'] = ((Char)0x003C);
	        UCharToPseudo[0x3C] = '<';
	        pseudoToUChar['='] = ((Char)0x003D);
	        UCharToPseudo[0x3D] = '=';
	        pseudoToUChar['>'] = ((Char)0x003E);
	        UCharToPseudo[0x3E] = '>';
	        pseudoToUChar['?'] = ((Char)0x003F);
	        UCharToPseudo[0x3F] = '?';
	        pseudoToUChar['\\'] = ((Char)0x005C);
	        UCharToPseudo[0x5C] = '\\';
	        /* initialize specially used characters */
	        pseudoToUChar['`'] = ((Char)0x0300);
	        UCharToPseud2[0x00] = '`'; /* NSM */
	        pseudoToUChar['@'] = ((Char)0x200E);
	        UCharToPseud2[0x0E] = '@'; /* LRM */
	        pseudoToUChar['&'] = ((Char)0x200F);
	        UCharToPseud2[0x0F] = '&'; /* RLM */
	        pseudoToUChar['_'] = ((Char)0x001F);
	        UCharToPseudo[0x1F] = '_'; /* S */
	        pseudoToUChar['|'] = ((Char)0x2029);
	        UCharToPseud2[0x29] = '|'; /* B */
	        pseudoToUChar['['] = ((Char)0x202A);
	        UCharToPseud2[0x2A] = '['; /* LRE */
	        pseudoToUChar[']'] = ((Char)0x202B);
	        UCharToPseud2[0x2B] = ']'; /* RLE */
	        pseudoToUChar['^'] = ((Char)0x202C);
	        UCharToPseud2[0x2C] = '^'; /* PDF */
	        pseudoToUChar['{'] = ((Char)0x202D);
	        UCharToPseud2[0x2D] = '{'; /* LRO */
	        pseudoToUChar['}'] = ((Char)0x202E);
	        UCharToPseud2[0x2E] = '}'; /* RLO */
	        pseudoToUChar['~'] = ((Char)0x007F);
	        UCharToPseudo[0x7F] = '~'; /* BN */
	        /* initialize western digits */
	        for (i = 0, uchar = ((Char)0x0030); i < 6; i++, uchar++) {
	            c = columns[i];
	            pseudoToUChar[c] = uchar;
	            UCharToPseudo[uchar & 0x00ff] = c;
	        }
	        /* initialize Hindi digits */
	        for (i = 6, uchar = ((Char)0x0666); i < 10; i++, uchar++) {
	            c = columns[i];
	            pseudoToUChar[c] = uchar;
	            UCharToPseud2[uchar & 0x00ff] = c;
	        }
	        /* initialize Arabic letters */
	        for (i = 10, uchar = ((Char)0x0631); i < 16; i++, uchar++) {
	            c = columns[i];
	            pseudoToUChar[c] = uchar;
	            UCharToPseud2[uchar & 0x00ff] = c;
	        }
	        /* initialize Hebrew letters */
	        for (i = 16, uchar = ((Char)0x05D7); i < 32; i++, uchar++) {
	            c = columns[i];
	            pseudoToUChar[c] = uchar;
	            UCharToPseud2[uchar & 0x00ff] = c;
	        }
	        /* initialize Unassigned code points */
	        for (i = 32, uchar = ((Char)0x08D0); i < 36; i++, uchar++) {
	            c = columns[i];
	            pseudoToUChar[c] = uchar;
	            UCharToPseud2[uchar & 0x00ff] = c;
	        }
	        /* initialize Latin lower case letters */
	        for (i = 36, uchar = ((Char)0x0061); i < 62; i++, uchar++) {
	            c = columns[i];
	            pseudoToUChar[c] = uchar;
	            UCharToPseudo[uchar & 0x00ff] = c;
	        }
	        tablesInitialized = true;
	    }
	
	    /*----------------------------------------------------------------------*/
	
	    static internal String PseudoToU16(String input)
	    /*
	     * This function converts a pseudo-Bidi string into a char string. It
	     * returns the char string.
	     */
	    {
	        int len = input.Length;
	        char[] output = new char[len];
	        int i;
	        if (!tablesInitialized) {
	            BuildPseudoTables();
	        }
	        for (i = 0; i < len; i++)
	            output[i] = pseudoToUChar[input[i]];
	        return ILOG.J2CsMapping.Util.StringUtil.NewString(output);
	    }
	
	    /*----------------------------------------------------------------------*/
	
	    static internal String U16ToPseudo(String input)
	    /*
	     * This function converts a char string into a pseudo-Bidi string. It
	     * returns the pseudo-Bidi string.
	     */
	    {
	        int len = input.Length;
	        char[] output = new char[len];
	        int i;
	        char uchar;
	        if (!tablesInitialized) {
	            BuildPseudoTables();
	        }
	        for (i = 0; i < len; i++) {
	            uchar = input[i];
	            output[i] = (uchar < 0x0100) ? UCharToPseudo[uchar]
	                    : UCharToPseud2[uchar & 0x00ff];
	        }
	        return ILOG.J2CsMapping.Util.StringUtil.NewString(output);
	    }
	
	    internal void Errcont(String message) {
	        Msg(message, IBM.ICU.Charset.TestLog_Constants.ERR, false, false);
	    }
	
	    internal void Errcontln(String message) {
	        Msg(message, IBM.ICU.Charset.TestLog_Constants.ERR, false, true);
	    }
	
	    internal void PrintCaseInfo(Bidi bidi, String src, String dst) {
	        int length = bidi.GetProcessedLength();
	        sbyte[] levels = bidi.GetLevels();
	        char[] levelChars = new char[length];
	        sbyte lev;
	        int runCount = bidi.CountRuns();
	        Errcontln("========================================");
	        Errcontln("Processed length: " + length);
	        for (int i = 0; i < length; i++) {
	            lev = levels[i];
	            if (lev < 0) {
	                levelChars[i] = '-';
	            } else if (lev < columns.Length) {
	                levelChars[i] = columns[lev];
	            } else {
	                levelChars[i] = '+';
	            }
	        }
	        Errcontln("Levels: " + ILOG.J2CsMapping.Util.StringUtil.NewString(levelChars));
	        Errcontln("Source: " + src);
	        Errcontln("Result: " + dst);
	        Errcontln("Direction: " + bidi.GetDirection());
	        Errcontln("paraLevel: " + bidi.GetParaLevel().ToString());
	        Errcontln("reorderingMode: " + ModeToString(bidi.GetReorderingMode()));
	        Errcontln("reorderingOptions: "
	                + SpOptionsToString(bidi.GetReorderingOptions()));
	        Errcont("Runs: " + runCount + " => logicalStart.length/level: ");
	        for (int i_0 = 0; i_0 < runCount; i_0++) {
	            BidiRun run;
	            run = bidi.GetVisualRun(i_0);
	            Errcont(" " + run.GetStart() + "." + run.GetLength() + "/"
	                    + run.GetEmbeddingLevel());
	        }
	        Errcont("\n");
	    }
	
	    internal const String mates1 = "<>()[]{}";
	
	    internal const String mates2 = "><)(][}{";
	
	    static internal readonly char[] mates1Chars = mates1.ToCharArray();
	
	    static internal readonly char[] mates2Chars = mates2.ToCharArray();
	
	    internal bool MatchingPair(Bidi bidi, int i, char c1, char c2) {
	        if (c1 == c2) {
	            return true;
	        }
	        /*
	         * For REORDER_RUNS_ONLY, it would not be correct to check levels[i], so
	         * we use the appropriate run's level, which is good for all cases.
	         */
	        if (bidi.GetLogicalRun(i).GetDirection() == 0) {
	            return false;
	        }
	        for (int k = 0; k < mates1Chars.Length; k++) {
	            if ((c1 == mates1Chars[k]) && (c2 == mates2Chars[k])) {
	                return true;
	            }
	        }
	        return false;
	    }
	
	    internal bool CheckWhatYouCan(Bidi bidi, String src, String dst) {
	        int i, idx, logLimit, visLimit;
	        bool testOK, errMap, errDst;
	        char[] srcChars = src.ToCharArray();
	        char[] dstChars = dst.ToCharArray();
	        int[] visMap = bidi.GetVisualMap();
	        int[] logMap = bidi.GetLogicalMap();
	
	        testOK = true;
	        errMap = errDst = false;
	        logLimit = bidi.GetProcessedLength();
	        visLimit = bidi.GetResultLength();
	        if (visLimit > dstChars.Length) {
	            visLimit = dstChars.Length;
	        }
	        char[] accumSrc = new char[logLimit];
	        char[] accumDst = new char[visLimit];
	        ILOG.J2CsMapping.Collections.Arrays.Fill(accumSrc,'?');
	        ILOG.J2CsMapping.Collections.Arrays.Fill(accumDst,'?');
	
	        if (logMap.Length != logLimit) {
	            errMap = true;
	        }
	        for (i = 0; i < logLimit; i++) {
	            idx = bidi.GetVisualIndex(i);
	            if (idx != logMap[i]) {
	                errMap = true;
	            }
	            if (idx == IBM.ICU.Text.Bidi.MAP_NOWHERE) {
	                continue;
	            }
	            if (idx >= visLimit) {
	                continue;
	            }
	            accumDst[idx] = srcChars[i];
	            if (!MatchingPair(bidi, i, srcChars[i], dstChars[idx])) {
	                errDst = true;
	            }
	        }
	        if (errMap) {
	            if (testOK) {
	                PrintCaseInfo(bidi, src, dst);
	                testOK = false;
	            }
	            Errln("Mismatch between getLogicalMap() and getVisualIndex()");
	            Errcont("Map    :" + ValueOf(logMap));
	            Errcont("\n");
	            Errcont("Indexes:");
	            for (i = 0; i < logLimit; i++) {
	                Errcont(" " + bidi.GetVisualIndex(i));
	            }
	            Errcont("\n");
	        }
	        if (errDst) {
	            if (testOK) {
	                PrintCaseInfo(bidi, src, dst);
	                testOK = false;
	            }
	            Errln("Source does not map to Result");
	            Errcontln("We got: " + ILOG.J2CsMapping.Util.StringUtil.NewString(accumDst));
	        }
	
	        errMap = errDst = false;
	        if (visMap.Length != visLimit) {
	            errMap = true;
	        }
	        for (i = 0; i < visLimit; i++) {
	            idx = bidi.GetLogicalIndex(i);
	            if (idx != visMap[i]) {
	                errMap = true;
	            }
	            if (idx == IBM.ICU.Text.Bidi.MAP_NOWHERE) {
	                continue;
	            }
	            if (idx >= logLimit) {
	                continue;
	            }
	            accumSrc[idx] = dstChars[i];
	            if (!MatchingPair(bidi, idx, srcChars[idx], dstChars[i])) {
	                errDst = true;
	            }
	        }
	        if (errMap) {
	            if (testOK) {
	                PrintCaseInfo(bidi, src, dst);
	                testOK = false;
	            }
	            Errln("Mismatch between getVisualMap() and getLogicalIndex()");
	            Errcont("Map    :" + ValueOf(visMap));
	            Errcont("\n");
	            Errcont("Indexes:");
	            for (i = 0; i < visLimit; i++) {
	                Errcont(" " + bidi.GetLogicalIndex(i));
	            }
	            Errcont("\n");
	        }
	        if (errDst) {
	            if (testOK) {
	                PrintCaseInfo(bidi, src, dst);
	                testOK = false;
	            }
	            Errln("Result does not map to Source");
	            Errcontln("We got: " + ILOG.J2CsMapping.Util.StringUtil.NewString(accumSrc));
	        }
	        return testOK;
	    }
	
	    static BidiTest() {
	            InitCharFromDirProps();
	        }
	
	}
}
