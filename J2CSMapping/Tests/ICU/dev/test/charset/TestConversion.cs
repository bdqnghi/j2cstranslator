/*
 *******************************************************************************
 * Copyright (C) 2002-2007, International Business Machines Corporation and    *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 *
 *******************************************************************************
 */

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/16/10 2:47 PM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Dev.Test.Charset {
	
	using IBM.ICU.Charset;
	using IBM.ICU.Dev.Test;
	using IBM.ICU.Dev.Test.TestDataModule;
	using IBM.ICU.Impl;
	using ILOG.J2CsMapping.Collections;
	using ILOG.J2CsMapping.Collections.Generics;
	using ILOG.J2CsMapping.NIO;
	using ILOG.J2CsMapping.NIO.Charset;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Text;
	
	/// <summary>
	/// This maps to convtest.c which tests the test file for data-driven conversion
	/// tests.
	/// </summary>
	///
	public class TestConversion : ModuleTest {
	    /// <summary>
	    /// This maps to the C struct of conversion case in convtest.h that stores
	    /// the data for a conversion test
	    /// </summary>
	    ///
	    private class ConversionCase {
	        public ConversionCase() {
	            this.option = null;
	            this.cbErrorAction = null;
	            this.toUnicodeResult = null;
	            this.fromUnicodeResult = null;
	        }
	
	        internal int caseNr; // testcase index
	
	        internal String option; // callback options
	
	        internal CodingErrorAction cbErrorAction; // callback action type
	
	        internal CharBuffer toUnicodeResult;
	
	        internal ByteBuffer fromUnicodeResult;
	
	        // data retrieved from a test case conversion.txt
	        internal String charset; // charset
	
	        internal String unicode; // unicode string
	
	        internal ByteBuffer bytes; // byte
	
	        internal int[] offsets; // offsets
	
	        internal bool finalFlush; // flush
	
	        internal bool fallbacks; // fallback
	
	        internal String outErrorCode; // errorCode
	
	        internal String cbopt; // callback
	
	        // TestGetUnicodeSet variables
	        internal String map;
	
	        internal String mapnot;
	
	        internal int which;
	
	        internal String CaseNrAsString() {
	            return "[" + caseNr + "]";
	        }
	    }
	
	    // public methods --------------------------------------------------------
	
	    public static void Main(String[] args) {
	        new TestConversion().Run(args);
	    }
	
	    public TestConversion() : base("com/ibm/icu/dev/data/testdata/", "conversion") {
	    }
	
	    /*
	     * This method maps to the convtest.cpp runIndexedTest() method to run each
	     * type of conversion.
	     */
	    public override void ProcessModules() {
	        try {
	            int testFromUnicode = 0;
	            int testToUnicode = 0;
	            String testName = t.GetName().ToString();
	
	            // Iterate through and get each of the test case to process
	            for (IIterator iter = t.GetDataIterator(); iter.HasNext();) {
	                IBM.ICU.Dev.Test.TestDataModule.DataMap  testcase = (IBM.ICU.Dev.Test.TestDataModule.DataMap ) iter.Next();
	
	                if (testName.Equals("toUnicode",StringComparison.InvariantCultureIgnoreCase)) {
	                    TestToUnicode(testcase, testToUnicode);
	                    testToUnicode++;
	
	                } else if (testName.Equals("fromUnicode",StringComparison.InvariantCultureIgnoreCase)) {
	                    TestFromUnicode(testcase, testFromUnicode);
	                    testFromUnicode++;
	                } else if (testName.Equals("getUnicodeSet",StringComparison.InvariantCultureIgnoreCase)) {
	                    TestGetUnicodeSet(testcase);
	                } else {
	                    Warnln("Could not load the test cases for conversion");
	                    continue;
	                }
	            }
	        } catch (Exception e) {
	            Console.Error.WriteLine(e.StackTrace);
	        }
	
	    }
	
	    // private methods -------------------------------------------------------
	
	    // fromUnicode test worker functions ---------------------------------------
	    private void TestFromUnicode(IBM.ICU.Dev.Test.TestDataModule.DataMap  testcase, int caseNr_0) {
	
	        TestConversion.ConversionCase  cc = new TestConversion.ConversionCase ();
	
	        try {
	            // retrieve test case data
	            cc.caseNr = caseNr_0;
	            cc.charset = ((ICUResourceBundle) testcase.GetObject("charset"))
	                    .GetString();
	            cc.unicode = ((ICUResourceBundle) testcase.GetObject("unicode"))
	                    .GetString();
	            cc.bytes = ((ICUResourceBundle) testcase.GetObject("bytes"))
	                    .GetBinary();
	            cc.offsets = ((ICUResourceBundle) testcase.GetObject("offsets"))
	                    .GetIntVector();
	            cc.finalFlush = ((ICUResourceBundle) testcase.GetObject("flush"))
	                    .GetUInt() != 0;
	            cc.fallbacks = ((ICUResourceBundle) testcase.GetObject("fallbacks"))
	                    .GetUInt() != 0;
	            cc.outErrorCode = ((ICUResourceBundle) testcase
	                    .GetObject("errorCode")).GetString();
	            cc.cbopt = ((ICUResourceBundle) testcase.GetObject("callback"))
	                    .GetString();
	
	        } catch (Exception e) {
	            Errln("Skipping test:");
	            Errln("error parsing conversion/toUnicode test case " + cc.caseNr);
	            return;
	        }
	
	        // ----for debugging only
	        Logln("");
	        Logln("TestFromUnicode[" + caseNr_0 + "] " + cc.charset + " ");
	        Logln("Unicode:   " + cc.unicode);
	        Logln("Bytes:    " + Printbytes(cc.bytes, cc.bytes.Limit()));
	        ByteBuffer c = ILOG.J2CsMapping.NIO.ByteBuffer.Wrap(ILOG.J2CsMapping.Util.StringUtil.GetBytes(cc.cbopt));
	        Logln("Callback: " + Printbytes(c, c.Limit()) + " (" + cc.cbopt + ")");
	        Logln("...............................................");
	
	        // process the retrieved test data case
	        if (cc.offsets.Length == 0) {
	            cc.offsets = null;
	        } else if (cc.offsets.Length != cc.bytes.Limit()) {
	            Errln("fromUnicode[" + cc.caseNr + "] bytes[" + cc.bytes
	                    + "] and offsets[" + cc.offsets.Length
	                    + "] must have the same length");
	            return;
	        }
	
	        // check the callback replacement value
	        if (cc.cbopt.Length > 0) {
	
	            switch ((int) (cc.cbopt)[0]) {
	            case '?':
	                cc.cbErrorAction = ILOG.J2CsMapping.NIO.Charset.CodingErrorAction.REPLACE;
	                break;
	            case '0':
	                cc.cbErrorAction = ILOG.J2CsMapping.NIO.Charset.CodingErrorAction.IGNORE;
	                break;
	            case '.':
	                cc.cbErrorAction = ILOG.J2CsMapping.NIO.Charset.CodingErrorAction.REPORT;
	                break;
	            case '&':
	                cc.cbErrorAction = ILOG.J2CsMapping.NIO.Charset.CodingErrorAction.REPORT;
	                break;
	            default:
	                cc.cbErrorAction = null;
	                break;
	            }
	
	            // check for any options for the callback value --
	            cc.option = (cc.cbErrorAction == null) ? cc.cbopt : cc.cbopt.Substring(1);
	            if (cc.option == null) {
	                cc.option = null;
	            }
	        }
	        FromUnicodeCase(cc);
	    }
	
	    private void FromUnicodeCase(TestConversion.ConversionCase  cc) {
	
	        // create charset encoder for conversion test
	        CharsetProviderICU provider = new CharsetProviderICU();
	        Encoder encoder = null;
	        Encoding charset_0 = null;
	        try {
	            // if cc.charset starts with '*', obtain it from
	            // com/ibm/icu/dev/data/testdata
	            charset_0 = (cc.charset != null && cc.charset.Length > 0 && cc.charset[0] == '*') ? (Encoding) provider.CharsetForName(
	                    cc.charset.Substring(1), "../dev/data/testdata")
	                    : (Encoding) provider.CharsetForName(cc.charset);
	            encoder = (Encoder) charset_0.GetEncoder();
	            encoder.OnMalformedInput(ILOG.J2CsMapping.NIO.Charset.CodingErrorAction.REPLACE);
	            encoder.OnUnmappableCharacter(ILOG.J2CsMapping.NIO.Charset.CodingErrorAction.REPLACE);
	            if (encoder  is  CharsetEncoderICU) {
	                ((CharsetEncoderICU) encoder).SetFallbackUsed(cc.fallbacks);
	                if (((CharsetEncoderICU) encoder).IsFallbackUsed() != cc.fallbacks) {
	                    Errln("Fallback could not be set for " + cc.charset);
	                }
	            }
	
	        } catch (Exception e) {
	            // TODO implement loading of test data.
	            if (SkipIfBeforeICU(3, 9, 0)) {
	                Logln("Skipping test:(" + cc.charset
	                        + ") due to ICU Charset not supported at this time");
	            } else {
	                Errln(cc.charset + " was not found");
	            }
	            return;
	        }
	
	        // set the callback for the encoder
	        if (cc.cbErrorAction != null) {
	            encoder.OnUnmappableCharacter(cc.cbErrorAction);
	            encoder.OnMalformedInput(cc.cbErrorAction);
	
	            // if action has an option, put in the option for the case
	            if (cc.option.Equals("i")) {
	                encoder.OnMalformedInput(ILOG.J2CsMapping.NIO.Charset.CodingErrorAction.REPORT);
	            }
	
	            // if callback action is replace, and there is a subchar
	            // replace the decoder's default replacement value
	            // if substring, skip test due to current api not supporting
	            // substring
	            if (cc.cbErrorAction.Equals(ILOG.J2CsMapping.NIO.Charset.CodingErrorAction.REPLACE)) {
	                if (cc.cbopt.Length > 1) {
	                    if (cc.cbopt.Length > 1 && cc.cbopt[1] == '=') {
	                        Logln("Skipping test due to limitation in Java API - substitution string not supported");
	                        return;
	                    } else {
	                        // // read NUL-separated subchar first, if any
	                        // copy the subchar from Latin-1 characters
	                        // start after the NUL
	                        if (cc.cbopt[1] == 0x00) {
	                            cc.cbopt = cc.cbopt.Substring(2);
	
	                            try {
	                                encoder.ReplaceWith(ToByteArray(cc.cbopt));
	                            } catch (Exception e_1) {
	                                Logln("Skipping test due to limitation in Java API - substitution character sequence size error");
	                                return;
	                            }
	                        }
	                    }
	                }
	            }
	        }
	
	        // do charset encoding from unicode
	
	        // testing by steps using charset.encoder(in,out,flush)
	        int resultLength;
	        bool ok;
	        String[][] steps = { new String[] { "0", "bulk" },
	                new String[] { "1", "step=1" }, new String[] { "3", "step=3" },
	                new String[] { "7", "step=7" } };
	        int i, step;
	
	        ok = true;
	
	        for (i = 0; i < steps.Length && ok; ++i) {
	            step = Int32.Parse(steps[i][0]);
	
	            Logln("Testing step:[" + step + "]");
	            try {
	                resultLength = StepFromUnicode(cc, encoder, step);
	                ok = CheckFromUnicode(cc, resultLength);
	            } catch (Exception ex) {
	                Errln("Test failed: " + ex.GetType().FullName + " thrown: "
	                        + cc.charset + " [" + cc.caseNr + "]");
	                System.Console.Out.WriteLine(ex.StackTrace);
	                return;
	            }
	
	        }
	        // testing by whole buffer using out = charset.encoder(in)
	        while (ok && cc.finalFlush) {
	            Logln("Testing java API charset.encoder(in):");
	            cc.fromUnicodeResult = null;
	            ByteBuffer xout = null;
	
	            try {
	                xout = ILOG.J2CsMapping.NIO.ByteBuffer.Encode(ILOG.J2CsMapping.NIO.CharBuffer.Wrap(cc.unicode.ToCharArray()),encoder);
	                xout.Position(xout.Limit());
	                if (xout.Limit() != xout.Capacity()) {
	                    int pos = xout.Position();
	                    byte[] temp = xout.Array();
	                    xout = ILOG.J2CsMapping.NIO.ByteBuffer.Allocate(temp.Length * 4);
	                    xout.Put(temp);
	                    xout.Position(pos);
	                    CoderResult cr = encoder.Flush(xout);
	                    if (cr.IsOverflow()) {
	                        Logln("Overflow error with flushing encoder");
	                    }
	                }
	                cc.fromUnicodeResult = xout;
	
	                ok = CheckFromUnicode(cc, xout.Limit());
	                if (!ok) {
	                    break;
	                }
	            } catch (Exception e_2) {
	                // check the error code to see if it matches cc.errorCode
	                Logln("Encoder returned an error code");
	                Logln("ErrorCode expected is: " + cc.outErrorCode);
	                Logln("Error Result is: " + e_2.ToString());
	            }
	            break;
	        }
	    }
	
	    private int StepFromUnicode(TestConversion.ConversionCase  cc, Encoder encoder,
	            int step) {
	        if (step < 0) {
	            Errln("Negative step size, test internal error.");
	            return 0;
	        }
	
	        int sourceLen = cc.unicode.Length;
	        int targetLen = cc.bytes.Capacity() + 20; // for BOM, and to let
	                                                  // failures produce excess
	                                                  // output
	        CharBuffer source = ILOG.J2CsMapping.NIO.CharBuffer.Wrap(cc.unicode.ToCharArray());
	        ByteBuffer target = ILOG.J2CsMapping.NIO.ByteBuffer.Allocate(targetLen);
	        cc.fromUnicodeResult = null;
	        encoder.Reset();
	
	        int currentSourceLimit;
	        int currentTargetLimit;
	        if (step > 0) {
	            currentSourceLimit = Math.Min(step,sourceLen);
	            currentTargetLimit = Math.Min(step,targetLen);
	        } else {
	            currentSourceLimit = sourceLen;
	            currentTargetLimit = targetLen;
	        }
	
	        CoderResult cr = null;
	
	        for (;;) {
	            source.Limit(currentSourceLimit);
	            target.Limit(currentTargetLimit);
	
	            cr = encoder
	                    .Encode(source, target, currentSourceLimit == sourceLen);
	
	            if (cr.IsUnderflow()) {
	                if (currentSourceLimit == sourceLen) {
	                    // Do a final flush for cleanup, then break out
	                    // Encode loop, exits with cr==underflow in normal
	                    // operation.
	                    target.Limit(targetLen);
	                    cr = encoder.Flush(target);
	                    if (cr.IsUnderflow()) {
	                        // good
	                    } else if (cr.IsOverflow()) {
	                        Errln(cc.CaseNrAsString()
	                                + " Flush is producing excessive output");
	                    } else {
	                        Errln(cc.CaseNrAsString()
	                                + " Flush operation failed.  CoderResult = \""
	                                + cr.ToString() + "\"");
	                    }
	                    break;
	                }
	                currentSourceLimit = Math.Min(currentSourceLimit + step,sourceLen);
	            } else if (cr.IsOverflow()) {
	                if (currentTargetLimit == targetLen) {
	                    Errln(cc.CaseNrAsString()
	                            + " encode() is producing excessive output");
	                    break;
	                }
	                currentTargetLimit = Math.Min(currentTargetLimit + step,targetLen);
	            } else {
	                // check the error code to see if it matches cc.errorCode
	                Logln("Encoder returned an error code");
	                Logln("ErrorCode expected is: " + cc.outErrorCode);
	                Logln("Error Result is: " + cr.ToString());
	                break;
	            }
	
	        }
	
	        cc.fromUnicodeResult = target;
	        return target.Position();
	    }
	
	    private bool CheckFromUnicode(TestConversion.ConversionCase  cc, int resultLength) {
	        return CheckResultsFromUnicode(cc, cc.bytes, cc.fromUnicodeResult);
	    }
	
	    // toUnicode test worker functions -----------------------------------------
	    // ***
	
	    private void TestToUnicode(IBM.ICU.Dev.Test.TestDataModule.DataMap  testcase, int caseNr_0) {
	        // create Conversion case to store the test case data
	        TestConversion.ConversionCase  cc = new TestConversion.ConversionCase ();
	
	        try {
	            // retrieve test case data
	            cc.caseNr = caseNr_0;
	            cc.charset = ((ICUResourceBundle) testcase.GetObject("charset"))
	                    .GetString();
	            cc.bytes = ((ICUResourceBundle) testcase.GetObject("bytes"))
	                    .GetBinary();
	            cc.unicode = ((ICUResourceBundle) testcase.GetObject("unicode"))
	                    .GetString();
	            cc.offsets = ((ICUResourceBundle) testcase.GetObject("offsets"))
	                    .GetIntVector();
	            cc.finalFlush = ((ICUResourceBundle) testcase.GetObject("flush"))
	                    .GetUInt() != 0;
	            cc.fallbacks = ((ICUResourceBundle) testcase.GetObject("fallbacks"))
	                    .GetUInt() != 0;
	            cc.outErrorCode = ((ICUResourceBundle) testcase
	                    .GetObject("errorCode")).GetString();
	            cc.cbopt = ((ICUResourceBundle) testcase.GetObject("callback"))
	                    .GetString();
	
	        } catch (Exception e) {
	            Errln("Skipping test: error parsing conversion/toUnicode test case "
	                    + cc.caseNr);
	            return;
	        }
	
	        // ----for debugging only
	        Logln("");
	        Logln("TestToUnicode[" + caseNr_0 + "] " + cc.charset + " ");
	        Logln("Unicode:   " + IBM.ICU.Dev.Test.TestFmwk.Hex(cc.unicode));
	        Logln("Bytes:    " + Printbytes(cc.bytes, cc.bytes.Limit()));
	        ByteBuffer c = ILOG.J2CsMapping.NIO.ByteBuffer.Wrap(ILOG.J2CsMapping.Util.StringUtil.GetBytes(cc.cbopt));
	        Logln("Callback: " + Printbytes(c, c.Limit()) + " (" + cc.cbopt + ")");
	        Logln("...............................................");
	
	        // ----for debugging only
	
	        // TODO: This test case is skipped due to limitation in java's API for
	        // decoder replacement
	        // { "ibm-1363", :bin{ a2aea2 }, "\u00a1\u001a", :intvector{ 0, 2 },
	        // :int{1}, :int{0}, "", "?", :bin{""} }
	        if (cc.caseNr == 63 && SkipIfBeforeICU(3, 9, 0)) {
	            Logln("TestToUnicode[" + cc.caseNr + "] " + cc.charset);
	            Logln("Skipping test due to limitation in Java API - callback replacement value");
	            return;
	        }
	
	        // process the retrieved test data case
	        if (cc.offsets.Length == 0) {
	            cc.offsets = null;
	        } else if (cc.offsets.Length != cc.unicode.Length) {
	            Errln("Skipping test: toUnicode[" + cc.caseNr + "] unicode["
	                    + cc.unicode.Length + "] and offsets["
	                    + cc.offsets.Length + "] must have the same length");
	            return;
	        }
	        // check for the callback replacement value for unmappable
	        // characters or malformed errors
	        if (cc.cbopt.Length > 0) {
	            switch ((int) (cc.cbopt)[0]) {
	            case '?': // CALLBACK_SUBSTITUTE
	                cc.cbErrorAction = ILOG.J2CsMapping.NIO.Charset.CodingErrorAction.REPLACE;
	                break;
	            case '0': // CALLBACK_SKIP
	                cc.cbErrorAction = ILOG.J2CsMapping.NIO.Charset.CodingErrorAction.IGNORE;
	                break;
	            case '.': // CALLBACK_STOP
	                cc.cbErrorAction = ILOG.J2CsMapping.NIO.Charset.CodingErrorAction.REPORT;
	                break;
	            case '&': // CALLBACK_ESCAPE
	                cc.cbErrorAction = ILOG.J2CsMapping.NIO.Charset.CodingErrorAction.REPORT;
	                break;
	            default:
	                cc.cbErrorAction = null;
	                break;
	            }
	        }
	        // check for any options for the callback value
	        cc.option = (cc.cbErrorAction == null) ? null : cc.cbopt.Substring(1);
	        if (cc.option == null) {
	            cc.option = null;
	        }
	
	        ToUnicodeCase(cc);
	
	    }
	
	    private void ToUnicodeCase(TestConversion.ConversionCase  cc) {
	
	        // create converter for charset and decoder for each test case
	        CharsetProviderICU provider = new CharsetProviderICU();
	        Decoder decoder = null;
	        Encoding charset_0 = null;
	
	        try {
	            // if cc.charset starts with '*', obtain it from
	            // com/ibm/icu/dev/data/testdata
	            charset_0 = (cc.charset != null && cc.charset.Length > 0 && cc.charset[0] == '*') ? (Encoding) provider.CharsetForName(
	                    cc.charset.Substring(1), "../dev/data/testdata")
	                    : (Encoding) provider.CharsetForName(cc.charset);
	            decoder = (Decoder) charset_0.GetDecoder();
	            decoder.OnMalformedInput(ILOG.J2CsMapping.NIO.Charset.CodingErrorAction.REPLACE);
	            decoder.OnUnmappableCharacter(ILOG.J2CsMapping.NIO.Charset.CodingErrorAction.REPLACE);
	
	        } catch (Exception e) {
	            // TODO implement loading of test data.
	            if (SkipIfBeforeICU(3, 9, 0)) {
	                Logln("Skipping test:(" + cc.charset
	                        + ") due to ICU Charset not supported at this time");
	            } else {
	                Errln(cc.charset + " was not found");
	            }
	            return;
	        }
	
	        // set the callback for the decoder
	        if (cc.cbErrorAction != null) {
	            decoder.OnMalformedInput(cc.cbErrorAction);
	            decoder.OnUnmappableCharacter(cc.cbErrorAction);
	
	            // set the options (if any: SKIP_STOP_ON_ILLEGAL) for callback
	            if (cc.option.Equals("i")) {
	                decoder.OnMalformedInput(ILOG.J2CsMapping.NIO.Charset.CodingErrorAction.REPORT);
	            }
	
	            // if callback action is replace, and there is a subchar
	            // replace the decoder's default replacement value
	            // if substring, skip test due to current api not supporting
	            // substring replacement
	            if (cc.cbErrorAction.Equals(ILOG.J2CsMapping.NIO.Charset.CodingErrorAction.REPLACE)) {
	                if (cc.cbopt.Length > 1) {
	                    if (cc.cbopt[1] == '=') {
	                        Logln("Skipping test due to limitation in Java API - substitution string not supported");
	
	                    } else {
	                        // // read NUL-separated subchar first, if any
	                        // copy the subchar from Latin-1 characters
	                        // start after the NUL
	                        if (cc.cbopt[1] == 0x00) {
	                            cc.cbopt = cc.cbopt.Substring(2);
	
	                            try {
	                                decoder.ReplaceWith(cc.cbopt);
	                            } catch (Exception e_1) {
	                                Logln("Skipping test due to limitation in Java API - substitution character sequence size error");
	                            }
	                        }
	                    }
	                }
	            }
	        }
	
	        // Check the step to unicode
	        bool ok;
	        int resultLength;
	
	        String[][] steps = { new String[] { "0", "bulk" },
	                new String[] { "1", "step=1" }, new String[] { "3", "step=3" },
	                new String[] { "7", "step=7" } };
	
	        ok = true;
	        int step;
	        // testing by steps using the CoderResult cr =
	        // charset.decoder(in,out,flush) api
	        for (int i = 0; i < steps.Length && ok; ++i) {
	            step = Int32.Parse(steps[i][0]);
	
	            if (step < 0 && !cc.finalFlush) {
	                continue;
	            }
	            Logln("Testing step:[" + step + "]");
	
	            try {
	                resultLength = StepToUnicode(cc, decoder, step);
	                ok = CheckToUnicode(cc, resultLength);
	            } catch (Exception ex) {
	                Errln("Test failed: " + ex.GetType().FullName + " thrown: "
	                        + cc.charset + " [" + cc.caseNr + "]");
	                System.Console.Out.WriteLine(ex.StackTrace);
	                return;
	            }
	        }
	
	        // testing the java's out = charset.decoder(in) api
	        while (ok && cc.finalFlush) {
	            Logln("Testing java charset.decoder(in):");
	            cc.toUnicodeResult = null;
	            CharBuffer xout = null;
	
	            try {
	                xout = ILOG.J2CsMapping.NIO.CharBuffer.Decode(ILOG.J2CsMapping.NIO.ByteBuffer.Wrap(cc.bytes.Array()),decoder);
	                xout.Position(xout.Limit());
	                if (xout.Limit() < cc.unicode.Length) {
	                    int pos = xout.Position();
	                    char[] temp = xout.Array();
	                    xout = ILOG.J2CsMapping.NIO.CharBuffer.Allocate(cc.bytes.Limit());
	                    xout.Put(temp);
	                    xout.Position(pos);
	                    CoderResult cr = decoder.Flush(xout);
	                    if (cr.IsOverflow()) {
	                        Logln("Overflow error with flushing decodering");
	                    }
	                }
	
	                cc.toUnicodeResult = xout;
	
	                ok = CheckToUnicode(cc, xout.Limit());
	                if (!ok) {
	                    break;
	                }
	            } catch (Exception e_2) {
	                // check the error code to see if it matches cc.errorCode
	                Logln("Decoder returned an error code");
	                Logln("ErrorCode expected is: " + cc.outErrorCode);
	                Logln("Error Result is: " + e_2.ToString());
	            }
	            break;
	        }
	
	        return;
	    }
	
	    private int StepToUnicode(TestConversion.ConversionCase  cc, Decoder decoder,
	            int step)
	
	    {
	        ByteBuffer source;
	        CharBuffer target;
	        bool flush = false;
	        int sourceLen;
	        source = cc.bytes;
	        sourceLen = cc.bytes.Limit();
	        source.Position(0);
	        target = ILOG.J2CsMapping.NIO.CharBuffer.Allocate(cc.unicode.Length + 4);
	        target.Position(0);
	        cc.toUnicodeResult = null;
	        decoder.Reset();
	
	        if (step >= 0) {
	
	            int iStep = step;
	            int oStep = step;
	
	            for (;;) {
	
	                if (step != 0) {
	                    source.Limit((iStep <= sourceLen) ? iStep : sourceLen);
	                    target.Limit((oStep <= target.Capacity()) ? oStep : target
	                            .Capacity());
	                    flush = (cc.finalFlush && source.Limit() == sourceLen);
	
	                } else {
	                    // bulk mode
	                    source.Limit(sourceLen);
	                    target.Limit(target.Capacity());
	                    flush = cc.finalFlush;
	                }
	                // convert
	                CoderResult cr = null;
	                if (source.HasRemaining()) {
	
	                    cr = decoder.Decode(source, target, flush);
	                    // check pointers and errors
	                    if (cr.IsOverflow()) {
	                        // the partial target is filled, set a new limit,
	                        oStep = (target.Position() + step);
	                        target.Limit((oStep < target.Capacity()) ? oStep
	                                : target.Capacity());
	                        if (target.Limit() > target.Capacity()) {
	                            // target has reached its limit, an error occurred
	                            // or test case has an error code
	                            // check error code
	                            Logln("UnExpected error: Target Buffer is larger than capacity");
	                            break;
	                        }
	
	                    } else if (cr.IsError()) {
	                        // check the error code to see if it matches
	                        // cc.errorCode
	                        Logln("Decoder returned an error code");
	                        Logln("ErrorCode expected is: " + cc.outErrorCode);
	                        Logln("Error Result is: " + cr.ToString());
	                        break;
	                    }
	
	                } else {
	                    if (source.Limit() == sourceLen) {
	
	                        cr = decoder.Decode(source, target, true);
	
	                        // due to limitation of the API we need to check for
	                        // target limit for expected
	                        if (target.Limit() != cc.unicode.Length) {
	                            target.Limit(cc.unicode.Length);
	                            cr = decoder.Flush(target);
	                            if (cr.IsError()) {
	                                Errln("Flush operation failed");
	                            }
	                        }
	                        break;
	                    }
	                }
	                iStep += step;
	                oStep += step;
	
	            }
	
	        }// if(step ==0)
	
	        // --------------------------------------------------------------------------
	        else /* step<0 */{
	            /*
	             * step==-1: call only ucnv_getNextUChar() otherwise alternate
	             * between ucnv_toUnicode() and ucnv_getNextUChar() if step==-2 or
	             * -3, then give ucnv_toUnicode() the whole remaining input, else
	             * give it at most (-step-2)/2 bytes
	             */
	
	            for (;;) {
	                // convert
	                if ((step & 1) != 0 /* odd: -1, -3, -5, ... */) {
	
	                    target.Limit((target.Position() < target.Capacity()) ? target
	                            .Position() + 1 : target.Capacity());
	
	                    // decode behavior is return to output target 1 character
	                    CoderResult cr_0 = null;
	
	                    // similar to getNextUChar() , input is the whole string,
	                    // while outputs only 1 character
	                    source.Limit(sourceLen);
	                    while (target.Position() != target.Limit()
	                            && source.HasRemaining()) {
	                        cr_0 = decoder.Decode(source, target,
	                                source.Limit() == sourceLen);
	
	                        if (cr_0.IsOverflow()) {
	
	                            if (target.Limit() >= target.Capacity()) {
	                                // target has reached its limit, an error
	                                // occurred
	                                Logln("UnExpected error: Target Buffer is larger than capacity");
	                                break;
	                            } else {
	                                // 1 character has been consumed
	                                target.Limit(target.Position() + 1);
	                                break;
	                            }
	                        } else if (cr_0.IsError()) {
	                            Logln("Decoder returned an error code");
	                            Logln("ErrorCode expected is: " + cc.outErrorCode);
	                            Logln("Error Result is: " + cr_0.ToString());
	
	                            cc.toUnicodeResult = target;
	                            return target.Position();
	                        }
	
	                        else {
	                            // one character has been consumed
	                            if (target.Limit() == target.Position()) {
	                                target.Limit(target.Position() + 1);
	                                break;
	                            }
	                        }
	
	                    }
	                    if (source.Position() == sourceLen) {
	
	                        // due to limitation of the API we need to check
	                        // for target limit for expected
	                        cr_0 = decoder.Decode(source, target, true);
	                        if (target.Position() != cc.unicode.Length) {
	
	                            target.Limit(cc.unicode.Length);
	                            cr_0 = decoder.Flush(target);
	                            if (cr_0.IsError()) {
	                                Errln("Flush operation failed");
	                            }
	                        }
	                        break;
	                    }
	                    // alternate between -n-1 and -n but leave -1 alone
	                    if (step < -1) {
	                        ++step;
	                    }
	                } else {/* step is even */
	                    // allow only one UChar output
	
	                    target.Limit((target.Position() < target.Capacity()) ? target
	                            .Position() + 1 : target.Capacity());
	                    if (step == -2) {
	                        source.Limit(sourceLen);
	                    } else {
	                        source.Limit(source.Position() + (-step - 2) / 2);
	                        if (source.Limit() > sourceLen) {
	                            source.Limit(sourceLen);
	                        }
	                    }
	                    CoderResult cr_1 = decoder.Decode(source, target,
	                            source.Limit() == sourceLen);
	                    // check pointers and errors
	                    if (cr_1.IsOverflow()) {
	                        // one character has been consumed
	                        if (target.Limit() >= target.Capacity()) {
	                            // target has reached its limit, an error occurred
	                            Logln("Unexpected error: Target Buffer is larger than capacity");
	                            break;
	                        }
	                    } else if (cr_1.IsError()) {
	                        Logln("Decoder returned an error code");
	                        Logln("ErrorCode expected is: " + cc.outErrorCode);
	                        Logln("Error Result is: " + cr_1.ToString());
	                        break;
	                    }
	
	                    --step;
	                }
	            }
	        }
	
	        // --------------------------------------------------------------------------
	
	        cc.toUnicodeResult = target;
	        return target.Position();
	    }
	
	    private bool CheckToUnicode(TestConversion.ConversionCase  cc, int resultLength) {
	        return CheckResultsToUnicode(cc, cc.unicode, cc.toUnicodeResult);
	    }
	
	    private void TestGetUnicodeSet(IBM.ICU.Dev.Test.TestDataModule.DataMap  testcase) {
	        /*
	         * charset - will be opened, and ucnv_getUnicodeSet() called on it //
	         * map - set of code points and strings that must be in the returned set
	         * // mapnot - set of code points and strings that must *not* be in the
	         * // returned set // which - numeric UConverterUnicodeSet value Headers
	         * { "charset", "map", "mapnot", "which" }
	         */
	        TestConversion.ConversionCase  cc = new TestConversion.ConversionCase ();
	        // retrieve test case data
	        cc.charset = ((ICUResourceBundle) testcase.GetObject("charset"))
	                .GetString();
	        cc.map = ((ICUResourceBundle) testcase.GetObject("map")).GetString();
	        cc.mapnot = ((ICUResourceBundle) testcase.GetObject("mapnot"))
	                .GetString();
	        cc.which = ((ICUResourceBundle) testcase.GetObject("which")).GetUInt();
	
	        // create charset and encoder for each test case
	        Logln("TestGetUnicodeSet not supported at this time");
	
	    }
	
	    /// <summary>
	    /// This follows ucnv.c method ucnv_detectUnicodeSignature() to detect the
	    /// start of the stream for example U+FEFF (the Unicode BOM/signature
	    /// character) that can be ignored.
	    /// Detects Unicode signature byte sequences at the start of the byte stream
	    /// and returns number of bytes of the BOM of the indicated Unicode charset.
	    /// 0 is returned when no Unicode signature is recognized.
	    /// </summary>
	    ///
	
	    private String DetectUnicodeSignature(ByteBuffer source) {
	        int signatureLength = 0; // number of bytes of the signature
	        int SIG_MAX_LEN = 5;
	        String sigUniCharset = null; // states what unicode charset is the BOM
	        int i = 0;
	
	        byte[] start = { (byte) 0xa5, (byte) 0xa5, (byte) 0xa5, (byte) 0xa5,
	                (byte) 0xa5 };
	
	        while (i < source.Limit() && i < SIG_MAX_LEN) {
	            start[i] = source.Get(i);
	            i++;
	        }
	
	        if (start[0] == (byte) 0xFE && start[1] == (byte) 0xFF) {
	            signatureLength = 2;
	            sigUniCharset = "UTF-16BE";
	            source.Position(signatureLength);
	            return sigUniCharset;
	        } else if (start[0] == (byte) 0xFF && start[1] == (byte) 0xFE) {
	            if (start[2] == (byte) 0x00 && start[3] == (byte) 0x00) {
	                signatureLength = 4;
	                sigUniCharset = "UTF-32LE";
	                source.Position(signatureLength);
	                return sigUniCharset;
	            } else {
	                signatureLength = 2;
	                sigUniCharset = "UTF-16LE";
	                source.Position(signatureLength);
	                return sigUniCharset;
	            }
	        } else if (start[0] == (byte) 0xEF && start[1] == (byte) 0xBB
	                && start[2] == (byte) 0xBF) {
	            signatureLength = 3;
	            sigUniCharset = "UTF-8";
	            source.Position(signatureLength);
	            return sigUniCharset;
	        } else if (start[0] == (byte) 0x00 && start[1] == (byte) 0x00
	                && start[2] == (byte) 0xFE && start[3] == (byte) 0xFF) {
	            signatureLength = 4;
	            sigUniCharset = "UTF-32BE";
	            source.Position(signatureLength);
	            return sigUniCharset;
	        } else if (start[0] == (byte) 0x0E && start[1] == (byte) 0xFE
	                && start[2] == (byte) 0xFF) {
	            signatureLength = 3;
	            sigUniCharset = "SCSU";
	            source.Position(signatureLength);
	            return sigUniCharset;
	        } else if (start[0] == (byte) 0xFB && start[1] == (byte) 0xEE
	                && start[2] == (byte) 0x28) {
	            signatureLength = 3;
	            sigUniCharset = "BOCU-1";
	            source.Position(signatureLength);
	            return sigUniCharset;
	        } else if (start[0] == (byte) 0x2B && start[1] == (byte) 0x2F
	                && start[2] == (byte) 0x76) {
	
	            if (start[3] == (byte) 0x38 && start[4] == (byte) 0x2D) {
	                signatureLength = 5;
	                sigUniCharset = "UTF-7";
	                source.Position(signatureLength);
	                return sigUniCharset;
	            } else if (start[3] == (byte) 0x38 || start[3] == (byte) 0x39
	                    || start[3] == (byte) 0x2B || start[3] == (byte) 0x2F) {
	                signatureLength = 4;
	                sigUniCharset = "UTF-7";
	                source.Position(signatureLength);
	                return sigUniCharset;
	            }
	        } else if (start[0] == (byte) 0xDD && start[2] == (byte) 0x73
	                && start[2] == (byte) 0x66 && start[3] == (byte) 0x73) {
	            signatureLength = 4;
	            sigUniCharset = "UTF-EBCDIC";
	            source.Position(signatureLength);
	            return sigUniCharset;
	        }
	
	        /* no known Unicode signature byte sequence recognized */
	        return null;
	    }
	
	    internal String Printbytes(ByteBuffer buf, int pos) {
	        int cur = buf.Position();
	        String res = " (" + pos + ")==[";
	        for (int i = 0; i < pos; i++) {
	            res += "(" + i + ")" + IBM.ICU.Dev.Test.TestFmwk.Hex(buf.Get(i) & 0xff).Substring(2) + " ";
	        }
	        buf.Position(cur);
	        return res + "]";
	    }
	
	    internal String Printchars(CharBuffer buf, int pos) {
	        int cur = buf.Position();
	        String res = " (" + pos + ")==[";
	        for (int i = 0; i < pos; i++) {
	            res += "(" + i + ")" + IBM.ICU.Dev.Test.TestFmwk.Hex(buf.Get(i)) + " ";
	        }
	        buf.Position(cur);
	        return res + "]";
	    }
	
	    private bool CheckResultsFromUnicode(TestConversion.ConversionCase  cc,
	            ByteBuffer expected, ByteBuffer output) {
	
	        bool res = true;
	        expected.Rewind();
	        output.Limit(output.Position());
	        output.Rewind();
	
	        // remove any BOM signature before checking
	        DetectUnicodeSignature(output); // sets the position to after the BOM
	        output = output.Slice(); // removes anything before the current position
	
	        if (output.Limit() != expected.Limit()) {
	            Errln("Test failed: output length does not match expected for charset: "
	                    + cc.charset + " [" + cc.caseNr + "]");
	            res = false;
	        } else {
	            while (output.HasRemaining()) {
	                if (output.Get() != expected.Get()) {
	                    Errln("Test failed: output does not match expected for charset: "
	                            + cc.charset + " [" + cc.caseNr + "]");
	                    res = false;
	                    break;
	                }
	            }
	        }
	
	        if (res) {
	            Logln("[" + cc.caseNr + "]:" + cc.charset);
	            Logln("Input:       "
	                    + Printchars(ILOG.J2CsMapping.NIO.CharBuffer.Wrap(cc.unicode),
	                            cc.unicode.Length));
	            Logln("Output:      " + Printbytes(output, output.Limit()));
	            Logln("Expected:    " + Printbytes(expected, expected.Limit()));
	            Logln("Passed");
	        } else {
	            Errln("[" + cc.caseNr + "]:" + cc.charset);
	            Errln("Input:       "
	                    + Printchars(ILOG.J2CsMapping.NIO.CharBuffer.Wrap(cc.unicode),
	                            cc.unicode.Length));
	            Errln("Output:      " + Printbytes(output, output.Limit()));
	            Errln("Expected:    " + Printbytes(expected, expected.Limit()));
	            Errln("Failed");
	        }
	        return res;
	    }
	
	    private bool CheckResultsToUnicode(TestConversion.ConversionCase  cc, String expected,
	            CharBuffer output) {
	
	        bool res = true;
	        output.Limit(output.Position());
	        output.Rewind();
	
	        // test to see if the conversion matches actual results
	        if (output.Limit() != expected.Length) {
	            Errln("Test failed: output length does not match expected for charset: "
	                    + cc.charset + " [" + cc.caseNr + "]");
	            res = false;
	        } else {
	            for (int i = 0; i < expected.Length; i++) {
	                if (output.Get(i) != expected[i]) {
	                    Errln("Test failed: output does not match expected for charset: "
	                            + cc.charset + " [" + cc.caseNr + "]");
	                    res = false;
	                    break;
	                }
	            }
	        }
	
	        if (res) {
	            Logln("[" + cc.caseNr + "]:" + cc.charset);
	            Logln("Input:       " + Printbytes(cc.bytes, cc.bytes.Limit()));
	            Logln("Output:      " + Printchars(output, output.Limit()));
	            Logln("Expected:    "
	                    + Printchars(ILOG.J2CsMapping.NIO.CharBuffer.Wrap(expected), expected.Length));
	            Logln("Passed");
	        } else {
	            Errln("[" + cc.caseNr + "]:" + cc.charset);
	            Errln("Input:       " + Printbytes(cc.bytes, cc.bytes.Limit()));
	            Errln("Output:      " + Printchars(output, output.Limit()));
	            Errln("Expected:    "
	                    + Printchars(ILOG.J2CsMapping.NIO.CharBuffer.Wrap(expected), expected.Length));
	            Errln("Failed");
	        }
	        return res;
	    }
	
	    private byte[] ToByteArray(String str) {
	        byte[] ret = new byte[str.Length];
	        for (int i = 0; i < ret.Length; i++) {
	            char ch = str[i];
	            if (ch <= 0xFF) {
	                ret[i] = (byte) ch;
	            } else {
	                throw new ArgumentException(" byte value out of range: "
	                        + ch);
	            }
	        }
	        return ret;
	    }
	}
}
