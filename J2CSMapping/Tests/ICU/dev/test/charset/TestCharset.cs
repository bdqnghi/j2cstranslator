// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/16/10 2:46 PM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2006-2007, International Business Machines Corporation and    
/// others. All Rights Reserved.                                                
/// </summary>
///
namespace IBM.ICU.Dev.Test.Charset {
	
	using IBM.ICU.Charset;
	using IBM.ICU.Dev.Test;
	using ILOG.J2CsMapping.Collections;
	using ILOG.J2CsMapping.Collections.Generics;
	using ILOG.J2CsMapping.NIO;
	using ILOG.J2CsMapping.NIO.Charset;
	using ILOG.J2CsMapping.NIO.Charset.Spi;
	using ILOG.J2CsMapping.NIO.charset;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Resources;
	using System.Runtime.CompilerServices;
	using System.Text;
	
	public class TestCharset : TestFmwk {
	    public TestCharset() {
	        this.m_encoding = "UTF-16";
	        this.m_decoder = null;
	        this.m_encoder = null;
	        this.m_charset = null;
	    }
	
	    private String m_encoding;
	
	    internal Decoder m_decoder;
	
	    internal Encoder m_encoder;
	
	    internal Encoding m_charset;
	
	    internal const String unistr = "abcd\ud800\udc00\u1234\u00a5\u3000\r\n";
	
	    static internal readonly byte[] byteStr = { (byte) 0x00, (byte) 'a', (byte) 0x00,
	            (byte) 'b', (byte) 0x00, (byte) 'c', (byte) 0x00, (byte) 'd',
	            (byte) 0xd8, (byte) 0x00, (byte) 0xdc, (byte) 0x00, (byte) 0x12,
	            (byte) 0x34, (byte) 0x00, (byte) 0xa5, (byte) 0x30, (byte) 0x00,
	            (byte) 0x00, (byte) 0x0d, (byte) 0x00, (byte) 0x0a };
	
	    static internal readonly byte[] expectedByteStr = { (byte) 0xfe, (byte) 0xff,
	            (byte) 0x00, (byte) 'a', (byte) 0x00, (byte) 'b', (byte) 0x00,
	            (byte) 'c', (byte) 0x00, (byte) 'd', (byte) 0xd8, (byte) 0x00,
	            (byte) 0xdc, (byte) 0x00, (byte) 0x12, (byte) 0x34, (byte) 0x00,
	            (byte) 0xa5, (byte) 0x30, (byte) 0x00, (byte) 0x00, (byte) 0x0d,
	            (byte) 0x00, (byte) 0x0a };
	
	    protected internal override void Init() {
	        try {
	            CharsetProviderICU provider = new CharsetProviderICU();
	            // Charset charset = CharsetICU.forName(encoding);
	            m_charset = provider.CharsetForName(m_encoding);
	            m_decoder = (Decoder) m_charset.GetDecoder();
	            m_encoder = (Encoder) m_charset.GetEncoder();
	        } catch (MissingManifestResourceException ex) {
	            Warnln("Could not load charset data");
	        }
	    }
	
	    public static void Main(String[] args) {
	        new TestCharset().Run(args);
	    }
	
	    public void TestUTF16Converter() {
	        CharsetProvider icu = new CharsetProviderICU();
	        Encoding cs1 = icu.CharsetForName("UTF-16BE");
	        Encoder e1 = cs1.GetEncoder();
	        Decoder d1 = cs1.GetDecoder();
	
	        Encoding cs2 = icu.CharsetForName("UTF-16LE");
	        Encoder e2 = cs2.GetEncoder();
	        Decoder d2 = cs2.GetDecoder();
	
	        for (int i = 0x0000; i < 0x10FFFF; i += 0xFF) {
	            CharBuffer us = ILOG.J2CsMapping.NIO.CharBuffer.Allocate(0xFF * 2);
	            ByteBuffer bs1 = ILOG.J2CsMapping.NIO.ByteBuffer.Allocate(0xFF * 8);
	            ByteBuffer bs2 = ILOG.J2CsMapping.NIO.ByteBuffer.Allocate(0xFF * 8);
	            for (int j = 0; j < 0xFF; j++) {
	                int c = i + j;
	
	                if ((c >= 0xd800 && c <= 0xdFFF) || c > 0x10FFFF) {
	                    continue;
	                }
	
	                if (c > 0xFFFF) {
	                    char lead = IBM.ICU.Text.UTF16.GetLeadSurrogate(c);
	                    char trail = IBM.ICU.Text.UTF16.GetTrailSurrogate(c);
	                    if (!IBM.ICU.Text.UTF16.IsLeadSurrogate(lead)) {
	                        Errln("lead is not lead!" + lead + " for cp: \\U"
	                                + ILOG.J2CsMapping.Util.IlNumber.ToString(c,16));
	                        continue;
	                    }
	                    if (!IBM.ICU.Text.UTF16.IsTrailSurrogate(trail)) {
	                        Errln("trail is not trail!" + trail);
	                        continue;
	                    }
	                    us.Put(lead);
	                    us.Put(trail);
	                    bs1.Put((byte) (lead >> 8));
	                    bs1.Put((byte) (lead & 0xFF));
	                    bs1.Put((byte) (trail >> 8));
	                    bs1.Put((byte) (trail & 0xFF));
	
	                    bs2.Put((byte) (lead & 0xFF));
	                    bs2.Put((byte) (lead >> 8));
	                    bs2.Put((byte) (trail & 0xFF));
	                    bs2.Put((byte) (trail >> 8));
	                } else {
	
	                    if (c < 0xFF) {
	                        bs1.Put((byte) 0x00);
	                        bs1.Put((byte) (c));
	                        bs2.Put((byte) (c));
	                        bs2.Put((byte) 0x00);
	                    } else {
	                        bs1.Put((byte) (c >> 8));
	                        bs1.Put((byte) (c & 0xFF));
	
	                        bs2.Put((byte) (c & 0xFF));
	                        bs2.Put((byte) (c >> 8));
	                    }
	                    us.Put((char) c);
	                }
	            }
	
	            us.Limit(us.Position());
	            us.Position(0);
	            if (us.Length == 0) {
	                continue;
	            }
	
	            bs1.Limit(bs1.Position());
	            bs1.Position(0);
	            ByteBuffer newBS = ILOG.J2CsMapping.NIO.ByteBuffer.Allocate(bs1.Capacity());
	            // newBS.put((byte)0xFE);
	            // newBS.put((byte)0xFF);
	            newBS.Put(bs1);
	            bs1.Position(0);
	            SmBufDecode(d1, "UTF-16", bs1, us);
	            SmBufEncode(e1, "UTF-16", us, newBS);
	
	            bs2.Limit(bs2.Position());
	            bs2.Position(0);
	            newBS.Clear();
	            // newBS.put((byte)0xFF);
	            // newBS.put((byte)0xFE);
	            newBS.Put(bs2);
	            bs2.Position(0);
	            SmBufDecode(d2, "UTF16-LE", bs2, us);
	            SmBufEncode(e2, "UTF-16LE", us, newBS);
	
	        }
	    }
	
	    public void TestUTF32Converter() {
	        CharsetProvider icu = new CharsetProviderICU();
	        Encoding cs1 = icu.CharsetForName("UTF-32BE");
	        Encoder e1 = cs1.GetEncoder();
	        Decoder d1 = cs1.GetDecoder();
	
	        Encoding cs2 = icu.CharsetForName("UTF-32LE");
	        Encoder e2 = cs2.GetEncoder();
	        Decoder d2 = cs2.GetDecoder();
	
	        for (int i = 0x000; i < 0x10FFFF; i += 0xFF) {
	            CharBuffer us = ILOG.J2CsMapping.NIO.CharBuffer.Allocate(0xFF * 2);
	            ByteBuffer bs1 = ILOG.J2CsMapping.NIO.ByteBuffer.Allocate(0xFF * 8);
	            ByteBuffer bs2 = ILOG.J2CsMapping.NIO.ByteBuffer.Allocate(0xFF * 8);
	            for (int j = 0; j < 0xFF; j++) {
	                int c = i + j;
	
	                if ((c >= 0xd800 && c <= 0xdFFF) || c > 0x10FFFF) {
	                    continue;
	                }
	
	                if (c > 0xFFFF) {
	                    char lead = IBM.ICU.Text.UTF16.GetLeadSurrogate(c);
	                    char trail = IBM.ICU.Text.UTF16.GetTrailSurrogate(c);
	
	                    us.Put(lead);
	                    us.Put(trail);
	                } else {
	                    us.Put((char) c);
	                }
	                bs1.Put((byte) ((int) (((uint) c) >> 24)));
	                bs1.Put((byte) ((int) (((uint) c) >> 16)));
	                bs1.Put((byte) ((int) (((uint) c) >> 8)));
	                bs1.Put((byte) (c & 0xFF));
	
	                bs2.Put((byte) (c & 0xFF));
	                bs2.Put((byte) ((int) (((uint) c) >> 8)));
	                bs2.Put((byte) ((int) (((uint) c) >> 16)));
	                bs2.Put((byte) ((int) (((uint) c) >> 24)));
	            }
	            bs1.Limit(bs1.Position());
	            bs1.Position(0);
	            bs2.Limit(bs2.Position());
	            bs2.Position(0);
	            us.Limit(us.Position());
	            us.Position(0);
	            if (us.Length == 0) {
	                continue;
	            }
	
	            ByteBuffer newBS = ILOG.J2CsMapping.NIO.ByteBuffer.Allocate(bs1.Capacity());
	
	            newBS.Put((byte) 0x00);
	            newBS.Put((byte) 0x00);
	            newBS.Put((byte) 0xFE);
	            newBS.Put((byte) 0xFF);
	
	            newBS.Put(bs1);
	            bs1.Position(0);
	            SmBufDecode(d1, "UTF-32", bs1, us);
	            SmBufEncode(e1, "UTF-32", us, newBS);
	
	            newBS.Clear();
	
	            newBS.Put((byte) 0xFF);
	            newBS.Put((byte) 0xFE);
	            newBS.Put((byte) 0x00);
	            newBS.Put((byte) 0x00);
	
	            newBS.Put(bs2);
	            bs2.Position(0);
	            SmBufDecode(d2, "UTF-32LE", bs2, us);
	            SmBufEncode(e2, "UTF-32LE", us, newBS);
	
	        }
	    }
	
	    public void TestASCIIConverter() {
	        RunTestASCIIBasedConverter("ASCII", 0x80);
	    }
	
	    public void Test88591Converter() {
	        RunTestASCIIBasedConverter("iso-8859-1", 0x100);
	    }
	
	    public void RunTestASCIIBasedConverter(String converter, int limit) {
	        CharsetProvider icu = new CharsetProviderICU();
	        Encoding icuChar = icu.CharsetForName(converter);
	        Encoder encoder = icuChar.GetEncoder();
	        Decoder decoder = icuChar.GetDecoder();
	        CoderResult cr;
	
	        /* test with and without array-backed buffers */
	
	        byte[] bytes = new byte[0x10000];
	        char[] chars = new char[0x10000];
	        for (int j = 0; j <= 0xffff; j++) {
	            bytes[j] = (byte) j;
	            chars[j] = (char) j;
	        }
	
	        bool fail = false;
	        bool arrays = false;
	        bool decoding = false;
	        int i;
	
	        // 0 thru limit - 1
	        ByteBuffer bs = ILOG.J2CsMapping.NIO.ByteBuffer.Wrap(bytes, 0, limit);
	        CharBuffer us = ILOG.J2CsMapping.NIO.CharBuffer.Wrap(chars, 0, limit);
	        SmBufDecode(decoder, converter, bs, us, true);
	        SmBufDecode(decoder, converter, bs, us, false);
	        SmBufEncode(encoder, converter, us, bs, true);
	        SmBufEncode(encoder, converter, us, bs, false);
	        for (i = 0; i < limit; i++) {
	            bs = ILOG.J2CsMapping.NIO.ByteBuffer.Wrap(bytes, i, 1).Slice();
	            us = ILOG.J2CsMapping.NIO.CharBuffer.Wrap(chars, i, 1).Slice();
	            try {
	                decoding = true;
	                arrays = true;
	                SmBufDecode(decoder, converter, bs, us, true, false, true);
	
	                decoding = true;
	                arrays = false;
	                SmBufDecode(decoder, converter, bs, us, true, false, false);
	
	                decoding = false;
	                arrays = true;
	                SmBufEncode(encoder, converter, us, bs, true, false, true);
	
	                decoding = false;
	                arrays = false;
	                SmBufEncode(encoder, converter, us, bs, true, false, false);
	
	            } catch (Exception ex) {
	                Errln("Failed to fail to " + ((decoding) ? "decode" : "encode")
	                        + " 0x" + ILOG.J2CsMapping.Util.IlNumber.ToString(i,16)
	                        + ((arrays) ? " with arrays" : " without arrays")
	                        + " in " + converter);
	                return;
	            }
	        }
	
	        // decode limit thru 255
	        for (i = limit; i <= 0xff; i++) {
	            bs = ILOG.J2CsMapping.NIO.ByteBuffer.Wrap(bytes, i, 1).Slice();
	            us = ILOG.J2CsMapping.NIO.CharBuffer.Wrap(chars, i, 1).Slice();
	            try {
	                SmBufDecode(decoder, converter, bs, us, true, false, true);
	                fail = true;
	                arrays = true;
	                break;
	            } catch (Exception ex_0) {
	            }
	            try {
	                SmBufDecode(decoder, converter, bs, us, true, false, false);
	                fail = true;
	                arrays = false;
	                break;
	            } catch (Exception ex_1) {
	            }
	        }
	        if (fail) {
	            Errln("Failed to fail to decode 0x" + ILOG.J2CsMapping.Util.IlNumber.ToString(i,16)
	                    + ((arrays) ? " with arrays" : " without arrays") + " in "
	                    + converter);
	            return;
	        }
	
	        // encode limit thru 0xffff, skipping through much of the 1ff to feff
	        // range to save
	        // time (it would take too much time to test every possible case)
	        for (i = limit; i <= 0xffff; i = ((i >= 0x1ff && i < 0xfeff) ? i + 0xfd
	                : i + 1)) {
	            bs = ILOG.J2CsMapping.NIO.ByteBuffer.Wrap(bytes, i, 1).Slice();
	            us = ILOG.J2CsMapping.NIO.CharBuffer.Wrap(chars, i, 1).Slice();
	            try {
	                SmBufEncode(encoder, converter, us, bs, true, false, true);
	                fail = true;
	                arrays = true;
	                break;
	            } catch (Exception ex_2) {
	            }
	            try {
	                SmBufEncode(encoder, converter, us, bs, true, false, false);
	                fail = true;
	                arrays = false;
	                break;
	            } catch (Exception ex_3) {
	            }
	        }
	        if (fail) {
	            Errln("Failed to fail to encode 0x" + ILOG.J2CsMapping.Util.IlNumber.ToString(i,16)
	                    + ((arrays) ? " with arrays" : " without arrays") + " in "
	                    + converter);
	            return;
	        }
	
	        // test overflow / underflow edge cases
	        outer: {
	            for (int n = 1; n <= 3; n++) {
	                for (int m = 0; m < n; m++) {
	                    // expecting underflow
	                    try {
	                        bs = ILOG.J2CsMapping.NIO.ByteBuffer.Wrap(bytes, 'a', m).Slice();
	                        us = ILOG.J2CsMapping.NIO.CharBuffer.Wrap(chars, 'a', m).Slice();
	                        SmBufDecode(decoder, converter, bs, us, true, false, true);
	                        SmBufDecode(decoder, converter, bs, us, true, false, false);
	                        SmBufEncode(encoder, converter, us, bs, true, false, true);
	                        SmBufEncode(encoder, converter, us, bs, true, false, false);
	                        bs = ILOG.J2CsMapping.NIO.ByteBuffer.Wrap(bytes, 'a', m).Slice();
	                        us = ILOG.J2CsMapping.NIO.CharBuffer.Wrap(chars, 'a', n).Slice();
	                        SmBufDecode(decoder, converter, bs, us, true, false, true,
	                                m);
	                        SmBufDecode(decoder, converter, bs, us, true, false, false,
	                                m);
	                        bs = ILOG.J2CsMapping.NIO.ByteBuffer.Wrap(bytes, 'a', n).Slice();
	                        us = ILOG.J2CsMapping.NIO.CharBuffer.Wrap(chars, 'a', m).Slice();
	                        SmBufEncode(encoder, converter, us, bs, true, false, true,
	                                m);
	                        SmBufEncode(encoder, converter, us, bs, true, false, false,
	                                m);
	                        bs = ILOG.J2CsMapping.NIO.ByteBuffer.Wrap(bytes, 'a', n).Slice();
	                        us = ILOG.J2CsMapping.NIO.CharBuffer.Wrap(chars, 'a', n).Slice();
	                        SmBufDecode(decoder, converter, bs, us, true, false, true);
	                        SmBufDecode(decoder, converter, bs, us, true, false, false);
	                        SmBufEncode(encoder, converter, us, bs, true, false, true);
	                        SmBufEncode(encoder, converter, us, bs, true, false, false);
	                    } catch (Exception ex_4) {
	                        fail = true;
	                        goto gotoouter;
	                    }
	
	                    // expecting overflow
	                    try {
	                        bs = ILOG.J2CsMapping.NIO.ByteBuffer.Wrap(bytes, 'a', n).Slice();
	                        us = ILOG.J2CsMapping.NIO.CharBuffer.Wrap(chars, 'a', m).Slice();
	                        SmBufDecode(decoder, converter, bs, us, true, false, true);
	                        fail = true;
	                        break;
	                    } catch (Exception ex_5) {
	                        if (!(ex_5  is  BufferOverflowException)) {
	                            fail = true;
	                            goto gotoouter;
	                        }
	                    }
	                    try {
	                        bs = ILOG.J2CsMapping.NIO.ByteBuffer.Wrap(bytes, 'a', n).Slice();
	                        us = ILOG.J2CsMapping.NIO.CharBuffer.Wrap(chars, 'a', m).Slice();
	                        SmBufDecode(decoder, converter, bs, us, true, false, false);
	                        fail = true;
	                    } catch (Exception ex_6) {
	                        if (!(ex_6  is  BufferOverflowException)) {
	                            fail = true;
	                            goto gotoouter;
	                        }
	                    }
	                    try {
	                        bs = ILOG.J2CsMapping.NIO.ByteBuffer.Wrap(bytes, 'a', m).Slice();
	                        us = ILOG.J2CsMapping.NIO.CharBuffer.Wrap(chars, 'a', n).Slice();
	                        SmBufEncode(encoder, converter, us, bs, true, false, true);
	                        fail = true;
	                    } catch (Exception ex_7) {
	                        if (!(ex_7  is  BufferOverflowException)) {
	                            fail = true;
	                            goto gotoouter;
	                        }
	                    }
	                    try {
	                        bs = ILOG.J2CsMapping.NIO.ByteBuffer.Wrap(bytes, 'a', m).Slice();
	                        us = ILOG.J2CsMapping.NIO.CharBuffer.Wrap(chars, 'a', n).Slice();
	                        SmBufEncode(encoder, converter, us, bs, true, false, false);
	                        fail = true;
	                    } catch (Exception ex_8) {
	                        if (!(ex_8  is  BufferOverflowException)) {
	                            fail = true;
	                            goto gotoouter;
	                        }
	                    }
	                }
	            }
	        }
	        gotoouter:
	        ;
	        if (fail) {
	            Errln("Incorrect result in " + converter
	                    + " for underflow / overflow edge cases");
	            return;
	        }
	
	        // test surrogate combinations in encoding
	        String lead = "" + (char) 0xd888;
	        String trail = "" + (char) 0xdc88;
	        String norm = "a";
	        String end = "";
	        bs = ILOG.J2CsMapping.NIO.ByteBuffer.Wrap(new byte[] { 0 });
	        String[] input = new String[] { //
	        lead + lead, // malf(1)
	                lead + trail, // unmap(2)
	                lead + norm, // malf(1)
	                lead + end, // malf(1)
	                trail + lead, // unmap(1)
	                trail + trail, // unmap(1)
	                trail + norm, // unmap(1)
	                trail + end, // unmap(1)
	        };
	        CoderResult[] result = new CoderResult[] {
	                ILOG.J2CsMapping.NIO.Charset.CoderResult.MalformedForLength(1),
	                ILOG.J2CsMapping.NIO.Charset.CoderResult.UnmappableForLength(2),
	                ILOG.J2CsMapping.NIO.Charset.CoderResult.MalformedForLength(1),
	                ILOG.J2CsMapping.NIO.Charset.CoderResult.MalformedForLength(1),
	                ILOG.J2CsMapping.NIO.Charset.CoderResult.UnmappableForLength(1),
	                ILOG.J2CsMapping.NIO.Charset.CoderResult.UnmappableForLength(1),
	                ILOG.J2CsMapping.NIO.Charset.CoderResult.UnmappableForLength(1),
	                ILOG.J2CsMapping.NIO.Charset.CoderResult.UnmappableForLength(1), };
	        for (int index = 0; index < input.Length; index++) {
	            cr = encoder.Encode(ILOG.J2CsMapping.NIO.CharBuffer.Wrap(input[index]), bs, true);
	            bs.Rewind();
	            encoder.Reset();
	
	            // if cr != results[x]
	            if (!((cr.IsUnderflow() && result[index].IsUnderflow())
	                    || (cr.IsOverflow() && result[index].IsOverflow())
	                    || (cr.IsMalformed() && result[index].IsMalformed()) || (cr
	                    .IsUnmappable() && result[index].IsUnmappable()))
	                    || (cr.IsError() && cr.Length() != result[index].Length())) {
	                Errln("Incorrect result in " + converter + " for \""
	                        + input[index] + "\"");
	                break;
	            }
	
	            cr = encoder.Encode(ILOG.J2CsMapping.NIO.CharBuffer.Wrap(input[index].ToCharArray()),
	                    bs, true);
	            bs.Rewind();
	            encoder.Reset();
	
	            // if cr != results[x]
	            if (!((cr.IsUnderflow() && result[index].IsUnderflow())
	                    || (cr.IsOverflow() && result[index].IsOverflow())
	                    || (cr.IsMalformed() && result[index].IsMalformed()) || (cr
	                    .IsUnmappable() && result[index].IsUnmappable()))
	                    || (cr.IsError() && cr.Length() != result[index].Length())) {
	                Errln("Incorrect result in " + converter + " for \""
	                        + input[index] + "\"");
	                break;
	            }
	        }
	    }
	
	    public void TestUTF8Converter() {
	        String converter = "UTF-8";
	        CharsetProvider icu = new CharsetProviderICU();
	        Encoding icuChar = icu.CharsetForName(converter);
	        Encoder encoder = icuChar.GetEncoder();
	        Decoder decoder = icuChar.GetDecoder();
	        ByteBuffer bs;
	        CharBuffer us;
	        CoderResult cr;
	
	        int[] size = new int[] { 1 << 7, 1 << 11, 1 << 16 }; // # of 1,2,3 byte
	                                                             // combinations
	        byte[] bytes = new byte[size[0] + size[1] * 2 + size[2] * 3];
	        char[] chars = new char[size[0] + size[1] + size[2]];
	        int i = 0;
	        int x, y;
	
	        // 0 to 1 << 7 (1 byters)
	        for (; i < size[0]; i++) {
	            bytes[i] = (byte) i;
	            chars[i] = (char) i;
	            bs = ILOG.J2CsMapping.NIO.ByteBuffer.Wrap(bytes, i, 1).Slice();
	            us = ILOG.J2CsMapping.NIO.CharBuffer.Wrap(chars, i, 1).Slice();
	            try {
	                SmBufDecode(decoder, converter, bs, us, true, false, true);
	                SmBufDecode(decoder, converter, bs, us, true, false, false);
	                SmBufEncode(encoder, converter, us, bs, true, false, true);
	                SmBufEncode(encoder, converter, us, bs, true, false, false);
	            } catch (Exception ex) {
	                Errln("Incorrect result in " + converter + " for 0x"
	                        + ILOG.J2CsMapping.Util.IlNumber.ToString(i,16));
	                break;
	            }
	        }
	
	        // 1 << 7 to 1 << 11 (2 byters)
	        for (; i < size[1]; i++) {
	            x = size[0] + i * 2;
	            y = size[0] + i;
	            bytes[x + 0] = (byte) (0xc0 | ((i >> 6) & 0x1f));
	            bytes[x + 1] = (byte) (0x80 | ((i >> 0) & 0x3f));
	            chars[y] = (char) i;
	            bs = ILOG.J2CsMapping.NIO.ByteBuffer.Wrap(bytes, x, 2).Slice();
	            us = ILOG.J2CsMapping.NIO.CharBuffer.Wrap(chars, y, 1).Slice();
	            try {
	                SmBufDecode(decoder, converter, bs, us, true, false, true);
	                SmBufDecode(decoder, converter, bs, us, true, false, false);
	                SmBufEncode(encoder, converter, us, bs, true, false, true);
	                SmBufEncode(encoder, converter, us, bs, true, false, false);
	            } catch (Exception ex_0) {
	                Errln("Incorrect result in " + converter + " for 0x"
	                        + ILOG.J2CsMapping.Util.IlNumber.ToString(i,16));
	                break;
	            }
	        }
	
	        // 1 << 11 to 1 << 16 (3 byters and surrogates)
	        for (; i < size[2]; i++) {
	            x = size[0] + size[1] * 2 + i * 3;
	            y = size[0] + size[1] + i;
	            bytes[x + 0] = (byte) (0xe0 | ((i >> 12) & 0x0f));
	            bytes[x + 1] = (byte) (0x80 | ((i >> 6) & 0x3f));
	            bytes[x + 2] = (byte) (0x80 | ((i >> 0) & 0x3f));
	            chars[y] = (char) i;
	            if (!IBM.ICU.Text.UTF16.IsSurrogate((char) i)) {
	                bs = ILOG.J2CsMapping.NIO.ByteBuffer.Wrap(bytes, x, 3).Slice();
	                us = ILOG.J2CsMapping.NIO.CharBuffer.Wrap(chars, y, 1).Slice();
	                try {
	                    SmBufDecode(decoder, converter, bs, us, true, false, true);
	                    SmBufDecode(decoder, converter, bs, us, true, false, false);
	                    SmBufEncode(encoder, converter, us, bs, true, false, true);
	                    SmBufEncode(encoder, converter, us, bs, true, false, false);
	                } catch (Exception ex_1) {
	                    Errln("Incorrect result in " + converter + " for 0x"
	                            + ILOG.J2CsMapping.Util.IlNumber.ToString(i,16));
	                    break;
	                }
	            } else {
	                bs = ILOG.J2CsMapping.NIO.ByteBuffer.Wrap(bytes, x, 3).Slice();
	                us = ILOG.J2CsMapping.NIO.CharBuffer.Wrap(chars, y, 1).Slice();
	
	                decoder.Reset();
	                cr = decoder.Decode(bs, us, true);
	                bs.Rewind();
	                us.Rewind();
	                if (!cr.IsMalformed() || cr.Length() != 3) {
	                    Errln("Incorrect result in " + converter
	                            + " decoder for 0x" + ILOG.J2CsMapping.Util.IlNumber.ToString(i,16)
	                            + " received " + cr);
	                    break;
	                }
	                encoder.Reset();
	                cr = encoder.Encode(us, bs, true);
	                bs.Rewind();
	                us.Rewind();
	                if (!cr.IsMalformed() || cr.Length() != 1) {
	                    Errln("Incorrect result in " + converter
	                            + " encoder for 0x" + ILOG.J2CsMapping.Util.IlNumber.ToString(i,16)
	                            + " received " + cr);
	                    break;
	                }
	
	                bs = ILOG.J2CsMapping.NIO.ByteBuffer.Wrap(bytes, x, 3).Slice();
	                us = ILOG.J2CsMapping.NIO.CharBuffer.Wrap(new String(chars, y, 1));
	
	                decoder.Reset();
	                cr = decoder.Decode(bs, us, true);
	                bs.Rewind();
	                us.Rewind();
	                if (!cr.IsMalformed() || cr.Length() != 3) {
	                    Errln("Incorrect result in " + converter
	                            + " decoder for 0x" + ILOG.J2CsMapping.Util.IlNumber.ToString(i,16)
	                            + " received " + cr);
	                    break;
	                }
	                encoder.Reset();
	                cr = encoder.Encode(us, bs, true);
	                bs.Rewind();
	                us.Rewind();
	                if (!cr.IsMalformed() || cr.Length() != 1) {
	                    Errln("Incorrect result in " + converter
	                            + " encoder for 0x" + ILOG.J2CsMapping.Util.IlNumber.ToString(i,16)
	                            + " received " + cr);
	                    break;
	                }
	
	            }
	        }
	        if (true)
	            return;
	    }
	
	    // public void TestCharsetCallback() {
	    // String currentTest = "initialization";
	    // try {
	    // Class[] params;
	    //
	    // // get the classes
	    // Class CharsetCallback =
	    // Class.forName("com.ibm.icu.charset.CharsetCallback");
	    // Class Decoder =
	    // Class.forName("com.ibm.icu.charset.CharsetCallback$Decoder");
	    // Class Encoder =
	    // Class.forName("com.ibm.icu.charset.CharsetCallback$Encoder");
	    //
	    // // set up encoderCall
	    // params = new Class[] {CharsetEncoderICU.class, Object.class,
	    // CharBuffer.class, ByteBuffer.class, IntBuffer.class,
	    // char[].class, int.class, int.class, CoderResult.class };
	    // Method encoderCall = Encoder.getDeclaredMethod("call", params);
	    //
	    // // set up decoderCall
	    // params = new Class[] {CharsetDecoderICU.class, Object.class,
	    // ByteBuffer.class, CharBuffer.class, IntBuffer.class,
	    // char[].class, int.class, CoderResult.class};
	    // Method decoderCall = Decoder.getDeclaredMethod("call", params);
	    //
	    // // get relevant fields
	    // Object SUB_STOP_ON_ILLEGAL = getFieldValue(CharsetCallback,
	    // "SUB_STOP_ON_ILLEGAL", null);
	    //
	    // // set up a few arguments
	    // CharsetProvider provider = new CharsetProviderICU();
	    // Charset charset = provider.charsetForName("UTF-8");
	    // CharsetEncoderICU encoder = (CharsetEncoderICU)charset.newEncoder();
	    // CharsetDecoderICU decoder = (CharsetDecoderICU)charset.newDecoder();
	    // CharBuffer chars = CharBuffer.allocate(10);
	    // chars.put('o');
	    // chars.put('k');
	    // ByteBuffer bytes = ByteBuffer.allocate(10);
	    // bytes.put((byte)'o');
	    // bytes.put((byte)'k');
	    // IntBuffer offsets = IntBuffer.allocate(10);
	    // offsets.put(0);
	    // offsets.put(1);
	    // char[] buffer = null;
	    // Integer length = new Integer(2);
	    // Integer cp = new Integer(0);
	    // CoderResult unmap = CoderResult.unmappableForLength(2);
	    // CoderResult malf = CoderResult.malformedForLength(2);
	    // CoderResult under = CoderResult.UNDERFLOW;
	    //
	    // // set up error arrays
	    // Integer invalidCharLength = new Integer(1);
	    // Byte subChar1 = new Byte((byte)0);
	    // Byte subChar1_alternate = new Byte((byte)1); // for
	    // TO_U_CALLBACK_SUBSTITUTE
	    //
	    // // set up chars and bytes backups and expected values for certain cases
	    // CharBuffer charsBackup = bufferCopy(chars);
	    // ByteBuffer bytesBackup = bufferCopy(bytes);
	    // IntBuffer offsetsBackup = bufferCopy(offsets);
	    // CharBuffer encoderCharsExpected = bufferCopy(chars);
	    // ByteBuffer encoderBytesExpected = bufferCopy(bytes);
	    // IntBuffer encoderOffsetsExpected = bufferCopy(offsets);
	    // CharBuffer decoderCharsExpected1 = bufferCopy(chars);
	    // CharBuffer decoderCharsExpected2 = bufferCopy(chars);
	    // IntBuffer decoderOffsetsExpected1 = bufferCopy(offsets);
	    // IntBuffer decoderOffsetsExpected2 = bufferCopy(offsets);
	    //
	    // // initialize fields to obtain expected data
	    // setFieldValue(CharsetDecoderICU.class, "invalidCharLength", decoder,
	    // invalidCharLength);
	    // setFieldValue(CharsetICU.class, "subChar1", ((CharsetICU)
	    // decoder.charset()), subChar1);
	    //
	    // // run cbFromUWriteSub
	    // Method cbFromUWriteSub =
	    // CharsetEncoderICU.class.getDeclaredMethod("cbFromUWriteSub", new Class[]
	    // { CharsetEncoderICU.class, CharBuffer.class, ByteBuffer.class,
	    // IntBuffer.class});
	    // cbFromUWriteSub.setAccessible(true);
	    // CoderResult encoderResultExpected =
	    // (CoderResult)cbFromUWriteSub.invoke(encoder, new Object[] {encoder,
	    // encoderCharsExpected, encoderBytesExpected, encoderOffsetsExpected});
	    //
	    // // run toUWriteUChars with normal data
	    // Method toUWriteUChars =
	    // CharsetDecoderICU.class.getDeclaredMethod("toUWriteUChars", new Class[] {
	    // CharsetDecoderICU.class, char[].class, int.class, int.class,
	    // CharBuffer.class, IntBuffer.class, int.class});
	    // toUWriteUChars.setAccessible(true);
	    // CoderResult decoderResultExpected1 =
	    // (CoderResult)toUWriteUChars.invoke(decoder, new Object[] {decoder, new
	    // char[] {0xFFFD}, new Integer(0), new Integer(1), decoderCharsExpected1,
	    // decoderOffsetsExpected1, new Integer(bytes.position())});
	    //
	    // // reset certain fields
	    // setFieldValue(CharsetDecoderICU.class, "invalidCharLength", decoder,
	    // invalidCharLength);
	    // setFieldValue(CharsetICU.class, "subChar1", ((CharsetICU)
	    // decoder.charset()), subChar1_alternate);
	    //
	    // // run toUWriteUChars again
	    // CoderResult decoderResultExpected2 =
	    // (CoderResult)toUWriteUChars.invoke(decoder, new Object[] {decoder, new
	    // char[] {0x1A}, new Integer(0), new Integer(1), decoderCharsExpected2,
	    // decoderOffsetsExpected2, new Integer(bytes.position())});
	    //
	    // // begin creating the tests array
	    // ArrayList tests = new ArrayList();
	    //
	    // // create tests for FROM_U_CALLBACK_SKIP 0
	    // tests.add(new Object[] {encoderCall, "FROM_U_CALLBACK_SKIP", new Object[]
	    // { encoder, null, chars, bytes, offsets, buffer, length, cp, null },
	    // under, charsBackup, bytesBackup, offsetsBackup, new Object[] { }});
	    // tests.add(new Object[] {encoderCall, "FROM_U_CALLBACK_SKIP", new Object[]
	    // { encoder, SUB_STOP_ON_ILLEGAL, chars, bytes, offsets, buffer, length,
	    // cp, malf }, malf, charsBackup, bytesBackup, offsetsBackup, new Object[] {
	    // }});
	    // tests.add(new Object[] {encoderCall, "FROM_U_CALLBACK_SKIP", new Object[]
	    // { encoder, SUB_STOP_ON_ILLEGAL, chars, bytes, offsets, buffer, length,
	    // cp, unmap }, under, charsBackup, bytesBackup, offsetsBackup, new Object[]
	    // { }});
	    // tests.add(new Object[] {encoderCall, "FROM_U_CALLBACK_SKIP", new Object[]
	    // { encoder, SUB_STOP_ON_ILLEGAL + "xx", chars, bytes, offsets, buffer,
	    // length, cp, null }, null, charsBackup, bytesBackup, offsetsBackup, new
	    // Object[] { }});
	    //
	    // // create tests for TO_U_CALLBACK_SKIP 4
	    // tests.add(new Object[] {decoderCall, "TO_U_CALLBACK_SKIP", new Object[] {
	    // decoder, null, bytes, chars, offsets, buffer, length, null }, under,
	    // charsBackup, bytesBackup, offsetsBackup, new Object[] {
	    // invalidCharLength, subChar1 }});
	    // tests.add(new Object[] {decoderCall, "TO_U_CALLBACK_SKIP", new Object[] {
	    // decoder, SUB_STOP_ON_ILLEGAL, bytes, chars, offsets, buffer, length, malf
	    // }, malf, charsBackup, bytesBackup, offsetsBackup, new Object[] {
	    // invalidCharLength, subChar1 }});
	    // tests.add(new Object[] {decoderCall, "TO_U_CALLBACK_SKIP", new Object[] {
	    // decoder, SUB_STOP_ON_ILLEGAL, bytes, chars, offsets, buffer, length,
	    // unmap }, under, charsBackup, bytesBackup, offsetsBackup, new Object[] {
	    // invalidCharLength, subChar1 }});
	    // tests.add(new Object[] {decoderCall, "TO_U_CALLBACK_SKIP", new Object[] {
	    // decoder, SUB_STOP_ON_ILLEGAL + "xx", bytes, chars, offsets, buffer,
	    // length, null }, null, charsBackup, bytesBackup, offsetsBackup, new
	    // Object[] { invalidCharLength, subChar1 }});
	    //
	    // // create tests for FROM_U_CALLBACK_STOP 8
	    // tests.add(new Object[] {encoderCall, "FROM_U_CALLBACK_STOP", new Object[]
	    // { encoder, null, chars, bytes, offsets, buffer, length, cp, null }, null,
	    // charsBackup, bytesBackup, offsetsBackup, new Object[] { }});
	    // tests.add(new Object[] {encoderCall, "FROM_U_CALLBACK_STOP", new Object[]
	    // { encoder, SUB_STOP_ON_ILLEGAL, chars, bytes, offsets, buffer, length,
	    // cp, malf }, malf, charsBackup, bytesBackup, offsetsBackup, new Object[] {
	    // }});
	    // tests.add(new Object[] {encoderCall, "FROM_U_CALLBACK_STOP", new Object[]
	    // { encoder, SUB_STOP_ON_ILLEGAL, chars, bytes, offsets, buffer, length,
	    // cp, unmap }, unmap, charsBackup, bytesBackup, offsetsBackup, new Object[]
	    // { }});
	    // tests.add(new Object[] {encoderCall, "FROM_U_CALLBACK_STOP", new Object[]
	    // { encoder, SUB_STOP_ON_ILLEGAL + "xx", chars, bytes, offsets, buffer,
	    // length, cp, null }, null, charsBackup, bytesBackup, offsetsBackup, new
	    // Object[] { }});
	    //
	    // // create tests for TO_U_CALLBACK_STOP 12
	    // tests.add(new Object[] {decoderCall, "TO_U_CALLBACK_STOP", new Object[] {
	    // decoder, null, bytes, chars, offsets, buffer, length, null }, null,
	    // charsBackup, bytesBackup, offsetsBackup, new Object[] {
	    // invalidCharLength, subChar1 }});
	    // tests.add(new Object[] {decoderCall, "TO_U_CALLBACK_STOP", new Object[] {
	    // decoder, SUB_STOP_ON_ILLEGAL, bytes, chars, offsets, buffer, length, malf
	    // }, malf, charsBackup, bytesBackup, offsetsBackup, new Object[] {
	    // invalidCharLength, subChar1 }});
	    // tests.add(new Object[] {decoderCall, "TO_U_CALLBACK_STOP", new Object[] {
	    // decoder, SUB_STOP_ON_ILLEGAL, bytes, chars, offsets, buffer, length,
	    // unmap }, unmap, charsBackup, bytesBackup, offsetsBackup, new Object[] {
	    // invalidCharLength, subChar1 }});
	    // tests.add(new Object[] {decoderCall, "TO_U_CALLBACK_STOP", new Object[] {
	    // decoder, SUB_STOP_ON_ILLEGAL + "xx", bytes, chars, offsets, buffer,
	    // length, null }, null, charsBackup, bytesBackup, offsetsBackup, new
	    // Object[] { invalidCharLength, subChar1 }});
	    //
	    // // create tests for FROM_U_CALLBACK_SUBSTITUTE 16
	    // tests.add(new Object[] {encoderCall, "FROM_U_CALLBACK_SUBSTITUTE", new
	    // Object[] { encoder, null, chars, bytes, offsets, buffer, length, cp, null
	    // }, encoderResultExpected, encoderCharsExpected, encoderBytesExpected,
	    // encoderOffsetsExpected, new Object[] { }});
	    // tests.add(new Object[] {encoderCall, "FROM_U_CALLBACK_SUBSTITUTE", new
	    // Object[] { encoder, SUB_STOP_ON_ILLEGAL, chars, bytes, offsets, buffer,
	    // length, cp, malf }, malf, charsBackup, bytesBackup, offsetsBackup, new
	    // Object[] { }});
	    // tests.add(new Object[] {encoderCall, "FROM_U_CALLBACK_SUBSTITUTE", new
	    // Object[] { encoder, SUB_STOP_ON_ILLEGAL, chars, bytes, offsets, buffer,
	    // length, cp, unmap }, encoderResultExpected, encoderCharsExpected,
	    // encoderBytesExpected, encoderOffsetsExpected, new Object[] { }});
	    // tests.add(new Object[] {encoderCall, "FROM_U_CALLBACK_SUBSTITUTE", new
	    // Object[] { encoder, SUB_STOP_ON_ILLEGAL + "xx", chars, bytes, offsets,
	    // buffer, length, cp, null }, null, charsBackup, bytesBackup,
	    // offsetsBackup, new Object[] { }});
	    //
	    // // create tests for TO_U_CALLBACK_SUBSTITUTE 20
	    // tests.add(new Object[] {decoderCall, "TO_U_CALLBACK_SUBSTITUTE", new
	    // Object[] { decoder, null, bytes, chars, offsets, buffer, length, null },
	    // decoderResultExpected1, decoderCharsExpected1, bytesBackup,
	    // decoderOffsetsExpected1, new Object[] { invalidCharLength, subChar1 }});
	    // tests.add(new Object[] {decoderCall, "TO_U_CALLBACK_SUBSTITUTE", new
	    // Object[] { decoder, null, bytes, chars, offsets, buffer, length, null },
	    // decoderResultExpected2, decoderCharsExpected2, bytesBackup,
	    // decoderOffsetsExpected2, new Object[] { invalidCharLength,
	    // subChar1_alternate }});
	    //
	    // Iterator iter = tests.iterator();
	    // for (int i=0; iter.hasNext(); i++) {
	    // // get the data out of the map
	    // Object[] next = (Object[])iter.next();
	    //
	    // Method method = (Method)next[0];
	    // String fieldName = (String)next[1];
	    // Object field = getFieldValue(CharsetCallback, fieldName, null);
	    // Object[] args = (Object[])next[2];
	    // CoderResult expected = (CoderResult)next[3];
	    // CharBuffer charsExpected = (CharBuffer)next[4];
	    // ByteBuffer bytesExpected = (ByteBuffer)next[5];
	    // IntBuffer offsetsExpected = (IntBuffer)next[6];
	    //
	    // // set up error arrays and certain fields
	    // Object[] values = (Object[])next[7];
	    // if (method == decoderCall) {
	    // decoder.reset();
	    // setFieldValue(CharsetDecoderICU.class, "invalidCharLength", decoder,
	    // values[0]);
	    // setFieldValue(CharsetICU.class, "subChar1", ((CharsetICU)
	    // decoder.charset()), values[1]);
	    // } else if (method == encoderCall) {
	    // encoder.reset();
	    // }
	    //
	    // try {
	    // // invoke the method
	    // CoderResult actual = (CoderResult)method.invoke(field, args);
	    //
	    // // if expected != actual
	    // if (!coderResultsEqual(expected, actual)) {
	    // // case #i refers to the index in the arraylist tests
	    // errln(fieldName + " failed to return the correct result for case #" + i +
	    // ".");
	    // }
	    // // if the expected buffers != actual buffers
	    // else if (!(buffersEqual(chars, charsExpected) &&
	    // buffersEqual(bytes, bytesExpected) &&
	    // buffersEqual(offsets, offsetsExpected))) {
	    // // case #i refers to the index in the arraylist tests
	    // errln(fieldName +
	    // " did not perform the correct operation on the buffers for case #" + i +
	    // ".");
	    // }
	    // } catch (InvocationTargetException ex) {
	    // // case #i refers to the index in the arraylist tests
	    // errln(fieldName + " threw an exception for case #" + i + ": " +
	    // ex.getCause());
	    // //ex.getCause().printStackTrace();
	    // }
	    //
	    // // reset the buffers
	    // System.arraycopy(bytesBackup.array(), 0, bytes.array(), 0, 10);
	    // System.arraycopy(charsBackup.array(), 0, chars.array(), 0, 10);
	    // System.arraycopy(offsetsBackup.array(), 0, offsets.array(), 0, 10);
	    // bytes.position(bytesBackup.position());
	    // chars.position(charsBackup.position());
	    // offsets.position(offsetsBackup.position());
	    // }
	    //
	    // } catch (Exception ex) {
	    // errln("TestCharsetCallback skipped due to " + ex.toString());
	    // ex.printStackTrace();
	    // }
	    // }
	    //
	    // private Object getFieldValue(Class c, String name, Object instance)
	    // throws Exception {
	    // Field field = c.getDeclaredField(name);
	    // field.setAccessible(true);
	    // return field.get(instance);
	    // }
	    // private void setFieldValue(Class c, String name, Object instance, Object
	    // value) throws Exception {
	    // Field field = c.getDeclaredField(name);
	    // field.setAccessible(true);
	    // if (value instanceof Boolean)
	    // field.setBoolean(instance, ((Boolean)value).booleanValue());
	    // else if (value instanceof Byte)
	    // field.setByte(instance, ((Byte)value).byteValue());
	    // else if (value instanceof Character)
	    // field.setChar(instance, ((Character)value).charValue());
	    // else if (value instanceof Double)
	    // field.setDouble(instance, ((Double)value).doubleValue());
	    // else if (value instanceof Float)
	    // field.setFloat(instance, ((Float)value).floatValue());
	    // else if (value instanceof Integer)
	    // field.setInt(instance, ((Integer)value).intValue());
	    // else if (value instanceof Long)
	    // field.setLong(instance, ((Long)value).longValue());
	    // else if (value instanceof Short)
	    // field.setShort(instance, ((Short)value).shortValue());
	    // else
	    // field.set(instance, value);
	    // }
	    // private boolean coderResultsEqual(CoderResult a, CoderResult b) {
	    // if (a == null && b == null)
	    // return true;
	    // if (a == null || b == null)
	    // return false;
	    // if ((a.isUnderflow() && b.isUnderflow()) || (a.isOverflow() &&
	    // b.isOverflow()))
	    // return true;
	    // if (a.length() != b.length())
	    // return false;
	    // if ((a.isMalformed() && b.isMalformed()) || (a.isUnmappable() &&
	    // b.isUnmappable()))
	    // return true;
	    // return false;
	    // }
	    // private boolean buffersEqual(ByteBuffer a, ByteBuffer b) {
	    // if (a.position() != b.position())
	    // return false;
	    // int limit = a.position();
	    // for (int i=0; i<limit; i++)
	    // if (a.get(i) != b.get(i))
	    // return false;
	    // return true;
	    // }
	    // private boolean buffersEqual(CharBuffer a, CharBuffer b) {
	    // if (a.position() != b.position())
	    // return false;
	    // int limit = a.position();
	    // for (int i=0; i<limit; i++)
	    // if (a.get(i) != b.get(i))
	    // return false;
	    // return true;
	    // }
	    // private boolean buffersEqual(IntBuffer a, IntBuffer b) {
	    // if (a.position() != b.position())
	    // return false;
	    // int limit = a.position();
	    // for (int i=0; i<limit; i++)
	    // if (a.get(i) != b.get(i))
	    // return false;
	    // return true;
	    // }
	    // private ByteBuffer bufferCopy(ByteBuffer src) {
	    // ByteBuffer dest = ByteBuffer.allocate(src.limit());
	    // System.arraycopy(src.array(), 0, dest.array(), 0, src.limit());
	    // dest.position(src.position());
	    // return dest;
	    // }
	    // private CharBuffer bufferCopy(CharBuffer src) {
	    // CharBuffer dest = CharBuffer.allocate(src.limit());
	    // System.arraycopy(src.array(), 0, dest.array(), 0, src.limit());
	    // dest.position(src.position());
	    // return dest;
	    // }
	    // private IntBuffer bufferCopy(IntBuffer src) {
	    // IntBuffer dest = IntBuffer.allocate(src.limit());
	    // System.arraycopy(src.array(), 0, dest.array(), 0, src.limit());
	    // dest.position(src.position());
	    // return dest;
	    // }
	
	    public void TestAPISemantics(/* String encoding */) {
	        int rc;
	        ByteBuffer byes = ILOG.J2CsMapping.NIO.ByteBuffer.Wrap(byteStr);
	        CharBuffer uniVal = ILOG.J2CsMapping.NIO.CharBuffer.Wrap(unistr);
	        ByteBuffer expected = ILOG.J2CsMapping.NIO.ByteBuffer.Wrap(expectedByteStr);
	
	        rc = 0;
	        if (m_decoder == null) {
	            Warnln("Could not load decoder.");
	            return;
	        }
	        m_decoder.Reset();
	        /* Convert the whole buffer to Unicode */
	        try {
	            CharBuffer chars = ILOG.J2CsMapping.NIO.CharBuffer.Allocate(unistr.Length);
	            CoderResult result = m_decoder.Decode(byes, chars, false);
	
	            if (result.IsError()) {
	                Errln("ToChars encountered Error");
	                rc = 1;
	            }
	            if (result.IsOverflow()) {
	                Errln("ToChars encountered overflow exception");
	                rc = 1;
	            }
	            if (!Equals(chars, unistr)) {
	                Errln("ToChars does not match");
	                Printchars(chars);
	                Errln("Expected : ");
	                Printchars(unistr);
	                rc = 2;
	            }
	
	        } catch (Exception e) {
	            Errln("ToChars - exception in buffer");
	            rc = 5;
	        }
	
	        /* Convert single bytes to Unicode */
	        try {
	            CharBuffer chars_0 = ILOG.J2CsMapping.NIO.CharBuffer.Allocate(unistr.Length);
	            ByteBuffer b = ILOG.J2CsMapping.NIO.ByteBuffer.Wrap(byteStr);
	            m_decoder.Reset();
	            CoderResult result_1 = null;
	            for (int i = 1; i <= byteStr.Length; i++) {
	                b.Limit(i);
	                result_1 = m_decoder.Decode(b, chars_0, false);
	                if (result_1.IsOverflow()) {
	                    Errln("ToChars single threw an overflow exception");
	                }
	                if (result_1.IsError()) {
	                    Errln("ToChars single the result is an error "
	                            + result_1.ToString());
	                }
	            }
	            if (unistr.Length != (chars_0.Limit())) {
	                Errln("ToChars single len does not match");
	                rc = 3;
	            }
	            if (!Equals(chars_0, unistr)) {
	                Errln("ToChars single does not match");
	                Printchars(chars_0);
	                rc = 4;
	            }
	        } catch (Exception e_2) {
	            Errln("ToChars - exception in single");
	            // e.printStackTrace();
	            rc = 6;
	        }
	
	        /* Convert the buffer one at a time to Unicode */
	        try {
	            CharBuffer chars_3 = ILOG.J2CsMapping.NIO.CharBuffer.Allocate(unistr.Length);
	            m_decoder.Reset();
	            byes.Rewind();
	            for (int i_4 = 1; i_4 <= byteStr.Length; i_4++) {
	                byes.Limit(i_4);
	                CoderResult result_5 = m_decoder.Decode(byes, chars_3, false);
	                if (result_5.IsError()) {
	                    Errln("Error while decoding: " + result_5.ToString());
	                }
	                if (result_5.IsOverflow()) {
	                    Errln("ToChars Simple threw an overflow exception");
	                }
	            }
	            if (chars_3.Limit() != unistr.Length) {
	                Errln("ToChars Simple buffer len does not match");
	                rc = 7;
	            }
	            if (!Equals(chars_3, unistr)) {
	                Errln("ToChars Simple buffer does not match");
	                Printchars(chars_3);
	                Err(" Expected : ");
	                Printchars(unistr);
	                rc = 8;
	            }
	        } catch (Exception e_6) {
	            Errln("ToChars - exception in single buffer");
	            // e.printStackTrace(System.err);
	            rc = 9;
	        }
	        if (rc != 0) {
	            Errln("Test Simple ToChars for encoding : FAILED");
	        }
	
	        rc = 0;
	        /* Convert the whole buffer from unicode */
	        try {
	            ByteBuffer bytes = ILOG.J2CsMapping.NIO.ByteBuffer.Allocate(expectedByteStr.Length);
	            m_encoder.Reset();
	            CoderResult result_7 = m_encoder.Encode(uniVal, bytes, false);
	            if (result_7.IsError()) {
	                Errln("FromChars reported error: " + result_7.ToString());
	                rc = 1;
	            }
	            if (result_7.IsOverflow()) {
	                Errln("FromChars threw an overflow exception");
	            }
	            bytes.Position(0);
	            if (!bytes.Equals(expected)) {
	                Errln("FromChars does not match");
	                Printbytes(bytes);
	                rc = 2;
	            }
	        } catch (Exception e_8) {
	            Errln("FromChars - exception in buffer");
	            // e.printStackTrace(System.err);
	            rc = 5;
	        }
	
	        /* Convert the buffer one char at a time to unicode */
	        try {
	            ByteBuffer bytes_9 = ILOG.J2CsMapping.NIO.ByteBuffer.Allocate(expectedByteStr.Length);
	            CharBuffer c = ILOG.J2CsMapping.NIO.CharBuffer.Wrap(unistr);
	            m_encoder.Reset();
	            CoderResult result_10 = null;
	            for (int i_11 = 1; i_11 <= unistr.Length; i_11++) {
	                c.Limit(i_11);
	                result_10 = m_encoder.Encode(c, bytes_9, false);
	                if (result_10.IsOverflow()) {
	                    Errln("FromChars single threw an overflow exception");
	                }
	                if (result_10.IsError()) {
	                    Errln("FromChars single threw an error: "
	                            + result_10.ToString());
	                }
	            }
	            if (expectedByteStr.Length != bytes_9.Limit()) {
	                Errln("FromChars single len does not match");
	                rc = 3;
	            }
	
	            bytes_9.Position(0);
	            if (!bytes_9.Equals(expected)) {
	                Errln("FromChars single does not match");
	                Printbytes(bytes_9);
	                rc = 4;
	            }
	
	        } catch (Exception e_12) {
	            Errln("FromChars - exception in single");
	            // e.printStackTrace(System.err);
	            rc = 6;
	        }
	
	        /* Convert one char at a time to unicode */
	        try {
	            ByteBuffer bytes_13 = ILOG.J2CsMapping.NIO.ByteBuffer.Allocate(expectedByteStr.Length);
	            m_encoder.Reset();
	            char[] temp = unistr.ToCharArray();
	            CoderResult result_14 = null;
	            for (int i_15 = 0; i_15 <= temp.Length; i_15++) {
	                uniVal.Limit(i_15);
	                result_14 = m_encoder.Encode(uniVal, bytes_13, false);
	                if (result_14.IsOverflow()) {
	                    Errln("FromChars simple threw an overflow exception");
	                }
	                if (result_14.IsError()) {
	                    Errln("FromChars simple threw an error: "
	                            + result_14.ToString());
	                }
	            }
	            if (bytes_13.Limit() != expectedByteStr.Length) {
	                Errln("FromChars Simple len does not match");
	                rc = 7;
	            }
	            if (!bytes_13.Equals(byes)) {
	                Errln("FromChars Simple does not match");
	                Printbytes(bytes_13);
	                rc = 8;
	            }
	        } catch (Exception e_16) {
	            Errln("FromChars - exception in single buffer");
	            // e.printStackTrace(System.err);
	            rc = 9;
	        }
	        if (rc != 0) {
	            Errln("Test Simple FromChars " + m_encoding + " --FAILED");
	        }
	    }
	
	    internal void Printchars(CharBuffer buf) {
	        int i;
	        char[] chars = new char[buf.Limit()];
	        // save the current position
	        int pos = buf.Position();
	        buf.Position(0);
	        buf.Get(chars);
	        // reset to old position
	        buf.Position(pos);
	        for (i = 0; i < chars.Length; i++) {
	            Err(IBM.ICU.Dev.Test.TestFmwk.Hex(chars[i]) + " ");
	        }
	        Errln("");
	    }
	
	    internal void Printchars(String str) {
	        char[] chars = str.ToCharArray();
	        for (int i = 0; i < chars.Length; i++) {
	            Err(IBM.ICU.Dev.Test.TestFmwk.Hex(chars[i]) + " ");
	        }
	        Errln("");
	    }
	
	    internal void Printbytes(ByteBuffer buf) {
	        int i;
	        byte[] bytes = new byte[buf.Limit()];
	        // save the current position
	        int pos = buf.Position();
	        buf.Position(0);
	        buf.Get(bytes);
	        // reset to old position
	        buf.Position(pos);
	        for (i = 0; i < bytes.Length; i++) {
	            System.Console.Out.Write(IBM.ICU.Dev.Test.TestFmwk.Hex(bytes[i]) + " ");
	        }
	        Errln("");
	    }
	
	    public bool Equals(CharBuffer buf, String str) {
	        return Equals(buf, str.ToCharArray());
	    }
	
	    public bool Equals(CharBuffer buf, CharBuffer str) {
	        if (buf.Limit() != str.Limit())
	            return false;
	        int limit = buf.Limit();
	        for (int i = 0; i < limit; i++)
	            if (buf.Get(i) != str.Get(i))
	                return false;
	        return true;
	    }
	
	    public bool Equals(CharBuffer buf, CharBuffer str, int limit) {
	        if (limit > buf.Limit() || limit > str.Limit())
	            return false;
	        for (int i = 0; i < limit; i++)
	            if (buf.Get(i) != str.Get(i))
	                return false;
	        return true;
	    }
	
	    public bool Equals(CharBuffer buf, char[] compareTo) {
	        char[] chars = new char[buf.Limit()];
	        // save the current position
	        int pos = buf.Position();
	        buf.Position(0);
	        buf.Get(chars);
	        // reset to old position
	        buf.Position(pos);
	        return Equals(chars, compareTo);
	    }
	
	    public bool Equals(char[] chars, char[] compareTo) {
	        if (chars.Length != compareTo.Length) {
	            Errln("Length does not match chars: " + chars.Length
	                    + " compareTo: " + compareTo.Length);
	            return false;
	        } else {
	            bool result = true;
	            for (int i = 0; i < chars.Length; i++) {
	                if (chars[i] != compareTo[i]) {
	                    Logln("Got: " + IBM.ICU.Dev.Test.TestFmwk.Hex(chars[i]) + " Expected: "
	                            + IBM.ICU.Dev.Test.TestFmwk.Hex(compareTo[i]) + " At: " + i);
	                    result = false;
	                }
	            }
	            return result;
	        }
	    }
	
	    public bool Equals(ByteBuffer buf, byte[] compareTo) {
	        byte[] chars = new byte[buf.Limit()];
	        // save the current position
	        int pos = buf.Position();
	        buf.Position(0);
	        buf.Get(chars);
	        // reset to old position
	        buf.Position(pos);
	        return Equals(chars, compareTo);
	    }
	
	    public bool Equals(ByteBuffer buf, ByteBuffer compareTo) {
	        if (buf.Limit() != compareTo.Limit())
	            return false;
	        int limit = buf.Limit();
	        for (int i = 0; i < limit; i++)
	            if (buf.Get(i) != compareTo.Get(i))
	                return false;
	        return true;
	    }
	
	    public bool Equals(ByteBuffer buf, ByteBuffer compareTo, int limit) {
	        if (limit > buf.Limit() || limit > compareTo.Limit())
	            return false;
	        for (int i = 0; i < limit; i++)
	            if (buf.Get(i) != compareTo.Get(i))
	                return false;
	        return true;
	    }
	
	    public bool Equals(byte[] chars, byte[] compareTo) {
	        if (false/* chars.length != compareTo.length */) {
	            Errln("Length does not match chars: " + chars.Length
	                    + " compareTo: " + compareTo.Length);
	            return false;
	        } else {
	            bool result = true;
	            for (int i = 0; i < chars.Length; i++) {
	                if (chars[i] != compareTo[i]) {
	                    Logln("Got: " + IBM.ICU.Dev.Test.TestFmwk.Hex(chars[i]) + " Expected: "
	                            + IBM.ICU.Dev.Test.TestFmwk.Hex(compareTo[i]) + " At: " + i);
	                    result = false;
	                }
	            }
	            return result;
	        }
	    }
	
	    // TODO
	    /*
	     * public void TestCallback(String encoding) throws Exception {
	     * 
	     * byte[] gbSource = { (byte) 0x81, (byte) 0x36, (byte) 0xDE, (byte) 0x36,
	     * (byte) 0x81, (byte) 0x36, (byte) 0xDE, (byte) 0x37, (byte) 0x81, (byte)
	     * 0x36, (byte) 0xDE, (byte) 0x38, (byte) 0xe3, (byte) 0x32, (byte) 0x9a,
	     * (byte) 0x36 };
	     * 
	     * char[] subChars = { 'P', 'I' };
	     * 
	     * decoder.reset();
	     * 
	     * decoder.replaceWith(new String(subChars)); ByteBuffer mySource =
	     * ByteBuffer.wrap(gbSource); CharBuffer myTarget = CharBuffer.allocate(5);
	     * 
	     * decoder.decode(mySource, myTarget, true); char[] expectedResult = {
	     * '\u22A6', '\u22A7', '\u22A8', '\u0050', '\u0049', };
	     * 
	     * if (!equals(myTarget, new String(expectedResult))) {
	     * errln("Test callback GB18030 to Unicode : FAILED"); }
	     * 
	     * }
	     */
	    public void TestCanConvert(/* String encoding */) {
	        char[] mySource = { '\ud800', '\udc00',/* surrogate pair */
	        '\u22A6', '\u22A7', '\u22A8', '\u22A9', '\u22AA', '\u22AB', '\u22AC',
	                '\u22AD', '\u22AE', '\u22AF', '\u22B0', '\u22B1', '\u22B2',
	                '\u22B3', '\u22B4', '\ud800', '\udc00',/* surrogate pair */
	                '\u22B5', '\u22B6', '\u22B7', '\u22B8', '\u22B9', '\u22BA',
	                '\u22BB', '\u22BC', '\u22BD', '\u22BE' };
	        if (m_encoder == null) {
	            Warnln("Could not load encoder.");
	            return;
	        }
	        m_encoder.Reset();
	        if (!m_encoder.CanEncode(ILOG.J2CsMapping.Util.StringUtil.NewString(mySource))) {
	            Errln("Test canConvert() " + m_encoding + " failed. " + m_encoder);
	        }
	
	    }
	
	    public void TestAvailableCharsets() {
	        SortedList map = System.Text.Encoding.AvailableCharsets();
	        ILOG.J2CsMapping.Collections.ISet keySet = new ILOG.J2CsMapping.Collections.ListSet(map.Keys);
	        IIterator iter = new ILOG.J2CsMapping.Collections.IteratorAdapter(keySet.GetEnumerator());
	        while (iter.HasNext()) {
	            Logln("Charset name: " + iter.Next().ToString());
	        }
	        Object[] charsets = IBM.ICU.Charset.CharsetProviderICU.GetAvailableNames();
	        int mapSize = map.Count;
	        if (mapSize < charsets.Length) {
	            Errln("Charset.availableCharsets() returned a number less than the number returned by icu. ICU: "
	                    + charsets.Length + " JDK: " + mapSize);
	        }
	        Logln("Total Number of chasets = " + map.Count);
	    }
	
	    public void TestWindows936() {
	        CharsetProviderICU icu = new CharsetProviderICU();
	        Encoding cs = icu.CharsetForName("windows-936-2000");
	        String canonicalName = cs.Name();
	        if (!canonicalName.Equals("GBK")) {
	            Errln("Did not get the expected canonical name. Got: "
	                    + canonicalName); // get the canonical name
	        }
	    }
	
	    public void TestICUAvailableCharsets() {
	        CharsetProviderICU icu = new CharsetProviderICU();
	        Object[] charsets = IBM.ICU.Charset.CharsetProviderICU.GetAvailableNames();
	        for (int i = 0; i < charsets.Length; i++) {
	            Encoding cs = icu.CharsetForName((String) charsets[i]);
	            try {
	                Encoder encoder = cs.GetEncoder();
	                if (encoder != null) {
	                    Logln("Creation of encoder succeeded. " + cs.ToString());
	                }
	            } catch (Exception ex) {
	                Errln("Could not instantiate encoder for " + charsets[i]
	                        + ". Error: " + ex.ToString());
	            }
	            try {
	                Decoder decoder = cs.GetDecoder();
	                if (decoder != null) {
	                    Logln("Creation of decoder succeeded. " + cs.ToString());
	                }
	            } catch (Exception ex_0) {
	                Errln("Could not instantiate decoder for " + charsets[i]
	                        + ". Error: " + ex_0.ToString());
	            }
	        }
	    }
	
	    /* jitterbug 4312 */
	    public void TestUnsupportedCharset() {
	        CharsetProvider icu = new CharsetProviderICU();
	        Encoding icuChar = icu.CharsetForName("impossible");
	        if (icuChar != null) {
	            Errln("ICU does not conform to the spec");
	        }
	    }
	
	    public void TestEncoderCreation() {
	        try {
	            Encoding cs = System.Text.Encoding.GetEncoding("GB_2312-80");
	            Encoder enc = cs.GetEncoder();
	            if (enc != null && (enc  is  CharsetEncoderICU)) {
	                Logln("Successfully created the encoder: " + enc);
	            } else {
	                Errln("Error creating charset encoder.");
	            }
	        } catch (Exception e) {
	            Warnln("Error creating charset encoder." + e.ToString());
	            // e.printStackTrace();
	        }
	        try {
	            Encoding cs_0 = System.Text.Encoding.GetEncoding("x-ibm-971_P100-1995");
	            Encoder enc_1 = cs_0.GetEncoder();
	            if (enc_1 != null && (enc_1  is  CharsetEncoderICU)) {
	                Logln("Successfully created the encoder: " + enc_1);
	            } else {
	                Errln("Error creating charset encoder.");
	            }
	        } catch (Exception e_2) {
	            Warnln("Error creating charset encoder." + e_2.ToString());
	        }
	    }
	
	    public void TestSubBytes() {
	        try {
	            // create utf-8 decoder
	            Decoder decoder = new CharsetProviderICU().CharsetForName(
	                                "utf-8").GetDecoder();
	
	            // create a valid byte array, which can be decoded to " buffer"
	            byte[] unibytes = new byte[] { 0x0020, 0x0062, 0x0075, 0x0066,
	                    0x0066, 0x0065, 0x0072 };
	
	            ByteBuffer buffer = ILOG.J2CsMapping.NIO.ByteBuffer.Allocate(20);
	
	            // add a evil byte to make the byte buffer be malformed input
	            buffer.Put((byte) 0xd8);
	
	            // put the valid byte array
	            buffer.Put(unibytes);
	
	            // reset postion
	            buffer.Flip();
	
	            decoder.OnMalformedInput(ILOG.J2CsMapping.NIO.Charset.CodingErrorAction.REPLACE);
	            CharBuffer xout = ILOG.J2CsMapping.NIO.CharBuffer.Decode(buffer,decoder);
	            String expected = "\ufffd buffer";
	            if (!expected.Equals(ILOG.J2CsMapping.Util.StringUtil.NewString(xout.Array()))) {
	                Errln("Did not get the expected result for substitution chars. Got: "
	                        + ILOG.J2CsMapping.Util.StringUtil.NewString(xout.Array())
	                        + "("
	                        + IBM.ICU.Dev.Test.TestFmwk.Hex(xout.Array())
	                        + ")");
	            }
	            Logln("Output: " + ILOG.J2CsMapping.Util.StringUtil.NewString(xout.Array()) + "(" + IBM.ICU.Dev.Test.TestFmwk.Hex(xout.Array())
	                    + ")");
	        } catch (CharacterCodingException ex) {
	            Errln("Unexpected exception: " + ex.ToString());
	        }
	    }
	
	    /*
	     * public void TestImplFlushFailure(){
	     * 
	     * try{ CharBuffer in =
	     * CharBuffer.wrap("\u3005\u3006\u3007\u30FC\u2015\u2010\uFF0F");
	     * CharsetEncoder encoder = new
	     * CharsetProviderICU().charsetForName("iso-2022-jp").newEncoder();
	     * ByteBuffer out = ByteBuffer.allocate(30); encoder.encode(in, out, true);
	     * encoder.flush(out); if(out.position()!= 20){
	     * errln("Did not get the expected position from flush"); }
	     * 
	     * }catch (Exception ex){
	     * errln("Could not create encoder for  iso-2022-jp exception: "
	     * +ex.toString()); } }
	     */
	    public void TestISO88591() {
	
	        Encoding cs = new CharsetProviderICU().CharsetForName("iso-8859-1");
	        if (cs != null) {
	            Encoder encoder = cs.GetEncoder();
	            if (encoder != null) {
	                encoder.CanEncode("\uc2a3");
	            } else {
	                Errln("Could not create encoder for iso-8859-1");
	            }
	        } else {
	            Errln("Could not create Charset for iso-8859-1");
	        }
	
	    }
	
	    public void TestUTF8Encode() {
	        Encoder encoderICU = new CharsetProviderICU().CharsetForName(
	                        "utf-8").GetEncoder();
	        ByteBuffer xout = ILOG.J2CsMapping.NIO.ByteBuffer.Allocate(30);
	        CoderResult result = encoderICU.Encode(ILOG.J2CsMapping.NIO.CharBuffer.Wrap("\ud800"), xout,
	                true);
	
	        if (result.IsMalformed()) {
	            Logln("\\ud800 is malformed for ICU4JNI utf-8 encoder");
	        } else if (result.IsUnderflow()) {
	            Errln("\\ud800 is OK for ICU4JNI utf-8 encoder");
	        }
	
	        Encoder encoderJDK = System.Text.Encoding.GetEncoding("utf-8").GetEncoder();
	        result = encoderJDK.Encode(ILOG.J2CsMapping.NIO.CharBuffer.Wrap("\ud800"),
	                ILOG.J2CsMapping.NIO.ByteBuffer.Allocate(10), true);
	        if (result.IsUnderflow()) {
	            Errln("\\ud800 is OK for JDK utf-8 encoder");
	        } else if (result.IsMalformed()) {
	            Logln("\\ud800 is malformed for JDK utf-8 encoder");
	        }
	    }
	
	    /*
	     * private void printCB(CharBuffer buf){ buf.rewind();
	     * while(buf.hasRemaining()){ System.out.println(hex(buf.get())); }
	     * buf.rewind(); }
	     */
	    public void TestUTF8() {
	        try {
	            Encoder encoderICU = new CharsetProviderICU()
	                                .CharsetForName("utf-8").GetEncoder();
	            ILOG.J2CsMapping.NIO.ByteBuffer.Encode(ILOG.J2CsMapping.NIO.CharBuffer.Wrap("\ud800"),encoderICU);
	            Errln("\\ud800 is OK for ICU4JNI utf-8 encoder");
	        } catch (Exception e) {
	            Logln("\\ud800 is malformed for JDK utf-8 encoder");
	            // e.printStackTrace();
	        }
	
	        Encoder encoderJDK = System.Text.Encoding.GetEncoding("utf-8").GetEncoder();
	        try {
	            ILOG.J2CsMapping.NIO.ByteBuffer.Encode(ILOG.J2CsMapping.NIO.CharBuffer.Wrap("\ud800"),encoderJDK);
	            Errln("\\ud800 is OK for JDK utf-8 encoder");
	        } catch (Exception e_0) {
	            Logln("\\ud800 is malformed for JDK utf-8 encoder");
	            // e.printStackTrace();
	        }
	    }
	
	    public void TestUTF16Bom() {
	
	        Encoding cs = (new CharsetProviderICU()).CharsetForName("UTF-16");
	        char[] ins0 = new char[] { 0x1122, 0x2211, 0x3344, 0x4433, 0x5566,
	                0x6655, 0x7788, 0x8877, 0x9900 };
	        CharBuffer inBuf = ILOG.J2CsMapping.NIO.CharBuffer.Allocate(ins0.Length);
	        inBuf.Put(ins0);
	        Encoder encoder = cs.GetEncoder();
	        ByteBuffer outBuf = ILOG.J2CsMapping.NIO.ByteBuffer.Allocate(ins0.Length * 2 + 2);
	        inBuf.Rewind();
	        encoder.Encode(inBuf, outBuf, true);
	        outBuf.Rewind();
	        if (outBuf.Get(0) != (byte) 0xFE && outBuf.Get(1) != (byte) 0xFF) {
	            Errln("The UTF16 encoder did not appended bom. Length returned: "
	                    + outBuf.Remaining());
	        }
	        while (outBuf.HasRemaining()) {
	            Logln("0x" + IBM.ICU.Dev.Test.TestFmwk.Hex(outBuf.Get()));
	        }
	        Decoder decoder = cs.GetDecoder();
	        outBuf.Rewind();
	        CharBuffer rt = ILOG.J2CsMapping.NIO.CharBuffer.Allocate(ins0.Length);
	        CoderResult cr = decoder.Decode(outBuf, rt, true);
	        if (cr.IsError()) {
	            Errln("Decoding with BOM failed. Error: " + cr.ToString());
	        }
	        Equals(rt, ins0);
	        {
	            rt.Clear();
	            outBuf.Rewind();
	            Encoding utf16 = System.Text.Encoding.GetEncoding("UTF-16");
	            Decoder dc = utf16.GetDecoder();
	            cr = dc.Decode(outBuf, rt, true);
	            Equals(rt, ins0);
	        }
	    }
	
	    private void SmBufDecode(Decoder decoder, String encoding,
	            ByteBuffer source, CharBuffer target, bool throwException,
	            bool flush) {
	        SmBufDecode(decoder, encoding, source, target, throwException, flush,
	                true);
	    }
	
	    private void SmBufDecode(Decoder decoder, String encoding,
	            ByteBuffer source, CharBuffer target, bool throwException,
	            bool flush, bool backedByArray) {
	        SmBufDecode(decoder, encoding, source, target, throwException, flush,
	                backedByArray, -1);
	    }
	
	    private void SmBufDecode(Decoder decoder, String encoding,
	            ByteBuffer source, CharBuffer target, bool throwException,
	            bool flush, bool backedByArray, int targetLimit) {
	        ByteBuffer mySource;
	        CharBuffer myTarget;
	        if (backedByArray) {
	            mySource = ILOG.J2CsMapping.NIO.ByteBuffer.Allocate(source.Capacity());
	            myTarget = ILOG.J2CsMapping.NIO.CharBuffer.Allocate(target.Capacity());
	        } else {
	            // this does not guarantee by any means that mySource and myTarget
	            // are not backed by arrays
	            mySource = ILOG.J2CsMapping.NIO.ByteBuffer.AllocateDirect(source.Capacity());
	            myTarget = ILOG.J2CsMapping.NIO.ByteBuffer.AllocateDirect(target.Capacity() * 2)
	                    .AsCharBuffer();
	        }
	        mySource.Position(source.Position());
	        for (int i = source.Position(); i < source.Limit(); i++)
	            mySource.Put(i, source.Get(i));
	
	        {
	            decoder.Reset();
	            myTarget.Limit(target.Limit());
	            mySource.Limit(source.Limit());
	            mySource.Position(source.Position());
	            CoderResult result = ILOG.J2CsMapping.NIO.Charset.CoderResult.UNDERFLOW;
	            result = decoder.Decode(mySource, myTarget, true);
	            if (flush) {
	                decoder.Flush(myTarget);
	            }
	            if (result.IsError()) {
	                if (throwException) {
	                    throw new Exception();
	                }
	                Errln("Test complete buffers while decoding failed. "
	                        + result.ToString());
	                return;
	            }
	            if (result.IsOverflow()) {
	                if (throwException) {
	                    throw new BufferOverflowException();
	                }
	                Errln("Test complete buffers while decoding threw overflow exception");
	                return;
	            }
	            myTarget.Limit(myTarget.Position());
	            myTarget.Position(0);
	            target.Position(0);
	            if (result.IsUnderflow() && !Equals(myTarget, target, targetLimit)) {
	                Errln(" Test complete buffers while decoding  " + encoding
	                        + " TO Unicode--failed");
	            }
	        }
	        if (IsQuick()) {
	            return;
	        }
	        {
	            decoder.Reset();
	            myTarget.Limit(target.Limit());
	            mySource.Limit(source.Limit());
	            mySource.Position(source.Position());
	            myTarget.Clear();
	            myTarget.Position(0);
	
	            int inputLen = mySource.Remaining();
	
	            CoderResult result_0 = ILOG.J2CsMapping.NIO.Charset.CoderResult.UNDERFLOW;
	            for (int i_1 = 1; i_1 <= inputLen; i_1++) {
	                mySource.Limit(i_1);
	                if (i_1 == inputLen) {
	                    result_0 = decoder.Decode(mySource, myTarget, true);
	                } else {
	                    result_0 = decoder.Decode(mySource, myTarget, false);
	                }
	                if (result_0.IsError()) {
	                    Errln("Test small input buffers while decoding failed. "
	                            + result_0.ToString());
	                    break;
	                }
	                if (result_0.IsOverflow()) {
	                    if (throwException) {
	                        throw new BufferOverflowException();
	                    }
	                    Errln("Test small input buffers while decoding threw overflow exception");
	                    break;
	                }
	
	            }
	            if (result_0.IsUnderflow() && !Equals(myTarget, target, targetLimit)) {
	                Errln("Test small input buffers while decoding " + encoding
	                        + " TO Unicode--failed");
	            }
	        }
	        {
	            decoder.Reset();
	            myTarget.Limit(target.Limit());
	            mySource.Limit(source.Limit());
	            mySource.Position(source.Position());
	            myTarget.Clear();
	            while (true) {
	                int pos = myTarget.Position() + 1;
	                if (myTarget.Capacity() < pos)
	                    break;
	                myTarget.Limit(pos);
	                CoderResult result_2 = decoder.Decode(mySource, myTarget, false);
	                if (result_2.IsError()) {
	                    Errln("Test small output buffers while decoding "
	                            + result_2.ToString());
	                }
	                if (mySource.Position() == mySource.Limit()) {
	                    result_2 = decoder.Decode(mySource, myTarget, true);
	                    if (result_2.IsError()) {
	                        Errln("Test small output buffers while decoding "
	                                + result_2.ToString());
	                    }
	                    result_2 = decoder.Flush(myTarget);
	                    if (result_2.IsError()) {
	                        Errln("Test small output buffers while decoding "
	                                + result_2.ToString());
	                    }
	                    break;
	                }
	            }
	
	            if (!Equals(myTarget, target, targetLimit)) {
	                Errln("Test small output buffers " + encoding
	                        + " TO Unicode failed");
	            }
	        }
	    }
	
	    private void SmBufEncode(Encoder encoder, String encoding,
	            CharBuffer source, ByteBuffer target, bool throwException,
	            bool flush) {
	        SmBufEncode(encoder, encoding, source, target, throwException, flush,
	                true);
	    }
	
	    private void SmBufEncode(Encoder encoder, String encoding,
	            CharBuffer source, ByteBuffer target, bool throwException,
	            bool flush, bool backedByArray) {
	        SmBufEncode(encoder, encoding, source, target, throwException, flush,
	                true, -1);
	    }
	
	    private void SmBufEncode(Encoder encoder, String encoding,
	            CharBuffer source, ByteBuffer target, bool throwException,
	            bool flush, bool backedByArray, int targetLimit) {
	        Logln("Running smBufEncode for " + encoding + " with class " + encoder);
	
	        CharBuffer mySource;
	        ByteBuffer myTarget;
	        if (backedByArray) {
	            mySource = ILOG.J2CsMapping.NIO.CharBuffer.Allocate(source.Capacity());
	            myTarget = ILOG.J2CsMapping.NIO.ByteBuffer.Allocate(target.Capacity());
	        } else {
	            mySource = ILOG.J2CsMapping.NIO.ByteBuffer.AllocateDirect(source.Capacity() * 2)
	                    .AsCharBuffer();
	            myTarget = ILOG.J2CsMapping.NIO.ByteBuffer.AllocateDirect(target.Capacity());
	        }
	        mySource.Position(source.Position());
	        for (int i = source.Position(); i < source.Limit(); i++)
	            mySource.Put(i, source.Get(i));
	
	        myTarget.Clear();
	        {
	            Logln("Running tests on small input buffers for " + encoding);
	            encoder.Reset();
	            myTarget.Limit(target.Limit());
	            mySource.Limit(source.Limit());
	            mySource.Position(source.Position());
	            CoderResult result = null;
	
	            result = encoder.Encode(mySource, myTarget, true);
	            if (flush) {
	                result = encoder.Flush(myTarget);
	            }
	
	            if (result.IsError()) {
	                if (throwException) {
	                    throw new Exception();
	                }
	                Errln("Test complete while encoding failed. "
	                        + result.ToString());
	            }
	            if (result.IsOverflow()) {
	                if (throwException) {
	                    throw new BufferOverflowException();
	                }
	                Errln("Test complete while encoding threw overflow exception");
	            }
	            if (!Equals(myTarget, target, targetLimit)) {
	                Errln("Test complete buffers while encoding for " + encoding
	                        + " failed");
	
	            } else {
	                Logln("Tests complete buffers for " + encoding + " passed");
	            }
	        }
	        if (IsQuick()) {
	            return;
	        }
	        {
	            Logln("Running tests on small input buffers for " + encoding);
	            encoder.Reset();
	            myTarget.Clear();
	            myTarget.Limit(target.Limit());
	            mySource.Limit(source.Limit());
	            mySource.Position(source.Position());
	            int inputLen = mySource.Limit();
	            CoderResult result_0 = null;
	            for (int i_1 = 1; i_1 <= inputLen; i_1++) {
	                mySource.Limit(i_1);
	                result_0 = encoder.Encode(mySource, myTarget, false);
	                if (result_0.IsError()) {
	                    Errln("Test small input buffers while encoding failed. "
	                            + result_0.ToString());
	                }
	                if (result_0.IsOverflow()) {
	                    if (throwException) {
	                        throw new BufferOverflowException();
	                    }
	                    Errln("Test small input buffers while encoding threw overflow exception");
	                }
	            }
	            if (!Equals(myTarget, target, targetLimit)) {
	                Errln("Test small input buffers " + encoding
	                        + " From Unicode failed");
	            } else {
	                Logln("Tests on small input buffers for " + encoding
	                        + " passed");
	            }
	        }
	        {
	            Logln("Running tests on small output buffers for " + encoding);
	            encoder.Reset();
	            myTarget.Clear();
	            myTarget.Limit(target.Limit());
	            mySource.Limit(source.Limit());
	            mySource.Position(source.Position());
	            mySource.Position(0);
	            myTarget.Position(0);
	
	            Logln("myTarget.limit: " + myTarget.Limit() + " myTarget.capcity: "
	                    + myTarget.Capacity());
	
	            while (true) {
	                int pos = myTarget.Position();
	
	                CoderResult result_2 = encoder.Encode(mySource, myTarget, false);
	                Logln("myTarget.Position: " + pos + " myTarget.limit: "
	                        + myTarget.Limit());
	                Logln("mySource.position: " + mySource.Position()
	                        + " mySource.limit: " + mySource.Limit());
	
	                if (result_2.IsError()) {
	                    Errln("Test small output buffers while encoding "
	                            + result_2.ToString());
	                }
	                if (mySource.Position() == mySource.Limit()) {
	                    result_2 = encoder.Encode(mySource, myTarget, true);
	                    if (result_2.IsError()) {
	                        Errln("Test small output buffers while encoding "
	                                + result_2.ToString());
	                    }
	
	                    myTarget.Limit(myTarget.Capacity());
	                    result_2 = encoder.Flush(myTarget);
	                    if (result_2.IsError()) {
	                        Errln("Test small output buffers while encoding "
	                                + result_2.ToString());
	                    }
	                    break;
	                }
	            }
	            if (!Equals(myTarget, target, targetLimit)) {
	                Errln("Test small output buffers " + encoding
	                        + " From Unicode failed.");
	            }
	            Logln("Tests on small output buffers for " + encoding + " passed");
	        }
	    }
	
	    public void ConvertAllTest(ByteBuffer bSource, CharBuffer uSource) {
	        {
	            try {
	                m_decoder.Reset();
	                ByteBuffer mySource = bSource.Duplicate();
	                CharBuffer myTarget = ILOG.J2CsMapping.NIO.CharBuffer.Decode(mySource,m_decoder);
	                if (!Equals(myTarget, uSource)) {
	                    Errln("--Test convertAll() " + m_encoding
	                            + " to Unicode  --FAILED");
	                }
	            } catch (Exception e) {
	                // e.printStackTrace();
	                Errln(e.Message);
	            }
	        }
	        {
	            try {
	                m_encoder.Reset();
	                CharBuffer mySource_0 = ILOG.J2CsMapping.NIO.CharBuffer.Wrap(uSource);
	                ByteBuffer myTarget_1 = ILOG.J2CsMapping.NIO.ByteBuffer.Encode(mySource_0,m_encoder);
	                if (!Equals(myTarget_1, bSource)) {
	                    Errln("--Test convertAll() " + m_encoding
	                            + " to Unicode  --FAILED");
	                }
	            } catch (Exception e_2) {
	                // e.printStackTrace();
	                Errln("encoder.encode() failed " + e_2.Message + " "
	                        + e_2.ToString());
	            }
	        }
	
	    }
	
	    // TODO
	    /*
	     * public void TestString(ByteBuffer bSource, CharBuffer uSource) throws
	     * Exception { try { { String source = uSource.toString(); byte[] target =
	     * source.getBytes(m_encoding); if (!equals(target, bSource.array())) {
	     * errln("encode using string API failed"); } } {
	     * 
	     * String target = new String(bSource.array(), m_encoding); if
	     * (!equals(uSource, target.toCharArray())) {
	     * errln("decode using string API failed"); } } } catch (Exception e) {
	     * //e.printStackTrace(); errln(e.getMessage()); } }
	     * 
	     * /*private void fromUnicodeTest() throws Exception {
	     * 
	     * logln("Loaded Charset: " + charset.getClass().toString());
	     * logln("Loaded CharsetEncoder: " + encoder.getClass().toString());
	     * logln("Loaded CharsetDecoder: " + decoder.getClass().toString());
	     * 
	     * ByteBuffer myTarget = ByteBuffer.allocate(gbSource.length);
	     * logln("Created ByteBuffer of length: " + uSource.length); CharBuffer
	     * mySource = CharBuffer.wrap(uSource);
	     * logln("Wrapped ByteBuffer with CharBuffer  "); encoder.reset();
	     * logln("Test Unicode to " + encoding ); encoder.encode(mySource, myTarget,
	     * true); if (!equals(myTarget, gbSource)) { errln("--Test Unicode to " +
	     * encoding + ": FAILED"); } logln("Test Unicode to " + encoding
	     * +" passed"); }
	     * 
	     * public void TestToUnicode( ) throws Exception {
	     * 
	     * logln("Loaded Charset: " + charset.getClass().toString());
	     * logln("Loaded CharsetEncoder: " + encoder.getClass().toString());
	     * logln("Loaded CharsetDecoder: " + decoder.getClass().toString());
	     * 
	     * CharBuffer myTarget = CharBuffer.allocate(uSource.length); ByteBuffer
	     * mySource = ByteBuffer.wrap(getByteArray(gbSource)); decoder.reset();
	     * CoderResult result = decoder.decode(mySource, myTarget, true); if
	     * (result.isError()) { errln("Test ToUnicode -- FAILED"); } if
	     * (!equals(myTarget, uSource)) { errln("--Test " + encoding +
	     * " to Unicode :FAILED"); } }
	     * 
	     * public static byte[] getByteArray(char[] source) { byte[] target = new
	     * byte[source.length]; int i = source.length; for (; --i >= 0;) { target[i]
	     * = (byte) source[i]; } return target; } /* private void
	     * smBufCharset(Charset charset) { try { ByteBuffer bTarget =
	     * charset.encode(CharBuffer.wrap(uSource)); CharBuffer uTarget =
	     * charset.decode(ByteBuffer.wrap(getByteArray(gbSource)));
	     * 
	     * if (!equals(uTarget, uSource)) { errln("Test " + charset.toString() +
	     * " to Unicode :FAILED"); } if (!equals(bTarget, gbSource)) { errln("Test "
	     * + charset.toString() + " from Unicode :FAILED"); } } catch (Exception ex)
	     * { errln("Encountered exception in smBufCharset"); } }
	     * 
	     * public void TestMultithreaded() throws Exception { final Charset cs =
	     * Charset.forName(encoding); if (cs == charset) {
	     * errln("The objects are equal"); } smBufCharset(cs); try { final Thread t1
	     * = new Thread() { public void run() { // commented out since the mehtods
	     * on // Charset API are supposed to be thread // safe ... to test it we
	     * dont sync
	     * 
	     * // synchronized(charset){ while (!interrupted()) { try {
	     * smBufCharset(cs); } catch (UnsupportedCharsetException ueEx) {
	     * errln(ueEx.toString()); } }
	     * 
	     * // } } }; final Thread t2 = new Thread() { public void run() { //
	     * synchronized(charset){ while (!interrupted()) { try { smBufCharset(cs); }
	     * catch (UnsupportedCharsetException ueEx) { errln(ueEx.toString()); } }
	     * 
	     * //} } }; t1.start(); t2.start(); int i = 0; for (;;) { if (i >
	     * 1000000000) { try { t1.interrupt(); } catch (Exception e) { } try {
	     * t2.interrupt(); } catch (Exception e) { } break; } i++; } } catch
	     * (Exception e) { throw e; } }
	     * 
	     * public void TestSynchronizedMultithreaded() throws Exception { // Methods
	     * on CharsetDecoder and CharsetEncoder classes // are inherently unsafe if
	     * accessed by multiple concurrent // thread so we synchronize them final
	     * Charset charset = Charset.forName(encoding); final CharsetDecoder decoder
	     * = charset.newDecoder(); final CharsetEncoder encoder =
	     * charset.newEncoder(); try { final Thread t1 = new Thread() { public void
	     * run() { while (!interrupted()) { try { synchronized (encoder) {
	     * smBufEncode(encoder, encoding); } synchronized (decoder) {
	     * smBufDecode(decoder, encoding); } } catch (UnsupportedCharsetException
	     * ueEx) { errln(ueEx.toString()); } }
	     * 
	     * } }; final Thread t2 = new Thread() { public void run() { while
	     * (!interrupted()) { try { synchronized (encoder) { smBufEncode(encoder,
	     * encoding); } synchronized (decoder) { smBufDecode(decoder, encoding); } }
	     * catch (UnsupportedCharsetException ueEx) { errln(ueEx.toString()); } } }
	     * }; t1.start(); t2.start(); int i = 0; for (;;) { if (i > 1000000000) {
	     * try { t1.interrupt(); } catch (Exception e) { } try { t2.interrupt(); }
	     * catch (Exception e) { } break; } i++; } } catch (Exception e) { throw e;
	     * } }
	     */
	
	    public void TestMBCS() {
	        {
	            // Encoder: from Unicode conversion
	            Encoder encoderICU = new CharsetProviderICU()
	                                .CharsetForName("ibm-971").GetEncoder();
	            ByteBuffer xout = ILOG.J2CsMapping.NIO.ByteBuffer.Allocate(6);
	            encoderICU.OnUnmappableCharacter(ILOG.J2CsMapping.NIO.Charset.CodingErrorAction.REPLACE);
	            CoderResult result = encoderICU.Encode(
	                    ILOG.J2CsMapping.NIO.CharBuffer.Wrap("\u0131\u0061\u00a1"), xout, true);
	            if (!result.IsError()) {
	                byte[] expected = { (byte) 0xA9, (byte) 0xA5, (byte) 0xAF,
	                        (byte) 0xFE, (byte) 0xA2, (byte) 0xAE };
	                if (!Equals(expected, xout.Array())) {
	                    Errln("Did not get the expected result for substitution bytes. Got: "
	                            + IBM.ICU.Dev.Test.TestFmwk.Hex(xout.Array()));
	                }
	                Logln("Output: " + IBM.ICU.Dev.Test.TestFmwk.Hex(xout.Array()));
	            } else {
	                Errln("Encode operation failed for encoder: "
	                        + encoderICU.ToString());
	            }
	        }
	        {
	            // Decoder: to Unicode conversion
	            Decoder decoderICU = new CharsetProviderICU()
	                                .CharsetForName("ibm-971").GetDecoder();
	            CharBuffer out_0 = ILOG.J2CsMapping.NIO.CharBuffer.Allocate(3);
	            decoderICU.OnMalformedInput(ILOG.J2CsMapping.NIO.Charset.CodingErrorAction.REPLACE);
	            CoderResult result_1 = decoderICU.Decode(ILOG.J2CsMapping.NIO.ByteBuffer.Wrap(new byte[] {
	                    (byte) 0xA2, (byte) 0xAE, (byte) 0x12, (byte) 0x34,
	                    (byte) 0xEF, (byte) 0xDC }), out_0, true);
	            if (!result_1.IsError()) {
	                char[] expected_2 = { '\u00a1', '\ufffd', '\u6676' };
	                if (!Equals(expected_2, out_0.Array())) {
	                    Errln("Did not get the expected result for substitution chars. Got: "
	                            + IBM.ICU.Dev.Test.TestFmwk.Hex(out_0.Array()));
	                }
	                Logln("Output: " + IBM.ICU.Dev.Test.TestFmwk.Hex(out_0.Array()));
	            } else {
	                Errln("Decode operation failed for encoder: "
	                        + decoderICU.ToString());
	            }
	        }
	    }
	
	    public void TestJB4897() {
	        CharsetProviderICU provider = new CharsetProviderICU();
	        Encoding charset = provider.CharsetForName("x-abracadabra");
	        if (charset != null && charset.CanEncode() == true) {
	            Errln("provider.charsetForName() does not validate the charset names");
	        }
	    }
	
	    public void TestJB5027() {
	        CharsetProviderICU provider = new CharsetProviderICU();
	
	        Encoding fake = provider.CharsetForName("doesNotExist");
	        if (fake != null) {
	            Errln("\"doesNotExist\" returned " + fake);
	        }
	        Encoding xfake = provider.CharsetForName("x-doesNotExist");
	        if (xfake != null) {
	            Errln("\"x-doesNotExist\" returned " + xfake);
	        }
	    }
	
	    // test to make sure that number of aliases and canonical names are in the
	    // charsets that are in
	    public void TestAllNames() {
	
	        CharsetProviderICU provider = new CharsetProviderICU();
	        Object[] available = IBM.ICU.Charset.CharsetProviderICU.GetAvailableNames();
	        for (int i = 0; i < available.Length; i++) {
	            try {
	                String canon = IBM.ICU.Charset.CharsetProviderICU
	                        .GetICUCanonicalName((String) available[i]);
	
	                // ',' is not allowed by Java's charset name checker
	                if (canon.IndexOf(',') >= 0) {
	                    continue;
	                }
	                Encoding cs = provider.CharsetForName((String) available[i]);
	
	                Object[] javaAliases = ILOG.J2CsMapping.Collections.Generics.Collections.ToArray(cs.Aliases());
	                // seach for ICU canonical name in javaAliases
	                bool inAliasList = false;
	                for (int j = 0; j < javaAliases.Length; j++) {
	                    String java = (String) javaAliases[j];
	                    if (java.Equals(canon)) {
	                        Logln("javaAlias: " + java + " canon: " + canon);
	                        inAliasList = true;
	                    }
	                }
	                if (inAliasList == false) {
	                    Errln("Could not find ICU canonical name: " + canon
	                            + " for java canonical name: " + available[i] + " "
	                            + i);
	                }
	            } catch (ArgumentException ex) {
	                Errln("could no load charset " + available[i] + " "
	                        + ex.Message);
	                continue;
	            }
	        }
	    }
	
	    public void TestDecoderImplFlush() {
	        CharsetProviderICU provider = new CharsetProviderICU();
	        Encoding ics = provider.CharsetForName("UTF-16");
	        Encoding jcs = System.Text.Encoding.GetEncoding("UTF-16"); // Java's UTF-16 charset
	        ExecDecoder(jcs);
	        ExecDecoder(ics);
	    }
	
	    public void TestEncoderImplFlush() {
	        CharsetProviderICU provider = new CharsetProviderICU();
	        Encoding ics = provider.CharsetForName("UTF-16");
	        Encoding jcs = System.Text.Encoding.GetEncoding("UTF-16"); // Java's UTF-16 charset
	        ExecEncoder(jcs);
	        ExecEncoder(ics);
	    }
	
	    private void ExecDecoder(Encoding cs) {
	        Decoder decoder = cs.GetDecoder();
	        decoder.OnMalformedInput(ILOG.J2CsMapping.NIO.Charset.CodingErrorAction.REPORT);
	        decoder.OnUnmappableCharacter(ILOG.J2CsMapping.NIO.Charset.CodingErrorAction.REPORT);
	        CharBuffer xout = ILOG.J2CsMapping.NIO.CharBuffer.Allocate(10);
	        CoderResult result = decoder.Decode(
	                ILOG.J2CsMapping.NIO.ByteBuffer.Wrap(new byte[] { -1, -2, 32, 0, 98 }), xout, false);
	        result = decoder.Decode(ILOG.J2CsMapping.NIO.ByteBuffer.Wrap(new byte[] { 98 }), xout, true);
	
	        Logln(cs.GetType().ToString() + ":" + result.ToString());
	        try {
	            result = decoder.Flush(xout);
	            Logln(cs.GetType().ToString() + ":" + result.ToString());
	        } catch (Exception e) {
	            Errln(e.Message + " " + cs.GetType().ToString());
	        }
	    }
	
	    private void ExecEncoder(Encoding cs) {
	        Encoder encoder = cs.GetEncoder();
	        encoder.OnMalformedInput(ILOG.J2CsMapping.NIO.Charset.CodingErrorAction.REPORT);
	        encoder.OnUnmappableCharacter(ILOG.J2CsMapping.NIO.Charset.CodingErrorAction.REPORT);
	        ByteBuffer xout = ILOG.J2CsMapping.NIO.ByteBuffer.Allocate(10);
	        CoderResult result = encoder.Encode(
	                ILOG.J2CsMapping.NIO.CharBuffer.Wrap(new char[] { '\uFFFF', '\u2345', 32, 98 }),
	                xout, false);
	        Logln(cs.GetType().ToString() + ":" + result.ToString());
	        result = encoder.Encode(ILOG.J2CsMapping.NIO.CharBuffer.Wrap(new char[] { 98 }), xout, true);
	
	        Logln(cs.GetType().ToString() + ":" + result.ToString());
	        try {
	            result = encoder.Flush(xout);
	            Logln(cs.GetType().ToString() + ":" + result.ToString());
	        } catch (Exception e) {
	            Errln(e.Message + " " + cs.GetType().ToString());
	        }
	    }
	
	    public void TestDecodeMalformed() {
	        CharsetProviderICU provider = new CharsetProviderICU();
	        Encoding ics = provider.CharsetForName("UTF-16BE");
	        // Use SUN's charset
	        Encoding jcs = System.Text.Encoding.GetEncoding("UTF-16");
	        CoderResult ir = ExecMalformed(ics);
	        CoderResult jr = ExecMalformed(jcs);
	        if (ir != jr) {
	            Errln("ICU's decoder did not return the same result as Sun. ICU: "
	                    + ir.ToString() + " Sun: " + jr.ToString());
	        }
	    }
	
	    private CoderResult ExecMalformed(Encoding cs) {
	        Decoder decoder = cs.GetDecoder();
	        decoder.OnMalformedInput(ILOG.J2CsMapping.NIO.Charset.CodingErrorAction.IGNORE);
	        decoder.OnUnmappableCharacter(ILOG.J2CsMapping.NIO.Charset.CodingErrorAction.REPORT);
	        ByteBuffer ins0 = ILOG.J2CsMapping.NIO.ByteBuffer.Wrap(new byte[] { 0x00, 0x41, 0x00, 0x42,
	                0x01 });
	        CharBuffer xout = ILOG.J2CsMapping.NIO.CharBuffer.Allocate(3);
	        return decoder.Decode(ins0, xout, true);
	    }
	
	    public void TestJavaUTF16Decoder() {
	        CharsetProviderICU provider = new CharsetProviderICU();
	        Encoding ics = provider.CharsetForName("UTF-16BE");
	        // Use SUN's charset
	        Encoding jcs = System.Text.Encoding.GetEncoding("UTF-16");
	        Exception ie = ExecConvertAll(ics);
	        Exception je = ExecConvertAll(jcs);
	        if (ie != je) {
	            Errln("ICU's decoder did not return the same result as Sun. ICU: "
	                    + ie.ToString() + " Sun: " + je.ToString());
	        }
	    }
	
	    private Exception ExecConvertAll(Encoding cs) {
	        ByteBuffer ins0 = ILOG.J2CsMapping.NIO.ByteBuffer.Allocate(400);
	        int i = 0;
	        while (ins0.Position() != ins0.Capacity()) {
	            ins0.Put((byte) 0xD8);
	            ins0.Put((byte) i);
	            ins0.Put((byte) 0xDC);
	            ins0.Put((byte) i);
	            i++;
	        }
	        ins0.Limit(ins0.Position());
	        ins0.Position(0);
	        Decoder decoder = cs.GetDecoder();
	        decoder.OnMalformedInput(ILOG.J2CsMapping.NIO.Charset.CodingErrorAction.IGNORE);
	        decoder.OnUnmappableCharacter(ILOG.J2CsMapping.NIO.Charset.CodingErrorAction.REPORT);
	        try {
	            CharBuffer xout = ILOG.J2CsMapping.NIO.CharBuffer.Decode(ins0,decoder);
	            if (xout != null) {
	                Logln(cs.ToString() + " encoing succeeded as expected!");
	            }
	        } catch (Exception ex) {
	            Errln("Did not get expected exception for encoding: "
	                    + cs.ToString());
	            return ex;
	        }
	        return null;
	    }
	
	    public void TestUTF32BOM() {
	
	        Encoding cs = (new CharsetProviderICU()).CharsetForName("UTF-32");
	        char[] ins0 = new char[] { 0xd800, 0xdc00, 0xd801, 0xdc01, 0xdbff,
	                0xdfff, 0xd900, 0xdd00, 0x0000, 0x0041, 0x0000, 0x0042, 0x0000,
	                0x0043 };
	
	        CharBuffer inBuf = ILOG.J2CsMapping.NIO.CharBuffer.Allocate(ins0.Length);
	        inBuf.Put(ins0);
	        Encoder encoder = cs.GetEncoder();
	        ByteBuffer outBuf = ILOG.J2CsMapping.NIO.ByteBuffer.Allocate(ins0.Length * 4 + 4);
	        inBuf.Rewind();
	        encoder.Encode(inBuf, outBuf, true);
	        outBuf.Rewind();
	        if (outBuf.Get(0) != (byte) 0x00 && outBuf.Get(1) != (byte) 0x00
	                && outBuf.Get(2) != (byte) 0xFF && outBuf.Get(3) != (byte) 0xFE) {
	            Errln("The UTF16 encoder did not appended bom. Length returned: "
	                    + outBuf.Remaining());
	        }
	        while (outBuf.HasRemaining()) {
	            Logln("0x" + IBM.ICU.Dev.Test.TestFmwk.Hex(outBuf.Get()));
	        }
	        Decoder decoder = cs.GetDecoder();
	        outBuf.Limit(outBuf.Position());
	        outBuf.Rewind();
	        CharBuffer rt = ILOG.J2CsMapping.NIO.CharBuffer.Allocate(ins0.Length);
	        CoderResult cr = decoder.Decode(outBuf, rt, true);
	        if (cr.IsError()) {
	            Errln("Decoding with BOM failed. Error: " + cr.ToString());
	        }
	        Equals(rt, ins0);
	        try {
	            rt.Clear();
	            outBuf.Rewind();
	            Encoding utf16 = System.Text.Encoding.GetEncoding("UTF-32");
	            Decoder dc = utf16.GetDecoder();
	            cr = dc.Decode(outBuf, rt, true);
	            Equals(rt, ins0);
	        } catch (ArgumentException ex) {
	            // swallow the expection.
	        }
	    }
	
	    /*
	     * Michael Ow Modified 070424
	     */
	    /*
	     * The following two methods provides the option of exceptions when Decoding
	     * and Encoding if needed for testing purposes.
	     */
	    private void SmBufDecode(Decoder decoder, String encoding,
	            ByteBuffer source, CharBuffer target) {
	        SmBufDecode(decoder, encoding, source, target, true);
	    }
	
	    private void SmBufDecode(Decoder decoder, String encoding,
	            ByteBuffer source, CharBuffer target, bool backedByArray) {
	        try {
	            SmBufDecode(decoder, encoding, source, target, false, false,
	                    backedByArray);
	        } catch (Exception ex) {
	            System.Console.Out.WriteLine("!exception!");
	        }
	    }
	
	    private void SmBufEncode(Encoder encoder, String encoding,
	            CharBuffer source, ByteBuffer target) {
	        SmBufEncode(encoder, encoding, source, target, true);
	    }
	
	    private void SmBufEncode(Encoder encoder, String encoding,
	            CharBuffer source, ByteBuffer target, bool backedByArray) {
	        try {
	            SmBufEncode(encoder, encoding, source, target, false, false);
	        } catch (Exception ex) {
	            System.Console.Out.WriteLine("!exception!");
	        }
	    }
	
	    // Test CharsetICUProvider
	    public void TestNullCanonicalName() {
	        String enc = null;
	        String canonicalName = IBM.ICU.Charset.CharsetProviderICU.GetICUCanonicalName(enc);
	
	        if (canonicalName != null) {
	            Errln("getICUCanonicalName return a non-null string for given null string");
	        }
	    }
	
	    public void TestGetAllNames() {
	        String[] names = null;
	
	        names = IBM.ICU.Charset.CharsetProviderICU.GetAllNames();
	
	        if (names == null) {
	            Errln("getAllNames returned a null string.");
	        }
	    }
	
	    // Test CharsetICU
	    public void TestCharsetContains() {
	        bool test;
	
	        CharsetProvider provider = new CharsetProviderICU();
	        Encoding cs1 = provider.CharsetForName("UTF-32");
	        Encoding cs2 = null;
	
	        test = cs1.Contains(cs2);
	
	        if (test != false) {
	            Errln("Charset.contains returned true for a null charset.");
	        }
	
	        cs2 = IBM.ICU.Charset.CharsetICU.ForNameICU("UTF-32");
	
	        test = cs1.Contains(cs2);
	
	        if (test != true) {
	            Errln("Charset.contains returned false for an identical charset.");
	        }
	
	        cs2 = provider.CharsetForName("UTF-8");
	
	        test = cs1.Contains(cs2);
	
	        if (test != false) {
	            Errln("Charset.contains returned true for a different charset.");
	        }
	    }
	
	    public void TestCharsetICUNullCharsetName() {
	        String charsetName = null;
	
	        try {
	            IBM.ICU.Charset.CharsetICU.ForNameICU(charsetName);
	            Errln("CharsetICU.forName should have thown an exception after getting a null charsetName.");
	        } catch (Exception ex) {
	        }
	    }
	
	    // Test CharsetASCII
	    public void TestCharsetASCIIOverFlow() {
	        int byteBufferLimit;
	        int charBufferLimit;
	
	        CharsetProvider provider = new CharsetProviderICU();
	        Encoding cs = provider.CharsetForName("ASCII");
	        Encoder encoder = cs.GetEncoder();
	        Decoder decoder = cs.GetDecoder();
	
	        CharBuffer charBuffer = ILOG.J2CsMapping.NIO.CharBuffer.Allocate(0x90);
	        ByteBuffer byteBuffer = ILOG.J2CsMapping.NIO.ByteBuffer.Allocate(0x90);
	
	        CharBuffer charBufferTest = ILOG.J2CsMapping.NIO.CharBuffer.Allocate(0xb0);
	        ByteBuffer byteBufferTest = ILOG.J2CsMapping.NIO.ByteBuffer.Allocate(0xb0);
	
	        for (int j = 0; j <= 0x7f; j++) {
	            charBuffer.Put((char) j);
	            byteBuffer.Put((byte) j);
	        }
	
	        byteBuffer.Limit(byteBufferLimit = byteBuffer.Position());
	        byteBuffer.Position(0);
	        charBuffer.Limit(charBufferLimit = charBuffer.Position());
	        charBuffer.Position(0);
	
	        // test for overflow
	        byteBufferTest.Limit(byteBufferLimit - 5);
	        byteBufferTest.Position(0);
	        charBufferTest.Limit(charBufferLimit - 5);
	        charBufferTest.Position(0);
	        try {
	            SmBufDecode(decoder, "ASCII", byteBuffer, charBufferTest, true,
	                    false);
	            Errln("Overflow exception while decoding ASCII should have been thrown.");
	        } catch (Exception ex) {
	        }
	        try {
	            SmBufEncode(encoder, "ASCII", charBuffer, byteBufferTest, true,
	                    false);
	            Errln("Overflow exception while encoding ASCII should have been thrown.");
	        } catch (Exception ex_0) {
	        }
	    }
	
	    // Test CharsetUTF7
	    public void TestCharsetUTF7() {
	        CharsetProvider provider = new CharsetProviderICU();
	        Encoding cs = provider.CharsetForName("UTF-7");
	        Encoder encoder = cs.GetEncoder();
	        Decoder decoder = cs.GetDecoder();
	
	        CharBuffer us = ILOG.J2CsMapping.NIO.CharBuffer.Allocate(0x100);
	        ByteBuffer bs = ILOG.J2CsMapping.NIO.ByteBuffer.Allocate(0x100);
	
	        /* Unicode : A<not equal to Alpha Lamda>. */
	        /* UTF7: AImIDkQ. */
	        us.Put((char) 0x41);
	        us.Put((char) 0x2262);
	        us.Put((char) 0x391);
	        us.Put((char) 0x39B);
	        us.Put((char) 0x2e);
	        bs.Put((byte) 0x41);
	        bs.Put((byte) 0x2b);
	        bs.Put((byte) 0x49);
	        bs.Put((byte) 0x6d);
	        bs.Put((byte) 0x49);
	        bs.Put((byte) 0x44);
	        bs.Put((byte) 0x6b);
	        bs.Put((byte) 0x51);
	        bs.Put((byte) 0x4f);
	        bs.Put((byte) 0x62);
	        bs.Put((byte) 0x2e);
	
	        bs.Limit(bs.Position());
	        bs.Position(0);
	        us.Limit(us.Position());
	        us.Position(0);
	
	        SmBufDecode(decoder, "UTF-7", bs, us);
	        SmBufEncode(encoder, "UTF-7", us, bs);
	
	        // The rest of the code in this method is to provide better code
	        // coverage
	        CharBuffer ccus = ILOG.J2CsMapping.NIO.CharBuffer.Allocate(0x10);
	        ByteBuffer ccbs = ILOG.J2CsMapping.NIO.ByteBuffer.Allocate(0x10);
	
	        // start of charset decoder code coverage code
	        // test for accurate illegal and control character checking
	        ccbs.Put((byte) 0x0D);
	        ccbs.Put((byte) 0x05);
	        ccus.Put((char) 0x0000);
	
	        ccbs.Limit(ccbs.Position());
	        ccbs.Position(0);
	        ccus.Limit(ccus.Position());
	        ccus.Position(0);
	
	        try {
	            SmBufDecode(decoder, "UTF-7-CC-DE-1", ccbs, ccus, true, false);
	            Errln("Exception while decoding UTF-7 code coverage test should have been thrown.");
	        } catch (Exception ex) {
	        }
	
	        ccbs.Clear();
	        ccus.Clear();
	
	        // test for illegal base64 character
	        ccbs.Put((byte) 0x2b);
	        ccbs.Put((byte) 0xff);
	        ccus.Put((char) 0x0000);
	
	        ccbs.Limit(ccbs.Position());
	        ccbs.Position(0);
	        ccus.Limit(ccus.Position());
	        ccus.Position(0);
	
	        try {
	            SmBufDecode(decoder, "UTF-7-CC-DE-2", ccbs, ccus, true, false);
	            Errln("Exception while decoding UTF-7 code coverage test should have been thrown.");
	        } catch (Exception ex_0) {
	        }
	
	        ccbs.Clear();
	        ccus.Clear();
	
	        // test for illegal order of the base64 character sequence
	        ccbs.Put((byte) 0x2b);
	        ccbs.Put((byte) 0x2d);
	        ccbs.Put((byte) 0x2b);
	        ccbs.Put((byte) 0x49);
	        ccbs.Put((byte) 0x2d);
	        ccus.Put((char) 0x0000);
	        ccus.Put((char) 0x0000);
	
	        ccbs.Limit(ccbs.Position());
	        ccbs.Position(0);
	        ccus.Limit(ccus.Position());
	        ccus.Position(0);
	
	        try {
	            SmBufDecode(decoder, "UTF-7-CC-DE-3", ccbs, ccus, true, false);
	            Errln("Exception while decoding UTF-7 code coverage test should have been thrown.");
	        } catch (Exception ex_1) {
	        }
	
	        ccbs.Clear();
	        ccus.Clear();
	
	        // test for illegal order of the base64 character sequence
	        ccbs.Put((byte) 0x2b);
	        ccbs.Put((byte) 0x0a);
	        ccbs.Put((byte) 0x09);
	        ccus.Put((char) 0x0000);
	
	        ccbs.Limit(ccbs.Position());
	        ccbs.Position(0);
	        ccus.Limit(ccus.Position());
	        ccus.Position(0);
	
	        try {
	            SmBufDecode(decoder, "UTF-7-CC-DE-4", ccbs, ccus, true, false);
	            Errln("Exception while decoding UTF-7 code coverage test should have been thrown.");
	        } catch (Exception ex_2) {
	        }
	
	        ccbs.Clear();
	        ccus.Clear();
	
	        // test for illegal order of the base64 character sequence
	        ccbs.Put((byte) 0x2b);
	        ccbs.Put((byte) 0x49);
	        ccbs.Put((byte) 0x0a);
	        ccus.Put((char) 0x0000);
	
	        ccbs.Limit(ccbs.Position());
	        ccbs.Position(0);
	        ccus.Limit(ccus.Position());
	        ccus.Position(0);
	
	        try {
	            SmBufDecode(decoder, "UTF-7-CC-DE-5", ccbs, ccus, true, false);
	            Errln("Exception while decoding UTF-7 code coverage test should have been thrown.");
	        } catch (Exception ex_3) {
	        }
	
	        ccbs.Clear();
	        ccus.Clear();
	
	        // test for illegal order of the base64 character sequence
	        ccbs.Put((byte) 0x2b);
	        ccbs.Put((byte) 0x00);
	        ccus.Put((char) 0x0000);
	
	        ccbs.Limit(ccbs.Position());
	        ccbs.Position(0);
	        ccus.Limit(ccus.Position());
	        ccus.Position(0);
	
	        try {
	            SmBufDecode(decoder, "UTF-7-CC-DE-6", ccbs, ccus, true, false);
	            Errln("Exception while decoding UTF-7 code coverage test should have been thrown.");
	        } catch (Exception ex_4) {
	        }
	
	        ccbs.Clear();
	        ccus.Clear();
	
	        // test for overflow buffer error
	        ccbs.Put((byte) 0x2b);
	        ccbs.Put((byte) 0x49);
	
	        ccbs.Limit(ccbs.Position());
	        ccbs.Position(0);
	        ccus.Limit(0);
	        ccus.Position(0);
	
	        try {
	            SmBufDecode(decoder, "UTF-7-CC-DE-7", ccbs, ccus, true, false);
	            Errln("Exception while decoding UTF-7 code coverage test should have been thrown.");
	        } catch (Exception ex_5) {
	        }
	
	        ccbs.Clear();
	        ccus.Clear();
	
	        // test for overflow buffer error
	        ccbs.Put((byte) 0x0c);
	        ccbs.Put((byte) 0x0c);
	
	        ccbs.Limit(ccbs.Position());
	        ccbs.Position(0);
	        ccus.Limit(0);
	        ccus.Position(0);
	
	        try {
	            SmBufDecode(decoder, "UTF-7-CC-DE-8", ccbs, ccus, true, false);
	            Errln("Exception while decoding UTF-7 code coverage test should have been thrown.");
	        } catch (Exception ex_6) {
	        }
	        // end of charset decoder code coverage code
	
	        // start of charset encoder code coverage code
	        ccbs.Clear();
	        ccus.Clear();
	        // test for overflow buffer error
	        ccus.Put((char) 0x002b);
	        ccbs.Put((byte) 0x2b);
	
	        ccbs.Limit(ccbs.Position());
	        ccbs.Position(0);
	        ccus.Limit(ccus.Position());
	        ccus.Position(0);
	
	        try {
	            SmBufEncode(encoder, "UTF-7-CC-EN-1", ccus, ccbs, true, false);
	            Errln("Exception while encoding UTF-7 code coverage test should have been thrown.");
	        } catch (Exception ex_7) {
	        }
	
	        ccbs.Clear();
	        ccus.Clear();
	
	        // test for overflow buffer error
	        ccus.Put((char) 0x002b);
	        ccus.Put((char) 0x2262);
	        ccbs.Put((byte) 0x2b);
	        ccbs.Put((byte) 0x2d);
	        ccbs.Put((byte) 0x00);
	        ccbs.Put((byte) 0x00);
	
	        ccbs.Limit(ccbs.Position());
	        ccbs.Position(0);
	        ccus.Limit(ccus.Position());
	        ccus.Position(0);
	
	        try {
	            SmBufEncode(encoder, "UTF-7-CC-EN-2", ccus, ccbs, true, false);
	            Errln("Exception while encoding UTF-7 code coverage test should have been thrown.");
	        } catch (Exception ex_8) {
	        }
	
	        ccbs.Clear();
	        ccus.Clear();
	
	        // test for overflow buffer error
	        ccus.Put((char) 0x2262);
	        ccus.Put((char) 0x0049);
	        ccbs.Put((byte) 0x00);
	        ccbs.Put((byte) 0x00);
	        ccbs.Put((byte) 0x00);
	        ccbs.Put((byte) 0x00);
	        ccbs.Put((byte) 0x00);
	        ccbs.Limit(ccbs.Position());
	        ccbs.Position(0);
	        ccus.Limit(ccus.Position());
	        ccus.Position(0);
	
	        try {
	            SmBufEncode(encoder, "UTF-7-CC-EN-3", ccus, ccbs, true, false);
	            Errln("Exception while encoding UTF-7 code coverage test should have been thrown.");
	        } catch (Exception ex_9) {
	        }
	
	        ccbs.Clear();
	        ccus.Clear();
	
	        // test for overflow buffer error
	        ccus.Put((char) 0x2262);
	        ccus.Put((char) 0x0395);
	        ccbs.Put((byte) 0x00);
	        ccbs.Put((byte) 0x00);
	        ccbs.Put((byte) 0x00);
	        ccbs.Put((byte) 0x00);
	        ccbs.Limit(ccbs.Position());
	        ccbs.Position(0);
	        ccus.Limit(ccus.Position());
	        ccus.Position(0);
	
	        try {
	            SmBufEncode(encoder, "UTF-7-CC-EN-4", ccus, ccbs, true, false);
	            Errln("Exception while encoding UTF-7 code coverage test should have been thrown.");
	        } catch (Exception ex_10) {
	        }
	
	        ccbs.Clear();
	        ccus.Clear();
	
	        // test for overflow buffer error
	        ccus.Put((char) 0x2262);
	        ccus.Put((char) 0x0395);
	        ccbs.Put((byte) 0x00);
	        ccbs.Put((byte) 0x00);
	        ccbs.Put((byte) 0x00);
	        ccbs.Put((byte) 0x00);
	        ccbs.Put((byte) 0x00);
	        ccbs.Limit(ccbs.Position());
	        ccbs.Position(0);
	        ccus.Limit(ccus.Position());
	        ccus.Position(0);
	
	        try {
	            SmBufEncode(encoder, "UTF-7-CC-EN-5", ccus, ccbs, true, false);
	            Errln("Exception while encoding UTF-7 code coverage test should have been thrown.");
	        } catch (Exception ex_11) {
	        }
	
	        ccbs.Clear();
	        ccus.Clear();
	
	        // test for overflow buffer error
	        ccus.Put((char) 0x2262);
	        ccus.Put((char) 0x0395);
	        ccus.Put((char) 0x0391);
	        ccbs.Put((byte) 0x00);
	        ccbs.Put((byte) 0x00);
	        ccbs.Put((byte) 0x00);
	        ccbs.Put((byte) 0x00);
	        ccbs.Put((byte) 0x00);
	        ccbs.Put((byte) 0x00);
	        ccbs.Put((byte) 0x00);
	        ccbs.Limit(ccbs.Position());
	        ccbs.Position(0);
	        ccus.Limit(ccus.Position());
	        ccus.Position(0);
	
	        try {
	            SmBufEncode(encoder, "UTF-7-CC-EN-6", ccus, ccbs, true, false);
	            Errln("Exception while encoding UTF-7 code coverage test should have been thrown.");
	        } catch (Exception ex_12) {
	        }
	
	        ccbs.Clear();
	        ccus.Clear();
	
	        // test for overflow buffer error
	        ccus.Put((char) 0x2262);
	        ccus.Put((char) 0x0395);
	        ccus.Put((char) 0x0391);
	        ccbs.Put((byte) 0x00);
	        ccbs.Put((byte) 0x00);
	        ccbs.Put((byte) 0x00);
	        ccbs.Put((byte) 0x00);
	        ccbs.Put((byte) 0x00);
	        ccbs.Put((byte) 0x00);
	        ccbs.Put((byte) 0x00);
	        ccbs.Put((byte) 0x00);
	        ccbs.Limit(ccbs.Position());
	        ccbs.Position(0);
	        ccus.Limit(ccus.Position());
	        ccus.Position(0);
	
	        try {
	            SmBufEncode(encoder, "UTF-7-CC-EN-7", ccus, ccbs, true, false);
	            Errln("Exception while encoding UTF-7 code coverage test should have been thrown.");
	        } catch (Exception ex_13) {
	        }
	
	        ccbs.Clear();
	        ccus.Clear();
	
	        // test for overflow buffer error
	        ccus.Put((char) 0x0049);
	        ccus.Put((char) 0x0048);
	        ccbs.Put((byte) 0x00);
	        ccbs.Limit(ccbs.Position());
	        ccbs.Position(0);
	        ccus.Limit(ccus.Position());
	        ccus.Position(0);
	
	        try {
	            SmBufEncode(encoder, "UTF-7-CC-EN-8", ccus, ccbs, true, false);
	            Errln("Exception while encoding UTF-7 code coverage test should have been thrown.");
	        } catch (Exception ex_14) {
	        }
	
	        ccbs.Clear();
	        ccus.Clear();
	
	        // test for overflow buffer error
	        ccus.Put((char) 0x2262);
	        ccbs.Put((byte) 0x00);
	        ccbs.Limit(ccbs.Position());
	        ccbs.Position(0);
	        ccus.Limit(ccus.Position());
	        ccus.Position(0);
	
	        try {
	            SmBufEncode(encoder, "UTF-7-CC-EN-9", ccus, ccbs, true, false);
	            Errln("Exception while encoding UTF-7 code coverage test should have been thrown.");
	        } catch (Exception ex_15) {
	        }
	
	        ccbs.Clear();
	        ccus.Clear();
	
	        // test for overflow buffer error
	        ccus.Put((char) 0x2262);
	        ccus.Put((char) 0x0049);
	        ccbs.Put((byte) 0x00);
	        ccbs.Put((byte) 0x00);
	        ccbs.Put((byte) 0x00);
	        ccbs.Put((byte) 0x00);
	        ccbs.Limit(ccbs.Position());
	        ccbs.Position(0);
	        ccus.Limit(ccus.Position());
	        ccus.Position(0);
	
	        try {
	            SmBufEncode(encoder, "UTF-7-CC-EN-10", ccus, ccbs, true, false);
	            Errln("Exception while encoding UTF-7 code coverage test should have been thrown.");
	        } catch (Exception ex_16) {
	        }
	
	        ccbs.Clear();
	        ccus.Clear();
	
	        // test for overflow buffer error
	        ccus.Put((char) 0x2262);
	        ccbs.Put((byte) 0x2b);
	        ccbs.Put((byte) 0x49);
	        ccbs.Put((byte) 0x6d);
	        ccbs.Put((byte) 0x49);
	
	        ccbs.Limit(ccbs.Position());
	        ccbs.Position(0);
	        ccus.Limit(ccus.Position());
	        ccus.Position(0);
	        try {
	            SmBufEncode(encoder, "UTF-7-CC-EN-11", ccus, ccbs, false, true);
	        } catch (Exception ex_17) {
	        }
	        // end of charset encoder code coverage code
	    }
	
	    // Test Charset ISCII
	    public void TestCharsetISCII() {
	        CharsetProvider provider = new CharsetProviderICU();
	        Encoding cs = provider.CharsetForName("ISCII,version=0");
	        Encoder encoder = cs.GetEncoder();
	        Decoder decoder = cs.GetDecoder();
	
	        CharBuffer us = ILOG.J2CsMapping.NIO.CharBuffer.Allocate(0x100);
	        ByteBuffer bs = ILOG.J2CsMapping.NIO.ByteBuffer.Allocate(0x100);
	        ByteBuffer bsr = ILOG.J2CsMapping.NIO.ByteBuffer.Allocate(0x100);
	
	        // test full range of Devanagari
	        us.Put((char) 0x0901);
	        us.Put((char) 0x0902);
	        us.Put((char) 0x0903);
	        us.Put((char) 0x0905);
	        us.Put((char) 0x0906);
	        us.Put((char) 0x0907);
	        us.Put((char) 0x0908);
	        us.Put((char) 0x0909);
	        us.Put((char) 0x090A);
	        us.Put((char) 0x090B);
	        us.Put((char) 0x090E);
	        us.Put((char) 0x090F);
	        us.Put((char) 0x0910);
	        us.Put((char) 0x090D);
	        us.Put((char) 0x0912);
	        us.Put((char) 0x0913);
	        us.Put((char) 0x0914);
	        us.Put((char) 0x0911);
	        us.Put((char) 0x0915);
	        us.Put((char) 0x0916);
	        us.Put((char) 0x0917);
	        us.Put((char) 0x0918);
	        us.Put((char) 0x0919);
	        us.Put((char) 0x091A);
	        us.Put((char) 0x091B);
	        us.Put((char) 0x091C);
	        us.Put((char) 0x091D);
	        us.Put((char) 0x091E);
	        us.Put((char) 0x091F);
	        us.Put((char) 0x0920);
	        us.Put((char) 0x0921);
	        us.Put((char) 0x0922);
	        us.Put((char) 0x0923);
	        us.Put((char) 0x0924);
	        us.Put((char) 0x0925);
	        us.Put((char) 0x0926);
	        us.Put((char) 0x0927);
	        us.Put((char) 0x0928);
	        us.Put((char) 0x0929);
	        us.Put((char) 0x092A);
	        us.Put((char) 0x092B);
	        us.Put((char) 0x092C);
	        us.Put((char) 0x092D);
	        us.Put((char) 0x092E);
	        us.Put((char) 0x092F);
	        us.Put((char) 0x095F);
	        us.Put((char) 0x0930);
	        us.Put((char) 0x0931);
	        us.Put((char) 0x0932);
	        us.Put((char) 0x0933);
	        us.Put((char) 0x0934);
	        us.Put((char) 0x0935);
	        us.Put((char) 0x0936);
	        us.Put((char) 0x0937);
	        us.Put((char) 0x0938);
	        us.Put((char) 0x0939);
	        us.Put((char) 0x200D);
	        us.Put((char) 0x093E);
	        us.Put((char) 0x093F);
	        us.Put((char) 0x0940);
	        us.Put((char) 0x0941);
	        us.Put((char) 0x0942);
	        us.Put((char) 0x0943);
	        us.Put((char) 0x0946);
	        us.Put((char) 0x0947);
	        us.Put((char) 0x0948);
	        us.Put((char) 0x0945);
	        us.Put((char) 0x094A);
	        us.Put((char) 0x094B);
	        us.Put((char) 0x094C);
	        us.Put((char) 0x0949);
	        us.Put((char) 0x094D);
	        us.Put((char) 0x093D);
	        us.Put((char) 0x0966);
	        us.Put((char) 0x0967);
	        us.Put((char) 0x0968);
	        us.Put((char) 0x0969);
	        us.Put((char) 0x096A);
	        us.Put((char) 0x096B);
	        us.Put((char) 0x096C);
	        us.Put((char) 0x096D);
	        us.Put((char) 0x096E);
	        us.Put((char) 0x096F);
	
	        bs.Put((byte) 0xEF);
	        bs.Put((byte) 0x42);
	        bs.Put((byte) 0xA1);
	        bs.Put((byte) 0xA2);
	        bs.Put((byte) 0xA3);
	        bs.Put((byte) 0xA4);
	        bs.Put((byte) 0xA5);
	        bs.Put((byte) 0xA6);
	        bs.Put((byte) 0xA7);
	        bs.Put((byte) 0xA8);
	        bs.Put((byte) 0xA9);
	        bs.Put((byte) 0xAA);
	        bs.Put((byte) 0xAB);
	        bs.Put((byte) 0xAC);
	        bs.Put((byte) 0xAD);
	        bs.Put((byte) 0xAE);
	        bs.Put((byte) 0xAF);
	        bs.Put((byte) 0xB0);
	        bs.Put((byte) 0xB1);
	        bs.Put((byte) 0xB2);
	        bs.Put((byte) 0xB3);
	        bs.Put((byte) 0xB4);
	        bs.Put((byte) 0xB5);
	        bs.Put((byte) 0xB6);
	        bs.Put((byte) 0xB7);
	        bs.Put((byte) 0xB8);
	        bs.Put((byte) 0xB9);
	        bs.Put((byte) 0xBA);
	        bs.Put((byte) 0xBB);
	        bs.Put((byte) 0xBC);
	        bs.Put((byte) 0xBD);
	        bs.Put((byte) 0xBE);
	        bs.Put((byte) 0xBF);
	        bs.Put((byte) 0xC0);
	        bs.Put((byte) 0xC1);
	        bs.Put((byte) 0xC2);
	        bs.Put((byte) 0xC3);
	        bs.Put((byte) 0xC4);
	        bs.Put((byte) 0xC5);
	        bs.Put((byte) 0xC6);
	        bs.Put((byte) 0xC7);
	        bs.Put((byte) 0xC8);
	        bs.Put((byte) 0xC9);
	        bs.Put((byte) 0xCA);
	        bs.Put((byte) 0xCB);
	        bs.Put((byte) 0xCC);
	        bs.Put((byte) 0xCD);
	        bs.Put((byte) 0xCE);
	        bs.Put((byte) 0xCF);
	        bs.Put((byte) 0xD0);
	        bs.Put((byte) 0xD1);
	        bs.Put((byte) 0xD2);
	        bs.Put((byte) 0xD3);
	        bs.Put((byte) 0xD4);
	        bs.Put((byte) 0xD5);
	        bs.Put((byte) 0xD6);
	        bs.Put((byte) 0xD7);
	        bs.Put((byte) 0xD8);
	        bs.Put((byte) 0xD9);
	        bs.Put((byte) 0xDA);
	        bs.Put((byte) 0xDB);
	        bs.Put((byte) 0xDC);
	        bs.Put((byte) 0xDD);
	        bs.Put((byte) 0xDE);
	        bs.Put((byte) 0xDF);
	        bs.Put((byte) 0xE0);
	        bs.Put((byte) 0xE1);
	        bs.Put((byte) 0xE2);
	        bs.Put((byte) 0xE3);
	        bs.Put((byte) 0xE4);
	        bs.Put((byte) 0xE5);
	        bs.Put((byte) 0xE6);
	        bs.Put((byte) 0xE7);
	        bs.Put((byte) 0xE8);
	        bs.Put((byte) 0xEA);
	        bs.Put((byte) 0xE9);
	        bs.Put((byte) 0xF1);
	        bs.Put((byte) 0xF2);
	        bs.Put((byte) 0xF3);
	        bs.Put((byte) 0xF4);
	        bs.Put((byte) 0xF5);
	        bs.Put((byte) 0xF6);
	        bs.Put((byte) 0xF7);
	        bs.Put((byte) 0xF8);
	        bs.Put((byte) 0xF9);
	        bs.Put((byte) 0xFA);
	
	        bsr.Put((byte) 0xA1);
	        bsr.Put((byte) 0xA2);
	        bsr.Put((byte) 0xA3);
	        bsr.Put((byte) 0xA4);
	        bsr.Put((byte) 0xA5);
	        bsr.Put((byte) 0xA6);
	        bsr.Put((byte) 0xA7);
	        bsr.Put((byte) 0xA8);
	        bsr.Put((byte) 0xA9);
	        bsr.Put((byte) 0xAA);
	        bsr.Put((byte) 0xAB);
	        bsr.Put((byte) 0xAC);
	        bsr.Put((byte) 0xAD);
	        bsr.Put((byte) 0xAE);
	        bsr.Put((byte) 0xAF);
	        bsr.Put((byte) 0xB0);
	        bsr.Put((byte) 0xB1);
	        bsr.Put((byte) 0xB2);
	        bsr.Put((byte) 0xB3);
	        bsr.Put((byte) 0xB4);
	        bsr.Put((byte) 0xB5);
	        bsr.Put((byte) 0xB6);
	        bsr.Put((byte) 0xB7);
	        bsr.Put((byte) 0xB8);
	        bsr.Put((byte) 0xB9);
	        bsr.Put((byte) 0xBA);
	        bsr.Put((byte) 0xBB);
	        bsr.Put((byte) 0xBC);
	        bsr.Put((byte) 0xBD);
	        bsr.Put((byte) 0xBE);
	        bsr.Put((byte) 0xBF);
	        bsr.Put((byte) 0xC0);
	        bsr.Put((byte) 0xC1);
	        bsr.Put((byte) 0xC2);
	        bsr.Put((byte) 0xC3);
	        bsr.Put((byte) 0xC4);
	        bsr.Put((byte) 0xC5);
	        bsr.Put((byte) 0xC6);
	        bsr.Put((byte) 0xC7);
	        bsr.Put((byte) 0xC8);
	        bsr.Put((byte) 0xC9);
	        bsr.Put((byte) 0xCA);
	        bsr.Put((byte) 0xCB);
	        bsr.Put((byte) 0xCC);
	        bsr.Put((byte) 0xCD);
	        bsr.Put((byte) 0xCE);
	        bsr.Put((byte) 0xCF);
	        bsr.Put((byte) 0xD0);
	        bsr.Put((byte) 0xD1);
	        bsr.Put((byte) 0xD2);
	        bsr.Put((byte) 0xD3);
	        bsr.Put((byte) 0xD4);
	        bsr.Put((byte) 0xD5);
	        bsr.Put((byte) 0xD6);
	        bsr.Put((byte) 0xD7);
	        bsr.Put((byte) 0xD8);
	        bsr.Put((byte) 0xD9);
	        bsr.Put((byte) 0xDA);
	        bsr.Put((byte) 0xDB);
	        bsr.Put((byte) 0xDC);
	        bsr.Put((byte) 0xDD);
	        bsr.Put((byte) 0xDE);
	        bsr.Put((byte) 0xDF);
	        bsr.Put((byte) 0xE0);
	        bsr.Put((byte) 0xE1);
	        bsr.Put((byte) 0xE2);
	        bsr.Put((byte) 0xE3);
	        bsr.Put((byte) 0xE4);
	        bsr.Put((byte) 0xE5);
	        bsr.Put((byte) 0xE6);
	        bsr.Put((byte) 0xE7);
	        bsr.Put((byte) 0xE8);
	        bsr.Put((byte) 0xEA);
	        bsr.Put((byte) 0xE9);
	        bsr.Put((byte) 0xF1);
	        bsr.Put((byte) 0xF2);
	        bsr.Put((byte) 0xF3);
	        bsr.Put((byte) 0xF4);
	        bsr.Put((byte) 0xF5);
	        bsr.Put((byte) 0xF6);
	        bsr.Put((byte) 0xF7);
	        bsr.Put((byte) 0xF8);
	        bsr.Put((byte) 0xF9);
	        bsr.Put((byte) 0xFA);
	
	        // test Soft Halant
	        us.Put((char) 0x0915);
	        us.Put((char) 0x094d);
	        us.Put((char) 0x200D);
	        bs.Put((byte) 0xB3);
	        bs.Put((byte) 0xE8);
	        bs.Put((byte) 0xE9);
	        bsr.Put((byte) 0xB3);
	        bsr.Put((byte) 0xE8);
	        bsr.Put((byte) 0xE9);
	
	        // test explicit halant
	        us.Put((char) 0x0915);
	        us.Put((char) 0x094D);
	        us.Put((char) 0x200C);
	        bs.Put((byte) 0xB3);
	        bs.Put((byte) 0xE8);
	        bs.Put((byte) 0xE8);
	        bsr.Put((byte) 0xB3);
	        bsr.Put((byte) 0xE8);
	        bsr.Put((byte) 0xE8);
	
	        // test double danda
	        us.Put((char) 0x0965);
	        bs.Put((byte) 0xEA);
	        bs.Put((byte) 0xEA);
	        bsr.Put((byte) 0xEA);
	        bsr.Put((byte) 0xEA);
	
	        // test ASCII
	        us.Put((char) 0x1B);
	        us.Put((char) 0x24);
	        us.Put((char) 0x29);
	        us.Put((char) 0x47);
	        us.Put((char) 0x0E);
	        us.Put((char) 0x23);
	        us.Put((char) 0x21);
	        us.Put((char) 0x23);
	        us.Put((char) 0x22);
	        us.Put((char) 0x23);
	        us.Put((char) 0x23);
	        us.Put((char) 0x23);
	        us.Put((char) 0x24);
	        us.Put((char) 0x23);
	        us.Put((char) 0x25);
	        us.Put((char) 0x23);
	        us.Put((char) 0x26);
	        us.Put((char) 0x23);
	        us.Put((char) 0x27);
	        us.Put((char) 0x23);
	        us.Put((char) 0x28);
	        us.Put((char) 0x23);
	        us.Put((char) 0x29);
	        us.Put((char) 0x23);
	        us.Put((char) 0x2A);
	        us.Put((char) 0x23);
	        us.Put((char) 0x2B);
	        us.Put((char) 0x0F);
	        us.Put((char) 0x2F);
	        us.Put((char) 0x2A);
	
	        bs.Put((byte) 0x1B);
	        bs.Put((byte) 0x24);
	        bs.Put((byte) 0x29);
	        bs.Put((byte) 0x47);
	        bs.Put((byte) 0x0E);
	        bs.Put((byte) 0x23);
	        bs.Put((byte) 0x21);
	        bs.Put((byte) 0x23);
	        bs.Put((byte) 0x22);
	        bs.Put((byte) 0x23);
	        bs.Put((byte) 0x23);
	        bs.Put((byte) 0x23);
	        bs.Put((byte) 0x24);
	        bs.Put((byte) 0x23);
	        bs.Put((byte) 0x25);
	        bs.Put((byte) 0x23);
	        bs.Put((byte) 0x26);
	        bs.Put((byte) 0x23);
	        bs.Put((byte) 0x27);
	        bs.Put((byte) 0x23);
	        bs.Put((byte) 0x28);
	        bs.Put((byte) 0x23);
	        bs.Put((byte) 0x29);
	        bs.Put((byte) 0x23);
	        bs.Put((byte) 0x2A);
	        bs.Put((byte) 0x23);
	        bs.Put((byte) 0x2B);
	        bs.Put((byte) 0x0F);
	        bs.Put((byte) 0x2F);
	        bs.Put((byte) 0x2A);
	
	        bsr.Put((byte) 0x1B);
	        bsr.Put((byte) 0x24);
	        bsr.Put((byte) 0x29);
	        bsr.Put((byte) 0x47);
	        bsr.Put((byte) 0x0E);
	        bsr.Put((byte) 0x23);
	        bsr.Put((byte) 0x21);
	        bsr.Put((byte) 0x23);
	        bsr.Put((byte) 0x22);
	        bsr.Put((byte) 0x23);
	        bsr.Put((byte) 0x23);
	        bsr.Put((byte) 0x23);
	        bsr.Put((byte) 0x24);
	        bsr.Put((byte) 0x23);
	        bsr.Put((byte) 0x25);
	        bsr.Put((byte) 0x23);
	        bsr.Put((byte) 0x26);
	        bsr.Put((byte) 0x23);
	        bsr.Put((byte) 0x27);
	        bsr.Put((byte) 0x23);
	        bsr.Put((byte) 0x28);
	        bsr.Put((byte) 0x23);
	        bsr.Put((byte) 0x29);
	        bsr.Put((byte) 0x23);
	        bsr.Put((byte) 0x2A);
	        bsr.Put((byte) 0x23);
	        bsr.Put((byte) 0x2B);
	        bsr.Put((byte) 0x0F);
	        bsr.Put((byte) 0x2F);
	        bsr.Put((byte) 0x2A);
	
	        // test from Lotus
	        // Some of the Lotus ISCII code points have been changed or commented
	        // out.
	        us.Put((char) 0x0061);
	        us.Put((char) 0x0915);
	        us.Put((char) 0x000D);
	        us.Put((char) 0x000A);
	        us.Put((char) 0x0996);
	        us.Put((char) 0x0043);
	        us.Put((char) 0x0930);
	        us.Put((char) 0x094D);
	        us.Put((char) 0x200D);
	        us.Put((char) 0x0901);
	        us.Put((char) 0x000D);
	        us.Put((char) 0x000A);
	        us.Put((char) 0x0905);
	        us.Put((char) 0x0985);
	        us.Put((char) 0x0043);
	        us.Put((char) 0x0915);
	        us.Put((char) 0x0921);
	        us.Put((char) 0x002B);
	        us.Put((char) 0x095F);
	        bs.Put((byte) 0x61);
	        bs.Put((byte) 0xB3);
	        bs.Put((byte) 0x0D);
	        bs.Put((byte) 0x0A);
	        bs.Put((byte) 0xEF);
	        bs.Put((byte) 0x42);
	        bs.Put((byte) 0xEF);
	        bs.Put((byte) 0x43);
	        bs.Put((byte) 0xB4);
	        bs.Put((byte) 0x43);
	        bs.Put((byte) 0xEF);
	        bs.Put((byte) 0x42);
	        bs.Put((byte) 0xCF);
	        bs.Put((byte) 0xE8);
	        bs.Put((byte) 0xE9);
	        bs.Put((byte) 0xA1);
	        bs.Put((byte) 0x0D);
	        bs.Put((byte) 0x0A);
	        bs.Put((byte) 0xEF);
	        bs.Put((byte) 0x42);
	        bs.Put((byte) 0xA4);
	        bs.Put((byte) 0xEF);
	        bs.Put((byte) 0x43);
	        bs.Put((byte) 0xA4);
	        bs.Put((byte) 0x43);
	        bs.Put((byte) 0xEF);
	        bs.Put((byte) 0x42);
	        bs.Put((byte) 0xB3);
	        bs.Put((byte) 0xBF);
	        bs.Put((byte) 0x2B);
	        bs.Put((byte) 0xCE);
	        bsr.Put((byte) 0x61);
	        bsr.Put((byte) 0xEF);
	        bsr.Put((byte) 0x42);
	        bsr.Put((byte) 0xEF);
	        bsr.Put((byte) 0x30);
	        bsr.Put((byte) 0xB3);
	        bsr.Put((byte) 0x0D);
	        bsr.Put((byte) 0x0A);
	        bsr.Put((byte) 0xEF);
	        bsr.Put((byte) 0x43);
	        bsr.Put((byte) 0xB4);
	        bsr.Put((byte) 0x43);
	        bsr.Put((byte) 0xEF);
	        bsr.Put((byte) 0x42);
	        bsr.Put((byte) 0xCF);
	        bsr.Put((byte) 0xE8);
	        bsr.Put((byte) 0xD9);
	        bsr.Put((byte) 0xEF);
	        bsr.Put((byte) 0x42);
	        bsr.Put((byte) 0xA1);
	        bsr.Put((byte) 0x0D);
	        bsr.Put((byte) 0x0A);
	        bsr.Put((byte) 0xEF);
	        bsr.Put((byte) 0x42);
	        bsr.Put((byte) 0xA4);
	        bsr.Put((byte) 0xEF);
	        bsr.Put((byte) 0x43);
	        bsr.Put((byte) 0xA4);
	        bsr.Put((byte) 0x43);
	        bsr.Put((byte) 0xEF);
	        bsr.Put((byte) 0x42);
	        bsr.Put((byte) 0xB3);
	        bsr.Put((byte) 0xBF);
	        bsr.Put((byte) 0x2B);
	        bsr.Put((byte) 0xEF);
	        bsr.Put((byte) 0x42);
	        bsr.Put((byte) 0xCE);
	        // end of test from Lotus
	
	        // tamil range
	        us.Put((char) 0x0B86);
	        us.Put((char) 0x0B87);
	        us.Put((char) 0x0B88);
	        bs.Put((byte) 0xEF);
	        bs.Put((byte) 0x44);
	        bs.Put((byte) 0xA5);
	        bs.Put((byte) 0xA6);
	        bs.Put((byte) 0xA7);
	        bsr.Put((byte) 0xEF);
	        bsr.Put((byte) 0x44);
	        bsr.Put((byte) 0xA5);
	        bsr.Put((byte) 0xA6);
	        bsr.Put((byte) 0xA7);
	
	        // telugu range
	        us.Put((char) 0x0C05);
	        us.Put((char) 0x0C02);
	        us.Put((char) 0x0C03);
	        us.Put((char) 0x0C31);
	        bs.Put((byte) 0xEF);
	        bs.Put((byte) 0x45);
	        bs.Put((byte) 0xA4);
	        bs.Put((byte) 0xA2);
	        bs.Put((byte) 0xA3);
	        bs.Put((byte) 0xD0);
	        bsr.Put((byte) 0xEF);
	        bsr.Put((byte) 0x45);
	        bsr.Put((byte) 0xA4);
	        bsr.Put((byte) 0xA2);
	        bsr.Put((byte) 0xA3);
	        bsr.Put((byte) 0xD0);
	
	        // kannada range
	        us.Put((char) 0x0C85);
	        us.Put((char) 0x0C82);
	        us.Put((char) 0x0C83);
	        bs.Put((byte) 0xEF);
	        bs.Put((byte) 0x48);
	        bs.Put((byte) 0xA4);
	        bs.Put((byte) 0xA2);
	        bs.Put((byte) 0xA3);
	        bsr.Put((byte) 0xEF);
	        bsr.Put((byte) 0x48);
	        bsr.Put((byte) 0xA4);
	        bsr.Put((byte) 0xA2);
	        bsr.Put((byte) 0xA3);
	
	        // test Abbr sign and Anudatta
	        us.Put((char) 0x0970);
	        us.Put((char) 0x0952);
	        us.Put((char) 0x0960);
	        us.Put((char) 0x0944);
	        us.Put((char) 0x090C);
	        us.Put((char) 0x0962);
	        us.Put((char) 0x0961);
	        us.Put((char) 0x0963);
	        us.Put((char) 0x0950);
	        us.Put((char) 0x093D);
	        us.Put((char) 0x0958);
	        us.Put((char) 0x0959);
	        us.Put((char) 0x095A);
	        us.Put((char) 0x095B);
	        us.Put((char) 0x095C);
	        us.Put((char) 0x095D);
	        us.Put((char) 0x095E);
	        us.Put((char) 0x0020);
	        us.Put((char) 0x094D);
	        us.Put((char) 0x0930);
	        us.Put((char) 0x0000);
	        us.Put((char) 0x00A0);
	        bs.Put((byte) 0xEF);
	        bs.Put((byte) 0x42);
	        bs.Put((byte) 0xF0);
	        bs.Put((byte) 0xBF);
	        bs.Put((byte) 0xF0);
	        bs.Put((byte) 0xB8);
	        bs.Put((byte) 0xAA);
	        bs.Put((byte) 0xE9);
	        bs.Put((byte) 0xDF);
	        bs.Put((byte) 0xE9);
	        bs.Put((byte) 0xA6);
	        bs.Put((byte) 0xE9);
	        bs.Put((byte) 0xDB);
	        bs.Put((byte) 0xE9);
	        bs.Put((byte) 0xA7);
	        bs.Put((byte) 0xE9);
	        bs.Put((byte) 0xDC);
	        bs.Put((byte) 0xE9);
	        bs.Put((byte) 0xA1);
	        bs.Put((byte) 0xE9);
	        bs.Put((byte) 0xEA);
	        bs.Put((byte) 0xE9);
	        bs.Put((byte) 0xB3);
	        bs.Put((byte) 0xE9);
	        bs.Put((byte) 0xB4);
	        bs.Put((byte) 0xE9);
	        bs.Put((byte) 0xB5);
	        bs.Put((byte) 0xE9);
	        bs.Put((byte) 0xBA);
	        bs.Put((byte) 0xE9);
	        bs.Put((byte) 0xBF);
	        bs.Put((byte) 0xE9);
	        bs.Put((byte) 0xC0);
	        bs.Put((byte) 0xE9);
	        bs.Put((byte) 0xC9);
	        bs.Put((byte) 0xE9);
	        bs.Put((byte) 0x20);
	        bs.Put((byte) 0xE8);
	        bs.Put((byte) 0xCF);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0xA0);
	        // bs.put((byte)0xEF); bs.put((byte)0x30);
	        bsr.Put((byte) 0xEF);
	        bsr.Put((byte) 0x42);
	        bsr.Put((byte) 0xF0);
	        bsr.Put((byte) 0xBF);
	        bsr.Put((byte) 0xF0);
	        bsr.Put((byte) 0xB8);
	        bsr.Put((byte) 0xAA);
	        bsr.Put((byte) 0xE9);
	        bsr.Put((byte) 0xDF);
	        bsr.Put((byte) 0xE9);
	        bsr.Put((byte) 0xA6);
	        bsr.Put((byte) 0xE9);
	        bsr.Put((byte) 0xDB);
	        bsr.Put((byte) 0xE9);
	        bsr.Put((byte) 0xA7);
	        bsr.Put((byte) 0xE9);
	        bsr.Put((byte) 0xDC);
	        bsr.Put((byte) 0xE9);
	        bsr.Put((byte) 0xA1);
	        bsr.Put((byte) 0xE9);
	        bsr.Put((byte) 0xEA);
	        bsr.Put((byte) 0xE9);
	        bsr.Put((byte) 0xB3);
	        bsr.Put((byte) 0xE9);
	        bsr.Put((byte) 0xB4);
	        bsr.Put((byte) 0xE9);
	        bsr.Put((byte) 0xB5);
	        bsr.Put((byte) 0xE9);
	        bsr.Put((byte) 0xBA);
	        bsr.Put((byte) 0xE9);
	        bsr.Put((byte) 0xBF);
	        bsr.Put((byte) 0xE9);
	        bsr.Put((byte) 0xC0);
	        bsr.Put((byte) 0xE9);
	        bsr.Put((byte) 0xC9);
	        bsr.Put((byte) 0xE9);
	        bsr.Put((byte) 0xD9);
	        bsr.Put((byte) 0xE8);
	        bsr.Put((byte) 0xCF);
	        bsr.Put((byte) 0x00);
	        bsr.Put((byte) 0xA0);
	
	        bs.Limit(bs.Position());
	        bs.Position(0);
	        us.Limit(us.Position());
	        us.Position(0);
	        bsr.Limit(bsr.Position());
	        bsr.Position(0);
	
	        // round trip test
	        try {
	            SmBufDecode(decoder, "ISCII-part1", bsr, us, false, true);
	            SmBufEncode(encoder, "ISCII-part2", us, bs);
	            SmBufDecode(decoder, "ISCII-part3", bs, us, false, true);
	        } catch (Exception ex) {
	            Errln("ISCII round trip test failed.");
	        }
	
	        // Test new characters in the ISCII charset
	        encoder = provider.CharsetForName("ISCII,version=0").GetEncoder();
	        decoder = provider.CharsetForName("ISCII,version=0").GetDecoder();
	        char[] u_pts = { (char) 0x0904, (char) 0x0A01, (char) 0x0A03,
	                (char) 0x0A33, (char) 0x0A70 };
	        byte[] b_pts = { (byte) 0xef, (byte) 0x42, (byte) 0xa4, (byte) 0xe0,
	                (byte) 0xef, (byte) 0x4b, (byte) 0xa1, (byte) 0xa3,
	                (byte) 0xd2, (byte) 0xf0, (byte) 0xbf };
	        us = ILOG.J2CsMapping.NIO.CharBuffer.Allocate(u_pts.Length);
	        bs = ILOG.J2CsMapping.NIO.ByteBuffer.Allocate(b_pts.Length);
	        us.Put(u_pts);
	        bs.Put(b_pts);
	
	        bs.Limit(bs.Position());
	        bs.Position(0);
	        us.Limit(us.Position());
	        us.Position(0);
	
	        try {
	            SmBufDecode(decoder, "ISCII-update", bs, us, true, true);
	            bs.Position(0);
	            us.Position(0);
	            SmBufEncode(encoder, "ISCII-update", us, bs, true, true);
	        } catch (Exception ex_0) {
	            Errln("Error occurred while encoding/decoding ISCII with the new characters.");
	        }
	
	        // The rest of the code in this method is to provide better code
	        // coverage
	        CharBuffer ccus = ILOG.J2CsMapping.NIO.CharBuffer.Allocate(0x10);
	        ByteBuffer ccbs = ILOG.J2CsMapping.NIO.ByteBuffer.Allocate(0x10);
	
	        // start of charset decoder code coverage code
	        // test overflow buffer
	        ccbs.Put((byte) 0x49);
	
	        ccbs.Limit(ccbs.Position());
	        ccbs.Position(0);
	        ccus.Limit(0);
	        ccus.Position(0);
	
	        try {
	            SmBufDecode(decoder, "ISCII-CC-DE-1", ccbs, ccus, true, false);
	            Errln("Exception while decoding ISCII should have been thrown.");
	        } catch (Exception ex_1) {
	        }
	
	        ccbs.Clear();
	        ccus.Clear();
	
	        // test atr overflow buffer
	        ccbs.Put((byte) 0xEF);
	        ccbs.Put((byte) 0x40);
	        ccbs.Put((byte) 0xEF);
	        ccbs.Put((byte) 0x20);
	        ccus.Put((char) 0x00);
	
	        ccbs.Limit(ccbs.Position());
	        ccbs.Position(0);
	        ccus.Limit(ccus.Position());
	        ccus.Position(0);
	
	        try {
	            SmBufDecode(decoder, "ISCII-CC-DE-2", ccbs, ccus, true, false);
	            Errln("Exception while decoding ISCII should have been thrown.");
	        } catch (Exception ex_2) {
	        }
	
	        // end of charset decoder code coverage code
	
	        ccbs.Clear();
	        ccus.Clear();
	
	        // start of charset encoder code coverage code
	        // test ascii overflow buffer
	        ccus.Put((char) 0x41);
	
	        ccus.Limit(ccus.Position());
	        ccus.Position(0);
	        ccbs.Limit(0);
	        ccbs.Position(0);
	
	        try {
	            SmBufEncode(encoder, "ISCII-CC-EN-1", ccus, ccbs, true, false);
	            Errln("Exception while encoding ISCII should have been thrown.");
	        } catch (Exception ex_3) {
	        }
	
	        ccbs.Clear();
	        ccus.Clear();
	
	        // test ascii overflow buffer
	        ccus.Put((char) 0x0A);
	        ccbs.Put((byte) 0x00);
	
	        ccus.Limit(ccus.Position());
	        ccus.Position(0);
	        ccbs.Limit(ccbs.Position());
	        ccbs.Position(0);
	
	        try {
	            SmBufEncode(encoder, "ISCII-CC-EN-2", ccus, ccbs, true, false);
	            Errln("Exception while encoding ISCII should have been thrown.");
	        } catch (Exception ex_4) {
	        }
	
	        ccbs.Clear();
	        ccus.Clear();
	
	        // test surrogate malform
	        ccus.Put((char) 0x06E3);
	        ccbs.Put((byte) 0x00);
	
	        ccus.Limit(ccus.Position());
	        ccus.Position(0);
	        ccbs.Limit(ccbs.Position());
	        ccbs.Position(0);
	
	        try {
	            SmBufEncode(encoder, "ISCII-CC-EN-3", ccus, ccbs, true, false);
	            Errln("Exception while encoding ISCII should have been thrown.");
	        } catch (Exception ex_5) {
	        }
	
	        ccbs.Clear();
	        ccus.Clear();
	
	        // test surrogate malform
	        ccus.Put((char) 0xD801);
	        ccus.Put((char) 0xDD01);
	        ccbs.Put((byte) 0x00);
	
	        ccus.Limit(ccus.Position());
	        ccus.Position(0);
	        ccbs.Limit(ccbs.Position());
	        ccbs.Position(0);
	
	        try {
	            SmBufEncode(encoder, "ISCII-CC-EN-4", ccus, ccbs, true, false);
	            Errln("Exception while encoding ISCII should have been thrown.");
	        } catch (Exception ex_6) {
	        }
	
	        ccbs.Clear();
	        ccus.Clear();
	
	        // test trail surrogate malform
	        ccus.Put((char) 0xDD01);
	        ccbs.Put((byte) 0x00);
	
	        ccus.Limit(ccus.Position());
	        ccus.Position(0);
	        ccbs.Limit(ccbs.Position());
	        ccbs.Position(0);
	
	        try {
	            SmBufEncode(encoder, "ISCII-CC-EN-5", ccus, ccbs, true, false);
	            Errln("Exception while encoding ISCII should have been thrown.");
	        } catch (Exception ex_7) {
	        }
	
	        ccbs.Clear();
	        ccus.Clear();
	
	        // test lead surrogates malform
	        ccus.Put((char) 0xD801);
	        ccus.Put((char) 0xD802);
	        ccbs.Put((byte) 0x00);
	
	        ccus.Limit(ccus.Position());
	        ccus.Position(0);
	        ccbs.Limit(ccbs.Position());
	        ccbs.Position(0);
	
	        try {
	            SmBufEncode(encoder, "ISCII-CC-EN-6", ccus, ccbs, true, false);
	            Errln("Exception while encoding ISCII should have been thrown.");
	        } catch (Exception ex_8) {
	        }
	
	        ccus.Clear();
	        ccbs.Clear();
	
	        // test overflow buffer
	        ccus.Put((char) 0x0901);
	        ccbs.Put((byte) 0x00);
	
	        ccus.Limit(ccus.Position());
	        ccus.Position(0);
	        ccbs.Limit(ccbs.Position());
	        ccbs.Position(0);
	
	        cs = provider.CharsetForName("ISCII,version=0");
	        encoder = cs.GetEncoder();
	
	        try {
	            SmBufEncode(encoder, "ISCII-CC-EN-7", ccus, ccbs, true, false);
	            Errln("Exception while encoding ISCII should have been thrown.");
	        } catch (Exception ex_9) {
	        }
	        // end of charset encoder code coverage code
	    }
	
	    // Test for the IMAP Charset
	    public void TestCharsetIMAP() {
	        CharsetProvider provider = new CharsetProviderICU();
	        Encoding cs = provider.CharsetForName("IMAP-mailbox-name");
	        Encoder encoder = cs.GetEncoder();
	        Decoder decoder = cs.GetDecoder();
	
	        CharBuffer us = ILOG.J2CsMapping.NIO.CharBuffer.Allocate(0x20);
	        ByteBuffer bs = ILOG.J2CsMapping.NIO.ByteBuffer.Allocate(0x20);
	
	        us.Put((char) 0x00A3);
	        us.Put((char) 0x2020);
	        us.Put((char) 0x41);
	
	        bs.Put((byte) 0x26);
	        bs.Put((byte) 0x41);
	        bs.Put((byte) 0x4B);
	        bs.Put((byte) 0x4D);
	        bs.Put((byte) 0x67);
	        bs.Put((byte) 0x49);
	        bs.Put((byte) 0x41);
	        bs.Put((byte) 0x2D);
	        bs.Put((byte) 0x41);
	
	        bs.Limit(bs.Position());
	        bs.Position(0);
	        us.Limit(us.Position());
	        us.Position(0);
	
	        SmBufDecode(decoder, "IMAP", bs, us);
	        SmBufEncode(encoder, "IMAP", us, bs);
	
	        // the rest of the code in this method is for better code coverage
	        us.Clear();
	        bs.Clear();
	
	        // start of charset encoder code coverage
	        // test buffer overflow
	        us.Put((char) 0x0026);
	        us.Put((char) 0x17A9);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	
	        bs.Limit(bs.Position());
	        bs.Position(0);
	        us.Limit(us.Position());
	        us.Position(0);
	
	        try {
	            SmBufEncode(encoder, "IMAP-EN-1", us, bs, true, false);
	            Errln("Exception while encoding IMAP (1) should have been thrown.");
	        } catch (Exception ex) {
	        }
	
	        us.Clear();
	        bs.Clear();
	
	        // test buffer overflow
	        us.Put((char) 0x17A9);
	        us.Put((char) 0x0941);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	
	        bs.Limit(bs.Position());
	        bs.Position(0);
	        us.Limit(us.Position());
	        us.Position(0);
	
	        try {
	            SmBufEncode(encoder, "IMAP-EN-2", us, bs, true, false);
	            Errln("Exception while encoding IMAP (2) should have been thrown.");
	        } catch (Exception ex_0) {
	        }
	
	        us.Clear();
	        bs.Clear();
	
	        // test buffer overflow
	        us.Put((char) 0x17A9);
	        us.Put((char) 0x0941);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	
	        bs.Limit(bs.Position());
	        bs.Position(0);
	        us.Limit(us.Position());
	        us.Position(0);
	
	        try {
	            SmBufEncode(encoder, "IMAP-EN-3", us, bs, true, false);
	            Errln("Exception while encoding IMAP (3) should have been thrown.");
	        } catch (Exception ex_1) {
	        }
	
	        us.Clear();
	        bs.Clear();
	
	        // test buffer overflow
	        us.Put((char) 0x17A9);
	        us.Put((char) 0x0941);
	        us.Put((char) 0x0955);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	
	        bs.Limit(bs.Position());
	        bs.Position(0);
	        us.Limit(us.Position());
	        us.Position(0);
	
	        try {
	            SmBufEncode(encoder, "IMAP-EN-4", us, bs, true, false);
	            Errln("Exception while encoding IMAP (4) should have been thrown.");
	        } catch (Exception ex_2) {
	        }
	
	        us.Clear();
	        bs.Clear();
	
	        // test buffer overflow
	        us.Put((char) 0x17A9);
	        us.Put((char) 0x0941);
	        us.Put((char) 0x0955);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	
	        bs.Limit(bs.Position());
	        bs.Position(0);
	        us.Limit(us.Position());
	        us.Position(0);
	
	        try {
	            SmBufEncode(encoder, "IMAP-EN-5", us, bs, true, false);
	            Errln("Exception while encoding IMAP (5) should have been thrown.");
	        } catch (Exception ex_3) {
	        }
	
	        us.Clear();
	        bs.Clear();
	
	        // test buffer overflow
	        us.Put((char) 0x17A9);
	        us.Put((char) 0x0941);
	        us.Put((char) 0x0955);
	        us.Put((char) 0x0970);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	
	        bs.Limit(bs.Position());
	        bs.Position(0);
	        us.Limit(us.Position());
	        us.Position(0);
	
	        try {
	            SmBufEncode(encoder, "IMAP-EN-6", us, bs, true, false);
	            Errln("Exception while encoding IMAP (6) should have been thrown.");
	        } catch (Exception ex_4) {
	        }
	
	        us.Clear();
	        bs.Clear();
	
	        // test buffer overflow
	        us.Put((char) 0x17A9);
	        us.Put((char) 0x0941);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	
	        bs.Limit(bs.Position());
	        bs.Position(0);
	        us.Limit(us.Position());
	        us.Position(0);
	
	        try {
	            SmBufEncode(encoder, "IMAP-EN-7", us, bs, true, true);
	            Errln("Exception while encoding IMAP (7) should have been thrown.");
	        } catch (Exception ex_5) {
	        }
	
	        us.Clear();
	        bs.Clear();
	
	        // test flushing
	        us.Put((char) 0x17A9);
	        us.Put((char) 0x0941);
	        bs.Put((byte) 0x26);
	        bs.Put((byte) 0x46);
	        bs.Put((byte) 0x36);
	        bs.Put((byte) 0x6b);
	        bs.Put((byte) 0x4a);
	        bs.Put((byte) 0x51);
	        bs.Put((byte) 0x51);
	        bs.Put((byte) 0x2d);
	
	        bs.Limit(bs.Position());
	        bs.Position(0);
	        us.Limit(us.Position());
	        us.Position(0);
	
	        try {
	            SmBufEncode(encoder, "IMAP-EN-8", us, bs, true, true);
	        } catch (Exception ex_6) {
	            Errln("Exception while encoding IMAP (8) should not have been thrown.");
	        }
	
	        us = ILOG.J2CsMapping.NIO.CharBuffer.Allocate(0x08);
	        bs = ILOG.J2CsMapping.NIO.ByteBuffer.Allocate(0x08);
	
	        // test flushing buffer overflow
	        us.Put((char) 0x0061);
	        bs.Put((byte) 0x61);
	        bs.Put((byte) 0x00);
	
	        bs.Limit(bs.Position());
	        bs.Position(0);
	        us.Limit(us.Position());
	        us.Position(0);
	
	        try {
	            SmBufEncode(encoder, "IMAP-EN-9", us, bs, true, true);
	        } catch (Exception ex_7) {
	            Errln("Exception while encoding IMAP (9) should not have been thrown.");
	        }
	        // end of charset encoder code coverage
	
	        us = ILOG.J2CsMapping.NIO.CharBuffer.Allocate(0x10);
	        bs = ILOG.J2CsMapping.NIO.ByteBuffer.Allocate(0x10);
	
	        // start of charset decoder code coverage
	        // test malform case 2
	        us.Put((char) 0x0000);
	        us.Put((char) 0x0000);
	        bs.Put((byte) 0x26);
	        bs.Put((byte) 0x41);
	        bs.Put((byte) 0x43);
	        bs.Put((byte) 0x41);
	
	        bs.Limit(bs.Position());
	        bs.Position(0);
	        us.Limit(us.Position());
	        us.Position(0);
	
	        try {
	            SmBufDecode(decoder, "IMAP-DE-1", bs, us, true, false);
	            Errln("Exception while decoding IMAP (1) should have been thrown.");
	        } catch (Exception ex_8) {
	        }
	
	        us.Clear();
	        bs.Clear();
	
	        // test malform case 5
	        us.Put((char) 0x0000);
	        us.Put((char) 0x0000);
	        us.Put((char) 0x0000);
	        bs.Put((byte) 0x26);
	        bs.Put((byte) 0x41);
	        bs.Put((byte) 0x41);
	        bs.Put((byte) 0x41);
	        bs.Put((byte) 0x41);
	        bs.Put((byte) 0x49);
	        bs.Put((byte) 0x41);
	
	        bs.Limit(bs.Position());
	        bs.Position(0);
	        us.Limit(us.Position());
	        us.Position(0);
	
	        try {
	            SmBufDecode(decoder, "IMAP-DE-2", bs, us, true, false);
	            Errln("Exception while decoding IMAP (2) should have been thrown.");
	        } catch (Exception ex_9) {
	        }
	
	        us.Clear();
	        bs.Clear();
	
	        // test malform case 7
	        us.Put((char) 0x0000);
	        us.Put((char) 0x0000);
	        us.Put((char) 0x0000);
	        us.Put((char) 0x0000);
	        bs.Put((byte) 0x26);
	        bs.Put((byte) 0x41);
	        bs.Put((byte) 0x41);
	        bs.Put((byte) 0x41);
	        bs.Put((byte) 0x41);
	        bs.Put((byte) 0x41);
	        bs.Put((byte) 0x41);
	        bs.Put((byte) 0x42);
	        bs.Put((byte) 0x41);
	
	        bs.Limit(bs.Position());
	        bs.Position(0);
	        us.Limit(us.Position());
	        us.Position(0);
	
	        try {
	            SmBufDecode(decoder, "IMAP-DE-3", bs, us, true, false);
	            Errln("Exception while decoding IMAP (3) should have been thrown.");
	        } catch (Exception ex_10) {
	        }
	        // end of charset decoder coder coverage
	    }
	
	    // Test for charset UTF32LE to provide better code coverage
	    public void TestCharsetUTF32LE() {
	        CoderResult result = ILOG.J2CsMapping.NIO.Charset.CoderResult.UNDERFLOW;
	        CharsetProvider provider = new CharsetProviderICU();
	        Encoding cs = provider.CharsetForName("UTF-32LE");
	        Encoder encoder = cs.GetEncoder();
	        // CharsetDecoder decoder = cs.newDecoder();
	
	        CharBuffer us = ILOG.J2CsMapping.NIO.CharBuffer.Allocate(0x10);
	        ByteBuffer bs = ILOG.J2CsMapping.NIO.ByteBuffer.Allocate(0x10);
	
	        // test malform surrogate
	        us.Put((char) 0xD901);
	        bs.Put((byte) 0x00);
	
	        bs.Limit(bs.Position());
	        bs.Position(0);
	        us.Limit(us.Position());
	        us.Position(0);
	
	        try {
	            SmBufEncode(encoder, "UTF32LE-EN-1", us, bs, true, false);
	            Errln("Exception while encoding UTF32LE (1) should have been thrown.");
	        } catch (Exception ex) {
	        }
	
	        bs.Clear();
	        us.Clear();
	
	        // test malform surrogate
	        us.Put((char) 0xD901);
	        us.Put((char) 0xD902);
	        bs.Put((byte) 0x00);
	
	        bs.Limit(bs.Position());
	        bs.Position(0);
	        us.Limit(us.Position());
	        us.Position(0);
	
	        result = encoder.Encode(us, bs, true);
	
	        if (!result.IsError() && !result.IsOverflow()) {
	            Errln("Error while encoding UTF32LE (2) should have occurred.");
	        }
	
	        bs.Clear();
	        us.Clear();
	
	        // test overflow trail surrogate
	        us.Put((char) 0xDD01);
	        us.Put((char) 0xDD0E);
	        us.Put((char) 0xDD0E);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	
	        bs.Limit(bs.Position());
	        bs.Position(0);
	        us.Limit(us.Position());
	        us.Position(0);
	
	        result = encoder.Encode(us, bs, true);
	
	        if (!result.IsError() && !result.IsOverflow()) {
	            Errln("Error while encoding UTF32LE (3) should have occurred.");
	        }
	
	        bs.Clear();
	        us.Clear();
	
	        // test malform lead surrogate
	        us.Put((char) 0xD90D);
	        us.Put((char) 0xD90E);
	        bs.Put((byte) 0x00);
	
	        bs.Limit(bs.Position());
	        bs.Position(0);
	        us.Limit(us.Position());
	        us.Position(0);
	
	        try {
	            SmBufEncode(encoder, "UTF32LE-EN-4", us, bs, true, false);
	            Errln("Exception while encoding UTF32LE (4) should have been thrown.");
	        } catch (Exception ex_0) {
	        }
	
	        bs.Clear();
	        us.Clear();
	
	        // test overflow buffer
	        us.Put((char) 0x0061);
	        bs.Put((byte) 0x00);
	
	        bs.Limit(bs.Position());
	        bs.Position(0);
	        us.Limit(us.Position());
	        us.Position(0);
	
	        try {
	            SmBufEncode(encoder, "UTF32LE-EN-5", us, bs, true, false);
	            Errln("Exception while encoding UTF32LE (5) should have been thrown.");
	        } catch (Exception ex_1) {
	        }
	
	        bs.Clear();
	        us.Clear();
	
	        // test malform trail surrogate
	        us.Put((char) 0xDD01);
	        bs.Put((byte) 0x00);
	
	        bs.Limit(bs.Position());
	        bs.Position(0);
	        us.Limit(us.Position());
	        us.Position(0);
	
	        try {
	            SmBufEncode(encoder, "UTF32LE-EN-6", us, bs, true, false);
	            Errln("Exception while encoding UTF32LE (6) should have been thrown.");
	        } catch (Exception ex_2) {
	        }
	    }
	
	    // Test for charset UTF16LE to provide better code coverage
	    public void TestCharsetUTF16LE() {
	        CoderResult result = ILOG.J2CsMapping.NIO.Charset.CoderResult.UNDERFLOW;
	        CharsetProvider provider = new CharsetProviderICU();
	        Encoding cs = provider.CharsetForName("UTF-16LE");
	        Encoder encoder = cs.GetEncoder();
	        // CharsetDecoder decoder = cs.newDecoder();
	
	        char[] u_pts1 = { (char) 0xD805, (char) 0xDC01, (char) 0xDC02,
	                (char) 0xDC03, (char) 0xD901, (char) 0xD902 };
	        byte[] b_pts1 = { (byte) 0x00, (byte) 0x00, (byte) 0x00, (byte) 0x00,
	                (byte) 0x00, (byte) 0x00, (byte) 0x00 };
	
	        CharBuffer us = ILOG.J2CsMapping.NIO.CharBuffer.Allocate(u_pts1.Length);
	        ByteBuffer bs = ILOG.J2CsMapping.NIO.ByteBuffer.Allocate(b_pts1.Length);
	
	        us.Put(u_pts1);
	        bs.Put(b_pts1);
	
	        us.Limit(1);
	        us.Position(0);
	        bs.Limit(1);
	        bs.Position(0);
	
	        result = encoder.Encode(us, bs, true);
	
	        if (!result.IsMalformed()) {
	            Errln("Error while encoding UTF-16LE (1) should have occured.");
	        }
	
	        // Test for malform surrogate from previous buffer
	        us.Limit(4);
	        us.Position(1);
	        bs.Limit(7);
	        bs.Position(1);
	
	        result = encoder.Encode(us, bs, true);
	
	        if (!result.IsMalformed()) {
	            Errln("Error while encoding UTF-16LE (2) should have occured.");
	        }
	
	        // Test for malform trail surrogate
	        encoder.Reset();
	
	        us.Limit(1);
	        us.Position(0);
	        bs.Limit(1);
	        bs.Position(0);
	
	        result = encoder.Encode(us, bs, true);
	
	        us.Limit(6);
	        us.Position(4);
	        bs.Limit(4);
	        bs.Position(1);
	
	        result = encoder.Encode(us, bs, true);
	
	        if (!result.IsMalformed()) {
	            Errln("Error while encoding UTF-16LE (3) should have occured.");
	        }
	    }
	
	    // provide better code coverage for the generic charset UTF32
	    public void TestCharsetUTF32() {
	        CoderResult result = ILOG.J2CsMapping.NIO.Charset.CoderResult.UNDERFLOW;
	        CharsetProvider provider = new CharsetProviderICU();
	        Encoding cs = provider.CharsetForName("UTF-32");
	        Decoder decoder = cs.GetDecoder();
	        Encoder encoder = cs.GetEncoder();
	
	        char[] us_array = { 0x0000, 0x0000, 0x0000, 0x0000 };
	
	        byte[] bs_array1 = { (byte) 0x00, (byte) 0x00, (byte) 0xFE,
	                (byte) 0xFF, (byte) 0x00, (byte) 0x00, (byte) 0x04,
	                (byte) 0x43, (byte) 0xFF, (byte) 0xFE, (byte) 0x00,
	                (byte) 0x00, (byte) 0x43, (byte) 0x04, (byte) 0x00, (byte) 0x00 };
	
	        byte[] bs_array2 = { (byte) 0xFF, (byte) 0xFE, (byte) 0x00,
	                (byte) 0x00, (byte) 0x43, (byte) 0x04, (byte) 0x00, (byte) 0x00 };
	
	        CharBuffer us = ILOG.J2CsMapping.NIO.CharBuffer.Allocate(us_array.Length);
	        ByteBuffer bs = ILOG.J2CsMapping.NIO.ByteBuffer.Allocate(bs_array1.Length);
	
	        us.Put(us_array);
	        bs.Put(bs_array1);
	
	        us.Limit(us.Position());
	        us.Position(0);
	        bs.Limit(bs.Position());
	        bs.Position(0);
	
	        try {
	            SmBufDecode(decoder, "UTF32-DE-1", bs, us, true, false);
	            Errln("Malform exception while decoding UTF32 charset (1) should have been thrown.");
	        } catch (Exception ex) {
	        }
	
	        decoder = cs.GetDecoder();
	
	        bs = ILOG.J2CsMapping.NIO.ByteBuffer.Allocate(bs_array2.Length);
	        bs.Put(bs_array2);
	
	        us.Limit(4);
	        us.Position(0);
	        bs.Limit(bs.Position());
	        bs.Position(0);
	
	        try {
	            SmBufDecode(decoder, "UTF32-DE-2", bs, us, true, false);
	            Errln("Malform exception while decoding UTF32 charset (2) should have been thrown.");
	        } catch (Exception ex_0) {
	        }
	
	        // Test malform exception
	        bs.Clear();
	        us.Clear();
	
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0xFE);
	        bs.Put((byte) 0xFF);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        us.Put((char) 0x0000);
	
	        us.Limit(us.Position());
	        us.Position(0);
	        bs.Limit(bs.Position());
	        bs.Position(0);
	
	        try {
	            SmBufDecode(decoder, "UTF32-DE-3", bs, us, true, false);
	            Errln("Malform exception while decoding UTF32 charset (3) should have been thrown.");
	        } catch (Exception ex_1) {
	        }
	
	        // Test BOM testing
	        bs.Clear();
	        us.Clear();
	
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0xFF);
	        bs.Put((byte) 0xFE);
	        us.Put((char) 0x0000);
	
	        us.Limit(us.Position());
	        us.Position(0);
	        bs.Limit(bs.Position());
	        bs.Position(0);
	
	        try {
	            SmBufDecode(decoder, "UTF32-DE-4", bs, us, true, false);
	            Errln("Malform exception while decoding UTF32 charset (4) should have been thrown.");
	        } catch (Exception ex_2) {
	        }
	        // end of decoding code coverage
	
	        // start of encoding code coverage
	        us = ILOG.J2CsMapping.NIO.CharBuffer.Allocate(0x10);
	        bs = ILOG.J2CsMapping.NIO.ByteBuffer.Allocate(0x10);
	
	        // test wite BOM overflow error
	        us.Put((char) 0xDC01);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	
	        us.Limit(us.Position());
	        us.Position(0);
	        bs.Limit(bs.Position());
	        bs.Position(0);
	
	        result = encoder.Encode(us, bs, true);
	        if (!result.IsOverflow()) {
	            Errln("Buffer overflow error while encoding UTF32 charset (1) should have occurred.");
	        }
	
	        us.Clear();
	        bs.Clear();
	
	        // test malform surrogate and store value in fromChar32
	        us.Put((char) 0xD801);
	        us.Put((char) 0xD802);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	
	        us.Limit(us.Position());
	        us.Position(0);
	        bs.Limit(bs.Position());
	        bs.Position(0);
	
	        result = encoder.Encode(us, bs, true);
	        if (!result.IsOverflow()) {
	            Errln("Overflow error while encoding UTF32 charset (2) should have occurred.");
	        }
	
	        us.Clear();
	        bs.Clear();
	
	        // test malform surrogate
	        us.Put((char) 0x0000);
	        us.Put((char) 0xD902);
	        bs.Put((byte) 0x00);
	
	        us.Limit(us.Position());
	        us.Position(0);
	        bs.Limit(bs.Position());
	        bs.Position(0);
	
	        result = encoder.Encode(us, bs, true);
	        if (!result.IsOverflow()) {
	            Errln("Overflow error while encoding UTF32 charset (3) should have occurred.");
	        }
	
	        us.Clear();
	        bs.Clear();
	
	        // test malform surrogate
	        encoder.Reset();
	        us.Put((char) 0xD801);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	
	        us.Limit(us.Position());
	        us.Position(0);
	        bs.Limit(bs.Position());
	        bs.Position(0);
	
	        result = encoder.Encode(us, bs, true);
	        if (!result.IsMalformed()) {
	            Errln("Malform error while encoding UTF32 charset (4) should have occurred.");
	        }
	
	        us.Clear();
	        bs.Clear();
	
	        // test overflow surrogate
	        us.Put((char) 0x0000);
	        us.Put((char) 0xDDE1);
	        us.Put((char) 0xD915);
	        us.Put((char) 0xDDF2);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	
	        us.Limit(us.Position());
	        us.Position(0);
	        bs.Limit(bs.Position());
	        bs.Position(0);
	
	        result = encoder.Encode(us, bs, true);
	        if (!result.IsOverflow()) {
	            Errln("Overflow error while encoding UTF32 charset (5) should have occurred.");
	        }
	
	        us.Clear();
	        bs.Clear();
	
	        // test malform surrogate
	        encoder.Reset();
	        us.Put((char) 0xDDE1);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	
	        us.Limit(us.Position());
	        us.Position(0);
	        bs.Limit(bs.Position());
	        bs.Position(0);
	
	        result = encoder.Encode(us, bs, true);
	        if (!result.IsMalformed()) {
	            Errln("Malform error while encoding UTF32 charset (6) should have occurred.");
	        }
	        // end of encoding code coverage
	    }
	
	    // this method provides better code coverage decoding UTF32 LE/BE
	    public void TestDecodeUTF32LEBE() {
	        CharsetProvider provider = new CharsetProviderICU();
	        Decoder decoder;
	        CharBuffer us = ILOG.J2CsMapping.NIO.CharBuffer.Allocate(0x10);
	        ByteBuffer bs = ILOG.J2CsMapping.NIO.ByteBuffer.Allocate(0x10);
	
	        // decode UTF32LE
	        decoder = provider.CharsetForName("UTF-32LE").GetDecoder();
	        // test overflow buffer
	        bs.Put((byte) 0x41);
	        bs.Put((byte) 0xFF);
	        bs.Put((byte) 0x01);
	        bs.Put((byte) 0x00);
	        us.Put((char) 0x0000);
	
	        us.Limit(us.Position());
	        us.Position(0);
	        bs.Limit(bs.Position());
	        bs.Position(0);
	
	        try {
	            SmBufDecode(decoder, "UTF-32LE", bs, us, true, false);
	            Errln("Overflow exception while decoding UTF32LE (1) should have been thrown.");
	        } catch (Exception ex) {
	        }
	
	        us.Clear();
	        bs.Clear();
	        // test malform buffer
	        bs.Put((byte) 0x02);
	        bs.Put((byte) 0xD9);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        us.Put((char) 0x0000);
	
	        us.Limit(us.Position());
	        us.Position(0);
	        bs.Limit(bs.Position());
	        bs.Position(0);
	
	        try {
	            SmBufDecode(decoder, "UTF-32LE", bs, us, true, false);
	            Errln("Malform exception while decoding UTF32LE (2) should have been thrown.");
	        } catch (Exception ex_0) {
	        }
	
	        us.Clear();
	        bs.Clear();
	        // test malform buffer
	        bs.Put((byte) 0xFF);
	        bs.Put((byte) 0xFE);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0xFF);
	        bs.Put((byte) 0xDF);
	        bs.Put((byte) 0x10);
	        us.Put((char) 0x0000);
	
	        us.Limit(us.Position());
	        us.Position(0);
	        bs.Limit(bs.Position());
	        bs.Position(0);
	
	        try {
	            SmBufDecode(decoder, "UTF-32LE", bs, us, true, false);
	            Errln("Malform exception while decoding UTF32LE (3) should have been thrown.");
	        } catch (Exception ex_1) {
	        }
	
	        us.Clear();
	        bs.Clear();
	        // test malform buffer
	        bs.Put((byte) 0xFF);
	        bs.Put((byte) 0xFE);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x02);
	        bs.Put((byte) 0xD9);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        us.Put((char) 0x0000);
	
	        us.Limit(us.Position());
	        us.Position(0);
	        bs.Limit(bs.Position());
	        bs.Position(0);
	
	        try {
	            SmBufDecode(decoder, "UTF-32LE", bs, us, true, false);
	            Errln("Malform exception while decoding UTF32LE (4) should have been thrown.");
	        } catch (Exception ex_2) {
	        }
	
	        us.Clear();
	        bs.Clear();
	        // test overflow buffer
	        bs.Put((byte) 0xFF);
	        bs.Put((byte) 0xFE);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0xDD);
	        bs.Put((byte) 0xFF);
	        bs.Put((byte) 0x10);
	        bs.Put((byte) 0x00);
	        us.Put((char) 0x0000);
	
	        us.Limit(us.Position());
	        us.Position(0);
	        bs.Limit(bs.Position());
	        bs.Position(0);
	
	        try {
	            SmBufDecode(decoder, "UTF-32LE", bs, us, true, false);
	            Errln("Overflow exception while decoding UTF32LE (5) should have been thrown.");
	        } catch (Exception ex_3) {
	        }
	        // end of decode UTF32LE
	
	        bs.Clear();
	        us.Clear();
	
	        // decode UTF32BE
	        decoder = provider.CharsetForName("UTF-32BE").GetDecoder();
	        // test overflow buffer
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x01);
	        bs.Put((byte) 0xFF);
	        bs.Put((byte) 0x41);
	        us.Put((char) 0x0000);
	
	        us.Limit(us.Position());
	        us.Position(0);
	        bs.Limit(bs.Position());
	        bs.Position(0);
	
	        try {
	            SmBufDecode(decoder, "UTF-32BE", bs, us, true, false);
	            Errln("Overflow exception while decoding UTF32BE (1) should have been thrown.");
	        } catch (Exception ex_4) {
	        }
	
	        bs.Clear();
	        us.Clear();
	        // test malform buffer
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0xD9);
	        bs.Put((byte) 0x02);
	        us.Put((char) 0x0000);
	
	        us.Limit(us.Position());
	        us.Position(0);
	        bs.Limit(bs.Position());
	        bs.Position(0);
	
	        try {
	            SmBufDecode(decoder, "UTF-32BE", bs, us, true, false);
	            Errln("Malform exception while decoding UTF32BE (2) should have been thrown.");
	        } catch (Exception ex_5) {
	        }
	
	        bs.Clear();
	        us.Clear();
	        // test malform buffer
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0xFE);
	        bs.Put((byte) 0xFF);
	        bs.Put((byte) 0x10);
	        bs.Put((byte) 0xFF);
	        bs.Put((byte) 0xDF);
	        us.Put((char) 0x0000);
	
	        us.Limit(us.Position());
	        us.Position(0);
	        bs.Limit(bs.Position());
	        bs.Position(0);
	
	        try {
	            SmBufDecode(decoder, "UTF-32BE", bs, us, true, false);
	            Errln("Malform exception while decoding UTF32BE (3) should have been thrown.");
	        } catch (Exception ex_6) {
	        }
	
	        bs.Clear();
	        us.Clear();
	        // test overflow buffer
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0xFE);
	        bs.Put((byte) 0xFF);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x10);
	        bs.Put((byte) 0xFF);
	        bs.Put((byte) 0xDD);
	        us.Put((char) 0x0000);
	
	        us.Limit(us.Position());
	        us.Position(0);
	        bs.Limit(bs.Position());
	        bs.Position(0);
	
	        try {
	            SmBufDecode(decoder, "UTF-32BE", bs, us, true, false);
	            Errln("Overflow exception while decoding UTF32BE (4) should have been thrown.");
	        } catch (Exception ex_7) {
	        }
	
	        bs.Clear();
	        us.Clear();
	        // test malform buffer
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0xFE);
	        us.Put((char) 0x0000);
	
	        us.Limit(us.Position());
	        us.Position(0);
	        bs.Limit(bs.Position());
	        bs.Position(0);
	
	        try {
	            SmBufDecode(decoder, "UTF-32BE", bs, us, true, false);
	            Errln("Malform exception while decoding UTF32BE (5) should have been thrown.");
	        } catch (Exception ex_8) {
	        }
	        // end of decode UTF32BE
	    }
	
	    // provide better code coverage for UTF8
	    public void TestCharsetUTF8() {
	        CoderResult result = ILOG.J2CsMapping.NIO.Charset.CoderResult.UNDERFLOW;
	        CharsetProvider provider = new CharsetProviderICU();
	        Decoder decoder = provider.CharsetForName("UTF-8").GetDecoder();
	        Encoder encoder = provider.CharsetForName("UTF-8").GetEncoder();
	
	        CharBuffer us = ILOG.J2CsMapping.NIO.CharBuffer.Allocate(0x10);
	        ByteBuffer bs = ILOG.J2CsMapping.NIO.ByteBuffer.Allocate(0x10);
	        ByteBuffer bs2;
	        CharBuffer us2;
	        int limit_us;
	        int limit_bs;
	
	        // encode and decode using read only buffer
	        encoder.Reset();
	        decoder.Reset();
	        us.Put((char) 0x0041);
	        us.Put((char) 0x0081);
	        us.Put((char) 0xEF65);
	        us.Put((char) 0xD902);
	        bs.Put((byte) 0x41);
	        bs.Put((byte) 0xc2);
	        bs.Put((byte) 0x81);
	        bs.Put((byte) 0xee);
	        bs.Put((byte) 0xbd);
	        bs.Put((byte) 0xa5);
	        bs.Put((byte) 0x00);
	        limit_us = us.Position();
	        limit_bs = bs.Position();
	
	        us.Limit(limit_us);
	        us.Position(0);
	        bs.Limit(limit_bs);
	        bs.Position(0);
	        bs2 = bs.AsReadOnlyBuffer();
	        us2 = us.AsReadOnlyBuffer();
	
	        result = decoder.Decode(bs2, us, true);
	        if (!result.IsUnderflow() || !Equals(us, us2)) {
	            Errln("Error while decoding UTF-8 (1) should not have occured.");
	        }
	
	        us2.Limit(limit_us);
	        us2.Position(0);
	        bs.Limit(limit_bs);
	        bs.Position(0);
	
	        result = encoder.Encode(us2, bs, true);
	        if (!result.IsUnderflow() || !Equals(bs, bs2)) {
	            Errln("Error while encoding UTF-8 (1) should not have occured.");
	        }
	
	        us.Clear();
	        bs.Clear();
	
	        // test overflow buffer while encoding
	        // readonly buffer
	        encoder.Reset();
	        us.Put((char) 0x0081);
	        us.Put((char) 0xEF65);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        limit_us = us.Position();
	        us2 = us.AsReadOnlyBuffer();
	        us2.Limit(limit_us);
	        us2.Position(0);
	        bs.Limit(1);
	        bs.Position(0);
	        result = encoder.Encode(us2, bs, true);
	        if (!result.IsOverflow()) {
	            Errln("Overflow Error should have occured while encoding UTF-8 (2).");
	        }
	
	        encoder.Reset();
	
	        us2.Limit(limit_us);
	        us2.Position(1);
	        bs.Limit(1);
	        bs.Position(0);
	        result = encoder.Encode(us2, bs, true);
	        if (!result.IsOverflow()) {
	            Errln("Overflow Error should have occured while encoding UTF-8 (3).");
	        }
	
	        encoder.Reset();
	
	        us2.Limit(limit_us);
	        us2.Position(1);
	        bs.Limit(2);
	        bs.Position(0);
	        result = encoder.Encode(us2, bs, true);
	        if (!result.IsOverflow()) {
	            Errln("Overflow Error should have occured while encoding UTF-8 (4).");
	        }
	
	        encoder.Reset();
	
	        us2.Limit(limit_us);
	        us2.Position(0);
	        bs.Limit(2);
	        bs.Position(0);
	        result = encoder.Encode(us2, bs, true);
	        if (!result.IsOverflow()) {
	            Errln("Overflow Error should have occured while encoding UTF-8 (5).");
	        }
	
	        // not readonly buffer
	        encoder.Reset();
	
	        us.Limit(limit_us);
	        us.Position(0);
	        bs.Limit(1);
	        bs.Position(0);
	        result = encoder.Encode(us, bs, true);
	        if (!result.IsOverflow()) {
	            Errln("Overflow Error should have occured while encoding UTF-8 (6).");
	        }
	
	        encoder.Reset();
	
	        us.Limit(limit_us);
	        us.Position(0);
	        bs.Limit(3);
	        bs.Position(0);
	        result = encoder.Encode(us, bs, true);
	        if (!result.IsOverflow()) {
	            Errln("Overflow Error should have occured while encoding UTF-8 (7).");
	        }
	
	        encoder.Reset();
	
	        us.Limit(limit_us);
	        us.Position(1);
	        bs.Limit(2);
	        bs.Position(0);
	        result = encoder.Encode(us, bs, true);
	        if (!result.IsOverflow()) {
	            Errln("Overflow Error should have occured while encoding UTF-8 (8).");
	        }
	
	        encoder.Reset();
	
	        us.Limit(limit_us + 1);
	        us.Position(1);
	        bs.Limit(3);
	        bs.Position(0);
	        result = encoder.Encode(us, bs, true);
	        if (!result.IsOverflow()) {
	            Errln("Overflow Error should have occured while encoding UTF-8 (9).");
	        }
	
	        us.Clear();
	        bs.Clear();
	
	        // test encoding 4 byte characters
	        encoder.Reset();
	        us.Put((char) 0xD902);
	        us.Put((char) 0xDD02);
	        us.Put((char) 0x0041);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        bs.Put((byte) 0x00);
	        limit_us = us.Position();
	        us2 = us.AsReadOnlyBuffer();
	        us2.Limit(limit_us);
	        us2.Position(0);
	        bs.Limit(1);
	        bs.Position(0);
	        result = encoder.Encode(us2, bs, true);
	        if (!result.IsOverflow()) {
	            Errln("Overflow Error should have occured while encoding UTF-8 (10).");
	        }
	
	        encoder.Reset();
	
	        us2.Limit(limit_us);
	        us2.Position(0);
	        bs.Limit(2);
	        bs.Position(0);
	        result = encoder.Encode(us2, bs, true);
	        if (!result.IsOverflow()) {
	            Errln("Overflow Error should have occured while encoding UTF-8 (11).");
	        }
	
	        encoder.Reset();
	
	        us2.Limit(limit_us);
	        us2.Position(0);
	        bs.Limit(3);
	        bs.Position(0);
	        result = encoder.Encode(us2, bs, true);
	        if (!result.IsOverflow()) {
	            Errln("Overflow Error should have occured while encoding UTF-8 (12).");
	        }
	
	        encoder.Reset();
	
	        us2.Limit(limit_us);
	        us2.Position(0);
	        bs.Limit(4);
	        bs.Position(0);
	        result = encoder.Encode(us2, bs, true);
	        if (!result.IsOverflow()) {
	            Errln("Overflow Error should have occured while encoding UTF-8 (13).");
	        }
	
	        us.Clear();
	        bs.Clear();
	
	        // decoding code coverage
	        // test malform error
	        decoder.Reset();
	        bs.Put((byte) 0xC0);
	        bs.Put((byte) 0xC0);
	        us.Put((char) 0x0000);
	        bs2 = bs.AsReadOnlyBuffer();
	
	        us.Limit(1);
	        us.Position(0);
	        bs2.Limit(1);
	        bs2.Position(0);
	
	        result = decoder.Decode(bs2, us, true);
	        result = decoder.Flush(us);
	        if (!result.IsMalformed()) {
	            Errln("Malform error should have occurred while decoding UTF-8 (1).");
	        }
	
	        us.Limit(1);
	        us.Position(0);
	        bs2.Limit(1);
	        bs2.Position(0);
	
	        decoder.Reset();
	
	        result = decoder.Decode(bs2, us, true);
	        us.Limit(1);
	        us.Position(0);
	        bs2.Limit(2);
	        bs2.Position(0);
	        result = decoder.Decode(bs2, us, true);
	        if (!result.IsMalformed()) {
	            Errln("Malform error should have occurred while decoding UTF-8 (2).");
	        }
	
	        us.Clear();
	        bs.Clear();
	
	        // test overflow buffer
	        bs.Put((byte) 0x01);
	        bs.Put((byte) 0x41);
	        us.Put((char) 0x0000);
	        bs2 = bs.AsReadOnlyBuffer();
	        us.Limit(1);
	        us.Position(0);
	        bs2.Limit(2);
	        bs2.Position(0);
	
	        result = decoder.Decode(bs2, us, true);
	        if (!result.IsOverflow()) {
	            Errln("Overflow error should have occurred while decoding UTF-8 (3).");
	        }
	
	        us.Clear();
	        bs.Clear();
	
	        // test malform string
	        decoder.Reset();
	        bs.Put((byte) 0xF5);
	        bs.Put((byte) 0xB4);
	        bs.Put((byte) 0x8A);
	        bs.Put((byte) 0x8C);
	        us.Put((char) 0x0000);
	        bs2 = bs.AsReadOnlyBuffer();
	        us.Limit(1);
	        us.Position(0);
	        bs2.Limit(4);
	        bs2.Position(0);
	
	        result = decoder.Decode(bs2, us, true);
	        if (!result.IsMalformed()) {
	            Errln("Malform error should have occurred while decoding UTF-8 (4).");
	        }
	
	        bs.Clear();
	
	        // test overflow
	        decoder.Reset();
	        bs.Put((byte) 0xF3);
	        bs.Put((byte) 0xB4);
	        bs.Put((byte) 0x8A);
	        bs.Put((byte) 0x8C);
	        bs2 = bs.AsReadOnlyBuffer();
	        us.Limit(1);
	        us.Position(0);
	        bs2.Limit(4);
	        bs2.Position(0);
	
	        result = decoder.Decode(bs2, us, true);
	        if (!result.IsOverflow()) {
	            Errln("Overflow error should have occurred while decoding UTF-8 (5).");
	        }
	
	        // test overflow
	        decoder.Reset();
	        us.Limit(2);
	        us.Position(0);
	        bs2.Limit(5);
	        bs2.Position(0);
	
	        result = decoder.Decode(bs2, us, true);
	        if (!result.IsOverflow()) {
	            Errln("Overflow error should have occurred while decoding UTF-8 (5).");
	        }
	
	        // test overflow
	        decoder.Reset();
	        us.Limit(1);
	        us.Position(0);
	        bs.Limit(5);
	        bs.Position(0);
	
	        result = decoder.Decode(bs, us, true);
	        if (!result.IsOverflow()) {
	            Errln("Overflow error should have occurred while decoding UTF-8 (6).");
	        }
	
	        bs.Clear();
	
	        // test overflow
	        decoder.Reset();
	        bs.Put((byte) 0x41);
	        bs.Put((byte) 0x42);
	        us.Limit(1);
	        us.Position(0);
	        bs.Limit(2);
	        bs.Position(0);
	
	        result = decoder.Decode(bs, us, true);
	        if (!result.IsOverflow()) {
	            Errln("Overflow error should have occurred while decoding UTF-8 (7).");
	        }
	
	    }
	
	    // provide better code coverage for Charset UTF16
	    public void TestCharsetUTF16() {
	        CoderResult result = ILOG.J2CsMapping.NIO.Charset.CoderResult.UNDERFLOW;
	        CharsetProvider provider = new CharsetProviderICU();
	        Decoder decoder = provider.CharsetForName("UTF-16").GetDecoder();
	        Encoder encoder = provider.CharsetForName("UTF-16").GetEncoder();
	
	        CharBuffer us = ILOG.J2CsMapping.NIO.CharBuffer.Allocate(0x10);
	        ByteBuffer bs = ILOG.J2CsMapping.NIO.ByteBuffer.Allocate(0x10);
	
	        // test flush buffer and malform string
	        bs.Put((byte) 0xFF);
	        us.Put((char) 0x0000);
	
	        us.Limit(us.Position());
	        us.Position(0);
	        bs.Limit(bs.Position());
	        bs.Position(0);
	
	        result = decoder.Decode(bs, us, true);
	        result = decoder.Flush(us);
	        if (!result.IsMalformed()) {
	            Errln("Malform error while decoding UTF-16 should have occurred.");
	        }
	
	        us.Clear();
	        bs.Clear();
	
	        us.Put((char) 0xD902);
	        us.Put((char) 0xDD01);
	        us.Put((char) 0x0041);
	
	        us.Limit(1);
	        us.Position(0);
	        bs.Limit(4);
	        bs.Position(0);
	
	        result = encoder.Encode(us, bs, true);
	        us.Limit(3);
	        us.Position(0);
	        bs.Limit(3);
	        bs.Position(0);
	        result = encoder.Encode(us, bs, true);
	        if (!result.IsOverflow()) {
	            Errln("Overflow buffer while encoding UTF-16 should have occurred.");
	        }
	
	        us.Clear();
	        bs.Clear();
	
	        // test overflow buffer
	        decoder.Reset();
	        decoder = provider.CharsetForName("UTF-16BE").GetDecoder();
	
	        bs.Put((byte) 0xFF);
	        bs.Put((byte) 0xFE);
	        bs.Put((byte) 0x41);
	
	        us.Limit(0);
	        us.Position(0);
	        bs.Limit(3);
	        bs.Position(0);
	
	        result = decoder.Decode(bs, us, true);
	        if (!result.IsOverflow()) {
	            Errln("Overflow buffer while decoding UTF-16 should have occurred.");
	        }
	    }
	}
}
