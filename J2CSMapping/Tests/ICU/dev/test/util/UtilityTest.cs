//##header J2SE15
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/13/10 4:02 PM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /*
 **********************************************************************
 * Copyright (c) 2003-2006, International Business Machines
 * Corporation and others.  All Rights Reserved.
 **********************************************************************
 * Author: Alan Liu
 * Created: March 8 2003
 * Since: ICU 2.6
 **********************************************************************
 */
namespace IBM.ICU.Charset
{

    using IBM.ICU.Impl;
    using IBM.ICU.Text;
    using IBM.ICU.Util;
    using ILOG.J2CsMapping.Collections;
    using ILOG.J2CsMapping.Collections.Generics;
    using ILOG.J2CsMapping.NIO;
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.IO;
    using System.Runtime.CompilerServices;
    using NUnit.Framework;

    /// @test
    /// @summary Test of internal Utility class
    [TestFixture]
    public class UtilityTest : TestFmwk
    {

        public static void Main(String[] args)
        {
            new UtilityTest().Run(args);
        }

        [Test]
        public void TestUnescape()
        {
            String input = "Sch\\u00f6nes Auto: \\u20ac 11240.\\fPrivates Zeichen: \\U00102345\\e\\cC\\n \\x1b\\x{263a}";

            String expect = "Sch\u00F6nes Auto: \u20AC 11240.\u000CPrivates Zeichen: \uDBC8\uDF45\u001B\u0003\012 \u001B\u263A";

            String result = IBM.ICU.Impl.Utility.Unescape(input);
            if (!result.Equals(expect))
            {
                Errln("FAIL: Utility.unescape() returned " + result + ", exp. "
                        + expect);
            }
        }

        [Test]
        public void TestFormat()
        {
            String[] data = { "the quick brown fox jumps over the lazy dog",
	                "testing space , quotations \"",
	                "testing weird supplementary characters \ud800\udc00",
	                "testing control characters \u0001 and line breaking!! \n are we done yet?" };
            String[] result = {
	                "        \"the quick brown fox jumps over the lazy dog\"",
	                "        \"testing space , quotations \\042\"",
	                "        \"testing weird supplementary characters \\uD800\\uDC00\"",
	                "        \"testing control characters \\001 and line breaking!! \\n are we done ye\"+"
	                        + IBM.ICU.Impl.Utility.LINE_SEPARATOR
	                        + "        \"t?\"" };
            String[] result1 = { "\"the quick brown fox jumps over the lazy dog\"",
	                "\"testing space , quotations \\042\"",
	                "\"testing weird supplementary characters \\uD800\\uDC00\"",
	                "\"testing control characters \\001 and line breaking!! \\n are we done yet?\"" };

            for (int i = 0; i < data.Length; i++)
            {
                AssertEquals("formatForSource(\"" + data[i] + "\")", result[i],
                        IBM.ICU.Impl.Utility.FormatForSource(data[i]));
            }
            for (int i_0 = 0; i_0 < data.Length; i_0++)
            {
                AssertEquals("format1ForSource(\"" + data[i_0] + "\")", result1[i_0],
                        IBM.ICU.Impl.Utility.Format1ForSource(data[i_0]));
            }
        }

        [Test]
        public void TestHighBit()
        {
            int[] data = { -1, -1276, 0, 0xFFFF, 0x1234 };
            sbyte[] result = { -1, -1, -1, 15, 12 };
            for (int i = 0; i < data.Length; i++)
            {
                if (IBM.ICU.Impl.Utility.HighBit(data[i]) != result[i])
                {
                    Errln("Fail: Highest bit of \\u" + ILOG.J2CsMapping.Util.IlNumber.ToString(data[i], 16)
                            + " should be " + result[i]);
                }
            }
        }

        [Test]
        public void TestCompareUnsigned()
        {
            int[] data = { 0, 1, -1879048193, -1, Int32.MaxValue,
	                Int32.MinValue, 2342423, -2342423 };
            for (int i = 0; i < data.Length; i++)
            {
                for (int j = 0; j < data.Length; j++)
                {
                    if (IBM.ICU.Impl.Utility.CompareUnsigned(data[i], data[j]) != CompareLongUnsigned(
                            data[i], data[j]))
                    {
                        Errln("Fail: Unsigned comparison failed with " + data[i]
                                + " " + data[i + 1]);
                    }
                }
            }
        }

        // This test indends to test the utility class ByteArrayWrapper
        // Seems that the class is somewhat incomplete, for example
        // - getHashCode(Object) is weird
        // - PatternMatch feature(search part of array within the whole one) lacks
        public void TestByteArrayWrapper()
        {
            /*sbyte[] ba = { 0x00, 0x01, 0x02 };
            sbyte[] bb = { 0x00, 0x01, 0x02, -1 };
            // #if defined(FOUNDATION10) || defined(J2SE13)
            // ## com.ibm.icu.impl.ByteBuffer buffer =
            // com.ibm.icu.impl.ByteBuffer.wrap(ba);
            // #else
            ILOG.J2CsMapping.NIO.ByteBuffer buffer = ILOG.J2CsMapping.NIO.ByteBuffer.Wrap(ba);
            // #endif
            ByteArrayWrapper x = new ByteArrayWrapper(buffer);
	
            ByteArrayWrapper y = new ByteArrayWrapper(ba, 3);
            ByteArrayWrapper z = new ByteArrayWrapper(bb, 3);
	
            if (!y.ToString().Equals("00 01 02")) {
                Errln("FAIL: test toString : Failed!");
            }
	
            // test equality
            if (!x.Equals(y) || !x.Equals(z))
                Errln("FAIL: test (operator ==): Failed!");
            if (x.GetHashCode() != y.GetHashCode())
                Errln("FAIL: identical objects have different hash codes.");
	
            // test non-equality
            y = new ByteArrayWrapper(bb, 4);
            if (x.Equals(y))
                Errln("FAIL: test (operator !=): Failed!");
	
            // test sign of unequal comparison
            if ((x.CompareTo(y) > 0) != (y.CompareTo(x) < 0)) {
                Errln("FAIL: comparisons not opposite sign");
            }*/
        }

        private int CompareLongUnsigned(int x, int y)
        {
            long x1 = x & 0xFFFFFFFFl;
            long y1 = y & 0xFFFFFFFFl;
            if (x1 < y1)
            {
                return -1;
            }
            else if (x1 > y1)
            {
                return 1;
            }
            return 0;
        }

        [Test]
        public void TestUnicodeSet()
        {
            String[] array = new String[] { "a", "b", "c", "{de}" };
            IList list = ILOG.J2CsMapping.Collections.Arrays.AsList(array);
            ILOG.J2CsMapping.Collections.ISet aset = new HashedSet(list);
            Logln(" *** The source set's size is: " + aset.Count);
            // The size reads 4
            UnicodeSet set = new UnicodeSet();
            set.Clear();
            set.AddAll(aset);
            Logln(" *** After addAll, the UnicodeSet size is: " + set.Size());
            // The size should also read 4, but 0 is seen instead

        }

        [Test]
        public void TestAssert()
        {
            try
            {
                IBM.ICU.Impl.Assert.Assrt(false);
                Errln("FAIL: Assert.assrt(false)");
            }
            catch (InvalidOperationException e)
            {
                if (e.Message.Equals("assert failed"))
                {
                    Logln("Assert.assrt(false) works");
                }
                else
                {
                    Errln("FAIL: Assert.assrt(false) returned " + e.Message);
                }
            }
            try
            {
                IBM.ICU.Impl.Assert.Assrt("Assert message", false);
                Errln("FAIL: Assert.assrt(false)");
            }
            catch (InvalidOperationException e_0)
            {
                if (e_0.Message.Equals("assert 'Assert message' failed"))
                {
                    Logln("Assert.assrt(false) works");
                }
                else
                {
                    Errln("FAIL: Assert.assrt(false) returned " + e_0.Message);
                }
            }
            try
            {
                IBM.ICU.Impl.Assert.Fail("Assert message");
                Errln("FAIL: Assert.fail");
            }
            catch (InvalidOperationException e_1)
            {
                if (e_1.Message.Equals("failure 'Assert message'"))
                {
                    Logln("Assert.fail works");
                }
                else
                {
                    Errln("FAIL: Assert.fail returned " + e_1.Message);
                }
            }
            try
            {
                IBM.ICU.Impl.Assert.Fail(new InvalidFormatException());
                Errln("FAIL: Assert.fail with an exception");
            }
            catch (InvalidOperationException e_2)
            {
                Logln("Assert.fail works");
            }
        }

        [Test]
        public void TestCaseInsensitiveString()
        {
            CaseInsensitiveString str1 = new CaseInsensitiveString("ThIs is A tEst");
            CaseInsensitiveString str2 = new CaseInsensitiveString("This IS a test");
            if (!str1.Equals(str2) || !str1.ToString().Equals(str1.GetString())
                    || str1.ToString().Equals(str2.ToString()))
            {
                Errln("FAIL: str1(" + str1 + ") != str2(" + str2 + ")");
            }
        }
    }
}
