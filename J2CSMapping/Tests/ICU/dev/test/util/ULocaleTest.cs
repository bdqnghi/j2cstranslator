/*
 **********************************************************************
 * Copyright (c) 2004-2007, International Business Machines
 * Corporation and others.  All Rights Reserved.
 **********************************************************************
 * Author: Alan Liu
 * Created: January 14 2004
 * Since: ICU 2.8
 **********************************************************************
 */
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/13/10 4:02 PM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
namespace IBM.ICU.Charset
{

    using IBM.ICU.Text;
    using System;
    using IBM.ICU.Util;
    using System.Collections;
    using System.Reflection;
    using System.Security;
    using ILOG.J2CsMapping.Collections;
    using ILOG.J2CsMapping.Util;
    using NUnit.Framework;

    [TestFixture]
    public class ULocaleTest : TestFmwk
    {

        public static void Main(String[] args)
        {
            new ULocaleTest().Run(args);
        }

        [Test]
        public void TestCalendar()
        {
            // TODO The CalendarFactory mechanism is not public,
            // so we can't test it yet. If it becomes public,
            // enable this code.

            // class CFactory : CalendarFactory {
            // Locale loc;
            // Calendar proto;
            // public CFactory(Locale locale, Calendar prototype) {
            // loc = locale;
            // proto = prototype;
            // }
            // public Calendar create(TimeZone tz, Locale locale) {
            // // ignore tz -- not relevant to this test
            // return locale.equals(loc) ?
            // (Calendar) proto.clone() : null;
            // }
            // public String factoryName() {
            // return "CFactory";
            // }
            // };

            CheckService("en_US_BROOKLYN", new ULocaleTest.Anonymous_C9());
        }

        // Currency getLocale API is obsolete in 3.2. Since it now returns
        // ULocale.ROOT,
        // and this is not equal to the requested locale zh_TW_TAIPEI, the
        // checkService call would always fail. So we now omit the test.
        /*
         * public void TestCurrency() { checkService("zh_TW_TAIPEI", new
         * ServiceFacade() { public Object create(ULocale req) { return
         * Currency.getInstance(req); } }, null, new Registrar() { public Object
         * register(ULocale loc, Object prototype) { return
         * Currency.registerInstance((Currency) prototype, loc); } public boolean
         * unregister(Object key) { return Currency.unregister(key); } }); }
         */
        [Test]
        public void TestBreakIterator()
        {
            CheckService("ja_JP_OSAKA", new ULocaleTest.Anonymous_C8(), null, new ULocaleTest.Anonymous_C7());
        }

        [Test]
        public void TestCollator()
        {
            CheckService("ja_JP_YOKOHAMA", new ULocaleTest.Anonymous_C6(), null, new ULocaleTest.Anonymous_C5());
        }

        [Test]
        public void TestDateFormat()
        {
            CheckService("de_CH_ZURICH", new ULocaleTest.Anonymous_C4(), new ULocaleTest.Anonymous_C3(), null);
        }

        [Test]
        public void TestNumberFormat()
        {


            CheckService("fr_FR_NICE", new ULocaleTest.Anonymous_C2(), new ULocaleTest.Anonymous_C1(), new ULocaleTest.Anonymous_C0());
        }

        [Test]
        public void TestSetULocaleKeywords()
        {
            ULocale uloc = new ULocale("en_Latn_US");
            uloc = uloc.SetKeywordValue("Foo", "FooValue");
            if (!"en_Latn_US@foo=FooValue".Equals(uloc.GetName()))
            {
                Errln("failed to add foo keyword, got: " + uloc.GetName());
            }
            uloc = uloc.SetKeywordValue("Bar", "BarValue");
            if (!"en_Latn_US@bar=BarValue;foo=FooValue".Equals(uloc.GetName()))
            {
                Errln("failed to add bar keyword, got: " + uloc.GetName());
            }
            uloc = uloc.SetKeywordValue("BAR", "NewBarValue");
            if (!"en_Latn_US@bar=NewBarValue;foo=FooValue".Equals(uloc.GetName()))
            {
                Errln("failed to change bar keyword, got: " + uloc.GetName());
            }
            uloc = uloc.SetKeywordValue("BaR", null);
            if (!"en_Latn_US@foo=FooValue".Equals(uloc.GetName()))
            {
                Errln("failed to delete bar keyword, got: " + uloc.GetName());
            }
            uloc = uloc.SetKeywordValue(null, null);
            if (!"en_Latn_US".Equals(uloc.GetName()))
            {
                Errln("failed to delete all keywords, got: " + uloc.GetName());
            }
        }

        /*
         * ticket#5060
         */
        [Test]
        public void TestJavaLocaleCompatibility()
        {
            ILOG.J2CsMapping.Util.Locale backupDefault = ILOG.J2CsMapping.Util.Locale.GetDefault();

            // Java Locale for ja_JP with Japanese calendar
            ILOG.J2CsMapping.Util.Locale jaJPJP = new ILOG.J2CsMapping.Util.Locale("ja", "JP", "JP");
            ILOG.J2CsMapping.Util.Locale jaJP = new ILOG.J2CsMapping.Util.Locale("ja", "JP");

            IBM.ICU.Util.Calendar cal = IBM.ICU.Util.Calendar.GetInstance(jaJPJP);
            String caltype = cal.GetType();
            if (!caltype.Equals("japanese"))
            {
                Errln("FAIL: Invalid calendar type: " + caltype
                        + " /expected: japanese");
            }

            cal = IBM.ICU.Util.Calendar.GetInstance(jaJP);
            caltype = cal.GetType();
            if (!caltype.Equals("gregorian"))
            {
                Errln("FAIL: Invalid calendar type: " + caltype
                        + " /expected: gregorian");
            }

            // Default locale
            ILOG.J2CsMapping.Util.Locale.SetDefault(jaJPJP);
            ULocale defUloc = IBM.ICU.Util.ULocale.GetDefault();
            if (!defUloc.ToString().Equals("ja_JP@calendar=japanese"))
            {
                Errln("FAIL: Invalid default ULocale: " + defUloc
                        + " /expected: ja_JP@calendar=japanese");
            }
            // Check calendar type
            cal = IBM.ICU.Util.Calendar.GetInstance();
            caltype = cal.GetType();
            if (!caltype.Equals("japanese"))
            {
                Errln("FAIL: Invalid calendar type: " + caltype
                        + " /expected: japanese");
            }
            ILOG.J2CsMapping.Util.Locale.SetDefault(backupDefault);

            // Set default via ULocale
            IBM.ICU.Util.ULocale.SetDefault(new ULocale("ja_JP@calendar=japanese"));
            if (!System.Globalization.CultureInfo.InvariantCulture.Equals(jaJPJP))
            {
                Errln("FAIL: ULocale#setDefault failed to set Java Locale ja_JP_JP /actual: "
                        + System.Globalization.CultureInfo.InvariantCulture);
            }
            ILOG.J2CsMapping.Util.Locale.SetDefault(backupDefault);

            // We also want to map ICU locale ja@calendar=japanese to Java ja_JP_JP
            IBM.ICU.Util.ULocale.SetDefault(new ULocale("ja@calendar=japanese"));
            if (!System.Globalization.CultureInfo.InvariantCulture.Equals(jaJPJP))
            {
                Errln("FAIL: ULocale#setDefault failed to set Java Locale ja_JP_JP /actual: "
                        + System.Globalization.CultureInfo.InvariantCulture);
            }
            ILOG.J2CsMapping.Util.Locale.SetDefault(backupDefault);

            // Java no_NO_NY
            ILOG.J2CsMapping.Util.Locale noNONY = new ILOG.J2CsMapping.Util.Locale("no", "NO", "NY");
            ILOG.J2CsMapping.Util.Locale.SetDefault(noNONY);
            defUloc = IBM.ICU.Util.ULocale.GetDefault();
            if (defUloc.ToString().Equals("nn_NY"))
            {
                Errln("FAIL: Invalid default ULocale: " + defUloc
                        + " /expected: nn_NY");
            }
            ILOG.J2CsMapping.Util.Locale.SetDefault(backupDefault);

            // Set default via ULocale
            IBM.ICU.Util.ULocale.SetDefault(new ULocale("nn_NO"));
            if (!System.Globalization.CultureInfo.InvariantCulture.Equals(noNONY))
            {
                Errln("FAIL: ULocale#setDefault failed to set Java Locale no_NO_NY /actual: "
                        + System.Globalization.CultureInfo.InvariantCulture);
            }
            ILOG.J2CsMapping.Util.Locale.SetDefault(backupDefault);

            // We also want to map ICU locale nn to Java no_NO_NY
            IBM.ICU.Util.ULocale.SetDefault(new ULocale("nn"));
            if (!System.Globalization.CultureInfo.InvariantCulture.Equals(noNONY))
            {
                Errln("FAIL: ULocale#setDefault failed to set Java Locale no_NO_NY /actual: "
                        + System.Globalization.CultureInfo.InvariantCulture);
            }
            ILOG.J2CsMapping.Util.Locale.SetDefault(backupDefault);
        }

        // ================= Infrastructure =================

        /// <summary>
        /// Compare two locale IDs. If they are equal, return 0. If `string' starts
        /// with `prefix' plus an additional element, that is, string == prefix + '_'
        /// + x, then return 1. Otherwise return a value < 0.
        /// </summary>
        ///
        static internal int Loccmp(String str0, String prefix)
        {
            int slen = str0.Length, plen = prefix.Length;
            /* 'root' is "less than" everything */
            if (prefix.Equals("root"))
            {
                return (str0.Equals("root")) ? 0 : 1;
            }
            // ON JAVA (only -- not on C -- someone correct me if I'm wrong)
            // consider "" to be an alternate name for "root".
            if (plen == 0)
            {
                return (slen == 0) ? 0 : 1;
            }
            if (!str0.StartsWith(prefix))
                return -1; /* mismatch */
            if (slen == plen)
                return 0;
            if (str0[plen] == '_')
                return 1;
            return -2; /* false match, e.g. "en_USX" cmp "en_US" */
        }

        /// <summary>
        /// Check the relationship between requested locales, and report problems.
        /// The caller specifies the expected relationships between requested and
        /// valid (expReqValid) and between valid and actual (expValidActual).
        /// Possible values are: "gt" strictly greater than, e.g., en_US > en "ge"
        /// greater or equal, e.g., en >= en "eq" equal, e.g., en == en
        /// </summary>
        ///
        internal void Checklocs(String label, String req, ILOG.J2CsMapping.Util.Locale validLoc, ILOG.J2CsMapping.Util.Locale actualLoc,
                String expReqValid, String expValidActual)
        {
            String valid = validLoc.ToString();
            String actual = actualLoc.ToString();
            int reqValid = Loccmp(req, valid);
            int validActual = Loccmp(valid, actual);
            bool reqOK = (expReqValid.Equals("gt") && reqValid > 0)
                    || (expReqValid.Equals("ge") && reqValid >= 0)
                    || (expReqValid.Equals("eq") && reqValid == 0);
            bool valOK = (expValidActual.Equals("gt") && validActual > 0)
                    || (expValidActual.Equals("ge") && validActual >= 0)
                    || (expValidActual.Equals("eq") && validActual == 0);
            if (reqOK && valOK)
            {
                Logln("Ok: " + label + "; req=" + req + ", valid=" + valid
                        + ", actual=" + actual);
            }
            else
            {
                Errln("FAIL: " + label + "; req=" + req + ", valid=" + valid
                        + ", actual=" + actual
                        + ((reqOK) ? "" : "\n  req !" + expReqValid + " valid")
                        + ((valOK) ? "" : "\n  val !" + expValidActual + " actual"));
            }
        }

        public sealed class Anonymous_C9 : ULocaleTest.ServiceFacade
        {
            public Object Create(ULocale req)
            {
                return IBM.ICU.Util.Calendar.GetInstance(req);
            }
            // }, null, new Registrar() {
            // public Object register(ULocale loc, Object prototype) {
            // CFactory f = new CFactory(loc, (Calendar) prototype);
            // return Calendar.register(f, loc);
            // }
            // public boolean unregister(Object key) {
            // return Calendar.unregister(key);
            // }
        }

        public sealed class Anonymous_C8 : ULocaleTest.ServiceFacade
        {
            public Object Create(ULocale req)
            {
                return IBM.ICU.Text.BreakIterator.GetWordInstance(req);
            }
        }

        public sealed class Anonymous_C7 : ULocaleTest.Registrar
        {
            public Object Register(ULocale loc, Object prototype)
            {
                return IBM.ICU.Text.BreakIterator
                        .RegisterInstance((BreakIterator)prototype, loc,
                                IBM.ICU.Text.BreakIterator.KIND_WORD);
            }

            public bool Unregister(Object key)
            {
                return IBM.ICU.Text.BreakIterator.Unregister(key);
            }
        }

        public sealed class Anonymous_C6 : ULocaleTest.ServiceFacade
        {
            public Object Create(ULocale req)
            {
                return IBM.ICU.Text.Collator.GetInstance(req);
            }
        }

        public sealed class Anonymous_C5 : ULocaleTest.Registrar
        {
            public Object Register(ULocale loc, Object prototype)
            {
                return IBM.ICU.Text.Collator.RegisterInstance((Collator)prototype, loc);
            }

            public bool Unregister(Object key)
            {
                return IBM.ICU.Text.Collator.Unregister(key);
            }
        }

        public sealed class Anonymous_C4 : ULocaleTest.ServiceFacade
        {
            public Object Create(ULocale req)
            {
                return IBM.ICU.Text.DateFormat.GetDateInstance(IBM.ICU.Text.DateFormat.DEFAULT, req);
            }
        }

        public sealed class Anonymous_C3 : ULocaleTest.Subobject
        {
            public Object Get(Object parent)
            {
                return ((SimpleDateFormat)parent).GetDateFormatSymbols();
            }
        }

        public sealed class Anonymous_C2 : ULocaleTest.ServiceFacade
        {
            public Object Create(ULocale req)
            {
                return IBM.ICU.Text.NumberFormat.GetInstance(req);
            }
        }

        public sealed class Anonymous_C1 : ULocaleTest.Subobject
        {
            public Object Get(Object parent)
            {
                return ((DecimalFormat)parent).GetDecimalFormatSymbols();
            }
        }

        public sealed class Anonymous_C0 : ULocaleTest.Registrar
        {
            public Object Register(ULocale loc, Object prototype)
            {
                ULocaleTest.NFactory f = new ULocaleTest.NFactory(loc, (NumberFormat)prototype);
                return IBM.ICU.Text.NumberFormat.RegisterFactory(f);
            }

            public bool Unregister(Object key)
            {
                return IBM.ICU.Text.NumberFormat.Unregister(key);
            }
        }

        /// <summary>
        /// Interface used by checkService defining a protocol to create an object,
        /// given a requested locale.
        /// </summary>
        ///
        public interface ServiceFacade
        {
            Object Create(ULocale requestedLocale);
        }

        /// <summary>
        /// Interface used by checkService defining a protocol to get a contained
        /// subobject, given its parent object.
        /// </summary>
        ///
        public interface Subobject
        {
            Object Get(Object parent);
        }

        /// <summary>
        /// Interface used by checkService defining a protocol to register and
        /// unregister a service object prototype.
        /// </summary>
        ///
        public interface Registrar
        {
            Object Register(ULocale loc, Object prototype);

            bool Unregister(Object key);
        }

        /// <summary>
        /// Use reflection to call getLocale() on the given object to determine both
        /// the valid and the actual locale. Verify these for correctness.
        /// </summary>
        ///
        internal void CheckObject(String requestedLocale, Object obj, String expReqValid,
                String expValidActual)
        {
            Type[] getLocaleParams = new Type[] { typeof(ULocale.Type) };
            try
            {
                Type cls = obj.GetType();
                MethodInfo getLocale = ILOG.J2CsMapping.Reflect.Helper.GetMethod(cls, "getLocale", getLocaleParams);
                ULocale valid = (ULocale)ILOG.J2CsMapping.Reflect.Helper.Invoke(getLocale, obj, new Object[] { IBM.ICU.Util.ULocale.VALID_LOCALE });
                ULocale actual = (ULocale)ILOG.J2CsMapping.Reflect.Helper.Invoke(getLocale, obj, new Object[] { IBM.ICU.Util.ULocale.ACTUAL_LOCALE });
                Checklocs(cls.FullName, requestedLocale, valid.ToLocale(),
                        actual.ToLocale(), expReqValid, expValidActual);
            }

            // Make the following exceptions _specific_ -- do not
            // catch(Exception), since that will catch the exception
            // that errln throws.
            catch (AmbiguousMatchException e1)
            {
                // no longer an error, Currency has no getLocale
                // errln("FAIL: reflection failed: " + e1);
            }
            catch (SecurityException e2)
            {
                Errln("FAIL: reflection failed: " + e2);
            }
            catch (MemberAccessException e3)
            {
                Errln("FAIL: reflection failed: " + e3);
            }
            catch (ArgumentException e4)
            {
                Errln("FAIL: reflection failed: " + e4);
            }
            catch (TargetInvocationException e5)
            {
                // no longer an error, Currency has no getLocale
                // errln("FAIL: reflection failed: " + e5);
            }
        }

        /// <summary>
        /// Verify the correct getLocale() behavior for the given service.
        /// </summary>
        ///
        /// <param name="requestedLocale">the locale to request. This MUST BE FAKE. In other words, itshould be something like en_US_FAKEVARIANT so this method canverify correct fallback behavior.</param>
        /// <param name="svc">a factory object that can create the object to be tested. Thisisn't necessary here (one could just pass in the object) butis required for the overload of this method that takes aRegistrar.</param>
        internal void CheckService(String requestedLocale, ULocaleTest.ServiceFacade svc)
        {
            CheckService(requestedLocale, svc, null, null);
        }

        /// <summary>
        /// Verify the correct getLocale() behavior for the given service.
        /// </summary>
        ///
        /// <param name="requestedLocale">the locale to request. This MUST BE FAKE. In other words, itshould be something like en_US_FAKEVARIANT so this method canverify correct fallback behavior.</param>
        /// <param name="svc">a factory object that can create the object to be tested.</param>
        /// <param name="sub">an object that can be used to retrieve a subobject whichshould also be tested. May be null.</param>
        /// <param name="reg">an object that supplies the registration and unregistrationfunctionality to be tested. May be null.</param>
        internal void CheckService(String requestedLocale, ULocaleTest.ServiceFacade svc, ULocaleTest.Subobject sub,
                ULocaleTest.Registrar reg)
        {
            ULocale req = new ULocale(requestedLocale);
            Object obj = svc.Create(req);
            CheckObject(requestedLocale, obj, "gt", "ge");
            if (sub != null)
            {
                Object subobj = sub.Get(obj);
                CheckObject(requestedLocale, subobj, "gt", "ge");
            }
            if (reg != null)
            {
                Logln("Info: Registering service");
                Object key = reg.Register(req, obj);
                Object objReg = svc.Create(req);
                CheckObject(requestedLocale, objReg, "eq", "eq");
                if (sub != null)
                {
                    Object subobj_0 = sub.Get(obj);
                    // Assume subobjects don't come from services, so
                    // their metadata should be structured normally.
                    CheckObject(requestedLocale, subobj_0, "gt", "ge");
                }
                Logln("Info: Unregistering service");
                if (!reg.Unregister(key))
                {
                    Errln("FAIL: unregister failed");
                }
                Object objUnreg = svc.Create(req);
                CheckObject(requestedLocale, objUnreg, "gt", "ge");
            }
        }

        private const int LOCALE_SIZE = 9;

        private static readonly String[][] rawData2 = new String[][] {
	                            new String[] { "en", "fr", "ca", "el", "no", "zh",
	                                    "de", "es", "ja" },
	                            new String[] { "", "", "", "", "", "Hans", "", "",
	                                    "" },
	                            new String[] { "US", "FR", "ES", "GR", "NO", "CN",
	                                    "DE", "", "JP" },
	                            new String[] { "", "", "", "", "NY", "", "", "", "" },
	                            new String[] { "en_US", "fr_FR", "ca_ES", "el_GR",
	                                    "no_NO_NY", "zh_Hans_CN",
	                                    "de_DE@collation=phonebook",
	                                    "es@collation=traditional",
	                                    "ja_JP@calendar=japanese" },
	                            new String[] { "eng", "fra", "cat", "ell", "nor",
	                                    "zho", "deu", "spa", "jpn" },
	                            new String[] { "USA", "FRA", "ESP", "GRC", "NOR",
	                                    "CHN", "DEU", "", "JPN" },
	                            new String[] { "409", "40c", "403", "408", "814",
	                                    "804", "407", "a", "411" },
	                            new String[] { "English", "French", "Catalan",
	                                    "Greek", "Norwegian", "Chinese", "German",
	                                    "Spanish", "Japanese" },
	                            new String[] { "", "", "", "", "",
	                                    "Simplified Han", "", "", "" },
	                            new String[] { "United States", "France", "Spain",
	                                    "Greece", "Norway", "China", "Germany", "",
	                                    "Japan" },
	                            new String[] { "", "", "", "", "NY", "", "", "", "" },
	                            new String[] {
	                                    "English (United States)",
	                                    "French (France)",
	                                    "Catalan (Spain)",
	                                    "Greek (Greece)",
	                                    "Norwegian (Norway, NY)",
	                                    "Chinese (Simplified Han, China)",
	                                    "German (Germany, Collation=Phonebook Order)",
	                                    "Spanish (Collation=Traditional)",
	                                    "Japanese (Japan, Calendar=Japanese Calendar)" },
	                            new String[] { "anglais", "fran\\u00E7ais",
	                                    "catalan", "grec", "norv\\u00E9gien",
	                                    "chinois", "allemand", "espagnol",
	                                    "japonais" },
	                            new String[] { "", "", "", "", "", "Hans", "", "",
	                                    "" },
	                            new String[] { "\\u00C9tats-Unis", "France",
	                                    "Espagne", "Gr\\u00E8ce", "Norv\\u00E8ge",
	                                    "Chine", "Allemagne", "", "Japon" },
	                            new String[] { "", "", "", "", "NY", "", "", "", "" },
	                            new String[] {
	                                    "anglais (\\u00C9tats-Unis)",
	                                    "fran\\u00E7ais (France)",
	                                    "catalan (Espagne)",
	                                    "grec (Gr\\u00E8ce)",
	                                    "norv\\u00E9gien (Norv\\u00E8ge, NY)",
	                                    "chinois (Hans, Chine)",
	                                    "allemand (Allemagne, Ordonnancement=Ordre de l'annuaire)",
	                                    "espagnol (Ordonnancement=Ordre traditionnel)",
	                                    "japonais (Japon, Calendrier=Calendrier japonais)" },
	                            new String[] { "angl\\u00E8s", "franc\\u00E8s",
	                                    "catal\\u00E0", "grec", "noruec",
	                                    "xin\\u00E9s", "alemany", "espanyol",
	                                    "japon\\u00E8s" },
	                            new String[] { "", "", "", "", "", "Hans", "", "",
	                                    "" },
	                            new String[] { "Estats Units", "Fran\\u00E7a",
	                                    "Espanya", "Gr\\u00E8cia", "Noruega",
	                                    "Xina", "Alemanya", "", "Jap\\u00F3" },
	                            new String[] { "", "", "", "", "NY", "", "", "", "" },
	                            new String[] { "angl\\u00E8s (Estats Units)",
	                                    "franc\\u00E8s (Fran\\u00E7a)",
	                                    "catal\\u00E0 (Espanya)",
	                                    "grec (Gr\\u00E8cia)",
	                                    "noruec (Noruega, NY)",
	                                    "xin\\u00E9s (Hans, Xina)",
	                                    "alemany (Alemanya, COLLATION=PHONEBOOK)",
	                                    "espanyol (COLLATION=TRADITIONAL)",
	                                    "japon\\u00E8s (Jap\\u00F3, CALENDAR=JAPANESE)" },
	                            new String[] {
	                                    "\\u0391\\u03b3\\u03b3\\u03bb\\u03b9\\u03ba\\u03ac",
	                                    "\\u0393\\u03b1\\u03bb\\u03bb\\u03b9\\u03ba\\u03ac",
	                                    "\\u039a\\u03b1\\u03c4\\u03b1\\u03bb\\u03b1\\u03bd\\u03b9\\u03ba\\u03ac",
	                                    "\\u0395\\u03bb\\u03bb\\u03b7\\u03bd\\u03b9\\u03ba\\u03ac",
	                                    "\\u039d\\u03bf\\u03c1\\u03b2\\u03b7\\u03b3\\u03b9\\u03ba\\u03ac",
	                                    "\\u039A\\u03B9\\u03BD\\u03B5\\u03B6\\u03B9\\u03BA\\u03AC",
	                                    "\\u0393\\u03B5\\u03C1\\u03BC\\u03B1\\u03BD\\u03B9\\u03BA\\u03AC",
	                                    "\\u0399\\u03C3\\u03C0\\u03B1\\u03BD\\u03B9\\u03BA\\u03AC",
	                                    "\\u0399\\u03B1\\u03C0\\u03C9\\u03BD\\u03B9\\u03BA\\u03AC" },
	                            new String[] { "", "", "", "", "", "Hans", "", "",
	                                    "" },
	                            new String[] {
	                                    "\\u0397\\u03bd\\u03c9\\u03bc\\u03ad\\u03bd\\u03b5\\u03c2 \\u03a0\\u03bf\\u03bb\\u03b9\\u03c4\\u03b5\\u03af\\u03b5\\u03c2",
	                                    "\\u0393\\u03b1\\u03bb\\u03bb\\u03af\\u03b1",
	                                    "\\u0399\\u03c3\\u03c0\\u03b1\\u03bd\\u03af\\u03b1",
	                                    "\\u0395\\u03bb\\u03bb\\u03ac\\u03b4\\u03b1",
	                                    "\\u039d\\u03bf\\u03c1\\u03b2\\u03b7\\u03b3\\u03af\\u03b1",
	                                    "\\u039A\\u03AF\\u03BD\\u03B1",
	                                    "\\u0393\\u03B5\\u03C1\\u03BC\\u03B1\\u03BD\\u03AF\\u03B1",
	                                    "",
	                                    "\\u0399\\u03B1\\u03C0\\u03C9\\u03BD\\u03AF\\u03B1" },
	                            new String[] { "", "", "", "", "NY", "", "", "", "" },
	                            new String[] {
	                                    "\\u0391\\u03b3\\u03b3\\u03bb\\u03b9\\u03ba\\u03ac (\\u0397\\u03bd\\u03c9\\u03bc\\u03ad\\u03bd\\u03b5\\u03c2 \\u03a0\\u03bf\\u03bb\\u03b9\\u03c4\\u03b5\\u03af\\u03b5\\u03c2)",
	                                    "\\u0393\\u03b1\\u03bb\\u03bb\\u03b9\\u03ba\\u03ac (\\u0393\\u03b1\\u03bb\\u03bb\\u03af\\u03b1)",
	                                    "\\u039a\\u03b1\\u03c4\\u03b1\\u03bb\\u03b1\\u03bd\\u03b9\\u03ba\\u03ac (\\u0399\\u03c3\\u03c0\\u03b1\\u03bd\\u03af\\u03b1)",
	                                    "\\u0395\\u03bb\\u03bb\\u03b7\\u03bd\\u03b9\\u03ba\\u03ac (\\u0395\\u03bb\\u03bb\\u03ac\\u03b4\\u03b1)",
	                                    "\\u039d\\u03bf\\u03c1\\u03b2\\u03b7\\u03b3\\u03b9\\u03ba\\u03ac (\\u039d\\u03bf\\u03c1\\u03b2\\u03b7\\u03b3\\u03af\\u03b1, NY)",
	                                    "\\u039A\\u03B9\\u03BD\\u03B5\\u03B6\\u03B9\\u03BA\\u03AC (Hans, \\u039A\\u03AF\\u03BD\\u03B1)",
	                                    "\\u0393\\u03B5\\u03C1\\u03BC\\u03B1\\u03BD\\u03B9\\u03BA\\u03AC (\\u0393\\u03B5\\u03C1\\u03BC\\u03B1\\u03BD\\u03AF\\u03B1, COLLATION=PHONEBOOK)",
	                                    "\\u0399\\u03C3\\u03C0\\u03B1\\u03BD\\u03B9\\u03BA\\u03AC (COLLATION=TRADITIONAL)",
	                                    "\\u0399\\u03B1\\u03C0\\u03C9\\u03BD\\u03B9\\u03BA\\u03AC (\\u0399\\u03B1\\u03C0\\u03C9\\u03BD\\u03AF\\u03B1, CALENDAR=JAPANESE)" } };

        // private static final int ENGLISH = 0;
        // private static final int FRENCH = 1;
        // private static final int CATALAN = 2;
        // private static final int GREEK = 3;
        // private static final int NORWEGIAN = 4;
        private const int LANG = 0;

        private const int SCRIPT = 1;

        private const int CTRY = 2;

        private const int VAR = 3;

        private const int NAME = 4;

        // private static final int LANG3 = 5;
        // private static final int CTRY3 = 6;
        // private static final int LCID = 7;
        // private static final int DLANG_EN = 8;
        // private static final int DSCRIPT_EN = 9;
        // private static final int DCTRY_EN = 10;
        // private static final int DVAR_EN = 11;
        // private static final int DNAME_EN = 12;
        // private static final int DLANG_FR = 13;
        // private static final int DSCRIPT_FR = 14;
        // private static final int DCTRY_FR = 15;
        // private static final int DVAR_FR = 16;
        // private static final int DNAME_FR = 17;
        // private static final int DLANG_CA = 18;
        // private static final int DSCRIPT_CA = 19;
        // private static final int DCTRY_CA = 20;
        // private static final int DVAR_CA = 21;
        // private static final int DNAME_CA = 22;
        // private static final int DLANG_EL = 23;
        // private static final int DSCRIPT_EL = 24;
        // private static final int DCTRY_EL = 25;
        // private static final int DVAR_EL = 26;
        // private static final int DNAME_EL = 27;
        [Test]
        public void TestBasicGetters()
        {
            int i;
            Logln("Testing Basic Getters\n");
            for (i = 0; i < LOCALE_SIZE; i++)
            {
                String testLocale = (rawData2[NAME][i]);
                Logln("Testing " + testLocale + ".....\n");

                String lang = IBM.ICU.Util.ULocale.GetLanguage(testLocale);
                if (0 != String.CompareOrdinal(lang, rawData2[LANG][i]))
                {
                    Errln("  Language code mismatch: " + lang + " versus "
                            + rawData2[LANG][i]);
                }

                String ctry = IBM.ICU.Util.ULocale.GetCountry(testLocale);
                if (0 != String.CompareOrdinal(ctry, rawData2[CTRY][i]))
                {
                    Errln("  Country code mismatch: " + ctry + " versus "
                            + rawData2[CTRY][i]);
                }

                String var = IBM.ICU.Util.ULocale.GetVariant(testLocale);
                if (0 != String.CompareOrdinal(var, rawData2[VAR][i]))
                {
                    Errln("  Variant code mismatch: " + var + " versus "
                            + rawData2[VAR][i]);
                }

                String name = IBM.ICU.Util.ULocale.GetName(testLocale);
                if (0 != String.CompareOrdinal(name, rawData2[NAME][i]))
                {
                    Errln("  Name mismatch: " + name + " versus "
                            + rawData2[NAME][i]);
                }

            }
        }
        [Test]
        public void TestPrefixes()
        {
            // POSIX ids are no longer handled by getName, so POSIX failures are
            // ignored
            String[][] testData = new String[][] {
	                new String[] { "sv", "", "FI", "AL", "sv-fi-al", "sv_FI_AL",
	                        null },
	                new String[] { "en", "", "GB", "", "en-gb", "en_GB", null },
	                new String[] { "i-hakka", "", "MT", "XEMXIJA",
	                        "i-hakka_MT_XEMXIJA", "i-hakka_MT_XEMXIJA", null },
	                new String[] { "i-hakka", "", "CN", "", "i-hakka_CN",
	                        "i-hakka_CN", null },
	                new String[] { "i-hakka", "", "MX", "", "I-hakka_MX",
	                        "i-hakka_MX", null },
	                new String[] { "x-klingon", "", "US", "SANJOSE",
	                        "X-KLINGON_us_SANJOSE", "x-klingon_US_SANJOSE", null },
	                new String[] { "mr", "", "", "", "mr.utf8", "mr.utf8", "mr" },
	                new String[] { "de", "", "TV", "", "de-tv.koi8r",
	                        "de_TV.koi8r", "de_TV" },
	                new String[] { "x-piglatin", "", "ML", "", "x-piglatin_ML.MBE",
	                        "x-piglatin_ML.MBE", "x-piglatin_ML" },
	                new String[] { "i-cherokee", "", "US", "",
	                        "i-Cherokee_US.utf7", "i-cherokee_US.utf7",
	                        "i-cherokee_US" },
	                new String[] { "x-filfli", "", "MT", "FILFLA",
	                        "x-filfli_MT_FILFLA.gb-18030",
	                        "x-filfli_MT_FILFLA.gb-18030", "x-filfli_MT_FILFLA" },
	                new String[] { "no", "", "NO", "NY_B", "no-no-ny.utf32@B",
	                        "no_NO_NY.utf32@B", "no_NO_NY_B" },
	                new String[] { "no", "", "NO", "B", "no-no.utf32@B",
	                        "no_NO.utf32@B", "no_NO_B" },
	                new String[] { "no", "", "", "NY", "no__ny", "no__NY", null },
	                new String[] { "no", "", "", "NY", "no@ny", "no@ny", "no__NY" },
	                new String[] { "el", "Latn", "", "", "el-latn", "el_Latn", null },
	                new String[] { "en", "Cyrl", "RU", "", "en-cyrl-ru",
	                        "en_Cyrl_RU", null },
	                new String[] { "zh", "Hant", "TW", "STROKE",
	                        "zh-hant_TW_STROKE", "zh_Hant_TW_STROKE", null },
	                new String[] { "qq", "Qqqq", "QQ", "QQ", "qq_Qqqq_QQ_QQ",
	                        "qq_Qqqq_QQ_QQ", null },
	                new String[] { "qq", "Qqqq", "", "QQ", "qq_Qqqq__QQ",
	                        "qq_Qqqq__QQ", null },
	                new String[] { "12", "3456", "78", "90", "12_3456_78_90",
	                        "12_3456_78_90", null },
	                new String[] { "", "", "", "", "@FOO=bar", "@foo=bar", null },
	                new String[] { "", "", "", "", "_@FOO=bar", "@foo=bar", null },
	                new String[] { "", "", "", "", "__@FOO=bar", "@foo=bar", null },
	                new String[] { "", "", "", "FOO", "__foo@FOO=bar",
	                        "__FOO@foo=bar", null } };

            String loc, buf, buf1;
            String[] testTitles = { "ULocale.getLanguage()",
	                "ULocale.getScript()", "ULocale.getCountry()",
	                "ULocale.getVariant()", "name", "ULocale.getName()",
	                "canonicalize()", };
            ULocale uloc;

            for (int row = 0; row < testData.Length; row++)
            {
                loc = testData[row][NAME];
                Logln("Test #" + row + ": " + loc);

                uloc = new ULocale(loc);

                for (int n = 0; n <= (NAME + 2); n++)
                {
                    if (n == NAME)
                        continue;

                    switch (n)
                    {
                        case LANG:
                            buf = IBM.ICU.Util.ULocale.GetLanguage(loc);
                            buf1 = uloc.GetLanguage();
                            break;

                        case SCRIPT:
                            buf = IBM.ICU.Util.ULocale.GetScript(loc);
                            buf1 = uloc.GetScript();
                            break;

                        case CTRY:
                            buf = IBM.ICU.Util.ULocale.GetCountry(loc);
                            buf1 = uloc.GetCountry();
                            break;

                        case VAR:
                            buf = IBM.ICU.Util.ULocale.GetVariant(loc);
                            buf1 = buf;
                            break;

                        case NAME + 1:
                            buf = IBM.ICU.Util.ULocale.GetName(loc);
                            buf1 = uloc.GetName();
                            break;

                        case NAME + 2:
                            buf = IBM.ICU.Util.ULocale.Canonicalize(loc);
                            buf1 = IBM.ICU.Util.ULocale.CreateCanonical(loc).GetName();
                            break;

                        default:
                            buf = "**??";
                            buf1 = buf;
                            break;
                    }

                    Logln("#" + row + ": " + testTitles[n] + " on " + loc
                            + ": -> [" + buf + "]");

                    String expected = testData[row][n];
                    if (expected == null && n == (NAME + 2))
                    {
                        expected = testData[row][NAME + 1];
                    }

                    // ignore POSIX failures in getName, we don't spec behavior in
                    // this case
                    if (n == NAME + 1
                            && (expected.IndexOf('.') != -1 || expected
                                    .IndexOf('@') != -1))
                    {
                        continue;
                    }

                    if (String.CompareOrdinal(buf, expected) != 0)
                    {
                        Errln("#" + row + ": " + testTitles[n] + " on " + loc
                                + ": -> [" + buf + "] (expected '" + expected
                                + "'!)");
                    }
                    if (String.CompareOrdinal(buf1, expected) != 0)
                    {
                        Errln("#" + row + ": " + testTitles[n]
                                + " on ULocale object " + loc + ": -> [" + buf1
                                + "] (expected '" + expected + "'!)");
                    }
                }
            }
        }
        [Test]
        public void TestObsoleteNames()
        {
            String[][] tests = new String[][] { new String[] { "eng_USA", "eng", "en", "USA", "US" },
	                        new String[] { "kok", "kok", "kok", "", "" },
	                        new String[] { "in", "ind", "in", "", "" },
	                        new String[] { "id", "ind", "id", "", "" },
	                        new String[] { "sh", "srp", "sh", "", "" },
	                        new String[] { "zz_CS", "", "zz", "SCG", "CS" },
	                        new String[] { "zz_FX", "", "zz", "FXX", "FX" },
	                        new String[] { "zz_RO", "", "zz", "ROU", "RO" },
	                        new String[] { "zz_TP", "", "zz", "TMP", "TP" },
	                        new String[] { "zz_TL", "", "zz", "TLS", "TL" },
	                        new String[] { "zz_ZR", "", "zz", "ZAR", "ZR" },
	                        new String[] { "zz_FXX", "", "zz", "FXX", "FX" },
	                        new String[] { "zz_ROM", "", "zz", "ROU", "RO" },
	                        new String[] { "zz_ROU", "", "zz", "ROU", "RO" },
	                        new String[] { "zz_ZAR", "", "zz", "ZAR", "ZR" },
	                        new String[] { "zz_TMP", "", "zz", "TMP", "TP" },
	                        new String[] { "zz_TLS", "", "zz", "TLS", "TL" },
	                        new String[] { "zz_YUG", "", "zz", "YUG", "YU" },
	                        new String[] { "mlt_PSE", "mlt", "mt", "PSE", "PS" },
	                        new String[] { "iw", "heb", "iw", "", "" },
	                        new String[] { "ji", "yid", "ji", "", "" },
	                        new String[] { "jw", "jaw", "jw", "", "" },
	                        new String[] { "sh", "srp", "sh", "", "" },
	                        new String[] { "", "", "", "", "" } };

            for (int i = 0; i < tests.Length; i++)
            {
                String locale = tests[i][0];
                Logln("** Testing : " + locale);
                String buff, buff1;
                ULocale uloc = new ULocale(locale);

                buff = IBM.ICU.Util.ULocale.GetISO3Language(locale);
                if (String.CompareOrdinal(buff, tests[i][1]) != 0)
                {
                    Errln("FAIL: ULocale.getISO3Language(" + locale + ")==" + buff
                            + ",\t expected " + tests[i][1]);
                }
                else
                {
                    Logln("   ULocale.getISO3Language(" + locale + ")==" + buff);
                }

                buff1 = uloc.GetISO3Language();
                if (String.CompareOrdinal(buff1, tests[i][1]) != 0)
                {
                    Errln("FAIL: ULocale.getISO3Language(" + locale + ")==" + buff
                            + ",\t expected " + tests[i][1]);
                }
                else
                {
                    Logln("   ULocale.getISO3Language(" + locale + ")==" + buff);
                }

                buff = IBM.ICU.Util.ULocale.GetLanguage(locale);
                if (String.CompareOrdinal(buff, tests[i][2]) != 0)
                {
                    Errln("FAIL: ULocale.getLanguage(" + locale + ")==" + buff
                            + ",\t expected " + tests[i][2]);
                }
                else
                {
                    Logln("   ULocale.getLanguage(" + locale + ")==" + buff);
                }

                buff = IBM.ICU.Util.ULocale.GetISO3Country(locale);
                if (String.CompareOrdinal(buff, tests[i][3]) != 0)
                {
                    Errln("FAIL: ULocale.getISO3Country(" + locale + ")==" + buff
                            + ",\t expected " + tests[i][3]);
                }
                else
                {
                    Logln("   ULocale.getISO3Country(" + locale + ")==" + buff);
                }

                buff1 = uloc.GetISO3Country();
                if (String.CompareOrdinal(buff1, tests[i][3]) != 0)
                {
                    Errln("FAIL: ULocale.getISO3Country(" + locale + ")==" + buff
                            + ",\t expected " + tests[i][3]);
                }
                else
                {
                    Logln("   ULocale.getISO3Country(" + locale + ")==" + buff);
                }

                buff = IBM.ICU.Util.ULocale.GetCountry(locale);
                if (String.CompareOrdinal(buff, tests[i][4]) != 0)
                {
                    Errln("FAIL: ULocale.getCountry(" + locale + ")==" + buff
                            + ",\t expected " + tests[i][4]);
                }
                else
                {
                    Logln("   ULocale.getCountry(" + locale + ")==" + buff);
                }
            }

            if (String.CompareOrdinal(IBM.ICU.Util.ULocale.GetLanguage("iw_IL"), IBM.ICU.Util.ULocale.GetLanguage("he_IL")) == 0)
            {
                Errln("he,iw ULocale.getLanguage mismatch");
            }

            String buff_0 = IBM.ICU.Util.ULocale.GetLanguage("kok_IN");
            if (String.CompareOrdinal(buff_0, "kok") != 0)
            {
                Errln("ULocale.getLanguage(\"kok\") failed. Expected: kok Got: "
                        + buff_0);
            }
        }
        [Test]
        public void TestCanonicalization()
        {
            String[][] testCases = new String[][] {
	                                new String[] { "ca_ES_PREEURO",
	                                        "ca_ES_PREEURO", "ca_ES@currency=ESP" },
	                                new String[] { "de_AT_PREEURO",
	                                        "de_AT_PREEURO", "de_AT@currency=ATS" },
	                                new String[] { "de_DE_PREEURO",
	                                        "de_DE_PREEURO", "de_DE@currency=DEM" },
	                                new String[] { "de_LU_PREEURO",
	                                        "de_LU_PREEURO", "de_LU@currency=EUR" },
	                                new String[] { "el_GR_PREEURO",
	                                        "el_GR_PREEURO", "el_GR@currency=GRD" },
	                                new String[] { "en_BE_PREEURO",
	                                        "en_BE_PREEURO", "en_BE@currency=BEF" },
	                                new String[] { "en_IE_PREEURO",
	                                        "en_IE_PREEURO", "en_IE@currency=IEP" },
	                                new String[] { "es_ES_PREEURO",
	                                        "es_ES_PREEURO", "es_ES@currency=ESP" },
	                                new String[] { "eu_ES_PREEURO",
	                                        "eu_ES_PREEURO", "eu_ES@currency=ESP" },
	                                new String[] { "fi_FI_PREEURO",
	                                        "fi_FI_PREEURO", "fi_FI@currency=FIM" },
	                                new String[] { "fr_BE_PREEURO",
	                                        "fr_BE_PREEURO", "fr_BE@currency=BEF" },
	                                new String[] { "fr_FR_PREEURO",
	                                        "fr_FR_PREEURO", "fr_FR@currency=FRF" },
	                                new String[] { "fr_LU_PREEURO",
	                                        "fr_LU_PREEURO", "fr_LU@currency=LUF" },
	                                new String[] { "ga_IE_PREEURO",
	                                        "ga_IE_PREEURO", "ga_IE@currency=IEP" },
	                                new String[] { "gl_ES_PREEURO",
	                                        "gl_ES_PREEURO", "gl_ES@currency=ESP" },
	                                new String[] { "it_IT_PREEURO",
	                                        "it_IT_PREEURO", "it_IT@currency=ITL" },
	                                new String[] { "nl_BE_PREEURO",
	                                        "nl_BE_PREEURO", "nl_BE@currency=BEF" },
	                                new String[] { "nl_NL_PREEURO",
	                                        "nl_NL_PREEURO", "nl_NL@currency=NLG" },
	                                new String[] { "pt_PT_PREEURO",
	                                        "pt_PT_PREEURO", "pt_PT@currency=PTE" },
	                                new String[] { "de__PHONEBOOK",
	                                        "de__PHONEBOOK",
	                                        "de@collation=phonebook" },
	                                new String[] { "en_GB_EURO", "en_GB_EURO",
	                                        "en_GB@currency=EUR" },
	                                new String[] { "en_GB@EURO", null,
	                                        "en_GB@currency=EUR" },
	                                new String[] { "es__TRADITIONAL",
	                                        "es__TRADITIONAL",
	                                        "es@collation=traditional" },
	                                new String[] { "hi__DIRECT", "hi__DIRECT",
	                                        "hi@collation=direct" },
	                                new String[] { "ja_JP_TRADITIONAL",
	                                        "ja_JP_TRADITIONAL",
	                                        "ja_JP@calendar=japanese" },
	                                new String[] { "th_TH_TRADITIONAL",
	                                        "th_TH_TRADITIONAL",
	                                        "th_TH@calendar=buddhist" },
	                                new String[] { "zh_TW_STROKE", "zh_TW_STROKE",
	                                        "zh_TW@collation=stroke" },
	                                new String[] { "zh__PINYIN", "zh__PINYIN",
	                                        "zh@collation=pinyin" },
	                                new String[] { "zh@collation=pinyin",
	                                        "zh@collation=pinyin",
	                                        "zh@collation=pinyin" },
	                                new String[] { "zh_CN@collation=pinyin",
	                                        "zh_CN@collation=pinyin",
	                                        "zh_CN@collation=pinyin" },
	                                new String[] { "zh_CN_CA@collation=pinyin",
	                                        "zh_CN_CA@collation=pinyin",
	                                        "zh_CN_CA@collation=pinyin" },
	                                new String[] { "en_US_POSIX", "en_US_POSIX",
	                                        "en_US_POSIX" },
	                                new String[] { "hy_AM_REVISED",
	                                        "hy_AM_REVISED", "hy_AM_REVISED" },
	                                new String[] { "no_NO_NY", "no_NO_NY",
	                                        "no_NO_NY" },
	                                new String[] { "no@ny", null, "no__NY" },
	                                new String[] { "no-no.utf32@B", null, "no_NO_B" },
	                                new String[] { "qz-qz@Euro", null,
	                                        "qz_QZ@currency=EUR" },
	                                new String[] { "en-BOONT", "en_BOONT",
	                                        "en__BOONT" },
	                                new String[] { "de-1901", "de_1901", "de__1901" },
	                                new String[] { "de-1906", "de_1906", "de__1906" },
	                                new String[] { "sr-SP-Cyrl", "sr_SP_CYRL",
	                                        "sr_Cyrl_CS" },
	                                new String[] { "sr-SP-Latn", "sr_SP_LATN",
	                                        "sr_Latn_CS" },
	                                new String[] { "sr_YU_CYRILLIC",
	                                        "sr_YU_CYRILLIC", "sr_Cyrl_CS" },
	                                new String[] { "uz-UZ-Cyrl", "uz_UZ_CYRL",
	                                        "uz_Cyrl_UZ" },
	                                new String[] { "uz-UZ-Latn", "uz_UZ_LATN",
	                                        "uz_Latn_UZ" },
	                                new String[] { "zh-CHS", "zh_CHS", "zh_Hans" },
	                                new String[] { "zh-CHT", "zh_CHT", "zh_Hant" },
	                                new String[] { "mr.utf8", null, "mr" },
	                                new String[] { "de-tv.koi8r", null, "de_TV" },
	                                new String[] { "x-piglatin_ML.MBE", null,
	                                        "x-piglatin_ML" },
	                                new String[] { "i-cherokee_US.utf7", null,
	                                        "i-cherokee_US" },
	                                new String[] { "x-filfli_MT_FILFLA.gb-18030",
	                                        null, "x-filfli_MT_FILFLA" },
	                                new String[] { "no-no-ny.utf8@B", null,
	                                        "no_NO_NY_B" },
	                                new String[] {
	                                        "en_Hant_IL_VALLEY_GIRL@currency=EUR;calendar=Japanese;",
	                                        "en_Hant_IL_VALLEY_GIRL@calendar=Japanese;currency=EUR",
	                                        "en_Hant_IL_VALLEY_GIRL@calendar=Japanese;currency=EUR" },
	                                new String[] {
	                                        "en_Hant_IL_VALLEY_GIRL@calendar=Japanese;currency=EUR",
	                                        "en_Hant_IL_VALLEY_GIRL@calendar=Japanese;currency=EUR",
	                                        "en_Hant_IL_VALLEY_GIRL@calendar=Japanese;currency=EUR" },
	                                new String[] { "no-Hant-GB_NY@currency=$$$",
	                                        "no_Hant_GB_NY@currency=$$$",
	                                        "no_Hant_GB_NY@currency=$$$" },
	                                new String[] { "root@kw=foo", "root@kw=foo",
	                                        "root@kw=foo" },
	                                new String[] { "@calendar=gregorian",
	                                        "@calendar=gregorian",
	                                        "@calendar=gregorian" } };

            for (int i = 0; i < testCases.Length; i++)
            {
                String[] testCase = testCases[i];
                String source = testCase[0];
                String level1Expected = testCase[1];
                String level2Expected = testCase[2];

                if (level1Expected != null)
                { // null means we have no expectations
                    // for how this case is handled
                    String level1 = IBM.ICU.Util.ULocale.GetName(source);
                    if (!level1.Equals(level1Expected))
                    {
                        Errln("ULocale.getName error for: '" + source
                                + "' expected: '" + level1Expected + "' but got: '"
                                + level1 + "'");
                    }
                    else
                    {
                        Logln("Ulocale.getName for: '" + source + "' returned: '"
                                + level1 + "'");
                    }
                }
                else
                {
                    Logln("ULocale.getName skipped: '" + source + "'");
                }

                if (level2Expected != null)
                {
                    String level2 = IBM.ICU.Util.ULocale.Canonicalize(source);
                    if (!level2.Equals(level2Expected))
                    {
                        Errln("ULocale.getName error for: '" + source
                                + "' expected: '" + level2Expected + "' but got: '"
                                + level2 + "'");
                    }
                    else
                    {
                        Logln("Ulocale.canonicalize for: '" + source
                                + "' returned: '" + level2 + "'");
                    }
                }
                else
                {
                    Logln("ULocale.canonicalize skipped: '" + source + "'");
                }
            }
        }
        [Test]
        public void TestGetAvailable()
        {
            ULocale[] locales = IBM.ICU.Util.ULocale.GetAvailableLocales();
            if (locales.Length < 10)
            {
                Errln("Did not get the correct result from getAvailableLocales");
            }
            if (!locales[locales.Length - 1].Equals("zh_Hant_TW"))
            {
                Errln("Did not get the expected result");
            }
        }
        [Test]
        public void TestDisplayNames()
        {
            // consistency check, also check that all data is available
            {
                ULocale[] locales = IBM.ICU.Util.ULocale.GetAvailableLocales();
                for (int i = 0; i < locales.Length; ++i)
                {
                    ULocale l = locales[i];
                    String name = l.GetDisplayName();

                    Logln(l + " --> " + name + ", "
                            + l.GetDisplayName(IBM.ICU.Util.ULocale.GERMAN) + ", "
                            + l.GetDisplayName(IBM.ICU.Util.ULocale.FRANCE));

                    String language = l.GetDisplayLanguage();
                    String script = l.GetDisplayScript();
                    String country = l.GetDisplayCountry();
                    String variant = l.GetDisplayVariant();

                    CheckName(name, language, script, country, variant);

                    for (int j = 0; j < locales.Length; ++j)
                    {
                        ULocale dl = locales[j];

                        name = l.GetDisplayName(dl);
                        language = l.GetDisplayLanguage(dl);
                        script = l.GetDisplayScript(dl);
                        country = l.GetDisplayCountry(dl);
                        variant = l.GetDisplayVariant(dl);

                        if (!CheckName(name, language, script, country, variant))
                        {
                            break;
                        }
                    }
                }
            }
            // spot check
            {
                ULocale[] locales_0 = { IBM.ICU.Util.ULocale.US, IBM.ICU.Util.ULocale.GERMANY, IBM.ICU.Util.ULocale.FRANCE };
                String[] names = { "Chinese (China)", "Chinesisch (China)",
	                    "chinois (Chine)" };
                ULocale locale = new ULocale("zh_CN");
                for (int i_1 = 0; i_1 < locales_0.Length; ++i_1)
                {
                    String name_2 = locale.GetDisplayName(locales_0[i_1]);
                    if (!names[i_1].Equals(name_2))
                    {
                        Errln("expected '" + names[i_1] + "' but got '" + name_2 + "'");
                    }
                }
            }
        }

        private bool CheckName(String name, String language, String script,
                String country, String variant)
        {
            if (language.Length > 0 && name.IndexOf(language) == -1)
            {
                Errln("name '" + name + "' does not contain language '" + language
                        + "'");
                return false;
            }
            if (script.Length > 0 && name.IndexOf(script) == -1)
            {
                Errln("name '" + name + "' does not contain script '" + script
                        + "'");
                return false;
            }
            if (country.Length > 0 && name.IndexOf(country) == -1)
            {
                Errln("name '" + name + "' does not contain country '" + country
                        + "'");
                return false;
            }
            if (variant.Length > 0 && name.IndexOf(variant) == -1)
            {
                Errln("name '" + name + "' does not contain variant '" + variant
                        + "'");
                return false;
            }
            return true;
        }
        [Test]
        public void TestCoverage()
        {
            {
                // Cover displayXXX
                int i, j;
                String localeID = "zh_CN";
                String name, language, script, country, variant;
                Logln("Covering APIs with signature displayXXX(String, String)");
                for (i = 0; i < LOCALE_SIZE; i++)
                {
                    // localeID String
                    String testLocale = (rawData2[NAME][i]);

                    Logln("Testing " + testLocale + ".....");
                    name = IBM.ICU.Util.ULocale.GetDisplayName(localeID, testLocale);
                    language = IBM.ICU.Util.ULocale.GetDisplayLanguage(localeID, testLocale);
                    script = IBM.ICU.Util.ULocale.GetDisplayScript(localeID, testLocale);
                    country = IBM.ICU.Util.ULocale.GetDisplayCountry(localeID, testLocale);
                    variant = IBM.ICU.Util.ULocale.GetDisplayVariant(localeID, testLocale);

                    if (!CheckName(name, language, script, country, variant))
                    {
                        break;
                    }
                }

                Logln("Covering APIs with signature displayXXX(String, ULocale)\n");
                for (j = 0; j < LOCALE_SIZE; j++)
                {
                    String testLocale_0 = (rawData2[NAME][j]);
                    ULocale loc = new ULocale(testLocale_0);

                    Logln("Testing " + testLocale_0 + ".....");
                    name = IBM.ICU.Util.ULocale.GetDisplayName(localeID, loc);
                    language = IBM.ICU.Util.ULocale.GetDisplayLanguage(localeID, loc);
                    script = IBM.ICU.Util.ULocale.GetDisplayScript(localeID, loc);
                    country = IBM.ICU.Util.ULocale.GetDisplayCountry(localeID, loc);
                    variant = IBM.ICU.Util.ULocale.GetDisplayVariant(localeID, loc);

                    if (!CheckName(name, language, script, country, variant))
                    {
                        break;
                    }
                }
            }
            ULocale loc1 = new ULocale("en_US_BROOKLYN");
            ULocale loc2 = new ULocale("en", "US", "BROOKLYN");
            if (!loc2.Equals(loc1))
            {
                Errln("ULocale.ULocale(String a, String b, String c)");
            }

            ULocale loc3 = new ULocale("en_US");
            ULocale loc4 = new ULocale("en", "US");
            if (!loc4.Equals(loc3))
            {
                Errln("ULocale.ULocale(String a, String b)");
            }

            ULocale loc5 = (ULocale)loc4.Clone();
            if (!loc5.Equals(loc4))
            {
                Errln("ULocale.clone should get the same ULocale");
            }
            IBM.ICU.Util.ULocale.GetISOCountries(); // To check the result ?!
        }
        [Test]
        public void TestBamBm()
        {
            // "bam" shouldn't be there since the official code is 'bm'
            String[] isoLanguages = IBM.ICU.Util.ULocale.GetISOLanguages();
            for (int i = 0; i < isoLanguages.Length; ++i)
            {
                if ("bam".Equals(isoLanguages[i]))
                {
                    Errln("found bam");
                }
                if (i > 0 && String.CompareOrdinal(isoLanguages[i], isoLanguages[i - 1]) <= 0)
                {
                    Errln("language list out of order: '" + isoLanguages[i]
                            + " <= " + isoLanguages[i - 1]);
                }
            }
        }
        [Test]
        public void TestDisplayKeyword()
        {
            // prepare testing data
            InitHashtable();
            String[] data = { "en_US@collation=direct;calendar=islamic-civil",
	                "zh_Hans@collation=pinyin;calendar=chinese",
	                "foo_Bar_BAZ@collation=traditional;calendar=buddhist" };

            for (int i = 0; i < data.Length; i++)
            {
                String localeID = data[i];
                Logln("");
                Logln("Testing locale " + localeID + " ...");
                ULocale loc = new ULocale(localeID);

                IIterator it = loc.GetKeywords();
                IIterator it2 = IBM.ICU.Util.ULocale.GetKeywords(localeID);
                // it and it2 are not equal here. No way to verify their equivalence
                // yet.
                while (it.HasNext())
                {
                    String key = (String)it.Next();
                    String key2 = (String)it2.Next();
                    if (!key.Equals(key2))
                    {
                        Errln("FAIL: static and non-static getKeywords returned different results.");
                    }

                    // To verify display of Keyword
                    // display the above key in English
                    String s0 = IBM.ICU.Util.ULocale.GetDisplayKeyword(key); // display in
                    // default locale
                    String s1 = IBM.ICU.Util.ULocale.GetDisplayKeyword(key, IBM.ICU.Util.ULocale.US);
                    String s2 = IBM.ICU.Util.ULocale.GetDisplayKeyword(key, "en_US");
                    if (!s1.Equals(s2))
                    {
                        Errln("FAIL: one of the getDisplayKeyword methods failed.");
                    }
                    if (IBM.ICU.Util.ULocale.GetDefault().Equals(IBM.ICU.Util.ULocale.US) && !s1.Equals(s0))
                    {
                        Errln("FAIL: getDisplayKeyword methods failed for the default locale.");
                    }
                    if (!s1.Equals(h[0][key]))
                    {
                        Warnln("Locale " + localeID
                                + " getDisplayKeyword for key: " + key
                                + " in English expected \"" + h[0][key]
                                + "\" saw \"" + s1 + "\" instead");
                    }
                    else
                    {
                        Logln("OK: getDisplayKeyword for key: " + key
                                + " in English got " + s1);
                    }

                    // display the key in S-Chinese
                    s1 = IBM.ICU.Util.ULocale.GetDisplayKeyword(key, IBM.ICU.Util.ULocale.CHINA);
                    s2 = IBM.ICU.Util.ULocale.GetDisplayKeyword(key, "zh_Hans");
                    if (!s1.Equals(s2))
                    {
                        Errln("one of the getDisplayKeyword methods failed.");
                    }
                    if (!s1.Equals(h[1][key]))
                    {
                        Warnln("Locale " + localeID
                                + " getDisplayKeyword for key: " + key
                                + " in Chinese expected \"" + h[1][key]
                                + "\" saw \"" + s1 + "\" instead");
                    }
                    else
                    {
                        Logln("OK: getDisplayKeyword for key: " + key
                                + " in Chinese got " + s1);
                    }

                    // To verify display of Keyword values
                    String type = loc.GetKeywordValue(key);
                    // display type in English
                    String ss0 = loc.GetDisplayKeywordValue(key);
                    String ss1 = loc.GetDisplayKeywordValue(key, IBM.ICU.Util.ULocale.US);
                    String ss2 = IBM.ICU.Util.ULocale.GetDisplayKeywordValue(localeID, key,
                            "en_US");
                    String ss3 = IBM.ICU.Util.ULocale.GetDisplayKeywordValue(localeID, key,
                            IBM.ICU.Util.ULocale.US);
                    if (!ss1.Equals(ss2) || !ss1.Equals(ss3))
                    {
                        Errln("FAIL: one of the getDisplayKeywordValue methods failed.");
                    }
                    if (IBM.ICU.Util.ULocale.GetDefault().Equals(IBM.ICU.Util.ULocale.US) && !ss1.Equals(ss0))
                    {
                        Errln("FAIL: getDisplayKeyword methods failed for the default locale.");
                    }
                    if (!ss1.Equals(h[0][type]))
                    {
                        Warnln(" Locale " + localeID
                                + " getDisplayKeywordValue for key: " + key
                                + " in English expected \"" + h[0][type]
                                + "\" saw \"" + ss1 + "\" instead");
                    }
                    else
                    {
                        Logln("OK: getDisplayKeywordValue for key: " + key
                                + " in English got " + ss1);
                    }

                    // display type in Chinese
                    ss0 = loc.GetDisplayKeywordValue(key);
                    ss1 = loc.GetDisplayKeywordValue(key, IBM.ICU.Util.ULocale.CHINA);
                    ss2 = IBM.ICU.Util.ULocale.GetDisplayKeywordValue(localeID, key, "zh_Hans");
                    ss3 = IBM.ICU.Util.ULocale.GetDisplayKeywordValue(localeID, key,
                            IBM.ICU.Util.ULocale.CHINA);
                    if (!ss1.Equals(ss2) || !ss1.Equals(ss3))
                    {
                        Warnln("one of the getDisplayKeywordValue methods failed.");
                    }
                    if (!ss1.Equals(h[1][type]))
                    {
                        Warnln("Locale " + localeID
                                + " getDisplayKeywordValue for key: " + key
                                + " in Chinese expected \"" + h[1][type]
                                + "\" saw \"" + ss1 + "\" instead");
                    }
                    else
                    {
                        Logln("OK: getDisplayKeywordValue for key: " + key
                                + " in Chinese got " + ss1);
                    }
                }
            }
        }

        private void InitHashtable()
        {
            h[0] = new Hashtable();
            h[1] = new Hashtable();

            // display in English
            ILOG.J2CsMapping.Collections.Collections.Put(h[0], "collation", "collation");
            ILOG.J2CsMapping.Collections.Collections.Put(h[0], "calendar", "calendar");
            ILOG.J2CsMapping.Collections.Collections.Put(h[0], "currency", "Currency");
            ILOG.J2CsMapping.Collections.Collections.Put(h[0], "phonebook", "Phonebook Order");
            ILOG.J2CsMapping.Collections.Collections.Put(h[0], "pinyin", "Pinyin Sort Order");
            ILOG.J2CsMapping.Collections.Collections.Put(h[0], "traditional", "Traditional Sort Order");
            ILOG.J2CsMapping.Collections.Collections.Put(h[0], "stroke", "Stroke Order");
            ILOG.J2CsMapping.Collections.Collections.Put(h[0], "direct", "Direct Sort Order");
            ILOG.J2CsMapping.Collections.Collections.Put(h[0], "japanese", "Japanese Calendar");
            ILOG.J2CsMapping.Collections.Collections.Put(h[0], "buddhist", "Buddhist Calendar");
            ILOG.J2CsMapping.Collections.Collections.Put(h[0], "islamic", "Islamic Calendar");
            ILOG.J2CsMapping.Collections.Collections.Put(h[0], "islamic-civil", "Islamic-Civil Calendar");
            ILOG.J2CsMapping.Collections.Collections.Put(h[0], "hebrew", "Hebrew Calendar");
            ILOG.J2CsMapping.Collections.Collections.Put(h[0], "chinese", "Chinese Calendar");
            ILOG.J2CsMapping.Collections.Collections.Put(h[0], "gregorian", "Gregorian Calendar");

            // display in S-Chinese
            ILOG.J2CsMapping.Collections.Collections.Put(h[1], "collation", "\u5BF9\u7167");
            ILOG.J2CsMapping.Collections.Collections.Put(h[1], "calendar", "\u65E5\u5386");
            ILOG.J2CsMapping.Collections.Collections.Put(h[1], "currency", "\u8D27\u5E01");
            ILOG.J2CsMapping.Collections.Collections.Put(h[1], "direct", "\u987A\u5E8F");
            ILOG.J2CsMapping.Collections.Collections.Put(h[1], "phonebook", "\u7535\u8BDD\u7C3F\u987A\u5E8F");
            ILOG.J2CsMapping.Collections.Collections.Put(h[1], "pinyin", "\u62FC\u97F3\u987a\u5e8f");
            ILOG.J2CsMapping.Collections.Collections.Put(h[1], "stroke", "\u7B14\u5212\u987A\u5E8F");
            ILOG.J2CsMapping.Collections.Collections.Put(h[1], "traditional", "\u4F20\u7EDF\u5386\u6CD5");
            ILOG.J2CsMapping.Collections.Collections.Put(h[1], "japanese", "\u65E5\u672C\u65E5\u5386");
            ILOG.J2CsMapping.Collections.Collections.Put(h[1], "buddhist", "\u4F5B\u6559\u65E5\u5386");
            ILOG.J2CsMapping.Collections.Collections.Put(h[1], "islamic", "\u4F0A\u65AF\u5170\u65E5\u5386");
            ILOG.J2CsMapping.Collections.Collections.Put(h[1], "islamic-civil", "\u4F0A\u65AF\u5170\u5E0C\u5409\u6765\u5386");
            ILOG.J2CsMapping.Collections.Collections.Put(h[1], "hebrew", "\u5E0C\u4F2F\u6765\u65E5\u5386");
            ILOG.J2CsMapping.Collections.Collections.Put(h[1], "chinese", "\u519C\u5386");
            ILOG.J2CsMapping.Collections.Collections.Put(h[1], "gregorian", "\u516C\u5386");
        }

        // Hashtables for storing expected display of keys/types of locale in
        // English and Chinese
        private static IDictionary[] h = new Hashtable[2];

        private static readonly String[][] ACCEPT_LANGUAGE_TESTS = {
	            new String[] { "mt_MT", "false" }, new String[] { "en", "false" },
	            new String[] { "en", "true" }, new String[] { null, "true" },
	            new String[] { "es", "false" }, new String[] { "de", "false" } };

        private static readonly String[] ACCEPT_LANGUAGE_HTTP = {
	            "mt-mt, ja;q=0.76, en-us;q=0.95, en;q=0.92, en-gb;q=0.89, fr;q=0.87, iu-ca;q=0.84, iu;q=0.82, ja-jp;q=0.79, mt;q=0.97, de-de;q=0.74, de;q=0.71, es;q=0.68, it-it;q=0.66, it;q=0.63, vi-vn;q=0.61, vi;q=0.58, nl-nl;q=0.55, nl;q=0.53, th-th-traditional;q=.01",
	            "ja;q=0.5, en;q=0.8, tlh",
	            "en-zzz, de-lx;q=0.8",
	            "mga-ie;q=0.9, tlh",
	            "xxx-yyy;q=.01, xxx-yyy;q=.01, xxx-yyy;q=.01, xxx-yyy;q=.01, xxx-yyy;q=.01, xxx-yyy;q=.01, "
	                    + "xxx-yyy;q=.01, xxx-yyy;q=.01, xxx-yyy;q=.01, xxx-yyy;q=.01, xxx-yyy;q=.01, xxx-yyy;q=.01, "
	                    + "xxx-yyy;q=.01, xxx-yyy;q=.01, xxx-yyy;q=.01, xxx-yyy;q=.01, xxx-yyy;q=.01, xxx-yyy;q=.01, "
	                    + "xxx-yyy;q=.01, xxx-yyy;q=.01, xxx-yyy;q=.01, xxx-yyy;q=.01, xxx-yyy;q=.01, xxx-yyy;q=.01, "
	                    + "xxx-yyy;q=.01, xxx-yyy;q=.01, xxx-yyy;q=.01, xxx-yyy;q=.01, xxx-yyy;q=.01, xxx-yyy;q=.01, "
	                    + "xxx-yyy;q=.01, xxx-yyy;q=.01, xxx-yyy;q=.01, xxx-yyy;q=.01, xxx-yyy;q=.01, xxx-yyy;q=.01, "
	                    + "xxx-yyy;q=.01, xxx-yyy;q=.01, xxx-yyy;q=.01, xxx-yyy;q=.01, xxx-yyy;q=.01, xxx-yyy;q=.01, "
	                    + "xxx-yyy;q=.01, xxx-yyy;q=.01, xxx-yyy;q=.01, xxx-yyy;q=.01, xxx-yyy;q=.01, xxx-yyy;q=.01, "
	                    + "xxx-yyy;q=.01, xxx-yyy;q=.01, xxx-yyy;q=.01, xxx-yyy;q=.01, xxx-yyy;q=.01, xxx-yyy;q=.01, "
	                    + "xxx-yyy;q=.01, xxx-yyy;q=.01, xxx-yyy;q=.01, xxx-yyy;q=.01, xxx-yyy;q=.01, xxx-yyy;q=.01, "
	                    + "es", "de;q=.9, fr;q=.9, xxx-yyy, sr;q=.8" };
        [Test]
        public void TestAcceptLanguage()
        {
            for (int i = 0; i < (ACCEPT_LANGUAGE_HTTP.Length); i++)
            {
                bool expectBoolean = Boolean.Parse(ACCEPT_LANGUAGE_TESTS[i][1]);
                String expectLocale = ACCEPT_LANGUAGE_TESTS[i][0];

                Logln("#" + i + ": expecting: " + expectLocale + " ("
                        + expectBoolean + ")");

                bool[] r = { false };
                ULocale n = IBM.ICU.Util.ULocale.AcceptLanguage(ACCEPT_LANGUAGE_HTTP[i], r);
                if ((n == null) && (expectLocale != null))
                {
                    Errln("result was null! line #" + i);
                    continue;
                }
                if (((n == null) && (expectLocale == null))
                        || (n.ToString().Equals(expectLocale)))
                {
                    Logln(" locale: OK.");
                }
                else
                {
                    Errln("expected " + expectLocale + " but got " + n.ToString());
                }
                if (expectBoolean.Equals((bool)(r[0])))
                {
                    Logln(" bool: OK.");
                }
                else
                {
                    Errln("bool: not OK, was " + (r[0]).ToString()
                            + " expected " + expectBoolean.ToString());
                }
            }
        }

        private ULocale[] StringToULocaleArray(String acceptLanguageList)
        {
            // following code is copied from
            // ULocale.acceptLanguage(String acceptLanguageList, ULocale[]
            // availableLocales, boolean[] fallback)


            // 1st: parse out the acceptLanguageList into an array

            SortedList map = new SortedList();

            int l = acceptLanguageList.Length;
            int n;
            for (n = 0; n < l; n++)
            {
                int itemEnd = acceptLanguageList.IndexOf(',', n);
                if (itemEnd == -1)
                {
                    itemEnd = l;
                }
                int paramEnd = acceptLanguageList.IndexOf(';', n);
                double q = 1.0d;

                if ((paramEnd != -1) && (paramEnd < itemEnd))
                {
                    /* semicolon (;) is closer than end (,) */
                    int t = paramEnd + 1;
                    while (Character.IsWhitespace(acceptLanguageList[t]))
                    {
                        t++;
                    }
                    if (acceptLanguageList[t] == 'q')
                    {
                        t++;
                    }
                    while (Character.IsWhitespace(acceptLanguageList[t]))
                    {
                        t++;
                    }
                    if (acceptLanguageList[t] == '=')
                    {
                        t++;
                    }
                    while (Character.IsWhitespace(acceptLanguageList[t]))
                    {
                        t++;
                    }
                    try
                    {
                        String val = acceptLanguageList.Substring(t, (itemEnd) - (t))
                                .Trim();
                        q = ((Double)Double.Parse(val, ILOG.J2CsMapping.Util.NumberFormatProvider.NumberFormat));
                    }
                    catch (FormatException nfe)
                    {
                        q = 1.0d;
                    }
                }
                else
                {
                    q = 1.0d; // default
                    paramEnd = itemEnd;
                }

                String loc = acceptLanguageList.Substring(n, (paramEnd) - (n)).Trim();
                int serial = map.Count;
                ULocaleTest.ULocaleAcceptLanguageQ entry = new ULocaleTest.ULocaleAcceptLanguageQ(q, serial);
                ILOG.J2CsMapping.Collections.Collections.Put(map, entry, new ULocale(IBM.ICU.Util.ULocale.Canonicalize(loc))); // sort in
                // reverse
                // order..
                // 1.0, 0.9,
                // 0.8 ..
                // etc
                n = itemEnd; // get next item. (n++ will skip over delimiter)
            }

            ULocale[] acceptList = (ULocale[])ILOG.J2CsMapping.Collections.Generics.Collections.ToArray(map.Values, new ULocale[map.Count]);
            return acceptList;
        }
        [Test]
        public void TestAcceptLanguage2()
        {
            for (int i = 0; i < (ACCEPT_LANGUAGE_HTTP.Length); i++)
            {
                bool expectBoolean = Boolean.Parse(ACCEPT_LANGUAGE_TESTS[i][1]);
                String expectLocale = ACCEPT_LANGUAGE_TESTS[i][0];

                Logln("#" + i + ": expecting: " + expectLocale + " ("
                        + expectBoolean + ")");

                bool[] r = { false };
                ULocale n = IBM.ICU.Util.ULocale.AcceptLanguage(
                        StringToULocaleArray(ACCEPT_LANGUAGE_HTTP[i]), r);
                if ((n == null) && (expectLocale != null))
                {
                    Errln("result was null! line #" + i);
                    continue;
                }
                if (((n == null) && (expectLocale == null))
                        || (n.ToString().Equals(expectLocale)))
                {
                    Logln(" locale: OK.");
                }
                else
                {
                    Errln("expected " + expectLocale + " but got " + n.ToString());
                }
                if (expectBoolean.Equals((bool)(r[0])))
                {
                    Logln(" bool: OK.");
                }
                else
                {
                    Errln("bool: not OK, was " + (r[0]).ToString()
                            + " expected " + expectBoolean.ToString());
                }
            }
        }
        [Test]
        public void TestJB3962()
        {
            ULocale loc = new ULocale("de_CH");
            String disp = loc.GetDisplayName(IBM.ICU.Util.ULocale.GERMAN);
            if (!disp.Equals("Deutsch (Schweiz)"))
            {
                Errln("Did not get the expected display name for de_CH locale. Got: "
                        + IBM.ICU.Charset.TestFmwk.Prettify(disp));
            }
        }
        [Test]
        public void TestAddLikelySubtags()
        {
            String[][] data = {
	                new String[] { "en", "en_Latn_US" },
	                new String[] { "en_US_BOSTON", "en_Latn_US_BOSTON" },
	                new String[] { "th@calendar=buddhist",
	                        "th_Thai_TH@calendar=buddhist" },
	                new String[] { "ar_ZZ", "ar_Arab_EG" },
	                new String[] { "cch", "cch_Latn_NG" },
	                new String[] { "zh", "zh_Hans_CN" },
	                new String[] { "zh_TW", "zh_Hant_TW" },
	                new String[] { "zh_HK", "zh_Hant_HK" },
	                new String[] { "zh_Hant", "zh_Hant_TW" },
	                new String[] { "zh_Zzzz_CN", "zh_Hans_CN" },
	                new String[] { "und_US", "en_Latn_US" },
	                new String[] { "und_HK", "zh_Hant_HK" } };
            for (int i = 0; i < data.Length; i++)
            {
                ULocale org = new ULocale(data[i][0]);
                ULocale res = IBM.ICU.Util.ULocale.AddLikelySubtag(org);
                if (!res.ToString().Equals(data[i][1]))
                {
                    Errln("Original: " + data[i][0] + " Expected: " + data[i][1]
                            + " - but got " + res.ToString());
                }
            }
        }

        internal class NFactory : IBM.ICU.Text.NumberFormat.SimpleNumberFormatFactory
        {
            internal NumberFormat proto;

            internal ULocale locale;

            public NFactory(ULocale loc, NumberFormat fmt)
                : base(loc)
            {
                this.locale = loc;
                this.proto = fmt;
            }

            public override NumberFormat CreateFormat(ULocale loc, int formatType)
            {
                return (NumberFormat)((locale.Equals(loc)) ? proto.Clone()
                        : null);
            }
        }

        internal class ULocaleAcceptLanguageQ : IComparable
        {
            private double q;

            private double serial;

            public ULocaleAcceptLanguageQ(double theq, int theserial)
            {
                q = theq;
                serial = theserial;
            }

            public virtual int CompareTo(Object o)
            {
                ULocaleTest.ULocaleAcceptLanguageQ other = (ULocaleTest.ULocaleAcceptLanguageQ)o;
                if (q > other.q)
                { // reverse - to sort in descending order
                    return -1;
                }
                else if (q < other.q)
                {
                    return 1;
                }
                if (serial < other.serial)
                {
                    return -1;
                }
                else if (serial > other.serial)
                {
                    return 1;
                }
                else
                {
                    return 0; // same object
                }
            }
        }
    }
}
