// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/13/10 4:02 PM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 1996-2007, International Business Machines Corporation and    
/// others. All Rights Reserved.                                                
/// </summary>
///
namespace IBM.ICU.Charset
{

    using IBM.ICU.Impl;
    using IBM.ICU.Util;
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.IO;
    using System.Runtime.CompilerServices;
    using System.Text;
    using NUnit.Framework;

    /// <summary>
    /// Testing class for Trie. Tests here will be simple, since both CharTrie and
    /// IntTrie are very similar and are heavily used in other parts of ICU4J. Codes
    /// using Tries are expected to have detailed tests.
    /// </summary>
    ///
    public sealed class TrieTest : TestFmwk
    {
        // constructor ---------------------------------------------------

        /// <summary>
        /// Constructor
        /// </summary>
        ///
        public TrieTest()
        {
        }

        // public methods -----------------------------------------------

        public static void Main(String[] arg)
        {
            TrieTest test = new TrieTest();
            try
            {
                test.Run(arg);
            }
            catch (Exception e)
            {
                test.Errln("Error testing trietest");
            }
        }

        /// <summary>
        /// Values for setting possibly overlapping, out-of-order ranges of values
        /// </summary>
        ///
        private sealed class SetRange
        {
            internal SetRange(int start, int limit, int value_ren, bool overwrite)
            {
                this.start = start;
                this.limit = limit;
                this.value_ren = value_ren;
                this.overwrite = overwrite;
            }

            internal int start, limit;

            internal int value_ren;

            internal bool overwrite;
        }

        /// <summary>
        /// Values for testing: value is set from the previous boundary's limit to
        /// before this boundary's limit
        /// </summary>
        ///
        private sealed class CheckRange
        {
            internal CheckRange(int limit_0, int value_ren)
            {
                this.limit = limit_0;
                this.value_ren = value_ren;
            }

            internal int limit;

            internal int value_ren;
        }

        private sealed class _testFoldedValue :
                TrieBuilder.DataManipulate
        {
            public _testFoldedValue(IntTrieBuilder builder)
            {
                m_builder_ = builder;
            }

            public int GetFoldedValue(int start_0, int offset)
            {
                int foldedValue = 0;
                int limit_1 = start_0 + 0x400;
                while (start_0 < limit_1)
                {
                    int value_ren = m_builder_.GetValue(start_0);
                    if (m_builder_.IsInZeroBlock(start_0))
                    {
                        start_0 += IBM.ICU.Impl.TrieBuilder.DATA_BLOCK_LENGTH;
                    }
                    else
                    {
                        foldedValue |= value_ren;
                        ++start_0;
                    }
                }

                if (foldedValue != 0)
                {
                    return (offset << 16) | foldedValue;
                }
                return 0;
            }

            private IntTrieBuilder m_builder_;
        }

        private sealed class _testFoldingOffset :
                Trie.DataManipulate
        {
            public int GetFoldingOffset(int value_ren)
            {
                return (int)(((uint)value_ren) >> 16);
            }
        }

        private sealed class _testEnumValue : TrieIterator
        {
            public _testEnumValue(Trie data)
                : base(data)
            {
            }

            protected override int Extract(int value_ren)
            {
                return value_ren ^ 0x5555;
            }
        }

        private void _testTrieIteration(IntTrie trie, TrieTest.CheckRange[] checkRanges,
                int countCheckRanges)
        {
            // write a string
            int countValues = 0;
            StringBuilder s = new StringBuilder();
            int[] values = new int[30];
            for (int i = 0; i < countCheckRanges; ++i)
            {
                int c = checkRanges[i].limit;
                if (c != 0)
                {
                    --c;
                    IBM.ICU.Text.UTF16.Append(s, c);
                    values[countValues++] = checkRanges[i].value_ren;
                }
            }
            int limit_0 = s.Length;
            // try forward
            int p = 0;
            int i_1 = 0;
            while (p < limit_0)
            {
                int c_2 = IBM.ICU.Text.UTF16.CharAt(s, p);
                p += IBM.ICU.Text.UTF16.GetCharCount(c_2);
                int value_ren = trie.GetCodePointValue(c_2);
                if (value_ren != values[i_1])
                {
                    Errln("wrong value from UTRIE_NEXT(U+" + ILOG.J2CsMapping.Util.IlNumber.ToString(c_2, 16)
                            + "): 0x" + ILOG.J2CsMapping.Util.IlNumber.ToString(value_ren, 16)
                            + " instead of 0x" + ILOG.J2CsMapping.Util.IlNumber.ToString(values[i_1], 16));
                }
                // unlike the c version lead is 0 if c is non-supplementary
                char lead = IBM.ICU.Text.UTF16.GetLeadSurrogate(c_2);
                char trail = IBM.ICU.Text.UTF16.GetTrailSurrogate(c_2);
                if ((lead == 0) ? trail != s[p - 1] : !IBM.ICU.Text.UTF16
                        .IsLeadSurrogate(lead)
                        || !IBM.ICU.Text.UTF16.IsTrailSurrogate(trail)
                        || lead != s[p - 2] || trail != s[p - 1])
                {
                    Errln("wrong (lead, trail) from UTRIE_NEXT(U+"
                            + ILOG.J2CsMapping.Util.IlNumber.ToString(c_2, 16));
                    continue;
                }
                if (lead != 0)
                {
                    value_ren = trie.GetLeadValue(lead);
                    value_ren = trie.GetTrailValue(value_ren, trail);
                    if (value_ren != trie.GetSurrogateValue(lead, trail)
                            && value_ren != values[i_1])
                    {
                        Errln("wrong value from getting supplementary "
                                + "values (U+" + ILOG.J2CsMapping.Util.IlNumber.ToString(c_2, 16) + "): 0x"
                                + ILOG.J2CsMapping.Util.IlNumber.ToString(value_ren, 16) + " instead of 0x"
                                + ILOG.J2CsMapping.Util.IlNumber.ToString(values[i_1], 16));
                    }
                }
                ++i_1;
            }
        }

        private void _testTrieRanges(TrieTest.SetRange[] setRanges, int countSetRanges,
                TrieTest.CheckRange[] checkRanges, int countCheckRanges, bool latin1Linear)
        {
            IntTrieBuilder newTrie = new IntTrieBuilder(null, 2000,
                    checkRanges[0].value_ren, checkRanges[0].value_ren, latin1Linear);

            // set values from setRanges[]
            bool ok = true;
            for (int i = 0; i < countSetRanges; ++i)
            {
                int start_0 = setRanges[i].start;
                int limit_1 = setRanges[i].limit;
                int value_ren = setRanges[i].value_ren;
                bool overwrite_2 = setRanges[i].overwrite;
                if ((limit_1 - start_0) == 1 && overwrite_2)
                {
                    ok &= newTrie.SetValue(start_0, value_ren);
                }
                else
                {
                    ok &= newTrie.SetRange(start_0, limit_1, value_ren, overwrite_2);
                }
            }
            if (!ok)
            {
                Errln("setting values into a trie failed");
                return;
            }

            // verify that all these values are in the new Trie
            int start_3 = 0;
            for (int i_4 = 0; i_4 < countCheckRanges; ++i_4)
            {
                int limit_5 = checkRanges[i_4].limit;
                int value_6 = checkRanges[i_4].value_ren;

                while (start_3 < limit_5)
                {
                    if (value_6 != newTrie.GetValue(start_3))
                    {
                        Errln("newTrie [U+" + ILOG.J2CsMapping.Util.IlNumber.ToString(start_3, 16) + "]==0x"
                                + ILOG.J2CsMapping.Util.IlNumber.ToString(newTrie.GetValue(start_3), 16)
                                + " instead of 0x" + ILOG.J2CsMapping.Util.IlNumber.ToString(value_6, 16));
                    }
                    ++start_3;
                }
            }

            IntTrie trie = newTrie.Serialize(new TrieTest._testFoldedValue(newTrie),
                    new TrieTest._testFoldingOffset());

            // test linear Latin-1 range from utrie_getData()
            if (latin1Linear)
            {
                start_3 = 0;
                for (int i_7 = 0; i_7 < countCheckRanges && start_3 <= 0xff; ++i_7)
                {
                    int limit_8 = checkRanges[i_7].limit;
                    int value_9 = checkRanges[i_7].value_ren;

                    while (start_3 < limit_8 && start_3 <= 0xff)
                    {
                        if (value_9 != trie.GetLatin1LinearValue((char)start_3))
                        {
                            Errln("IntTrie.getLatin1LinearValue[U+"
                                    + ILOG.J2CsMapping.Util.IlNumber.ToString(start_3, 16)
                                    + "]==0x"
                                    + ILOG.J2CsMapping.Util.IlNumber.ToString(trie
                                                                            .GetLatin1LinearValue((char)start_3), 16)
                                    + " instead of 0x" + ILOG.J2CsMapping.Util.IlNumber.ToString(value_9, 16));
                        }
                        ++start_3;
                    }
                }
            }

            if (latin1Linear != trie.IsLatin1Linear())
            {
                Errln("trie serialization did not preserve " + "Latin-1-linearity");
            }

            // verify that all these values are in the serialized Trie
            start_3 = 0;
            for (int i_10 = 0; i_10 < countCheckRanges; ++i_10)
            {
                int limit_11 = checkRanges[i_10].limit;
                int value_12 = checkRanges[i_10].value_ren;

                if (start_3 == 0xd800)
                {
                    // skip surrogates
                    start_3 = limit_11;
                    continue;
                }

                while (start_3 < limit_11)
                {
                    if (start_3 <= 0xffff)
                    {
                        int value2 = trie.GetBMPValue((char)start_3);
                        if (value_12 != value2)
                        {
                            Errln("serialized trie.getBMPValue(U+"
                                    + ILOG.J2CsMapping.Util.IlNumber.ToString(start_3, 16) + " == 0x"
                                    + ILOG.J2CsMapping.Util.IlNumber.ToString(value2, 16)
                                    + " instead of 0x" + ILOG.J2CsMapping.Util.IlNumber.ToString(value_12, 16));
                        }
                        if (!IBM.ICU.Text.UTF16.IsLeadSurrogate((char)start_3))
                        {
                            value2 = trie.GetLeadValue((char)start_3);
                            if (value_12 != value2)
                            {
                                Errln("serialized trie.getLeadValue(U+"
                                        + ILOG.J2CsMapping.Util.IlNumber.ToString(start_3, 16) + " == 0x"
                                        + ILOG.J2CsMapping.Util.IlNumber.ToString(value2, 16)
                                        + " instead of 0x"
                                        + ILOG.J2CsMapping.Util.IlNumber.ToString(value_12, 16));
                            }
                        }
                    }
                    int value2_13 = trie.GetCodePointValue(start_3);
                    if (value_12 != value2_13)
                    {
                        Errln("serialized trie.getCodePointValue(U+"
                                + ILOG.J2CsMapping.Util.IlNumber.ToString(start_3, 16) + ")==0x"
                                + ILOG.J2CsMapping.Util.IlNumber.ToString(value2_13, 16) + " instead of 0x"
                                + ILOG.J2CsMapping.Util.IlNumber.ToString(value_12, 16));
                    }
                    ++start_3;
                }
            }

            // enumerate and verify all ranges

            int enumRanges = 1;
            TrieIterator iter = new TrieTest._testEnumValue(trie);
            RangeValueIterator_Constants.Element result = new RangeValueIterator_Constants.Element();
            while (iter.Next(result))
            {
                if (result.start != checkRanges[enumRanges - 1].limit
                        || result.limit != checkRanges[enumRanges].limit
                        || (result.value_ren ^ 0x5555) != checkRanges[enumRanges].value_ren)
                {
                    Errln("utrie_enum() delivers wrong range [U+"
                            + ILOG.J2CsMapping.Util.IlNumber.ToString(result.start, 16)
                            + "..U+"
                            + ILOG.J2CsMapping.Util.IlNumber.ToString(result.limit, 16)
                            + "].0x"
                            + ILOG.J2CsMapping.Util.IlNumber.ToString(result.value_ren ^ 0x5555, 16)
                            + " instead of [U+"
                            + ILOG.J2CsMapping.Util.IlNumber.ToString(checkRanges[enumRanges - 1].limit, 16)
                            + "..U+"
                            + ILOG.J2CsMapping.Util.IlNumber.ToString(checkRanges[enumRanges].limit, 16)
                            + "].0x"
                            + ILOG.J2CsMapping.Util.IlNumber.ToString(checkRanges[enumRanges].value_ren, 16));
                }
                enumRanges++;
            }

            // test linear Latin-1 range
            if (trie.IsLatin1Linear())
            {
                for (start_3 = 0; start_3 < 0x100; ++start_3)
                {
                    if (trie.GetLatin1LinearValue((char)start_3) != trie
                            .GetLeadValue((char)start_3))
                    {
                        Errln("trie.getLatin1LinearValue[U+"
                                + ILOG.J2CsMapping.Util.IlNumber.ToString(start_3, 16)
                                + "]=0x"
                                + ILOG.J2CsMapping.Util.IlNumber.ToString(trie
                                                                    .GetLatin1LinearValue((char)start_3), 16)
                                + " instead of 0x"
                                + ILOG.J2CsMapping.Util.IlNumber.ToString(trie
                                                                    .GetLeadValue((char)start_3), 16));
                    }
                }
            }

            _testTrieIteration(trie, checkRanges, countCheckRanges);
        }

        private void _testTrieRanges2(TrieTest.SetRange[] setRanges, int countSetRanges,
                TrieTest.CheckRange[] checkRanges, int countCheckRanges)
        {
            _testTrieRanges(setRanges, countSetRanges, checkRanges,
                    countCheckRanges, false);

            _testTrieRanges(setRanges, countSetRanges, checkRanges,
                    countCheckRanges, true);
        }

        private void _testTrieRanges4(TrieTest.SetRange[] setRanges, int countSetRanges,
                TrieTest.CheckRange[] checkRanges, int countCheckRanges)
        {
            _testTrieRanges2(setRanges, countSetRanges, checkRanges,
                    countCheckRanges);
        }

        // test data ------------------------------------------------------------

        /// <summary>
        /// set consecutive ranges, even with value 0
        /// </summary>
        ///
        private static TrieTest.SetRange[] setRanges1 = { new TrieTest.SetRange (0, 0x20, 0, false),
	            new TrieTest.SetRange (0x20, 0xa7, 0x1234, false),
	            new TrieTest.SetRange (0xa7, 0x3400, 0, false),
	            new TrieTest.SetRange (0x3400, 0x9fa6, 0x6162, false),
	            new TrieTest.SetRange (0x9fa6, 0xda9e, 0x3132, false),
	            new TrieTest.SetRange (0xdada, 0xeeee, 0x87ff, false),
	            new TrieTest.SetRange (0xeeee, 0x11111, 1, false),
	            new TrieTest.SetRange (0x11111, 0x44444, 0x6162, false),
	            new TrieTest.SetRange (0x44444, 0x60003, 0, false),
	            new TrieTest.SetRange (0xf0003, 0xf0004, 0xf, false),
	            new TrieTest.SetRange (0xf0004, 0xf0006, 0x10, false),
	            new TrieTest.SetRange (0xf0006, 0xf0007, 0x11, false),
	            new TrieTest.SetRange (0xf0007, 0xf0020, 0x12, false),
	            new TrieTest.SetRange (0xf0020, 0x110000, 0, false) };

        private static TrieTest.CheckRange[] checkRanges1 = { new TrieTest.CheckRange (0, 0),
	            new TrieTest.CheckRange (0x20, 0), new TrieTest.CheckRange (0xa7, 0x1234),
	            new TrieTest.CheckRange (0x3400, 0), new TrieTest.CheckRange (0x9fa6, 0x6162),
	            new TrieTest.CheckRange (0xda9e, 0x3132), new TrieTest.CheckRange (0xdada, 0),
	            new TrieTest.CheckRange (0xeeee, 0x87ff), new TrieTest.CheckRange (0x11111, 1),
	            new TrieTest.CheckRange (0x44444, 0x6162), new TrieTest.CheckRange (0xf0003, 0),
	            new TrieTest.CheckRange (0xf0004, 0xf), new TrieTest.CheckRange (0xf0006, 0x10),
	            new TrieTest.CheckRange (0xf0007, 0x11), new TrieTest.CheckRange (0xf0020, 0x12),
	            new TrieTest.CheckRange (0x110000, 0) };

        /// <summary>
        /// set some interesting overlapping ranges
        /// </summary>
        ///
        private static TrieTest.SetRange[] setRanges2 = {
	            new TrieTest.SetRange (0x21, 0x7f, 0x5555, true),
	            new TrieTest.SetRange (0x2f800, 0x2fedc, 0x7a, true),
	            new TrieTest.SetRange (0x72, 0xdd, 3, true),
	            new TrieTest.SetRange (0xdd, 0xde, 4, false),
	            new TrieTest.SetRange (0x2f987, 0x2fa98, 5, true),
	            new TrieTest.SetRange (0x2f777, 0x2f833, 0, true),
	            new TrieTest.SetRange (0x2f900, 0x2ffee, 1, false),
	            new TrieTest.SetRange (0x2ffee, 0x2ffef, 2, true) };

        private static TrieTest.CheckRange[] checkRanges2 = { new TrieTest.CheckRange (0, 0),
	            new TrieTest.CheckRange (0x21, 0), new TrieTest.CheckRange (0x72, 0x5555),
	            new TrieTest.CheckRange (0xdd, 3), new TrieTest.CheckRange (0xde, 4),
	            new TrieTest.CheckRange (0x2f833, 0), new TrieTest.CheckRange (0x2f987, 0x7a),
	            new TrieTest.CheckRange (0x2fa98, 5), new TrieTest.CheckRange (0x2fedc, 0x7a),
	            new TrieTest.CheckRange (0x2ffee, 1), new TrieTest.CheckRange (0x2ffef, 2),
	            new TrieTest.CheckRange (0x110000, 0) };

        /// <summary>
        /// use a non-zero initial value
        /// </summary>
        ///
        private static TrieTest.SetRange[] setRanges3 = {
	            new TrieTest.SetRange (0x31, 0xa4, 1, false),
	            new TrieTest.SetRange (0x3400, 0x6789, 2, false),
	            new TrieTest.SetRange (0x30000, 0x34567, 9, true),
	            new TrieTest.SetRange (0x45678, 0x56789, 3, true) };

        private static TrieTest.CheckRange[] checkRanges3 = { new TrieTest.CheckRange (0, 9),
	            new TrieTest.CheckRange (0x31, 9), new TrieTest.CheckRange (0xa4, 1),
	            new TrieTest.CheckRange (0x3400, 9), new TrieTest.CheckRange (0x6789, 2),
	            new TrieTest.CheckRange (0x45678, 9), new TrieTest.CheckRange (0x56789, 3),
	            new TrieTest.CheckRange (0x110000, 9) };

        public void TestIntTrie()
        {
            _testTrieRanges4(setRanges1, setRanges1.Length, checkRanges1,
                    checkRanges1.Length);
            _testTrieRanges4(setRanges2, setRanges2.Length, checkRanges2,
                    checkRanges2.Length);
            _testTrieRanges4(setRanges3, setRanges3.Length, checkRanges3,
                    checkRanges3.Length);
        }

        public void TestCharValues()
        {
            CharTrie trie = null;
            try
            {
                trie = IBM.ICU.Impl.UCharacterProperty.GetInstance().m_trie_;
            }
            catch (Exception e)
            {
                Warnln("Error creating ucharacter trie");
                return;
            }

            for (int i = 0; i < 0xFFFF; i++)
            {
                if (i < 0xFF
                        && trie.GetBMPValue((char)i) != trie
                                .GetLatin1LinearValue((char)i))
                {
                    Errln("For latin 1 codepoint, getBMPValue should be the same "
                            + "as getLatin1LinearValue");
                }
                if (trie.GetBMPValue((char)i) != trie.GetCodePointValue(i))
                {
                    Errln("For BMP codepoint, getBMPValue should be the same "
                            + "as getCodepointValue");
                }
            }
            for (int i_0 = 0x10000; i_0 < 0x10ffff; i_0++)
            {
                char lead = IBM.ICU.Text.UTF16.GetLeadSurrogate(i_0);
                char trail = IBM.ICU.Text.UTF16.GetTrailSurrogate(i_0);
                char value_ren = trie.GetCodePointValue(i_0);
                if (value_ren != trie.GetSurrogateValue(lead, trail)
                        || value_ren != trie.GetTrailValue(trie.GetLeadValue(lead),
                                trail))
                {
                    Errln("For Non-BMP codepoints, getSurrogateValue should be "
                            + "the same s getCodepointValue and getTrailValue");
                }
            }
        }

        private class DummyGetFoldingOffset : Trie.DataManipulate
        {
            public virtual int GetFoldingOffset(int value_ren)
            {
                return -1; /*
	                        * never get non-initialValue data for supplementary code
	                        * points
	                        */
            }
        }

        public void TestDummyCharTrie()
        {
            CharTrie trie;
            int initialValue = 0x313, leadUnitValue = 0xaffe;
            int value_ren;
            int c;
            trie = new CharTrie(initialValue, leadUnitValue,
                    new TrieTest.DummyGetFoldingOffset());

            /* test that all code points have initialValue */
            for (c = 0; c <= 0x10ffff; ++c)
            {
                value_ren = trie.GetCodePointValue(c);
                if (value_ren != initialValue)
                {
                    Errln("CharTrie/dummy.getCodePointValue(c)(U+" + IBM.ICU.Charset.TestFmwk.Hex(c)
                            + ")=0x" + IBM.ICU.Charset.TestFmwk.Hex(value_ren) + " instead of 0x"
                            + IBM.ICU.Charset.TestFmwk.Hex(initialValue));
                }
            }

            /* test that the lead surrogate code units have leadUnitValue */
            for (c = 0xd800; c <= 0xdbff; ++c)
            {
                value_ren = trie.GetLeadValue((char)c);
                if (value_ren != leadUnitValue)
                {
                    Errln("CharTrie/dummy.getLeadValue(c)(U+" + IBM.ICU.Charset.TestFmwk.Hex(c) + ")=0x"
                            + IBM.ICU.Charset.TestFmwk.Hex(value_ren) + " instead of 0x" + IBM.ICU.Charset.TestFmwk.Hex(leadUnitValue));
                }
            }
        }

        public void TestDummyIntTrie()
        {
            IntTrie trie;
            int initialValue = 0x01234567, leadUnitValue = -1985229329;
            int value_ren;
            int c;
            trie = new IntTrie(initialValue, leadUnitValue,
                    new TrieTest.DummyGetFoldingOffset());

            /* test that all code points have initialValue */
            for (c = 0; c <= 0x10ffff; ++c)
            {
                value_ren = trie.GetCodePointValue(c);
                if (value_ren != initialValue)
                {
                    Errln("IntTrie/dummy.getCodePointValue(c)(U+" + IBM.ICU.Charset.TestFmwk.Hex(c) + ")=0x"
                            + IBM.ICU.Charset.TestFmwk.Hex(value_ren) + " instead of 0x" + IBM.ICU.Charset.TestFmwk.Hex(initialValue));
                }
            }

            /* test that the lead surrogate code units have leadUnitValue */
            for (c = 0xd800; c <= 0xdbff; ++c)
            {
                value_ren = trie.GetLeadValue((char)c);
                if (value_ren != leadUnitValue)
                {
                    Errln("IntTrie/dummy.getLeadValue(c)(U+" + IBM.ICU.Charset.TestFmwk.Hex(c) + ")=0x"
                            + IBM.ICU.Charset.TestFmwk.Hex(value_ren) + " instead of 0x" + IBM.ICU.Charset.TestFmwk.Hex(leadUnitValue));
                }
            }
        }
    }
}
