// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/13/10 4:01 PM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 1996-2007, international Business Machines Corporation and    
/// others. All Rights Reserved.                                                
/// </summary>
///
namespace IBM.ICU.Charset {
		
	using IBM.ICU.Text;
	using ILOG.J2CsMapping.Collections;
	using ILOG.J2CsMapping.Collections.Generics;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Text;
	
	/// <summary>
	/// Provides more flexible formatting of UnicodeSet patterns.
	/// </summary>
	///
	public class PrettyPrinter {
	    public PrettyPrinter() {
	        ((RuleBasedCollator) spaceComp)
	                .SetStrength(IBM.ICU.Text.Collator.PRIMARY);
	        SetOrdering(IBM.ICU.Text.Collator
	                .GetInstance(IBM.ICU.Util.ULocale.ROOT));
	        this.first = true;
	        this.target = new StringBuilder();
	        this.firstCodePoint = -2;
	        this.lastCodePoint = -2;
	        this.compressRanges = true;
	        this.lastString = "";
	        this.toQuote = new UnicodeSet(patternWhitespace);
	        this.quoter = null;
	        this.spaceComp = IBM.ICU.Text.Collator.GetInstance(IBM.ICU.Util.ULocale.ROOT);
	    }
	
	    private static readonly UnicodeSet patternWhitespace = (UnicodeSet) new UnicodeSet(
	            "[[:Cn:][:Default_Ignorable_Code_Point:][:patternwhitespace:]]")
	            .Freeze();
	
	    private static readonly UnicodeSet sortAtEnd = (UnicodeSet) new UnicodeSet(
	            "[[:Cn:][:Cs:][:Co:][:Ideographic:]]").Freeze();
	
	    private bool first;
	
	    private StringBuilder target;
	
	    private int firstCodePoint;
	
	    private int lastCodePoint;
	
	    private bool compressRanges;
	
	    private String lastString;
	
	    private UnicodeSet toQuote;
	
	    private Transliterator quoter;
	
	    private IComparer ordering;
	
	    private IComparer spaceComp;
	    public Transliterator GetQuoter() {
	        return quoter;
	    }
	
	    public PrettyPrinter SetQuoter(Transliterator quoter_0) {
	        this.quoter = quoter_0;
	        return this; // for chaining
	    }
	
	    public bool IsCompressRanges() {
	        return compressRanges;
	    }
	
	    
	    /// <param name="compressRanges_0">if you want abcde instead of a-e, make this false</param>
	    /// <returns></returns>
	    public PrettyPrinter SetCompressRanges(bool compressRanges_0) {
	        this.compressRanges = compressRanges_0;
	        return this;
	    }
	
	    public IComparer GetOrdering() {
	        return ordering;
	    }
	
	    
	    /// <param name="ordering_0">the resulting ordering of the list of characters in thepattern</param>
	    /// <returns></returns>
	    public PrettyPrinter SetOrdering(IComparer ordering_0) {
	        this.ordering = new IBM.ICU.Charset.CollectionUtilities.MultiComparator (new IComparer[] { ordering_0,
	                new UTF16.StringComparator(true, false, 0) });
	        return this;
	    }
	
	    public IComparer GetSpaceComparator() {
	        return spaceComp;
	    }
	
	    
	    /// <param name="spaceComp_0">if the comparison returns non-zero, then a space will beinserted between characters</param>
	    /// <returns>this, for chaining</returns>
	    public PrettyPrinter SetSpaceComparator(IComparer spaceComp_0) {
	        this.spaceComp = spaceComp_0;
	        return this;
	    }
	
	    public UnicodeSet GetToQuote() {
	        return toQuote;
	    }
	
	    /// <summary>
	    /// a UnicodeSet of extra characters to quote with \\uXXXX-style escaping
	    /// (will automatically quote pattern whitespace)
	    /// </summary>
	    ///
	    /// <param name="toQuote_0"></param>
	    public PrettyPrinter SetToQuote(UnicodeSet toQuote_0) {
	        toQuote_0 = (UnicodeSet) toQuote_0.Clone();
	        toQuote_0.AddAll(patternWhitespace);
	        this.toQuote = toQuote_0;
	        return this;
	    }
	
	    /// <summary>
	    /// Get the pattern for a particular set.
	    /// </summary>
	    ///
	    /// <param name="uset"></param>
	    /// <returns>formatted UnicodeSet</returns>
	    public String ToPattern(UnicodeSet uset) {
	        first = true;
	        UnicodeSet putAtEnd = new UnicodeSet(uset).RetainAll(sortAtEnd); // remove
	                                                                         // all
	                                                                         // the
	                                                                         // unassigned
	                                                                         // gorp
	                                                                         // for
	                                                                         // now
	        // make sure that comparison separates all strings, even canonically
	        // equivalent ones
	        ILOG.J2CsMapping.Collections.ISet orderedStrings = new SortedSet(ordering);
	        for (UnicodeSetIterator it = new UnicodeSetIterator(uset); it
	                .NextRange();) {
	            if (it.codepoint == IBM.ICU.Text.UnicodeSetIterator.IS_STRING) {
	                ILOG.J2CsMapping.Collections.Generics.Collections.Add(orderedStrings,it.str0);
	            } else {
	                for (int i = it.codepoint; i <= it.codepointEnd; ++i) {
	                    if (!putAtEnd.Contains(i)) {
	                        ILOG.J2CsMapping.Collections.Generics.Collections.Add(orderedStrings,IBM.ICU.Text.UTF16.ValueOf(i));
	                    }
	                }
	            }
	        }
	        target.Length=0;
	        target.Append("[");
	        for (IIterator it_0 = new ILOG.J2CsMapping.Collections.IteratorAdapter(orderedStrings.GetEnumerator()); it_0.HasNext();) {
	            AppendUnicodeSetItem((String) it_0.Next());
	        }
	        for (UnicodeSetIterator it_1 = new UnicodeSetIterator(putAtEnd); it_1
	                .Next();) { // add back the unassigned gorp
	            AppendUnicodeSetItem(it_1.codepoint);
	        }
	        FlushLast();
	        target.Append("]");
	        String sresult = target.ToString();
	
	        // double check the results. This can be removed once we have more
	        // tests.
	        // try {
	        // UnicodeSet doubleCheck = new UnicodeSet(sresult);
	        // if (!uset.equals(doubleCheck)) {
	        // throw new
	        // IllegalStateException("Failure to round-trip in pretty-print " + uset
	        // + " => " + sresult + "\r\n source-result: " + new
	        // UnicodeSet(uset).removeAll(doubleCheck) + "\r\n result-source: " +
	        // new UnicodeSet(doubleCheck).removeAll(uset));
	        // }
	        // } catch (RuntimeException e) {
	        // throw (RuntimeException) new
	        // IllegalStateException("Failure to round-trip in pretty-print " +
	        // uset).initCause(e);
	        // }
	        return sresult;
	    }
	
	    private PrettyPrinter AppendUnicodeSetItem(String s) {
	        int cp;
	        if (IBM.ICU.Text.UTF16.HasMoreCodePointsThan(s, 1)) {
	            FlushLast();
	            AddSpace(s);
	            target.Append("{");
	            for (int i = 0; i < s.Length; i += IBM.ICU.Text.UTF16.GetCharCount(cp)) {
	                AppendQuoted(cp = IBM.ICU.Text.UTF16.CharAt(s, i));
	            }
	            target.Append("}");
	            lastString = s;
	        } else {
	            AppendUnicodeSetItem(IBM.ICU.Text.UTF16.CharAt(s, 0));
	        }
	        return this;
	    }
	
	    private void AppendUnicodeSetItem(int cp) {
	        if (!compressRanges)
	            FlushLast();
	        if (cp == lastCodePoint + 1) {
	            lastCodePoint = cp; // continue range
	        } else { // start range
	            FlushLast();
	            firstCodePoint = lastCodePoint = cp;
	        }
	    }
	
	    private void AddSpace(String s) {
	        if (first) {
	            first = false;
	        } else if (spaceComp.Compare(s, lastString) != 0) {
	            target.Append(' ');
	        } else {
	            int cp = IBM.ICU.Text.UTF16.CharAt(s, 0);
	            int type = IBM.ICU.Lang.UCharacter.GetType(cp);
	            if (type == IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.NON_SPACING_MARK
	                    || type == IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.ENCLOSING_MARK) {
	                target.Append(' ');
	            } else if (type == IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.SURROGATE
	                    && cp >= IBM.ICU.Text.UTF16.TRAIL_SURROGATE_MIN_VALUE) {
	                target.Append(' '); // make sure we don't accidentally merge two
	                                    // surrogates
	            }
	        }
	    }
	
	    private void FlushLast() {
	        if (lastCodePoint >= 0) {
	            AddSpace(IBM.ICU.Text.UTF16.ValueOf(firstCodePoint));
	            if (firstCodePoint != lastCodePoint) {
	                AppendQuoted(firstCodePoint);
	                target.Append((firstCodePoint + 1 == lastCodePoint) ? ' ' : '-');
	            }
	            AppendQuoted(lastCodePoint);
	            lastString = IBM.ICU.Text.UTF16.ValueOf(lastCodePoint);
	            firstCodePoint = lastCodePoint = -2;
	        }
	    }
	
	    internal PrettyPrinter AppendQuoted(int codePoint) {
	        if (toQuote.Contains(codePoint)) {
	            if (quoter != null) {
	                target.Append(quoter.Transliterate(IBM.ICU.Text.UTF16.ValueOf(codePoint)));
	                return this;
	            }
	            if (codePoint > 0xFFFF) {
	                target.Append("\\U");
	                target.Append(IBM.ICU.Impl.Utility.Hex(codePoint, 8));
	            } else {
	                target.Append("\\u");
	                target.Append(IBM.ICU.Impl.Utility.Hex(codePoint, 4));
	            }
	            return this;
	        }
	        switch (codePoint) {
	        case '[': // SET_OPEN:
	        case ']': // SET_CLOSE:
	        case '-': // HYPHEN:
	        case '^': // COMPLEMENT:
	        case '&': // INTERSECTION:
	        case '\\': // BACKSLASH:
	        case '{':
	        case '}':
	        case '$':
	        case ':':
	            target.Append('\\');
	            break;
	        default:
	            // Escape whitespace
	            if (patternWhitespace.Contains(codePoint)) {
	                target.Append('\\');
	            }
	            break;
	        }
	        IBM.ICU.Text.UTF16.Append(target, codePoint);
	        return this;
	    }
	    // Appender append(String s) {
	    // target.append(s);
	    // return this;
	    // }
	    // public String toString() {
	    // return target.toString();
	    // }
	}
}
