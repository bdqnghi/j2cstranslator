//##header J2SE15
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/13/10 4:01 PM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 //#if defined(FOUNDATION10) || defined(J2SE13)
//#else
/*
 *******************************************************************************
 * Copyright (C) 2002-2007, International Business Machines Corporation and    *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 */
namespace IBM.ICU.Charset {
	
	// TODO integrate this into the test framework
	
	using IBM.ICU.Text;
	using ILOG.J2CsMapping.Collections;
	using ILOG.J2CsMapping.Collections.Generics;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.Globalization;
	using System.IO;
	using System.Runtime.CompilerServices;
	
	// TODO change to use test framework
	public class TestBagFormatter {
	
	    static internal void GeneratePropertyAliases(bool showValues) {
	        GeneratePropertyAliases(showValues, IBM.ICU.Charset.ICUPropertyFactory.Make());
	    }
	
	    static internal void GeneratePropertyAliases(bool showValues,
	            UnicodeProperty.Factory ups) {
	        ComparatorInfo order = System.Globalization.ComparatorInfo.GetInstance(System.Globalization.CultureInfo.CreateSpecificCulture("en"));
	        SortedSet props = new SortedSet(order);
	        SortedSet values = new SortedSet(order);
	        BagFormatter bf = new BagFormatter();
	        ILOG.J2CsMapping.Collections.Generics.Collections.AddAll(ups.GetAvailableNames(),props);
	        for (int i = IBM.ICU.Charset.UnicodeProperty.BINARY; i < IBM.ICU.Charset.UnicodeProperty.LIMIT_TYPE; ++i) {
	            System.Console.Out.WriteLine(IBM.ICU.Charset.UnicodeProperty.GetTypeName(i));
	            IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(props.GetEnumerator());
	            while (it.HasNext()) {
	                String propAlias = (String) it.Next();
	                UnicodeProperty up = ups.GetProperty(propAlias);
	                int type = up.GetType();
	                if (type != i)
	                    continue;
	                System.Console.Out.WriteLine();
	                System.Console.Out.WriteLine(propAlias + "\t"
	                        + bf.Join(up.GetNameAliases()));
	                if (!showValues)
	                    continue;
	                ILOG.J2CsMapping.Collections.Collections.Clear(values);
	                if (type == IBM.ICU.Charset.UnicodeProperty.NUMERIC
	                        || type == IBM.ICU.Charset.UnicodeProperty.EXTENDED_NUMERIC) {
	                    UnicodeMap um = new UnicodeMap();
	                    um.PutAll(up);
	                    System.Console.Out.WriteLine(um.ToString(new TestBagFormatter.NumberComparator ()));
	                    continue;
	                }
	                ILOG.J2CsMapping.Collections.Collections.Clear(values);
	                ILOG.J2CsMapping.Collections.Generics.Collections.AddAll(up.GetAvailableValues(),values);
	                IIterator it2 = new ILOG.J2CsMapping.Collections.IteratorAdapter(values.GetEnumerator());
	                while (it2.HasNext()) {
	                    String valueAlias = (String) it2.Next();
	                    System.Console.Out.WriteLine("\t"
	                            + bf.Join(valueAlias + "\t"
	                                    + up.GetValueAliases(valueAlias)));
	                }
	            }
	        }
	    }
	
	    internal class NumberComparator : IComparer {
	        public virtual int Compare(Object o1, Object o2) {
	            if (o1 == o2)
	                return 0;
	            if (o1 == null)
	                return 1;
	            if (o2 == null)
	                return -1;
	            double n1 = ((Double )Double.Parse((String) o1,ILOG.J2CsMapping.Util.NumberFormatProvider.NumberFormat));
	            double n2 = ((Double )Double.Parse((String) o2,ILOG.J2CsMapping.Util.NumberFormatProvider.NumberFormat));
	            return (n1 < n2) ? -1 : (n1 > n2) ? 1 : 0;
	        }
	    }
	
	    public static void Main(String[] args) {
	        System.Console.Out.WriteLine("Start");
	        try {
	            // readCharacters();
	            UnicodeProperty prop = IBM.ICU.Charset.ICUPropertyFactory.Make().GetProperty(
	                    "Canonicalcombiningclass");
	            prop.GetAvailableValues();
	
	            GeneratePropertyAliases(true);
	
	            BagFormatter bf = new BagFormatter();
	
	            UnicodeSet us = new UnicodeSet("[:gc=nd:]");
	            IBM.ICU.Charset.BagFormatter.CONSOLE.WriteLine("[:gc=nd:]");
	            bf.ShowSetNames(IBM.ICU.Charset.BagFormatter.CONSOLE, us);
	
	            us = new UnicodeSet("[:numeric_value=2:]");
	            IBM.ICU.Charset.BagFormatter.CONSOLE.WriteLine("[:numeric_value=2:]");
	            bf.ShowSetNames(IBM.ICU.Charset.BagFormatter.CONSOLE, us);
	
	            us = new UnicodeSet("[:numeric_type=numeric:]");
	            IBM.ICU.Charset.BagFormatter.CONSOLE.WriteLine("[:numeric_type=numeric:]");
	            bf.ShowSetNames(IBM.ICU.Charset.BagFormatter.CONSOLE, us);
	
	            UnicodeProperty.Factory ups = IBM.ICU.Charset.ICUPropertyFactory.Make();
	            us = ups.GetSet("gc=mn", null, null);
	            IBM.ICU.Charset.BagFormatter.CONSOLE.WriteLine("gc=mn");
	            bf.ShowSetNames(IBM.ICU.Charset.BagFormatter.CONSOLE, us);
	
	            if (true)
	                return;
	            // showNames("Name", ".*MARK.*");
	            // showNames("NFD", "a.+");
	            // showNames("NFD", false);
	            // showNames("Lowercase_Mapping", false);
	            // TestUnicodePropertySource.test(true);
	            // showNames(".*\\ \\-.*");
	
	            // checkHTML();
	            // testIsRTL();
	
	            // TestTokenizer.test();
	            // RandomCollator.generate("collationTest.txt", null);
	
	            // TestPick.test();
	            // printRandoms();
	            // if (true) return;
	            // testLocales();
	            // if (true) return;
	            /*
	             * TestCollator tc = new TestCollator();
	             * tc.test(RuleBasedCollator.getInstance(),1000);
	             */
	            /*
	             * StringBuffer sb = new StringBuffer(); for (int i = 0; i < 100;
	             * ++i) { sb.setLength(0); rc.nextRule(sb); System.out.println(sb);
	             * }
	             */
	        } finally {
	            System.Console.Out.WriteLine("End");
	        }
	
	    }
	
	    static internal void TestLocales() {
	        CultureInfo[] locales = System.Globalization.ComparatorInfo.GetAvailableLocales();
	        ILOG.J2CsMapping.Collections.ISet s = new SortedSet(System.Globalization.ComparatorInfo.GetInstance());
	        for (int i = 0; i < locales.Length; ++i) {
	            String lang = locales[i].TwoLetterISOLanguageName;
	            String dlang = locales[i].GetDisplayLanguage();
	            String country = ILOG.J2CsMapping.Util.Culture.CultureInfoHelper.GetCountry(locales[i]);
	            String dcountry = locales[i].GetDisplayCountry();
	            if (country.Equals(""))
	                continue;
	            ILOG.J2CsMapping.Collections.Generics.Collections.Add(s,"" + "\t" + dcountry + "\t" + country + "\t" + dlang + "\t"
	                                + lang);
	        }
	        // CollectionFormatter cf = new CollectionFormatter();
	        StreamWriter pw = IBM.ICU.Charset.BagFormatter.OpenUTF8Writer("", "countries.txt");
	        IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(s.GetEnumerator());
	        while (it.HasNext()) {
	            pw.WriteLine(it.Next());
	        }
	        pw.Close();
	    }
	
	    /*
	     * Use the number of significant digits to round get a rounding value.
	     */
	    /*
	     * static final double LOG10 = Math.log(10); public static void
	     * useSignificantDigits(double value, int digits) { double log10 =
	     * Math.log(value)/LOG10; // log[e]
	     * 
	     * }
	     */
	
	    static internal readonly UnicodeSet RTL = new UnicodeSet(
	            "[[:L:]&[[:bidi class=R:][:bidi class=AL:]]]");
	
	    static internal bool IsRTL(CultureInfo loc) {
	        // in 2.8 we can use the exemplar characters, but for 2.6 we have to
	        // work around it
	        int[] scripts = IBM.ICU.Lang.UScript.GetCode(loc);
	        return new UnicodeSet()
	                .ApplyIntPropertyValue(IBM.ICU.Lang.UProperty.SCRIPT,
	                        (scripts == null) ? IBM.ICU.Lang.UScript.LATIN : scripts[0])
	                .RetainAll(RTL).Size() != 0;
	    }
	
	    static internal void TestIsRTL() {
	        CultureInfo[] locales = System.Globalization.CultureInfo.GetCultures(CultureTypes.AllCultures);
	        ILOG.J2CsMapping.Collections.ISet s = new SortedSet();
	        for (int i = 0; i < locales.Length; ++i) {
	            ILOG.J2CsMapping.Collections.Generics.Collections.Add(s,((IsRTL(locales[i])) ? "R " : "L ")
	                                + locales[i].DisplayName);
	        }
	        IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(s.GetEnumerator());
	        while (it.HasNext()) {
	            System.Console.Out.WriteLine(it.Next());
	        }
	    }
	
	    static internal readonly Transliterator toHTML = IBM.ICU.Text.Transliterator.CreateFromRules(
	            "any-html", "'<' > '&lt;' ;" + "'&' > '&amp;' ;" + "'>' > '&gt;' ;"
	                    + "'\"' > '&quot;' ; ", IBM.ICU.Text.Transliterator.FORWARD);
	
	    static internal readonly Transliterator fromHTML = IBM.ICU.Text.Transliterator.CreateFromRules(
	            "html-any", "'<' < '&'[lL][Tt]';' ;" + "'&' < '&'[aA][mM][pP]';' ;"
	                    + "'>' < '&'[gG][tT]';' ;"
	                    + "'\"' < '&'[qQ][uU][oO][tT]';' ; ",
	            IBM.ICU.Text.Transliterator.REVERSE);
	
	    static internal void CheckHTML() {
	        String foo = "& n < b < \"ab\"";
	        String fii = toHTML.Transliterate(foo);
	        System.Console.Out.WriteLine("in: " + foo);
	        System.Console.Out.WriteLine("out: " + fii);
	        System.Console.Out.WriteLine("in*: " + fromHTML.Transliterate(fii));
	        System.Console.Out.WriteLine("IN*: " + fromHTML.Transliterate(fii.ToUpper()));
	    }
	    /*
	     * static void showNames(String propAlias, boolean matches) { BagFormatter
	     * bf = new BagFormatter(); UnicodeSet stuff; stuff = new
	     * UnicodePropertySource.ICU() .setPropertyAlias(propAlias)
	     * .getPropertySet(matches, null);
	     * System.out.println(bf.showSetNames(propAlias + " with " + matches,
	     * stuff)); }
	     * 
	     * static void showNames(String propAlias, String pattern) { BagFormatter bf
	     * = new BagFormatter(); UnicodeSet stuff; stuff = new
	     * UnicodePropertySource.ICU() .setPropertyAlias(propAlias)
	     * .getPropertySet(Pattern.compile(pattern).matcher(""), null);
	     * System.out.println(bf.showSetNames(propAlias + "with " + pattern,
	     * stuff)); }
	     */
	}
	// #endif
}
