//##header J2SE15
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/13/10 4:01 PM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 //#if defined(FOUNDATION10) || defined(J2SE13)
//#else
/*
 *******************************************************************************
 * Copyright (C) 1996-2007, International Business Machines Corporation and    *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 */
namespace IBM.ICU.Charset {
	
    using IBM.ICU.Text;
	using ILOG.J2CsMapping.Collections;
	using ILOG.J2CsMapping.Collections.Generics;
	using ILOG.J2CsMapping.Text;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Text;
	
	public abstract class UnicodeProperty : UnicodeLabel {
	
	    public UnicodeProperty() {
	        this.firstNameAlias = null;
	        this.valueToFirstValueAlias = null;
	        this.maxValueWidth = -1;
	        this.maxFirstValueAliasWidth = -1;
	        this.unicodeMap = null;
	    }
	
	    public static bool DEBUG = false;
	
	    public static String CHECK_NAME = "FC_NFKC_Closure";
	
	    public static int CHECK_VALUE = 0x037A;
	
	    private String name;
	
	    private String firstNameAlias;
	
	    private int type;
	
	    private IDictionary valueToFirstValueAlias;
	
	    /*
	     * Name: Unicode_1_Name Name: ISO_Comment Name: Name Name: Unicode_1_Name
	     */
	
	    public const int UNKNOWN = 0, BINARY = 2, EXTENDED_BINARY = 3,
	            ENUMERATED = 4, EXTENDED_ENUMERATED = 5, CATALOG = 6,
	            EXTENDED_CATALOG = 7, MISC = 8, EXTENDED_MISC = 9, STRING = 10,
	            EXTENDED_STRING = 11, NUMERIC = 12, EXTENDED_NUMERIC = 13,
	            START_TYPE = 2, LIMIT_TYPE = 14, EXTENDED_MASK = 1,
	            CORE_MASK = ~EXTENDED_MASK, BINARY_MASK = (1 << BINARY)
	                    | (1 << EXTENDED_BINARY), STRING_MASK = (1 << STRING)
	                    | (1 << EXTENDED_STRING),
	            STRING_OR_MISC_MASK = (1 << STRING) | (1 << EXTENDED_STRING)
	                    | (1 << MISC) | (1 << EXTENDED_MISC),
	            ENUMERATED_OR_CATALOG_MASK = (1 << ENUMERATED)
	                    | (1 << EXTENDED_ENUMERATED) | (1 << CATALOG)
	                    | (1 << EXTENDED_CATALOG);
	
	    private static readonly String[] TYPE_NAMES = { "Unknown", "Unknown",
	            "Binary", "Extended Binary", "Enumerated", "Extended Enumerated",
	            "Catalog", "Extended Catalog", "Miscellaneous",
	            "Extended Miscellaneous", "String", "Extended String", "Numeric",
	            "Extended Numeric", };
	
	    public static String GetTypeName(int propType) {
	        return TYPE_NAMES[propType];
	    }
	
	    public String GetName() {
	        return name;
	    }
	
	    public new int GetType() {
	        return type;
	    }
	
	    public bool IsType(int mask) {
	        return ((1 << type) & mask) != 0;
	    }
	
	    protected internal void SetName(String str0) {
	        if (str0 == null)
	            throw new ArgumentException("Name must not be null");
	        name = str0;
	    }
	
	    protected internal void SetType(int i) {
	        type = i;
	    }
	
	    public String GetVersion() {
	        return _getVersion();
	    }
	
	    public String GetValue(int codepoint) {
	        if (DEBUG && CHECK_VALUE == codepoint && CHECK_NAME.Equals(GetName())) {
	            String value_ren = _getValue(codepoint);
	            System.Console.Out.WriteLine(GetName() + "(" + IBM.ICU.Impl.Utility.Hex(codepoint) + "):"
	                    + ((GetType() == STRING) ? IBM.ICU.Impl.Utility.Hex(value_ren) : value_ren));
	            return value_ren;
	        }
	        return _getValue(codepoint);
	    }
	
	    // public String getValue(int codepoint, boolean isShort) {
	    // return getValue(codepoint);
	    // }
	
	    public IList GetNameAliases(IList result) {
	        if (result == null)
	            result = new ArrayList(1);
	        return _getNameAliases(result);
	    }
	
	    public IList GetValueAliases(String valueAlias, IList result) {
	        if (result == null)
	            result = new ArrayList(1);
	        result = _getValueAliases(valueAlias, result);
	        if (!result.Contains(valueAlias)) { // FIX && type < NUMERIC
	            result = _getValueAliases(valueAlias, result); // for debugging
	            throw new ArgumentException("Internal error: " + GetName()
	                    + " doesn't contain " + valueAlias + ": "
	                    + new BagFormatter().JoinMthd(result));
	        }
	        return result;
	    }
	
	    public IList GetAvailableValues(IList result) {
	        if (result == null)
	            result = new ArrayList(1);
	        return _getAvailableValues(result);
	    }
	
	    protected abstract internal String _getVersion();
	
	    protected abstract internal String _getValue(int codepoint);
	
	    protected abstract internal IList _getNameAliases(IList result);
	
	    protected abstract internal IList _getValueAliases(String valueAlias, IList result);
	
	    protected abstract internal IList _getAvailableValues(IList result);
	
	    // conveniences
	    public IList GetNameAliases() {
	        return GetNameAliases(null);
	    }
	
	    public IList GetValueAliases(String valueAlias) {
	        return GetValueAliases(valueAlias, null);
	    }
	
	    public IList GetAvailableValues() {
	        return GetAvailableValues(null);
	    }
	
	    public sealed override String GetValue(int codepoint, bool getShortest) {
	        String result = GetValue(codepoint);
	        if (type >= MISC || result == null || !getShortest)
	            return result;
	        return GetFirstValueAlias(result);
	    }
	
	    public String GetFirstNameAlias() {
	        if (firstNameAlias == null) {
	            firstNameAlias = (String) GetNameAliases()[0];
	        }
	        return firstNameAlias;
	    }
	
	    public String GetFirstValueAlias(String value_ren) {
	        if (valueToFirstValueAlias == null)
	            _getFirstValueAliasCache();
	        return (String) ILOG.J2CsMapping.Collections.Collections.Get(valueToFirstValueAlias,value_ren);
	    }
	
	    private void _getFirstValueAliasCache() {
	        maxValueWidth = 0;
	        maxFirstValueAliasWidth = 0;
	        valueToFirstValueAlias = new Hashtable(1);
	        IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(GetAvailableValues().GetEnumerator());
	        while (it.HasNext()) {
	            String value_ren = (String) it.Next();
	            String first = (String) GetValueAliases(value_ren)[0];
	            if (first == null) { // internal error
	                throw new ArgumentException(
	                        "Value not in value aliases: " + value_ren);
	            }
	            if (DEBUG && CHECK_NAME.Equals(GetName())) {
	                System.Console.Out.WriteLine("First Alias: " + GetName() + ": " + value_ren
	                        + " => " + first
	                        + new BagFormatter().JoinMthd(GetValueAliases(value_ren)));
	            }
	            ILOG.J2CsMapping.Collections.Collections.Put(valueToFirstValueAlias,value_ren,first);
	            if (value_ren.Length > maxValueWidth) {
	                maxValueWidth = value_ren.Length;
	            }
	            if (first.Length > maxFirstValueAliasWidth) {
	                maxFirstValueAliasWidth = first.Length;
	            }
	        }
	    }
	
	    private int maxValueWidth;
	
	    private int maxFirstValueAliasWidth;
	
	    public override int GetMaxWidth(bool getShortest) {
	        if (maxValueWidth < 0)
	            _getFirstValueAliasCache();
	        if (getShortest)
	            return maxFirstValueAliasWidth;
	        return maxValueWidth;
	    }
	
	    public UnicodeSet GetSet(String propertyValue) {
	        return GetSet(propertyValue, null);
	    }
	
	    public UnicodeSet GetSet(UnicodeProperty.PatternMatcher  matcher) {
	        return GetSet(matcher, null);
	    }
	
	    public UnicodeSet GetSet(String propertyValue, UnicodeSet result) {
	        return GetSet(new UnicodeProperty.SimpleMatcher (propertyValue,
	                (IsType(STRING_OR_MISC_MASK)) ? null : PROPERTY_COMPARATOR),
	                result);
	    }
	
	    private UnicodeMap unicodeMap;
	
	    public const String UNUSED = "??";
	
	    public UnicodeSet GetSet(UnicodeProperty.PatternMatcher  matcher, UnicodeSet result) {
	        if (result == null)
	            result = new UnicodeSet();
	        if (IsType(STRING_OR_MISC_MASK)) {
	            for (int i = 0; i <= 0x10FFFF; ++i) {
	                String value_ren = GetValue(i);
	                if (value_ren != null && matcher.Matches(value_ren)) {
	                    result.Add(i);
	                }
	            }
	            return result;
	        }
	        IList temp = new ArrayList(1); // to avoid reallocating...
	        UnicodeMap um = GetUnicodeMap_internal();
	        IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(um.GetAvailableValues(null).GetEnumerator());
	        main: {
	            while (it.HasNext()) {
	                String value_0 = (String) it.Next();
	                ILOG.J2CsMapping.Collections.Collections.Clear(temp);
	                IIterator it2 = new ILOG.J2CsMapping.Collections.IteratorAdapter(GetValueAliases(value_0, temp).GetEnumerator());
	                while (it2.HasNext()) {
	                    String value2 = (String) it2.Next();
	                    // System.out.println("Values:" + value2);
	                    if (matcher.Matches(value2)
	                            || matcher.Matches(ToSkeleton(value2))) {
	                        um.GetSet(value_0, result);
	                        goto main;
	                    }
	                }
	            }
	        }
	        gotomain:
	        ;
	        return result;
	    }
	
	    /*
	     * public UnicodeSet getMatchSet(UnicodeSet result) { if (result == null)
	     * result = new UnicodeSet(); addAll(matchIterator, result); return result;
	     * }
	     * 
	     * public void setMatchSet(UnicodeSet set) { matchIterator = new
	     * UnicodeSetIterator(set); }
	     */
	
	    /// <summary>
	    /// Utility for debugging
	    /// </summary>
	    ///
	    public static String GetStack() {
	        Exception e = new Exception();
	        StringWriter sw = new StringWriter(System.Globalization.NumberFormatInfo.InvariantInfo);
	        StreamWriter pw = ILOG.J2CsMapping.IO.IOUtility.NewStreamWriter(sw) /* Warning: if writer (arg) is a StringWriter exception raised */;
	        pw.WriteLine(e.StackTrace);
	        pw.Flush();
	        return "Showing Stack with fake " + sw.GetStringBuilder().ToString();
	    }
	
	    public sealed class Anonymous_C0 : IComparer {
	        public int Compare(Object o1, Object o2) {
	            return IBM.ICU.Charset.UnicodeProperty.CompareNames((String) o1, (String) o2);
	        }
	    }
	
	    // TODO use this instead of plain strings
	    public class Name : IComparable {
	        private String skeleton;
	
	        private String pretty;
	
	        public readonly int RAW, TITLE, NORMAL;
	
	        public Name(String name_0, int style) {
	            this.RAW = 0;
	            this.TITLE = 1;
	            this.NORMAL = 2;
	            if (name_0 == null)
	                name_0 = "";
	            if (style == RAW) {
	                skeleton = pretty = name_0;
	            } else {
	                pretty = IBM.ICU.Charset.UnicodeProperty.Regularize(name_0, style == TITLE);
	                skeleton = IBM.ICU.Charset.UnicodeProperty.ToSkeleton(pretty);
	            }
	        }
	
	        public virtual int CompareTo(Object o) {
	            return String.CompareOrdinal(skeleton,((UnicodeProperty.Name ) o).skeleton);
	        }
	
	        public override bool Equals(Object o) {
	            return skeleton.Equals(((UnicodeProperty.Name ) o).skeleton);
	        }
	
	        public override int GetHashCode() {
	            return skeleton.GetHashCode();
	        }
	
	        public override String ToString() {
	            return pretty;
	        }
	    }
	
	    
	    /// <returns>the unicode map</returns>
	    public UnicodeMap GetUnicodeMap() {
	        return GetUnicodeMap(false);
	    }
	
	    
	    /// <returns>the unicode map</returns>
	    public UnicodeMap GetUnicodeMap(bool getShortest) {
	        if (!getShortest)
	            return (UnicodeMap) GetUnicodeMap_internal().CloneAsThawed();
	        UnicodeMap result = new UnicodeMap();
	        for (int i = 0; i <= 0x10FFFF; ++i) {
	            // if (DEBUG && i == 0x41) System.out.println(i + "\t" +
	            // getValue(i));
	            String // if (DEBUG && i == 0x41) System.out.println(i + "\t" +
	                        // getValue(i));
	                        value_ren = GetValue(i, true);
	            result.Put(i, value_ren);
	        }
	        return result;
	    }
	
	    
	    /// <returns>the unicode map</returns>
	    protected internal UnicodeMap GetUnicodeMap_internal() {
	        if (unicodeMap == null)
	            unicodeMap = _getUnicodeMap();
	        return unicodeMap;
	    }
	
	    protected internal UnicodeMap _getUnicodeMap() {
	        UnicodeMap result = new UnicodeMap();
	        Hashtable myIntern = new Hashtable();
	        for (int i = 0; i <= 0x10FFFF; ++i) {
	            // if (DEBUG && i == 0x41) System.out.println(i + "\t" +
	            // getValue(i));
	            String // if (DEBUG && i == 0x41) System.out.println(i + "\t" +
	                        // getValue(i));
	                        value_ren = GetValue(i);
	            String iValue = (String) ILOG.J2CsMapping.Collections.Collections.Get(myIntern,value_ren);
	            if (iValue == null)
	                ILOG.J2CsMapping.Collections.Collections.Put(myIntern,value_ren,iValue = value_ren);
	            result.Put(i, iValue);
	        }
	        if (DEBUG) {
	            for (int i_0 = 0; i_0 <= 0x10FFFF; ++i_0) {
	                // if (DEBUG && i == 0x41) System.out.println(i + "\t" +
	                // getValue(i));
	                String value_1 = GetValue(i_0);
	                String resultValue = (String) result.GetValue(i_0);
	                if (!value_1.Equals(resultValue)) {
	                    throw new Exception("Value failure at: "
	                            + IBM.ICU.Impl.Utility.Hex(i_0));
	                }
	            }
	        }
	        if (DEBUG && CHECK_NAME.Equals(GetName())) {
	            System.Console.Out.WriteLine(GetName() + ":\t" + (((object) this).GetType()).FullName + "\t"
	                    + GetVersion());
	            System.Console.Out.WriteLine(GetStack());
	            System.Console.Out.WriteLine(result);
	        }
	        return result;
	    }
	
	    /// <summary>
	    /// Really ought to create a Collection UniqueList, that forces uniqueness.
	    /// But for now...
	    /// </summary>
	    ///
	    public static ICollection AddUnique(Object obj, ICollection result) {
	        if (obj != null && !ILOG.J2CsMapping.Collections.Collections.Contains(obj,result))
	            ILOG.J2CsMapping.Collections.Collections.Add(result,obj);
	        return result;
	    }
	
	    /// <summary>
	    /// Utility for managing property & non-string value aliases
	    /// </summary>
	    ///
	    public static readonly IComparer PROPERTY_COMPARATOR = new UnicodeProperty.Anonymous_C0 ();
	
	    /// <summary>
	    /// Utility for managing property & non-string value aliases
	    /// </summary>
	    ///
	    // TODO optimize
	    public static bool EqualNames(String a, String b) {
	        if (a == b)
	            return true;
	        if (a == null)
	            return false;
	        return ToSkeleton(a).Equals(ToSkeleton(b));
	    }
	
	    /// <summary>
	    /// Utility for managing property & non-string value aliases
	    /// </summary>
	    ///
	    // TODO optimize
	    public static int CompareNames(String a, String b) {
	        if (a == b)
	            return 0;
	        if (a == null)
	            return -1;
	        if (b == null)
	            return 1;
	        return String.CompareOrdinal(ToSkeleton(a),ToSkeleton(b));
	    }
	
	    /// <summary>
	    /// Utility for managing property & non-string value aliases
	    /// </summary>
	    ///
	    // TODO account for special names, tibetan, hangul
	    public static String ToSkeleton(String source) {
	        if (source == null)
	            return null;
	        StringBuilder skeletonBuffer = new StringBuilder();
	        bool gotOne = false;
	        // remove spaces, '_', '-'
	        // we can do this with char, since no surrogates are involved
	        for (int i = 0; i < source.Length; ++i) {
	            char ch = source[i];
	            if (i > 0 && (ch == '_' || ch == ' ' || ch == '-')) {
	                gotOne = true;
	            } else {
	                char ch2 = Char.ToLower(ch);
	                if (ch2 != ch) {
	                    gotOne = true;
	                    skeletonBuffer.Append(ch2);
	                } else {
	                    skeletonBuffer.Append(ch);
	                }
	            }
	        }
	        if (!gotOne)
	            return source; // avoid string creation
	        return skeletonBuffer.ToString();
	    }
	
	    // get the name skeleton
	    public static String ToNameSkeleton(String source) {
	        if (source == null)
	            return null;
	        StringBuilder result = new StringBuilder();
	        // remove spaces, medial '-'
	        // we can do this with char, since no surrogates are involved
	        for (int i = 0; i < source.Length; ++i) {
	            char ch = source[i];
	            if (('0' <= ch && ch <= '9') || ('A' <= ch && ch <= 'Z')
	                    || ch == '<' || ch == '>') {
	                result.Append(ch);
	            } else if (ch == ' ') {
	                // don't copy ever
	            } else if (ch == '-') {
	                // only copy non-medials AND trailing O-E
	                if (0 == i
	                        || i == source.Length - 1
	                        || source[i - 1] == ' '
	                        || source[i + 1] == ' '
	                        || (i == source.Length - 2
	                                && source[i - 1] == 'O' && source[i + 1] == 'E')) {
	                    System.Console.Out.WriteLine("****** EXCEPTION " + source);
	                    result.Append(ch);
	                }
	                // otherwise don't copy
	            } else {
	                throw new ArgumentException("Illegal Name Char: U+"
	                        + IBM.ICU.Impl.Utility.Hex(ch) + ", " + ch);
	            }
	        }
	        return result.ToString();
	    }
	
	    /// <summary>
	    /// These routines use the Java functions, because they only need to act on
	    /// ASCII Changes space, - into _, inserts _ between lower and UPPER.
	    /// </summary>
	    ///
	    public static String Regularize(String source, bool titlecaseStart) {
	        if (source == null)
	            return source;
	        /*
	         * if (source.equals("noBreak")) { // HACK if (titlecaseStart) return
	         * "NoBreak"; return source; }
	         */
	        StringBuilder result = new StringBuilder();
	        int lastCat = -1;
	        bool haveFirstCased = true;
	        for (int i = 0; i < source.Length; ++i) {
	            char c = source[i];
	            if (c == ' ' || c == '-' || c == '_') {
	                c = '_';
	                haveFirstCased = true;
	            }
	            if (c == '=')
	                haveFirstCased = true;
	            int cat = ILOG.J2CsMapping.Util.Character.GetType(c);
                if (lastCat == ILOG.J2CsMapping.Util.Character.LOWERCASE_LETTER
                        && cat == ILOG.J2CsMapping.Util.Character.UPPERCASE_LETTER)
                {
	                result.Append('_');
	            }
	            if (haveFirstCased
                        && (cat == ILOG.J2CsMapping.Util.Character.LOWERCASE_LETTER
                                || cat == ILOG.J2CsMapping.Util.Character.TITLECASE_LETTER || cat == ILOG.J2CsMapping.Util.Character.UPPERCASE_LETTER))
                {
	                if (titlecaseStart) {
	                    c = Char.ToUpper(c);
	                }
	                haveFirstCased = false;
	            }
	            result.Append(c);
	            lastCat = cat;
	        }
	        return result.ToString();
	    }
	
	    /// <summary>
	    /// Utility function for comparing codepoint to string without generating new
	    /// string.
	    /// </summary>
	    ///
	    /// <param name="codepoint"></param>
	    /// <param name="other"></param>
	    /// <returns>true if the codepoint equals the string</returns>
	    public static bool Equals(int codepoint, String other) {
	        if (other.Length == 1) {
	            return codepoint == other[0];
	        }
	        if (other.Length == 2) {
	            return other.Equals(IBM.ICU.Text.UTF16.ValueOf(codepoint));
	        }
	        return false;
	    }
	
	    /// <summary>
	    /// Utility that should be on UnicodeSet
	    /// </summary>
	    ///
	    /// <param name="source"></param>
	    /// <param name="result"></param>
	    static public void AddAll(UnicodeSetIterator source, UnicodeSet result) {
	        while (source.NextRange()) {
	            if (source.codepoint == IBM.ICU.Text.UnicodeSetIterator.IS_STRING) {
	                result.Add(source.str0);
	            } else {
	                result.Add(source.codepoint, source.codepointEnd);
	            }
	        }
	    }
	
	    /// <summary>
	    /// Really ought to create a Collection UniqueList, that forces uniqueness.
	    /// But for now...
	    /// </summary>
	    ///
	    public static ICollection AddAllUnique(ICollection source, ICollection result) {
	        for (IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(source.GetEnumerator()); it.HasNext();) {
	            AddUnique(it.Next(), result);
	        }
	        return result;
	    }
	
	    /// <summary>
	    /// Really ought to create a Collection UniqueList, that forces uniqueness.
	    /// But for now...
	    /// </summary>
	    ///
	    public static ICollection AddAllUnique(Object[] source, ICollection result) {
	        for (int i = 0; i < source.Length; ++i) {
	            AddUnique(source[i], result);
	        }
	        return result;
	    }
	
	    public class Factory {
	        public Factory() {
	            this.canonicalNames = new SortedList();
	            this.skeletonNames = new SortedList();
	            this.propertyCache = new Hashtable(1);
	            this.inverseMatcher = new UnicodeProperty.InversePatternMatcher ();
	        }
	
	        static internal bool DEBUG = false;
	
	        internal IDictionary canonicalNames;
	
	        internal IDictionary skeletonNames;
	
	        internal IDictionary propertyCache;
	
	        public UnicodeProperty.Factory  Add(UnicodeProperty sp) {
	            ILOG.J2CsMapping.Collections.Collections.Put(canonicalNames,sp.GetName(),sp);
	            IList c = sp.GetNameAliases(new ArrayList(1));
	            IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(c.GetEnumerator());
	            while (it.HasNext()) {
	                ILOG.J2CsMapping.Collections.Collections.Put(skeletonNames,IBM.ICU.Charset.UnicodeProperty.ToSkeleton((String) it.Next()),sp);
	            }
	            return this;
	        }
	
	        public UnicodeProperty GetProperty(String propertyAlias) {
	            return (UnicodeProperty) ILOG.J2CsMapping.Collections.Collections.Get(skeletonNames,IBM.ICU.Charset.UnicodeProperty.ToSkeleton(propertyAlias));
	        }
	
	        public IList GetAvailableNames() {
	            return GetAvailableNames(null);
	        }
	
	        public IList GetAvailableNames(IList result) {
	            if (result == null)
	                result = new ArrayList(1);
	            IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(new ILOG.J2CsMapping.Collections.ListSet(canonicalNames.Keys).GetEnumerator());
	            while (it.HasNext()) {
	                IBM.ICU.Charset.UnicodeProperty.AddUnique(it.Next(), result);
	            }
	            return result;
	        }
	
	        public IList GetAvailableNames(int propertyTypeMask) {
	            return GetAvailableNames(propertyTypeMask, null);
	        }
	
	        public IList GetAvailableNames(int propertyTypeMask, IList result) {
	            if (result == null)
	                result = new ArrayList(1);
	            IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(new ILOG.J2CsMapping.Collections.ListSet(canonicalNames.Keys).GetEnumerator());
	            while (it.HasNext()) {
	                String item = (String) it.Next();
	                UnicodeProperty property = GetProperty(item);
	                if (DEBUG)
	                    System.Console.Out.WriteLine("Properties: " + item + ","
	                            + property.GetType());
	                if (!property.IsType(propertyTypeMask)) {
	                    // System.out.println("Masking: " + property.getType() + ","
	                    // + propertyTypeMask);
	                    continue;
	                }
	                IBM.ICU.Charset.UnicodeProperty.AddUnique(property.GetName(), result);
	            }
	            return result;
	        }
	
	        internal UnicodeProperty.InversePatternMatcher  inverseMatcher;
	
	        /// <summary>
	        /// Format is: propname ('=' | '!=') propvalue ( '|' propValue )
	        /// </summary>
	        ///
	        public UnicodeSet GetSet(String propAndValue,
	                UnicodeProperty.PatternMatcher  matcher, UnicodeSet result) {
	            int equalPos = propAndValue.IndexOf('=');
	            String prop = propAndValue.Substring(0,(equalPos)-(0));
	            String value_ren = propAndValue.Substring(equalPos + 1);
	            bool negative = false;
	            if (prop.EndsWith("!")) {
	                prop = prop.Substring(0,(prop.Length - 1)-(0));
	                negative = true;
	            }
	            prop = prop.Trim();
	            UnicodeProperty up = GetProperty(prop);
	            if (matcher == null) {
	                matcher = new UnicodeProperty.SimpleMatcher (value_ren,
	                        (up.IsType(IBM.ICU.Charset.UnicodeProperty.STRING_OR_MISC_MASK)) ? null
	                                : IBM.ICU.Charset.UnicodeProperty.PROPERTY_COMPARATOR);
	            }
	            if (negative) {
	                inverseMatcher.Set(matcher);
	                matcher = inverseMatcher;
	            }
	            return up.GetSet(matcher.Set(value_ren), result);
	        }
	
	        public UnicodeSet GetSet(String propAndValue,
	                UnicodeProperty.PatternMatcher  matcher) {
	            return GetSet(propAndValue, matcher, null);
	        }
	
	        public UnicodeSet GetSet(String propAndValue) {
	            return GetSet(propAndValue, null, null);
	        }
	
	        public SymbolTable GetSymbolTable(String prefix) {
	            return new IBM.ICU.Charset.UnicodeProperty.Factory.PropertySymbolTable (this, prefix);
	        }
	
	        internal class MyXSymbolTable : UnicodeSet.XSymbolTable {
	                    private UnicodeProperty.Factory outer_Factory;
	        
	                    
	                    /// <param name="factory"></param>
	                    public MyXSymbolTable(UnicodeProperty.Factory factory) {
	                        outer_Factory = factory;
	                    }
	        
	                    public override bool ApplyPropertyAlias(String propertyName,
	                            String propertyValue, UnicodeSet result) {
	                        if (false)
	                            System.Console.Out.WriteLine(propertyName + "=" + propertyValue);
	                        UnicodeProperty prop = outer_Factory.GetProperty(propertyName);
	                        if (prop == null)
	                            return false;
	                        result.Clear();
	                        UnicodeSet x = prop.GetSet(propertyValue, result);
	                        return x.Size() != 0;
	                    }
	                }
	
	        public UnicodeSet.XSymbolTable GetXSymbolTable() {
	            return new IBM.ICU.Charset.UnicodeProperty.Factory.MyXSymbolTable (this);
	        }
	
	        internal class PropertySymbolTable : SymbolTable {
	                    private UnicodeProperty.Factory outer_Factory;
	        
	                    internal const bool DEBUG = false;
	        
	                    private String prefix;
	        
	                    internal UnicodeProperty.RegexMatcher regexMatcher;
	        
	                    internal PropertySymbolTable(UnicodeProperty.Factory factory, String prefix_0) {
	                        outer_Factory = factory;
	                        this.regexMatcher = new UnicodeProperty.RegexMatcher();
	                        this.prefix = prefix_0;
	                    }
	        
	                    public virtual char[] Lookup(String s) {
	                        if (DEBUG)
	                            System.Console.Out.WriteLine("\t(" + prefix + ")Looking up " + s);
	                        // ensure, again, that prefix matches
	                        int start = prefix.Length;

                            if (!ILOG.J2CsMapping.Util.StringUtil.RegionMatches(s, true, 0, prefix, 0, start))
	                            return null;
	        
	                        int pos = s.IndexOf(':', start);
	                        if (pos < 0) { // should never happen
	                            throw new ArgumentException(
	                                    "Internal Error: missing =: " + s + "\r\n");
	                        }
	                        UnicodeProperty prop = outer_Factory.GetProperty(s.Substring(start,(pos)-(start)));
	                        if (prop == null) {
	                            throw new ArgumentException("Invalid Property in: "
	                                    + s + "\r\nUse " + ShowSet(outer_Factory.GetAvailableNames()));
	                        }
	                        String value_ren = s.Substring(pos + 1);
	                        UnicodeSet set;
	                        if (value_ren.StartsWith("\u00AB")) { // regex!
	                            set = prop.GetSet(regexMatcher.Set(value_ren.Substring(1,(value_ren.Length - 1)-(1))));
	                        } else {
	                            set = prop.GetSet(value_ren);
	                        }
	                        if (set.Size() == 0) {
	                            throw new ArgumentException(
	                                    "Empty Property-Value in: " + s + "\r\nUse "
	                                            + ShowSet(prop.GetAvailableValues()));
	                        }
	                        if (DEBUG)
	                            System.Console.Out.WriteLine("\t(" + prefix + ")Returning "
	                                    + set.ToPattern(true));
	                        return set.ToPattern(true).ToCharArray(); // really ugly
	                    }
	        
	                    public String ShowSet(IList list) {
	                        StringBuilder result = new StringBuilder("[");
	                        bool first = true;
	                        for (IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(list.GetEnumerator()); it.HasNext();) {
	                            if (!first)
	                                result.Append(", ");
	                            else
	                                first = false;
	                            result.Append(it.Next().ToString());
	                        }
	                        result.Append("]");
	                        return result.ToString();
	                    }
	        
	                    public virtual UnicodeMatcher LookupMatcher(int ch) {
	                        return null;
	                    }

                        public virtual String ParseReference(String text, ILOG.J2CsMapping.Text.ParsePosition pos,
	                            int limit) {
	                        if (DEBUG)
	                            System.Console.Out.WriteLine("\t(" + prefix + ")Parsing <"
	                                    + text.Substring(pos.GetIndex(),(limit)-(pos.GetIndex())) + ">");
	                        int start = pos.GetIndex();
	                        // ensure that it starts with 'prefix'
                            if (!ILOG.J2CsMapping.Util.StringUtil
	                                .RegionMatches(text, true, start, prefix, 0, prefix.Length))
	                            return null;
	                        start += prefix.Length;
	                        // now see if it is of the form identifier:identifier
	                        int i = GetIdentifier(text, start, limit);
	                        if (i == start)
	                            return null;
	                        String prop = text.Substring(start,(i)-(start));
	                        String value_ren = "true";
	                        if (i < limit) {
	                            if (text[i] == ':') {
	                                int j;
	                                if (text[i + 1] == '\u00AB') { // regular
	                                                                      // expression
	                                    j = text.IndexOf('\u00BB', i + 2) + 1; // include
	                                                                           // last
	                                                                           // character
	                                    if (j <= 0)
	                                        return null;
	                                } else {
	                                    j = GetIdentifier(text, i + 1, limit);
	                                }
	                                value_ren = text.Substring(i + 1,(j)-(i + 1));
	                                i = j;
	                            }
	                        }
	                        pos.SetIndex(i);
	                        if (DEBUG)
	                            System.Console.Out.WriteLine("\t(" + prefix + ")Parsed <" + prop
	                                    + ">=<" + value_ren + ">");
	                        return prefix + prop + ":" + value_ren;
	                    }
	        
	                    public int GetIdentifier(String text, int start, int limit) {
	                        if (DEBUG)
	                            System.Console.Out.WriteLine("\tGetID <"
	                                    + text.Substring(start,(limit)-(start)) + ">");
	                        int cp = 0;
	                        int i;
	                        for (i = start; i < limit; i += IBM.ICU.Text.UTF16.GetCharCount(cp)) {
	                            cp = IBM.ICU.Text.UTF16.CharAt(text, i);
	                            if (!IBM.ICU.Lang.UCharacter
	                                    .IsUnicodeIdentifierPart(cp) && cp != '.') {
	                                break;
	                            }
	                        }
	                        if (DEBUG)
	                            System.Console.Out.WriteLine("\tGotID <" + text.Substring(start,(i)-(start))
	                                    + ">");
	                        return i;
	                    }
	                }
	    }
	
	    public class FilteredProperty : UnicodeProperty {
	        private UnicodeProperty property;
	
	        protected internal UnicodeProperty.StringFilter  filter;
	
	        protected internal UnicodeSetIterator matchIterator;
	
	        protected internal Hashtable backmap;
	
	        internal bool allowValueAliasCollisions;
	
	        public FilteredProperty(UnicodeProperty property_0, UnicodeProperty.StringFilter  filter_1) {
	            this.matchIterator = new UnicodeSetIterator(
	                    new UnicodeSet(0, 0x10FFFF));
	            this.allowValueAliasCollisions = false;
	            this.temp = new ArrayList(1);
	            this.property = property_0;
	            this.filter = filter_1;
	        }
	
	        public UnicodeProperty.StringFilter  GetFilter() {
	            return filter;
	        }
	
	        public UnicodeProperty SetFilter(UnicodeProperty.StringFilter  filter_0) {
	            this.filter = filter_0;
	            return this;
	        }
	
	        internal IList temp;
	
	        protected internal override IList _getAvailableValues(IList result) {
	            ILOG.J2CsMapping.Collections.Collections.Clear(temp);
	            return filter.AddUnique(property.GetAvailableValues(temp), result);
	        }

            protected internal override IList _getNameAliases(IList result)
            {
	            ILOG.J2CsMapping.Collections.Collections.Clear(temp);
	            return filter.AddUnique(property.GetNameAliases(temp), result);
	        }

            protected internal override String _getValue(int codepoint)
            {
	            return filter.Remap(property.GetValue(codepoint));
	        }

            protected internal override IList _getValueAliases(String valueAlias, IList result)
            {
	            if (backmap == null) {
	                backmap = new Hashtable(1);
	                ILOG.J2CsMapping.Collections.Collections.Clear(temp);
	                IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(property.GetAvailableValues(temp).GetEnumerator());
	                while (it.HasNext()) {
	                    String item = (String) it.Next();
	                    String mappedItem = filter.Remap(item);
	                    if (ILOG.J2CsMapping.Collections.Collections.Get(backmap,mappedItem) != null
	                            && !allowValueAliasCollisions) {
	                        throw new ArgumentException(
	                                "Filter makes values collide! " + item + ", "
	                                        + mappedItem);
	                    }
	                    ILOG.J2CsMapping.Collections.Collections.Put(backmap,mappedItem,item);
	                }
	            }
	            valueAlias = (String) ILOG.J2CsMapping.Collections.Collections.Get(backmap,valueAlias);
	            ILOG.J2CsMapping.Collections.Collections.Clear(temp);
	            return filter.AddUnique(property.GetValueAliases(valueAlias, temp),
	                    result);
	        }

            protected internal override String _getVersion()
            {
	            return property.GetVersion();
	        }
	
	        public bool IsAllowValueAliasCollisions() {
	            return allowValueAliasCollisions;
	        }
	
	        public UnicodeProperty.FilteredProperty  SetAllowValueAliasCollisions(bool b) {
	            allowValueAliasCollisions = b;
	            return this;
	        }
	
	    }
	
	    public abstract class StringFilter /*: ICloneable*/ {
	        public abstract String Remap(String original);
	
	        public IList AddUnique(ICollection source, IList result) {
	            if (result == null)
	                result = new ArrayList(1);
	            IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(source.GetEnumerator());
	            while (it.HasNext()) {
	                IBM.ICU.Charset.UnicodeProperty.AddUnique(Remap((String) it.Next()), result);
	            }
	            return result;
	        }
	        /*
	         * public Object clone() { try { return super.clone(); } catch
	         * (CloneNotSupportedException e) { throw new
	         * IllegalStateException("Should never happen."); } }
	         */
	    }
	
	    public class MapFilter : UnicodeProperty.StringFilter  {
	        private IDictionary valueMap;
	
	        public MapFilter(IDictionary valueMap_0) {
	            this.valueMap = valueMap_0;
	        }
	
	        public override String Remap(String original) {
	            Object changed = ILOG.J2CsMapping.Collections.Collections.Get(valueMap,original);
	            return (changed == null) ? original : (String) changed;
	        }
	
	        public IDictionary GetMap() {
	            return valueMap;
	        }
	    }
	
	    public interface PatternMatcher : IBM.ICU.Charset.CollectionUtilities.ObjectMatcher  {
	        UnicodeProperty.PatternMatcher  Set(String pattern);
	    }
	
	    public class InversePatternMatcher : IBM.ICU.Charset.CollectionUtilities.InverseMatcher , 
	            UnicodeProperty.PatternMatcher  {
	        internal UnicodeProperty.PatternMatcher  other;
	
	        public UnicodeProperty.PatternMatcher  Set(UnicodeProperty.PatternMatcher  toInverse) {
	            other = toInverse;
	            return this;
	        }
	
	        public override bool Matches(Object value_ren) {
	            return !other.Matches(value_ren);
	        }
	
	        public virtual UnicodeProperty.PatternMatcher  Set(String pattern) {
	            other.Set(pattern);
	            return this;
	        }
	    }
	
	    public class SimpleMatcher : UnicodeProperty.PatternMatcher  {
	        internal IComparer comparator;
	
	        internal String pattern;
	
	        public SimpleMatcher(String pattern_0, IComparer comparator_1) {
	            this.comparator = comparator_1;
	            this.pattern = pattern_0;
	        }
	
	        public virtual bool Matches(Object value_ren) {
	            if (comparator == null)
	                return pattern.Equals(value_ren);
	            return comparator.Compare(pattern, value_ren) == 0;
	        }
	
	        public virtual UnicodeProperty.PatternMatcher  Set(String pattern_0) {
	            this.pattern = pattern_0;
	            return this;
	        }
	    }
	
	    public class RegexMatcher : UnicodeProperty.PatternMatcher {
            private ILOG.J2CsMapping.RegEx.Matcher matcher;
	
	        public virtual UnicodeProperty.PatternMatcher Set(String pattern_0) {
                matcher = ILOG.J2CsMapping.RegEx.Pattern.Compile(pattern_0).Matcher("");
	            return this;
	        }
	
	        public virtual bool Matches(Object value_ren) {
	            matcher.Reset(value_ren.ToString());
	            return matcher.Matches();
	        }
	    }
	
	    public abstract class BaseProperty : UnicodeProperty {
	        public BaseProperty() {
	            this.propertyAliases = new ArrayList(1);
	        }
	
	        protected internal IList propertyAliases;
	
	        protected internal IDictionary toValueAliases;
	
	        protected internal String version;
	
	        public UnicodeProperty.BaseProperty  SetMain(String alias, String shortAlias,
	                int propertyType, String version_0) {
	            SetName(alias);
	            SetType(propertyType);
	            ILOG.J2CsMapping.Collections.Generics.Collections.Add(propertyAliases,shortAlias);
	            ILOG.J2CsMapping.Collections.Generics.Collections.Add(propertyAliases,alias);
	            this.version = version_0;
	            return this;
	        }

            protected internal override String _getVersion()
            {
	            return version;
	        }

            protected internal override IList _getNameAliases(IList result)
            {
	            IBM.ICU.Charset.UnicodeProperty.AddAllUnique(propertyAliases, result);
	            return result;
	        }
	
	        public UnicodeProperty.BaseProperty  AddValueAliases(String[][] valueAndAlternates,
	                bool errorIfCant) {
	            if (toValueAliases == null)
	                _fixValueAliases();
	            for (int i = 0; i < valueAndAlternates.Length; ++i) {
	                for (int j = 1; j < valueAndAlternates[0].Length; ++j) {
	                    AddValueAlias(valueAndAlternates[i][0],
	                            valueAndAlternates[i][j], errorIfCant);
	                }
	            }
	            return this;
	        }
	
	        public void AddValueAlias(String value_ren, String valueAlias,
	                bool errorIfCant) {
	            IList result = (IList) ILOG.J2CsMapping.Collections.Collections.Get(toValueAliases,value_ren);
	            if (result == null && !errorIfCant)
	                return;
	            IBM.ICU.Charset.UnicodeProperty.AddUnique(value_ren, result);
	            IBM.ICU.Charset.UnicodeProperty.AddUnique(valueAlias, result);
	        }
	
	        protected internal override IList _getValueAliases(String valueAlias, IList result) {
	            if (toValueAliases == null)
	                _fixValueAliases();
	            IList a = (IList) ILOG.J2CsMapping.Collections.Collections.Get(toValueAliases,valueAlias);
	            if (a != null)
	                IBM.ICU.Charset.UnicodeProperty.AddAllUnique(a, result);
	            return result;
	        }
	
	        protected internal void _fixValueAliases() {
	            if (toValueAliases == null)
	                toValueAliases = new Hashtable(1);
	            for (IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(GetAvailableValues().GetEnumerator()); it.HasNext();) {
	                Object value_ren = it.Next();
	                _ensureValueInAliases(value_ren);
	            }
	        }
	
	        protected internal void _ensureValueInAliases(Object value_ren) {
	            IList result = (IList) ILOG.J2CsMapping.Collections.Collections.Get(toValueAliases,value_ren);
	            if (result == null)
	                ILOG.J2CsMapping.Collections.Collections.Put(toValueAliases,value_ren,result = new ArrayList(1));
	            IBM.ICU.Charset.UnicodeProperty.AddUnique(value_ren, result);
	        }
	
	        public UnicodeProperty.BaseProperty  SwapFirst2ValueAliases() {
	            for (IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(new ILOG.J2CsMapping.Collections.ListSet(toValueAliases.Keys).GetEnumerator()); it.HasNext();) {
	                IList list = (IList) ILOG.J2CsMapping.Collections.Collections.Get(toValueAliases,it.Next());
	                if (list.Count < 2)
	                    continue;
	                Object first = list[0];
	                list[0]=list[1];
	                list[1]=first;
	            }
	            return this;
	        }
	
	    }
	
	    public abstract class SimpleProperty : UnicodeProperty.BaseProperty  {
	        internal IList values;
	
	        public UnicodeProperty.SimpleProperty  AddName(String alias) {
	            ILOG.J2CsMapping.Collections.Generics.Collections.Add(propertyAliases,alias);
	            return this;
	        }
	
	        public UnicodeProperty.SimpleProperty  SetValues(String valueAlias) {
	            _addToValues(valueAlias, null);
	            return this;
	        }
	
	        public UnicodeProperty.SimpleProperty  SetValues(String[] valueAliases,
	                String[] alternateValueAliases) {
	            for (int i = 0; i < valueAliases.Length; ++i) {
	                if (valueAliases[i].Equals(IBM.ICU.Charset.UnicodeProperty.UNUSED))
	                    continue;
	                _addToValues(
	                        valueAliases[i],
	                        (alternateValueAliases != null) ? alternateValueAliases[i]
	                                : null);
	            }
	            return this;
	        }
	
	        public UnicodeProperty.SimpleProperty  SetValues(IList valueAliases) {
	            this.values = new ArrayList(valueAliases);
	            for (IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(this.values.GetEnumerator()); it.HasNext();) {
	                _addToValues((String) it.Next(), null);
	            }
	            return this;
	        }

            protected internal override IList _getAvailableValues(IList result)
            {
	            if (values == null)
	                _fillValues();
	            ILOG.J2CsMapping.Collections.Generics.Collections.AddAll(values,result);
	            return result;
	        }
	
	        protected internal void _fillValues() {
	            IList newvalues = (IList) GetUnicodeMap_internal()
	                    .GetAvailableValues(new ArrayList());
	            for (IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(newvalues.GetEnumerator()); it.HasNext();) {
	                _addToValues((String) it.Next(), null);
	            }
	        }
	
	        public void _addToValues(String item, String alias) {
	            if (values == null)
	                values = new ArrayList(1);
	            if (toValueAliases == null)
	                _fixValueAliases();
	            IBM.ICU.Charset.UnicodeProperty.AddUnique(item, values);
	            _ensureValueInAliases(item);
	            AddValueAlias(item, alias, true);
	        }
	        /*
	         * public String _getVersion() { return version; }
	         */
	    }
	
	    public class UnicodeMapProperty : UnicodeProperty.BaseProperty  {
	        /*
	         * Example of usage: new UnicodeProperty.UnicodeMapProperty() { {
	         * unicodeMap = new UnicodeMap(); unicodeMap.setErrorOnReset(true);
	         * unicodeMap.put(0xD, "CR"); unicodeMap.put(0xA, "LF"); UnicodeProperty
	         * cat = getProperty("General_Category"); UnicodeSet temp =
	         * cat.getSet("Line_Separator")
	         * .addAll(cat.getSet("Paragraph_Separator"))
	         * .addAll(cat.getSet("Control")) .addAll(cat.getSet("Format"))
	         * .remove(0xD).remove(0xA).remove(0x200C).remove(0x200D);
	         * unicodeMap.putAll(temp, "Control"); UnicodeSet graphemeExtend =
	         * getProperty("Grapheme_Extend").getSet("true");
	         * unicodeMap.putAll(graphemeExtend,"Extend"); UnicodeProperty hangul =
	         * getProperty("Hangul_Syllable_Type");
	         * unicodeMap.putAll(hangul.getSet("L"),"L");
	         * unicodeMap.putAll(hangul.getSet("V"),"V");
	         * unicodeMap.putAll(hangul.getSet("T"),"T");
	         * unicodeMap.putAll(hangul.getSet("LV"),"LV");
	         * unicodeMap.putAll(hangul.getSet("LVT"),"LVT");
	         * unicodeMap.setMissing("Other"); } }.setMain("Grapheme_Cluster_Break",
	         * "GCB", UnicodeProperty.ENUMERATED, version)
	         */
	        protected internal UnicodeMap unicodeMap;
	
	        public UnicodeProperty.UnicodeMapProperty  Set(UnicodeMap map) {
	            unicodeMap = map;
	            return this;
	        }
	
	        protected internal override String _getValue(int codepoint) {
	            return (String) unicodeMap.GetValue(codepoint);
	        }
	
	        /*
	         * protected List _getValueAliases(String valueAlias, List result) { if
	         * (!unicodeMap.getAvailableValues().contains(valueAlias)) return
	         * result; result.add(valueAlias); return result; // no other aliases }
	         */protected internal override IList _getAvailableValues(IList result) {
	            return (IList) unicodeMap.GetAvailableValues(result);
	        }
	    }
	}
	// #endif
	
}
