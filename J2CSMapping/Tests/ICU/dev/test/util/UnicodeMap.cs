//##header J2SE15
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/13/10 4:02 PM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 //#if defined(FOUNDATION10) || defined(J2SE13)
//#else
/*
 *******************************************************************************
 * Copyright (C) 1996-2007, International Business Machines Corporation and    *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 */
namespace IBM.ICU.Charset {
	
	using IBM.ICU.Text;
	using IBM.ICU.Util;
	using ILOG.J2CsMapping.Collections;
	using ILOG.J2CsMapping.Collections.Generics;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Text;
	
	/// <summary>
	/// Class for mapping Unicode characters to values Much smaller storage than
	/// using HashMap, and much faster and more compact than a list of UnicodeSets.
	/// </summary>
	///
	[Serializable]
	
	public sealed class UnicodeMap : /*ICloneable, */Freezable /*, Externalizable*/ {
	    public UnicodeMap() {
	        Clear();
	        this.availableValues = new HashedSet();
	    }
	
	    /// <summary>
	    /// For serialization
	    /// </summary>
	    ///
	    private const long serialVersionUID = -6540936876295804105L;
	
	    internal const bool ASSERTIONS = false;
	
	    internal const long GROWTH_PERCENT = 200; // 100 is no growth!
	
	    internal const long GROWTH_GAP = 10; // extra bump!
	
	    private int length;
	
	    // two parallel arrays to save memory. Wish Java had structs.
	    private int[] transitions;
	
	    private Object[] values;
	
	    private HashedSet availableValues;
	
	    private bool staleAvailableValues;
	
	    private bool errorOnReset;
	
	    private bool locked;
	
	    private int lastIndex;
	
	    public UnicodeMap Clear() {
	        if (locked)
	            throw new NotSupportedException(
	                    "Attempt to modify locked object");
	        length = 2;
	        transitions = new int[] { 0, 0x110000, 0, 0, 0, 0, 0, 0, 0, 0 };
	        values = new Object[10];
	
	        ILOG.J2CsMapping.Collections.Collections.Clear(availableValues);
	        staleAvailableValues = false;
	
	        errorOnReset = false;
	        lastIndex = 0;
	        return this;
	    }
	
	    /* Boilerplate */
	    public override bool Equals(Object other) {
	        if (other == null)
	            return false;
	        try {
	            UnicodeMap that = (UnicodeMap) other;
	            if (length != that.length)
	                return false;
	            for (int i = 0; i < length - 1; ++i) {
	                if (transitions[i] != that.transitions[i])
	                    return false;
	                if (!AreEqual(values[i], that.values[i]))
	                    return false;
	            }
	            return true;
	        } catch (InvalidCastException e) {
	            return false;
	        }
	    }
	
	    public int GetHashCode(Object o) {
	        return o.GetHashCode();
	        // equator.getHashCode
	    }
	
	    public static bool AreEqual(Object a, Object b) {
	        if (a == b)
	            return true;
	        if (a == null || b == null)
	            return false;
	        return a.Equals(b);
	    }
	
	    public override int GetHashCode() {
	        int result = length;
	        // TODO might want to abbreviate this for speed.
	        for (int i = 0; i < length - 1; ++i) {
	            result = 37 * result + transitions[i];
	            result = 37 * result + GetHashCode(values[i]);
	        }
	        return result;
	    }
	
	    /// <summary>
	    /// Standard clone. Warning, as with Collections, does not do deep clone.
	    /// </summary>
	    ///
	    public Object CloneAsThawed() {
	        UnicodeMap that = new UnicodeMap();
	        that.length = length;
	        that.transitions = (int[]) transitions.Clone();
	        that.values = (Object[]) values.Clone();
	        that.availableValues = new HashedSet(availableValues);
	        that.locked = false;
	        return that;
	    }
	
	    /* for internal consistency checking */
	
	    internal void _checkInvariants() {
	        if (length < 2 || length > transitions.Length
	                || transitions.Length != values.Length) {
	            throw new ArgumentException("Invariant failed: Lengths bad");
	        }
	        for (int i = 1; i < length - 1; ++i) {
	            if (AreEqual(values[i - 1], values[i])) {
	                throw new ArgumentException(
	                        "Invariant failed: values shared at " + "\t"
	                                + IBM.ICU.Impl.Utility.Hex(i - 1) + ": <" + values[i - 1]
	                                + ">" + "\t" + IBM.ICU.Impl.Utility.Hex(i) + ": <"
	                                + values[i] + ">");
	            }
	        }
	        if (transitions[0] != 0 || transitions[length - 1] != 0x110000) {
	            throw new ArgumentException(
	                    "Invariant failed: bounds set wrong");
	        }
	        for (int i_0 = 1; i_0 < length - 1; ++i_0) {
	            if (transitions[i_0 - 1] >= transitions[i_0]) {
	                throw new ArgumentException(
	                        "Invariant failed: not monotonic" + "\t"
	                                + IBM.ICU.Impl.Utility.Hex(i_0 - 1) + ": "
	                                + transitions[i_0 - 1] + "\t" + IBM.ICU.Impl.Utility.Hex(i_0)
	                                + ": " + transitions[i_0]);
	            }
	        }
	    }
	
	    /// <summary>
	    /// Finds an index such that inversionList[i] <= codepoint <
	    /// inversionList[i+1] Assumes that 0 <= codepoint <= 0x10FFFF
	    /// </summary>
	    ///
	    /// <param name="codepoint"></param>
	    /// <returns>the index</returns>
	    private int _findIndex(int c) {
	        int lo = 0;
	        int hi = length - 1;
	        int i = (int) (((uint) (lo + hi)) >> 1);
	        // invariant: c >= list[lo]
	        // invariant: c < list[hi]
	        while (i != lo) {
	            if (c < transitions[i]) {
	                hi = i;
	            } else {
	                lo = i;
	            }
	            i = (int) (((uint) (lo + hi)) >> 1);
	        }
	        if (ASSERTIONS)
	            _checkFind(c, lo);
	        return lo;
	    }
	
	    private void _checkFind(int codepoint, int value_ren) {
	        int other = __findIndex(codepoint);
	        if (other != value_ren) {
	            throw new ArgumentException(
	                    "Invariant failed: binary search" + "\t"
	                            + IBM.ICU.Impl.Utility.Hex(codepoint) + ": " + value_ren
	                            + "\tshould be: " + other);
	        }
	    }
	
	    private int __findIndex(int codepoint) {
	        // TODO use binary search
	        for (int i = length - 1; i > 0; --i) {
	            if (transitions[i] <= codepoint)
	                return i;
	        }
	        return 0;
	    }
	
	    /*
	     * Try indexed lookup
	     * 
	     * static final int SHIFT = 8; int[] starts = new int[0x10FFFF>>SHIFT]; //
	     * lowest transition index where codepoint>>x can be found boolean
	     * startsValid = false; private int findIndex(int codepoint) { if
	     * (!startsValid) { int start = 0; for (int i = 1; i < length; ++i) {
	     * 
	     * } } for (int i = length-1; i > 0; --i) { if (transitions[i] <= codepoint)
	     * return i; } return 0; }
	     */
	
	    /// <summary>
	    /// Remove the items from index through index+count-1. Logically reduces the
	    /// size of the internal arrays.
	    /// </summary>
	    ///
	    /// <param name="index"></param>
	    /// <param name="count"></param>
	    private void _removeAt(int index, int count) {
	        for (int i = index + count; i < length; ++i) {
	            transitions[i - count] = transitions[i];
	            values[i - count] = values[i];
	        }
	        length -= count;
	    }
	
	    /// <summary>
	    /// Add a gap from index to index+count-1. The values there are undefined,
	    /// and must be set. Logically grows arrays to accomodate. Actual growth is
	    /// limited
	    /// </summary>
	    ///
	    /// <param name="index"></param>
	    /// <param name="count"></param>
	    private void _insertGapAt(int index, int count) {
	        int newLength = length + count;
	        int[] oldtransitions = transitions;
	        Object[] oldvalues = values;
	        if (newLength > transitions.Length) {
	            int allocation = (int) (GROWTH_GAP + (newLength * GROWTH_PERCENT) / 100);
	            transitions = new int[allocation];
	            values = new Object[allocation];
	            for (int i = 0; i < index; ++i) {
	                transitions[i] = oldtransitions[i];
	                values[i] = oldvalues[i];
	            }
	        }
	        for (int i_0 = length - 1; i_0 >= index; --i_0) {
	            transitions[i_0 + count] = oldtransitions[i_0];
	            values[i_0 + count] = oldvalues[i_0];
	        }
	        length = newLength;
	    }
	
	    /// <summary>
	    /// Associates code point with value. Removes any previous association.
	    /// </summary>
	    ///
	    /// <param name="codepoint"></param>
	    /// <param name="value"></param>
	    /// <returns>this, for chaining</returns>
	    private UnicodeMap _put(int codepoint, Object value_ren) {
	        // Warning: baseIndex is an invariant; must
	        // be defined such that transitions[baseIndex] < codepoint
	        // at end of this routine.
	        int baseIndex;
	        if (transitions[lastIndex] <= codepoint
	                && codepoint < transitions[lastIndex + 1]) {
	            baseIndex = lastIndex;
	        } else {
	            baseIndex = _findIndex(codepoint);
	        }
	        int limitIndex = baseIndex + 1;
	        // cases are (a) value is already set
	        if (AreEqual(values[baseIndex], value_ren))
	            return this;
	        if (locked)
	            throw new NotSupportedException(
	                    "Attempt to modify locked object");
	        if (errorOnReset && values[baseIndex] != null) {
	            throw new ArgumentException("Attempt to reset value for "
	                    + IBM.ICU.Impl.Utility.Hex(codepoint)
	                    + " when that is disallowed. Old: " + values[baseIndex]
	                    + "; New: " + value_ren);
	        }
	
	        // adjust the available values
	        staleAvailableValues = true;
	        ILOG.J2CsMapping.Collections.Generics.Collections.Add(availableValues,value_ren); // add if not there already
	
	        int baseCP = transitions[baseIndex];
	        int limitCP = transitions[limitIndex];
	        // we now start walking through the difference case,
	        // based on whether we are at the start or end of range
	        // and whether the range is a single character or multiple
	
	        if (baseCP == codepoint) {
	            // CASE: At very start of range
	            bool connectsWithPrevious = baseIndex != 0
	                    && AreEqual(value_ren, values[baseIndex - 1]);
	
	            if (limitCP == codepoint + 1) {
	                // CASE: Single codepoint range
	                bool connectsWithFollowing = baseIndex < length - 1
	                        && AreEqual(value_ren, values[limitIndex]);
	
	                if (connectsWithPrevious) {
	                    // A1a connects with previous & following, so remove index
	                    if (connectsWithFollowing) {
	                        _removeAt(baseIndex, 2);
	                    } else {
	                        _removeAt(baseIndex, 1); // extend previous
	                    }
	                    --baseIndex; // fix up
	                } else if (connectsWithFollowing) {
	                    _removeAt(baseIndex, 1); // extend following backwards
	                    transitions[baseIndex] = codepoint;
	                } else {
	                    // doesn't connect on either side, just reset
	                    values[baseIndex] = value_ren;
	                }
	            } else if (connectsWithPrevious) {
	                // A.1: start of multi codepoint range
	                // if connects
	                ++transitions[baseIndex]; // extend previous
	            } else {
	                // otherwise insert new transition
	                transitions[baseIndex] = codepoint + 1; // fix following range
	                _insertGapAt(baseIndex, 1);
	                values[baseIndex] = value_ren;
	                transitions[baseIndex] = codepoint;
	            }
	        } else if (limitCP == codepoint + 1) {
	            // CASE: at end of range
	            // if connects, just back up range
	            bool connectsWithFollowing_0 = baseIndex < length - 1
	                    && AreEqual(value_ren, values[limitIndex]);
	
	            if (connectsWithFollowing_0) {
	                --transitions[limitIndex];
	                return this;
	            } else {
	                _insertGapAt(limitIndex, 1);
	                transitions[limitIndex] = codepoint;
	                values[limitIndex] = value_ren;
	            }
	        } else {
	            // CASE: in middle of range
	            // insert gap, then set the new range
	            _insertGapAt(++baseIndex, 2);
	            transitions[baseIndex] = codepoint;
	            values[baseIndex] = value_ren;
	            transitions[baseIndex + 1] = codepoint + 1;
	            values[baseIndex + 1] = values[baseIndex - 1]; // copy lower range
	                                                           // values
	        }
	        lastIndex = baseIndex; // store for next time
	        return this;
	    }
	
	    private UnicodeMap _putAll(int startCodePoint, int endCodePoint,
	            Object value_ren) {
	        for (int i = startCodePoint; i <= endCodePoint; ++i) {
	            _put(i, value_ren);
	        }
	        return this;
	    }
	
	    /// <summary>
	    /// Sets the codepoint value.
	    /// </summary>
	    ///
	    /// <param name="codepoint"></param>
	    /// <param name="value"></param>
	    /// <returns>this (for chaining)</returns>
	    public UnicodeMap Put(int codepoint, Object value_ren) {
	        if (codepoint < 0 || codepoint > 0x10FFFF) {
	            throw new ArgumentException("Codepoint out of range: "
	                    + codepoint);
	        }
	        _put(codepoint, value_ren);
	        if (ASSERTIONS)
	            _checkInvariants();
	        return this;
	    }
	
	    /// <summary>
	    /// Adds bunch o' codepoints; otherwise like put.
	    /// </summary>
	    ///
	    /// <param name="codepoints"></param>
	    /// <param name="value"></param>
	    /// <returns>this (for chaining)</returns>
	    public UnicodeMap PutAll(UnicodeSet codepoints, Object value_ren) {
	        // TODO optimize
	        UnicodeSetIterator it = new UnicodeSetIterator(codepoints);
	        while (it.NextRange()) {
	            _putAll(it.codepoint, it.codepointEnd, value_ren);
	        }
	        return this;
	    }
	
	    /// <summary>
	    /// Adds bunch o' codepoints; otherwise like add.
	    /// </summary>
	    ///
	    /// <param name="startCodePoint"></param>
	    /// <param name="endCodePoint"></param>
	    /// <param name="value"></param>
	    /// <returns>this (for chaining)</returns>
	    public UnicodeMap PutAll(int startCodePoint, int endCodePoint, Object value_ren) {
	        if (startCodePoint < 0 || endCodePoint > 0x10FFFF) {
	            throw new ArgumentException("Codepoint out of range: "
	                    + IBM.ICU.Impl.Utility.Hex(startCodePoint) + ".."
	                    + IBM.ICU.Impl.Utility.Hex(endCodePoint));
	        }
	        // TODO optimize
	        for (int i = startCodePoint; i <= endCodePoint; ++i) {
	            _put(i, value_ren);
	        }
	        return this;
	    }
	
	    /// <summary>
	    /// Add all the (main) values from a Unicode property
	    /// </summary>
	    ///
	    /// <param name="prop">the property to add to the map</param>
	    /// <returns>this (for chaining)</returns>
	    public UnicodeMap PutAll(UnicodeProperty prop) {
	        // TODO optimize
	        for (int i = 0; i <= 0x10FFFF; ++i) {
	            _put(i, prop.GetValue(i));
	        }
	        return this;
	    }
	
	    /// <summary>
	    /// Add all the (main) values from a Unicode property
	    /// </summary>
	    ///
	    /// <param name="prop">the property to add to the map</param>
	    /// <returns>this (for chaining)</returns>
	    public UnicodeMap PutAll(UnicodeMap prop) {
	        // TODO optimize
	        for (int i = 0; i <= 0x10FFFF; ++i) {
	            _put(i, prop.GetValue(i));
	        }
	        return this;
	    }
	
	    /// <summary>
	    /// Set the currently unmapped Unicode code points to the given value.
	    /// </summary>
	    ///
	    /// <param name="value">the value to set</param>
	    /// <returns>this (for chaining)</returns>
	    public UnicodeMap SetMissing(Object value_ren) {
	        // fast path, if value not yet present
	        if (!ILOG.J2CsMapping.Collections.Collections.Contains(value_ren,GetAvailableValues())) {
	            staleAvailableValues = true;
	            ILOG.J2CsMapping.Collections.Generics.Collections.Add(availableValues,value_ren);
	            for (int i = 0; i < length; ++i) {
	                if (values[i] == null)
	                    values[i] = value_ren;
	            }
	            return this;
	        } else {
	            return PutAll(GetSet(null), value_ren);
	        }
	    }
	
	    /// <summary>
	    /// Returns the set associated with a given value. Deposits into result if it
	    /// is not null. Remember to clear if you just want the new values.
	    /// </summary>
	    ///
	    /// <param name="value"></param>
	    /// <param name="result"></param>
	    /// <returns>result</returns>
	    public UnicodeSet GetSet(Object value_ren, UnicodeSet result) {
	        if (result == null)
	            result = new UnicodeSet();
	        for (int i = 0; i < length - 1; ++i) {
	            if (AreEqual(value_ren, values[i])) {
	                result.Add(transitions[i], transitions[i + 1] - 1);
	            }
	        }
	        return result;
	    }
	
	    public UnicodeSet GetSet(Object value_ren) {
	        return GetSet(value_ren, null);
	    }
	
	    public UnicodeSet KeySet() {
	        return GetSet(null, null).Complement();
	    }
	
	    /// <summary>
	    /// Returns the list of possible values. Deposits each non-null value into
	    /// result. Creates result if it is null. Remember to clear result if you are
	    /// not appending to existing collection.
	    /// </summary>
	    ///
	    /// <param name="result"></param>
	    /// <returns>result</returns>
	    public ICollection GetAvailableValues(ICollection result) {
	        if (staleAvailableValues) {
	            // collect all the current values
	            // retain them in the availableValues
	            ILOG.J2CsMapping.Collections.ISet temp = new HashedSet();
	            for (int i = 0; i < length - 1; ++i) {
	                if (values[i] != null)
	                    ILOG.J2CsMapping.Collections.Generics.Collections.Add(temp,values[i]);
	            }
	            availableValues.RetainAll(temp);
	            staleAvailableValues = false;
	        }
	        if (result == null)
	            result = new ArrayList(availableValues.Count);
	        ILOG.J2CsMapping.Collections.Generics.Collections.AddAll(availableValues,result);
	        return result;
	    }
	
	    /// <summary>
	    /// Convenience method
	    /// </summary>
	    ///
	    public ICollection GetAvailableValues() {
	        return GetAvailableValues(null);
	    }
	
	    /// <summary>
	    /// Gets the value associated with a given code point. Returns null, if there
	    /// is no such value.
	    /// </summary>
	    ///
	    /// <param name="codepoint"></param>
	    /// <returns>the value</returns>
	    public Object GetValue(int codepoint) {
	        if (codepoint < 0 || codepoint > 0x10FFFF) {
	            throw new ArgumentException("Codepoint out of range: "
	                    + codepoint);
	        }
	        return values[_findIndex(codepoint)];
	    }
	
	    /// <summary>
	    /// Change a new string from the source string according to the mappings. For
	    /// each code point cp, if getValue(cp) is null, append the character,
	    /// otherwise append getValue(cp).toString()
	    /// </summary>
	    ///
	    /// <param name="source"></param>
	    /// <returns></returns>
	    public String Fold(String source) {
	        StringBuilder result = new StringBuilder();
	        int cp;
	        for (int i = 0; i < source.Length; i += IBM.ICU.Text.UTF16.GetCharCount(cp)) {
	            cp = IBM.ICU.Text.UTF16.CharAt(source, i);
	            Object mResult = GetValue(cp);
	            if (mResult != null) {
	                result.Append(mResult);
	            } else {
	                IBM.ICU.Text.UTF16.Append(result, cp);
	            }
	        }
	        return result.ToString();
	    }
	
	    public interface Composer {
	        Object Compose(int codePoint, Object a, Object b);
	    }
	
	    public UnicodeMap ComposeWith(UnicodeMap other, UnicodeMap.Composer  composer) {
	        for (int i = 0; i <= 0x10FFFF; ++i) {
	            Object v1 = GetValue(i);
	            Object v2 = other.GetValue(i);
	            Object v3 = composer.Compose(i, v1, v2);
	            if (v1 != v3 && (v1 == null || !v1.Equals(v3)))
	                Put(i, v3);
	        }
	        return this;
	    }
	
	    public UnicodeMap ComposeWith(UnicodeSet set, Object value_ren,
	            UnicodeMap.Composer  composer) {
	        for (UnicodeSetIterator it = new UnicodeSetIterator(set); it.Next();) {
	            int i = it.codepoint;
	            Object v1 = GetValue(i);
	            Object v3 = composer.Compose(i, v1, value_ren);
	            if (v1 != v3 && (v1 == null || !v1.Equals(v3)))
	                Put(i, v3);
	        }
	        return this;
	    }
	
	    /// <summary>
	    /// Follow the style used by UnicodeSetIterator
	    /// </summary>
	    ///
	    public class MapIterator {
	        public int codepoint;
	
	        public int codepointEnd;
	
	        public Object value_ren;
	
	        private UnicodeMap map;
	
	        private int index;
	
	        private int startRange;
	
	        private int endRange;
	
	        private Object lastValue;
	
	        public MapIterator(UnicodeMap map_0) {
	            Reset(map_0);
	        }
	
	        // note: length of 2 means {0, 110000}. Only want to index up to 0!
	        public bool NextRange() {
	            if (index < 0 || index >= map.length - 1)
	                return false;
	            value_ren = map.values[index];
	            codepoint = startRange = map.transitions[index++];
	            codepointEnd = endRange = map.transitions[index] - 1; // -1 to make
	                                                                  // limit into
	                                                                  // end
	            return true;
	        }
	
	        public bool Next() {
	            if (startRange > endRange) {
	                // System.out.println("***" + Utility.hex(startRange) + ".." +
	                // Utility.hex(endRange));
	                if (!NextRange())
	                    return false;
	                // index now points AFTER the start of the range
	                lastValue = map.values[index - 1];
	                // System.out.println("***" + Utility.hex(codepoint) + ".." +
	                // Utility.hex(codepointEnd) + " => " + lastValue);
	            }
	            value_ren = lastValue;
	            codepoint = codepointEnd = startRange++; // set to first, and
	                                                     // iterate
	            return true;
	        }
	
	        public UnicodeMap.MapIterator  Reset() {
	            index = 0;
	            startRange = 0;
	            endRange = -1;
	            return this;
	        }
	
	        public UnicodeMap.MapIterator  Reset(UnicodeMap newMap) {
	            this.map = newMap;
	            return Reset();
	        }
	    }
	
	    public override String ToString() {
	        return ToString(null);
	    }
	
	    public String ToString(IComparer collected) {
	        StringBuilder result = new StringBuilder();
	        if (collected == null) {
	            for (int i = 0; i < length - 1; ++i) {
	                Object value_ren = values[i];
	                if (value_ren == null)
	                    continue;
	                int start = transitions[i];
	                int end = transitions[i + 1] - 1;
	                result.Append(IBM.ICU.Impl.Utility.Hex(start));
	                if (start != end)
	                    result.Append("..").Append(IBM.ICU.Impl.Utility.Hex(end));
	                result.Append("\t=> ")
	                        .Append((values[i] == null) ? "null" : values[i]
	                                .ToString()).Append("\r\n");
	            }
	        } else {
	            ILOG.J2CsMapping.Collections.ISet set = (ISet) GetAvailableValues(new SortedSet(collected));
	            for (IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(set.GetEnumerator()); it.HasNext();) {
	                Object value_0 = it.Next();
	                UnicodeSet s = GetSet(value_0);
	                result.Append(value_0).Append("\t=> ").Append(s.ToPattern(true))
	                        .Append("\r\n");
	            }
	        }
	        return result.ToString();
	    }
	
	    
	    /// <returns>Returns the errorOnReset.</returns>
	    public bool GetErrorOnReset() {
	        return errorOnReset;
	    }
	
	    
	    /// <param name="errorOnReset_0">The errorOnReset to set.</param>
	    public void SetErrorOnReset(bool errorOnReset_0) {
	        this.errorOnReset = errorOnReset_0;
	    }
	
	    /*
	     * (non-Javadoc)
	     * 
	     * @see com.ibm.icu.dev.test.util.Lockable#isLocked()
	     */
	    public bool IsFrozen() {
	        // TODO Auto-generated method stub
	        return locked;
	    }
	
	    /*
	     * (non-Javadoc)
	     * 
	     * @see com.ibm.icu.dev.test.util.Lockable#lock()
	     */
	    public Object Freeze() {
	        locked = true;
	        return this;
	    }
	
	    internal const bool DEBUG_WRITE = false;
	
	    // TODO Fix to serialize more than just strings.
	    // Only if all the items are strings will we do the following compression
	    // Otherwise we'll just use Java Serialization, bulky as it is
	    /*public void WriteExternal(ObjectOutput out1) {
	        DataOutputCompressor sc = new DataOutputCompressor(out1);
	        // if all objects are strings
	        ICollection availableVals = GetAvailableValues();
	        bool allStrings = AllAreString(availableVals);
	        sc.WriteBoolean(allStrings);
	        IDictionary object_index = new Hashtable();
	        if (AllAreString(availableVals)) {
	            sc.WriteStringSet(new SortedSet(availableVals), object_index);
	        } else {
	            sc.WriteCollection(availableVals, object_index);
	        }
	        sc.WriteUInt(length);
	        int lastTransition = -1;
	        int lastValueNumber = 0;
	        if (DEBUG_WRITE)
	            System.Console.Out.WriteLine("Trans count: " + length);
	        for (int i = 0; i < length; ++i) {
	            int valueNumber = ((Int32) ILOG.J2CsMapping.Collections.Collections.Get(object_index,values[i]));
	            if (DEBUG_WRITE)
	                System.Console.Out.WriteLine("Trans: " + transitions[i] + ",\t"
	                        + valueNumber);
	
	            int deltaTransition = transitions[i] - lastTransition;
	            lastTransition = transitions[i];
	            int deltaValueNumber = valueNumber - lastValueNumber;
	            lastValueNumber = valueNumber;
	
	            deltaValueNumber <<= 1; // make room for one bit
	            bool canCombine = deltaTransition == 1;
	            if (canCombine)
	                deltaValueNumber |= 1;
	            sc.WriteInt(deltaValueNumber);
	            if (DEBUG_WRITE)
	                System.Console.Out.WriteLine("deltaValueNumber: " + deltaValueNumber);
	            if (!canCombine) {
	                sc.WriteUInt(deltaTransition);
	                if (DEBUG_WRITE)
	                    System.Console.Out.WriteLine("deltaTransition: " + deltaTransition);
	            }
	        }
	        sc.Flush();
	    }*/
	
	    private bool AllAreString(ICollection availableValues2) {
	        // if (true) return false;
	        for (IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(availableValues2.GetEnumerator()); it.HasNext();) {
	            if (!(it.Next()  is  String))
	                return false;
	        }
	        return true;
	    }
	
	    /*public void ReadExternal(ObjectInput in1) {
	        DataInputCompressor sc = new DataInputCompressor(in1);
	        bool allStrings = sc.ReadBoolean();
	        Object[] valuesList;
	        availableValues = new LinkedHashSet();
	        if (allStrings) {
	            valuesList = sc.ReadStringSet(availableValues);
	        } else {
	            valuesList = sc.ReadCollection(availableValues);
	        }
	        length = sc.ReadUInt();
	        transitions = new int[length];
	        if (DEBUG_WRITE)
	            System.Console.Out.WriteLine("Trans count: " + length);
	        values = new Object[length];
	        int currentTransition = -1;
	        int currentValue = 0;
	        int deltaTransition;
	        for (int i = 0; i < length; ++i) {
	            int temp = sc.ReadInt();
	            if (DEBUG_WRITE)
	                System.Console.Out.WriteLine("deltaValueNumber: " + temp);
	            bool combined = (temp & 1) != 0;
	            temp >>= 1;
	            values[i] = valuesList[currentValue += temp];
	            if (!combined) {
	                deltaTransition = sc.ReadUInt();
	                if (DEBUG_WRITE)
	                    System.Console.Out.WriteLine("deltaTransition: " + deltaTransition);
	            } else {
	                deltaTransition = 1;
	            }
	            transitions[i] = currentTransition += deltaTransition; // delta
	                                                                   // value
	            if (DEBUG_WRITE)
	                System.Console.Out.WriteLine("Trans: " + transitions[i] + ",\t"
	                        + currentValue);
	        }
	    }*/
	
	    static internal int FindCommon(String last, String s) {
	        int minLen = Math.Min(last.Length,s.Length);
	        for (int i = 0; i < minLen; ++i) {
	            if (last[i] != s[i])
	                return i;
	        }
	        return minLen;
	    }
	
	    // /**
	    // * @param sc
	    // * @throws IOException
	    // *
	    // */
	    // private void showSize(String title, ObjectOutput out, StreamCompressor
	    // sc) throws IOException {
	    // sc.showSize(this, title, out);
	    // }
	    // //public void readObject(ObjectInputStream in) throws IOException {
	    // public static class StreamCompressor {
	    // transient byte[] buffer = new byte[1];
	    // transient StringBuffer stringBuffer = new StringBuffer();
	    //
	    // transient byte[] readWriteBuffer = new byte[8];
	    // int position = 0;
	    // DataOutput out;
	    // DataInput in;
	    //
	    // /**
	    // * Format is:
	    // * @throws IOException
	    // */
	    // public void writeInt(int i) throws IOException {
	    // while (true) {
	    // if (position == readWriteBuffer.length) {
	    // out.write(readWriteBuffer);
	    // position = 0;
	    // }
	    // if ((i & ~0x7F) == 0) {
	    // readWriteBuffer[position++] = (byte)i;
	    // break;
	    // }
	    // readWriteBuffer[position++] = (byte)(0x80 | i);
	    // i >>>= 7;
	    // }
	    // }
	    // /**
	    // * @throws IOException
	    // *
	    // */
	    // public int readNInt(ObjectInput in) throws IOException {
	    // int result = readInt(in);
	    // boolean negative = (result & 1) != 0;
	    // result >>>= 1;
	    // if (negative) result = ~result;
	    // return result;
	    // }
	    // /**
	    // * @throws IOException
	    // *
	    // */
	    // public void writeNInt(int input) throws IOException {
	    // int flag = 0;
	    // if (input < 0) {
	    // input = ~input;
	    // flag = 1;
	    // }
	    // input = (input << 1) | flag;
	    // writeInt(out, input);
	    // }
	    // /**
	    // * @throws IOException
	    // *
	    // */
	    // public void flush() throws IOException {
	    // out.write(readWriteBuffer);
	    // position = 0;
	    // }
	    //
	    // int readPosition = readWriteBuffer.length;
	    //
	    // public int readInt(ObjectInput in) throws IOException {
	    // int result = 0;
	    // int offset = 0;
	    // while (true) {
	    // if (readPosition == readWriteBuffer.length) {
	    // in.read(readWriteBuffer);
	    // readPosition = 0;
	    // }
	    // //in.read(buffer);
	    // int input = readWriteBuffer[readPosition++]; // buffer[0];
	    // result |= (input & 0x7F) << offset;
	    // if ((input & 0x80) == 0) {
	    // return result;
	    // }
	    // offset += 7;
	    // }
	    // }
	    //
	    // /**
	    // * @throws IOException
	    // *
	    // */
	    // public void writeString(String s) throws IOException {
	    // writeInt(UTF16.countCodePoint(s));
	    // writeCodePoints(s);
	    // }
	    // /**
	    // *
	    // */
	    // private void writeCodePoints(String s) throws IOException {
	    // int cp = 0;
	    // for (int i = 0; i < s.length(); i += UTF16.getCharCount(cp)) {
	    // cp = UTF16.charAt(s, i);
	    // writeInt(cp);
	    // }
	    // }
	    // /**
	    // * @throws IOException
	    // *
	    // */
	    // public String readString() throws IOException {
	    // int len = readInt(in);
	    // return readCodePoints(in, len);
	    // }
	    // /**
	    // *
	    // */
	    // private String readCodePoints(int len) throws IOException {
	    // stringBuffer.setLength(0);
	    // for (int i = 0; i < len; ++i) {
	    // int cp = readInt(in);
	    // UTF16.append(stringBuffer, cp);
	    // }
	    // return stringBuffer.toString();
	    // }
	    // /**
	    // * @param this
	    // * @throws IOException
	    // *
	    // */
	    // private void showSize(UnicodeMap map, String title, ObjectOutput out)
	    // throws IOException {
	    // out.flush();
	    // System.out.println(title + ": " + (map.debugOut.size() + position));
	    // }
	    // }
	}
	// #endif
}
