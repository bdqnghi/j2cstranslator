/*
 **********************************************************************
 * Copyright (c) 2002-2006, International Business Machines
 * Corporation and others.  All Rights Reserved.
 **********************************************************************
 * Author: Mark Davis
 **********************************************************************
 */// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/13/10 4:01 PM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
namespace IBM.ICU.Charset
{

    using ILOG.J2CsMapping.Collections;
    using ILOG.J2CsMapping.Collections.Generics;
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.IO;
    using System.Runtime.CompilerServices;

    /// <summary>
    /// A collection that is like a sorted set, except that it allows multiple
    /// elements that compare as equal
    /// </summary>
    ///
    // TODO replace use of Set with a collection that takes an Equator
    public class SortedBag : ICollection
    {
        /// <summary>
        /// A map of sets, where each corresponds to one sorted element. The sets are
        /// never empty
        /// </summary>
        ///
        internal IDictionary m;

        private int size;

        public SortedBag(IComparer c)
        {
            EMPTY_ITERATOR = new ILOG.J2CsMapping.Collections.IteratorAdapter(new HashedSet().GetEnumerator());
            m = new SortedList(c);
        }

        public virtual bool Add(Object s)
        {
            ILOG.J2CsMapping.Collections.ISet o = (ISet)ILOG.J2CsMapping.Collections.Collections.Get(m, s);
            if (o == null)
            {
                o = new HashedSet(1);
                ILOG.J2CsMapping.Collections.Collections.Put(m, s, o);
            }
            bool result = ILOG.J2CsMapping.Collections.Generics.Collections.Add(o, s);
            if (result)
                size++;
            return result;
        }

        public virtual IIterator Iterator()
        {
            return new SortedBag.MyIterator(this);
        }

        static internal IIterator EMPTY_ITERATOR;

        internal class MyIterator : IIterator
        {
            private SortedBag outer_SortedBag;

            private IIterator mapIterator;

            private IIterator setIterator;

            internal MyIterator(SortedBag bag)
            {
                outer_SortedBag = bag;
                this.mapIterator = new ILOG.J2CsMapping.Collections.IteratorAdapter(new ILOG.J2CsMapping.Collections.ListSet(outer_SortedBag.m.Keys).GetEnumerator());
                this.setIterator = null;
                mapIterator = new ILOG.J2CsMapping.Collections.IteratorAdapter(new ILOG.J2CsMapping.Collections.ListSet(outer_SortedBag.m.Keys).GetEnumerator());
                setIterator = GetSetIterator();
            }

            public IIterator GetSetIterator()
            {
                if (!mapIterator.HasNext())
                    return IBM.ICU.Charset.SortedBag.EMPTY_ITERATOR;
                return new ILOG.J2CsMapping.Collections.IteratorAdapter(((ISet)ILOG.J2CsMapping.Collections.Collections.Get(outer_SortedBag.m, mapIterator.Next())).GetEnumerator());
            }

            public virtual bool HasNext()
            {
                return setIterator.HasNext() || mapIterator.HasNext();
            }

            public virtual Object Next()
            {
                if (!setIterator.HasNext())
                {
                    setIterator = GetSetIterator();
                }
                return setIterator.Next();
            }

            public virtual void Remove()
            {
                throw new NotSupportedException();
            }

            #region AddedByTranslator

            object ILOG.J2CsMapping.Collections.IIterator.Next()
            {
                return this.Next();
            }

            #endregion

        }

        public virtual void Clear()
        {
            m.Clear();
        }


        public virtual int Count
        {
            get
            {
                return size;
            }
        }


        public virtual bool IsEmpty()
        {
            return size == 0;
        }

        public virtual bool Contains(Object o)
        {
            ILOG.J2CsMapping.Collections.ISet set = (ISet)ILOG.J2CsMapping.Collections.Collections.Get(m, o);
            if (set == null)
                return false;
            return ILOG.J2CsMapping.Collections.Collections.Contains(o, set);
        }

        public virtual Object[] ToArray()
        {
            return ILOG.J2CsMapping.Collections.Collections.ToArray(this, new Object[size]);
        }

        public virtual Object[] ToArray(Object[] a)
        {
            int count = 0;
            for (IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(this.GetEnumerator()); it.HasNext(); )
            {
                a[count++] = it.Next();
            }
            return a;
        }

        /*
         * (non-Javadoc)
         * 
         * @see java.util.Collection#remove(java.lang.Object)
         */
        public virtual bool Remove(Object o)
        {
            ILOG.J2CsMapping.Collections.ISet set = (ISet)ILOG.J2CsMapping.Collections.Collections.Get(m, o);
            if (set == null)
                return false;
            if (!ILOG.J2CsMapping.Collections.Generics.Collections.Remove(set, o))
                return false;
            if (set.Count == 0)
                ILOG.J2CsMapping.Collections.Collections.Remove(m, o);
            size--;
            return true;
        }

        public virtual bool ContainsAll(ICollection c)
        {
            for (IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(c.GetEnumerator()); it.HasNext(); )
            {
                if (!ILOG.J2CsMapping.Collections.Collections.Contains(it.Next(), this))
                    return false;
            }
            return true;
        }

        public virtual bool AddAll(ICollection c)
        {
            bool result = false;
            for (IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(c.GetEnumerator()); it.HasNext(); )
            {
                if (ILOG.J2CsMapping.Collections.Collections.Add(this, it.Next()))
                    result = true;
            }
            return result;
        }

        public virtual bool RemoveAll(ICollection c)
        {
            bool result = false;
            for (IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(c.GetEnumerator()); it.HasNext(); )
            {
                if (ILOG.J2CsMapping.Collections.Generics.Collections.Remove(this, it.Next()))
                    result = true;
            }
            return result;
        }

        public virtual bool RetainAll(ICollection c)
        {
            // WARNING: this may not work if the comparator does not distinguish
            // all items that are equals().
            ILOG.J2CsMapping.Collections.ISet stuffToRemove = new HashedSet(); // have to do this since iterator may
            // not allow removal!
            for (IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(this.GetEnumerator()); it.HasNext(); )
            {
                Object item = it.Next();
                if (!ILOG.J2CsMapping.Collections.Collections.Contains(item, c))
                    ILOG.J2CsMapping.Collections.Generics.Collections.Add(stuffToRemove, item);
            }
            return RemoveAll(stuffToRemove);
        }

        #region ICollection Members

        public void CopyTo(Array array, int index)
        {
            throw new NotImplementedException();
        }

        public bool IsSynchronized
        {
            get { throw new NotImplementedException(); }
        }

        public object SyncRoot
        {
            get { throw new NotImplementedException(); }
        }

        #endregion

        #region IEnumerable Members

        public IEnumerator GetEnumerator()
        {
            throw new NotImplementedException();
        }

        #endregion
    }
}
