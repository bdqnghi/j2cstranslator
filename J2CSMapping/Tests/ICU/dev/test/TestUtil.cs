//##header J2SE15
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/13/10 10:46 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2001-2006, International Business Machines Corporation and    
/// others. All Rights Reserved.                                                
/// </summary>
///
namespace IBM.ICU.Charset {
	
	using ILOG.J2CsMapping.Threading;
	using ILOG.J2CsMapping.Util;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Text;
	using System.Threading;
	
	public sealed class TestUtil {
	    /// <summary>
	    /// Path to test data in icu4jtest.jar
	    /// </summary>
	    ///
	    public const String LOCAL_DATA_PATH = "/com/ibm/icu/dev/data/";
	
	    /// <summary>
	    /// Standard path to the test data in the file system.
	    /// </summary>
	    ///
	    public const String DATA_PATH = "/src" + LOCAL_DATA_PATH;
	
	    /// <summary>
	    /// Property for user-defined data path.
	    /// </summary>
	    ///
	    public const String DATA_PATH_PROPERTY = "ICUDataPath";
	
	    /// <summary>
	    /// Property for modular build.
	    /// </summary>
	    ///
	    public const String DATA_MODULAR_BUILD_PROPERTY = "ICUModularBuild";
	
	    /// <summary>
	    /// Compute a full data path using the ICUDataPath, if defined, or the
	    /// user.dir, if we are allowed access to it.
	    /// </summary>
	    ///
	    private static String DataPath(String fileName) {
	        String s = System.Environment.GetEnvironmentVariable(DATA_PATH_PROPERTY);
	        if (s == null) {
	            // assume user.dir is directly above src directory
	            // data path must end in '/' or '\', fileName should not start with
	            // one
	            s = System.Environment.GetEnvironmentVariable("user.dir"); // protected property
	            s = s + DATA_PATH;
	        }
	        return s + fileName;
	    }
	
	    /// <summary>
	    /// Return an input stream on the data file at path 'name' rooted at the data
	    /// path
	    /// </summary>
	    ///
	    public static Stream GetDataStream(String name) {
	        Stream mask0 = null;
	        try {
	            mask0 = File.OpenRead(DataPath(name));
	        } catch (Exception e) {
	            try {
	                mask0 = typeof(TestUtil).Assembly.GetFile(LOCAL_DATA_PATH + name);
	            } catch (Exception t) {
	                IOException ex = new IOException("data resource '" + name
	                        + "' not found");
	                // #if defined(FOUNDATION10) || defined(J2SE13)
	                // ## t.printStackTrace();
	                // #else
	                // initCause API was introduced in JDK 1.4
	                //ex.InitCause(t);
	                // #endif
	
	                throw ex;
	            }
	        }
	        return mask0;
	    }
	
	    /// <summary>
	    /// Return a buffered reader on the data file at path 'name' rooted at the
	    /// data path.
	    /// </summary>
	    ///
	    public static TextReader GetDataReader(String name, String charset) {
	        Stream mask0 = GetDataStream(name);
	        StreamReader isr = (charset == null) ? new StreamReader(mask0)
	                : new StreamReader(mask0,System.Text.Encoding.GetEncoding(charset));
	        return isr;
	    }
	
	    /// <summary>
	    /// Return a buffered reader on the data file at path 'name' rooted at the
	    /// data path, using the provided encoding.
	    /// </summary>
	    ///
	    public static TextReader GetDataReader(String name) {
	        return GetDataReader(name, null);
	    }
	
	    static internal readonly char[] DIGITS = { '0', '1', '2', '3', '4', '5', '6', '7', '8',
	            '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
	            'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y',
	            'Z' };
	
	    /// <summary>
	    /// Return true if the character is NOT printable ASCII. The tab, newline and
	    /// linefeed characters are considered unprintable.
	    /// </summary>
	    ///
	    public static bool IsUnprintable(int c) {
	        return !(c >= 0x20 && c <= 0x7E);
	    }
	
	    /// <summary>
	    /// Escape unprintable characters using <backslash>uxxxx notation for U+0000
	    /// to U+FFFF and <backslash>Uxxxxxxxx for U+10000 and above. If the
	    /// character is printable ASCII, then do nothing and return FALSE.
	    /// Otherwise, append the escaped notation and return TRUE.
	    /// </summary>
	    ///
	    public static bool EscapeUnprintable(StringBuilder result, int c) {
	        if (IsUnprintable(c)) {
	            result.Append('\\');
	            if ((c & ~0xFFFF) != 0) {
	                result.Append('U');
	                result.Append(DIGITS[0xF & (c >> 28)]);
	                result.Append(DIGITS[0xF & (c >> 24)]);
	                result.Append(DIGITS[0xF & (c >> 20)]);
	                result.Append(DIGITS[0xF & (c >> 16)]);
	            } else {
	                result.Append('u');
	            }
	            result.Append(DIGITS[0xF & (c >> 12)]);
	            result.Append(DIGITS[0xF & (c >> 8)]);
	            result.Append(DIGITS[0xF & (c >> 4)]);
	            result.Append(DIGITS[0xF & c]);
	            return true;
	        }
	        return false;
	    }
	
	    internal class Lock {
	        private int count;
	
	        [MethodImpl(MethodImplOptions.Synchronized)]
	        internal void Inc() {
	            ++count;
	        }
	
	        [MethodImpl(MethodImplOptions.Synchronized)]
	        internal void Dec() {
	            --count;
	        }
	
	        [MethodImpl(MethodImplOptions.Synchronized)]
	        internal int Count() {
	            return count;
	        }
	
	        internal void Go() {
	            try {
	                while (Count() > 0) {
	                     lock (this) {
	                                            ILOG.J2CsMapping.Threading.ThreadUtil.NotifyAll(this);
	                                        }
	                    ILOG.J2CsMapping.Threading.ThreadWrapper.Sleep(50);
	                }
	            } catch (ThreadInterruptedException e) {
	            }
	        }
	    }
	
	    internal class TestThread : ThreadWrapper {
	        internal TestUtil.Lock  loke;
	
	        internal IRunnable target;
	
	        internal TestThread(TestUtil.Lock  loke, IRunnable target_0) {
	            this.loke = loke;
	            this.target = target_0;
	
	            loke.Inc();
	        }
	
	        public override void Run() {
	            try {
	                 lock (loke) {
	                                    ILOG.J2CsMapping.Threading.ThreadUtil.Wait(loke);
	                                }
	                target.Run();
	            } catch (ThreadInterruptedException e) {
	            }
	
	            loke.Dec();
	        }
	    }
	
	    public static void RunUntilDone(IRunnable[] targets) {
	        if (targets == null) {
	            throw new ArgumentException("targets is null");
	        }
	        if (targets.Length == 0) {
	            return;
	        }
	
	        TestUtil.Lock  loke = new TestUtil.Lock ();
	        for (int i = 0; i < targets.Length; ++i) {
	            new TestUtil.TestThread (loke, targets[i]).Start();
	        }
	
	        loke.Go();
	    }
	
	    public static TextReader OpenUTF8Reader(String dir, String filename) {
	        return OpenReader(dir, filename, "UTF-8");
	    }
	
	    public static TextReader OpenReader(String dir, String filename,
	            String encoding) {
	        FileInfo file = new FileInfo(dir + filename);
	        return new StreamReader(file.OpenRead(),System.Text.Encoding.GetEncoding(encoding));
	    }
	
	}
}
