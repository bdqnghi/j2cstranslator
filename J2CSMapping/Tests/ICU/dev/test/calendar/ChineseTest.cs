// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/13/10 4:02 PM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2000-2007, International Business Machines Corporation and
/// others. All Rights Reserved.
/// </summary>
///
namespace IBM.ICU.Charset
{

    using IBM.ICU.Text;
    using IBM.ICU.Util;
    using ILOG.J2CsMapping.Util;
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.Globalization;
    using System.IO;
    using System.Runtime.CompilerServices;
    using System.Text;
    using NUnit.Framework;

    /// <summary>
    /// Test of ChineseCalendar.
    /// Leap months in this century: Wed May 23 2001 = 4638-04///-01, Year 18, Cycle 78
    /// Sun Mar 21 2004 = 4641-02///-01, Year 21, Cycle 78 Thu Aug 24 2006 =
    /// 4643-07///-01, Year 23, Cycle 78 Tue Jun 23 2009 = 4646-05///-01, Year 26, Cycle
    /// 78 Mon May 21 2012 = 4649-04///-01, Year 29, Cycle 78 Fri Oct 24 2014 =
    /// 4651-09///-01, Year 31, Cycle 78 Sun Jul 23 2017 = 4654-06///-01, Year 34, Cycle
    /// 78 Sat May 23 2020 = 4657-04///-01, Year 37, Cycle 78 Wed Mar 22 2023 =
    /// 4660-02///-01, Year 40, Cycle 78 Fri Jul 25 2025 = 4662-06///-01, Year 42, Cycle
    /// 78 Fri Jun 23 2028 = 4665-05///-01, Year 45, Cycle 78 Tue Apr 22 2031 =
    /// 4668-03///-01, Year 48, Cycle 78 Thu Dec 22 2033 = 4670-11///-01, Year 50, Cycle
    /// 78 Wed Jul 23 2036 = 4673-06///-01, Year 53, Cycle 78 Wed Jun 22 2039 =
    /// 4676-05///-01, Year 56, Cycle 78 Sat Mar 22 2042 = 4679-02///-01, Year 59, Cycle
    /// 78 Tue Aug 23 2044 = 4681-07///-01, Year 01, Cycle 79 Sun Jun 23 2047 =
    /// 4684-05///-01, Year 04, Cycle 79 Thu Apr 21 2050 = 4687-03///-01, Year 07, Cycle
    /// 79 Mon Sep 23 2052 = 4689-08///-01, Year 09, Cycle 79 Sat Jul 24 2055 =
    /// 4692-06///-01, Year 12, Cycle 79 Wed May 22 2058 = 4695-04///-01, Year 15, Cycle
    /// 79 Wed Apr 20 2061 = 4698-03///-01, Year 18, Cycle 79 Fri Aug 24 2063 =
    /// 4700-07///-01, Year 20, Cycle 79 Wed Jun 23 2066 = 4703-05///-01, Year 23, Cycle
    /// 79 Tue May 21 2069 = 4706-04///-01, Year 26, Cycle 79 Thu Sep 24 2071 =
    /// 4708-08///-01, Year 28, Cycle 79 Tue Jul 24 2074 = 4711-06///-01, Year 31, Cycle
    /// 79 Sat May 22 2077 = 4714-04///-01, Year 34, Cycle 79 Sat Apr 20 2080 =
    /// 4717-03///-01, Year 37, Cycle 79 Mon Aug 24 2082 = 4719-07///-01, Year 39, Cycle
    /// 79 Fri Jun 22 2085 = 4722-05///-01, Year 42, Cycle 79 Fri May 21 2088 =
    /// 4725-04///-01, Year 45, Cycle 79 Sun Sep 24 2090 = 4727-08///-01, Year 47, Cycle
    /// 79 Thu Jul 23 2093 = 4730-06///-01, Year 50, Cycle 79 Tue May 22 2096 =
    /// 4733-04///-01, Year 53, Cycle 79 Sun Mar 22 2099 = 4736-02///-01, Year 56, Cycle
    /// 79
    /// </summary>
    [TestFixture]
    public class ChineseTest : CalendarTest
    {

        public static void Main(String[] args)
        {
            new ChineseTest().Run(args);
        }

        /// <summary>
        /// Test basic mapping to and from Gregorian.
        /// </summary>
        [Test]
        public void TestMapping()
        {

            int[] DATA = {
	                // (Note: months are 1-based)
	                // Gregorian Chinese
	                1964, 9, 4, 4601, 7, 0, 28, 1964, 9, 5, 4601, 7, 0, 29, 1964,
	                9, 6, 4601, 8, 0, 1, 1964, 9, 7, 4601, 8, 0, 2, 1961, 12, 25,
	                4598, 11, 0, 18, 1999, 6, 4, 4636, 4, 0, 21,
	
	                1990, 5, 23, 4627, 4, 0, 29, 1990, 5, 24, 4627, 5, 0, 1, 1990,
	                6, 22, 4627, 5, 0, 30, 1990, 6, 23, 4627, 5, 1, 1, 1990, 7, 20,
	                4627, 5, 1, 28, 1990, 7, 21, 4627, 5, 1, 29, 1990, 7, 22, 4627,
	                6, 0, 1, };

            ChineseCalendar cal = new ChineseCalendar();
            StringBuilder buf = new StringBuilder();

            Logln("Gregorian -> Chinese");
            // java.util.Calendar grego = java.util.Calendar.getInstance();
            IBM.ICU.Util.Calendar grego = IBM.ICU.Util.Calendar.GetInstance();
            grego.Clear();
            for (int i = 0; i < DATA.Length; )
            {
                grego.Set(DATA[i++], DATA[i++] - 1, DATA[i++]);
                DateTime date = grego.GetTime();
                cal.SetTime(date);
                int y = cal.Get(IBM.ICU.Util.Calendar.EXTENDED_YEAR);
                int m = cal.Get(IBM.ICU.Util.Calendar.MONTH) + 1; // 0-based -> 1-based
                int L = cal.Get(IBM.ICU.Util.ChineseCalendar.IS_LEAP_MONTH);
                int d = cal.Get(IBM.ICU.Util.Calendar.DAY_OF_MONTH);
                int yE = DATA[i++]; // Expected y, m, isLeapMonth, d
                int mE = DATA[i++]; // 1-based
                int LE = DATA[i++];
                int dE = DATA[i++];
                buf.Length = 0;
                buf.Append(date + " -> ");
                buf.Append(y + "/" + m + ((L == 1) ? "(leap)" : "") + "/" + d);
                if (y == yE && m == mE && L == LE && d == dE)
                {
                    Logln("OK: " + buf.ToString());
                }
                else
                {
                    Errln("Fail: " + buf.ToString() + ", expected " + yE + "/" + mE
                            + ((LE == 1) ? "(leap)" : "") + "/" + dE);
                }
            }

            Logln("Chinese -> Gregorian");
            for (int i_0 = 0; i_0 < DATA.Length; )
            {
                grego.Set(DATA[i_0++], DATA[i_0++] - 1, DATA[i_0++]);
                DateTime dexp = grego.GetTime();
                int cyear = DATA[i_0++];
                int cmonth = DATA[i_0++];
                int cisleapmonth = DATA[i_0++];
                int cdayofmonth = DATA[i_0++];
                cal.Clear();
                cal.Set(IBM.ICU.Util.Calendar.EXTENDED_YEAR, cyear);
                cal.Set(IBM.ICU.Util.Calendar.MONTH, cmonth - 1);
                cal.Set(IBM.ICU.Util.ChineseCalendar.IS_LEAP_MONTH, cisleapmonth);
                cal.Set(IBM.ICU.Util.Calendar.DAY_OF_MONTH, cdayofmonth);
                DateTime date_1 = cal.GetTime();
                buf.Length = 0;
                buf.Append(cyear + "/" + cmonth
                        + ((cisleapmonth == 1) ? "(leap)" : "") + "/" + cdayofmonth);
                buf.Append(" -> " + date_1);
                if (date_1.Equals(dexp))
                {
                    Logln("OK: " + buf.ToString());
                }
                else
                {
                    Errln("Fail: " + buf.ToString() + ", expected " + dexp);
                }
            }
        }

        /// <summary>
        /// Make sure no Gregorian dates map to Chinese 1-based day of month zero.
        /// This was a problem with some of the astronomical new moon determinations.
        /// </summary>
        [Test]
        public void TestZeroDOM()
        {
            ChineseCalendar cal = new ChineseCalendar();
            IBM.ICU.Util.GregorianCalendar greg = new IBM.ICU.Util.GregorianCalendar(1989,
                    IBM.ICU.Util.Calendar.SEPTEMBER, 1);
            Logln("Start: " + greg.GetTime());
            for (int i = 0; i < 1000; ++i)
            {
                cal.SetTimeInMillis(greg.GetTimeInMillis());
                if (cal.Get(IBM.ICU.Util.Calendar.DAY_OF_MONTH) == 0)
                {
                    Errln("Fail: "
                            + greg.GetTime()
                            + " -> "
                            + cal.Get(IBM.ICU.Util.Calendar.EXTENDED_YEAR)
                            + "/"
                            + cal.Get(IBM.ICU.Util.Calendar.MONTH)
                            + ((cal.Get(IBM.ICU.Util.ChineseCalendar.IS_LEAP_MONTH) == 1) ? "(leap)"
                                    : "") + "/" + cal.Get(IBM.ICU.Util.Calendar.DAY_OF_MONTH));
                }
                greg.Add(IBM.ICU.Util.Calendar.DAY_OF_YEAR, 1);
            }
            Logln("End: " + greg.GetTime());
        }

        /// <summary>
        /// Test minimum and maximum functions.
        /// </summary>
        [Test]
        public void TestLimits()
        {
            // The number of days and the start date can be adjusted
            // arbitrarily to either speed up the test or make it more
            // thorough, but try to test at least a full year, preferably a
            // full non-leap and a full leap year.

            // Final parameter is either number of days, if > 0, or test
            // duration in seconds, if < 0.
            IBM.ICU.Util.Calendar tempcal = IBM.ICU.Util.Calendar.GetInstance();
            tempcal.Clear();
            tempcal.Set(1989, IBM.ICU.Util.Calendar.NOVEMBER, 1);
            ChineseCalendar chinese = new ChineseCalendar();
            if (!SkipIfBeforeICU(3, 9, 0))
            {
                DoLimitsTest(chinese, null, tempcal.GetTime());
            }
            DoTheoreticalLimitsTest(chinese, true);
        }

        /// <summary>
        /// Run through several standard tests from Dershowitz & Reingold.
        /// </summary>
        [Test]
        public void TestJulianDayMapping()
        {

            /* TestCase[] tests = {
                     //
                     // From Dershowitz & Reingold, "Calendrical Calculations".
                     //
                     // The months in this table are 1-based rather than 0-based.
                     //
                     // * Failing fields->millis
                     // ** Millis->fields gives 0-based month -1
                     // These failures were fixed by changing the start search date
                     // for the winter solstice from Dec 15 to Dec 1.
                     //
                     // Julian Day Era Year Month Leap DOM WkDay
                     new ChineseTestCase(1507231.5d, 35, 11, 6, false, 12, IBM.ICU.Charset.CalendarTest.SUN),
                     new ChineseTestCase(1660037.5d, 42, 9, 10, false, 27, IBM.ICU.Charset.CalendarTest.WED),
                     new ChineseTestCase(1746893.5d, 46, 7, 8, false, 4, IBM.ICU.Charset.CalendarTest.WED),
                     new ChineseTestCase(1770641.5d, 47, 12, 8, false, 9, IBM.ICU.Charset.CalendarTest.SUN),
                     new ChineseTestCase(1892731.5d, 52, 46, 11, false, 20, IBM.ICU.Charset.CalendarTest.WED),
                     new ChineseTestCase(1931579.5d, 54, 33, 4, false, 5, IBM.ICU.Charset.CalendarTest.MON),
                     new ChineseTestCase(1974851.5d, 56, 31, 10, false, 15, IBM.ICU.Charset.CalendarTest.SAT),
                     new ChineseTestCase(2091164.5d, 61, 50, 3, false, 7, IBM.ICU.Charset.CalendarTest.SUN),
                     new ChineseTestCase(2121509.5d, 63, 13, 4, false, 24, IBM.ICU.Charset.CalendarTest.SUN),
                     new ChineseTestCase(2155779.5d, 64, 47, 2, false, 9, IBM.ICU.Charset.CalendarTest.FRI),
                     new ChineseTestCase(2174029.5d, 65, 37, 2, false, 9, IBM.ICU.Charset.CalendarTest.SAT),
                     new ChineseTestCase(2191584.5d, 66, 25, 2, false, 23, IBM.ICU.Charset.CalendarTest.FRI),
                     new ChineseTestCase(2195261.5d, 66, 35, 3, false, 9, IBM.ICU.Charset.CalendarTest.SUN), // *
                     new ChineseTestCase(2229274.5d, 68, 8, 5, false, 2, IBM.ICU.Charset.CalendarTest.SUN), // *
                     new ChineseTestCase(2245580.5d, 68, 53, 1, false, 8, IBM.ICU.Charset.CalendarTest.WED), // **
                     new ChineseTestCase(2266100.5d, 69, 49, 3, false, 4, IBM.ICU.Charset.CalendarTest.SAT),
                     new ChineseTestCase(2288542.5d, 70, 50, 8, false, 2, IBM.ICU.Charset.CalendarTest.SAT), // *
                     new ChineseTestCase(2290901.5d, 70, 57, 1, false, 29, IBM.ICU.Charset.CalendarTest.SAT), // *
                     new ChineseTestCase(2323140.5d, 72, 25, 4, true, 20, IBM.ICU.Charset.CalendarTest.WED), // *
                     new ChineseTestCase(2334848.5d, 72, 57, 6, false, 5, IBM.ICU.Charset.CalendarTest.SUN),
                     new ChineseTestCase(2348020.5d, 73, 33, 6, false, 6, IBM.ICU.Charset.CalendarTest.FRI),
                     new ChineseTestCase(2366978.5d, 74, 25, 5, false, 5, IBM.ICU.Charset.CalendarTest.SUN),
                     new ChineseTestCase(2385648.5d, 75, 16, 6, false, 12, IBM.ICU.Charset.CalendarTest.MON),
                     new ChineseTestCase(2392825.5d, 75, 36, 2, false, 13, IBM.ICU.Charset.CalendarTest.WED),
                     new ChineseTestCase(2416223.5d, 76, 40, 3, false, 22, IBM.ICU.Charset.CalendarTest.SUN),
                     new ChineseTestCase(2425848.5d, 77, 6, 7, false, 21, IBM.ICU.Charset.CalendarTest.SUN),
                     new ChineseTestCase(2430266.5d, 77, 18, 8, false, 9, IBM.ICU.Charset.CalendarTest.MON),
                     new ChineseTestCase(2430833.5d, 77, 20, 3, false, 15, IBM.ICU.Charset.CalendarTest.MON),
                     new ChineseTestCase(2431004.5d, 77, 20, 9, false, 9, IBM.ICU.Charset.CalendarTest.THU),
                     new ChineseTestCase(2448698.5d, 78, 9, 2, false, 14, IBM.ICU.Charset.CalendarTest.TUE),
                     new ChineseTestCase(2450138.5d, 78, 13, 1, false, 7, IBM.ICU.Charset.CalendarTest.SUN),
                     new ChineseTestCase(2465737.5d, 78, 55, 10, false, 14, IBM.ICU.Charset.CalendarTest.WED),
                     new ChineseTestCase(2486076.5d, 79, 51, 6, false, 7, IBM.ICU.Charset.CalendarTest.SUN),
	
                     // Additional tests not from D&R
                     new ChineseTestCase(2467496.5d, 78, 60, 8, false, 2, IBM.ICU.Charset.CalendarTest.FRI), // year
                                                                               // 60
             };
	
             ChineseCalendar cal = new ChineseCalendar();
             cal.SetLenient(true);
             DoTestCases(tests, cal);*/
        }

        /// <summary>
        /// Test formatting.
        /// </summary>
        [Test]
        public void TestFormat()
        {
            ChineseCalendar cal = new ChineseCalendar();
            DateFormat fmt = IBM.ICU.Text.DateFormat.GetDateTimeInstance(cal,
                    IBM.ICU.Text.DateFormat.DEFAULT, IBM.ICU.Text.DateFormat.DEFAULT);

            IBM.ICU.Util.Calendar tempcal = IBM.ICU.Util.Calendar.GetInstance();
            tempcal.Clear();

            DateTime[] DATA = new DateTime[2];
            tempcal.Set(2001, IBM.ICU.Util.Calendar.MAY, 22);
            DATA[0] = tempcal.GetTime();
            tempcal.Set(2001, IBM.ICU.Util.Calendar.MAY, 23);
            DATA[1] = tempcal.GetTime();
            // Wed May 23 2001 = Month 4(leap), Day 1, Year 18, Cycle 78

            for (int i = 0; i < DATA.Length; ++i)
            {
                String s = fmt.Format(DATA[i]);
                try
                {
                    DateTime e = fmt.Parse(s);
                    if (e.Equals(DATA[i]))
                    {
                        Logln("Ok: " + DATA[i] + " -> " + s + " -> " + e);
                    }
                    else
                    {
                        Errln("FAIL: " + DATA[i] + " -> " + s + " -> " + e);
                    }
                }
                catch (ILOG.J2CsMapping.Util.ParseException e_0)
                {
                    Errln("Fail: " + s + " -> parse failure at "
                            + e_0.GetErrorOffset());
                    Errln(e_0.ToString());
                }
            }
        }

        /// <summary>
        /// Make sure IS_LEAP_MONTH participates in field resolution.
        /// </summary>
        [Test]
        public void TestResolution()
        {
            ChineseCalendar cal = new ChineseCalendar();
            DateFormat fmt = IBM.ICU.Text.DateFormat.GetDateInstance(cal, IBM.ICU.Text.DateFormat.DEFAULT);

            // May 22 2001 = y4638 m4 d30 doy119
            // May 23 2001 = y4638 m4* d1 doy120

            int THE_YEAR = 4638;
            int END = -1;

            int[] DATA = {
	                // Format:
	                // (field, value)+, END, exp.month, exp.isLeapMonth, exp.DOM
	                // Note: exp.month is ONE-BASED
	
	                IBM.ICU.Util.Calendar.DAY_OF_YEAR, 1, END,
	                1,
	                0,
	                1, // Expect 1-1
	
	                IBM.ICU.Util.ChineseCalendar.IS_LEAP_MONTH, 1, IBM.ICU.Util.Calendar.DAY_OF_MONTH, 1,
	                IBM.ICU.Util.Calendar.MONTH,
	                3,
	                END,
	                4,
	                1,
	                1, // Expect 4*-1
	
	                IBM.ICU.Util.Calendar.MONTH,
	                1, // Should ignore
	                IBM.ICU.Util.ChineseCalendar.IS_LEAP_MONTH,
	                1, // Should ignore
	                IBM.ICU.Util.Calendar.DAY_OF_MONTH,
	                1, // Should ignore
	                IBM.ICU.Util.Calendar.DAY_OF_YEAR,
	                121,
	                END,
	                4,
	                1,
	                2, // Expect 4*-2
	
	                // I've disabled this test because it doesn't work this way,
	                // not even with a GregorianCalendar! MONTH alone isn't enough
	                // to supersede DAY_OF_YEAR. Some other month-related field is
	                // also required. - Liu 11/28/00
	                // ! // If we set MONTH last, that should take precedence
	                // ! ChineseCalendar.IS_LEAP_MONTH, 1,
	                // ! Calendar.DAY_OF_MONTH, 1,
	                // ! Calendar.DAY_OF_YEAR, 5, // Should ignore
	                // ! Calendar.MONTH, 3,
	                // ! END,
	                // ! 4,1,1, // Expect 4*-1
	
	                IBM.ICU.Util.Calendar.MONTH, 3, IBM.ICU.Util.Calendar.DAY_OF_MONTH, 1,
	                IBM.ICU.Util.Calendar.DAY_OF_YEAR, 5, // Should ignore
	                IBM.ICU.Util.ChineseCalendar.IS_LEAP_MONTH, 1, END, 4, 1, 1, // Expect 4*-1
	        };

            StringBuilder buf = new StringBuilder();
            for (int i = 0; i < DATA.Length; )
            {
                cal.Clear();
                cal.Set(IBM.ICU.Util.Calendar.EXTENDED_YEAR, THE_YEAR);
                buf.Length = 0;
                buf.Append("EXTENDED_YEAR=" + THE_YEAR);
                while (DATA[i] != END)
                {
                    cal.Set(DATA[i++], DATA[i++]);
                    buf.Append(" " + IBM.ICU.Charset.CalendarTest.FieldName(DATA[i - 2]) + "=" + DATA[i - 1]);
                }
                ++i; // Skip over END mark
                int expMonth = DATA[i++] - 1;
                int expIsLeapMonth = DATA[i++];
                int expDOM = DATA[i++];
                int month = cal.Get(IBM.ICU.Util.Calendar.MONTH);
                int isLeapMonth = cal.Get(IBM.ICU.Util.ChineseCalendar.IS_LEAP_MONTH);
                int dom = cal.Get(IBM.ICU.Util.Calendar.DAY_OF_MONTH);
                if (expMonth == month && expIsLeapMonth == isLeapMonth
                        && dom == expDOM)
                {
                    Logln("OK: " + buf + " => " + fmt.Format(cal.GetTime()));
                }
                else
                {
                    String s = fmt.Format(cal.GetTime());
                    cal.Clear();
                    cal.Set(IBM.ICU.Util.Calendar.EXTENDED_YEAR, THE_YEAR);
                    cal.Set(IBM.ICU.Util.Calendar.MONTH, expMonth);
                    cal.Set(IBM.ICU.Util.ChineseCalendar.IS_LEAP_MONTH, expIsLeapMonth);
                    cal.Set(IBM.ICU.Util.Calendar.DAY_OF_MONTH, expDOM);
                    Errln("Fail: " + buf + " => " + s + "=" + (month + 1) + ","
                            + isLeapMonth + "," + dom + ", expected "
                            + fmt.Format(cal.GetTime()) + "=" + (expMonth + 1)
                            + "," + expIsLeapMonth + "," + expDOM);
                }
            }
        }

        /// <summary>
        /// Test the behavior of fields that are out of range.
        /// </summary>
        [Test]
        public void TestOutOfRange()
        {
            int[] DATA = new int[] {
	                // Input Output
	                4638, 13, 1, 4639, 1, 1, 4638, 18, 1, 4639, 6, 1, 4639, 0, 1,
	                4638, 12, 1, 4639, -6, 1, 4638, 6, 1, 4638, 1, 32, 4638, 2, 2, // 1-4638
	                                                                               // has
	                                                                               // 30
	                                                                               // days
	                4638, 2, -1, 4638, 1, 29, };
            ChineseCalendar cal = new ChineseCalendar();
            for (int i = 0; i < DATA.Length; )
            {
                int y1 = DATA[i++];
                int m1 = DATA[i++] - 1;
                int d1 = DATA[i++];
                int y2 = DATA[i++];
                int m2 = DATA[i++] - 1;
                int d2 = DATA[i++];
                cal.Clear();
                cal.Set(IBM.ICU.Util.Calendar.EXTENDED_YEAR, y1);
                cal.Set(IBM.ICU.Charset.CalendarTest.MONTH, m1);
                cal.Set(IBM.ICU.Charset.CalendarTest.DATE, d1);
                int y = cal.Get(IBM.ICU.Util.Calendar.EXTENDED_YEAR);
                int m = cal.Get(IBM.ICU.Charset.CalendarTest.MONTH);
                int d = cal.Get(IBM.ICU.Charset.CalendarTest.DATE);
                if (y != y2 || m != m2 || d != d2)
                {
                    Errln("Fail: " + y1 + "/" + (m1 + 1) + "/" + d1
                            + " resolves to " + y + "/" + (m + 1) + "/" + d
                            + ", expected " + y2 + "/" + (m2 + 1) + "/" + d2);
                }
                else if (IsVerbose())
                {
                    Logln("OK: " + y1 + "/" + (m1 + 1) + "/" + d1 + " resolves to "
                            + y + "/" + (m + 1) + "/" + d);
                }
            }
        }

        /// <summary>
        /// Test the behavior of ChineseCalendar.add(). The only real nastiness with
        /// roll is the MONTH field around leap months.
        /// </summary>
        [Test]
        public void TestAdd()
        {
            int[][] tests = new int[][] {
	                new int[] { 4642, 3, 0, 15,
	                        IBM.ICU.Charset.CalendarTest.MONTH, 3,
	                        4642, 6, 0, 15 },
	                new int[] { 4639, 12, 0, 15,
	                        IBM.ICU.Charset.CalendarTest.MONTH, 1,
	                        4640, 1, 0, 15 },
	                new int[] { 4640, 1, 0, 15,
	                        IBM.ICU.Charset.CalendarTest.MONTH, -1,
	                        4639, 12, 0, 15 },
	                new int[] { 4638, 3, 0, 15,
	                        IBM.ICU.Charset.CalendarTest.MONTH, 3,
	                        4638, 5, 0, 15 },
	                new int[] { 4638, 3, 0, 15,
	                        IBM.ICU.Charset.CalendarTest.MONTH, 2,
	                        4638, 4, 1, 15 },
	                new int[] { 4638, 4, 0, 15,
	                        IBM.ICU.Charset.CalendarTest.MONTH, 1,
	                        4638, 4, 1, 15 },
	                new int[] { 4638, 4, 1, 15,
	                        IBM.ICU.Charset.CalendarTest.MONTH, 1,
	                        4638, 5, 0, 15 },
	                new int[] { 4638, 4, 0, 30,
	                        IBM.ICU.Charset.CalendarTest.MONTH, 1,
	                        4638, 4, 1, 29 },
	                new int[] { 4638, 4, 0, 30,
	                        IBM.ICU.Charset.CalendarTest.MONTH, 2,
	                        4638, 5, 0, 30 },
	                new int[] { 4638, 4, 0, 30,
	                        IBM.ICU.Charset.CalendarTest.MONTH, 3,
	                        4638, 6, 0, 29 } };

            ChineseCalendar cal = new ChineseCalendar();
            DoRollAdd(IBM.ICU.Charset.CalendarTest.ADD, cal, tests);
        }

        /// <summary>
        /// Test the behavior of ChineseCalendar.roll(). The only real nastiness with
        /// roll is the MONTH field around leap months.
        /// </summary>
        [Test]
        public void TestRoll()
        {
            int[][] tests = new int[][] {
	                new int[] { 4642, 3, 0, 15,
	                        IBM.ICU.Charset.CalendarTest.MONTH, 3,
	                        4642, 6, 0, 15 },
	                new int[] { 4642, 3, 0, 15,
	                        IBM.ICU.Charset.CalendarTest.MONTH, 11,
	                        4642, 2, 0, 15 },
	                new int[] { 4639, 12, 0, 15,
	                        IBM.ICU.Charset.CalendarTest.MONTH, 1,
	                        4639, 1, 0, 15 },
	                new int[] { 4640, 1, 0, 15,
	                        IBM.ICU.Charset.CalendarTest.MONTH, -1,
	                        4640, 12, 0, 15 },
	                new int[] { 4638, 3, 0, 15,
	                        IBM.ICU.Charset.CalendarTest.MONTH, 3,
	                        4638, 5, 0, 15 },
	                new int[] { 4638, 3, 0, 15,
	                        IBM.ICU.Charset.CalendarTest.MONTH, 16,
	                        4638, 5, 0, 15 },
	                new int[] { 4638, 3, 0, 15,
	                        IBM.ICU.Charset.CalendarTest.MONTH, 2,
	                        4638, 4, 1, 15 },
	                new int[] { 4638, 3, 0, 15,
	                        IBM.ICU.Charset.CalendarTest.MONTH, 28,
	                        4638, 4, 1, 15 },
	                new int[] { 4638, 4, 0, 15,
	                        IBM.ICU.Charset.CalendarTest.MONTH, 1,
	                        4638, 4, 1, 15 },
	                new int[] { 4638, 4, 0, 15,
	                        IBM.ICU.Charset.CalendarTest.MONTH, -12,
	                        4638, 4, 1, 15 },
	                new int[] { 4638, 4, 1, 15,
	                        IBM.ICU.Charset.CalendarTest.MONTH, 1,
	                        4638, 5, 0, 15 },
	                new int[] { 4638, 4, 1, 15,
	                        IBM.ICU.Charset.CalendarTest.MONTH, -25,
	                        4638, 5, 0, 15 },
	                new int[] { 4638, 4, 0, 30,
	                        IBM.ICU.Charset.CalendarTest.MONTH, 1,
	                        4638, 4, 1, 29 },
	                new int[] { 4638, 4, 0, 30,
	                        IBM.ICU.Charset.CalendarTest.MONTH, 14,
	                        4638, 4, 1, 29 },
	                new int[] { 4638, 4, 0, 30,
	                        IBM.ICU.Charset.CalendarTest.MONTH, 15,
	                        4638, 5, 0, 30 },
	                new int[] { 4638, 4, 0, 30,
	                        IBM.ICU.Charset.CalendarTest.MONTH, -10,
	                        4638, 6, 0, 29 } };

            ChineseCalendar cal = new ChineseCalendar();
            DoRollAdd(IBM.ICU.Charset.CalendarTest.ROLL, cal, tests);
        }

        internal void DoRollAdd(bool roll, ChineseCalendar cal, int[][] tests)
        {
            String name = (roll) ? "rolling" : "adding";

            for (int i = 0; i < tests.Length; i++)
            {
                int[] test = tests[i];

                cal.Clear();
                cal.Set(IBM.ICU.Util.Calendar.EXTENDED_YEAR, test[0]);
                cal.Set(IBM.ICU.Util.Calendar.MONTH, test[1] - 1);
                cal.Set(IBM.ICU.Util.ChineseCalendar.IS_LEAP_MONTH, test[2]);
                cal.Set(IBM.ICU.Util.Calendar.DAY_OF_MONTH, test[3]);
                if (roll)
                {
                    cal.Roll(test[4], test[5]);
                }
                else
                {
                    cal.Add(test[4], test[5]);
                }
                if (cal.Get(IBM.ICU.Util.Calendar.EXTENDED_YEAR) != test[6]
                        || cal.Get(IBM.ICU.Charset.CalendarTest.MONTH) != (test[7] - 1)
                        || cal.Get(IBM.ICU.Util.ChineseCalendar.IS_LEAP_MONTH) != test[8]
                        || cal.Get(IBM.ICU.Charset.CalendarTest.DATE) != test[9])
                {
                    Errln("Fail: " + name + " "
                            + YmdToString(test[0], test[1] - 1, test[2], test[3])
                            + " " + IBM.ICU.Charset.CalendarTest.FieldName(test[4]) + " by " + test[5]
                            + ": expected "
                            + YmdToString(test[6], test[7] - 1, test[8], test[9])
                            + ", got " + IBM.ICU.Charset.CalendarTest.YmdToString(cal));
                }
                else if (IsVerbose())
                {
                    Logln("OK: " + name + " "
                            + YmdToString(test[0], test[1] - 1, test[2], test[3])
                            + " " + IBM.ICU.Charset.CalendarTest.FieldName(test[4]) + " by " + test[5]
                            + ": got " + IBM.ICU.Charset.CalendarTest.YmdToString(cal));
                }
            }
        }

        /// <summary>
        /// Convert year,month,day values to the form "year/month/day". On input the
        /// month value is zero-based, but in the result string it is one-based.
        /// </summary>
        static public String YmdToString(int year, int month, int isLeapMonth,
                int day)
        {
            return "" + year + "/" + (month + 1)
                    + ((isLeapMonth != 0) ? "(leap)" : "") + "/" + day;
        }

        // public void TestFindLeapMonths() {
        // ChineseCalendar cal = new ChineseCalendar();
        // cal.setTime(new Date(2000-1900, Calendar.JANUARY, 1));
        // long end = new Date(2100-1900, Calendar.JANUARY, 1).getTime();
        // ChineseDateFormat fmt = (ChineseDateFormat) DateFormat.getInstance(cal);
        // fmt.applyPattern("u-MMl-dd, 'Year' y, 'Cycle' G");
        // while (cal.getTimeInMillis() < end) {
        // if (cal.get(ChineseCalendar.IS_LEAP_MONTH) != 0) {
        // cal.set(Calendar.DAY_OF_MONTH, 1);
        // logln(cal.getTime() + " = " + fmt.format(cal.getTime()));
        // cal.set(Calendar.DAY_OF_MONTH, 29);
        // }
        // cal.add(Calendar.DAY_OF_YEAR, 25);
        // }
        // }

        [Test]
        public void TestCoverage()
        {
            ChineseCalendar cal = new ChineseCalendar();
            DateFormat format = IBM.ICU.Text.DateFormat.GetInstance(cal);
            if (!(format is ChineseDateFormat))
            {
                Errln("DateFormat.getInstance(" + cal
                        + ") did not return a ChineseDateFormat");
            }
            ChineseDateFormat fmt = (ChineseDateFormat)format;
            fmt.ApplyPattern("llyyll");
            DateTime time = IBM.ICU.Charset.TestFmwk.GetDate(2100, IBM.ICU.Util.Calendar.JANUARY, 1);
            String str = fmt.Format(time);
            try
            {
                DateTime e = fmt.Parse(str);
                Logln("chinese calendar time: " + time + " result: " + str
                        + " --> " + e);
            }
            catch (ILOG.J2CsMapping.Util.ParseException ex)
            {
                Logln(ex.Message); // chinese calendar can't parse this, no
                // error for now
            }

            // new ChineseCalendar(TimeZone,ULocale)
            ChineseCalendar ccal2 = new ChineseCalendar(IBM.ICU.Util.TimeZone.GetDefault(),
                    IBM.ICU.Util.ULocale.CHINA);
            if (ccal2 == null)
            {
                Errln("could not create ChineseCalendar with TimeZone ULocale");
            }
            else
            {
                fmt = (ChineseDateFormat)IBM.ICU.Text.DateFormat.GetDateInstance(ccal2,
                        IBM.ICU.Text.DateFormat.DEFAULT, IBM.ICU.Util.ULocale.CHINA);
                time = IBM.ICU.Charset.TestFmwk.GetDate(2001, IBM.ICU.Util.Calendar.MAY, 23);
                str = fmt.Format(time);
                Logln("Chinese calendar time: " + time + " result: " + str);
            }
        }

        [Test]
        public void TestScratch()
        {
            String[] strMonths = { "Januari", "Pebruari", "Maret", "April", "Mei",
	                "Juni", "Juli", "Agustus", "September", "Oktober", "Nopember",
	                "Desember" };
            String[] strShortMonths = { "Jan", "Peb", "Mar", "Apr", "Mei", "Jun",
	                "Jul", "Agt", "Sep", "Okt", "Nop", "Des" };
            String[] strWeeks = { "", "Minggu", "Senin", "Selasa", "Rabu", "Kamis",
	                "Jumat", "Sabtu" };
            DateFormatSymbols dfsDate = new DateFormatSymbols(
                    new ILOG.J2CsMapping.Util.Locale("id", "ID"));
            dfsDate.SetMonths(strMonths);
            dfsDate.SetShortMonths(strShortMonths);
            dfsDate.SetWeekdays(strWeeks);
            ULocale uloInd = dfsDate.GetLocale(IBM.ICU.Util.ULocale.ACTUAL_LOCALE);
            if (uloInd == null)
            {
                Errln("did not get the expected ULocale");
            }
            Logln(uloInd.ToString());
            ILOG.J2CsMapping.Util.Locale locInd = uloInd.ToLocale();
            if (locInd == null)
            {
                Errln("did not get the expected result");
            }
            Logln(locInd.ToString());
        }

        [Test]
        public void TestInitWithCurrentTime()
        {
            // jb4555
            // if the chinese calendar current millis isn't called, the default year
            // is wrong.
            // this test is assuming the 'year' is the current cycle
            // so when we cross a cycle boundary, the target will need to change
            // that shouldn't be for awhile yet...

            ChineseCalendar cc = new ChineseCalendar();
            cc.Set(IBM.ICU.Util.Calendar.YEAR, 22);
            cc.Set(IBM.ICU.Util.Calendar.MONTH, 0);
            // need to set leap month flag off, otherwise, the test case always
            // fails when
            // current time is in a leap month
            cc.Set(IBM.ICU.Util.ChineseCalendar.IS_LEAP_MONTH, 0);
            cc.Set(IBM.ICU.Util.Calendar.DATE, 19);
            cc.Set(IBM.ICU.Util.Calendar.HOUR_OF_DAY, 0);
            cc.Set(IBM.ICU.Util.Calendar.MINUTE, 0);
            cc.Set(IBM.ICU.Util.Calendar.SECOND, 0);
            cc.Set(IBM.ICU.Util.Calendar.MILLISECOND, 0);

            cc.Add(IBM.ICU.Util.Calendar.DATE, 1);

            DateTime target = new DateTime(105, IBM.ICU.Util.Calendar.FEBRUARY, 28);
            DateTime result = cc.GetTime();

            AssertEquals("chinese and gregorian date should match", target, result);
        }
    }
}
