/*
 *******************************************************************************
 * Copyright (C) 2000-2007, International Business Machines Corporation and
 * others. All Rights Reserved.
 *******************************************************************************
 */
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/13/10 4:02 PM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
namespace IBM.ICU.Charset
{

    using IBM.ICU.Impl;
    using IBM.ICU.Text;
    using IBM.ICU.Util;
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.Globalization;
    using System.IO;
    using System.Runtime.CompilerServices;
    using System.Text;
    using NUnit.Framework;

    /// @summary Tests of new functionality in IBMCalendar
    [TestFixture]
    public class IBMCalendarTest : CalendarTest
    {

        public static void Main(String[] args)
        {
            new IBMCalendarTest().Run(args);
        }

        /// <summary>
        /// Test weekend support in IBMCalendar.
        /// NOTE: This test will have to be updated when the isWeekend() etc. API is
        /// finalized later.
        /// In particular, the test will have to be rewritten to instantiate a
        /// Calendar in the given locale (using getInstance()) and call that
        /// Calendar's isWeekend() etc. methods.
        /// </summary>
        [Test]
        public void TestWeekend()
        {
            SimpleDateFormat fmt = new SimpleDateFormat(
                    "EEE MMM dd yyyy G HH:mm:ss.SSS");

            // NOTE
            // This test tests for specific locale data. This is probably okay
            // as far as US data is concerned, but if the Arabic/Bahrain data
            // changes, this test will have to be updated.

            // Test specific days
            Object[] DATA1 = { new ILOG.J2CsMapping.Util.Locale("en-us"), new int[] { // Saturday:Sunday
	                2000, IBM.ICU.Util.Calendar.MARCH, 17, 23, 0, 0, // Fri 23:00
	                        2000, IBM.ICU.Util.Calendar.MARCH, 18, 0, -1, 0, // Fri 23:59:59.999
	                        2000, IBM.ICU.Util.Calendar.MARCH, 18, 0, 0, 1, // Sat 00:00
	                        2000, IBM.ICU.Util.Calendar.MARCH, 18, 15, 0, 1, // Sat 15:00
	                        2000, IBM.ICU.Util.Calendar.MARCH, 19, 23, 0, 1, // Sun 23:00
	                        2000, IBM.ICU.Util.Calendar.MARCH, 20, 0, -1, 1, // Sun 23:59:59.999
	                        2000, IBM.ICU.Util.Calendar.MARCH, 20, 0, 0, 0, // Mon 00:00
	                        2000, IBM.ICU.Util.Calendar.MARCH, 20, 8, 0, 0, // Mon 08:00
	                }, new ILOG.J2CsMapping.Util.Locale("ar","BH"), new int[] { // Thursday:Friday
	                2000, IBM.ICU.Util.Calendar.MARCH, 15, 23, 0, 0, // Wed 23:00
	                        2000, IBM.ICU.Util.Calendar.MARCH, 16, 0, -1, 0, // Wed 23:59:59.999
	                        2000, IBM.ICU.Util.Calendar.MARCH, 16, 0, 0, 1, // Thu 00:00
	                        2000, IBM.ICU.Util.Calendar.MARCH, 16, 15, 0, 1, // Thu 15:00
	                        2000, IBM.ICU.Util.Calendar.MARCH, 17, 23, 0, 1, // Fri 23:00
	                        2000, IBM.ICU.Util.Calendar.MARCH, 18, 0, -1, 1, // Fri 23:59:59.999
	                        2000, IBM.ICU.Util.Calendar.MARCH, 18, 0, 0, 0, // Sat 00:00
	                        2000, IBM.ICU.Util.Calendar.MARCH, 18, 8, 0, 0, // Sat 08:00
	                }, };

            // Test days of the week
            Object[] DATA2 = {
	                new ILOG.J2CsMapping.Util.Locale("en-us"),
	                new int[] { IBM.ICU.Util.Calendar.MONDAY, IBM.ICU.Util.Calendar.WEEKDAY, IBM.ICU.Util.Calendar.FRIDAY,
	                        IBM.ICU.Util.Calendar.WEEKDAY, IBM.ICU.Util.Calendar.SATURDAY, IBM.ICU.Util.Calendar.WEEKEND,
	                        IBM.ICU.Util.Calendar.SUNDAY, IBM.ICU.Util.Calendar.WEEKEND_CEASE, },
	                new ILOG.J2CsMapping.Util.Locale("ar","BH"), new int[] { // Thursday:Friday
	                IBM.ICU.Util.Calendar.WEDNESDAY, IBM.ICU.Util.Calendar.WEEKDAY, IBM.ICU.Util.Calendar.SATURDAY,
	                        IBM.ICU.Util.Calendar.WEEKDAY, IBM.ICU.Util.Calendar.THURSDAY, IBM.ICU.Util.Calendar.WEEKEND,
	                        IBM.ICU.Util.Calendar.FRIDAY, IBM.ICU.Util.Calendar.WEEKEND_CEASE, }, };

            // We only test the getDayOfWeekType() and isWeekend() APIs.
            // The getWeekendTransition() API is tested indirectly via the
            // isWeekend() API, which calls it.

            for (int i1 = 0; i1 < DATA1.Length; i1 += 2)
            {
                ILOG.J2CsMapping.Util.Locale loc = (ILOG.J2CsMapping.Util.Locale)DATA1[i1];
                int[] data = (int[])DATA1[i1 + 1];
                IBM.ICU.Util.Calendar cal = IBM.ICU.Util.Calendar.GetInstance(loc);
                Logln("Locale: " + loc);
                for (int i = 0; i < data.Length; i += 6)
                {
                    cal.Clear();
                    cal.Set(data[i], data[i + 1], data[i + 2], data[i + 3], 0, 0);
                    if (data[i + 4] != 0)
                    {
                        cal.SetTime(new DateTime(((cal.GetTime().Ticks / 10000) + data[i + 4]) * 10000));
                    }
                    bool isWeekend = cal.IsWeekend();
                    bool ok = isWeekend == (data[i + 5] != 0);
                    if (ok)
                    {
                        Logln("Ok:   " + fmt.Format(cal.GetTime()) + " isWeekend="
                                + isWeekend);
                    }
                    else
                    {
                        Errln("FAIL: " + fmt.Format(cal.GetTime()) + " isWeekend="
                                + isWeekend + ", expected=" + (!isWeekend));
                    }
                }
            }

            for (int i2 = 0; i2 < DATA2.Length; i2 += 2)
            {
                ILOG.J2CsMapping.Util.Locale loc_0 = (ILOG.J2CsMapping.Util.Locale)DATA2[i2];
                int[] data_1 = (int[])DATA2[i2 + 1];
                Logln("Locale: " + loc_0);
                IBM.ICU.Util.Calendar cal_2 = IBM.ICU.Util.Calendar.GetInstance(loc_0);
                for (int i_3 = 0; i_3 < data_1.Length; i_3 += 2)
                {
                    int type = cal_2.GetDayOfWeekType(data_1[i_3]);
                    int exp = data_1[i_3 + 1];
                    if (type == exp)
                    {
                        Logln("Ok:   DOW " + data_1[i_3] + " type=" + type);
                    }
                    else
                    {
                        Errln("FAIL: DOW " + data_1[i_3] + " type=" + type
                                + ", expected=" + exp);
                    }
                }
            }
        }

        /// <summary>
        /// Run a test of a quasi-Gregorian calendar. This is a calendar that behaves
        /// like a Gregorian but has different year/era mappings. The int[] data
        /// array should have the format:
        /// { era, year, gregorianYear, month, dayOfMonth, ... }
        /// </summary>
        internal void QuasiGregorianTest(IBM.ICU.Util.Calendar cal, int[] data)
        {
            // As of JDK 1.4.1_01, using the Sun JDK GregorianCalendar as
            // a reference throws us off by one hour. This is most likely
            // due to the JDK 1.4 incorporation of historical time zones.
            // java.util.Calendar grego = java.util.Calendar.getInstance();
            IBM.ICU.Util.Calendar grego = IBM.ICU.Util.Calendar.GetInstance();
            for (int i = 0; i < data.Length; )
            {
                int era = data[i++];
                int year = data[i++];
                int gregorianYear = data[i++];
                int month = data[i++];
                int dayOfMonth = data[i++];

                grego.Clear();
                grego.Set(gregorianYear, month, dayOfMonth);
                DateTime D = grego.GetTime();

                cal.Clear();
                cal.Set(IBM.ICU.Util.Calendar.ERA, era);
                cal.Set(year, month, dayOfMonth);
                DateTime d = cal.GetTime();
                if (d.Equals(D))
                {
                    Logln("OK: " + era + ":" + year + "/" + (month + 1) + "/"
                            + dayOfMonth + " => " + d);
                }
                else
                {
                    Errln("Fail: " + era + ":" + year + "/" + (month + 1) + "/"
                            + dayOfMonth + " => " + d + ", expected " + D);
                }

                cal.Clear();
                cal.SetTime(D);
                int e = cal.Get(IBM.ICU.Util.Calendar.ERA);
                int y = cal.Get(IBM.ICU.Util.Calendar.YEAR);
                if (y == year && e == era)
                {
                    Logln("OK: " + D + " => " + cal.Get(IBM.ICU.Util.Calendar.ERA) + ":"
                            + cal.Get(IBM.ICU.Util.Calendar.YEAR) + "/"
                            + (cal.Get(IBM.ICU.Util.Calendar.MONTH) + 1) + "/"
                            + cal.Get(IBM.ICU.Util.Calendar.DATE));
                }
                else
                {
                    Logln("Fail: " + D + " => " + cal.Get(IBM.ICU.Util.Calendar.ERA) + ":"
                            + cal.Get(IBM.ICU.Util.Calendar.YEAR) + "/"
                            + (cal.Get(IBM.ICU.Util.Calendar.MONTH) + 1) + "/"
                            + cal.Get(IBM.ICU.Util.Calendar.DATE) + ", expected " + era + ":"
                            + year + "/" + (month + 1) + "/" + dayOfMonth);
                }
            }
        }

        /// <summary>
        /// Verify that BuddhistCalendar shifts years to Buddhist Era but otherwise
        /// behaves like GregorianCalendar.
        /// </summary>
        [Test]
        public void TestBuddhist()
        {
            QuasiGregorianTest(new BuddhistCalendar(), new int[] {
	                // BE 2542 == 1999 CE
	                0, 2542, 1999, IBM.ICU.Util.Calendar.JUNE, 4 });
        }
        [Test]
        public void TestBuddhistCoverage()
        {
            {
                // new BuddhistCalendar(ULocale)
                BuddhistCalendar cal = new BuddhistCalendar(IBM.ICU.Util.ULocale.GetDefault());
                if (cal == null)
                {
                    Errln("could not create BuddhistCalendar with ULocale");
                }
            }

            {
                // new BuddhistCalendar(TimeZone,ULocale)
                BuddhistCalendar cal_0 = new BuddhistCalendar(IBM.ICU.Util.TimeZone.GetDefault(),
                        IBM.ICU.Util.ULocale.GetDefault());
                if (cal_0 == null)
                {
                    Errln("could not create BuddhistCalendar with TimeZone ULocale");
                }
            }

            {
                // new BuddhistCalendar(TimeZone)
                BuddhistCalendar cal_1 = new BuddhistCalendar(IBM.ICU.Util.TimeZone.GetDefault());
                if (cal_1 == null)
                {
                    Errln("could not create BuddhistCalendar with TimeZone");
                }
            }

            {
                // new BuddhistCalendar(Locale)
                BuddhistCalendar cal_2 = new BuddhistCalendar(ILOG.J2CsMapping.Util.Locale.GetDefault());
                if (cal_2 == null)
                {
                    Errln("could not create BuddhistCalendar with Locale");
                }
            }

            {
                // new BuddhistCalendar(TimeZone, Locale)
                BuddhistCalendar cal_3 = new BuddhistCalendar(IBM.ICU.Util.TimeZone.GetDefault(),
                        ILOG.J2CsMapping.Util.Locale.GetDefault());
                if (cal_3 == null)
                {
                    Errln("could not create BuddhistCalendar with TimeZone and Locale");
                }
            }

            {
                // new BuddhistCalendar(Date)
                BuddhistCalendar cal_4 = new BuddhistCalendar(DateTime.Now);
                if (cal_4 == null)
                {
                    Errln("could not create BuddhistCalendar with Date");
                }
            }

            {
                // new BuddhistCalendar(int year, int month, int date)
                BuddhistCalendar cal_5 = new BuddhistCalendar(2543, IBM.ICU.Util.Calendar.MAY, 22);
                if (cal_5 == null)
                {
                    Errln("could not create BuddhistCalendar with year,month,data");
                }
            }

            {
                // new BuddhistCalendar(int year, int month, int date, int hour, int
                // minute, int second)
                BuddhistCalendar cal_6 = new BuddhistCalendar(2543, IBM.ICU.Util.Calendar.MAY, 22,
                        1, 1, 1);
                if (cal_6 == null)
                {
                    Errln("could not create BuddhistCalendar with year,month,date,hour,minute,second");
                }
            }

            {
                // data
                BuddhistCalendar cal_7 = new BuddhistCalendar(2543, IBM.ICU.Util.Calendar.MAY, 22);
                DateTime time = cal_7.GetTime();

                String[] calendarLocales = { "th_TH" };

                String[] formatLocales = { "en", "ar", "hu", "th" };

                for (int i = 0; i < calendarLocales.Length; ++i)
                {
                    String calLocName = calendarLocales[i];
                    ILOG.J2CsMapping.Util.Locale calLocale = IBM.ICU.Impl.LocaleUtility.GetLocaleFromName(calLocName);
                    cal_7 = new BuddhistCalendar(calLocale);

                    for (int j = 0; j < formatLocales.Length; ++j)
                    {
                        String locName = formatLocales[j];
                        ILOG.J2CsMapping.Util.Locale formatLocale = IBM.ICU.Impl.LocaleUtility
                                .GetLocaleFromName(locName);
                        DateFormat format = IBM.ICU.Text.DateFormat.GetDateTimeInstance(cal_7,
                                IBM.ICU.Text.DateFormat.FULL, IBM.ICU.Text.DateFormat.FULL, formatLocale);
                        Logln(calLocName + "/" + locName + " --> "
                                + format.Format(time));
                    }
                }
            }
        }

        /// <summary>
        /// Test limits of the Buddhist calendar.
        /// </summary>
        [Test]
        public void TestBuddhistLimits()
        {
            // Final parameter is either number of days, if > 0, or test
            // duration in seconds, if < 0.
            IBM.ICU.Util.Calendar cal = IBM.ICU.Util.Calendar.GetInstance();
            cal.Set(2007, IBM.ICU.Util.Calendar.JANUARY, 1);
            BuddhistCalendar buddhist = new BuddhistCalendar();
            if (!SkipIfBeforeICU(3, 9, 0))
            {
                DoLimitsTest(buddhist, null, cal.GetTime());
            }
            DoTheoreticalLimitsTest(buddhist, false);
        }

        /// <summary>
        /// Verify that TaiwanCalendar shifts years to Minguo Era but otherwise
        /// behaves like GregorianCalendar.
        /// </summary>
        [Test]
        public void TestTaiwan()
        {
            QuasiGregorianTest(new IBM.ICU.Util.TaiwanCalendar(), new int[] {
	                IBM.ICU.Util.TaiwanCalendar.BEFORE_MINGUO, 8, 1904, IBM.ICU.Util.Calendar.FEBRUARY, 29,
	                IBM.ICU.Util.TaiwanCalendar.MINGUO, 1, 1912, IBM.ICU.Util.Calendar.JUNE, 4,
	                IBM.ICU.Util.TaiwanCalendar.MINGUO, 3, 1914, IBM.ICU.Util.Calendar.FEBRUARY, 12,
	                IBM.ICU.Util.TaiwanCalendar.MINGUO, 96, 2007, IBM.ICU.Util.Calendar.FEBRUARY, 12, });
        }

        /// <summary>
        /// Test limits of the Taiwan calendar.
        /// </summary>
        [Test]
        public void TestTaiwanLimits()
        {
            // Final parameter is either number of days, if > 0, or test
            // duration in seconds, if < 0.
            IBM.ICU.Util.Calendar cal = IBM.ICU.Util.Calendar.GetInstance();
            cal.Set(2007, IBM.ICU.Util.Calendar.JANUARY, 1);
            IBM.ICU.Util.TaiwanCalendar taiwan = new IBM.ICU.Util.TaiwanCalendar();
            if (!SkipIfBeforeICU(3, 9, 0))
            {
                DoLimitsTest(taiwan, null, cal.GetTime());
            }
            DoTheoreticalLimitsTest(taiwan, false);
        }
        [Test]
        public void TestTaiwanCoverage()
        {
            {
                // new TaiwanCalendar(ULocale)
                IBM.ICU.Util.TaiwanCalendar cal = new IBM.ICU.Util.TaiwanCalendar(IBM.ICU.Util.ULocale.GetDefault());
                if (cal == null)
                {
                    Errln("could not create TaiwanCalendar with ULocale");
                }
            }

            {
                // new TaiwanCalendar(TimeZone,ULocale)
                IBM.ICU.Util.TaiwanCalendar cal_0 = new IBM.ICU.Util.TaiwanCalendar(IBM.ICU.Util.TimeZone.GetDefault(),
                        IBM.ICU.Util.ULocale.GetDefault());
                if (cal_0 == null)
                {
                    Errln("could not create TaiwanCalendar with TimeZone ULocale");
                }
            }

            {
                // new TaiwanCalendar(TimeZone)
                IBM.ICU.Util.TaiwanCalendar cal_1 = new IBM.ICU.Util.TaiwanCalendar(IBM.ICU.Util.TimeZone.GetDefault());
                if (cal_1 == null)
                {
                    Errln("could not create TaiwanCalendar with TimeZone");
                }
            }

            {
                // new TaiwanCalendar(Locale)
                IBM.ICU.Util.TaiwanCalendar cal_2 = new IBM.ICU.Util.TaiwanCalendar(ILOG.J2CsMapping.Util.Locale.GetDefault());
                if (cal_2 == null)
                {
                    Errln("could not create TaiwanCalendar with Locale");
                }
            }

            {
                // new TaiwanCalendar(TimeZone, Locale)
                IBM.ICU.Util.TaiwanCalendar cal_3 = new IBM.ICU.Util.TaiwanCalendar(IBM.ICU.Util.TimeZone.GetDefault(),
                        ILOG.J2CsMapping.Util.Locale.GetDefault());
                if (cal_3 == null)
                {
                    Errln("could not create TaiwanCalendar with TimeZone and Locale");
                }
            }

            {
                // new TaiwanCalendar(Date)
                IBM.ICU.Util.TaiwanCalendar cal_4 = new IBM.ICU.Util.TaiwanCalendar(DateTime.Now);
                if (cal_4 == null)
                {
                    Errln("could not create TaiwanCalendar with Date");
                }
            }

            {
                // new TaiwanCalendar(int year, int month, int date)
                IBM.ICU.Util.TaiwanCalendar cal_5 = new IBM.ICU.Util.TaiwanCalendar(34, IBM.ICU.Util.Calendar.MAY, 22);
                if (cal_5 == null)
                {
                    Errln("could not create TaiwanCalendar with year,month,data");
                }
            }

            {
                // new TaiwanCalendar(int year, int month, int date, int hour, int
                // minute, int second)
                IBM.ICU.Util.TaiwanCalendar cal_6 = new IBM.ICU.Util.TaiwanCalendar(34, IBM.ICU.Util.Calendar.MAY, 22, 1, 1,
                        1);
                if (cal_6 == null)
                {
                    Errln("could not create TaiwanCalendar with year,month,date,hour,minute,second");
                }
            }

            {
                // data
                IBM.ICU.Util.TaiwanCalendar cal_7 = new IBM.ICU.Util.TaiwanCalendar(34, IBM.ICU.Util.Calendar.MAY, 22);
                DateTime time = cal_7.GetTime();

                String[] calendarLocales = { "en", "zh" };

                String[] formatLocales = { "en", "ar", "hu", "th" };

                for (int i = 0; i < calendarLocales.Length; ++i)
                {
                    String calLocName = calendarLocales[i];
                    ILOG.J2CsMapping.Util.Locale calLocale = IBM.ICU.Impl.LocaleUtility.GetLocaleFromName(calLocName);
                    cal_7 = new IBM.ICU.Util.TaiwanCalendar(calLocale);

                    for (int j = 0; j < formatLocales.Length; ++j)
                    {
                        String locName = formatLocales[j];
                        ILOG.J2CsMapping.Util.Locale formatLocale = IBM.ICU.Impl.LocaleUtility
                                .GetLocaleFromName(locName);
                        DateFormat format = IBM.ICU.Text.DateFormat.GetDateTimeInstance(cal_7,
                                IBM.ICU.Text.DateFormat.FULL, IBM.ICU.Text.DateFormat.FULL, formatLocale);
                        Logln(calLocName + "/" + locName + " --> "
                                + format.Format(time));
                    }
                }
            }
        }

        /// <summary>
        /// Verify that JapaneseCalendar shifts years to Japanese Eras but otherwise
        /// behaves like GregorianCalendar.
        /// </summary>
        [Test]
        public void TestJapanese()
        {
            // First make sure this test works for GregorianCalendar
            int[] control = { IBM.ICU.Util.GregorianCalendar.AD, 1868, 1868, IBM.ICU.Util.Calendar.SEPTEMBER,
	                8, IBM.ICU.Util.GregorianCalendar.AD, 1868, 1868, IBM.ICU.Util.Calendar.SEPTEMBER, 9,
	                IBM.ICU.Util.GregorianCalendar.AD, 1869, 1869, IBM.ICU.Util.Calendar.JUNE, 4,
	                IBM.ICU.Util.GregorianCalendar.AD, 1912, 1912, IBM.ICU.Util.Calendar.JULY, 29,
	                IBM.ICU.Util.GregorianCalendar.AD, 1912, 1912, IBM.ICU.Util.Calendar.JULY, 30,
	                IBM.ICU.Util.GregorianCalendar.AD, 1912, 1912, IBM.ICU.Util.Calendar.AUGUST, 1, };
            QuasiGregorianTest(new IBM.ICU.Util.GregorianCalendar(), control);

            int[] data = { IBM.ICU.Util.JapaneseCalendar.MEIJI, 1, 1868, IBM.ICU.Util.Calendar.SEPTEMBER, 8,
	                IBM.ICU.Util.JapaneseCalendar.MEIJI, 1, 1868, IBM.ICU.Util.Calendar.SEPTEMBER, 9,
	                IBM.ICU.Util.JapaneseCalendar.MEIJI, 2, 1869, IBM.ICU.Util.Calendar.JUNE, 4,
	                IBM.ICU.Util.JapaneseCalendar.MEIJI, 45, 1912, IBM.ICU.Util.Calendar.JULY, 29,
	                IBM.ICU.Util.JapaneseCalendar.TAISHO, 1, 1912, IBM.ICU.Util.Calendar.JULY, 30,
	                IBM.ICU.Util.JapaneseCalendar.TAISHO, 1, 1912, IBM.ICU.Util.Calendar.AUGUST, 1, };
            QuasiGregorianTest(new IBM.ICU.Util.JapaneseCalendar(), data);
        }

        /// <summary>
        /// Test limits of the Gregorian calendar.
        /// </summary>
        [Test]
        public void TestGregorianLimits()
        {
            // Final parameter is either number of days, if > 0, or test
            // duration in seconds, if < 0.
            IBM.ICU.Util.Calendar cal = IBM.ICU.Util.Calendar.GetInstance();
            cal.Set(2004, IBM.ICU.Util.Calendar.JANUARY, 1);
            IBM.ICU.Util.GregorianCalendar gregorian = new IBM.ICU.Util.GregorianCalendar();
            DoLimitsTest(gregorian, null, cal.GetTime());
            DoTheoreticalLimitsTest(gregorian, false);
        }

        /// <summary>
        /// Test behavior of fieldDifference around leap years. Also test a large
        /// field difference to check binary search.
        /// </summary>
        [Test]
        public void TestLeapFieldDifference()
        {
            IBM.ICU.Util.Calendar cal = IBM.ICU.Util.Calendar.GetInstance();
            cal.Set(2004, IBM.ICU.Util.Calendar.FEBRUARY, 29);
            DateTime date2004 = cal.GetTime();
            cal.Set(2000, IBM.ICU.Util.Calendar.FEBRUARY, 29);
            DateTime date2000 = cal.GetTime();
            int y = cal.FieldDifference(date2004, IBM.ICU.Util.Calendar.YEAR);
            int d = cal.FieldDifference(date2004, IBM.ICU.Util.Calendar.DAY_OF_YEAR);
            if (d == 0)
            {
                Logln("Ok: 2004/Feb/29 - 2000/Feb/29 = " + y + " years, " + d
                        + " days");
            }
            else
            {
                Errln("FAIL: 2004/Feb/29 - 2000/Feb/29 = " + y + " years, " + d
                        + " days");
            }
            cal.SetTime(date2004);
            y = cal.FieldDifference(date2000, IBM.ICU.Util.Calendar.YEAR);
            d = cal.FieldDifference(date2000, IBM.ICU.Util.Calendar.DAY_OF_YEAR);
            if (d == 0)
            {
                Logln("Ok: 2000/Feb/29 - 2004/Feb/29 = " + y + " years, " + d
                        + " days");
            }
            else
            {
                Errln("FAIL: 2000/Feb/29 - 2004/Feb/29 = " + y + " years, " + d
                        + " days");
            }
            // Test large difference
            cal.Set(2001, IBM.ICU.Util.Calendar.APRIL, 5); // 2452005
            DateTime ayl = cal.GetTime();
            cal.Set(1964, IBM.ICU.Util.Calendar.SEPTEMBER, 7); // 2438646
            DateTime asl = cal.GetTime();
            d = cal.FieldDifference(ayl, IBM.ICU.Util.Calendar.DAY_OF_MONTH);
            cal.SetTime(ayl);
            int d2 = cal.FieldDifference(asl, IBM.ICU.Util.Calendar.DAY_OF_MONTH);
            if (d == -d2 && d == 13359)
            {
                Logln("Ok: large field difference symmetrical " + d);
            }
            else
            {
                Logln("FAIL: large field difference incorrect " + d + ", " + d2
                        + ", expect +/- 13359");
            }
        }

        /// <summary>
        /// Test ms_MY "Malay (Malaysia)" locale. Bug 1543.
        /// </summary>
        [Test]
        public void TestMalaysianInstance()
        {
            ILOG.J2CsMapping.Util.Locale loc = new ILOG.J2CsMapping.Util.Locale("ms", "MY"); // Malay (Malaysia)
            IBM.ICU.Util.Calendar cal = IBM.ICU.Util.Calendar.GetInstance(loc);
            if (cal == null)
            {
                Errln("could not create Malaysian instance");
            }
        }

        /// <summary>
        /// setFirstDayOfWeek and setMinimalDaysInFirstWeek may change the field <=>
        /// time mapping, since they affect the interpretation of the WEEK_OF_MONTH
        /// or WEEK_OF_YEAR fields.
        /// </summary>
        [Test]
        public void TestWeekShift()
        {
            IBM.ICU.Util.Calendar cal = new IBM.ICU.Util.GregorianCalendar(
                    IBM.ICU.Util.TimeZone.GetTimeZone("America/Los_Angeles"), new ILOG.J2CsMapping.Util.Locale("en", "US"));
            cal.SetTime(new DateTime((997257600000L) * 10000)); // Wed Aug 08 01:00:00 PDT 2001
            // In pass one, change the first day of week so that the weeks
            // shift in August 2001. In pass two, change the minimal days
            // in the first week so that the weeks shift in August 2001.
            // August 2001
            // Su Mo Tu We Th Fr Sa
            // 1 2 3 4
            // 5 6 7 8 9 10 11
            // 12 13 14 15 16 17 18
            // 19 20 21 22 23 24 25
            // 26 27 28 29 30 31
            for (int pass = 0; pass < 2; ++pass)
            {
                if (pass == 0)
                {
                    cal.SetFirstDayOfWeek(IBM.ICU.Util.Calendar.WEDNESDAY);
                    cal.SetMinimalDaysInFirstWeek(4);
                }
                else
                {
                    cal.SetFirstDayOfWeek(IBM.ICU.Util.Calendar.SUNDAY);
                    cal.SetMinimalDaysInFirstWeek(4);
                }
                cal.Add(IBM.ICU.Util.Calendar.DATE, 1); // Force recalc
                cal.Add(IBM.ICU.Util.Calendar.DATE, -1);

                DateTime time1 = cal.GetTime(); // Get time -- should not change

                // Now change a week parameter and then force a recalc.
                // The bug is that the recalc should not be necessary --
                // calendar should do so automatically.
                if (pass == 0)
                {
                    cal.SetFirstDayOfWeek(IBM.ICU.Util.Calendar.THURSDAY);
                }
                else
                {
                    cal.SetMinimalDaysInFirstWeek(5);
                }

                int woy1 = cal.Get(IBM.ICU.Util.Calendar.WEEK_OF_YEAR);
                int wom1 = cal.Get(IBM.ICU.Util.Calendar.WEEK_OF_MONTH);

                cal.Add(IBM.ICU.Util.Calendar.DATE, 1); // Force recalc
                cal.Add(IBM.ICU.Util.Calendar.DATE, -1);

                int woy2 = cal.Get(IBM.ICU.Util.Calendar.WEEK_OF_YEAR);
                int wom2 = cal.Get(IBM.ICU.Util.Calendar.WEEK_OF_MONTH);

                DateTime time2 = cal.GetTime();

                if (!time1.Equals(time2))
                {
                    Errln("FAIL: shifting week should not alter time");
                }
                else
                {
                    Logln(time1.ToString());
                }
                if (woy1 == woy2 && wom1 == wom2)
                {
                    Logln("Ok: WEEK_OF_YEAR: " + woy1 + ", WEEK_OF_MONTH: " + wom1);
                }
                else
                {
                    Errln("FAIL: WEEK_OF_YEAR: " + woy1 + " => " + woy2
                            + ", WEEK_OF_MONTH: " + wom1 + " => " + wom2
                            + " after week shift");
                }
            }
        }

        /// <summary>
        /// Make sure that when adding a day, we actually wind up in a different day.
        /// The DST adjustments we use to keep the hour constant across DST changes
        /// can backfire and change the day.
        /// </summary>
        [Test]
        public void TestTimeZoneTransitionAdd()
        {
            ILOG.J2CsMapping.Util.Locale locale = new ILOG.J2CsMapping.Util.Locale("en-us"); // could also be CHINA
            SimpleDateFormat dateFormat = new SimpleDateFormat(
                    "MM/dd/yyyy HH:mm z", locale);

            String[] tz = IBM.ICU.Util.TimeZone.GetAvailableIDs();

            for (int z = 0; z < tz.Length; ++z)
            {
                IBM.ICU.Util.TimeZone t = IBM.ICU.Util.TimeZone.GetTimeZone(tz[z]);
                dateFormat.SetTimeZone(t);

                IBM.ICU.Util.Calendar cal = IBM.ICU.Util.Calendar.GetInstance(t, locale);
                cal.Clear();
                // Scan the year 2003, overlapping the edges of the year
                cal.Set(IBM.ICU.Util.Calendar.YEAR, 2002);
                cal.Set(IBM.ICU.Util.Calendar.MONTH, IBM.ICU.Util.Calendar.DECEMBER);
                cal.Set(IBM.ICU.Util.Calendar.DAY_OF_MONTH, 25);

                for (int i = 0; i < 365 + 10; ++i)
                {
                    DateTime yesterday = cal.GetTime();
                    int yesterday_day = cal.Get(IBM.ICU.Util.Calendar.DAY_OF_MONTH);
                    cal.Add(IBM.ICU.Util.Calendar.DAY_OF_MONTH, 1);
                    if (yesterday_day == cal.Get(IBM.ICU.Util.Calendar.DAY_OF_MONTH))
                    {
                        Errln(tz[z] + " " + dateFormat.Format(yesterday) + " +1d= "
                                + dateFormat.Format(cal.GetTime()));
                    }
                }
            }
        }
        [Test]
        public void TestJB1684()
        {


            // July 2001 August 2001 January 2002
            // Su Mo Tu We Th Fr Sa Su Mo Tu We Th Fr Sa Su Mo Tu We Th Fr Sa
            // 1 2 3 4 5 6 7 1 2 3 4 1 2 3 4 5
            // 8 9 10 11 12 13 14 5 6 7 8 9 10 11 6 7 8 9 10 11 12
            // 15 16 17 18 19 20 21 12 13 14 15 16 17 18 13 14 15 16 17 18 19
            // 22 23 24 25 26 27 28 19 20 21 22 23 24 25 20 21 22 23 24 25 26
            // 29 30 31 26 27 28 29 30 31 27 28 29 30 31
            IBMCalendarTest.TestData[] tests = {
	                new IBMCalendarTest.TestData (2001, 8, 6, 2001, 8, 2, IBM.ICU.Util.Calendar.MONDAY,
	                        "2001 08 02 Mon", null),
	                new IBMCalendarTest.TestData (2001, 8, 7, 2001, 8, 2, IBM.ICU.Util.Calendar.TUESDAY,
	                        "2001 08 02 Tue", null),
	                new IBMCalendarTest.TestData (2001, 8, 5,/* 12, */2001, 8, 2, IBM.ICU.Util.Calendar.SUNDAY,
	                        "2001 08 02 Sun", null),
	                new IBMCalendarTest.TestData (2001, 8, 6, /* 7, 30, */2001, 7, 6,
	                        IBM.ICU.Util.Calendar.MONDAY, "2001 07 06 Mon", "2001 08 02 Mon"),
	                new IBMCalendarTest.TestData (2001, 8, 7, /* 7, 31, */2001, 7, 6,
	                        IBM.ICU.Util.Calendar.TUESDAY, "2001 07 06 Tue", "2001 08 02 Tue"),
	                new IBMCalendarTest.TestData (2001, 8, 5, 2001, 7, 6, IBM.ICU.Util.Calendar.SUNDAY,
	                        "2001 07 06 Sun", "2001 08 02 Sun"),
	                new IBMCalendarTest.TestData (2001, 7, 30, 2001, 8, 1, IBM.ICU.Util.Calendar.MONDAY,
	                        "2001 08 01 Mon", "2001 07 05 Mon"),
	                new IBMCalendarTest.TestData (2001, 7, 31, 2001, 8, 1, IBM.ICU.Util.Calendar.TUESDAY,
	                        "2001 08 01 Tue", "2001 07 05 Tue"),
	                new IBMCalendarTest.TestData (2001, 7, 29, /* 8, 5, */2001, 8, 1,
	                        IBM.ICU.Util.Calendar.SUNDAY, "2001 08 01 Sun", "2001 07 05 Sun"),
	                new IBMCalendarTest.TestData (2001, 12, 31, 2001, 12, 6, IBM.ICU.Util.Calendar.MONDAY,
	                        "2001 12 06 Mon", null),
	                new IBMCalendarTest.TestData (2002, 1, 1, 2002, 1, 1, IBM.ICU.Util.Calendar.TUESDAY,
	                        "2002 01 01 Tue", null),
	                new IBMCalendarTest.TestData (2002, 1, 2, 2002, 1, 1, IBM.ICU.Util.Calendar.WEDNESDAY,
	                        "2002 01 01 Wed", null),
	                new IBMCalendarTest.TestData (2002, 1, 3, 2002, 1, 1, IBM.ICU.Util.Calendar.THURSDAY,
	                        "2002 01 01 Thu", null),
	                new IBMCalendarTest.TestData (2002, 1, 4, 2002, 1, 1, IBM.ICU.Util.Calendar.FRIDAY,
	                        "2002 01 01 Fri", null),
	                new IBMCalendarTest.TestData (2002, 1, 5, 2002, 1, 1, IBM.ICU.Util.Calendar.SATURDAY,
	                        "2002 01 01 Sat", null),
	                new IBMCalendarTest.TestData (2001, 12, 30, /* 2002, 1, 6, */2002, 1, 1,
	                        IBM.ICU.Util.Calendar.SUNDAY, "2002 01 01 Sun", "2001 12 06 Sun"), };

            int pass = 0, error = 0, warning = 0;

            String pattern = "yyyy MM WW EEE";
            IBM.ICU.Util.GregorianCalendar cal = new IBM.ICU.Util.GregorianCalendar();
            SimpleDateFormat sdf = new SimpleDateFormat(pattern);
            sdf.SetCalendar(cal);

            cal.SetFirstDayOfWeek(IBM.ICU.Util.Calendar.SUNDAY);
            cal.SetMinimalDaysInFirstWeek(1);

            for (int i = 0; i < tests.Length; ++i)
            {
                IBMCalendarTest.TestData test = tests[i];
                Log("\n-----\nTesting round trip of " + test.year + " "
                        + (test.month + 1) + " " + test.date + " (written as) "
                        + test.data);

                cal.Clear();
                cal.Set(test.year, test.month, test.date);
                DateTime ms = cal.GetTime();

                cal.Clear();
                cal.Set(IBM.ICU.Util.Calendar.YEAR, test.womyear);
                cal.Set(IBM.ICU.Util.Calendar.MONTH, test.wommon);
                cal.Set(IBM.ICU.Util.Calendar.WEEK_OF_MONTH, test.wom);
                cal.Set(IBM.ICU.Util.Calendar.DAY_OF_WEEK, test.dow);
                DateTime ms2 = cal.GetTime();

                if (!ms2.Equals(ms))
                {
                    Log("\nError: GregorianCalendar.DOM gave " + ms
                            + "\n       GregorianCalendar.WOM gave " + ms2);
                    error++;
                }
                else
                {
                    pass++;
                }

                ms2 = default(DateTime);
                try
                {
                    ms2 = sdf.Parse(test.data);
                }
                catch (ILOG.J2CsMapping.Util.ParseException e)
                {
                    Errln("parse exception: " + e);
                }

                if (!ms2.Equals(ms))
                {
                    Log("\nError: GregorianCalendar gave      " + ms
                            + "\n       SimpleDateFormat.parse gave " + ms2);
                    error++;
                }
                else
                {
                    pass++;
                }

                String result = sdf.Format(ms);
                if (!result.Equals(test.normalized))
                {
                    Log("\nWarning: format of '" + test.data + "' gave"
                            + "\n                   '" + result + "'"
                            + "\n          expected '" + test.normalized + "'");
                    warning++;
                }
                else
                {
                    pass++;
                }

                DateTime ms3 = default(DateTime);
                try
                {
                    ms3 = sdf.Parse(result);
                }
                catch (ILOG.J2CsMapping.Util.ParseException e_0)
                {
                    Errln("parse exception 2: " + e_0);
                }

                if (!ms3.Equals(ms))
                {
                    error++;
                    Log("\nError: Re-parse of '" + result + "' gave time of "
                            + "\n        " + ms3 + "\n    not " + ms);
                }
                else
                {
                    pass++;
                }
            }
            String info = "\nPassed: " + pass + ", Warnings: " + warning
                    + ", Errors: " + error;
            if (error > 0)
            {
                Errln(info);
            }
            else
            {
                Logln(info);
            }
        }

        /// <summary>
        /// Test the ZoneMeta API.
        /// </summary>
        [Test]
        public void TestZoneMeta()
        {
            // Test index by country API

            String[][] COUNTRY = { new String[] { "" },
	                new String[] { "US", "America/Los_Angeles", "PST" } };
            StringBuilder buf = new StringBuilder();
            for (int i = 0; i < COUNTRY.Length; ++i)
            {
                String[] a = IBM.ICU.Impl.ZoneMeta.GetAvailableIDs(COUNTRY[i][0]);
                buf.Length = 0;
                buf.Append("Country \"" + COUNTRY[i][0] + "\": [");
                // Use bitmask to track which of the expected zones we see
                int mask = 0;
                for (int j = 0; j < a.Length; ++j)
                {
                    if (j != 0)
                        buf.Append(", ");
                    buf.Append(a[j]);
                    for (int k = 1; k < COUNTRY[i].Length; ++k)
                    {
                        if ((mask & (1 << k)) == 0 && a[j].Equals(COUNTRY[i][k]))
                        {
                            mask |= (1 << k);
                        }
                    }
                }
                buf.Append("]");
                mask >>= 1;
                // Check bitmask to see if we saw all expected zones
                if (mask == (1 << (COUNTRY[i].Length - 1)) - 1)
                {
                    Logln(buf.ToString());
                }
                else
                {
                    Errln(buf.ToString());
                }
            }

            // Test equivalent IDs API

            int n = IBM.ICU.Impl.ZoneMeta.CountEquivalentIDs("PST");
            bool ok = false;
            buf.Length = 0;
            buf.Append("Equivalent to PST: ");
            for (int i_0 = 0; i_0 < n; ++i_0)
            {
                String id = IBM.ICU.Impl.ZoneMeta.GetEquivalentID("PST", i_0);
                if (id.Equals("America/Los_Angeles"))
                {
                    ok = true;
                }
                if (i_0 != 0)
                    buf.Append(", ");
                buf.Append(id);
            }
            if (ok)
            {
                Logln(buf.ToString());
            }
            else
            {
                Errln(buf.ToString());
            }
        }
        [Test]
        public void TestComparable()
        {
            IBM.ICU.Util.GregorianCalendar c0 = new IBM.ICU.Util.GregorianCalendar();
            IBM.ICU.Util.GregorianCalendar c1 = new IBM.ICU.Util.GregorianCalendar();
            c1.Add(IBM.ICU.Util.Calendar.DAY_OF_MONTH, 1);
            if (c0.CompareTo(c1) >= 0)
            {
                Errln("calendar " + c0 + " not < " + c1);
            }
            c0.Add(IBM.ICU.Util.Calendar.MONTH, 1);
            if (c0.CompareTo(c1) <= 0)
            {
                Errln("calendar " + c0 + " not > " + c1);
            }

            c0.SetTimeInMillis(c1.GetTimeInMillis());
            if (c0.CompareTo(c1) != 0)
            {
                Errln("calendar " + c0 + " not == " + c1);
            }

            // coverage
            try
            {
                c0.CompareTo((Object)null);
                Errln("calendar.compareTo didn't object to null arg");
            }
            catch (NullReferenceException npe)
            {
                Logln("PASS: calendar.compareTo objected to null arg");
            }
        }

        /// <summary>
        /// Miscellaneous tests to increase coverage.
        /// </summary>
        [Test]
        public void TestCoverage()
        {
            // BuddhistCalendar
            BuddhistCalendar bcal = new BuddhistCalendar();
            /* int i = */
            bcal.GetMinimum(IBM.ICU.Util.Calendar.ERA);
            bcal.Add(IBM.ICU.Util.Calendar.YEAR, 1);
            bcal.Add(IBM.ICU.Util.Calendar.MONTH, 1);
            /* Date d = */
            bcal.GetTime();

            // CalendarAstronomer
            // (This class should probably be made package-private.)
            CalendarAstronomer astro = new CalendarAstronomer();
            /* String s = */
            astro.Local(0);

            // ChineseCalendar
            ChineseCalendar ccal = new ChineseCalendar(IBM.ICU.Util.TimeZone.GetDefault(),
                    ILOG.J2CsMapping.Util.Locale.GetDefault());
            ccal.Add(IBM.ICU.Util.Calendar.MONTH, 1);
            ccal.Add(IBM.ICU.Util.Calendar.YEAR, 1);
            ccal.Roll(IBM.ICU.Util.Calendar.MONTH, 1);
            ccal.Roll(IBM.ICU.Util.Calendar.YEAR, 1);
            ccal.GetTime();

            // ICU 2.6
            IBM.ICU.Util.Calendar cal = IBM.ICU.Util.Calendar.GetInstance(new ILOG.J2CsMapping.Util.Locale("en-us"));
            Logln(cal.ToString());
            Logln(cal.GetDisplayName(new ILOG.J2CsMapping.Util.Locale("en-us")));
            int weekendOnset = -1;
            int weekendCease = -1;
            for (int i = IBM.ICU.Util.Calendar.SUNDAY; i <= IBM.ICU.Util.Calendar.SATURDAY; ++i)
            {
                if (cal.GetDayOfWeekType(i) == IBM.ICU.Util.Calendar.WEEKEND_ONSET)
                {
                    weekendOnset = i;
                }
                if (cal.GetDayOfWeekType(i) == IBM.ICU.Util.Calendar.WEEKEND_CEASE)
                {
                    weekendCease = i;
                }
            }
            // can't call this unless we get a transition day (unusual),
            // but make the call anyway for coverage reasons
            try
            {
                /* int x= */
                cal.GetWeekendTransition(weekendOnset);
                /* int x= */
                cal.GetWeekendTransition(weekendCease);
            }
            catch (ArgumentException e)
            {
            }
            /* int x= */
            cal.IsWeekend(DateTime.Now);

            // new GregorianCalendar(ULocale)
            IBM.ICU.Util.GregorianCalendar gcal = new IBM.ICU.Util.GregorianCalendar(IBM.ICU.Util.ULocale.GetDefault());
            if (gcal == null)
            {
                Errln("could not create GregorianCalendar with ULocale");
            }
            else
            {
                Logln("Calendar display name: "
                        + gcal.GetDisplayName(IBM.ICU.Util.ULocale.GetDefault()));
            }

            // cover getAvailableULocales
            ULocale[] locales = IBM.ICU.Util.Calendar.GetAvailableULocales();
            long count = locales.Length;
            if (count == 0)
                Errln("getAvailableULocales return empty list");
            Logln("" + count + " available ulocales in Calendar.");

            // Jitterbug 4451, for coverage

            IBMCalendarTest.StubCalendar stub = new IBMCalendarTest.StubCalendar(this);
            stub.Run();
        }

        // Tests for jb 4541
        [Test]
        public void TestJB4541()
        {
            ULocale loc = new ULocale("en_US");

            // !!! Shouldn't we have an api like this?
            // !!! Question: should this reflect those actually available in this
            // copy of ICU, or
            // the list of types we assume is available?
            // String[] calTypes = Calendar.getAvailableTypes();
            String[] calTypes = { "buddhist", "chinese", "coptic",
	                "ethiopic", "gregorian", "hebrew", "islamic", "islamic-civil",
	                "japanese", "taiwan" };

            // constructing a DateFormat with a locale indicating a calendar type
            // should construct a
            // date format appropriate to that calendar
            DateTime time = DateTime.Now;
            for (int i = 0; i < calTypes.Length; ++i)
            {
                ULocale aLoc = loc.SetKeywordValue("calendar", calTypes[i]);
                Logln("locale: " + aLoc);

                DateFormat df = IBM.ICU.Text.DateFormat.GetDateTimeInstance(IBM.ICU.Text.DateFormat.FULL,
                        IBM.ICU.Text.DateFormat.FULL, aLoc);

                Logln("df type: " + df.GetType().FullName + " loc: "
                        + df.GetLocale(IBM.ICU.Util.ULocale.VALID_LOCALE));

                IBM.ICU.Util.Calendar cal = df.GetCalendar();
                // todo, what about variants of calendars, we have a type for
                // islamic-civil, should we also have a type
                // for variants of other calendars?
                AssertEquals("calendar types", cal.GetType(),
                        (calTypes[i].Equals("islamic-civil")) ? "islamic"
                                : calTypes[i]);
                DateFormat df2 = cal.GetDateTimeFormat(IBM.ICU.Text.DateFormat.FULL,
                        IBM.ICU.Text.DateFormat.FULL, IBM.ICU.Util.ULocale.US);
                Logln("df2 type: " + df2.GetType().FullName + " loc: "
                        + df2.GetLocale(IBM.ICU.Util.ULocale.VALID_LOCALE));
                AssertEquals("format results", df.Format(time), df2.Format(time));
            }

            // dateFormat.setCalendar should throw exception if wrong format for
            // calendar
            if (false)
            {
                DateFormat df_0 = IBM.ICU.Text.DateFormat.GetDateTimeInstance(IBM.ICU.Text.DateFormat.FULL,
                        IBM.ICU.Text.DateFormat.FULL, new ULocale("en_US@calendar=chinese"));

                Logln("dateformat type: " + df_0.GetType().FullName);

                IBM.ICU.Util.Calendar cal_1 = IBM.ICU.Util.Calendar.GetInstance(new ULocale(
                        "en_US@calendar=chinese"));

                Logln("calendar type: " + ((object)cal_1).GetType().FullName);
            }
        }

        internal class TestData
        {
            internal int year;

            internal int month;

            internal int date;

            internal int womyear;

            internal int wommon;

            internal int wom;

            internal int dow;

            internal String data;

            internal String normalized;

            public TestData(int year_0, int month_1, int date_2, int womyear_3,
                    int wommon_4, int wom_5, int dow_6, String data_7, String normalized_8)
            {
                this.year = year_0;
                this.month = month_1 - 1;
                this.date = date_2;
                this.womyear = womyear_3;
                this.wommon = wommon_4 - 1;
                this.wom = wom_5;
                this.dow = dow_6;
                this.data = data_7; // year, month, week of month, day
                this.normalized = data_7;
                if (normalized_8 != null)
                    this.normalized = normalized_8;
            }
        }

        [Serializable]
        public class StubCalendar : IBM.ICU.Util.Calendar
        {
            private IBMCalendarTest outer_IBMCalendarTest;


            /// <param name="test"></param>
            public StubCalendar(IBMCalendarTest test)
            {
                outer_IBMCalendarTest = test;
            }

            /// <summary>
            /// For serialization
            /// </summary>
            ///
            private const long serialVersionUID = -4558903444622684759L;

            protected override int HandleGetLimit(int field, int limitType)
            {
                return 0;
            }

            protected override int HandleComputeMonthStart(int eyear, int month_0,
                    bool useMonth)
            {
                return 0;
            }

            protected override int HandleGetExtendedYear()
            {
                return 0;
            }

            public void Run()
            {
                if (IBM.ICU.Util.Calendar.GregorianPreviousMonthLength(2000, 2) != 29)
                {
                    outer_IBMCalendarTest.Errln("Year 2000 Feb should have 29 days.");
                }
                long millis = IBM.ICU.Util.Calendar.JulianDayToMillis(IBM.ICU.Util.Calendar.MAX_JULIAN);
                if (millis != IBM.ICU.Util.Calendar.MAX_MILLIS)
                {
                    outer_IBMCalendarTest.Errln("Did not get the expected value from julianDayToMillis. Got:"
                            + millis);
                }
                DateFormat df = HandleGetDateFormat("", ILOG.J2CsMapping.Util.Locale.GetDefault());
                if (!df.Equals(HandleGetDateFormat("", IBM.ICU.Util.ULocale.GetDefault())))
                {
                    outer_IBMCalendarTest.Errln("Calendar.handleGetDateFormat(String, Locale) should delegate to ( ,ULocale)");
                }
                if (!GetType().Equals("gregorian"))
                {
                    outer_IBMCalendarTest.Errln("Calendar.getType() should be 'gregorian'");
                }
            }
        }
    }
}
