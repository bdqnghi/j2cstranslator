/*
 *******************************************************************************
 * Copyright (C) 1996-2007, International Business Machines Corporation and    *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 */
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/13/10 4:01 PM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
namespace IBM.ICU.Charset
{

    // AstroTest

    using IBM.ICU.Impl;
    using System;
    using IBM.ICU.Util;
    using ILOG.J2CsMapping.Text;
    using NUnit.Framework;
    using ILOG.J2CsMapping.Util;

    // TODO: try finding next new moon after  07/28/1984 16:00 GMT
    [TestFixture]
    public class AstroTest : TestFmwk
    {
        public static void Main(String[] args)
        {
            new AstroTest().Run(args);
        }

        internal const double PI = System.Math.PI;

        [Test]
        public void TestSolarLongitude()
        {
            IBM.ICU.Util.GregorianCalendar gc = new IBM.ICU.Util.GregorianCalendar(new SimpleTimeZone(0,
                    "UTC"));
            CalendarAstronomer astro = new CalendarAstronomer();
            double[][] tests = {
	                new double[] { 1980, 7, 27, 0x0, 0x0, 2.166442986535465d,
	                        2.2070499713207730d, 0.3355704075759270d },
	                new double[] { 1988, 7, 27, 0x0, 0x0, 2.167484927693959d,
	                        2.2081183335606176d, 0.3353093444275315d } };
            Logln("");
            for (int i = 0; i < tests.Length; i++)
            {
                gc.Clear();
                gc.Set((int)tests[i][0], (int)tests[i][1] - 1, (int)tests[i][2],
                        (int)tests[i][3], (int)tests[i][4]);

                astro.SetDate(gc.GetTime());

                double longitude = astro.GetSunLongitude();
                if (longitude != tests[i][5])
                {
                    if ((float)longitude == (float)tests[i][5])
                    {
                        Logln("longitude(" + longitude + ") !=  tests[i][5]("
                                + tests[i][5] + ") in double for test " + i);
                    }
                    else
                    {
                        Errln("FAIL: longitude(" + longitude + ") !=  tests[i][5]("
                                + tests[i][5] + ") for test " + i);
                    }
                }
                IBM.ICU.Impl.CalendarAstronomer.Equatorial result = astro.GetSunPosition();
                if (result.ascension != tests[i][6])
                {
                    if ((float)result.ascension == (float)tests[i][6])
                    {
                        Logln("result.ascension(" + result.ascension
                                + ") !=  tests[i][6](" + tests[i][6]
                                + ") in double for test " + i);
                    }
                    else
                    {
                        Errln("FAIL: result.ascension(" + result.ascension
                                + ") !=  tests[i][6](" + tests[i][6]
                                + ") for test " + i);
                    }
                }
                if (result.declination != tests[i][7])
                {
                    if ((float)result.declination == (float)tests[i][7])
                    {
                        Logln("result.declination(" + result.declination
                                + ") !=  tests[i][7](" + tests[i][7]
                                + ") in double for test " + i);
                    }
                    else
                    {
                        Errln("FAIL: result.declination(" + result.declination
                                + ") !=  tests[i][7](" + tests[i][7]
                                + ") for test " + i);
                    }
                }
            }
        }
        [Test]
        public void TestLunarPosition()
        {
            IBM.ICU.Util.GregorianCalendar gc = new IBM.ICU.Util.GregorianCalendar(new SimpleTimeZone(0,
                    "UTC"));
            CalendarAstronomer astro = new CalendarAstronomer();
            double[][] tests = { new double[] { 1979, 2, 26, 16, 0x0,
	                -0.3778379118188744d, -0.1399698825594198d } };
            Logln("");

            for (int i = 0; i < tests.Length; i++)
            {
                gc.Clear();
                gc.Set((int)tests[i][0], (int)tests[i][1] - 1, (int)tests[i][2],
                        (int)tests[i][3], (int)tests[i][4]);
                astro.SetDate(gc.GetTime());

                IBM.ICU.Impl.CalendarAstronomer.Equatorial result = astro.GetMoonPosition();
                if (result.ascension != tests[i][5])
                {
                    if ((float)result.ascension == (float)tests[i][5])
                    {
                        Logln("result.ascension(" + result.ascension
                                + ") !=  tests[i][5](" + tests[i][5]
                                + ") in double for test " + i);
                    }
                    else
                    {
                        Errln("FAIL: result.ascension(" + result.ascension
                                + ") !=  tests[i][5](" + tests[i][5]
                                + ") for test " + i);
                    }
                }
                if (result.declination != tests[i][6])
                {
                    if ((float)result.declination == (float)tests[i][6])
                    {
                        Logln("result.declination(" + result.declination
                                + ") !=  tests[i][6](" + tests[i][6]
                                + ") in double for test " + i);
                    }
                    else
                    {
                        Errln("FAIL: result.declination(" + result.declination
                                + ") !=  tests[i][6](" + tests[i][6]
                                + ") for test " + i);
                    }
                }
            }
        }
        [Test]
        public void TestCoordinates()
        {
            CalendarAstronomer astro = new CalendarAstronomer();
            IBM.ICU.Impl.CalendarAstronomer.Equatorial result = astro.EclipticToEquatorial(139.686111d * PI / 180.0d,
                    4.875278d * PI / 180.0d);
            Logln("result is " + result + ";  " + result.ToHmsString());
        }

        [Test]
        public void TestCoverage()
        {
            IBM.ICU.Util.GregorianCalendar cal = new IBM.ICU.Util.GregorianCalendar(1958, IBM.ICU.Util.Calendar.AUGUST, 15);
            DateTime then = cal.GetTime();
            CalendarAstronomer myastro = new CalendarAstronomer(then);

            // Latitude: 34 degrees 05' North
            // Longitude: 118 degrees 22' West
            double laLat = 34 + 5d / 60, laLong = 360 - (118 + 22d / 60);
            CalendarAstronomer myastro2 = new CalendarAstronomer(laLong, laLat);

            double eclLat = laLat * System.Math.PI / 360;
            double eclLong = laLong * System.Math.PI / 360;
            IBM.ICU.Impl.CalendarAstronomer.Ecliptic ecl = new IBM.ICU.Impl.CalendarAstronomer.Ecliptic(eclLat, eclLong);
            Logln("ecliptic: " + ecl);

            CalendarAstronomer myastro3 = new CalendarAstronomer();
            myastro3.SetJulianDay((4713 + 2000) * 365.25d);

            CalendarAstronomer[] astronomers = { myastro, myastro2, myastro3,
	                myastro2 // check cache
	
	        };

            for (int i = 0; i < astronomers.Length; ++i)
            {
                CalendarAstronomer astro = astronomers[i];

                Logln("astro: " + astro);
                Logln("   time: " + astro.GetTime());
                Logln("   date: " + astro.GetDate());
                Logln("   cent: " + astro.GetJulianCentury());
                Logln("   gw sidereal: " + astro.GetGreenwichSidereal());
                Logln("   loc sidereal: " + astro.GetLocalSidereal());
                Logln("   equ ecl: " + astro.EclipticToEquatorial(ecl));
                Logln("   equ long: " + astro.EclipticToEquatorial(eclLong));
                Logln("   horiz: " + astro.EclipticToHorizon(eclLong));
                Logln("   sunrise: " + DateUtil.DateFromJavaMillis(astro.GetSunRiseSet(true)));
                Logln("   sunset: " + DateUtil.DateFromJavaMillis(astro.GetSunRiseSet(false)));
                Logln("   moon phase: " + astro.GetMoonPhase());
                Logln("   moonrise: " + DateUtil.DateFromJavaMillis(astro.GetMoonRiseSet(true)));
                Logln("   moonset: " + DateUtil.DateFromJavaMillis(astro.GetMoonRiseSet(false)));
                Logln("   prev summer solstice: "
                        + DateUtil.DateFromJavaMillis(astro.GetSunTime(
                                                    IBM.ICU.Impl.CalendarAstronomer.SUMMER_SOLSTICE, false)));
                Logln("   next summer solstice: "
                        + DateUtil.DateFromJavaMillis(astro.GetSunTime(
                                                    IBM.ICU.Impl.CalendarAstronomer.SUMMER_SOLSTICE, true)));
                Logln("   prev full moon: "
                        + DateUtil.DateFromJavaMillis(astro.GetMoonTime(IBM.ICU.Impl.CalendarAstronomer.FULL_MOON,
                                                    false)));
                Logln("   next full moon: "
                        + DateUtil.DateFromJavaMillis(astro.GetMoonTime(IBM.ICU.Impl.CalendarAstronomer.FULL_MOON,
                                                    true)));
            }

        }

        internal const long DAY_MS = 24 * 60 * 60 * 1000L;
        [Test]
        public void TestSunriseTimes()
        {

            // logln("Sunrise/Sunset times for San Jose, California, USA");
            // CalendarAstronomer astro = new CalendarAstronomer(-121.55, 37.20);
            // TimeZone tz = TimeZone.getTimeZone("America/Los_Angeles");

            // We'll use a table generated by the UNSO website as our reference
            // From: http://aa.usno.navy.mil/
            // -Location: W079 25, N43 40
            // -Rise and Set for the Sun for 2001
            // -Zone: 4h West of Greenwich
            int[] USNO = { 6, 59, 19, 45, 6, 57, 19, 46, 6, 56, 19, 47, 6, 54, 19,
	                48, 6, 52, 19, 49, 6, 50, 19, 51, 6, 48, 19, 52, 6, 47, 19, 53,
	                6, 45, 19, 54, 6, 43, 19, 55, 6, 42, 19, 57, 6, 40, 19, 58, 6,
	                38, 19, 59, 6, 36, 20, 0, 6, 35, 20, 1, 6, 33, 20, 3, 6, 31,
	                20, 4, 6, 30, 20, 5, 6, 28, 20, 6, 6, 27, 20, 7, 6, 25, 20, 8,
	                6, 23, 20, 10, 6, 22, 20, 11, 6, 20, 20, 12, 6, 19, 20, 13, 6,
	                17, 20, 14, 6, 16, 20, 16, 6, 14, 20, 17, 6, 13, 20, 18, 6, 11,
	                20, 19, };

            Logln("Sunrise/Sunset times for Toronto, Canada");
            CalendarAstronomer astro = new CalendarAstronomer(-(79 + 25 / 60),
                    43 + 40 / 60);

            // As of ICU4J 2.8 the ICU4J time zones implement pass-through
            // to the underlying JDK. Because of variation in the
            // underlying JDKs, we have to use a fixed-offset
            // SimpleTimeZone to get consistent behavior between JDKs.
            // The offset we want is [-18000000, 3600000] (raw, dst).
            // [aliu 10/15/03]

            // TimeZone tz = TimeZone.getTimeZone("America/Montreal");
            IBM.ICU.Util.TimeZone tz = new SimpleTimeZone(-18000000 + 3600000, "Montreal(FIXED)");

            IBM.ICU.Util.GregorianCalendar cal = new IBM.ICU.Util.GregorianCalendar(tz, Locale.US);
            IBM.ICU.Util.GregorianCalendar cal2 = new IBM.ICU.Util.GregorianCalendar(tz, Locale.US);
            cal.Clear();
            cal.Set(IBM.ICU.Util.Calendar.YEAR, 2001);
            cal.Set(IBM.ICU.Util.Calendar.MONTH, IBM.ICU.Util.Calendar.APRIL);
            cal.Set(IBM.ICU.Util.Calendar.DAY_OF_MONTH, 1);
            cal.Set(IBM.ICU.Util.Calendar.HOUR_OF_DAY, 12); // must be near local noon for
            // getSunRiseSet to work

            IBM.ICU.Text.DateFormat df = IBM.ICU.Text.DateFormat.GetTimeInstance(cal, IBM.ICU.Text.DateFormat.MEDIUM,
                    Locale.US);
            IBM.ICU.Text.DateFormat df2 = IBM.ICU.Text.DateFormat.GetDateTimeInstance(cal, IBM.ICU.Text.DateFormat.MEDIUM,
                    IBM.ICU.Text.DateFormat.MEDIUM, Locale.US);
            IBM.ICU.Text.DateFormat day = IBM.ICU.Text.DateFormat.GetDateInstance(cal, IBM.ICU.Text.DateFormat.MEDIUM,
                    Locale.US);

            for (int i = 0; i < 30; i++)
            {
                astro.SetDate(cal.GetTime());

                DateTime sunrise = DateUtil.DateFromJavaMillis(astro.GetSunRiseSet(true));
                DateTime sunset = DateUtil.DateFromJavaMillis(astro.GetSunRiseSet(false));

                cal2.SetTime(cal.GetTime());
                cal2.Set(IBM.ICU.Util.Calendar.SECOND, 0);
                cal2.Set(IBM.ICU.Util.Calendar.MILLISECOND, 0);

                cal2.Set(IBM.ICU.Util.Calendar.HOUR_OF_DAY, USNO[4 * i + 0]);
                cal2.Set(IBM.ICU.Util.Calendar.MINUTE, USNO[4 * i + 1]);
                DateTime exprise = cal2.GetTime();
                cal2.Set(IBM.ICU.Util.Calendar.HOUR_OF_DAY, USNO[4 * i + 2]);
                cal2.Set(IBM.ICU.Util.Calendar.MINUTE, USNO[4 * i + 3]);
                DateTime expset = cal2.GetTime();
                // Compute delta of what we got to the USNO data, in seconds
                int deltarise = Math.Abs((int)((sunrise.Ticks / 10000) - (exprise.Ticks / 10000)) / 1000);
                int deltaset = Math.Abs((int)((sunset.Ticks / 10000) - (expset.Ticks / 10000)) / 1000);

                // Allow a deviation of 0..MAX_DEV seconds
                // It would be nice to get down to 60 seconds, but at this
                // point that appears to be impossible without a redo of the
                // algorithm using something more advanced than Duffett-Smith.
                int MAX_DEV = 180;
                if (deltarise > MAX_DEV || deltaset > MAX_DEV)
                {
                    if (deltarise > MAX_DEV)
                    {
                        Errln("FAIL: " + day.Format(cal.GetTime()) + ", Sunrise: "
                                + df2.Format(sunrise) + " (USNO "
                                + df.Format(exprise) + " d=" + deltarise + "s)");
                    }
                    else
                    {
                        Logln(day.Format(cal.GetTime()) + ", Sunrise: "
                                + df.Format(sunrise) + " (USNO "
                                + df.Format(exprise) + ")");
                    }
                    if (deltaset > MAX_DEV)
                    {
                        Errln("FAIL: " + day.Format(cal.GetTime()) + ", Sunset: "
                                + df2.Format(sunset) + " (USNO "
                                + df.Format(expset) + " d=" + deltaset + "s)");
                    }
                    else
                    {
                        Logln(day.Format(cal.GetTime()) + ", Sunset: "
                                + df.Format(sunset) + " (USNO " + df.Format(expset)
                                + ")");
                    }
                }
                else
                {
                    Logln(day.Format(cal.GetTime()) + ", Sunrise: "
                            + df.Format(sunrise) + " (USNO " + df.Format(exprise)
                            + ")" + ", Sunset: " + df.Format(sunset) + " (USNO "
                            + df.Format(expset) + ")");
                }
                cal.Add(IBM.ICU.Util.Calendar.DATE, 1);
            }

            // CalendarAstronomer a = new CalendarAstronomer(-(71+5/60), 42+37/60);
            // cal.clear();
            // cal.set(cal.YEAR, 1986);
            // cal.set(cal.MONTH, cal.MARCH);
            // cal.set(cal.DATE, 10);
            // cal.set(cal.YEAR, 1988);
            // cal.set(cal.MONTH, cal.JULY);
            // cal.set(cal.DATE, 27);
            // a.setDate(cal.getTime());
            // long r = a.getSunRiseSet2(true);
        }
        [Test]
        public void TestBasics()
        {
            // Check that our JD computation is the same as the book's (p. 88)
            CalendarAstronomer astro = new CalendarAstronomer();
            IBM.ICU.Util.GregorianCalendar cal3 = new IBM.ICU.Util.GregorianCalendar(
                    IBM.ICU.Util.TimeZone.GetTimeZone("GMT"), Locale.US);
            IBM.ICU.Text.DateFormat d3 = IBM.ICU.Text.DateFormat.GetDateTimeInstance(cal3, IBM.ICU.Text.DateFormat.MEDIUM,
                    IBM.ICU.Text.DateFormat.MEDIUM, Locale.US);
            cal3.Clear();
            cal3.Set(IBM.ICU.Util.Calendar.YEAR, 1980);
            cal3.Set(IBM.ICU.Util.Calendar.MONTH, IBM.ICU.Util.Calendar.JULY);
            cal3.Set(IBM.ICU.Util.Calendar.DATE, 27);
            astro.SetDate(cal3.GetTime());
            double jd = astro.GetJulianDay() - 2447891.5d;
            double exp = -3444;
            if (jd == exp)
            {
                Logln(d3.Format(cal3.GetTime()) + " => " + jd);
            }
            else
            {
                Errln("FAIL: " + d3.Format(cal3.GetTime()) + " => " + jd
                        + ", expected " + exp);
            }

            // cal3.clear();
            // cal3.set(cal3.YEAR, 1990);
            // cal3.set(cal3.MONTH, Calendar.JANUARY);
            // cal3.set(cal3.DATE, 1);
            // cal3.add(cal3.DATE, -1);
            // astro.setDate(cal3.getTime());
            // astro.foo();
        }
    }
}
