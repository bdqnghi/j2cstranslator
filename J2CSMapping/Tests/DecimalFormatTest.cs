/* 
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/// ---------------------------------------------------------------------------------------------------
///  This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
///  Version 1.0.0                                                                                      
/// ---------------------------------------------------------------------------------------------------
 namespace Text2 {
	
	using ILOG.J2CsMapping.IO;
	using ILOG.J2CsMapping.Text;
	using NUnit.Framework;
	using NUnit;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.Globalization;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Text;
	
	/*import org.apache.harmony.testframework.serialization.SerializationTest;
	
	import tests.support.Support_BitSet;
	import tests.support.Support_DecimalFormat;*/
	
	[NUnit.Framework.TestFixture]
	public class DecimalFormatTest {
        [NUnit.Framework.Test]
        public void Test()
        {
            object o = new DecimalFormat().Parse("04000\f1+9\t2\0");
            Assert.AreEqual(o, "4000");
        }

	/*
		[NUnit.Framework.Test]
		public void TestAttributedCharacterIterator() {
			// Regression for http://issues.apache.org/jira/browse/HARMONY-333
			AttributedCharacterIterator iterator = new DummyFormat()
					.FormatToCharacterIterator(((int)(1)));
			Junit.Framework.Assert.AssertNotNull(iterator);
			Junit.Framework.Assert.AssertFalse("attributes should exist", (iterator.GetAttributes().Count==0));
		}
	
		/*
		 * Test the getter and setter of parseBigDecimal and parseIntegerOnly and
		 * test the default value of them.
		 *
		[NUnit.Framework.Test]
		public void Test_isParseBigDecimalLjava_lang_Boolean_isParseIntegerOnlyLjava_lang_Boolean() {
	
			// parseBigDecimal default to false
			DummyFormat form = (DummyFormat) ILOG.J2CsMapping.Text.NumberFormat
					.GetInstance(System.Globalization.CultureInfo.CreateSpecificCulture("en-us"));
			Junit.Framework.Assert.AssertFalse(form.IsParseBigDecimal());
			form.SetParseBigDecimal(true);
			Junit.Framework.Assert.AssertTrue(form.IsParseBigDecimal());
			form.SetParseBigDecimal(false);
			Junit.Framework.Assert.AssertFalse(form.IsParseBigDecimal());
	
			// parseIntegerOnly default to false
			Junit.Framework.Assert.AssertFalse(form.IsParseIntegerOnly());
		}
	
		// Test the type of the returned object
	
		[NUnit.Framework.Test]
		public void Test_parseLjava_lang_String_Ljava_text_ParsePosition() {
			DummyFormat form = (DummyFormat) ILOG.J2CsMapping.Text.NumberFormat
					.GetInstance(System.Globalization.CultureInfo.CreateSpecificCulture("en-us"));
			object number = form.Parse("23.1", new ParsePosition(0));
			Junit.Framework.Assert.AssertTrue(number  is  Double);
	
			// Test parsed object of type double when
			// parseBigDecimal is set to true
	
			form = (DummyFormat) ILOG.J2CsMapping.Text.NumberFormat.GetInstance(System.Globalization.CultureInfo.CreateSpecificCulture("en-us"));
			number = form.Parse("23.1", new ParsePosition(0));
			Junit.Framework.Assert.AssertTrue(number  is  Double);
	
			form.SetParseBigDecimal(true);
			number = form.Parse("23.1", new ParsePosition(0));
	
			Junit.Framework.Assert.AssertTrue(number  is  Decimal);
			Junit.Framework.Assert.AssertEquals(Decimal.Parse("23.1"), number);
	
			// When parseIntegerOnly set to true, all float numbers will be parsed
			// into Long.
			// With the exception that, the value is out of the bound of Long or
			// some special values such as NaN or Infinity.
	
			form = (DummyFormat) ILOG.J2CsMapping.Text.NumberFormat.GetInstance(System.Globalization.CultureInfo.CreateSpecificCulture("en-us"));
			form.SetParseIntegerOnly(true);
			number = form.Parse("23.1f", new ParsePosition(0));
	
			Junit.Framework.Assert.AssertTrue(number  is  Int64);
	
			number = form.Parse("23.0", new ParsePosition(0));
			Junit.Framework.Assert.AssertTrue(number  is  Int64);
	
			number = form.Parse("-0.0", new ParsePosition(0));
			Junit.Framework.Assert.AssertTrue(number  is  Int64);
			Junit.Framework.Assert.AssertTrue((long )(0).Equals(number));
	
			number = form.Parse("-9,223,372,036,854,775,8080.00",
					new ParsePosition(0));
			Junit.Framework.Assert.AssertTrue(number  is  Double);
	
			// Even if parseIntegerOnly is set to true, NaN will be parsed to Double
	
			form = (DummyFormat) ILOG.J2CsMapping.Text.NumberFormat.GetInstance(System.Globalization.CultureInfo.CreateSpecificCulture("en-us"));
			form.SetParseIntegerOnly(true);
			NumberFormatInfo symbols = new NumberFormatInfo();
			number = form.Parse(symbols.GetNaN(), new ParsePosition(0));
			Junit.Framework.Assert.AssertTrue(number  is  Double);
	
			// Even if parseIntegerOnly is set to true, Infinity will still be
			// parsed to Double
	
			form = (DummyFormat) ILOG.J2CsMapping.Text.NumberFormat.GetInstance(System.Globalization.CultureInfo.CreateSpecificCulture("en-us"));
			form.SetParseIntegerOnly(true);
			symbols = new NumberFormatInfo();
			number = form.Parse(symbols.GetInfinity(), new ParsePosition(0));
			Junit.Framework.Assert.AssertTrue(number  is  Double);
	
			// ParseBigDecimal take precedence of parseBigInteger
	
			form = (DummyFormat) ILOG.J2CsMapping.Text.NumberFormat.GetInstance(System.Globalization.CultureInfo.CreateSpecificCulture("en-us"));
			form.SetParseIntegerOnly(true);
			form.SetParseBigDecimal(true);
	
			number = form.Parse("23.1f", new ParsePosition(0));
	
			Junit.Framework.Assert.AssertTrue(number  is  Decimal);
	
			number = form.Parse("23.0", new ParsePosition(0));
			Junit.Framework.Assert.AssertTrue(number  is  Decimal);
	
			number = form.Parse("-9,223,372,036,854,775,8080.00",
					new ParsePosition(0));
			Junit.Framework.Assert.AssertFalse(number  is  Int64);
			Junit.Framework.Assert.AssertTrue(number  is  Decimal);
	
			// Test whether the parsed object is of type float. (To be specific,
			// they are of type Double)
	
			form = (DummyFormat) ILOG.J2CsMapping.Text.NumberFormat.GetInstance(System.Globalization.CultureInfo.CreateSpecificCulture("en-us"));
	
			number = form.Parse("23.1f", new ParsePosition(0));
			Junit.Framework.Assert.AssertTrue(number  is  Double);
	
			form.SetParseBigDecimal(true);
			number = form.Parse("23.1f", new ParsePosition(0));
			Junit.Framework.Assert.AssertTrue(number  is  Decimal);
			Junit.Framework.Assert.AssertEquals(Decimal.Parse("23.1"), number);
	
			// Integer will be parsed to Long, unless parseBigDecimal is set to true
	
			form = (DummyFormat) ILOG.J2CsMapping.Text.NumberFormat.GetInstance(System.Globalization.CultureInfo.CreateSpecificCulture("en-us"));
	
			number = form.Parse("123", new ParsePosition(0));
			Junit.Framework.Assert.AssertTrue(number  is  Int64);
	
			form.SetParseBigDecimal(true);
			number = form.Parse("123", new ParsePosition(0));
			Junit.Framework.Assert.AssertTrue(number  is  Decimal);
			Junit.Framework.Assert.AssertEquals(Decimal.Parse("123"), number);
	
			// NaN will be parsed to Double, no matter parseBigDecimal set or not.
	
			form = (DummyFormat) ILOG.J2CsMapping.Text.NumberFormat.GetInstance(System.Globalization.CultureInfo.CreateSpecificCulture("en-us"));
			symbols = new NumberFormatInfo();
			number = form.Parse(symbols.GetNaN() + "", new ParsePosition(0));
			Junit.Framework.Assert.AssertTrue(number  is  Double);
	
			form.SetParseBigDecimal(true);
			number = form.Parse(symbols.GetNaN() + "", new ParsePosition(0));
			Junit.Framework.Assert.AssertTrue(number  is  Double);
	
			// Infinity will be parsed to Double, no matter parseBigDecimal set or
			// not.
	
			form = (DummyFormat) ILOG.J2CsMapping.Text.NumberFormat.GetInstance(System.Globalization.CultureInfo.CreateSpecificCulture("en-us"));
			symbols = new NumberFormatInfo();
	
			number = form.Parse(symbols.GetInfinity(), new ParsePosition(0));
	
			Junit.Framework.Assert.AssertTrue(number  is  Double);
			Junit.Framework.Assert.AssertEquals("Infinity", number.ToString());
			// When set bigDecimal to true, the result of parsing infinity
	
			form = (DummyFormat) ILOG.J2CsMapping.Text.NumberFormat.GetInstance(System.Globalization.CultureInfo.CreateSpecificCulture("en-us"));
			symbols = new NumberFormatInfo();
			form.SetParseBigDecimal(true);
	
			number = form.Parse(symbols.GetInfinity(), new ParsePosition(0));
			Junit.Framework.Assert.AssertTrue(number  is  Double);
			Junit.Framework.Assert.AssertEquals("Infinity", number.ToString());
	
			// Negative infinity will be parsed to double no matter parseBigDecimal
			// set or not
	
			form = (DummyFormat) ILOG.J2CsMapping.Text.NumberFormat.GetInstance(System.Globalization.CultureInfo.CreateSpecificCulture("en-us"));
			symbols = new NumberFormatInfo();
	
			number = form.Parse("-" + symbols.GetInfinity(), new ParsePosition(0));
	
			Junit.Framework.Assert.AssertTrue(number  is  Double);
			Junit.Framework.Assert.AssertEquals("-Infinity", number.ToString());
	
			// When set bigDecimal to true, the result of parsing minus infinity
	
			form = (DummyFormat) ILOG.J2CsMapping.Text.NumberFormat.GetInstance(System.Globalization.CultureInfo.CreateSpecificCulture("en-us"));
			symbols = new NumberFormatInfo();
			form.SetParseBigDecimal(true);
	
			number = form.Parse("-" + symbols.GetInfinity(), new ParsePosition(0));
	
			Junit.Framework.Assert.AssertTrue(number  is  Double);
			Junit.Framework.Assert.AssertEquals("-Infinity", number.ToString());
	
			// -0.0 will be parsed to different type according to the combination of
			// parseBigDecimal and parseIntegerOnly
	
			form = (DummyFormat) ILOG.J2CsMapping.Text.NumberFormat.GetInstance(System.Globalization.CultureInfo.CreateSpecificCulture("en-us"));
	
			// parseBigDecimal == true;
			// parseIntegerOnly == false;
			form.SetParseBigDecimal(true);
			number = form.Parse("-0", new ParsePosition(0));
			Junit.Framework.Assert.AssertTrue(number  is  Decimal);
	
			number = form.Parse("-0.0", new ParsePosition(0));
			Junit.Framework.Assert.AssertTrue(number  is  Decimal);
	
			// parseBigDecimal == false;
			// parseIntegerOnly == true;
			form.SetParseBigDecimal(false);
			form.SetParseIntegerOnly(true);
			number = form.Parse("-0", new ParsePosition(0));
	
			Junit.Framework.Assert.AssertTrue(number  is  Int64);
	
			number = form.Parse("-0.0", new ParsePosition(0));
			Junit.Framework.Assert.AssertTrue(number  is  Int64);
	
			// parseBigDecimal == false;
			// parseIntegerOnly == false;
			form.SetParseBigDecimal(false);
			form.SetParseIntegerOnly(false);
			number = form.Parse("-0", new ParsePosition(0));
			Junit.Framework.Assert.AssertTrue(number  is  Double);
	
			number = form.Parse("-0.0", new ParsePosition(0));
			Junit.Framework.Assert.AssertTrue(number  is  Double);
	
			// parseBigDecimal == true;
			// parseIntegerOnly == true;
			// parseBigDecimal take precedence of parseBigInteger
			form.SetParseBigDecimal(true);
			form.SetParseIntegerOnly(true);
			number = form.Parse("-0", new ParsePosition(0));
			Junit.Framework.Assert.AssertTrue(number  is  Decimal);
	
			number = form.Parse("-0.0", new ParsePosition(0));
			Junit.Framework.Assert.AssertTrue(number  is  Decimal);
	
			number = form.Parse("12.4", new ParsePosition(0));
			Junit.Framework.Assert.AssertTrue(number  is  Decimal);
	
			// When parseBigDecimal is set to false, no matter how massive the
			// mantissa part of a number is, the number will be parsed into Double
	
			form = (DummyFormat) ILOG.J2CsMapping.Text.NumberFormat.GetInstance(System.Globalization.CultureInfo.CreateSpecificCulture("en-us"));
	
			number = form.Parse("9,223,372,036,854,775,808.00",
					new ParsePosition(0));
	
			Junit.Framework.Assert.AssertTrue(number  is  Double);
			Junit.Framework.Assert.AssertEquals("9.223372036854776E18", number.ToString());
	
			number = form.Parse("-9,223,372,036,854,775,8080.00",
					new ParsePosition(0));
			Junit.Framework.Assert.AssertTrue(number  is  Double);
			Junit.Framework.Assert.AssertEquals("-9.223372036854776E19", number.ToString());
	
			// When parseBigDecimal is set to true, if mantissa part of number
			// exceeds Long.MAX_VALUE, the number will be parsed into BigDecimal
	
			form = (DummyFormat) ILOG.J2CsMapping.Text.NumberFormat.GetInstance(System.Globalization.CultureInfo.CreateSpecificCulture("en-us"));
	
			form.SetParseBigDecimal(true);
			number = form.Parse("9,223,372,036,854,775,808.00",
					new ParsePosition(0));
	
			Junit.Framework.Assert.AssertTrue(number  is  Decimal);
	
			Junit.Framework.Assert.AssertEquals(9.223372036854776E18d, Convert.ToDouble(number), 0);
	
			number = form.Parse("-9,223,372,036,854,775,8080.00",
					new ParsePosition(0));
	
			Junit.Framework.Assert.AssertTrue(number  is  Decimal);
			Junit.Framework.Assert.AssertEquals(-9.223372036854776E19d, Convert.ToDouble(number), 0);
	
			// The minimum value of Long will be parsed to Long when parseBigDecimal
			// is not set
	
			ParsePosition pos = new ParsePosition(0);
			DummyFormat df = new DummyFormat();
			pos = new ParsePosition(0);
			object nb = df.Parse("" + Int64.MinValue, pos);
			Junit.Framework.Assert.AssertTrue(nb  is  Int64);
	
			// The maximum value of Long will be parsed to Long when parseBigDecimal
			// is set
			pos = new ParsePosition(0);
			df = new DummyFormat();
			pos = new ParsePosition(0);
			nb = df.Parse("" + Int64.MaxValue, pos);
			Junit.Framework.Assert.AssertTrue(nb  is  Int64);
	
			// When parsing invalid string( which is neither consist of digits nor
			// NaN/Infinity), a null will be returned.
	
			pos = new ParsePosition(0);
			df = new DummyFormat();
			try {
				nb = df.Parse("invalid", pos);
				Junit.Framework.Assert.AssertNull(nb);
			} catch (NullReferenceException e) {
				Junit.Framework.Assert.Fail("Should not throw NPE");
			}
		}
	
		[NUnit.Framework.Test]
		public void Test_getMaximumFractionDigits() {
			NumberFormat nform = ILOG.J2CsMapping.Text.NumberFormat.GetInstance(System.Globalization.CultureInfo.CreateSpecificCulture("en-us"));
			DummyFormat form = (DummyFormat) nform;
	
			// getMaximumFractionDigits of NumberFormat default to 3
			// getMaximumFractionDigits of DecimalFormat default to 3
			Junit.Framework.Assert.AssertEquals(3, nform.GetMaximumFractionDigits());
			Junit.Framework.Assert.AssertEquals(3, form.GetMaximumFractionDigits());
	
			// Greater than 340 (critical number used to distinguish
			// BigInteger and BigDecimal)
			nform.SetMaximumFractionDigits(500);
			Junit.Framework.Assert.AssertEquals(500, nform.GetMaximumFractionDigits());
			Junit.Framework.Assert.AssertEquals(500, form.GetMaximumFractionDigits());
	
			form.SetMaximumFractionDigits(500);
			Junit.Framework.Assert.AssertEquals(500, nform.GetMaximumFractionDigits());
			Junit.Framework.Assert.AssertEquals(500, form.GetMaximumFractionDigits());
	
			form.Format(12.3d);
			Junit.Framework.Assert.AssertEquals(500, nform.GetMaximumFractionDigits());
			Junit.Framework.Assert.AssertEquals(500, form.GetMaximumFractionDigits());
		}
	
		[NUnit.Framework.Test]
		public void Test_getMinimumFractionDigits() {
			NumberFormat nform = ILOG.J2CsMapping.Text.NumberFormat.GetInstance(System.Globalization.CultureInfo.CreateSpecificCulture("en-us"));
			DummyFormat form = (DummyFormat) nform;
	
			// getMinimumFractionDigits from NumberFormat (default to 0)
			// getMinimumFractionDigits from DecimalFormat (default to 0)
			Junit.Framework.Assert.AssertEquals(0, nform.GetMinimumFractionDigits());
			Junit.Framework.Assert.AssertEquals(0, form.GetMinimumFractionDigits());
	
			// Greater than 340 (critical number used to distinguish
			// BigInteger and BigDecimal)
			nform.SetMinimumFractionDigits(500);
			Junit.Framework.Assert.AssertEquals(500, nform.GetMinimumFractionDigits());
			Junit.Framework.Assert.AssertEquals(500, form.GetMinimumFractionDigits());
	
			form.SetMaximumFractionDigits(400);
			Junit.Framework.Assert.AssertEquals(400, nform.GetMinimumFractionDigits());
			Junit.Framework.Assert.AssertEquals(400, form.GetMinimumFractionDigits());
		}
	
		//FIXME This test fails on Harmony ClassLibrary
		[NUnit.Framework.Test]
		public void Test_getMaximumIntegerDigits() {
			int maxIntDigit = 309;
	
			// When use default locale, in this case zh_CN
			// the returned instance of NumberFormat is a DecimalFormat
			DummyFormat form = new DummyFormat("00.###E0");
			Junit.Framework.Assert.AssertEquals(2, form.GetMaximumIntegerDigits());
	
			NumberFormat nform = ILOG.J2CsMapping.Text.NumberFormat.GetInstance(System.Globalization.CultureInfo.CreateSpecificCulture("en-us"));
			form = null;
			if (nform  is  DummyFormat) {
				form = (DummyFormat) nform;
			}
	
			// Greater than 309 (critical number used to distinguish
			// BigInteger and BigDecimal)
			nform.SetMaximumIntegerDigits(500);
			Junit.Framework.Assert.AssertEquals(500, nform.GetMaximumIntegerDigits());
			Junit.Framework.Assert.AssertEquals(500, form.GetMaximumIntegerDigits());
	
			form = new DummyFormat("00.###E0");
			Junit.Framework.Assert.AssertEquals(2, form.GetMaximumIntegerDigits());
	
			form.SetMaximumIntegerDigits(500);
			Junit.Framework.Assert.AssertEquals(500, nform.GetMaximumIntegerDigits());
			Junit.Framework.Assert.AssertEquals(500, form.GetMaximumIntegerDigits());
			form.Format(12.3d);
			Junit.Framework.Assert.AssertEquals(500, nform.GetMaximumIntegerDigits());
			Junit.Framework.Assert.AssertEquals(500, form.GetMaximumIntegerDigits());
	
			nform = ILOG.J2CsMapping.Text.NumberFormat.GetInstance(System.Globalization.CultureInfo.CreateSpecificCulture("en-us"));
			form = null;
			if (nform  is  DummyFormat) {
				form = (DummyFormat) nform;
			}
			// getMaximumIntegerDigits from NumberFormat default to 309
			// getMaximumIntegerDigits from DecimalFormat default to 309
			// the following 2 assertions will fail on RI implementation, since the
			// implementation of ICU and RI are not identical. RI does not give
			// DecimalFormat an initial bound about its maximumIntegerDigits
			// (default to Integer.MAX_VALUE: 2147483647 )
			Junit.Framework.Assert.AssertEquals(maxIntDigit, nform.GetMaximumIntegerDigits());
			Junit.Framework.Assert.AssertEquals(maxIntDigit, form.GetMaximumIntegerDigits());
	
			// regression test for HARMONY-878
			Junit.Framework.Assert.AssertTrue(new DummyFormat("0\t0").GetMaximumIntegerDigits() > 0);
		}
	
		[NUnit.Framework.Test]
		public void Test_getMinimumIntegerDigits() {
			int minIntDigit = 1;
			NumberFormat nform = ILOG.J2CsMapping.Text.NumberFormat.GetInstance(System.Globalization.CultureInfo.CreateSpecificCulture("en-us"));
			DummyFormat form = (DummyFormat) nform;
	
			// getMaximumIntegerDigits from NumberFormat (default to 1)
			// getMaximumIntegerDigits from DecimalFormat (default to 1)
			Junit.Framework.Assert.AssertEquals(minIntDigit, nform.GetMinimumIntegerDigits());
			Junit.Framework.Assert.AssertEquals(minIntDigit, form.GetMinimumIntegerDigits());
	
			// Greater than 309 (critical number used to distinguish
			// BigInteger and BigDecimal)
			nform.SetMinimumIntegerDigits(500);
			Junit.Framework.Assert.AssertEquals(500, nform.GetMinimumIntegerDigits());
			Junit.Framework.Assert.AssertEquals(500, form.GetMinimumIntegerDigits());
	
			form.SetMaximumIntegerDigits(400);
			Junit.Framework.Assert.AssertEquals(400, nform.GetMinimumIntegerDigits());
			Junit.Framework.Assert.AssertEquals(400, form.GetMinimumIntegerDigits());
	
		}
	
		[NUnit.Framework.Test]
		public void Test_formatLjava_lang_Obj_Ljava_StringBuffer_Ljava_text_FieldPosition() {
			NumberFormat nform = ILOG.J2CsMapping.Text.NumberFormat.GetInstance(System.Globalization.CultureInfo.CreateSpecificCulture("en-us"));
			DummyFormat form = (DummyFormat) nform;
	
			// If Object(including null) is not of type Number,
			// IllegalArgumentException will be thrown out
			try {
				form.Format(new Object(), new StringBuilder(), new FieldPosition(0));
				Junit.Framework.Assert.Fail("Should throw IAE");
			} catch (ArgumentException e) {
				// expected
			}
			try {
				form.Format(null, new StringBuilder(), new FieldPosition(0));
				Junit.Framework.Assert.Fail("Should throw IAE");
			} catch (ArgumentException e_0) {
				// expected
			}
	
			// When StringBuffer == null || FieldPosition == null
			// NullPointerException will be thrown out.
			try {
				form.Format((double )(1.9d), null, new FieldPosition(0));
				Junit.Framework.Assert.Fail("Should throw NPE");
			} catch (NullReferenceException e_1) {
				// expected
			}
	
			try {
				form.Format((double )(1.3d), new StringBuilder(), null);
				Junit.Framework.Assert.Fail("Should throw NPE");
			} catch (NullReferenceException e_2) {
				// expected
			}
	
			try {
				form.Format((double )(1.4d), null, null);
				Junit.Framework.Assert.Fail("Should throw NPE");
			} catch (NullReferenceException e_3) {
				// expected
			}
	
			try {
				form.Format(new Object(), null, null);
				Junit.Framework.Assert.Fail("Should throw IllegalArgumentException");
			} catch (ArgumentException e_4) {
				// expected
			}
	
			FieldPosition pos;
			StringBuilder xout;
			DummyFormat format = (DummyFormat) ILOG.J2CsMapping.Text.NumberFormat
					.GetInstance(System.Globalization.CultureInfo.CreateSpecificCulture("en-us"));
	
			// format maxLong
			pos = new FieldPosition(0);
			xout = format.Format((long )(Int64.MaxValue), new StringBuilder(), pos);
			Junit.Framework.Assert.AssertTrue("Wrong result L1: " + xout, xout.ToString().Equals(
					"9,223,372,036,854,775,807"));
	
			// format minLong
			pos = new FieldPosition(0);
			xout = format.Format((long )(Int64.MinValue), new StringBuilder(), pos);
			Junit.Framework.Assert.AssertTrue("Wrong result L2: " + xout, xout.ToString().Equals(
					"-9,223,372,036,854,775,808"));
	
			// format maxLong of type BigInteger
			pos = new FieldPosition(0);
			xout = format.Format(Int64.Parse(Int64.MaxValue.ToString()), new StringBuilder(), pos);
			Junit.Framework.Assert.AssertTrue("Wrong result BI1: " + xout, xout.ToString().Equals(
					"9,223,372,036,854,775,807"));
	
			// format minLong of type BigInteger
			pos = new FieldPosition(0);
			xout = format.Format(Int64.Parse(Int64.MinValue.ToString()), new StringBuilder(), pos);
			Junit.Framework.Assert.AssertTrue("Wrong result BI2: " + xout, xout.ToString().Equals(
					"-9,223,372,036,854,775,808"));
	
			// format maxLong + 1
			Int64 big;
			pos = new FieldPosition(0);
			big = Int64.Parse(Int64.MaxValue.ToString())
					.Add(Int64.Parse("1"));
			xout = format.Format(big, new StringBuilder(), pos);
			Junit.Framework.Assert.AssertTrue("Wrong result BI3: " + xout, xout.ToString().Equals(
					"9,223,372,036,854,775,808"));
	
			// format minLong - 1
			pos = new FieldPosition(0);
			big = Int64.Parse(Int64.MinValue.ToString())
					.Add(Int64.Parse("-1"));
			xout = format.Format(big, new StringBuilder(), pos);
			Junit.Framework.Assert.AssertTrue("Wrong result BI4: " + xout, xout.ToString().Equals(
					"-9,223,372,036,854,775,809"));
	
			// format big decimal
			pos = new FieldPosition(0);
			xout = format.Format(Decimal.Parse("51.348"),
					new StringBuilder(), pos);
			Junit.Framework.Assert.AssertTrue("Wrong result BD1: " + xout, xout.ToString().Equals("51.348"));
	
			// format big decimal
			pos = new FieldPosition(0);
			xout = format.Format(Decimal.Parse("51"), new StringBuilder(),
					pos);
			Junit.Framework.Assert.AssertTrue("Wrong result BD2: " + xout, xout.ToString().Equals("51"));
	
			// format big decimal Double.MAX_VALUE * 2
			Decimal bigDecimal;
			pos = new FieldPosition(0);
			String doubleMax2 = "359,538,626,972,463,141,629,054,847,463,408,"
					+ "713,596,141,135,051,689,993,197,834,953,606,314,521,560,057,077,"
					+ "521,179,117,265,533,756,343,080,917,907,028,764,928,468,642,653,"
					+ "778,928,365,536,935,093,407,075,033,972,099,821,153,102,564,152,"
					+ "490,980,180,778,657,888,151,737,016,910,267,884,609,166,473,806,"
					+ "445,896,331,617,118,664,246,696,549,595,652,408,289,446,337,476,"
					+ "354,361,838,599,762,500,808,052,368,249,716,736";
			bigDecimal = new Decimal(System.Double.MaxValue).Add(new Decimal(
					System.Double.MaxValue));
			xout = format.Format(bigDecimal, new StringBuilder(), pos);
			Junit.Framework.Assert.AssertTrue("Wrong result BDmax2: " + xout, xout.ToString().Equals(
					doubleMax2));
	
			// format big decimal Double.MIN_VALUE + Double.MIN_VALUE
			// and Double.MIN_VALUE - Double.MIN_VALUE
			pos = new FieldPosition(0);
	
			bigDecimal = new Decimal(System.Double.MinValue).Add(new Decimal(
					System.Double.MinValue));
			xout = format.Format(bigDecimal, new StringBuilder(), pos);
	
			bigDecimal = new Decimal(System.Single.MaxValue).Add(new Decimal(
					System.Single.MaxValue));
			xout = format.Format(bigDecimal, new StringBuilder(), pos);
			String BDFloatMax2 = "680,564,693,277,057,719,623,408,366,969,033,850,880";
			Junit.Framework.Assert.AssertTrue("Wrong result BDFloatMax2: " + xout, xout.ToString().Equals(
					BDFloatMax2));
			// format big decimal Float.MIN_VALUE + Float.MIN_VALUE
			// and Float.MIN_VALUE - Float.MIN_VALUE
			bigDecimal = new Decimal(System.Single.MinValue).Add(new Decimal(
					System.Single.MinValue));
			xout = format.Format(bigDecimal, new StringBuilder(), pos);
			String BDFloatMin2 = "0";
	
			bigDecimal = new Decimal(System.Single.MinValue).Subtract(new Decimal(
					System.Single.MinValue));
			xout = format.Format(bigDecimal, new StringBuilder(), pos);
	
			Junit.Framework.Assert.AssertTrue("Wrong result BDFloatMax2: " + xout, xout.ToString().Equals(
					BDFloatMin2));
	
		}
	
		[NUnit.Framework.Test]
		public void Test_setMaximumFractionDigitsLjava_lang_Integer() {
			NumberFormat nform = ILOG.J2CsMapping.Text.NumberFormat.GetInstance(System.Globalization.CultureInfo.CreateSpecificCulture("en-us"));
			DummyFormat form = (DummyFormat) nform;
	
			form.SetMaximumFractionDigits(-2);
			Junit.Framework.Assert.AssertEquals(0, form.GetMaximumFractionDigits());
	
			form.SetMaximumFractionDigits(341);
			Junit.Framework.Assert.AssertEquals(341, form.GetMaximumFractionDigits());
		}
	
		[NUnit.Framework.Test]
		public void Test_setMinimumFractionDigitsLjava_lang_Integer() {
			NumberFormat nform = ILOG.J2CsMapping.Text.NumberFormat.GetInstance(System.Globalization.CultureInfo.CreateSpecificCulture("en-us"));
			DummyFormat form = (DummyFormat) nform;
	
			form.SetMinimumFractionDigits(-3);
			Junit.Framework.Assert.AssertEquals(0, form.GetMinimumFractionDigits());
	
			form.SetMinimumFractionDigits(310);
			Junit.Framework.Assert.AssertEquals(310, form.GetMinimumFractionDigits());
		}
	
		[NUnit.Framework.Test]
		public void Test_setMaximumIntegerDigitsLjava_lang_Integer() {
			NumberFormat nform = ILOG.J2CsMapping.Text.NumberFormat.GetInstance(System.Globalization.CultureInfo.CreateSpecificCulture("en-us"));
			DummyFormat form = (DummyFormat) nform;
	
			form.SetMaximumIntegerDigits(-3);
			Junit.Framework.Assert.AssertEquals(0, form.GetMaximumIntegerDigits());
	
			form.SetMaximumIntegerDigits(310);
			Junit.Framework.Assert.AssertEquals(310, form.GetMaximumIntegerDigits());
		}
	
		[NUnit.Framework.Test]
		public void Test_setMinimumIntegerDigitsLjava_lang_Integer() {
			NumberFormat nform = ILOG.J2CsMapping.Text.NumberFormat.GetInstance(System.Globalization.CultureInfo.CreateSpecificCulture("en-us"));
			DummyFormat form = (DummyFormat) nform;
	
			form.SetMinimumIntegerDigits(-3);
			Junit.Framework.Assert.AssertEquals(0, form.GetMinimumIntegerDigits());
	
			form.SetMinimumIntegerDigits(310);
			Junit.Framework.Assert.AssertEquals(310, form.GetMinimumIntegerDigits());
		}
	
		// When MaxFractionDigits is set first and less than MinFractionDigits, max
		// will be changed to min value
		[NUnit.Framework.Test]
		public void Test_setMinimumFactionDigitsLjava_lang_Integer_setMaximumFractionDigitsLjava_lang_Integer() {
			NumberFormat nform = ILOG.J2CsMapping.Text.NumberFormat.GetInstance(System.Globalization.CultureInfo.CreateSpecificCulture("en-us"));
			DummyFormat form = (DummyFormat) nform;
	
			form.SetMaximumFractionDigits(100);
			form.SetMinimumFractionDigits(200);
	
			Junit.Framework.Assert.AssertEquals(200, form.GetMaximumFractionDigits());
			Junit.Framework.Assert.AssertEquals(200, form.GetMinimumFractionDigits());
	
			form.SetMaximumIntegerDigits(100);
			form.SetMinimumIntegerDigits(200);
	
			Junit.Framework.Assert.AssertEquals(200, form.GetMaximumIntegerDigits());
			Junit.Framework.Assert.AssertEquals(200, form.GetMinimumIntegerDigits());
		}
	
		// When MinFractionDigits is set first and less than MaxFractionDigits, min
		// will be changed to max value
		[NUnit.Framework.Test]
		public void Test_setMaximumFactionDigitsLjava_lang_Integer_setMinimumFractionDigitsLjava_lang_Integer() {
			NumberFormat nform = ILOG.J2CsMapping.Text.NumberFormat.GetInstance(System.Globalization.CultureInfo.CreateSpecificCulture("en-us"));
			DummyFormat form = (DummyFormat) nform;
	
			form.SetMinimumFractionDigits(200);
			form.SetMaximumFractionDigits(100);
	
			Junit.Framework.Assert.AssertEquals(100, form.GetMaximumFractionDigits());
			Junit.Framework.Assert.AssertEquals(100, form.GetMinimumFractionDigits());
	
			form.SetMinimumIntegerDigits(200);
			form.SetMaximumIntegerDigits(100);
	
			Junit.Framework.Assert.AssertEquals(100, form.GetMaximumIntegerDigits());
			Junit.Framework.Assert.AssertEquals(100, form.GetMinimumIntegerDigits());
		}
	
		[NUnit.Framework.Test]
		public void Test_equalsLjava_lang_Object() {
			DummyFormat format = (DummyFormat) ILOG.J2CsMapping.Text.NumberFormat
					.GetInstance(System.Globalization.CultureInfo.CreateSpecificCulture("en-us"));
			DummyFormat cloned = (DummyFormat) format.Clone();
			cloned.SetDecimalFormatSymbols(NumberFormatInfo.GetInstance(System.Globalization.CultureInfo.CreateSpecificCulture("en-us")));
			Junit.Framework.Assert.AssertEquals(format, cloned);
	
			Currency c = System.Collections.Currency.GetInstance(System.Globalization.CultureInfo.CreateSpecificCulture("en-us"));
			cloned.SetCurrency(c);
	
			Junit.Framework.Assert.AssertEquals(format, cloned);
		}
	
		[NUnit.Framework.Test]
		public void Test_setPositivePrefixLjava_lang_String() {
			DummyFormat format = new DummyFormat();
			Junit.Framework.Assert.AssertEquals("", format.GetPositivePrefix());
		}
	
		[NUnit.Framework.Test]
		public void Test_setPositiveSuffixLjava_lang_String() {
			DummyFormat format = new DummyFormat();
			Junit.Framework.Assert.AssertEquals("", format.GetPositiveSuffix());
		}
	
		[NUnit.Framework.Test]
		public void Test_setNegativePrefixLjava_lang_String() {
			DummyFormat format = new DummyFormat();
			Junit.Framework.Assert.AssertEquals("-", format.GetNegativePrefix());
		}
	
		[NUnit.Framework.Test]
		public void Test_setNegativeSuffixLjava_lang_String() {
			DummyFormat format = new DummyFormat();
			Junit.Framework.Assert.AssertEquals("", format.GetNegativeSuffix());
		}
	
		[NUnit.Framework.Test]
		public void Test_setGroupingUse() {
			DummyFormat format = new DummyFormat();
			StringBuilder buf = new StringBuilder();
			format.SetGroupingUsed(false);
			format.Format((long )(1970), buf, new FieldPosition(0));
			Junit.Framework.Assert.AssertEquals("1970", buf.ToString());
			Junit.Framework.Assert.AssertFalse(format.IsGroupingUsed());
		}
	
		
		/// @tests java.text.DecimalFormat#DecimalFormat(java.lang.String)
		[NUnit.Framework.Test]
		public void Test_ConstructorLjava_lang_String() {
			// Test for method java.text.DecimalFormat(java.lang.String)
			// the constructor form that specifies a pattern is equal to the form
			// constructed with no pattern and applying that pattern using the
			// applyPattern call
			DummyFormat format = new DummyFormat("'$'0000.0000");
			DummyFormat format1 = new DummyFormat();
			format1.ApplyPattern("'$'0000.0000");
			Junit.Framework.Assert.AssertTrue("Constructed format did not match applied format object",
					format.Equals(format1));
		}
	
		
		/// @tests java.text.DecimalFormat#applyPattern(java.lang.String)
		[NUnit.Framework.Test]
		public void Test_applyPatternLjava_lang_String() {
			DummyFormat format = new DummyFormat("#.#");
			Junit.Framework.Assert.AssertEquals("Wrong pattern 1", "#0.#", format.ToPattern());
			format = new DummyFormat("#.");
			Junit.Framework.Assert.AssertEquals("Wrong pattern 2", "#0.", format.ToPattern());
			format = new DummyFormat("#");
			Junit.Framework.Assert.AssertEquals("Wrong pattern 3", "#", format.ToPattern());
			format = new DummyFormat(".#");
			Junit.Framework.Assert.AssertEquals("Wrong pattern 4", "#.0", format.ToPattern());
		}
	
		
		/// @tests java.text.DecimalFormat#clone()
		[NUnit.Framework.Test]
		public void Test_clone() {
			DummyFormat format = (DummyFormat) ILOG.J2CsMapping.Text.NumberFormat
					.GetInstance(System.Globalization.CultureInfo.CreateSpecificCulture("en-us"));
			DummyFormat cloned = (DummyFormat) format.Clone();
			Junit.Framework.Assert.AssertEquals(cloned.GetDecimalFormatSymbols(), format
					.GetDecimalFormatSymbols());
	
			format = new DummyFormat("'$'0000.0000");
			DummyFormat format1 = (DummyFormat) (format.Clone());
			// make sure the objects are equal
			Junit.Framework.Assert.AssertTrue("Object's clone isn't equal!", format.Equals(format1));
			// change the content of the clone and make sure it's not equal anymore
			// verifies that it's data is now distinct from the original
			format1.ApplyPattern("'$'0000.####");
			Junit.Framework.Assert.AssertTrue("Object's changed clone should not be equal!", !format
					.Equals(format1));
		}
	
		private void Compare(String testName, String format, String expected) {
			Junit.Framework.Assert.AssertTrue(testName + " got: " + format + " expected: " + expected,
					format.Equals(expected));
		}
	
		private bool Compare(int count, String format, String expected) {
			bool result = format.Equals(expected);
			if (!result)
				System.Console.Out.WriteLine("Failure test: " + count + " got: " + format
						+ " expected: " + expected);
			return result;
		}
	
		/**
		 * @tests java.text.DecimalFormat#format(double, java.lang.StringBuffer,
		 *        java.text.FieldPosition)
		 */
		//FIXME This test fails on Harmony ClassLibrary
		/*public void test_formatDLjava_lang_StringBufferLjava_text_FieldPosition() {
		    new Support_DecimalFormat(
		            "test_formatDLjava_lang_StringBufferLjava_text_FieldPosition")
		            .t_format_with_FieldPosition();
	
		    int failCount = 0;
		    Support_BitSet failures = new Support_BitSet();
	
		    final DecimalFormatSymbols dfs = new DecimalFormatSymbols(Locale.US);
	
		    DecimalFormat df = new DecimalFormat("00.0#E0", dfs);
		    compare("00.0#E0: 0.0", df.format(0.0), "00.0E0");
		    compare("00.0#E0: 1.0", df.format(1.0), "10.0E-1");
		    compare("00.0#E0: 12.0", df.format(12.0), "12.0E0");
		    compare("00.0#E0: 123.0", df.format(123.0), "12.3E1");
		    compare("00.0#E0: 1234.0", df.format(1234.0), "12.34E2");
		    compare("00.0#E0: 12346.0", df.format(12346.0), "12.35E3");
		    compare("00.0#E0: 99999.0", df.format(99999.0), "10.0E4");
		    compare("00.0#E0: 1.2", df.format(1.2), "12.0E-1");
		    compare("00.0#E0: 12.3", df.format(12.3), "12.3E0");
		    compare("00.0#E0: 123.4", df.format(123.4), "12.34E1");
		    compare("00.0#E0: 1234.6", df.format(1234.6), "12.35E2");
		    compare("00.0#E0: 9999.9", df.format(9999.9), "10.0E3");
		    compare("00.0#E0: 0.1", df.format(0.1), "10.0E-2");
		    compare("00.0#E0: 0.12", df.format(0.12), "12.0E-2");
		    compare("00.0#E0: 0.123", df.format(0.123), "12.3E-2");
		    compare("00.0#E0: 0.1234", df.format(0.1234), "12.34E-2");
		    compare("00.0#E0: 0.12346", df.format(0.12346), "12.35E-2");
		    compare("00.0#E0: 0.99999", df.format(0.99999), "10.0E-1");
		    compare("00.0#E0: -0.0", df.format(-0.0), "-00.0E0");
		    compare("00.0#E0: -1.0", df.format(-1.0), "-10.0E-1");
		    compare("00.0#E0: -12.0", df.format(-12.0), "-12.0E0");
		    compare("00.0#E0: -123.0", df.format(-123.0), "-12.3E1");
		    compare("00.0#E0: -1234.0", df.format(-1234.0), "-12.34E2");
		    compare("00.0#E0: -12346.0", df.format(-12346.0), "-12.35E3");
		    compare("00.0#E0: -99999.0", df.format(-99999.0), "-10.0E4");
	
		    df = new DecimalFormat("##0.0E0", dfs);
		    compare("##0.0E0: -0.0", df.format(-0.0), "-0.0E0");
		    compare("##0.0E0: 0.0", df.format(0.0), "0.0E0");
		    compare("##0.0E0: 1.0", df.format(1.0), "1.0E0");
		    compare("##0.0E0: 12.0", df.format(12.0), "12E0");
		    compare("##0.0E0: 123.0", df.format(123.0), "123E0");
		    compare("##0.0E0: 1234.0", df.format(1234.0), "1.234E3");
		    compare("##0.0E0: 12346.0", df.format(12346.0), "12.35E3");
		    // Fails in JDK 1.2.2
		    if (!compare(failCount, df.format(99999.0), "100E3"))
		        failures.set(failCount);
		    failCount++;
		    compare("##0.0E0: 999999.0", df.format(999999.0), "1.0E6");
	
		    df = new DecimalFormat("#00.0##E0", dfs);
		    compare("#00.0##E0: 0.1", df.format(0.1), ".100E0");
		    compare("#00.0##E0: 0.12", df.format(0.12), ".120E0");
		    compare("#00.0##E0: 0.123", df.format(0.123), ".123E0");
		    compare("#00.0##E0: 0.1234", df.format(0.1234), ".1234E0");
		    compare("#00.0##E0: 0.1234567", df.format(0.1234567), ".123457E0");
		    compare("#00.0##E0: 0.01", df.format(0.01), "10.0E-3");
		    compare("#00.0##E0: 0.012", df.format(0.012), "12.0E-3");
		    compare("#00.0##E0: 0.0123", df.format(0.0123), "12.3E-3");
		    compare("#00.0##E0: 0.01234", df.format(0.01234), "12.34E-3");
		    compare("#00.0##E0: 0.01234567", df.format(0.01234567), "12.3457E-3");
		    compare("#00.0##E0: 0.001", df.format(0.001), "1.00E-3");
		    compare("#00.0##E0: 0.0012", df.format(0.0012), "1.20E-3");
		    compare("#00.0##E0: 0.00123", df.format(0.00123), "1.23E-3");
		    compare("#00.0##E0: 0.001234", df.format(0.001234), "1.234E-3");
		    compare("#00.0##E0: 0.001234567", df.format(0.001234567), "1.23457E-3");
		    compare("#00.0##E0: 0.0001", df.format(0.0001), "100E-6");
		    compare("#00.0##E0: 0.00012", df.format(0.00012), "120E-6");
		    compare("#00.0##E0: 0.000123", df.format(0.000123), "123E-6");
		    compare("#00.0##E0: 0.0001234", df.format(0.0001234), "123.4E-6");
		    compare("#00.0##E0: 0.0001234567", df.format(0.0001234567),
		            "123.457E-6");
	
		    // Fails in JDK 1.2.2
		    if (!compare(failCount, df.format(0.0), "0.00E0"))
		        failures.set(failCount);
		    failCount++;
		    compare("#00.0##E0: 1.0", df.format(1.0), "1.00E0");
		    compare("#00.0##E0: 12.0", df.format(12.0), "12.0E0");
		    compare("#00.0##E0: 123.0", df.format(123.0), "123E0");
		    compare("#00.0##E0: 1234.0", df.format(1234.0), "1.234E3");
		    compare("#00.0##E0: 12345.0", df.format(12345.0), "12.345E3");
		    compare("#00.0##E0: 123456.0", df.format(123456.0), "123.456E3");
		    compare("#00.0##E0: 1234567.0", df.format(1234567.0), "1.23457E6");
		    compare("#00.0##E0: 12345678.0", df.format(12345678.0), "12.3457E6");
		    compare("#00.0##E0: 99999999.0", df.format(99999999.0), "100E6");
	
		    df = new DecimalFormat("#.0E0", dfs);
		    compare("#.0E0: -0.0", df.format(-0.0), "-.0E0");
		    compare("#.0E0: 0.0", df.format(0.0), ".0E0");
		    compare("#.0E0: 1.0", df.format(1.0), ".1E1");
		    compare("#.0E0: 12.0", df.format(12.0), ".12E2");
		    compare("#.0E0: 123.0", df.format(123.0), ".12E3");
		    compare("#.0E0: 1234.0", df.format(1234.0), ".12E4");
		    compare("#.0E0: 9999.0", df.format(9999.0), ".1E5");
	
		    df = new DecimalFormat("0.#E0", dfs);
		    compare("0.#E0: -0.0", df.format(-0.0), "-0E0");
		    compare("0.#E0: 0.0", df.format(0.0), "0E0");
		    compare("0.#E0: 1.0", df.format(1.0), "1E0");
		    compare("0.#E0: 12.0", df.format(12.0), "1.2E1");
		    compare("0.#E0: 123.0", df.format(123.0), "1.2E2");
		    compare("0.#E0: 1234.0", df.format(1234.0), "1.2E3");
		    compare("0.#E0: 9999.0", df.format(9999.0), "1E4");
	
		    df = new DecimalFormat(".0E0", dfs);
		    compare(".0E0: -0.0", df.format(-0.0), "-.0E0");
		    compare(".0E0: 0.0", df.format(0.0), ".0E0");
		    compare(".0E0: 1.0", df.format(1.0), ".1E1");
		    compare(".0E0: 12.0", df.format(12.0), ".1E2");
		    compare(".0E0: 123.0", df.format(123.0), ".1E3");
		    compare(".0E0: 1234.0", df.format(1234.0), ".1E4");
		    compare(".0E0: 9999.0", df.format(9999.0), ".1E5");
	
		    df = new DecimalFormat("0.E0", dfs);
		    // Fails in JDK 1.2.2
		    if (!compare(failCount, df.format(0.0), "0.E0"))
		        failures.set(failCount);
		    failCount++;
		    if (!compare(failCount, df.format(1.0), "1.E0"))
		        failures.set(failCount);
		    failCount++;
		    if (!compare(failCount, df.format(12.0), "1.E1"))
		        failures.set(failCount);
		    failCount++;
		    if (!compare(failCount, df.format(123.0), "1.E2"))
		        failures.set(failCount);
		    failCount++;
		    if (!compare(failCount, df.format(1234.0), "1.E3"))
		        failures.set(failCount);
		    failCount++;
		    if (!compare(failCount, df.format(9999.0), "1.E4"))
		        failures.set(failCount);
		    failCount++;
	
		    df = new DecimalFormat("##0.00#E0", dfs);
		    compare("##0.00#E0: 0.1", df.format(0.1), ".100E0");
		    compare("##0.00#E0: 0.1234567", df.format(0.1234567), ".123457E0");
		    compare("##0.00#E0: 0.9999999", df.format(0.9999999), "1.00E0");
		    compare("##0.00#E0: 0.01", df.format(0.01), "10.0E-3");
		    compare("##0.00#E0: 0.01234567", df.format(0.01234567), "12.3457E-3");
		    compare("##0.00#E0: 0.09999999", df.format(0.09999999), ".100E0");
		    compare("##0.00#E0: 0.001", df.format(0.001), "1.00E-3");
		    compare("##0.00#E0: 0.001234567", df.format(0.001234567), "1.23457E-3");
		    compare("##0.00#E0: 0.009999999", df.format(0.009999999), "10.0E-3");
		    compare("##0.00#E0: 0.0001", df.format(0.0001), "100E-6");
		    compare("##0.00#E0: 0.0001234567", df.format(0.0001234567),
		            "123.457E-6");
		    compare("##0.00#E0: 0.0009999999", df.format(0.0009999999), "1.00E-3");
	
		    df = new DecimalFormat("###0.00#E0", dfs);
		    compare("###0.00#E0: 0.1", df.format(0.1), ".100E0");
		    compare("###0.00#E0: 0.12345678", df.format(0.12345678), ".1234568E0");
		    compare("###0.00#E0: 0.99999999", df.format(0.99999999), "1.00E0");
		    compare("###0.00#E0: 0.01", df.format(0.01), "100E-4");
		    compare("###0.00#E0: 0.012345678", df.format(0.012345678),
		            "123.4568E-4");
		    compare("###0.00#E0: 0.099999999", df.format(0.099999999), ".100E0");
		    compare("###0.00#E0: 0.001", df.format(0.001), "10.0E-4");
		    compare("###0.00#E0: 0.0012345678", df.format(0.0012345678),
		            "12.34568E-4");
		    compare("###0.00#E0: 0.0099999999", df.format(0.0099999999), "100E-4");
		    compare("###0.00#E0: 0.0001", df.format(0.0001), "1.00E-4");
		    compare("###0.00#E0: 0.00012345678", df.format(0.00012345678),
		            "1.234568E-4");
		    compare("###0.00#E0: 0.00099999999", df.format(0.00099999999),
		            "10.0E-4");
		    // Fails in JDK 1.2.2
		    if (!compare(failCount, df.format(0.00001), "1000E-8"))
		        failures.set(failCount);
		    failCount++;
		    compare("###0.00#E0: 0.000012345678", df.format(0.000012345678),
		            "1234.568E-8");
		    compare("###0.00#E0: 0.000099999999", df.format(0.000099999999),
		            "1.00E-4");
	
		    df = new DecimalFormat("###0.0#E0", dfs);
		    compare("###0.0#E0: 0.1", df.format(0.1), ".10E0");
		    compare("###0.0#E0: 0.1234567", df.format(0.1234567), ".123457E0");
		    compare("###0.0#E0: 0.9999999", df.format(0.9999999), "1.0E0");
		    // Fails in JDK 1.2.2
		    if (!compare(failCount, df.format(0.01), "100E-4"))
		        failures.set(failCount);
		    failCount++;
		    compare("###0.0#E0: 0.01234567", df.format(0.01234567), "123.457E-4");
		    compare("###0.0#E0: 0.09999999", df.format(0.09999999), ".10E0");
		    compare("###0.0#E0: 0.001", df.format(0.001), "10E-4");
		    compare("###0.0#E0: 0.001234567", df.format(0.001234567), "12.3457E-4");
		    // Fails in JDK 1.2.2
		    if (!compare(failCount, df.format(0.009999999), "100E-4"))
		        failures.set(failCount);
		    failCount++;
		    compare("###0.0#E0: 0.0001", df.format(0.0001), "1.0E-4");
		    compare("###0.0#E0: 0.0001234567", df.format(0.0001234567),
		            "1.23457E-4");
		    compare("###0.0#E0: 0.0009999999", df.format(0.0009999999), "10E-4");
		    // Fails in JDK 1.2.2
		    if (!compare(failCount, df.format(0.00001), "1000E-8"))
		        failures.set(failCount);
		    failCount++;
		    compare("###0.0#E0: 0.00001234567", df.format(0.00001234567),
		            "1234.57E-8");
		    compare("###0.0#E0: 0.00009999999", df.format(0.00009999999), "1.0E-4");
	
		    assertTrue("Failed " + failures + " of " + failCount,
		            failures.length() == 0);
	
		    String formatString = "##0.#";
		    df = new DecimalFormat(formatString, dfs);
		    df.setMinimumFractionDigits(30);
		    compare(formatString + ": 0.000000000000000000000000000000", df
		            .format(0.0), "0.000000000000000000000000000000");
		    compare(formatString + ": -0.000000000000000000000000000000", df
		            .format(-0.0), "-0.000000000000000000000000000000");
		    compare(formatString + ": 1.000000000000000000000000000000", df
		            .format(1.0), "1.000000000000000000000000000000");
		    compare(formatString + ": -1.000000000000000000000000000000", df
		            .format(-1.0), "-1.000000000000000000000000000000");
	
		    df = new DecimalFormat(formatString);
		    df.setMaximumFractionDigits(30);
		    compare(formatString + ": 0", df.format(0.0), "0");
		    compare(formatString + ": -0", df.format(-0.0), "-0");
		    compare(formatString + ": 1", df.format(1.0), "1");
		    compare(formatString + ": -1", df.format(-1.0), "-1");
		}*/
	
		/**
		 * @tests java.text.DecimalFormat#format(long, java.lang.StringBuffer,
		 *        java.text.FieldPosition)
		 */
		//FIXME This test fails on Harmony ClassLibrary
		/*public void test_formatJLjava_lang_StringBufferLjava_text_FieldPosition() {
		    int failCount = 0;
		    Support_BitSet failures = new Support_BitSet();
	
		    final DecimalFormatSymbols dfs = new DecimalFormatSymbols(Locale.US);
	
		    DecimalFormat df = new DecimalFormat("00.0#E0", dfs);
		    assertEquals("00.0#E0: 0", "00.0E0", df.format(0));
		    assertEquals("00.0#E0: 1", "10.0E-1", df.format(1));
		    assertEquals("00.0#E0: 12", "12.0E0", df.format(12));
		    assertEquals("00.0#E0: 123", "12.3E1", df.format(123));
		    assertEquals("00.0#E0: 1234", "12.34E2", df.format(1234));
		    assertEquals("00.0#E0: 12346", "12.35E3", df.format(12346));
		    assertEquals("00.0#E0: 99999", "10.0E4", df.format(99999));
		    assertEquals("00.0#E0: -1", "-10.0E-1", df.format(-1));
		    assertEquals("00.0#E0: -12", "-12.0E0", df.format(-12));
		    assertEquals("00.0#E0: -123", "-12.3E1", df.format(-123));
		    assertEquals("00.0#E0: -1234", "-12.34E2", df.format(-1234));
		    assertEquals("00.0#E0: -12346", "-12.35E3", df.format(-12346));
		    assertEquals("00.0#E0: -99999", "-10.0E4", df.format(-99999));
	
		    df = new DecimalFormat("##0.0E0", dfs);
		    assertEquals("##0.0E0: 0", "0.0E0", df.format(0));
		    assertEquals("##0.0E0: 1", "1.0E0", df.format(1));
		    assertEquals("##0.0E0: 12", "12E0", df.format(12));
		    assertEquals("##0.0E0: 123", "123E0", df.format(123));
		    assertEquals("##0.0E0: 1234", "1.234E3", df.format(1234));
		    assertEquals("##0.0E0: 12346", "12.35E3", df.format(12346));
		    // Fails in JDK 1.2.2
		    if (!df.format(99999).equals("100E3"))
		        failures.set(failCount);
		    failCount++;
		    assertEquals("##0.0E0: 999999", "1.0E6", df.format(999999));
	
		    df = new DecimalFormat("#00.0##E0", dfs);
		    // Fails in JDK 1.2.2
		    if (!df.format(0).equals("0.00E0"))
		        failures.set(failCount);
		    failCount++;
		    assertEquals("#00.0##E0: 1", "1.00E0", df.format(1));
		    assertEquals("#00.0##E0: 12", "12.0E0", df.format(12));
		    assertEquals("#00.0##E0: 123", "123E0", df.format(123));
		    assertEquals("#00.0##E0: 1234", "1.234E3", df.format(1234));
		    assertEquals("#00.0##E0: 12345", "12.345E3", df.format(12345));
		    assertEquals("#00.0##E0: 123456", "123.456E3", df.format(123456));
		    assertEquals("#00.0##E0: 1234567", "1.23457E6", df.format(1234567));
		    assertEquals("#00.0##E0: 12345678", "12.3457E6", df.format(12345678));
		    assertEquals("#00.0##E0: 99999999", "100E6", df.format(99999999));
	
		    df = new DecimalFormat("#.0E0", dfs);
		    assertEquals("#.0E0: 0", ".0E0", df.format(0));
		    assertEquals("#.0E0: 1", ".1E1", df.format(1));
		    assertEquals("#.0E0: 12", ".12E2", df.format(12));
		    assertEquals("#.0E0: 123", ".12E3", df.format(123));
		    assertEquals("#.0E0: 1234", ".12E4", df.format(1234));
		    assertEquals("#.0E0: 9999", ".1E5", df.format(9999));
	
		    df = new DecimalFormat("0.#E0", dfs);
		    assertEquals("0.#E0: 0", "0E0", df.format(0));
		    assertEquals("0.#E0: 1", "1E0", df.format(1));
		    assertEquals("0.#E0: 12", "1.2E1", df.format(12));
		    assertEquals("0.#E0: 123", "1.2E2", df.format(123));
		    assertEquals("0.#E0: 1234", "1.2E3", df.format(1234));
		    assertEquals("0.#E0: 9999", "1E4", df.format(9999));
	
		    assertTrue("Failed " + failures + " of " + failCount,
		            failures.length() == 0);
		}*/
	
		/**
		 * @tests java.text.DecimalFormat#formatToCharacterIterator(java.lang.Object)
		 */
		//FIXME This test fails on Harmony ClassLibrary
		/*public void test_formatToCharacterIteratorLjava_lang_Object() {
	
		    try {
		        // Regression for HARMONY-466
		        new DecimalFormat().formatToCharacterIterator(null);
		        fail("NullPointerException expected");
		    } catch (NullPointerException e) {
		        // expected
		    }
	
		    new Support_DecimalFormat(
		            "test_formatToCharacterIteratorLjava_lang_Object")
		            .t_formatToCharacterIterator();
		}*
	
		
		/// @tests java.text.DecimalFormat#format(double)
		[NUnit.Framework.Test]
		public void Test_formatD() {
			DummyFormat format = (DummyFormat) ILOG.J2CsMapping.Text.NumberFormat
					.GetInstance(System.Globalization.CultureInfo.CreateSpecificCulture("en"));
			format.SetGroupingUsed(false);
			format.SetMaximumFractionDigits(400);
			for (int i = 0; i < 309; i++) {
				String tval = "1";
				for (int j = 0; j < i; j++)
					tval += "0";
				double d = ((Double )Double.Parse(tval,ILOG.J2CsMapping.Util.NumberFormatProvider.NumberFormat));
				String result = format.Format(d);
				Junit.Framework.Assert.AssertEquals(i + ") e:" + tval + " r:" + result, tval, result);
			}
			for (int i_0 = 0; i_0 < 322; i_0++) {
				String tval_1 = "0.";
				for (int j_2 = 0; j_2 < i_0; j_2++)
					tval_1 += "0";
				tval_1 += "1";
				double d_3 = ((Double )Double.Parse(tval_1,ILOG.J2CsMapping.Util.NumberFormatProvider.NumberFormat));
				String result_4 = format.Format(d_3);
				Junit.Framework.Assert.AssertEquals(i_0 + ") e:" + tval_1 + " r:" + result_4, tval_1, result_4);
			}
			Junit.Framework.Assert.AssertEquals("999999999999999", format.Format(999999999999999.0));
			Junit.Framework.Assert.AssertEquals("1", "999999999999999.9", format.Format(999999999999999.9d));
			Junit.Framework.Assert.AssertEquals("2", "99999999999999.98", format.Format(99999999999999.99d));
			Junit.Framework.Assert.AssertEquals("3", "9999999999999.998", format.Format(9999999999999.999d));
			Junit.Framework.Assert.AssertEquals("4", "999999999999.9999", format.Format(999999999999.9999d));
			Junit.Framework.Assert.AssertEquals("5", "99999999999.99998", format.Format(99999999999.99999d));
			Junit.Framework.Assert.AssertEquals("6", "9999999999.999998", format.Format(9999999999.999999d));
			Junit.Framework.Assert.AssertEquals("7", "999999999.9999999", format.Format(999999999.9999999d));
			Junit.Framework.Assert.AssertEquals("8", "99999999.99999999", format.Format(99999999.99999999d));
			Junit.Framework.Assert.AssertEquals("9", "9999999.999999998", format.Format(9999999.999999999d));
			Junit.Framework.Assert.AssertEquals("10", "99999.99999999999", format
					.Format(99999.99999999999d));
			Junit.Framework.Assert.AssertEquals("11", "9999.999999999998", format
					.Format(9999.999999999999d));
			Junit.Framework.Assert.AssertEquals("12", "999.9999999999999", format
					.Format(999.9999999999999d));
			Junit.Framework.Assert.AssertEquals("13", "99.99999999999999", format
					.Format(99.99999999999999d));
			Junit.Framework.Assert.AssertEquals("14", "9.999999999999998", format
					.Format(9.999999999999999d));
			Junit.Framework.Assert.AssertEquals("15", "0.9999999999999999", format
					.Format(.9999999999999999d));
		}
	
		
		/// @tests java.text.DecimalFormat#getDecimalFormatSymbols()
		[NUnit.Framework.Test]
		public void Test_getDecimalFormatSymbols() {
			DummyFormat df = (DummyFormat) ILOG.J2CsMapping.Text.NumberFormat
					.GetInstance(System.Globalization.CultureInfo.CreateSpecificCulture("en"));
			NumberFormatInfo dfs = df.GetDecimalFormatSymbols();
			Junit.Framework.Assert.AssertTrue("Identical symbols", dfs != df.GetDecimalFormatSymbols());
		}
	
		
		/// @tests java.text.DecimalFormat#getCurrency()
		//FIXME This test fails on Harmony ClassLibrary
		[NUnit.Framework.Test]
		public void Test_getCurrency() {
			Currency currK = System.Collections.Currency.GetInstance("KRW");
			Currency currX = System.Collections.Currency.GetInstance("XXX");
			Currency currE = System.Collections.Currency.GetInstance("EUR");
			Currency curr01;
	
			DummyFormat df = (DummyFormat) ILOG.J2CsMapping.Text.NumberFormat
					.GetCurrencyInstance(ILOG.J2CsMapping.Util.Culture.CultureInfoHelper.CreateCultureInfo("ko","KR"));
			Junit.Framework.Assert.AssertTrue("Test1: Returned incorrect currency",
					df.GetCurrency() == currK);
	
			df = (DummyFormat) ILOG.J2CsMapping.Text.NumberFormat.GetCurrencyInstance(ILOG.J2CsMapping.Util.Culture.CultureInfoHelper.CreateCultureInfo("","KR"));
			Junit.Framework.Assert.AssertTrue("Test2: Returned incorrect currency",
					df.GetCurrency() == currK);
	
			df = (DummyFormat) ILOG.J2CsMapping.Text.NumberFormat.GetCurrencyInstance(ILOG.J2CsMapping.Util.Culture.CultureInfoHelper.CreateCultureInfo("ko",""));
			Junit.Framework.Assert.AssertTrue("Test3: Returned incorrect currency",
					df.GetCurrency() == currX);
	
			df = (DummyFormat) ILOG.J2CsMapping.Text.NumberFormat.GetCurrencyInstance(ILOG.J2CsMapping.Util.Culture.CultureInfoHelper.CreateCultureInfo("fr","FR"));
			Junit.Framework.Assert.AssertTrue("Test4: Returned incorrect currency",
					df.GetCurrency() == currE);
	
			// Regression for HARMONY-1351
			df = (DummyFormat) ILOG.J2CsMapping.Text.NumberFormat.GetCurrencyInstance(new CultureInfo(
					"QWERTY"));
			Junit.Framework.Assert.AssertTrue("Test5: Returned incorrect currency",
					df.GetCurrency() == currX);
	
			// JDK fails these tests since it doesn't have the PREEURO variant
			// df = (DecimalFormat)NumberFormat.getCurrencyInstance(new Locale("fr",
			// "FR","PREEURO"));
			// assertTrue("Test5: Returned incorrect currency", df.getCurrency() ==
			// currF);
		}
	
		
		/// @tests java.text.DecimalFormat#getGroupingSize()
		[NUnit.Framework.Test]
		public void Test_getGroupingSize() {
			DummyFormat df = new DummyFormat("###0.##");
			Junit.Framework.Assert.AssertEquals("Wrong unset size", 0, df.GetGroupingSize());
			df = new DummyFormat("#,##0.##");
			Junit.Framework.Assert.AssertEquals("Wrong set size", 3, df.GetGroupingSize());
			df = new DummyFormat("#,###,###0.##");
			Junit.Framework.Assert.AssertEquals("Wrong multiple set size", 4, df.GetGroupingSize());
		}
	
		
		/// @tests java.text.DecimalFormat#getMultiplier()
		[NUnit.Framework.Test]
		public void Test_getMultiplier() {
			int defaultMultiplier = 1;
			NumberFormat nform = ILOG.J2CsMapping.Text.NumberFormat.GetInstance(System.Globalization.CultureInfo.CreateSpecificCulture("en-us"));
			DummyFormat form = (DummyFormat) nform;
			Junit.Framework.Assert.AssertEquals(defaultMultiplier, form.GetMultiplier());
	
			DummyFormat df = new DummyFormat("###0.##");
			Junit.Framework.Assert.AssertEquals("Wrong unset multiplier", 1, df.GetMultiplier());
			df = new DummyFormat("###0.##%");
			Junit.Framework.Assert.AssertEquals("Wrong percent multiplier", 100, df.GetMultiplier());
			df = new DummyFormat("###0.##\u2030");
			Junit.Framework.Assert.AssertEquals("Wrong mille multiplier", 1000, df.GetMultiplier());
		}
	
		
		/// @tests java.text.DecimalFormat#isDecimalSeparatorAlwaysShown()
		[NUnit.Framework.Test]
		public void Test_isDecimalSeparatorAlwaysShown() {
			DummyFormat df = new DummyFormat("###0.##");
			Junit.Framework.Assert.AssertTrue("Wrong unset value", !df.IsDecimalSeparatorAlwaysShown());
			df = new DummyFormat("###0.00");
			Junit.Framework.Assert.AssertTrue("Wrong unset2 value", !df.IsDecimalSeparatorAlwaysShown());
			df = new DummyFormat("###0.");
			Junit.Framework.Assert.AssertTrue("Wrong set value", df.IsDecimalSeparatorAlwaysShown());
		}
	
		
		/// @tests java.text.DecimalFormat#parse(java.lang.String,
		/// java.text.ParsePosition)
		//FIXME This test fails on Harmony ClassLibrary
		[NUnit.Framework.Test]
		public void Test_parseLjava_lang_StringLjava_text_ParsePosition() {
			DummyFormat format = (DummyFormat) ILOG.J2CsMapping.Text.NumberFormat
					.GetNumberInstance(System.Globalization.CultureInfo.CreateSpecificCulture("en"));
			ParsePosition pos = new ParsePosition(0);
			object result = format.Parse("9223372036854775807", pos);
			Junit.Framework.Assert.AssertTrue("Wrong result type for Long.MAX_VALUE",
					(Object) result.GetType() == (Object) typeof(Int64));
			Junit.Framework.Assert.AssertTrue("Wrong result Long.MAX_VALUE",
					Convert.ToInt64(result) == Int64.MaxValue);
			pos = new ParsePosition(0);
			result = format.Parse("-9223372036854775808", pos);
			Junit.Framework.Assert.AssertTrue("Wrong result type for Long.MIN_VALUE",
					(Object) result.GetType() == (Object) typeof(Int64));
			Junit.Framework.Assert.AssertTrue("Wrong result Long.MIN_VALUE: " + Convert.ToInt64(result), Convert.ToInt64(result) == Int64.MinValue);
			pos = new ParsePosition(0);
			result = format.Parse("9223372036854775808", pos);
			Junit.Framework.Assert.AssertTrue("Wrong result type for Long.MAX_VALUE+1",
					(Object) result.GetType() == (Object) typeof(Double));
			Junit.Framework.Assert.AssertTrue("Wrong result Long.MAX_VALUE + 1",
					Convert.ToDouble(result) == (double) Int64.MaxValue + 1);
			pos = new ParsePosition(0);
			result = format.Parse("-9223372036854775809", pos);
			Junit.Framework.Assert.AssertTrue("Wrong result type for Long.MIN_VALUE+1",
					(Object) result.GetType() == (Object) typeof(Double));
			Junit.Framework.Assert.AssertTrue("Wrong result Long.MIN_VALUE - 1",
					Convert.ToDouble(result) == (double) Int64.MinValue - 1);
	
			pos = new ParsePosition(0);
			result = format.Parse("18446744073709551629", pos);
			Junit.Framework.Assert.AssertTrue("Wrong result type for overflow",
					(Object) result.GetType() == (Object) typeof(Double));
			Junit.Framework.Assert.AssertTrue("Wrong result for overflow",
					Convert.ToDouble(result) == 18446744073709551629d);
	
			pos = new ParsePosition(0);
			result = format.Parse("42325917317067571199", pos);
			Junit.Framework.Assert.AssertTrue("Wrong result type for overflow a: " + result, (Object) result
					.GetType() == (Object) typeof(Double));
			Junit.Framework.Assert.AssertTrue("Wrong result for overflow a: " + result, Convert.ToDouble(result) == 42325917317067571199d);
			pos = new ParsePosition(0);
			result = format.Parse("4232591731706757119E1", pos);
			Junit.Framework.Assert.AssertTrue("Wrong result type for overflow b: " + result, (Object) result
					.GetType() == (Object) typeof(Double));
			Junit.Framework.Assert.AssertTrue("Wrong result for overflow b: " + result, Convert.ToDouble(result) == 42325917317067571190d);
			pos = new ParsePosition(0);
			result = format.Parse(".42325917317067571199E20", pos);
			Junit.Framework.Assert.AssertTrue("Wrong result type for overflow c: " + result, (Object) result
					.GetType() == (Object) typeof(Double));
			Junit.Framework.Assert.AssertTrue("Wrong result for overflow c: " + result, Convert.ToDouble(result) == 42325917317067571199d);
			pos = new ParsePosition(0);
			result = format.Parse("922337203685477580.9E1", pos);
			Junit.Framework.Assert.AssertTrue("Wrong result type for overflow d: " + result, (Object) result
					.GetType() == (Object) typeof(Double));
			Junit.Framework.Assert.AssertTrue("Wrong result for overflow d: " + result, Convert.ToDouble(result) == 9223372036854775809d);
			pos = new ParsePosition(0);
			result = format.Parse("9.223372036854775809E18", pos);
			Junit.Framework.Assert.AssertTrue("Wrong result type for overflow e: " + result, (Object) result
					.GetType() == (Object) typeof(Double));
			Junit.Framework.Assert.AssertTrue("Wrong result for overflow e: " + result, Convert.ToDouble(result) == 9223372036854775809d);
	
			// test parse with multipliers
			format.SetMultiplier(100);
			result = format.Parse("9223372036854775807", new ParsePosition(0));
			Junit.Framework.Assert.AssertTrue("Wrong result type multiplier 100: " + result, (Object) result
					.GetType() == (Object) typeof(Int64));
			Junit.Framework.Assert.AssertTrue("Wrong result for multiplier 100: " + result, Convert.ToInt64(result) == 92233720368547758L);
	
			format.SetMultiplier(1000);
			result = format.Parse("9223372036854775807", new ParsePosition(0));
			Junit.Framework.Assert.AssertTrue("Wrong result type multiplier 1000: " + result, (Object) result
					.GetType() == (Object) typeof(Int64));
			Junit.Framework.Assert.AssertTrue("Wrong result for multiplier 1000: " + result, Convert.ToInt64(result) == 9223372036854776L);
	
			format.SetMultiplier(10000);
			result = format.Parse("9223372036854775807", new ParsePosition(0));
			Junit.Framework.Assert.AssertTrue("Wrong result type multiplier 10000: " + result, (Object) result
					.GetType() == (Object) typeof(Double));
			Junit.Framework.Assert.AssertTrue("Wrong result for multiplier 10000: " + result, Convert.ToDouble(result) == 922337203685477.5807d);
	
		}
	
		
		/// @tests java.text.DecimalFormat#setDecimalFormatSymbols(java.text.DecimalFormatSymbols)
		[NUnit.Framework.Test]
		public void Test_setDecimalFormatSymbolsLjava_text_DecimalFormatSymbols() {
			DummyFormat df = new DummyFormat("###0.##");
			NumberFormatInfo dfs = new NumberFormatInfo();
			dfs.SetDecimalSeparator('@');
			df.SetDecimalFormatSymbols(dfs);
			Junit.Framework.Assert.AssertTrue("Not set", df.GetDecimalFormatSymbols().Equals(dfs));
			Junit.Framework.Assert.AssertEquals("Symbols not used", "1@2", df.Format(1.2d));
	
			// The returned symbols may be cloned in two spots
			// 1. When set
			// 2. When returned
			DummyFormat format = new DummyFormat();
			NumberFormatInfo symbols = new NumberFormatInfo();
			format.SetDecimalFormatSymbols(symbols);
			NumberFormatInfo symbolsOut = format.GetDecimalFormatSymbols();
			Junit.Framework.Assert.AssertNotSame(symbols, symbolsOut);
		}
	
		
		/// @tests java.text.DecimalFormat#setDecimalSeparatorAlwaysShown(boolean)
		[NUnit.Framework.Test]
		public void Test_setDecimalSeparatorAlwaysShownZ() {
			DummyFormat df = new DummyFormat("###0.##",
					NumberFormatInfo.GetInstance(System.Globalization.CultureInfo.CreateSpecificCulture("en-us")));
			Junit.Framework.Assert.AssertEquals("Wrong default result", "5", df.Format(5));
			df.SetDecimalSeparatorAlwaysShown(true);
			Junit.Framework.Assert.AssertTrue("Not set", df.IsDecimalSeparatorAlwaysShown());
			Junit.Framework.Assert.AssertEquals("Wrong set result", "7.", df.Format(7));
		}
	
		
		/// @tests java.text.DecimalFormat#setCurrency(java.util.Currency)
		[NUnit.Framework.Test]
		public void Test_setCurrencyLjava_util_Currency() {
			CultureInfo locale = System.Globalization.CultureInfo.CANADA;
			DummyFormat df = ((DummyFormat) ILOG.J2CsMapping.Text.NumberFormat
					.GetCurrencyInstance(locale));
	
			try {
				df.SetCurrency(null);
				Junit.Framework.Assert.Fail("Expected NullPointerException");
			} catch (NullReferenceException e) {
			}
	
			Currency currency = System.Collections.Currency.GetInstance("AED");
			df.SetCurrency(currency);
			Junit.Framework.Assert.AssertTrue("Returned incorrect currency", currency == df.GetCurrency());
			Junit.Framework.Assert.AssertTrue("Returned incorrect currency symbol", currency.GetSymbol(
					locale)
					.Equals(df.GetDecimalFormatSymbols().GetCurrencySymbol()));
			Junit.Framework.Assert.AssertTrue("Returned incorrect international currency symbol", currency
					.GetCurrencyCode().Equals(
							df.GetDecimalFormatSymbols()
									.GetInternationalCurrencySymbol()));
		}
	
		
		/// @tests java.text.DecimalFormat#setGroupingSize(int)
		[NUnit.Framework.Test]
		public void Test_setGroupingSizeI() {
			DummyFormat df = new DummyFormat("###0.##",
					NumberFormatInfo.GetInstance(System.Globalization.CultureInfo.CreateSpecificCulture("en")));
			df.SetGroupingUsed(true);
			df.SetGroupingSize(2);
			Junit.Framework.Assert.AssertEquals("Value not set", 2, df.GetGroupingSize());
			String result = df.Format(123);
			Junit.Framework.Assert.AssertTrue("Invalid format:" + result, result.Equals("1,23"));
		}
	
		
		/// @tests java.text.DecimalFormat#setMaximumFractionDigits(int)
		[NUnit.Framework.Test]
		public void Test_setMaximumFractionDigitsI() {
			DummyFormat df = new DummyFormat("###0.##",
					NumberFormatInfo.GetInstance(System.Globalization.CultureInfo.CreateSpecificCulture("en-us")));
			df.SetMaximumFractionDigits(3);
			Junit.Framework.Assert.AssertEquals("Not set", 3, df.GetMaximumFractionDigits());
			Junit.Framework.Assert.AssertEquals("Wrong maximum", "1.235", df.Format(1.23456d));
			df.SetMinimumFractionDigits(4);
			Junit.Framework.Assert.AssertEquals("Not changed", 4, df.GetMaximumFractionDigits());
			Junit.Framework.Assert.AssertEquals("Incorrect fraction", "456.0000", df.Format(456));
		}
	
		
		/// @tests java.text.DecimalFormat#setMaximumIntegerDigits(int)
		[NUnit.Framework.Test]
		public void Test_setMaximumIntegerDigitsI() {
			DummyFormat df = new DummyFormat("###0.##");
			df.SetMaximumIntegerDigits(2);
			Junit.Framework.Assert.AssertEquals("Not set", 2, df.GetMaximumIntegerDigits());
			Junit.Framework.Assert.AssertEquals("Wrong maximum", "34", df.Format(1234));
			df.SetMinimumIntegerDigits(4);
			Junit.Framework.Assert.AssertEquals("Not changed", 4, df.GetMaximumIntegerDigits());
			Junit.Framework.Assert.AssertEquals("Incorrect integer", "0026", df.Format(26));
		}
	
		
		/// @tests java.text.DecimalFormat#setMinimumFractionDigits(int)
		[NUnit.Framework.Test]
		public void Test_setMinimumFractionDigitsI() {
			DummyFormat df = new DummyFormat("###0.##",
					NumberFormatInfo.GetInstance(System.Globalization.CultureInfo.CreateSpecificCulture("en-us")));
			df.SetMinimumFractionDigits(4);
			Junit.Framework.Assert.AssertEquals("Not set", 4, df.GetMinimumFractionDigits());
			Junit.Framework.Assert.AssertEquals("Wrong minimum", "1.2300", df.Format(1.23d));
			df.SetMaximumFractionDigits(2);
			Junit.Framework.Assert.AssertEquals("Not changed", 2, df.GetMinimumFractionDigits());
			Junit.Framework.Assert.AssertEquals("Incorrect fraction", "456.00", df.Format(456));
		}
	
		
		/// @tests java.text.DecimalFormat#setMinimumIntegerDigits(int)
		[NUnit.Framework.Test]
		public void Test_setMinimumIntegerDigitsI() {
			DummyFormat df = new DummyFormat("###0.##",
					NumberFormatInfo.GetInstance(System.Globalization.CultureInfo.CreateSpecificCulture("en-us")));
			df.SetMinimumIntegerDigits(3);
			Junit.Framework.Assert.AssertEquals("Not set", 3, df.GetMinimumIntegerDigits());
			Junit.Framework.Assert.AssertEquals("Wrong minimum", "012", df.Format(12));
			df.SetMaximumIntegerDigits(2);
			Junit.Framework.Assert.AssertEquals("Not changed", 2, df.GetMinimumIntegerDigits());
			Junit.Framework.Assert.AssertEquals("Incorrect integer", "00.7", df.Format(0.7d));
		}
	
		
		/// @tests java.text.DecimalFormat#setMultiplier(int)
		//FIXME This test fails on Harmony ClassLibrary
		[NUnit.Framework.Test]
		public void Test_setMultiplierI() {
			DummyFormat df = new DummyFormat("###0.##");
			df.SetMultiplier(10);
			Junit.Framework.Assert.AssertEquals("Wrong multiplier", 10, df.GetMultiplier());
			Junit.Framework.Assert.AssertEquals("Wrong format", "50", df.Format(5));
			Junit.Framework.Assert.AssertEquals("Wrong parse", 5, System.Convert.ToInt32(df.Parse("50", new ParsePosition(0))));
	
			// regression test for HARMONY-879
			df.SetMultiplier(-1);
			Junit.Framework.Assert.AssertEquals("Wrong  multiplier for negative value", -1, df
					.GetMultiplier());
		}
	
		/**
		 * @tests serialization/deserialization compatibility.
		 */
		/* public void testSerializationSelf() throws Exception {
		     SerializationTest.verifySelf(new DecimalFormat());
		 }*
	
		
		/// @tests serialization compatibility with RI
		[NUnit.Framework.Test]
		public void Test_serializationHarmonyRICompatible() {
			NumberFormat nf = ILOG.J2CsMapping.Text.NumberFormat.GetInstance(ILOG.J2CsMapping.Util.Culture.CultureInfoHelper.FRANCE);
	
			DummyFormat df = null;
			if (!(nf  is  DummyFormat)) {
				throw new Exception("This NumberFormat is not a DecimalFormat");
	
			}
			df = (DummyFormat) nf;
	
			IlObjectInputStream oinput = null;
	
			DummyFormat deserializedDF = null;
	
			try {
				oinput = new IlObjectInputStream(ILOG.Rules.Util.Net.NetHelper.OpenStream(this.GetType().GetResource(
									"/serialization/java/text/DecimalFormat.ser")));
				deserializedDF = (DummyFormat) oinput.ReadObject();
			} finally {
				try {
					if (null != oinput) {
						((Stream) oinput).Close();
					}
				} catch (Exception e) {
					// ignore
				}
			}
	
			Junit.Framework.Assert.AssertEquals(df.GetNegativePrefix(), deserializedDF.GetNegativePrefix());
			Junit.Framework.Assert.AssertEquals(df.GetNegativeSuffix(), deserializedDF.GetNegativeSuffix());
			Junit.Framework.Assert.AssertEquals(df.GetPositivePrefix(), deserializedDF.GetPositivePrefix());
			Junit.Framework.Assert.AssertEquals(df.GetPositiveSuffix(), deserializedDF.GetPositiveSuffix());
			Junit.Framework.Assert.AssertEquals(df.GetCurrency(), deserializedDF.GetCurrency());
	
			Junit.Framework.Assert.AssertEquals(df.GetDecimalFormatSymbols(), deserializedDF
					.GetDecimalFormatSymbols());
	
			Junit.Framework.Assert.AssertEquals(df.GetGroupingSize(), df.GetGroupingSize());
			Junit.Framework.Assert.AssertEquals(df.GetMaximumFractionDigits(), deserializedDF
					.GetMaximumFractionDigits());
	
			Junit.Framework.Assert.AssertEquals(df.GetMaximumIntegerDigits(), deserializedDF
					.GetMaximumIntegerDigits());
	
			Junit.Framework.Assert.AssertEquals(df.GetMinimumFractionDigits(), deserializedDF
					.GetMinimumFractionDigits());
			Junit.Framework.Assert.AssertEquals(df.GetMinimumIntegerDigits(), deserializedDF
					.GetMinimumIntegerDigits());
			Junit.Framework.Assert.AssertEquals(df.GetMultiplier(), deserializedDF.GetMultiplier());
	
			// Deliberately omitted this assertion. Since different data resource
			// will cause the assertion fail.
			// assertEquals(df, deserializedDF);
	
		}
	
		/// <summary>
		/// Test whether DecimalFormat can parse Positive infinity correctly
		/// </summary>
		///
		[NUnit.Framework.Test]
		public void TestParseInfinityBigDecimalFalse() {
			// Regression test for HARMONY-106
			DummyFormat format = (DummyFormat) ILOG.J2CsMapping.Text.NumberFormat.GetInstance();
			NumberFormatInfo symbols = new NumberFormatInfo();
			object number = format.Parse(symbols.GetInfinity(),
					new ParsePosition(0));
			Junit.Framework.Assert.AssertTrue(number  is  Double);
			Junit.Framework.Assert.AssertTrue(Double.IsInfinity(Convert.ToDouble(number)));
		}
	
		/// <summary>
		/// Test whether DecimalFormat can parse Negative infinity correctly
		/// </summary>
		///
		[NUnit.Framework.Test]
		public void TestParseMinusInfinityBigDecimalFalse() {
			// Regression test for HARMONY-106
			DummyFormat format = (DummyFormat) ILOG.J2CsMapping.Text.NumberFormat.GetInstance();
			NumberFormatInfo symbols = new NumberFormatInfo();
			object number = format.Parse("-" + symbols.GetInfinity(),
					new ParsePosition(0));
			Junit.Framework.Assert.AssertTrue(number  is  Double);
			Junit.Framework.Assert.AssertTrue(Double.IsInfinity(Convert.ToDouble(number)));
		}
	
		/// <summary>
		/// Test if setDecimalFormatSymbols method wont throw NullPointerException 
		/// when it is called with null parameter.
		/// </summary>
		///
		[NUnit.Framework.Test]
		public void TestSetDecimalFormatSymbolsAsNull() {
			// Regression for HARMONY-1070
			DummyFormat format = (DummyFormat) ILOG.J2CsMapping.Text.NumberFormat.GetInstance();
			format.SetDecimalFormatSymbols(null);
		}*/
	}
}
