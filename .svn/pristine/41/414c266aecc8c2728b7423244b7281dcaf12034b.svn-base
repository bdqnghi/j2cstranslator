// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:30 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 1996-2007, International Business Machines Corporation and    
/// others. All Rights Reserved.                                                
/// </summary>
///
namespace IBM.ICU.Text {
	
	using IBM.ICU.Impl;
	using IBM.ICU.Util;
	using ILOG.J2CsMapping.Collections;
	using ILOG.J2CsMapping.Collections.Generics;
	using ILOG.J2CsMapping.Util;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Text;
	
	/// <summary>
	/// Class for building a collator from a list of collation rules. This class is
	/// uses CollationRuleParser
	/// </summary>
	///
	/// @draft 2.2
	internal sealed class CollationParsedRuleBuilder {
	    // package private constructors ------------------------------------------
	
	    /// <summary>
	    /// Constructor
	    /// </summary>
	    ///
	    /// <param name="rules">collation rules</param>
	    /// <exception cref="ParseException">thrown when argument rules have an invalid syntax</exception>
	    internal CollationParsedRuleBuilder(String rules) {
	        this.m_utilGens_ = new CollationParsedRuleBuilder.CEGenerator [] { new CollationParsedRuleBuilder.CEGenerator (), new CollationParsedRuleBuilder.CEGenerator (),
	                new CollationParsedRuleBuilder.CEGenerator () };
	        this.m_utilCEBuffer_ = new int[CE_BASIC_STRENGTH_LIMIT_];
	        this.m_utilIntBuffer_ = new int[CE_STRENGTH_LIMIT_];
	        this.m_utilElement_ = new CollationParsedRuleBuilder.Elements ();
	        this.m_utilElement2_ = new CollationParsedRuleBuilder.Elements ();
	        this.m_utilToken_ = new CollationRuleParser.Token();
	        this.m_utilCountBuffer_ = new int[6];
	        this.m_utilLongBuffer_ = new long[5];
	        this.m_utilLowerWeightRange_ = new CollationParsedRuleBuilder.WeightRange [] { new CollationParsedRuleBuilder.WeightRange (),
	                new CollationParsedRuleBuilder.WeightRange (), new CollationParsedRuleBuilder.WeightRange (), new CollationParsedRuleBuilder.WeightRange (),
	                new CollationParsedRuleBuilder.WeightRange () };
	        this.m_utilUpperWeightRange_ = new CollationParsedRuleBuilder.WeightRange [] { new CollationParsedRuleBuilder.WeightRange (),
	                new CollationParsedRuleBuilder.WeightRange (), new CollationParsedRuleBuilder.WeightRange (), new CollationParsedRuleBuilder.WeightRange (),
	                new CollationParsedRuleBuilder.WeightRange () };
	        this.m_utilWeightRange_ = new CollationParsedRuleBuilder.WeightRange ();
	        this.m_utilCharBuffer_ = new char[256];
	        this.m_utilCanIter_ = new CanonicalIterator("");
	        this.m_utilStringBuffer_ = new StringBuilder("");
	        m_parser_ = new CollationRuleParser(rules);
	        m_parser_.AssembleTokenList();
	        m_utilColEIter_ = IBM.ICU.Text.RuleBasedCollator.UCA_
	                .GetCollationElementIterator("");
	    }
	
	    // package private inner classes -----------------------------------------
	
	    /// <summary>
	    /// Inverse UCA wrapper
	    /// </summary>
	    ///
	    internal class InverseUCA {
	        // package private constructor ---------------------------------------
	
	        internal InverseUCA() {
	        }
	
	        // package private data member ---------------------------------------
	
	        /// <summary>
	        /// Array list of characters
	        /// </summary>
	        ///
	        internal int[] m_table_;
	
	        /// <summary>
	        /// Array list of continuation characters
	        /// </summary>
	        ///
	        internal char[] m_continuations_;
	
	        /// <summary>
	        /// UCA version of inverse UCA table
	        /// </summary>
	        ///
	        internal VersionInfo m_UCA_version_;
	
	        // package private method --------------------------------------------
	
	        /// <summary>
	        /// Returns the previous inverse ces of the argument ces
	        /// </summary>
	        ///
	        /// <param name="ce">ce to test</param>
	        /// <param name="contce">continuation ce to test</param>
	        /// <param name="strength">collation strength</param>
	        /// <param name="prevresult">an array to store the return results previous inverse ceand previous inverse continuation ce</param>
	        /// <returns>result of the inverse ce</returns>
	        internal int GetInversePrevCE(int ce, int contce, int strength,
	                int[] prevresult) {
	            int result = FindInverseCE(ce, contce);
	
	            if (result < 0) {
	                prevresult[0] = IBM.ICU.Text.CollationElementIterator.NULLORDER;
	                return -1;
	            }
	
	            ce &= IBM.ICU.Text.CollationParsedRuleBuilder.STRENGTH_MASK_[strength];
	            contce &= IBM.ICU.Text.CollationParsedRuleBuilder.STRENGTH_MASK_[strength];
	
	            prevresult[0] = ce;
	            prevresult[1] = contce;
	
	            while ((prevresult[0] & IBM.ICU.Text.CollationParsedRuleBuilder.STRENGTH_MASK_[strength]) == ce
	                    && (prevresult[1] & IBM.ICU.Text.CollationParsedRuleBuilder.STRENGTH_MASK_[strength]) == contce
	                    && result > 0) {
	                // this condition should prevent falling off the edge of the
	                // world
	                // here, we end up in a singularity - zero
	                prevresult[0] = m_table_[3 * (--result)];
	                prevresult[1] = m_table_[3 * result + 1];
	            }
	            return result;
	        }
	
	        internal int GetCEStrengthDifference(int CE, int contCE, int prevCE,
	                int prevContCE) {
	            int strength = IBM.ICU.Text.Collator.TERTIARY;
	            while (((prevCE & IBM.ICU.Text.CollationParsedRuleBuilder.STRENGTH_MASK_[strength]) != (CE & IBM.ICU.Text.CollationParsedRuleBuilder.STRENGTH_MASK_[strength]) || (prevContCE & IBM.ICU.Text.CollationParsedRuleBuilder.STRENGTH_MASK_[strength]) != (contCE & IBM.ICU.Text.CollationParsedRuleBuilder.STRENGTH_MASK_[strength]))
	                    && (strength != 0)) {
	                strength--;
	            }
	            return strength;
	        }
	
	        public int CompareCEs(int source0, int source1, int target0,
	                int target1) {
	            int s1 = source0, s2, t1 = target0, t2;
	            if (IBM.ICU.Text.RuleBasedCollator.IsContinuation(source1)) {
	                s2 = source1;
	            } else {
	                s2 = 0;
	            }
	            if (IBM.ICU.Text.RuleBasedCollator.IsContinuation(target1)) {
	                t2 = target1;
	            } else {
	                t2 = 0;
	            }
	
	            int s = 0, t = 0;
	            if (s1 == t1 && s2 == t2) {
	                return 0;
	            }
	            s = (s1 & -65536) | ((s2 & -65536) >> 16);
	            t = (t1 & -65536) | ((t2 & -65536) >> 16);
	            if (s == t) {
	                s = (s1 & 0x0000FF00) | (s2 & 0x0000FF00) >> 8;
	                t = (t1 & 0x0000FF00) | (t2 & 0x0000FF00) >> 8;
	                if (s == t) {
	                    s = (s1 & 0x000000FF) << 8 | (s2 & 0x000000FF);
	                    t = (t1 & 0x000000FF) << 8 | (t2 & 0x000000FF);
	                    return IBM.ICU.Impl.Utility.CompareUnsigned(s, t);
	                } else {
	                    return IBM.ICU.Impl.Utility.CompareUnsigned(s, t);
	                }
	            } else {
	                return IBM.ICU.Impl.Utility.CompareUnsigned(s, t);
	            }
	        }
	
	        /// <summary>
	        /// Finding the inverse CE of the argument CEs
	        /// </summary>
	        ///
	        /// <param name="ce">CE to be tested</param>
	        /// <param name="contce">continuation CE</param>
	        /// <returns>inverse CE</returns>
	        internal int FindInverseCE(int ce, int contce) {
	            int bottom = 0;
	            int top = m_table_.Length / 3;
	            int result = 0;
	
	            while (bottom < top - 1) {
	                result = (top + bottom) >> 1;
	                int first = m_table_[3 * result];
	                int second = m_table_[3 * result + 1];
	                int comparison = CompareCEs(first, second, ce, contce);
	                if (comparison > 0) {
	                    top = result;
	                } else if (comparison < 0) {
	                    bottom = result;
	                } else {
	                    break;
	                }
	            }
	
	            return result;
	        }
	
	        /// <summary>
	        /// Getting gap offsets in the inverse UCA
	        /// </summary>
	        ///
	        /// <param name="listheader">parsed token lists</param>
	        /// <exception cref="Exception">thrown when error occurs while finding the collationgaps</exception>
	        internal void GetInverseGapPositions(
	                CollationRuleParser.TokenListHeader listheader) {
	            // reset all the gaps
	            CollationRuleParser.Token token = listheader.m_first_;
	            int tokenstrength = token.m_strength_;
	
	            for (int i = 0; i < 3; i++) {
	                listheader.m_gapsHi_[3 * i] = 0;
	                listheader.m_gapsHi_[3 * i + 1] = 0;
	                listheader.m_gapsHi_[3 * i + 2] = 0;
	                listheader.m_gapsLo_[3 * i] = 0;
	                listheader.m_gapsLo_[3 * i + 1] = 0;
	                listheader.m_gapsLo_[3 * i + 2] = 0;
	                listheader.m_numStr_[i] = 0;
	                listheader.m_fStrToken_[i] = null;
	                listheader.m_lStrToken_[i] = null;
	                listheader.m_pos_[i] = -1;
	            }
	
	            if ((MathUtil.URS(listheader.m_baseCE_, 24)) >= RuleBasedCollator.UCA_CONSTANTS_.PRIMARY_IMPLICIT_MIN_
                        && (MathUtil.URS(listheader.m_baseCE_, 24)) <= RuleBasedCollator.UCA_CONSTANTS_.PRIMARY_IMPLICIT_MAX_)
                {
	                // implicits -
	                listheader.m_pos_[0] = 0;
	                int t1 = listheader.m_baseCE_;
	                int t2 = listheader.m_baseContCE_;
	                listheader.m_gapsLo_[0] = IBM.ICU.Text.CollationParsedRuleBuilder.MergeCE(t1, t2, IBM.ICU.Text.Collator.PRIMARY);
	                listheader.m_gapsLo_[1] = IBM.ICU.Text.CollationParsedRuleBuilder.MergeCE(t1, t2, IBM.ICU.Text.Collator.SECONDARY);
	                listheader.m_gapsLo_[2] = IBM.ICU.Text.CollationParsedRuleBuilder.MergeCE(t1, t2, IBM.ICU.Text.Collator.TERTIARY);
	                int primaryCE = t1 & IBM.ICU.Text.RuleBasedCollator.CE_PRIMARY_MASK_
	                        | MathUtil.URS(t2 & IBM.ICU.Text.RuleBasedCollator.CE_PRIMARY_MASK_, 16);
	                primaryCE = IBM.ICU.Text.RuleBasedCollator.impCEGen_
	                        .GetImplicitFromRaw(IBM.ICU.Text.RuleBasedCollator.impCEGen_
	                                .GetRawFromImplicit(primaryCE) + 1);
	
	                t1 = primaryCE & IBM.ICU.Text.RuleBasedCollator.CE_PRIMARY_MASK_ | 0x0505;
	                t2 = (primaryCE << 16) & IBM.ICU.Text.RuleBasedCollator.CE_PRIMARY_MASK_
	                        | IBM.ICU.Text.RuleBasedCollator.CE_CONTINUATION_MARKER_;
	
	                // if (listheader.m_baseCE_ < 0xEF000000) {
	                // // first implicits have three byte primaries, with a gap of
	                // // one so we esentially need to add 2 to the top byte in
	                // // listheader.m_baseContCE_
	                // t2 += 0x02000000;
	                // }
	                // else {
	                // // second implicits have four byte primaries, with a gap of
	                // // IMPLICIT_LAST2_MULTIPLIER_
	                // // Now, this guy is not really accessible here, so until we
	                // // find a better way to pass it around, assume that the gap
	                // is 1
	                // t2 += 0x00020000;
	                // }
	                listheader.m_gapsHi_[0] = IBM.ICU.Text.CollationParsedRuleBuilder.MergeCE(t1, t2, IBM.ICU.Text.Collator.PRIMARY);
	                listheader.m_gapsHi_[1] = IBM.ICU.Text.CollationParsedRuleBuilder.MergeCE(t1, t2, IBM.ICU.Text.Collator.SECONDARY);
	                listheader.m_gapsHi_[2] = IBM.ICU.Text.CollationParsedRuleBuilder.MergeCE(t1, t2, IBM.ICU.Text.Collator.TERTIARY);
	            } else if (listheader.m_indirect_ == true
	                    && listheader.m_nextCE_ != 0) {
	                listheader.m_pos_[0] = 0;
	                int t1_0 = listheader.m_baseCE_;
	                int t2_1 = listheader.m_baseContCE_;
	                listheader.m_gapsLo_[0] = IBM.ICU.Text.CollationParsedRuleBuilder.MergeCE(t1_0, t2_1, IBM.ICU.Text.Collator.PRIMARY);
	                listheader.m_gapsLo_[1] = IBM.ICU.Text.CollationParsedRuleBuilder.MergeCE(t1_0, t2_1, IBM.ICU.Text.Collator.SECONDARY);
	                listheader.m_gapsLo_[2] = IBM.ICU.Text.CollationParsedRuleBuilder.MergeCE(t1_0, t2_1, IBM.ICU.Text.Collator.TERTIARY);
	                t1_0 = listheader.m_nextCE_;
	                t2_1 = listheader.m_nextContCE_;
	                listheader.m_gapsHi_[0] = IBM.ICU.Text.CollationParsedRuleBuilder.MergeCE(t1_0, t2_1, IBM.ICU.Text.Collator.PRIMARY);
	                listheader.m_gapsHi_[1] = IBM.ICU.Text.CollationParsedRuleBuilder.MergeCE(t1_0, t2_1, IBM.ICU.Text.Collator.SECONDARY);
	                listheader.m_gapsHi_[2] = IBM.ICU.Text.CollationParsedRuleBuilder.MergeCE(t1_0, t2_1, IBM.ICU.Text.Collator.TERTIARY);
	            } else {
	                while (true) {
	                    if (tokenstrength < IBM.ICU.Text.CollationParsedRuleBuilder.CE_BASIC_STRENGTH_LIMIT_) {
	                        listheader.m_pos_[tokenstrength] = GetInverseNext(
	                                listheader, tokenstrength);
	                        if (listheader.m_pos_[tokenstrength] >= 0) {
	                            listheader.m_fStrToken_[tokenstrength] = token;
	                        } else {
	                            // The CE must be implicit, since it's not in the
	                            // table
	                            // Error
	                            throw new Exception("Internal program error");
	                        }
	                    }
	
	                    while (token != null && token.m_strength_ >= tokenstrength) {
	                        if (tokenstrength < IBM.ICU.Text.CollationParsedRuleBuilder.CE_BASIC_STRENGTH_LIMIT_) {
	                            listheader.m_lStrToken_[tokenstrength] = token;
	                        }
	                        token = token.m_next_;
	                    }
	                    if (tokenstrength < IBM.ICU.Text.CollationParsedRuleBuilder.CE_BASIC_STRENGTH_LIMIT_ - 1) {
	                        // check if previous interval is the same and merge the
	                        // intervals if it is so
	                        if (listheader.m_pos_[tokenstrength] == listheader.m_pos_[tokenstrength + 1]) {
	                            listheader.m_fStrToken_[tokenstrength] = listheader.m_fStrToken_[tokenstrength + 1];
	                            listheader.m_fStrToken_[tokenstrength + 1] = null;
	                            listheader.m_lStrToken_[tokenstrength + 1] = null;
	                            listheader.m_pos_[tokenstrength + 1] = -1;
	                        }
	                    }
	                    if (token != null) {
	                        tokenstrength = token.m_strength_;
	                    } else {
	                        break;
	                    }
	                }
	                for (int st = 0; st < 3; st++) {
	                    int pos = listheader.m_pos_[st];
	                    if (pos >= 0) {
	                        int t1_2 = m_table_[3 * pos];
	                        int t2_3 = m_table_[3 * pos + 1];
	                        listheader.m_gapsHi_[3 * st] = IBM.ICU.Text.CollationParsedRuleBuilder.MergeCE(t1_2, t2_3,
	                                IBM.ICU.Text.Collator.PRIMARY);
	                        listheader.m_gapsHi_[3 * st + 1] = IBM.ICU.Text.CollationParsedRuleBuilder.MergeCE(t1_2, t2_3,
	                                IBM.ICU.Text.Collator.SECONDARY);
	                        listheader.m_gapsHi_[3 * st + 2] = (t1_2 & 0x3f) << 24
	                                | (t2_3 & 0x3f) << 16;
	                        // pos --;
	                        // t1 = m_table_[3 * pos];
	                        // t2 = m_table_[3 * pos + 1];
	                        t1_2 = listheader.m_baseCE_;
	                        t2_3 = listheader.m_baseContCE_;
	
	                        listheader.m_gapsLo_[3 * st] = IBM.ICU.Text.CollationParsedRuleBuilder.MergeCE(t1_2, t2_3,
	                                IBM.ICU.Text.Collator.PRIMARY);
	                        listheader.m_gapsLo_[3 * st + 1] = IBM.ICU.Text.CollationParsedRuleBuilder.MergeCE(t1_2, t2_3,
	                                IBM.ICU.Text.Collator.SECONDARY);
	                        listheader.m_gapsLo_[3 * st + 2] = (t1_2 & 0x3f) << 24
	                                | (t2_3 & 0x3f) << 16;
	                    }
	                }
	            }
	        }
	
	        /// <summary>
	        /// Gets the next CE in the inverse table
	        /// </summary>
	        ///
	        /// <param name="listheader">token list header</param>
	        /// <param name="strength">collation strength</param>
	        /// <returns>next ce</returns>
	        public int GetInverseNext(
	                CollationRuleParser.TokenListHeader listheader, int strength) {
	            int ce = listheader.m_baseCE_;
	            int secondce = listheader.m_baseContCE_;
	            int result = FindInverseCE(ce, secondce);
	
	            if (result < 0) {
	                return -1;
	            }
	
	            ce &= IBM.ICU.Text.CollationParsedRuleBuilder.STRENGTH_MASK_[strength];
	            secondce &= IBM.ICU.Text.CollationParsedRuleBuilder.STRENGTH_MASK_[strength];
	
	            int nextce = ce;
	            int nextcontce = secondce;
	
	            while ((nextce & IBM.ICU.Text.CollationParsedRuleBuilder.STRENGTH_MASK_[strength]) == ce
	                    && (nextcontce & IBM.ICU.Text.CollationParsedRuleBuilder.STRENGTH_MASK_[strength]) == secondce) {
	                nextce = m_table_[3 * (++result)];
	                nextcontce = m_table_[3 * result + 1];
	            }
	
	            listheader.m_nextCE_ = nextce;
	            listheader.m_nextContCE_ = nextcontce;
	
	            return result;
	        }
	    }
	
	    // package private data members ------------------------------------------
	
	    /// <summary>
	    /// Inverse UCA, instantiate only when required
	    /// </summary>
	    ///
	    static internal readonly CollationParsedRuleBuilder.InverseUCA  INVERSE_UCA_;
	
	    /// <summary>
	    /// UCA and Inverse UCA version do not match
	    /// </summary>
	    ///
	    private const String INV_UCA_VERSION_MISMATCH_ = "UCA versions of UCA and inverse UCA should match";
	
	    /// <summary>
	    /// UCA and Inverse UCA version do not match
	    /// </summary>
	    ///
	    private const String UCA_NOT_INSTANTIATED_ = "UCA is not instantiated!";
	
	    /// <summary>
	    /// Parse and sets the collation rules in the argument collator
	    /// </summary>
	    ///
	    /// <param name="collator">to set</param>
	    /// <exception cref="Exception">thrown when internal program error occurs</exception>
	    internal void SetRules(RuleBasedCollator collator) {
	        if (m_parser_.m_resultLength_ > 0 || m_parser_.m_removeSet_ != null) {
	            // we have a set of rules, let's make something of it
	            AssembleTailoringTable(collator);
	        } else { // no rules, but no error either must be only options
	                 // We will init the collator from UCA
	            collator.SetWithUCATables();
	        }
	        // And set only the options
	        m_parser_.SetDefaultOptionsInCollator(collator);
	    }
	
	    private void CopyRangeFromUCA(CollationParsedRuleBuilder.BuildTable  t, int start, int end) {
	        int u = 0;
	        for (u = start; u <= end; u++) {
	            // if ((CE = ucmpe32_get(t.m_mapping, u)) == UCOL_NOT_FOUND
	            int CE = t.m_mapping_.GetValue(u);
	            if (CE == CE_NOT_FOUND_
	            // this test is for contractions that are missing the starting
	            // element. Looks like latin-1 should be done before
	            // assembling the table, even if it results in more false
	            // closure elements
	                    || (IsContractionTableElement(CE) && GetCE(
	                            t.m_contractions_, CE, 0) == CE_NOT_FOUND_)) {
	                // m_utilElement_.m_uchars_ = str.toString();
	                m_utilElement_.m_uchars_ = IBM.ICU.Lang.UCharacter.ToString(u);
	                m_utilElement_.m_cPoints_ = m_utilElement_.m_uchars_;
	                m_utilElement_.m_prefix_ = 0;
	                m_utilElement_.m_CELength_ = 0;
	                m_utilColEIter_.SetText(m_utilElement_.m_uchars_);
	                while (CE != IBM.ICU.Text.CollationElementIterator.NULLORDER) {
	                    CE = m_utilColEIter_.Next();
	                    if (CE != IBM.ICU.Text.CollationElementIterator.NULLORDER) {
	                        m_utilElement_.m_CEs_[m_utilElement_.m_CELength_++] = CE;
	                    }
	                }
	                AddAnElement(t, m_utilElement_);
	            }
	        }
	    }
	
	    /// <summary>
	    /// 2. Eliminate the negative lists by doing the following for each non-null
	    /// negative list: o if previousCE(baseCE, strongestN) != some ListHeader X's
	    /// baseCE, create new ListHeader X o reverse the list, add to the end of X's
	    /// positive list. Reset the strength of the first item you add, based on the
	    /// stronger strength levels of the two lists.
	    /// 3. For each ListHeader with a non-null positive list: o Find all
	    /// character strings with CEs between the baseCE and the next/previous CE,
	    /// at the strength of the first token. Add these to the tailoring. ? That
	    /// is, if UCA has ... x <<< X << x' <<< X' < y ..., and the tailoring has &
	    /// x < z... ? Then we change the tailoring to & x <<< X << x' <<< X' < z ...
	    /// It is possible that this part should be done even while constructing list
	    /// The problem is that it is unknown what is going to be the strongest
	    /// weight. So we might as well do it here o Allocate CEs for each token in
	    /// the list, based on the total number N of the largest level difference,
	    /// and the gap G between baseCE and nextCE at that level. The relation 
	    /// between the last item and nextCE is the same as the strongest strength. o
	    /// Example: baseCE < a << b <<< q << c < d < e/// nextCE(X,1) ? There are 3
	    /// primary items: a, d, e. Fit them into the primary gap. Then fit b and c
	    /// into the secondary gap between a and d, then fit q into the tertiary gap
	    /// between b and c. o Example: baseCE << b <<< q << c/// nextCE(X,2) ? There
	    /// are 2 secondary items: b, c. Fit them into the secondary gap. Then fit q
	    /// into the tertiary gap between b and c. o When incrementing primary
	    /// values, we will not cross high byte boundaries except where there is only
	    /// a single-byte primary. That is to ensure that the script reordering will
	    /// continue to work.
	    /// </summary>
	    ///
	    /// <param name="collator">the rule based collator to update</param>
	    /// <exception cref="Exception">thrown when internal program error occurs</exception>
	    internal void AssembleTailoringTable(RuleBasedCollator collator) {
	
	        for (int i = 0; i < m_parser_.m_resultLength_; i++) {
	            // now we need to generate the CEs
	            // We stuff the initial value in the buffers, and increase the
	            // appropriate buffer according to strength
	            if (m_parser_.m_listHeader_[i].m_first_ != null) {
	                // if there are any elements
	                // due to the way parser works, subsequent tailorings
	                // may remove all the elements from a sequence, therefore
	                // leaving an empty tailoring sequence.
	                InitBuffers(m_parser_.m_listHeader_[i]);
	            }
	        }
	
	        if (m_parser_.m_variableTop_ != null) {
	            // stuff the variable top value
	            m_parser_.m_options_.m_variableTopValue_ = MathUtil.URS(m_parser_.m_variableTop_.m_CE_[0], 16);
	            // remove it from the list
	            if (m_parser_.m_variableTop_.m_listHeader_.m_first_ == m_parser_.m_variableTop_) { // first
	                                                                                               // in
	                                                                                               // list
	                m_parser_.m_variableTop_.m_listHeader_.m_first_ = m_parser_.m_variableTop_.m_next_;
	            }
	            if (m_parser_.m_variableTop_.m_listHeader_.m_last_ == m_parser_.m_variableTop_) {
	                // first in list
	                m_parser_.m_variableTop_.m_listHeader_.m_last_ = m_parser_.m_variableTop_.m_previous_;
	            }
	            if (m_parser_.m_variableTop_.m_next_ != null) {
	                m_parser_.m_variableTop_.m_next_.m_previous_ = m_parser_.m_variableTop_.m_previous_;
	            }
	            if (m_parser_.m_variableTop_.m_previous_ != null) {
	                m_parser_.m_variableTop_.m_previous_.m_next_ = m_parser_.m_variableTop_.m_next_;
	            }
	        }
	
	        CollationParsedRuleBuilder.BuildTable  t = new CollationParsedRuleBuilder.BuildTable (m_parser_);
	
	        // After this, we have assigned CE values to all regular CEs now we
	        // will go through list once more and resolve expansions, make
	        // UCAElements structs and add them to table
	        for (int i_0 = 0; i_0 < m_parser_.m_resultLength_; i_0++) {
	            // now we need to generate the CEs
	            // We stuff the initial value in the buffers, and increase the
	            // appropriate buffer according to strength */
	            CreateElements(t, m_parser_.m_listHeader_[i_0]);
	        }
	
	        m_utilElement_.Clear();
	        StringBuilder str = new StringBuilder();
	
	        // add latin-1 stuff
	        CopyRangeFromUCA(t, 0, 0xFF);
	
	        // add stuff for copying
	        if (m_parser_.m_copySet_ != null) {
	            int i_1 = 0;
	            for (i_1 = 0; i_1 < m_parser_.m_copySet_.GetRangeCount(); i_1++) {
	                CopyRangeFromUCA(t, m_parser_.m_copySet_.GetRangeStart(i_1),
	                        m_parser_.m_copySet_.GetRangeEnd(i_1));
	            }
	        }
	
	        char[] conts = IBM.ICU.Text.RuleBasedCollator.UCA_CONTRACTIONS_;
	        int offset = 0;
	        while (conts[offset] != 0) {
	            // tailoredCE = ucmpe32_get(t.m_mapping, *conts);
	            int tailoredCE = t.m_mapping_.GetValue(conts[offset]);
	            if (tailoredCE != CE_NOT_FOUND_) {
	                bool needToAdd = true;
	                if (IsContractionTableElement(tailoredCE)) {
	                    if (IsTailored(t.m_contractions_, tailoredCE, conts,
	                            offset + 1) == true) {
	                        needToAdd = false;
	                    }
	                }
	                if (m_parser_.m_removeSet_ != null
	                        && m_parser_.m_removeSet_.Contains(conts[offset])) {
	                    needToAdd = false;
	                }
	
	                if (needToAdd == true) {
	                    // we need to add if this contraction is not tailored.
	                    m_utilElement_.m_prefix_ = 0;
	                    m_utilElement_.m_prefixChars_ = null;
	                    m_utilElement_.m_cPoints_ = m_utilElement_.m_uchars_;
	                    str.Remove(0,str.Length-(0));
	                    str.Append(conts[offset]);
	                    str.Append(conts[offset + 1]);
	                    if (conts[offset + 2] != 0) {
	                        str.Append(conts[offset + 2]);
	                    }
	                    m_utilElement_.m_uchars_ = str.ToString();
	                    m_utilElement_.m_CELength_ = 0;
	                    m_utilColEIter_.SetText(m_utilElement_.m_uchars_);
	                    while (true) {
	                        int CE = m_utilColEIter_.Next();
	                        if (CE != IBM.ICU.Text.CollationElementIterator.NULLORDER) {
	                            m_utilElement_.m_CEs_[m_utilElement_.m_CELength_++] = CE;
	                        } else {
	                            break;
	                        }
	                    }
	                    AddAnElement(t, m_utilElement_);
	                }
	            } else if (m_parser_.m_removeSet_ != null
	                    && m_parser_.m_removeSet_.Contains(conts[offset])) {
	                CopyRangeFromUCA(t, conts[offset], conts[offset]);
	            }
	
	            offset += 3;
	        }
	
	        // Add completely ignorable elements
	        ProcessUCACompleteIgnorables(t);
	
	        // canonical closure
	        CanonicalClosure(t);
	
	        // still need to produce compatibility closure
	        AssembleTable(t, collator);
	    }
	
	    // private inner classes -------------------------------------------------
	
	    private class CEGenerator {
	        // package private data members --------------------------------------
	
	        internal CollationParsedRuleBuilder.WeightRange [] m_ranges_;
	
	        internal int m_rangesLength_;
	
	        internal int m_byteSize_;
	
	        internal int m_start_;
	
	        internal int m_limit_;
	
	        internal int m_maxCount_;
	
	        internal int m_count_;
	
	        internal int m_current_;
	
	        internal int m_fLow_; // forbidden Low
	
	        internal int m_fHigh_; // forbidden High
	
	        // package private constructor ---------------------------------------
	
	        internal CEGenerator() {
	            m_ranges_ = new CollationParsedRuleBuilder.WeightRange [7];
	            for (int i = 6; i >= 0; i--) {
	                m_ranges_[i] = new CollationParsedRuleBuilder.WeightRange ();
	            }
	        }
	    }
	
	    private class WeightRange : IComparable {
	        // public methods ----------------------------------------------------
	
	        /// <summary>
	        /// Compares this object with target
	        /// </summary>
	        ///
	        /// <param name="target">object to compare with</param>
	        /// <returns>0 if equals, 1 if this is > target, -1 otherwise</returns>
	        public virtual int CompareTo(Object target) {
	            if ((Object) this == target) {
	                return 0;
	            }
	            int tstart = ((CollationParsedRuleBuilder.WeightRange ) target).m_start_;
	            if (m_start_ == tstart) {
	                return 0;
	            }
	            if (m_start_ > tstart) {
	                return 1;
	            }
	            return -1;
	        }
	
	        /// <summary>
	        /// Initialize
	        /// </summary>
	        ///
	        public void Clear() {
	            m_start_ = 0;
	            m_end_ = 0;
	            m_length_ = 0;
	            m_count_ = 0;
	            m_length2_ = 0;
	            m_count2_ = 0;
	        }
	
	        // package private data members --------------------------------------
	
	        internal int m_start_;
	
	        internal int m_end_;
	
	        internal int m_length_;
	
	        internal int m_count_;
	
	        internal int m_length2_;
	
	        internal int m_count2_;
	
	        // package private constructor ---------------------------------------
	
	        internal WeightRange() {
	            Clear();
	        }
	
	        /// <summary>
	        /// Copy constructor. Cloneable is troublesome, needs to check for
	        /// exception
	        /// </summary>
	        ///
	        /// <param name="source">to clone</param>
	        internal WeightRange(CollationParsedRuleBuilder.WeightRange  source) {
	            m_start_ = source.m_start_;
	            m_end_ = source.m_end_;
	            m_length_ = source.m_length_;
	            m_count_ = source.m_count_;
	            m_length2_ = source.m_length2_;
	            m_count2_ = source.m_count2_;
	        }
	    }
	
	    private class MaxJamoExpansionTable {
	        // package private data members --------------------------------------
	
	        internal ArrayList m_endExpansionCE_;
	
	        // vector of booleans
	        internal ArrayList m_isV_;
	
	        internal byte m_maxLSize_;
	
	        internal byte m_maxVSize_;
	
	        internal byte m_maxTSize_;
	
	        // package private constructor ---------------------------------------
	
	        internal MaxJamoExpansionTable() {
	            m_endExpansionCE_ = new ArrayList();
	            m_isV_ = new ArrayList();
	            m_endExpansionCE_.Add(((int)(0)));
	            m_isV_.Add(false);
	            m_maxLSize_ = 1;
	            m_maxVSize_ = 1;
	            m_maxTSize_ = 1;
	        }
	
	        internal MaxJamoExpansionTable(CollationParsedRuleBuilder.MaxJamoExpansionTable  table) {
	            m_endExpansionCE_ = (ArrayList) table.m_endExpansionCE_.Clone();
	            m_isV_ = (ArrayList) table.m_isV_.Clone();
	            m_maxLSize_ = table.m_maxLSize_;
	            m_maxVSize_ = table.m_maxVSize_;
	            m_maxTSize_ = table.m_maxTSize_;
	        }
	    }
	
	    private class MaxExpansionTable {
	        // package private constructor --------------------------------------
	
	        internal MaxExpansionTable() {
	            m_endExpansionCE_ = new ArrayList();
	            m_expansionCESize_ = new ArrayList();
	            m_endExpansionCE_.Add(((int)(0)));
	            m_expansionCESize_.Add((byte )((byte) 0));
	        }
	
	        internal MaxExpansionTable(CollationParsedRuleBuilder.MaxExpansionTable  table) {
	            m_endExpansionCE_ = (ArrayList) table.m_endExpansionCE_.Clone();
	            m_expansionCESize_ = (ArrayList) table.m_expansionCESize_.Clone();
	        }
	
	        // package private data member --------------------------------------
	
	        internal ArrayList m_endExpansionCE_;
	
	        internal ArrayList m_expansionCESize_;
	    }
	
	    private class BasicContractionTable {
	        // package private constructors -------------------------------------
	
	        internal BasicContractionTable() {
	            m_CEs_ = new ArrayList();
	            m_codePoints_ = new StringBuilder();
	        }
	
	        // package private data members -------------------------------------
	
	        internal StringBuilder m_codePoints_;
	
	        internal ArrayList m_CEs_;
	    }
	
	    private class ContractionTable {
	        // package private constructor --------------------------------------
	
	        /// <summary>
	        /// Builds a contraction table
	        /// </summary>
	        ///
	        /// <param name="mapping"></param>
	        internal ContractionTable(IntTrieBuilder mapping) {
	            m_mapping_ = mapping;
	            m_elements_ = new ArrayList();
	            m_CEs_ = new ArrayList();
	            m_codePoints_ = new StringBuilder();
	            m_offsets_ = new ArrayList();
	            m_currentTag_ = IBM.ICU.Text.CollationParsedRuleBuilder.CE_NOT_FOUND_TAG_;
	        }
	
	        /// <summary>
	        /// Copies a contraction table. Not all data will be copied into their
	        /// own object.
	        /// </summary>
	        ///
	        /// <param name="table"></param>
	        internal ContractionTable(CollationParsedRuleBuilder.ContractionTable  table) {
	            m_mapping_ = table.m_mapping_;
	            m_elements_ = (ArrayList) table.m_elements_.Clone();
	            m_codePoints_ = new StringBuilder(table.m_codePoints_.ToString());
	            m_CEs_ = (ArrayList) table.m_CEs_.Clone();
	            m_offsets_ = (ArrayList) table.m_offsets_.Clone();
	            m_currentTag_ = table.m_currentTag_;
	        }
	
	        // package private data members ------------------------------------
	
	        /// <summary>
	        /// Vector of BasicContractionTable
	        /// </summary>
	        ///
	        internal ArrayList m_elements_;
	
	        internal IntTrieBuilder m_mapping_;
	
	        internal StringBuilder m_codePoints_;
	
	        internal ArrayList m_CEs_;
	
	        internal ArrayList m_offsets_;
	
	        internal int m_currentTag_;
	    }
	
	    /// <summary>
	    /// Private class for combining mark table. The table is indexed by the class
	    /// value(0-255).
	    /// </summary>
	    ///
	    private class CombinClassTable {
	        /// <summary>
	        /// accumulated numbers of combining marks.
	        /// </summary>
	        ///
	        internal int[] index;
	
	        /// <summary>
	        /// code point array for combining marks.
	        /// </summary>
	        ///
	        internal char[] cPoints;
	
	        /// <summary>
	        /// size of cPoints.
	        /// </summary>
	        ///
	        internal int size;
	
	        // constructor
	        internal CombinClassTable() {
	            this.index = new int[256];
	            cPoints = null;
	            size = 0;
	            pos = 0;
	            curClass = 1;
	        }
	
	        /// <summary>
	        /// Copy the combining mark table from ccc and index in compact way.
	        /// </summary>
	        ///
	        /// <param name="cps">: code point array</param>
	        /// <param name="size">: size of ccc</param>
	        /// <param name="index">: index of combining classes(0-255)</param>
	        internal void Generate(char[] cps, int numOfCM, int[] ccIndex) {
	            int count = 0;
	
	            cPoints = new char[numOfCM];
	            for (int i = 0; i < 256; i++) {
	                for (int j = 0; j < ccIndex[i]; j++) {
	                    cPoints[count++] = cps[(i << 8) + j];
	                }
	                index[i] = count;
	            }
	            size = count;
	        }
	
	        /// <summary>
	        /// Get first CM(combining mark) with the combining class value cClass.
	        /// </summary>
	        ///
	        /// <param name="cClass">: combining class value.</param>
	        /// <returns>combining mark codepoint or 0 if no combining make with class
	        /// value cClass</returns>
	        internal char GetFirstCM(int cClass) {
	            curClass = cClass;
	            if (cPoints == null || cClass == 0
	                    || index[cClass] == index[cClass - 1]) {
	                return (char) 0;
	            }
	            pos = 1;
	            return cPoints[index[cClass - 1]];
	        }
	
	        /// <summary>
	        /// Get next CM(combining mark) with the combining class value cClass.
	        /// Return combining mark codepoint or 0 if no next CM.
	        /// </summary>
	        ///
	        internal char GetNextCM() {
	            if (cPoints == null
	                    || index[curClass] == (index[curClass - 1] + pos)) {
	                return (char) 0;
	            }
	            return cPoints[index[curClass - 1] + (pos++)];
	        }
	
	        // private data members
	        internal int pos;
	
	        internal int curClass;
	    }
	
	    private sealed class BuildTable : TrieBuilder.DataManipulate {
	        // package private methods ------------------------------------------
	
	        /// <summary>
	        /// For construction of the Trie tables. Has to be labeled public
	        /// </summary>
	        ///
	        /// <param name="cp"></param>
	        /// <param name="offset"></param>
	        /// <returns>data offset or 0</returns>
	        /// @draft 2.2
	        public int GetFoldedValue(int cp, int offset) {
	            int limit = cp + 0x400;
	            while (cp < limit) {
	                int value_ren = m_mapping_.GetValue(cp);
	                bool inBlockZero = m_mapping_.IsInZeroBlock(cp);
	                int tag = IBM.ICU.Text.CollationParsedRuleBuilder.GetCETag(value_ren);
	                if (inBlockZero == true) {
	                    cp += IBM.ICU.Impl.TrieBuilder.DATA_BLOCK_LENGTH;
	                } else if (!(IBM.ICU.Text.CollationParsedRuleBuilder.IsSpecial(value_ren) && (tag == IBM.ICU.Text.CollationParsedRuleBuilder.CE_IMPLICIT_TAG_ || tag == IBM.ICU.Text.CollationParsedRuleBuilder.CE_NOT_FOUND_TAG_))) {
	                    // These are values that are starting in either UCA
	                    // (IMPLICIT_TAG) or in the tailorings (NOT_FOUND_TAG).
	                    // Presence of these tags means that there is nothing in
	                    // this position and that it should be skipped.
	                    return IBM.ICU.Text.RuleBasedCollator.CE_SPECIAL_FLAG_
	                            | (IBM.ICU.Text.CollationParsedRuleBuilder.CE_SURROGATE_TAG_ << 24) | offset;
	                } else {
	                    ++cp;
	                }
	            }
	            return 0;
	        }
	
	        // package private constructor --------------------------------------
	
	        /// <summary>
	        /// Returns a table
	        /// </summary>
	        ///
	        internal BuildTable(CollationRuleParser parser) {
	            this.cmLookup = null;
	            m_collator_ = new RuleBasedCollator();
	            m_collator_.SetWithUCAData();
	            CollationParsedRuleBuilder.MaxExpansionTable  maxet = new CollationParsedRuleBuilder.MaxExpansionTable ();
	            CollationParsedRuleBuilder.MaxJamoExpansionTable  maxjet = new CollationParsedRuleBuilder.MaxJamoExpansionTable ();
	            m_options_ = parser.m_options_;
	            m_expansions_ = new ArrayList();
	            // Do your own mallocs for the structure, array and have linear
	            // Latin 1
	            int trieinitialvalue = IBM.ICU.Text.RuleBasedCollator.CE_SPECIAL_FLAG_
	                    | (IBM.ICU.Text.CollationParsedRuleBuilder.CE_NOT_FOUND_TAG_ << 24);
	            // temporary fix for jb3822, 0x100000 -> 30000
	            m_mapping_ = new IntTrieBuilder(null, 0x30000, trieinitialvalue,
	                    trieinitialvalue, true);
	            m_prefixLookup_ = new Hashtable();
	            // uhash_open(prefixLookupHash, prefixLookupComp);
	            m_contractions_ = new CollationParsedRuleBuilder.ContractionTable (m_mapping_);
	            // copy UCA's maxexpansion and merge as we go along
	            m_maxExpansions_ = maxet;
	            // adding an extra initial value for easier manipulation
	            for (int i = 0; i < RuleBasedCollator.UCA_.m_expansionEndCE_.Length; i++) {
	                maxet.m_endExpansionCE_.Add(((int)(RuleBasedCollator.UCA_.m_expansionEndCE_[i])));
	                maxet.m_expansionCESize_.Add((byte )(RuleBasedCollator.UCA_.m_expansionEndCEMaxSize_[i]));
	            }
	            m_maxJamoExpansions_ = maxjet;
	
	            m_unsafeCP_ = new sbyte[IBM.ICU.Text.CollationParsedRuleBuilder.UNSAFECP_TABLE_SIZE_];
	            m_contrEndCP_ = new sbyte[IBM.ICU.Text.CollationParsedRuleBuilder.UNSAFECP_TABLE_SIZE_];
	            ILOG.J2CsMapping.Collections.Arrays.Fill(m_unsafeCP_,(sbyte) 0);
	            ILOG.J2CsMapping.Collections.Arrays.Fill(m_contrEndCP_,(sbyte) 0);
	        }
	
	        /// <summary>
	        /// Duplicating a BuildTable. Not all data will be duplicated into their
	        /// own object.
	        /// </summary>
	        ///
	        /// <param name="table">to clone</param>
	        internal BuildTable(CollationParsedRuleBuilder.BuildTable  table) {
	            this.cmLookup = null;
	            m_collator_ = table.m_collator_;
	            m_mapping_ = new IntTrieBuilder(table.m_mapping_);
	            m_expansions_ = (ArrayList) table.m_expansions_.Clone();
	            m_contractions_ = new CollationParsedRuleBuilder.ContractionTable (table.m_contractions_);
	            m_contractions_.m_mapping_ = m_mapping_;
	            m_options_ = table.m_options_;
	            m_maxExpansions_ = new CollationParsedRuleBuilder.MaxExpansionTable (table.m_maxExpansions_);
	            m_maxJamoExpansions_ = new CollationParsedRuleBuilder.MaxJamoExpansionTable (
	                    table.m_maxJamoExpansions_);
	            m_unsafeCP_ = new sbyte[table.m_unsafeCP_.Length];
	            System.Array.Copy((Array)(table.m_unsafeCP_),0,(Array)(m_unsafeCP_),0,m_unsafeCP_.Length);
	            m_contrEndCP_ = new sbyte[table.m_contrEndCP_.Length];
	            System.Array.Copy((Array)(table.m_contrEndCP_),0,(Array)(m_contrEndCP_),0,m_contrEndCP_.Length);
	        }
	
	        // package private data members -------------------------------------
	
	        internal RuleBasedCollator m_collator_;
	
	        internal IntTrieBuilder m_mapping_;
	
	        internal ArrayList m_expansions_;
	
	        internal CollationParsedRuleBuilder.ContractionTable  m_contractions_;
	
	        // UCATableHeader image;
	        internal CollationRuleParser.OptionSet m_options_;
	
	        internal CollationParsedRuleBuilder.MaxExpansionTable  m_maxExpansions_;
	
	        internal CollationParsedRuleBuilder.MaxJamoExpansionTable  m_maxJamoExpansions_;
	
	        internal sbyte[] m_unsafeCP_;
	
	        internal sbyte[] m_contrEndCP_;
	
	        internal Hashtable m_prefixLookup_;
	
	        internal CollationParsedRuleBuilder.CombinClassTable  cmLookup;
	    }
	
	    private class Elements {
	        // package private data members -------------------------------------
	
	        internal String m_prefixChars_;
	
	        internal int m_prefix_;
	
	        internal String m_uchars_;
	
	        /// <summary>
	        /// Working string
	        /// </summary>
	        ///
	        internal String m_cPoints_;
	
	        /// <summary>
	        /// Offset to the working string
	        /// </summary>
	        ///
	        internal int m_cPointsOffset_;
	
	        /// <summary>
	        /// These are collation elements - there could be more than one - in case of expansion
	        /// </summary>
	        ///
	        internal int[] m_CEs_;
	
	        internal int m_CELength_;
	
	        /// <summary>
	        /// This is the value element maps in original table
	        /// </summary>
	        ///
	        internal int m_mapCE_;
	
	        internal int[] m_sizePrim_;
	
	        internal int[] m_sizeSec_;
	
	        internal int[] m_sizeTer_;
	
	        internal bool m_variableTop_;
	
	        internal bool m_caseBit_;
	
	        // package private constructors -------------------------------------
	
	        /// <summary>
	        /// Package private constructor
	        /// </summary>
	        ///
	        internal Elements() {
	            m_sizePrim_ = new int[128];
	            m_sizeSec_ = new int[128];
	            m_sizeTer_ = new int[128];
	            m_CEs_ = new int[256];
	            m_CELength_ = 0;
	        }
	
	        /// <summary>
	        /// Package private constructor
	        /// </summary>
	        ///
	        internal Elements(CollationParsedRuleBuilder.Elements  element) {
	            m_prefixChars_ = element.m_prefixChars_;
	            m_prefix_ = element.m_prefix_;
	            m_uchars_ = element.m_uchars_;
	            m_cPoints_ = element.m_cPoints_;
	            m_cPointsOffset_ = element.m_cPointsOffset_;
	            m_CEs_ = element.m_CEs_;
	            m_CELength_ = element.m_CELength_;
	            m_mapCE_ = element.m_mapCE_;
	            m_sizePrim_ = element.m_sizePrim_;
	            m_sizeSec_ = element.m_sizeSec_;
	            m_sizeTer_ = element.m_sizeTer_;
	            m_variableTop_ = element.m_variableTop_;
	            m_caseBit_ = element.m_caseBit_;
	        }
	
	        // package private methods -------------------------------------------
	
	        /// <summary>
	        /// Initializing the elements
	        /// </summary>
	        ///
	        public void Clear() {
	            m_prefixChars_ = null;
	            m_prefix_ = 0;
	            m_uchars_ = null;
	            m_cPoints_ = null;
	            m_cPointsOffset_ = 0;
	            m_CELength_ = 0;
	            m_mapCE_ = 0;
	            ILOG.J2CsMapping.Collections.Arrays.Fill(m_sizePrim_,0);
	            ILOG.J2CsMapping.Collections.Arrays.Fill(m_sizeSec_,0);
	            ILOG.J2CsMapping.Collections.Arrays.Fill(m_sizeTer_,0);
	            m_variableTop_ = false;
	            m_caseBit_ = false;
	        }
	
	        /// <summary>
	        /// Hashcode calculation for token
	        /// </summary>
	        ///
	        /// <returns>the hashcode</returns>
	        public override int GetHashCode() {
	            String str = m_cPoints_.Substring(m_cPointsOffset_);
	            return str.GetHashCode();
	        }
	
	        /// <summary>
	        /// Equals calculation
	        /// </summary>
	        ///
	        /// <param name="target">object to compare</param>
	        /// <returns>true if target is the same as this object</returns>
	        public override bool Equals(Object target) {
	            if (target == (Object) this) {
	                return true;
	            }
	            if (target  is  CollationParsedRuleBuilder.Elements ) {
	                CollationParsedRuleBuilder.Elements  t = (CollationParsedRuleBuilder.Elements ) target;
	                int size_0 = m_cPoints_.Length - m_cPointsOffset_;
	                if (size_0 == t.m_cPoints_.Length - t.m_cPointsOffset_) {
                        return StringUtil.RegionMatches(t.m_cPoints_, t.m_cPointsOffset_,
	                            m_cPoints_, m_cPointsOffset_, size_0);
	                }
	            }
	            return false;
	        }
	    }
	
	    // private data member ---------------------------------------------------
	
	    /// <summary>
	    /// Maximum strength used in CE building
	    /// </summary>
	    ///
	    private const int CE_BASIC_STRENGTH_LIMIT_ = 3;
	
	    /// <summary>
	    /// Maximum collation strength
	    /// </summary>
	    ///
	    private const int CE_STRENGTH_LIMIT_ = 16;
	
	    /// <summary>
	    /// Strength mask array, used in inverse UCA
	    /// </summary>
	    ///
	    private static readonly int[] STRENGTH_MASK_ = { -65536, -256,
	            -1 };
	
	    /// <summary>
	    /// CE tag for not found
	    /// </summary>
	    ///
	    private const int CE_NOT_FOUND_ = -268435456;
	
	    /// <summary>
	    /// CE tag for not found
	    /// </summary>
	    ///
	    private const int CE_NOT_FOUND_TAG_ = 0;
	
	    /// <summary>
	    /// This code point results in an expansion
	    /// </summary>
	    ///
	    private const int CE_EXPANSION_TAG_ = 1;
	
	    /// <summary>
	    /// Start of a contraction
	    /// </summary>
	    ///
	    private const int CE_CONTRACTION_TAG_ = 2;
	
	    /*
	     * Thai character - do the reordering
	     */
	    // private static final int CE_THAI_TAG_ = 3;
	    /*
	     * Charset processing, not yet implemented
	     */
	    // private static final int CE_CHARSET_TAG_ = 4;
	    /// <summary>
	    /// Lead surrogate that is tailored and doesn't start a contraction
	    /// </summary>
	    ///
	    private const int CE_SURROGATE_TAG_ = 5;
	
	    /*
	     * AC00-D7AF
	     */
	    // private static final int CE_HANGUL_SYLLABLE_TAG_ = 6;
	    /*
	     * D800-DBFF
	     */
	    // private static final int CE_LEAD_SURROGATE_TAG_ = 7;
	    /*
	     * DC00-DFFF
	     */
	    // private static final int CE_TRAIL_SURROGATE_TAG_ = 8;
	    /*
	     * 0x3400-0x4DB5, 0x4E00-0x9FA5, 0xF900-0xFA2D
	     */
	    // private static final int CE_CJK_IMPLICIT_TAG_ = 9;
	    private const int CE_IMPLICIT_TAG_ = 10;
	
	    private const int CE_SPEC_PROC_TAG_ = 11;
	
	    /// <summary>
	    /// This is a three byte primary with starting secondaries and tertiaries. It
	    /// fits in a single 32 bit CE and is used instead of expansion to save space
	    /// without affecting the performance (hopefully)
	    /// </summary>
	    ///
	    private const int CE_LONG_PRIMARY_TAG_ = 12;
	
	    /// <summary>
	    /// Unsafe UChar hash table table size. Size is 32 bytes for 1 bit for each
	    /// latin 1 char + some power of two for hashing the rest of the chars. Size
	    /// in bytes
	    /// </summary>
	    ///
	    private const int UNSAFECP_TABLE_SIZE_ = 1056;
	
	    /// <summary>
	    /// Mask value down to "some power of two" -1. Number of bits, not num of
	    /// bytes.
	    /// </summary>
	    ///
	    private const int UNSAFECP_TABLE_MASK_ = 0x1fff;
	
	    /// <summary>
	    /// Case values
	    /// </summary>
	    ///
	    private const int UPPER_CASE_ = 0x80;
	
	    private const int MIXED_CASE_ = 0x40;
	
	    private const int LOWER_CASE_ = 0x00;
	
	    /*
	     * Initial table size
	     */
	    // private static final int INIT_TABLE_SIZE_ = 1028;
	    /*
	     * Header size, copied from ICU4C, to be changed when that value changes
	     */
	    // private static final int HEADER_SIZE_ = 0xC4;
	    /// <summary>
	    /// Contraction table new element indicator
	    /// </summary>
	    ///
	    private const int CONTRACTION_TABLE_NEW_ELEMENT_ = 0xFFFFFF;
	
	    /// <summary>
	    /// Parser for the rules
	    /// </summary>
	    ///
	    private CollationRuleParser m_parser_;
	
	    /// <summary>
	    /// Utility UCA collation element iterator
	    /// </summary>
	    ///
	    private CollationElementIterator m_utilColEIter_;
	
	    /// <summary>
	    /// Utility data members
	    /// </summary>
	    ///
	    private CollationParsedRuleBuilder.CEGenerator [] m_utilGens_;
	
	    private int[] m_utilCEBuffer_;
	
	    private int[] m_utilIntBuffer_;
	
	    private CollationParsedRuleBuilder.Elements  m_utilElement_;
	
	    private CollationParsedRuleBuilder.Elements  m_utilElement2_;
	
	    private CollationRuleParser.Token m_utilToken_;
	
	    private int[] m_utilCountBuffer_;
	
	    private long[] m_utilLongBuffer_;
	
	    private CollationParsedRuleBuilder.WeightRange [] m_utilLowerWeightRange_;
	
	    private CollationParsedRuleBuilder.WeightRange [] m_utilUpperWeightRange_;
	
	    private CollationParsedRuleBuilder.WeightRange  m_utilWeightRange_;
	
	    private char[] m_utilCharBuffer_;
	
	    private CanonicalIterator m_utilCanIter_;
	
	    private StringBuilder m_utilStringBuffer_;
	
	    // Flag indicating a combining marks table is required or not.
	    private static bool buildCMTabFlag = false;
	
	    // private methods -------------------------------------------------------
	
	    
	    /// <param name="listheader">parsed rule tokens</param>
	    /// <exception cref="Exception">thrown when internal error occurs</exception>
	    private void InitBuffers(CollationRuleParser.TokenListHeader listheader) {
	        CollationRuleParser.Token token = listheader.m_last_;
	        ILOG.J2CsMapping.Collections.Arrays.Fill(m_utilIntBuffer_,0,CE_STRENGTH_LIMIT_,0);
	
	        token.m_toInsert_ = 1;
	        m_utilIntBuffer_[token.m_strength_] = 1;
	        while (token.m_previous_ != null) {
	            if (token.m_previous_.m_strength_ < token.m_strength_) {
	                // going up
	                m_utilIntBuffer_[token.m_strength_] = 0;
	                m_utilIntBuffer_[token.m_previous_.m_strength_]++;
	            } else if (token.m_previous_.m_strength_ > token.m_strength_) {
	                // going down
	                m_utilIntBuffer_[token.m_previous_.m_strength_] = 1;
	            } else {
	                m_utilIntBuffer_[token.m_strength_]++;
	            }
	            token = token.m_previous_;
	            token.m_toInsert_ = m_utilIntBuffer_[token.m_strength_];
	        }
	
	        token.m_toInsert_ = m_utilIntBuffer_[token.m_strength_];
	        INVERSE_UCA_.GetInverseGapPositions(listheader);
	
	        token = listheader.m_first_;
	        int fstrength = IBM.ICU.Text.Collator.IDENTICAL;
	        int initstrength = IBM.ICU.Text.Collator.IDENTICAL;
	
	        m_utilCEBuffer_[IBM.ICU.Text.Collator.PRIMARY] = MergeCE(listheader.m_baseCE_,
	                listheader.m_baseContCE_, IBM.ICU.Text.Collator.PRIMARY);
	        m_utilCEBuffer_[IBM.ICU.Text.Collator.SECONDARY] = MergeCE(listheader.m_baseCE_,
	                listheader.m_baseContCE_, IBM.ICU.Text.Collator.SECONDARY);
	        m_utilCEBuffer_[IBM.ICU.Text.Collator.TERTIARY] = MergeCE(listheader.m_baseCE_,
	                listheader.m_baseContCE_, IBM.ICU.Text.Collator.TERTIARY);
	        while (token != null) {
	            fstrength = token.m_strength_;
	            if (fstrength < initstrength) {
	                initstrength = fstrength;
	                if (listheader.m_pos_[fstrength] == -1) {
	                    while (listheader.m_pos_[fstrength] == -1 && fstrength > 0) {
	                        fstrength--;
	                    }
	                    if (listheader.m_pos_[fstrength] == -1) {
	                        throw new Exception("Internal program error");
	                    }
	                }
	                if (initstrength == IBM.ICU.Text.Collator.TERTIARY) {
	                    // starting with tertiary
	                    m_utilCEBuffer_[IBM.ICU.Text.Collator.PRIMARY] = listheader.m_gapsLo_[fstrength * 3];
	                    m_utilCEBuffer_[IBM.ICU.Text.Collator.SECONDARY] = listheader.m_gapsLo_[fstrength * 3 + 1];
	                    m_utilCEBuffer_[IBM.ICU.Text.Collator.TERTIARY] = GetCEGenerator(
	                            m_utilGens_[IBM.ICU.Text.Collator.TERTIARY],
	                            listheader.m_gapsLo_, listheader.m_gapsHi_, token,
	                            fstrength);
	                } else if (initstrength == IBM.ICU.Text.Collator.SECONDARY) {
	                    // secondaries
	                    m_utilCEBuffer_[IBM.ICU.Text.Collator.PRIMARY] = listheader.m_gapsLo_[fstrength * 3];
	                    m_utilCEBuffer_[IBM.ICU.Text.Collator.SECONDARY] = GetCEGenerator(
	                            m_utilGens_[IBM.ICU.Text.Collator.SECONDARY],
	                            listheader.m_gapsLo_, listheader.m_gapsHi_, token,
	                            fstrength);
	                    m_utilCEBuffer_[IBM.ICU.Text.Collator.TERTIARY] = GetSimpleCEGenerator(
	                            m_utilGens_[IBM.ICU.Text.Collator.TERTIARY], token,
	                            IBM.ICU.Text.Collator.TERTIARY);
	                } else {
	                    // primaries
	                    m_utilCEBuffer_[IBM.ICU.Text.Collator.PRIMARY] = GetCEGenerator(
	                            m_utilGens_[IBM.ICU.Text.Collator.PRIMARY],
	                            listheader.m_gapsLo_, listheader.m_gapsHi_, token,
	                            fstrength);
	                    m_utilCEBuffer_[IBM.ICU.Text.Collator.SECONDARY] = GetSimpleCEGenerator(
	                            m_utilGens_[IBM.ICU.Text.Collator.SECONDARY], token,
	                            IBM.ICU.Text.Collator.SECONDARY);
	                    m_utilCEBuffer_[IBM.ICU.Text.Collator.TERTIARY] = GetSimpleCEGenerator(
	                            m_utilGens_[IBM.ICU.Text.Collator.TERTIARY], token,
	                            IBM.ICU.Text.Collator.TERTIARY);
	                }
	            } else {
	                if (token.m_strength_ == IBM.ICU.Text.Collator.TERTIARY) {
	                    m_utilCEBuffer_[IBM.ICU.Text.Collator.TERTIARY] = GetNextGenerated(m_utilGens_[IBM.ICU.Text.Collator.TERTIARY]);
	                } else if (token.m_strength_ == IBM.ICU.Text.Collator.SECONDARY) {
	                    m_utilCEBuffer_[IBM.ICU.Text.Collator.SECONDARY] = GetNextGenerated(m_utilGens_[IBM.ICU.Text.Collator.SECONDARY]);
	                    m_utilCEBuffer_[IBM.ICU.Text.Collator.TERTIARY] = GetSimpleCEGenerator(
	                            m_utilGens_[IBM.ICU.Text.Collator.TERTIARY], token,
	                            IBM.ICU.Text.Collator.TERTIARY);
	                } else if (token.m_strength_ == IBM.ICU.Text.Collator.PRIMARY) {
	                    m_utilCEBuffer_[IBM.ICU.Text.Collator.PRIMARY] = GetNextGenerated(m_utilGens_[IBM.ICU.Text.Collator.PRIMARY]);
	                    m_utilCEBuffer_[IBM.ICU.Text.Collator.SECONDARY] = GetSimpleCEGenerator(
	                            m_utilGens_[IBM.ICU.Text.Collator.SECONDARY], token,
	                            IBM.ICU.Text.Collator.SECONDARY);
	                    m_utilCEBuffer_[IBM.ICU.Text.Collator.TERTIARY] = GetSimpleCEGenerator(
	                            m_utilGens_[IBM.ICU.Text.Collator.TERTIARY], token,
	                            IBM.ICU.Text.Collator.TERTIARY);
	                }
	            }
	            DoCE(m_utilCEBuffer_, token);
	            token = token.m_next_;
	        }
	    }
	
	    /// <summary>
	    /// Get the next generated ce
	    /// </summary>
	    ///
	    /// <param name="g">ce generator</param>
	    /// <returns>next generated ce</returns>
	    private int GetNextGenerated(CollationParsedRuleBuilder.CEGenerator  g) {
	        g.m_current_ = NextWeight(g);
	        return g.m_current_;
	    }
	
	    
	    /// <param name="g">CEGenerator</param>
	    /// <param name="token">rule token</param>
	    /// <param name="strength"></param>
	    /// <returns>ce generator</returns>
	    /// <exception cref="Exception">thrown when internal error occurs</exception>
	    private int GetSimpleCEGenerator(CollationParsedRuleBuilder.CEGenerator  g,
	            CollationRuleParser.Token token, int strength) {
	        int high, low, count = 1;
	        int maxbyte = (strength == IBM.ICU.Text.Collator.TERTIARY) ? 0x3F : 0xFF;
	
	        if (strength == IBM.ICU.Text.Collator.SECONDARY) {
	            low = IBM.ICU.Text.RuleBasedCollator.COMMON_TOP_2_ << 24;
	            high = -1;
	            count = 0xFF - IBM.ICU.Text.RuleBasedCollator.COMMON_TOP_2_;
	        } else {
	            low = IBM.ICU.Text.RuleBasedCollator.BYTE_COMMON_ << 24; // 0x05000000;
	            high = 0x40000000;
	            count = 0x40 - IBM.ICU.Text.RuleBasedCollator.BYTE_COMMON_;
	        }
	
	        if (token.m_next_ != null && token.m_next_.m_strength_ == strength) {
	            count = token.m_next_.m_toInsert_;
	        }
	
	        g.m_rangesLength_ = AllocateWeights(low, high, count, maxbyte,
	                g.m_ranges_);
	        g.m_current_ = IBM.ICU.Text.RuleBasedCollator.BYTE_COMMON_ << 24;
	
	        if (g.m_rangesLength_ == 0) {
	            throw new Exception("Internal program error");
	        }
	        return g.m_current_;
	    }
	
	    /// <summary>
	    /// Combines 2 ce into one with respect to the argument strength
	    /// </summary>
	    ///
	    /// <param name="ce1">first ce</param>
	    /// <param name="ce2">second ce</param>
	    /// <param name="strength">strength to use</param>
	    /// <returns>combined ce</returns>
	    private static int MergeCE(int ce1, int ce2, int strength) {
	        int mask = IBM.ICU.Text.RuleBasedCollator.CE_TERTIARY_MASK_;
	        if (strength == IBM.ICU.Text.Collator.SECONDARY) {
	            mask = IBM.ICU.Text.RuleBasedCollator.CE_SECONDARY_MASK_;
	        } else if (strength == IBM.ICU.Text.Collator.PRIMARY) {
	            mask = IBM.ICU.Text.RuleBasedCollator.CE_PRIMARY_MASK_;
	        }
	        ce1 &= mask;
	        ce2 &= mask;
	        switch (strength) {
	        case IBM.ICU.Text.Collator.PRIMARY:
	            return ce1 |MathUtil.URS(ce2, 16);
	        case IBM.ICU.Text.Collator.SECONDARY:
	            return ce1 << 16 | ce2 << 8;
	        default:
	            return ce1 << 24 | ce2 << 16;
	        }
	    }
	
	    
	    /// <param name="g">CEGenerator</param>
	    /// <param name="lows">low gap array</param>
	    /// <param name="highs">high gap array</param>
	    /// <param name="token">rule token</param>
	    /// <param name="fstrength"></param>
	    /// <exception cref="Exception">thrown when internal error occurs</exception>
	    private int GetCEGenerator(CollationParsedRuleBuilder.CEGenerator  g, int[] lows, int[] highs,
	            CollationRuleParser.Token token, int fstrength) {
	        int strength = token.m_strength_;
	        int low = lows[fstrength * 3 + strength];
	        int high = highs[fstrength * 3 + strength];
	        int maxbyte = 0;
	        if (strength == IBM.ICU.Text.Collator.TERTIARY) {
	            maxbyte = 0x3F;
	        } else if (strength == IBM.ICU.Text.Collator.PRIMARY) {
	            maxbyte = 0xFE;
	        } else {
	            maxbyte = 0xFF;
	        }
	
	        int count = token.m_toInsert_;
	
	        if (IBM.ICU.Impl.Utility.CompareUnsigned(low, high) >= 0
	                && strength > IBM.ICU.Text.Collator.PRIMARY) {
	            int s = strength;
	            while (true) {
	                s--;
	                if (lows[fstrength * 3 + s] != highs[fstrength * 3 + s]) {
	                    if (strength == IBM.ICU.Text.Collator.SECONDARY) {
	                        low = IBM.ICU.Text.RuleBasedCollator.COMMON_TOP_2_ << 24;
	                        high = -1;
	                    } else {
	                        // low = 0x02000000;
	                        // This needs to be checked - what if low is
	                        // not good...
	                        high = 0x40000000;
	                    }
	                    break;
	                }
	                if (s < 0) {
	                    throw new Exception("Internal program error");
	                }
	            }
	        }
	        if (low == 0) {
	            low = 0x01000000;
	        }
	        if (strength == IBM.ICU.Text.Collator.SECONDARY) { // similar as simple
	            if (IBM.ICU.Impl.Utility.CompareUnsigned(low,
	                    IBM.ICU.Text.RuleBasedCollator.COMMON_BOTTOM_2_ << 24) >= 0
	                    && IBM.ICU.Impl.Utility.CompareUnsigned(low,
	                            IBM.ICU.Text.RuleBasedCollator.COMMON_TOP_2_ << 24) < 0) {
	                low = IBM.ICU.Text.RuleBasedCollator.COMMON_TOP_2_ << 24;
	            }
	            if (IBM.ICU.Impl.Utility.CompareUnsigned(high,
	                    IBM.ICU.Text.RuleBasedCollator.COMMON_BOTTOM_2_ << 24) > 0
	                    && IBM.ICU.Impl.Utility.CompareUnsigned(high,
	                            IBM.ICU.Text.RuleBasedCollator.COMMON_TOP_2_ << 24) < 0) {
	                high = IBM.ICU.Text.RuleBasedCollator.COMMON_TOP_2_ << 24;
	            }
	            if (IBM.ICU.Impl.Utility.CompareUnsigned(low,
	                    IBM.ICU.Text.RuleBasedCollator.COMMON_BOTTOM_2_ << 24) < 0) {
	                g.m_rangesLength_ = AllocateWeights(
	                        IBM.ICU.Text.RuleBasedCollator.BYTE_UNSHIFTED_MIN_ << 24, high,
	                        count, maxbyte, g.m_ranges_);
	                g.m_current_ = NextWeight(g);
	                // g.m_current_ = RuleBasedCollator.COMMON_BOTTOM_2_ << 24;
	                return g.m_current_;
	            }
	        }
	
	        g.m_rangesLength_ = AllocateWeights(low, high, count, maxbyte,
	                g.m_ranges_);
	        if (g.m_rangesLength_ == 0) {
	            throw new Exception("Internal program error");
	        }
	        g.m_current_ = NextWeight(g);
	        return g.m_current_;
	    }
	
	    
	    /// <param name="ceparts">list of collation elements parts</param>
	    /// <param name="token">rule token</param>
	    /// <exception cref="Exception">thrown when forming case bits for expansions fails</exception>
	    private void DoCE(int[] ceparts, CollationRuleParser.Token token) {
	        // this one makes the table and stuff
	        // int noofbytes[] = new int[3];
	        for (int i = 0; i < 3; i++) {
	            // noofbytes[i] = countBytes(ceparts[i]);
	            m_utilIntBuffer_[i] = CountBytes(ceparts[i]);
	        }
	
	        // Here we have to pack CEs from parts
	        int cei = 0;
	        int value_ren = 0;
	
	        while ((cei << 1) < m_utilIntBuffer_[0] || cei < m_utilIntBuffer_[1]
	                || cei < m_utilIntBuffer_[2]) {
	            if (cei > 0) {
	                value_ren = IBM.ICU.Text.RuleBasedCollator.CE_CONTINUATION_MARKER_;
	            } else {
	                value_ren = 0;
	            }
	
	            if ((cei << 1) < m_utilIntBuffer_[0]) {
	                value_ren |= ((ceparts[0] >> (32 - ((cei + 1) << 4))) & 0xFFFF) << 16;
	            }
	            if (cei < m_utilIntBuffer_[1]) {
	                value_ren |= ((ceparts[1] >> (32 - ((cei + 1) << 3))) & 0xFF) << 8;
	            }
	
	            if (cei < m_utilIntBuffer_[2]) {
	                value_ren |= ((ceparts[2] >> (32 - ((cei + 1) << 3))) & 0x3F);
	            }
	            token.m_CE_[cei] = value_ren;
	            cei++;
	        }
	        if (cei == 0) { // totally ignorable
	            token.m_CELength_ = 1;
	            token.m_CE_[0] = 0;
	        } else { // there is at least something
	            token.m_CELength_ = cei;
	        }
	
	        // Case bits handling for expansion
	        if (token.m_CE_[0] != 0) { // case bits should be set only for
	                                   // non-ignorables
	            int startoftokenrule = token.m_source_ & 0xFF;
	            if (MathUtil.URS(token.m_source_, 24) > 1) {
	                // Do it manually
	                int length = MathUtil.URS(token.m_source_, 24);
	                String tokenstr = token.m_rules_.ToString(startoftokenrule,startoftokenrule + length-startoftokenrule);
	                token.m_CE_[0] |= GetCaseBits(tokenstr);
	            } else {
	                // Copy it from the UCA
	                int caseCE = GetFirstCE(token.m_rules_[startoftokenrule]);
	                token.m_CE_[0] |= (caseCE & 0xC0);
	            }
	        }
	    }
	
	    /// <summary>
	    /// Count the number of non-zero bytes used in the ce
	    /// </summary>
	    ///
	    /// <param name="ce"></param>
	    /// <returns>number of non-zero bytes used in ce</returns>
	    private static int CountBytes(int ce) {
	        int mask = -1;
	        int result = 0;
	        while (mask != 0) {
	            if ((ce & mask) != 0) {
	                result++;
	            }
	            mask = MathUtil.URS(mask, 8);
	        }
	        return result;
	    }
	
	    /// <summary>
	    /// We are ready to create collation elements
	    /// </summary>
	    ///
	    /// <param name="t">build table to insert</param>
	    /// <param name="lh">rule token list header</param>
	    private void CreateElements(CollationParsedRuleBuilder.BuildTable  t,
	            CollationRuleParser.TokenListHeader lh) {
	        CollationRuleParser.Token tok = lh.m_first_;
	        m_utilElement_.Clear();
	        while (tok != null) {
	            // first, check if there are any expansions
	            // if there are expansions, we need to do a little bit more
	            // processing since parts of expansion can be tailored, while
	            // others are not
	            if (tok.m_expansion_ != 0) {
	                int len = MathUtil.URS(tok.m_expansion_, 24);
	                int currentSequenceLen = len;
	                int expOffset = tok.m_expansion_ & 0x00FFFFFF;
	                m_utilToken_.m_source_ = currentSequenceLen | expOffset;
	                m_utilToken_.m_rules_ = m_parser_.m_source_;
	
	                while (len > 0) {
	                    currentSequenceLen = len;
	                    while (currentSequenceLen > 0) {
	                        m_utilToken_.m_source_ = (currentSequenceLen << 24)
	                                | expOffset;
	                        CollationRuleParser.Token expt = (CollationRuleParser.Token) m_parser_.m_hashTable_[m_utilToken_];
	                        if (expt != null
	                                && expt.m_strength_ != IBM.ICU.Text.CollationRuleParser.TOKEN_RESET_) {
	                            // expansion is tailored
	                            int noOfCEsToCopy = expt.m_CELength_;
	                            for (int j = 0; j < noOfCEsToCopy; j++) {
	                                tok.m_expCE_[tok.m_expCELength_ + j] = expt.m_CE_[j];
	                            }
	                            tok.m_expCELength_ += noOfCEsToCopy;
	                            // never try to add codepoints and CEs.
	                            // For some odd reason, it won't work.
	                            expOffset += currentSequenceLen; // noOfCEsToCopy;
	                            len -= currentSequenceLen; // noOfCEsToCopy;
	                            break;
	                        } else {
	                            currentSequenceLen--;
	                        }
	                    }
	                    if (currentSequenceLen == 0) {
	                        // couldn't find any tailored subsequence, will have to
	                        // get one from UCA. first, get the UChars from the
	                        // rules then pick CEs out until there is no more and
	                        // stuff them into expansion
	                        m_utilColEIter_.SetText(m_parser_.m_source_.ToString(expOffset,expOffset + 1-expOffset));
	                        while (true) {
	                            int order = m_utilColEIter_.Next();
	                            if (order == IBM.ICU.Text.CollationElementIterator.NULLORDER) {
	                                break;
	                            }
	                            tok.m_expCE_[tok.m_expCELength_++] = order;
	                        }
	                        expOffset++;
	                        len--;
	                    }
	                }
	            } else {
	                tok.m_expCELength_ = 0;
	            }
	
	            // set the ucaelement with obtained values
	            m_utilElement_.m_CELength_ = tok.m_CELength_ + tok.m_expCELength_;
	
	            // copy CEs
	            System.Array.Copy((Array)(tok.m_CE_),0,(Array)(m_utilElement_.m_CEs_),0,tok.m_CELength_);
	            System.Array.Copy((Array)(tok.m_expCE_),0,(Array)(m_utilElement_.m_CEs_),tok.m_CELength_,tok.m_expCELength_);
	
	            // copy UChars
	            // We kept prefix and source kind of together, as it is a kind of a
	            // contraction.
	            // However, now we have to slice the prefix off the main thing -
	            m_utilElement_.m_prefix_ = 0;// el.m_prefixChars_;
	            m_utilElement_.m_cPointsOffset_ = 0; // el.m_uchars_;
	            if (tok.m_prefix_ != 0) {
	                // we will just copy the prefix here, and adjust accordingly in
	                // the addPrefix function in ucol_elm. The reason is that we
	                // need to add both composed AND decomposed elements to the
	                // unsafe table.
	                int size_0 = tok.m_prefix_ >> 24;
	                int offset = tok.m_prefix_ & 0x00FFFFFF;
	                m_utilElement_.m_prefixChars_ = m_parser_.m_source_.ToString(offset,offset + size_0-offset);
	                size_0 = (tok.m_source_ >> 24) - (tok.m_prefix_ >> 24);
	                offset = (tok.m_source_ & 0x00FFFFFF) + (tok.m_prefix_ >> 24);
	                m_utilElement_.m_uchars_ = m_parser_.m_source_.ToString(offset,offset + size_0-offset);
	            } else {
	                m_utilElement_.m_prefixChars_ = null;
	                int offset_1 = tok.m_source_ & 0x00FFFFFF;
	                int size_2 = MathUtil.URS(tok.m_source_, 24);
	                m_utilElement_.m_uchars_ = m_parser_.m_source_.ToString(offset_1,offset_1 + size_2-offset_1);
	            }
	            m_utilElement_.m_cPoints_ = m_utilElement_.m_uchars_;
	
	            bool containCombinMarks = false;
	            for (int i = 0; i < m_utilElement_.m_cPoints_.Length
	                    - m_utilElement_.m_cPointsOffset_; i++) {
	                if (IsJamo(m_utilElement_.m_cPoints_[i])) {
	                    t.m_collator_.m_isJamoSpecial_ = true;
	                    break;
	                }
	                if (!buildCMTabFlag) {
	                    // check combining class
	                    char fcd = IBM.ICU.Impl.NormalizerImpl
	                            .GetFCD16(m_utilElement_.m_cPoints_[i]);
	                    if ((fcd & 0xff) == 0) {
	                        // reset flag when current char is not combining mark.
	                        containCombinMarks = false;
	                    } else {
	                        containCombinMarks = true;
	                    }
	                }
	            }
	
	            if (!buildCMTabFlag && containCombinMarks) {
	                buildCMTabFlag = true;
	            }
	
	            /***
	             * // Case bits handling m_utilElement_.m_CEs_[0] &= 0xFFFFFF3F; //
	             * Clean the case bits field if (m_utilElement_.m_cPoints_.length()
	             * - m_utilElement_.m_cPointsOffset_ > 1) { // Do it manually
	             * m_utilElement_.m_CEs_[0] |=
	             * getCaseBits(m_utilElement_.m_cPoints_); } else { // Copy it from
	             * the UCA int caseCE =
	             * getFirstCE(m_utilElement_.m_cPoints_.charAt(0));
	             * m_utilElement_.m_CEs_[0] |= (caseCE & 0xC0); }
	             ***/
	            // and then, add it
	            AddAnElement(t, m_utilElement_);
	            tok = tok.m_next_;
	        }
	    }
	
	    /// <summary>
	    /// Testing if the string argument has case
	    /// </summary>
	    ///
	    /// <param name="src">string</param>
	    /// <returns>the case for this char array</returns>
	    /// <exception cref="Exception">thrown when internal program error occurs</exception>
	    private int GetCaseBits(String src) {
	        int uCount = 0;
	        int lCount = 0;
	        src = IBM.ICU.Text.Normalizer.Decompose(src, true);
	        m_utilColEIter_.SetText(src);
	        for (int i = 0; i < src.Length; i++) {
	            m_utilColEIter_.SetText(src.Substring(i,(i + 1)-(i)));
	            int order = m_utilColEIter_.Next();
	            if (IBM.ICU.Text.RuleBasedCollator.IsContinuation(order)) {
	                throw new Exception("Internal program error");
	            }
	            if ((order & IBM.ICU.Text.RuleBasedCollator.CE_CASE_BIT_MASK_) == UPPER_CASE_) {
	                uCount++;
	            } else {
	                char ch = src[i];
	                if (IBM.ICU.Lang.UCharacter.IsLowerCase(ch)) {
	                    lCount++;
	                } else {
	                    if (ToSmallKana(ch) == ch && ToLargeKana(ch) != ch) {
	                        lCount++;
	                    }
	                }
	            }
	        }
	
	        if (uCount != 0 && lCount != 0) {
	            return MIXED_CASE_;
	        } else if (uCount != 0) {
	            return UPPER_CASE_;
	        } else {
	            return LOWER_CASE_;
	        }
	    }
	
	    /// <summary>
	    /// Converts a char to the uppercase Kana
	    /// </summary>
	    ///
	    /// <param name="ch">character to convert</param>
	    /// <returns>the converted Kana character</returns>
	    private static char ToLargeKana(char ch) {
	        if (0x3042 < ch && ch < 0x30ef) { // Kana range
	            switch (ch - 0x3000) {
	            case 0x41:
	            case 0x43:
	            case 0x45:
	            case 0x47:
	            case 0x49:
	            case 0x63:
	            case 0x83:
	            case 0x85:
	            case 0x8E:
	            case 0xA1:
	            case 0xA3:
	            case 0xA5:
	            case 0xA7:
	            case 0xA9:
	            case 0xC3:
	            case 0xE3:
	            case 0xE5:
	            case 0xEE:
	                ch++;
	                break;
	            case 0xF5:
	                ch = ((Char)0x30AB);
	                break;
	            case 0xF6:
	                ch = ((Char)0x30B1);
	                break;
	            }
	        }
	        return ch;
	    }
	
	    /// <summary>
	    /// Converts a char to the lowercase Kana
	    /// </summary>
	    ///
	    /// <param name="ch">character to convert</param>
	    /// <returns>the converted Kana character</returns>
	    private static char ToSmallKana(char ch) {
	        if (0x3042 < ch && ch < 0x30ef) { // Kana range
	            switch (ch - 0x3000) {
	            case 0x42:
	            case 0x44:
	            case 0x46:
	            case 0x48:
	            case 0x4A:
	            case 0x64:
	            case 0x84:
	            case 0x86:
	            case 0x8F:
	            case 0xA2:
	            case 0xA4:
	            case 0xA6:
	            case 0xA8:
	            case 0xAA:
	            case 0xC4:
	            case 0xE4:
	            case 0xE6:
	            case 0xEF:
	                ch--;
	                break;
	            case 0xAB:
	                ch = ((Char)0x30F5);
	                break;
	            case 0xB1:
	                ch = ((Char)0x30F6);
	                break;
	            }
	        }
	        return ch;
	    }
	
	    /// <summary>
	    /// This should be connected to special Jamo handling.
	    /// </summary>
	    ///
	    private int GetFirstCE(char ch) {
	        m_utilColEIter_.SetText(IBM.ICU.Lang.UCharacter.ToString(ch));
	        return m_utilColEIter_.Next();
	    }
	
	    /// <summary>
	    /// This adds a read element, while testing for existence
	    /// </summary>
	    ///
	    /// <param name="t">build table</param>
	    /// <param name="element"></param>
	    /// <returns>ce</returns>
	    private int AddAnElement(CollationParsedRuleBuilder.BuildTable  t, CollationParsedRuleBuilder.Elements  element) {
	        ArrayList expansions = t.m_expansions_;
	        element.m_mapCE_ = 0;
	
	        if (element.m_CELength_ == 1) {
	            element.m_mapCE_ = element.m_CEs_[0];
	
	        } else {
	            // unfortunately, it looks like we have to look for a long primary
	            // here since in canonical closure we are going to hit some long
	            // primaries from the first phase, and they will come back as
	            // continuations/expansions destroying the effect of the previous
	            // opitimization. A long primary is a three byte primary with
	            // starting secondaries and tertiaries. It can appear in long runs
	            // of only primary differences (like east Asian tailorings) also,
	            // it should not be an expansion, as expansions would break with
	            // this
	            if (element.m_CELength_ == 2 // a two CE expansion
	                    && IBM.ICU.Text.RuleBasedCollator.IsContinuation(element.m_CEs_[1])
	                    && (element.m_CEs_[1] & (~(0xFF << 24 | IBM.ICU.Text.RuleBasedCollator.CE_CONTINUATION_MARKER_))) == 0 // that
	                                                                                                              // has
	                                                                                                              // only
	                                                                                                              // primaries
	                                                                                                              // in
	                                                                                                              // continuation
	                    && (((element.m_CEs_[0] >> 8) & 0xFF) == IBM.ICU.Text.RuleBasedCollator.BYTE_COMMON_)
	                    // a common secondary
	                    && ((element.m_CEs_[0] & 0xFF) == IBM.ICU.Text.RuleBasedCollator.BYTE_COMMON_) // and
	                                                                                      // a
	                                                                                      // common
	                                                                                      // tertiary
	            ) {
	                element.m_mapCE_ = IBM.ICU.Text.RuleBasedCollator.CE_SPECIAL_FLAG_
	                // a long primary special
	                        | (CE_LONG_PRIMARY_TAG_ << 24)
	                        // first and second byte of primary
	                        | ((element.m_CEs_[0] >> 8) & 0xFFFF00)
	                        // third byte of primary
	                        | ((element.m_CEs_[1] >> 24) & 0xFF);
	            } else {
	                // omitting expansion offset in builder
	                // (HEADER_SIZE_ >> 2)
	                int expansion = IBM.ICU.Text.RuleBasedCollator.CE_SPECIAL_FLAG_
	                        | (CE_EXPANSION_TAG_ << IBM.ICU.Text.RuleBasedCollator.CE_TAG_SHIFT_)
	                        | (AddExpansion(expansions, element.m_CEs_[0]) << 4)
	                        & 0xFFFFF0;
	
	                for (int i = 1; i < element.m_CELength_; i++) {
	                    AddExpansion(expansions, element.m_CEs_[i]);
	                }
	                if (element.m_CELength_ <= 0xF) {
	                    expansion |= element.m_CELength_;
	                } else {
	                    AddExpansion(expansions, 0);
	                }
	                element.m_mapCE_ = expansion;
	                SetMaxExpansion(element.m_CEs_[element.m_CELength_ - 1],
	                        (byte) element.m_CELength_, t.m_maxExpansions_);
	                if (IsJamo(element.m_cPoints_[0])) {
	                    t.m_collator_.m_isJamoSpecial_ = true;
	                    SetMaxJamoExpansion(element.m_cPoints_[0],
	                            element.m_CEs_[element.m_CELength_ - 1],
	                            (byte) element.m_CELength_, t.m_maxJamoExpansions_);
	                }
	            }
	        }
	
	        // We treat digits differently - they are "uber special" and should be
	        // processed differently if numeric collation is on.
	        int uniChar = 0;
	        if ((element.m_uchars_.Length == 2)
	                && IBM.ICU.Text.UTF16.IsLeadSurrogate(element.m_uchars_[0])) {
	            uniChar = IBM.ICU.Impl.UCharacterProperty.GetRawSupplementary(
	                    element.m_uchars_[0], element.m_uchars_[1]);
	        } else if (element.m_uchars_.Length == 1) {
	            uniChar = element.m_uchars_[0];
	        }
	
	        // Here, we either have one normal CE OR mapCE is set. Therefore, we
	        // stuff only one element to the expansion buffer. When we encounter a
	        // digit and we don't do numeric collation, we will just pick the CE
	        // we have and break out of case (see ucol.cpp ucol_prv_getSpecialCE
	        // && ucol_prv_getSpecialPrevCE). If we picked a special, further
	        // processing will occur. If it's a simple CE, we'll return due
	        // to how the loop is constructed.
	        if (uniChar != 0 && IBM.ICU.Lang.UCharacter.IsDigit(uniChar)) {
	            // prepare the element
	            int expansion_0 = IBM.ICU.Text.RuleBasedCollator.CE_SPECIAL_FLAG_
	                    | (IBM.ICU.Text.CollationElementIterator.CE_DIGIT_TAG_ << IBM.ICU.Text.RuleBasedCollator.CE_TAG_SHIFT_)
	                    | 1;
	            if (element.m_mapCE_ != 0) {
	                // if there is an expansion, we'll pick it here
	                expansion_0 |= (AddExpansion(expansions, element.m_mapCE_) << 4);
	            } else {
	                expansion_0 |= (AddExpansion(expansions, element.m_CEs_[0]) << 4);
	            }
	            element.m_mapCE_ = expansion_0;
	        }
	
	        // here we want to add the prefix structure.
	        // I will try to process it as a reverse contraction, if possible.
	        // prefix buffer is already reversed.
	
	        if (element.m_prefixChars_ != null
	                && element.m_prefixChars_.Length - element.m_prefix_ > 0) {
	            // We keep the seen prefix starter elements in a hashtable we need
	            // it to be able to distinguish between the simple codepoints and
	            // prefix starters. Also, we need to use it for canonical closure.
	            m_utilElement2_.m_caseBit_ = element.m_caseBit_;
	            m_utilElement2_.m_CELength_ = element.m_CELength_;
	            m_utilElement2_.m_CEs_ = element.m_CEs_;
	            m_utilElement2_.m_mapCE_ = element.m_mapCE_;
	            // m_utilElement2_.m_prefixChars_ = element.m_prefixChars_;
	            m_utilElement2_.m_sizePrim_ = element.m_sizePrim_;
	            m_utilElement2_.m_sizeSec_ = element.m_sizeSec_;
	            m_utilElement2_.m_sizeTer_ = element.m_sizeTer_;
	            m_utilElement2_.m_variableTop_ = element.m_variableTop_;
	            m_utilElement2_.m_prefix_ = element.m_prefix_;
	            m_utilElement2_.m_prefixChars_ = IBM.ICU.Text.Normalizer.Compose(
	                    element.m_prefixChars_, false);
	            m_utilElement2_.m_uchars_ = element.m_uchars_;
	            m_utilElement2_.m_cPoints_ = element.m_cPoints_;
	            m_utilElement2_.m_cPointsOffset_ = 0;
	
	            if (t.m_prefixLookup_ != null) {
	                CollationParsedRuleBuilder.Elements  uCE = (CollationParsedRuleBuilder.Elements ) t.m_prefixLookup_[element];
	                if (uCE != null) {
	                    // there is already a set of code points here
	                    element.m_mapCE_ = AddPrefix(t, uCE.m_mapCE_, element);
	                } else { // no code points, so this spot is clean
	                    element.m_mapCE_ = AddPrefix(t, CE_NOT_FOUND_, element);
	                    uCE = new CollationParsedRuleBuilder.Elements (element);
	                    uCE.m_cPoints_ = uCE.m_uchars_;
	                    ILOG.J2CsMapping.Collections.Collections.Put(t.m_prefixLookup_,uCE,uCE);
	                }
	                if (m_utilElement2_.m_prefixChars_.Length != element.m_prefixChars_.Length - element.m_prefix_
	                        || ! StringUtil.RegionMatches(m_utilElement2_.m_prefixChars_, 0,
	                                element.m_prefixChars_, element.m_prefix_,
	                                m_utilElement2_.m_prefixChars_.Length)) {
	                    // do it!
	                    m_utilElement2_.m_mapCE_ = AddPrefix(t, element.m_mapCE_,
	                            m_utilElement2_);
	                }
	            }
	        }
	
	        // We need to use the canonical iterator here
	        // the way we do it is to generate the canonically equivalent strings
	        // for the contraction and then add the sequences that pass FCD check
	        if (element.m_cPoints_.Length - element.m_cPointsOffset_ > 1
	                && !(element.m_cPoints_.Length - element.m_cPointsOffset_ == 2
	                        && IBM.ICU.Text.UTF16.IsLeadSurrogate(element.m_cPoints_[0]) && IBM.ICU.Text.UTF16
	                        .IsTrailSurrogate(element.m_cPoints_[1]))) {
	            // this is a contraction, we should check whether a composed form
	            // should also be included
	            m_utilCanIter_.SetSource(element.m_cPoints_);
	            String source = m_utilCanIter_.Next();
	            while (source != null && source.Length > 0) {
	                if (IBM.ICU.Text.Normalizer.QuickCheck(source, IBM.ICU.Text.Normalizer.FCD, 0) != IBM.ICU.Text.Normalizer.NO) {
	                    element.m_uchars_ = source;
	                    element.m_cPoints_ = element.m_uchars_;
	                    FinalizeAddition(t, element);
	                }
	                source = m_utilCanIter_.Next();
	            }
	
	            return element.m_mapCE_;
	        } else {
	            return FinalizeAddition(t, element);
	        }
	    }
	
	    /// <summary>
	    /// Adds an expansion ce to the expansion vector
	    /// </summary>
	    ///
	    /// <param name="expansions">vector to add to</param>
	    /// <param name="value">of the expansion</param>
	    /// <returns>the current position of the new element</returns>
	    private static int AddExpansion(ArrayList expansions, int value_ren) {
	        expansions.Add(((int)(value_ren)));
	        return expansions.Count - 1;
	    }
	
	    /// <summary>
	    /// Looks for the maximum length of all expansion sequences ending with the
	    /// same collation element. The size required for maxexpansion and maxsize is
	    /// returned if the arrays are too small.
	    /// </summary>
	    ///
	    /// <param name="endexpansion">the last expansion collation element to be added</param>
	    /// <param name="expansionsize">size of the expansion</param>
	    /// <param name="maxexpansion">data structure to store the maximum expansion data.</param>
	    /// @returns size of the maxexpansion and maxsize used.
	    private static int SetMaxExpansion(int endexpansion, byte expansionsize,
	            CollationParsedRuleBuilder.MaxExpansionTable  maxexpansion) {
	        int start = 0;
	        int limit = maxexpansion.m_endExpansionCE_.Count;
	        long unsigned = (long) endexpansion;
	        unsigned &= 0xFFFFFFFFl;
	
	        // using binary search to determine if last expansion element is
	        // already in the array
	        int result = -1;
	        while (start < limit - 1) {
	            int mid = start + ((limit - start) >> 1);
	            long unsignedce = ((Int32) maxexpansion.m_endExpansionCE_[mid]);
	            unsignedce &= 0xFFFFFFFFl;
	            if (unsigned <= unsignedce) {
	                limit = mid;
	            } else {
	                start = mid;
	            }
	        }
	
	        if (((Int32) maxexpansion.m_endExpansionCE_[start]) == endexpansion) {
	            result = start;
	        } else if (((Int32) maxexpansion.m_endExpansionCE_[limit]) == endexpansion) {
	            result = limit;
	        }
	        if (result > -1) {
	            // found the ce in expansion, we'll just modify the size if it
	            // is smaller
	            Object currentsize = maxexpansion.m_expansionCESize_[result];
	            if (((Byte) currentsize) < expansionsize) {
	                maxexpansion.m_expansionCESize_[result]=(byte )(expansionsize);
	            }
	        } else {
	            // we'll need to squeeze the value into the array. initial
	            // implementation. shifting the subarray down by 1
	            maxexpansion.m_endExpansionCE_.Insert(start + 1,((int)(endexpansion)));
	            maxexpansion.m_expansionCESize_.Insert(start + 1,(byte )(expansionsize));
	        }
	        return maxexpansion.m_endExpansionCE_.Count;
	    }
	
	    /// <summary>
	    /// Sets the maximum length of all jamo expansion sequences ending with the
	    /// same collation element. The size required for maxexpansion and maxsize is
	    /// returned if the arrays are too small.
	    /// </summary>
	    ///
	    /// <param name="ch">the jamo codepoint</param>
	    /// <param name="endexpansion">the last expansion collation element to be added</param>
	    /// <param name="expansionsize">size of the expansion</param>
	    /// <param name="maxexpansion">data structure to store the maximum expansion data.</param>
	    /// @returns size of the maxexpansion and maxsize used.
	    private static int SetMaxJamoExpansion(char ch, int endexpansion,
	            byte expansionsize, CollationParsedRuleBuilder.MaxJamoExpansionTable  maxexpansion) {
	        bool isV = true;
	        if (ch >= 0x1100 && ch <= 0x1112) {
	            // determines L for Jamo, doesn't need to store this since it is
	            // never at the end of a expansion
	            if (maxexpansion.m_maxLSize_ < expansionsize) {
	                maxexpansion.m_maxLSize_ = expansionsize;
	            }
	            return maxexpansion.m_endExpansionCE_.Count;
	        }
	
	        if (ch >= 0x1161 && ch <= 0x1175) {
	            // determines V for Jamo
	            if (maxexpansion.m_maxVSize_ < expansionsize) {
	                maxexpansion.m_maxVSize_ = expansionsize;
	            }
	        }
	
	        if (ch >= 0x11A8 && ch <= 0x11C2) {
	            isV = false;
	            // determines T for Jamo
	            if (maxexpansion.m_maxTSize_ < expansionsize) {
	                maxexpansion.m_maxTSize_ = expansionsize;
	            }
	        }
	
	        int pos_0 = maxexpansion.m_endExpansionCE_.Count;
	        while (pos_0 > 0) {
	            pos_0--;
	            if (((Int32) maxexpansion.m_endExpansionCE_[pos_0]) == endexpansion) {
	                return maxexpansion.m_endExpansionCE_.Count;
	            }
	        }
	        maxexpansion.m_endExpansionCE_.Add(((int)(endexpansion)));
	        maxexpansion.m_isV_.Add((isV) ? true : false);
	
	        return maxexpansion.m_endExpansionCE_.Count;
	    }
	
	    /// <summary>
	    /// Adds a prefix to the table
	    /// </summary>
	    ///
	    /// <param name="t">build table to update</param>
	    /// <param name="CE">collation element to add</param>
	    /// <param name="element">rule element to add</param>
	    /// <returns>modified ce</returns>
	    private int AddPrefix(CollationParsedRuleBuilder.BuildTable  t, int CE, CollationParsedRuleBuilder.Elements  element) {
	        // currently the longest prefix we're supporting in Japanese is two
	        // characters long. Although this table could quite easily mimic
	        // complete contraction stuff there is no good reason to make a general
	        // solution, as it would require some error prone messing.
	        CollationParsedRuleBuilder.ContractionTable  contractions = t.m_contractions_;
	        String oldCP = element.m_cPoints_;
	        int oldCPOffset = element.m_cPointsOffset_;
	
	        contractions.m_currentTag_ = CE_SPEC_PROC_TAG_;
	        // here, we will normalize & add prefix to the table.
	        int size_0 = element.m_prefixChars_.Length - element.m_prefix_;
	        for (int j = 1; j < size_0; j++) {
	            // First add NFD prefix chars to unsafe CP hash table
	            // Unless it is a trail surrogate, which is handled algoritmically
	            // and shouldn't take up space in the table.
	            char ch = element.m_prefixChars_[j + element.m_prefix_];
	            if (!IBM.ICU.Text.UTF16.IsTrailSurrogate(ch)) {
	                UnsafeCPSet(t.m_unsafeCP_, ch);
	            }
	        }
	
	        // StringBuffer reversed = new StringBuffer();
	        m_utilStringBuffer_.Remove(0,m_utilStringBuffer_.Length-(0));
	        for (int j_1 = 0; j_1 < size_0; j_1++) {
	            // prefixes are going to be looked up backwards
	            // therefore, we will promptly reverse the prefix buffer...
	            int offset = element.m_prefixChars_.Length - j_1 - 1;
	            m_utilStringBuffer_.Append(element.m_prefixChars_[offset]);
	        }
	        element.m_prefixChars_ = m_utilStringBuffer_.ToString();
	        element.m_prefix_ = 0;
	
	        // the first codepoint is also unsafe, as it forms a 'contraction' with
	        // the prefix
	        if (!IBM.ICU.Text.UTF16.IsTrailSurrogate(element.m_cPoints_[0])) {
	            UnsafeCPSet(t.m_unsafeCP_, element.m_cPoints_[0]);
	        }
	
	        element.m_cPoints_ = element.m_prefixChars_;
	        element.m_cPointsOffset_ = element.m_prefix_;
	
	        // Add the last char of the contraction to the contraction-end hash
	        // table. unless it is a trail surrogate, which is handled
	        // algorithmically and shouldn't be in the table
	        if (!IBM.ICU.Text.UTF16.IsTrailSurrogate(element.m_cPoints_[element.m_cPoints_.Length - 1])) {
	            ContrEndCPSet(t.m_contrEndCP_,
	                    element.m_cPoints_[element.m_cPoints_.Length - 1]);
	        }
	        // First we need to check if contractions starts with a surrogate
	        // int cp = UTF16.charAt(element.m_cPoints_, element.m_cPointsOffset_);
	
	        // If there are any Jamos in the contraction, we should turn on special
	        // processing for Jamos
	        if (IsJamo(element.m_prefixChars_[element.m_prefix_])) {
	            t.m_collator_.m_isJamoSpecial_ = true;
	        }
	        // then we need to deal with it
	        // we could aready have something in table - or we might not
	        if (!IsPrefix(CE)) {
	            // if it wasn't contraction, we wouldn't end up here
	            int firstContractionOffset = AddContraction(contractions,
	                    CONTRACTION_TABLE_NEW_ELEMENT_, (char) 0, CE);
	            int newCE = ProcessContraction(contractions, element, CE_NOT_FOUND_);
	            AddContraction(contractions, firstContractionOffset,
	                    element.m_prefixChars_[element.m_prefix_], newCE);
	            AddContraction(contractions, firstContractionOffset, (char) 0xFFFF,
	                    CE);
	            CE = ConstructSpecialCE(CE_SPEC_PROC_TAG_, firstContractionOffset);
	        } else {
	            // we are adding to existing contraction
	            // there were already some elements in the table, so we need to add
	            // a new contraction
	            // Two things can happen here: either the codepoint is already in
	            // the table, or it is not
	            char ch_2 = element.m_prefixChars_[element.m_prefix_];
	            int position = FindCP(contractions, CE, ch_2);
	            if (position > 0) {
	                // if it is we just continue down the chain
	                int eCE = GetCE(contractions, CE, position);
	                int newCE_3 = ProcessContraction(contractions, element, eCE);
	                SetContraction(contractions, CE, position, ch_2, newCE_3);
	            } else {
	                // if it isn't, we will have to create a new sequence
	                ProcessContraction(contractions, element, CE_NOT_FOUND_);
	                InsertContraction(contractions, CE, ch_2, element.m_mapCE_);
	            }
	        }
	
	        element.m_cPoints_ = oldCP;
	        element.m_cPointsOffset_ = oldCPOffset;
	
	        return CE;
	    }
	
	    /// <summary>
	    /// Checks if the argument ce is a contraction
	    /// </summary>
	    ///
	    /// <param name="CE">collation element</param>
	    /// <returns>true if argument ce is a contraction</returns>
	    private static bool IsContraction(int CE) {
	        return IsSpecial(CE) && (GetCETag(CE) == CE_CONTRACTION_TAG_);
	    }
	
	    /// <summary>
	    /// Checks if the argument ce has a prefix
	    /// </summary>
	    ///
	    /// <param name="CE">collation element</param>
	    /// <returns>true if argument ce has a prefix</returns>
	    private static bool IsPrefix(int CE) {
	        return IsSpecial(CE) && (GetCETag(CE) == CE_SPEC_PROC_TAG_);
	    }
	
	    /// <summary>
	    /// Checks if the argument ce is special
	    /// </summary>
	    ///
	    /// <param name="CE">collation element</param>
	    /// <returns>true if argument ce is special</returns>
	    private static bool IsSpecial(int CE) {
	        return (CE & IBM.ICU.Text.RuleBasedCollator.CE_SPECIAL_FLAG_) == -268435456;
	    }
	
	    /// <summary>
	    /// Checks if the argument ce has a prefix
	    /// </summary>
	    ///
	    /// <param name="CE">collation element</param>
	    /// <returns>true if argument ce has a prefix</returns>
	    private static int GetCETag(int CE) {
	        return MathUtil.URS(CE & IBM.ICU.Text.RuleBasedCollator.CE_TAG_MASK_, IBM.ICU.Text.RuleBasedCollator.CE_TAG_SHIFT_);
	    }
	
	    /// <summary>
	    /// Gets the ce at position in contraction table
	    /// </summary>
	    ///
	    /// <param name="table">contraction table</param>
	    /// <param name="position">offset to the contraction table</param>
	    /// <returns>ce</returns>
	    private static int GetCE(CollationParsedRuleBuilder.ContractionTable  table, int element,
	            int position) {
	        element &= 0xFFFFFF;
	        CollationParsedRuleBuilder.BasicContractionTable  tbl = GetBasicContractionTable(table, element);
	
	        if (tbl == null) {
	            return CE_NOT_FOUND_;
	        }
	        if (position > tbl.m_CEs_.Count || position == -1) {
	            return CE_NOT_FOUND_;
	        } else {
	            return ((Int32) tbl.m_CEs_[position]);
	        }
	    }
	
	    /// <summary>
	    /// Sets the unsafe character
	    /// </summary>
	    ///
	    /// <param name="table">unsafe table</param>
	    /// <param name="c">character to be added</param>
	    private static void UnsafeCPSet(sbyte[] table, char c) {
	        int hash = c;
	        if (hash >= (UNSAFECP_TABLE_SIZE_ << 3)) {
	            if (hash >= 0xd800 && hash <= 0xf8ff) {
	                // Part of a surrogate, or in private use area.
	                // These don't go in the table
	                return;
	            }
	            hash = (hash & UNSAFECP_TABLE_MASK_) + 256;
	        }
            table[hash >> 3] |= (sbyte) (1 << (hash & 7));
	    }
	
	    /// <summary>
	    /// Sets the contraction end character
	    /// </summary>
	    ///
	    /// <param name="table">contraction end table</param>
	    /// <param name="c">character to be added</param>
	    private static void ContrEndCPSet(sbyte[] table, char c) {
	        int hash = c;
	        if (hash >= (UNSAFECP_TABLE_SIZE_ << 3)) {
	            hash = (hash & UNSAFECP_TABLE_MASK_) + 256;
	        }
	        table[hash >> 3] |= (sbyte) (1 << (hash & 7));
	    }
	
	    /// <summary>
	    /// Adds more contractions in table. If element is non existant, it creates
	    /// on. Returns element handle
	    /// </summary>
	    ///
	    /// <param name="table">contraction table</param>
	    /// <param name="element">offset to the contraction table</param>
	    /// <param name="codePoint">codepoint to add</param>
	    /// <param name="value"></param>
	    /// <returns>collation element</returns>
	    private static int AddContraction(CollationParsedRuleBuilder.ContractionTable  table, int element,
	            char codePoint, int value_ren) {
	        CollationParsedRuleBuilder.BasicContractionTable  tbl = GetBasicContractionTable(table, element);
	        if (tbl == null) {
	            tbl = AddAContractionElement(table);
	            element = table.m_elements_.Count - 1;
	        }
	
	        tbl.m_CEs_.Add(((int)(value_ren)));
	        tbl.m_codePoints_.Append(codePoint);
	        return ConstructSpecialCE(table.m_currentTag_, element);
	    }
	
	    /// <summary>
	    /// Adds a contraction element to the table
	    /// </summary>
	    ///
	    /// <param name="table">contraction table to update</param>
	    /// <returns>contraction</returns>
	    private static CollationParsedRuleBuilder.BasicContractionTable  AddAContractionElement(
	            CollationParsedRuleBuilder.ContractionTable  table) {
	        CollationParsedRuleBuilder.BasicContractionTable  result = new CollationParsedRuleBuilder.BasicContractionTable ();
	        table.m_elements_.Add(result);
	        return result;
	    }
	
	    /// <summary>
	    /// Constructs a special ce
	    /// </summary>
	    ///
	    /// <param name="tag">special tag</param>
	    /// <param name="CE">collation element</param>
	    /// <returns>a contraction ce</returns>
	    private static int ConstructSpecialCE(int tag, int CE) {
	        return IBM.ICU.Text.RuleBasedCollator.CE_SPECIAL_FLAG_
	                | (tag << IBM.ICU.Text.RuleBasedCollator.CE_TAG_SHIFT_) | (CE & 0xFFFFFF);
	    }
	
	    /// <summary>
	    /// Sets and inserts the element that has a contraction
	    /// </summary>
	    ///
	    /// <param name="contractions">contraction table</param>
	    /// <param name="element">contracting element</param>
	    /// <param name="existingCE"></param>
	    /// <returns>contraction ce</returns>
	    private static int ProcessContraction(CollationParsedRuleBuilder.ContractionTable  contractions,
	            CollationParsedRuleBuilder.Elements  element, int existingCE) {
	        int firstContractionOffset = 0;
	        // end of recursion
	        if (element.m_cPoints_.Length - element.m_cPointsOffset_ == 1) {
	            if (IsContractionTableElement(existingCE)
	                    && GetCETag(existingCE) == contractions.m_currentTag_) {
	                ChangeContraction(contractions, existingCE, (char) 0,
	                        element.m_mapCE_);
	                ChangeContraction(contractions, existingCE, (char) 0xFFFF,
	                        element.m_mapCE_);
	                return existingCE;
	            } else {
	                // can't do just that. existingCe might be a contraction,
	                // meaning that we need to do another step
	                return element.m_mapCE_;
	            }
	        }
	
	        // this recursion currently feeds on the only element we have...
	        // We will have to copy it in order to accomodate for both backward
	        // and forward cycles
	        // we encountered either an empty space or a non-contraction element
	        // this means we are constructing a new contraction sequence
	        element.m_cPointsOffset_++;
	        if (!IsContractionTableElement(existingCE)) {
	            // if it wasn't contraction, we wouldn't end up here
	            firstContractionOffset = AddContraction(contractions,
	                    CONTRACTION_TABLE_NEW_ELEMENT_, (char) 0, existingCE);
	            int newCE = ProcessContraction(contractions, element, CE_NOT_FOUND_);
	            AddContraction(contractions, firstContractionOffset,
	                    element.m_cPoints_[element.m_cPointsOffset_], newCE);
	            AddContraction(contractions, firstContractionOffset, (char) 0xFFFF,
	                    existingCE);
	            existingCE = ConstructSpecialCE(contractions.m_currentTag_,
	                    firstContractionOffset);
	        } else {
	            // we are adding to existing contraction
	            // there were already some elements in the table, so we need to add
	            // a new contraction
	            // Two things can happen here: either the codepoint is already in
	            // the table, or it is not
	            int position = FindCP(contractions, existingCE,
	                    element.m_cPoints_[element.m_cPointsOffset_]);
	            if (position > 0) {
	                // if it is we just continue down the chain
	                int eCE = GetCE(contractions, existingCE, position);
	                int newCE_0 = ProcessContraction(contractions, element, eCE);
	                SetContraction(contractions, existingCE, position,
	                        element.m_cPoints_[element.m_cPointsOffset_],
	                        newCE_0);
	            } else {
	                // if it isn't, we will have to create a new sequence
	                int newCE_1 = ProcessContraction(contractions, element,
	                        CE_NOT_FOUND_);
	                InsertContraction(contractions, existingCE,
	                        element.m_cPoints_[element.m_cPointsOffset_],
	                        newCE_1);
	            }
	        }
	        element.m_cPointsOffset_--;
	        return existingCE;
	    }
	
	    /// <summary>
	    /// Checks if CE belongs to the contraction table
	    /// </summary>
	    ///
	    /// <param name="CE">collation element to test</param>
	    /// <returns>true if CE belongs to the contraction table</returns>
	    private static bool IsContractionTableElement(int CE) {
	        return IsSpecial(CE)
	                && (GetCETag(CE) == CE_CONTRACTION_TAG_ || GetCETag(CE) == CE_SPEC_PROC_TAG_);
	    }
	
	    /// <summary>
	    /// Gets the codepoint
	    /// </summary>
	    ///
	    /// <param name="table">contraction table</param>
	    /// <param name="element">offset to the contraction element in the table</param>
	    /// <param name="codePoint">code point to look for</param>
	    /// <returns>the offset to the code point</returns>
	    private static int FindCP(CollationParsedRuleBuilder.ContractionTable  table, int element,
	            char codePoint) {
	        CollationParsedRuleBuilder.BasicContractionTable  tbl = GetBasicContractionTable(table, element);
	        if (tbl == null) {
	            return -1;
	        }
	
	        int position = 0;
	        while (codePoint > tbl.m_codePoints_[position]) {
	            position++;
	            if (position > tbl.m_codePoints_.Length) {
	                return -1;
	            }
	        }
	        if (codePoint == tbl.m_codePoints_[position]) {
	            return position;
	        } else {
	            return -1;
	        }
	    }
	
	    /// <summary>
	    /// Gets the contraction element out of the contraction table
	    /// </summary>
	    ///
	    /// <param name="table">contraction table</param>
	    /// <param name="offset">to the element in the contraction table</param>
	    /// <returns>basic contraction element at offset in the contraction table</returns>
	    private static CollationParsedRuleBuilder.BasicContractionTable  GetBasicContractionTable(
	            CollationParsedRuleBuilder.ContractionTable  table, int offset) {
	        offset &= 0xFFFFFF;
	        if (offset == 0xFFFFFF) {
	            return null;
	        }
	        return (CollationParsedRuleBuilder.BasicContractionTable ) table.m_elements_[offset];
	    }
	
	    /// <summary>
	    /// Changes the contraction element
	    /// </summary>
	    ///
	    /// <param name="table">contraction table</param>
	    /// <param name="element">offset to the element in the contraction table</param>
	    /// <param name="codePoint">codepoint</param>
	    /// <param name="newCE">new collation element</param>
	    /// <returns>basic contraction element at offset in the contraction table</returns>
	    private static int ChangeContraction(CollationParsedRuleBuilder.ContractionTable  table,
	            int element, char codePoint, int newCE) {
	        CollationParsedRuleBuilder.BasicContractionTable  tbl = GetBasicContractionTable(table, element);
	        if (tbl == null) {
	            return 0;
	        }
	        int position = 0;
	        while (codePoint > tbl.m_codePoints_[position]) {
	            position++;
	            if (position > tbl.m_codePoints_.Length) {
	                return CE_NOT_FOUND_;
	            }
	        }
	        if (codePoint == tbl.m_codePoints_[position]) {
	            tbl.m_CEs_[position]=((int)(newCE));
	            return element & 0xFFFFFF;
	        } else {
	            return CE_NOT_FOUND_;
	        }
	    }
	
	    /// <summary>
	    /// Sets a part of contraction sequence in table. If element is non existant,
	    /// it creates on. Returns element handle.
	    /// </summary>
	    ///
	    /// <param name="table">contraction table</param>
	    /// <param name="element">offset to the contraction table</param>
	    /// <param name="offset"></param>
	    /// <param name="codePoint">contraction character</param>
	    /// <param name="value">ce value</param>
	    /// <returns>new contraction ce</returns>
	    private static int SetContraction(CollationParsedRuleBuilder.ContractionTable  table,
	            int element, int offset, char codePoint, int value_ren) {
	        element &= 0xFFFFFF;
	        CollationParsedRuleBuilder.BasicContractionTable  tbl = GetBasicContractionTable(table, element);
	        if (tbl == null) {
	            tbl = AddAContractionElement(table);
	            element = table.m_elements_.Count - 1;
	        }
	
	        tbl.m_CEs_[offset]=((int)(value_ren));
	        tbl.m_codePoints_[offset]=codePoint;
	        return ConstructSpecialCE(table.m_currentTag_, element);
	    }
	
	    /// <summary>
	    /// Inserts a part of contraction sequence in table. Sequences behind the
	    /// offset are moved back. If element is non existent, it creates on.
	    /// </summary>
	    ///
	    /// <param name="table">contraction</param>
	    /// <param name="element">offset to the table contraction</param>
	    /// <param name="codePoint">code point</param>
	    /// <param name="value">collation element value</param>
	    /// <returns>contraction collation element</returns>
	    private static int InsertContraction(CollationParsedRuleBuilder.ContractionTable  table,
	            int element, char codePoint, int value_ren) {
	        element &= 0xFFFFFF;
	        CollationParsedRuleBuilder.BasicContractionTable  tbl = GetBasicContractionTable(table, element);
	        if (tbl == null) {
	            tbl = AddAContractionElement(table);
	            element = table.m_elements_.Count - 1;
	        }
	
	        int offset = 0;
	        while (tbl.m_codePoints_[offset] < codePoint
	                && offset < tbl.m_codePoints_.Length) {
	            offset++;
	        }
	
	        tbl.m_CEs_.Insert(offset,((int)(value_ren)));
	        tbl.m_codePoints_.Insert(offset, codePoint);
	
	        return ConstructSpecialCE(table.m_currentTag_, element);
	    }
	
	    /// <summary>
	    /// Finalize addition
	    /// </summary>
	    ///
	    /// <param name="t">build table</param>
	    /// <param name="element">to add</param>
	    private static int FinalizeAddition(CollationParsedRuleBuilder.BuildTable  t, CollationParsedRuleBuilder.Elements  element) {
	        int CE = CE_NOT_FOUND_;
	        // This should add a completely ignorable element to the
	        // unsafe table, so that backward iteration will skip
	        // over it when treating contractions.
	        if (element.m_mapCE_ == 0) {
	            for (int i = 0; i < element.m_cPoints_.Length; i++) {
	                char ch = element.m_cPoints_[i];
	                if (!IBM.ICU.Text.UTF16.IsTrailSurrogate(ch)) {
	                    UnsafeCPSet(t.m_unsafeCP_, ch);
	                }
	            }
	        }
	
	        if (element.m_cPoints_.Length - element.m_cPointsOffset_ > 1) {
	            // we're adding a contraction
	            int cp = IBM.ICU.Text.UTF16.CharAt(element.m_cPoints_, element.m_cPointsOffset_);
	            CE = t.m_mapping_.GetValue(cp);
	            CE = AddContraction(t, CE, element);
	        } else {
	            // easy case
	            CE = t.m_mapping_.GetValue(element.m_cPoints_[element.m_cPointsOffset_]);
	
	            if (CE != CE_NOT_FOUND_) {
	                if (IsContractionTableElement(CE)) {
	                    // adding a non contraction element (thai, expansion,
	                    // single) to already existing contraction
	                    if (!IsPrefix(element.m_mapCE_)) {
	                        // we cannot reenter prefix elements - as we are going
	                        // to create a dead loop
	                        // Only expansions and regular CEs can go here...
	                        // Contractions will never happen in this place
	                        SetContraction(t.m_contractions_, CE, 0, (char) 0,
	                                element.m_mapCE_);
	                        // This loop has to change the CE at the end of
	                        // contraction REDO!
	                        ChangeLastCE(t.m_contractions_, CE, element.m_mapCE_);
	                    }
	                } else {
	                    t.m_mapping_
	                            .SetValue(element.m_cPoints_[element.m_cPointsOffset_],
	                                    element.m_mapCE_);
	                }
	            } else {
	                t.m_mapping_.SetValue(
	                        element.m_cPoints_[element.m_cPointsOffset_],
	                        element.m_mapCE_);
	            }
	        }
	        return CE;
	    }
	
	    /// <summary>
	    /// Note regarding surrogate handling: We are interested only in the single
	    /// or leading surrogates in a contraction. If a surrogate is somewhere else
	    /// in the contraction, it is going to be handled as a pair of code units, as
	    /// it doesn't affect the performance AND handling surrogates specially would
	    /// complicate code way too much.
	    /// </summary>
	    ///
	    private static int AddContraction(CollationParsedRuleBuilder.BuildTable  t, int CE, CollationParsedRuleBuilder.Elements  element) {
	        CollationParsedRuleBuilder.ContractionTable  contractions = t.m_contractions_;
	        contractions.m_currentTag_ = CE_CONTRACTION_TAG_;
	
	        // First we need to check if contractions starts with a surrogate
	        int cp = IBM.ICU.Text.UTF16.CharAt(element.m_cPoints_, 0);
	        int cpsize = 1;
	        if (IBM.ICU.Lang.UCharacter.IsSupplementary(cp)) {
	            cpsize = 2;
	        }
	        if (cpsize < element.m_cPoints_.Length) {
	            // This is a real contraction, if there are other characters after
	            // the first
	            int size_0 = element.m_cPoints_.Length - element.m_cPointsOffset_;
	            for (int j = 1; j < size_0; j++) {
	                // First add contraction chars to unsafe CP hash table
	                // Unless it is a trail surrogate, which is handled
	                // algoritmically and shouldn't take up space in the table.
	                if (!IBM.ICU.Text.UTF16.IsTrailSurrogate(element.m_cPoints_[element.m_cPointsOffset_ + j])) {
	                    UnsafeCPSet(
	                            t.m_unsafeCP_,
	                            element.m_cPoints_[element.m_cPointsOffset_
	                                                                + j]);
	                }
	            }
	            // Add the last char of the contraction to the contraction-end
	            // hash table. unless it is a trail surrogate, which is handled
	            // algorithmically and shouldn't be in the table
	            if (!IBM.ICU.Text.UTF16.IsTrailSurrogate(element.m_cPoints_[element.m_cPoints_.Length - 1])) {
	                ContrEndCPSet(
	                        t.m_contrEndCP_,
	                        element.m_cPoints_[element.m_cPoints_.Length - 1]);
	            }
	
	            // If there are any Jamos in the contraction, we should turn on
	            // special processing for Jamos
	            if (IsJamo(element.m_cPoints_[element.m_cPointsOffset_])) {
	                t.m_collator_.m_isJamoSpecial_ = true;
	            }
	            // then we need to deal with it
	            // we could aready have something in table - or we might not
	            element.m_cPointsOffset_ += cpsize;
	            if (!IsContraction(CE)) {
	                // if it wasn't contraction, we wouldn't end up here
	                int firstContractionOffset = AddContraction(contractions,
	                        CONTRACTION_TABLE_NEW_ELEMENT_, (char) 0, CE);
	                int newCE = ProcessContraction(contractions, element,
	                        CE_NOT_FOUND_);
	                AddContraction(contractions, firstContractionOffset,
	                        element.m_cPoints_[element.m_cPointsOffset_],
	                        newCE);
	                AddContraction(contractions, firstContractionOffset,
	                        (char) 0xFFFF, CE);
	                CE = ConstructSpecialCE(CE_CONTRACTION_TAG_,
	                        firstContractionOffset);
	            } else {
	                // we are adding to existing contraction
	                // there were already some elements in the table, so we need to
	                // add a new contraction
	                // Two things can happen here: either the codepoint is already
	                // in the table, or it is not
	                int position = FindCP(contractions, CE,
	                        element.m_cPoints_[element.m_cPointsOffset_]);
	                if (position > 0) {
	                    // if it is we just continue down the chain
	                    int eCE = GetCE(contractions, CE, position);
	                    int newCE_1 = ProcessContraction(contractions, element, eCE);
	                    SetContraction(
	                            contractions,
	                            CE,
	                            position,
	                            element.m_cPoints_[element.m_cPointsOffset_],
	                            newCE_1);
	                } else {
	                    // if it isn't, we will have to create a new sequence
	                    int newCE_2 = ProcessContraction(contractions, element,
	                            CE_NOT_FOUND_);
	                    InsertContraction(
	                            contractions,
	                            CE,
	                            element.m_cPoints_[element.m_cPointsOffset_],
	                            newCE_2);
	                }
	            }
	            element.m_cPointsOffset_ -= cpsize;
	            t.m_mapping_.SetValue(cp, CE);
	        } else if (!IsContraction(CE)) {
	            // this is just a surrogate, and there is no contraction
	            t.m_mapping_.SetValue(cp, element.m_mapCE_);
	        } else {
	            // fill out the first stage of the contraction with the surrogate
	            // CE
	            ChangeContraction(contractions, CE, (char) 0, element.m_mapCE_);
	            ChangeContraction(contractions, CE, (char) 0xFFFF, element.m_mapCE_);
	        }
	        return CE;
	    }
	
	    /// <summary>
	    /// this is for adding non contractions
	    /// </summary>
	    ///
	    /// <param name="table">contraction table</param>
	    /// <param name="element">offset to the contraction table</param>
	    /// <param name="value">collation element value</param>
	    /// <returns>new collation element</returns>
	    private static int ChangeLastCE(CollationParsedRuleBuilder.ContractionTable  table, int element,
	            int value_ren) {
	        CollationParsedRuleBuilder.BasicContractionTable  tbl = GetBasicContractionTable(table, element);
	        if (tbl == null) {
	            return 0;
	        }
	
	        tbl.m_CEs_[tbl.m_CEs_.Count - 1]=((int)(value_ren));
	        return ConstructSpecialCE(table.m_currentTag_, element & 0xFFFFFF);
	    }
	
	    /// <summary>
	    /// Given a set of ranges calculated by allocWeights(), iterate through the
	    /// weights. Sets the next weight in cegenerator.m_current_.
	    /// </summary>
	    ///
	    /// <param name="cegenerator">object that contains ranges weight range array and itsrangeCount</param>
	    /// <returns>the next weight</returns>
	    private static int NextWeight(CollationParsedRuleBuilder.CEGenerator  cegenerator) {
	        if (cegenerator.m_rangesLength_ > 0) {
	            // get maxByte from the .count field
	            int maxByte = cegenerator.m_ranges_[0].m_count_;
	            // get the next weight
	            int weight = cegenerator.m_ranges_[0].m_start_;
	            if (weight == cegenerator.m_ranges_[0].m_end_) {
	                // this range is finished, remove it and move the following
	                // ones up
	                cegenerator.m_rangesLength_--;
	                if (cegenerator.m_rangesLength_ > 0) {
	                    System.Array.Copy((Array)(cegenerator.m_ranges_),1,(Array)(cegenerator.m_ranges_),0,cegenerator.m_rangesLength_);
	                    cegenerator.m_ranges_[0].m_count_ = maxByte;
	                    // keep maxByte in ranges[0]
	                }
	            } else {
	                // increment the weight for the next value
	                cegenerator.m_ranges_[0].m_start_ = IncWeight(weight,
	                        cegenerator.m_ranges_[0].m_length2_, maxByte);
	            }
	            return weight;
	        }
	        return -1;
	    }
	
	    /// <summary>
	    /// Increment the collation weight
	    /// </summary>
	    ///
	    /// <param name="weight">to increment</param>
	    /// <param name="length"></param>
	    /// <param name="maxByte"></param>
	    /// <returns>new incremented weight</returns>
	    private static int IncWeight(int weight, int length, int maxByte) {
	        while (true) {
	            int b = GetWeightByte(weight, length);
	            if (b < maxByte) {
	                return SetWeightByte(weight, length, b + 1);
	            } else {
	                // roll over, set this byte to BYTE_FIRST_TAILORED_ and
	                // increment the previous one
	                weight = SetWeightByte(weight, length,
	                        IBM.ICU.Text.RuleBasedCollator.BYTE_FIRST_TAILORED_);
	                --length;
	            }
	        }
	    }
	
	    /// <summary>
	    /// Gets the weight byte
	    /// </summary>
	    ///
	    /// <param name="weight"></param>
	    /// <param name="index_0"></param>
	    /// <returns>byte</returns>
	    private static int GetWeightByte(int weight, int index_0) {
	        return (weight >> ((4 - index_0) << 3)) & 0xff;
	    }
	
	    /// <summary>
	    /// Set the weight byte in table
	    /// </summary>
	    ///
	    /// <param name="weight"></param>
	    /// <param name="index_0"></param>
	    /// <param name="b">byte</param>
	    private static int SetWeightByte(int weight, int index_0, int b) {
	        index_0 <<= 3;
	        // 0xffffffff except a 00 "hole" for the index-th byte
            int mask = MathUtil.URS(-1, index_0); // (int)(((int)-1) >> index_0);
	        index_0 = 32 - index_0;
	        mask |= -256 << index_0;
	        return (weight & mask) | (b << index_0);
	    }
	
	    /// <summary>
	    /// Call getWeightRanges and then determine heuristically which ranges to use
	    /// for a given number of weights between (excluding) two limits
	    /// </summary>
	    ///
	    /// <param name="lowerLimit"></param>
	    /// <param name="upperLimit"></param>
	    /// <param name="n"></param>
	    /// <param name="maxByte"></param>
	    /// <param name="ranges"></param>
	    /// <returns></returns>
	    private int AllocateWeights(int lowerLimit, int upperLimit, int n,
	            int maxByte, CollationParsedRuleBuilder.WeightRange [] ranges) {
	        // number of usable byte values 3..maxByte
	        int countBytes = maxByte - IBM.ICU.Text.RuleBasedCollator.BYTE_FIRST_TAILORED_ + 1;
	        // [0] unused, [5] to make index checks unnecessary, m_utilCountBuffer_
	        // countBytes to the power of index, m_utilLongBuffer_ for unsignedness
	        // gcc requires explicit initialization
	        m_utilLongBuffer_[0] = 1;
	        m_utilLongBuffer_[1] = countBytes;
	        m_utilLongBuffer_[2] = m_utilLongBuffer_[1] * countBytes;
	        m_utilLongBuffer_[3] = m_utilLongBuffer_[2] * countBytes;
	        m_utilLongBuffer_[4] = m_utilLongBuffer_[3] * countBytes;
	        int rangeCount = GetWeightRanges(lowerLimit, upperLimit, maxByte,
	                countBytes, ranges);
	        if (rangeCount <= 0) {
	            return 0;
	        }
	        // what is the maximum number of weights with these ranges?
	        long maxCount = 0;
	        for (int i = 0; i < rangeCount; ++i) {
	            maxCount += (long) ranges[i].m_count_
	                    * m_utilLongBuffer_[4 - ranges[i].m_length_];
	        }
	        if (maxCount < n) {
	            return 0;
	        }
	        // set the length2 and count2 fields
	        for (int i_0 = 0; i_0 < rangeCount; ++i_0) {
	            ranges[i_0].m_length2_ = ranges[i_0].m_length_;
	            ranges[i_0].m_count2_ = ranges[i_0].m_count_;
	        }
	        // try until we find suitably large ranges
	        while (true) {
	            // get the smallest number of bytes in a range
	            int minLength = ranges[0].m_length2_;
	            // sum up the number of elements that fit into ranges of each byte
	            // length
	            ILOG.J2CsMapping.Collections.Arrays.Fill(m_utilCountBuffer_,0);
	            for (int i_1 = 0; i_1 < rangeCount; ++i_1) {
	                m_utilCountBuffer_[ranges[i_1].m_length2_] += ranges[i_1].m_count2_;
	            }
	            // now try to allocate n elements in the available short ranges
	            if (n <= m_utilCountBuffer_[minLength]
	                    + m_utilCountBuffer_[minLength + 1]) {
	                // trivial cases, use the first few ranges
	                maxCount = 0;
	                rangeCount = 0;
	                do {
	                    maxCount += ranges[rangeCount].m_count2_;
	                    ++rangeCount;
	                } while (n > maxCount);
	                break;
	            } else if (n <= ranges[0].m_count2_ * countBytes) {
	                // easy case, just make this one range large enough by
	                // lengthening it once more, possibly split it
	                rangeCount = 1;
	                // calculate how to split the range between maxLength-1
	                // (count1) and maxLength (count2)
	                long power_1 = m_utilLongBuffer_[minLength
	                        - ranges[0].m_length_];
	                long power = power_1 * countBytes;
	                int count2 = (int) ((n + power - 1) / power);
	                int count1 = ranges[0].m_count_ - count2;
	                // split the range
	                if (count1 < 1) {
	                    // lengthen the entire range to maxLength
	                    LengthenRange(ranges, 0, maxByte, countBytes);
	                } else {
	                    // really split the range
	                    // create a new range with the end and initial and current
	                    // length of the old one
	                    rangeCount = 2;
	                    ranges[1].m_end_ = ranges[0].m_end_;
	                    ranges[1].m_length_ = ranges[0].m_length_;
	                    ranges[1].m_length2_ = minLength;
	                    // set the end of the first range according to count1
	                    int i_2 = ranges[0].m_length_;
	                    int b = GetWeightByte(ranges[0].m_start_, i_2) + count1 - 1;
	                    // ranges[0].count and count1 may be >countBytes from
	                    // merging adjacent ranges; b > maxByte is possible
	                    if (b <= maxByte) {
	                        ranges[0].m_end_ = SetWeightByte(ranges[0].m_start_, i_2,
	                                b);
	                    } else {
	                        ranges[0].m_end_ = SetWeightByte(
	                                IncWeight(ranges[0].m_start_, i_2 - 1, maxByte),
	                                i_2, b - countBytes);
	                    }
	                    // set the bytes in the end weight at length + 1..length2
	                    // to maxByte
	                    b = (maxByte << 24) | (maxByte << 16) | (maxByte << 8)
	                            | maxByte; // this used to be 0xffffffff
	                    ranges[0].m_end_ = TruncateWeight(ranges[0].m_end_, i_2)
	                            | MathUtil.URS(b, i_2 << 3) & (b << ((4 - minLength) << 3));
	                    // set the start of the second range to immediately follow
	                    // the end of the first one
	                    ranges[1].m_start_ = IncWeight(ranges[0].m_end_, minLength,
	                            maxByte);
	                    // set the count values (informational)
	                    ranges[0].m_count_ = count1;
	                    ranges[1].m_count_ = count2;
	
	                    ranges[0].m_count2_ = (int) (count1 * power_1);
	                    // will be *countBytes when lengthened
	                    ranges[1].m_count2_ = (int) (count2 * power_1);
	
	                    // lengthen the second range to maxLength
	                    LengthenRange(ranges, 1, maxByte, countBytes);
	                }
	                break;
	            }
	            // no good match, lengthen all minLength ranges and iterate
	            for (int i_3 = 0; ranges[i_3].m_length2_ == minLength; ++i_3) {
	                LengthenRange(ranges, i_3, maxByte, countBytes);
	            }
	        }
	
	        if (rangeCount > 1) {
	            // sort the ranges by weight values
	            System.Array.Sort(ranges, 0, rangeCount);
	        }
	
	        // set maxByte in ranges[0] for ucol_nextWeight()
	        ranges[0].m_count_ = maxByte;
	
	        return rangeCount;
	    }
	
	    /// <summary>
	    /// Updates the range length
	    /// </summary>
	    ///
	    /// <param name="range">weight range array</param>
	    /// <param name="offset">to weight range array</param>
	    /// <param name="maxByte"></param>
	    /// <param name="countBytes"></param>
	    /// <returns>new length</returns>
	    private static int LengthenRange(CollationParsedRuleBuilder.WeightRange [] range, int offset,
	            int maxByte, int countBytes) {
	        int length = range[offset].m_length2_ + 1;
	        range[offset].m_start_ = SetWeightTrail(range[offset].m_start_, length,
	                IBM.ICU.Text.RuleBasedCollator.BYTE_FIRST_TAILORED_);
	        range[offset].m_end_ = SetWeightTrail(range[offset].m_end_, length,
	                maxByte);
	        range[offset].m_count2_ *= countBytes;
	        range[offset].m_length2_ = length;
	        return length;
	    }
	
	    /// <summary>
	    /// Gets the weight
	    /// </summary>
	    ///
	    /// <param name="weight"></param>
	    /// <param name="length"></param>
	    /// <param name="trail"></param>
	    /// <returns>new weight</returns>
	    private static int SetWeightTrail(int weight, int length, int trail) {
	        length = (4 - length) << 3;
	        return (weight & (-256 << length)) | (trail << length);
	    }
	
	    /// <summary>
	    /// take two CE weights and calculate the possible ranges of weights between
	    /// the two limits, excluding them for weights with up to 4 bytes there are
	    /// up to 2///4-1=7 ranges
	    /// </summary>
	    ///
	    /// <param name="lowerLimit"></param>
	    /// <param name="upperLimit"></param>
	    /// <param name="maxByte"></param>
	    /// <param name="countBytes"></param>
	    /// <param name="ranges"></param>
	    /// <returns>weight ranges</returns>
	    private int GetWeightRanges(int lowerLimit, int upperLimit, int maxByte,
	            int countBytes, CollationParsedRuleBuilder.WeightRange [] ranges) {
	        // assume that both lowerLimit & upperLimit are not 0
	        // get the lengths of the limits
	        int lowerLength = LengthOfWeight(lowerLimit);
	        int upperLength = LengthOfWeight(upperLimit);
	        if (IBM.ICU.Impl.Utility.CompareUnsigned(lowerLimit, upperLimit) >= 0) {
	            return 0;
	        }
	        // check that neither is a prefix of the other
	        if (lowerLength < upperLength) {
	            if (lowerLimit == TruncateWeight(upperLimit, lowerLength)) {
	                return 0;
	            }
	        }
	        // if the upper limit is a prefix of the lower limit then the earlier
	        // test lowerLimit >= upperLimit has caught it
	        // reset local variables
	        // With the limit lengths of 1..4, there are up to 7 ranges for
	        // allocation:
	        // range minimum length
	        // lower[4] 4
	        // lower[3] 3
	        // lower[2] 2
	        // middle 1
	        // upper[2] 2
	        // upper[3] 3
	        // upper[4] 4
	        // We are now going to calculate up to 7 ranges.
	        // Some of them will typically overlap, so we will then have to merge
	        // and eliminate ranges.
	
	        // We have to clean cruft from previous invocations
	        // before doing anything. C++ already does that
	        for (int length = 0; length < 5; length++) {
	            m_utilLowerWeightRange_[length].Clear();
	            m_utilUpperWeightRange_[length].Clear();
	        }
	        m_utilWeightRange_.Clear();
	
	        int weight = lowerLimit;
	        for (int length_0 = lowerLength; length_0 >= 2; --length_0) {
	            m_utilLowerWeightRange_[length_0].Clear();
	            int trail = GetWeightByte(weight, length_0);
	            if (trail < maxByte) {
	                m_utilLowerWeightRange_[length_0].m_start_ = IncWeightTrail(
	                        weight, length_0);
	                m_utilLowerWeightRange_[length_0].m_end_ = SetWeightTrail(weight,
	                        length_0, maxByte);
	                m_utilLowerWeightRange_[length_0].m_length_ = length_0;
	                m_utilLowerWeightRange_[length_0].m_count_ = maxByte - trail;
	            }
	            weight = TruncateWeight(weight, length_0 - 1);
	        }
	        m_utilWeightRange_.m_start_ = IncWeightTrail(weight, 1);
	
	        weight = upperLimit;
	        // [0] and [1] are not used - this simplifies indexing,
	        // m_utilUpperWeightRange_
	
	        for (int length_1 = upperLength; length_1 >= 2; length_1--) {
	            int trail_2 = GetWeightByte(weight, length_1);
	            if (trail_2 > IBM.ICU.Text.RuleBasedCollator.BYTE_FIRST_TAILORED_) {
	                m_utilUpperWeightRange_[length_1].m_start_ = SetWeightTrail(
	                        weight, length_1, IBM.ICU.Text.RuleBasedCollator.BYTE_FIRST_TAILORED_);
	                m_utilUpperWeightRange_[length_1].m_end_ = DecWeightTrail(weight,
	                        length_1);
	                m_utilUpperWeightRange_[length_1].m_length_ = length_1;
	                m_utilUpperWeightRange_[length_1].m_count_ = trail_2
	                        - IBM.ICU.Text.RuleBasedCollator.BYTE_FIRST_TAILORED_;
	            }
	            weight = TruncateWeight(weight, length_1 - 1);
	        }
	        m_utilWeightRange_.m_end_ = DecWeightTrail(weight, 1);
	
	        // set the middle range
	        m_utilWeightRange_.m_length_ = 1;
	        if (IBM.ICU.Impl.Utility.CompareUnsigned(m_utilWeightRange_.m_end_,
	                m_utilWeightRange_.m_start_) >= 0) {
	            // if (m_utilWeightRange_.m_end_ >= m_utilWeightRange_.m_start_) {
	            m_utilWeightRange_.m_count_ = MathUtil.URS(m_utilWeightRange_.m_end_ - m_utilWeightRange_.m_start_, 24) + 1;
	        } else {
	            // eliminate overlaps
	            // remove the middle range
	            m_utilWeightRange_.m_count_ = 0;
	            // reduce or remove the lower ranges that go beyond upperLimit
	            for (int length_3 = 4; length_3 >= 2; --length_3) {
	                if (m_utilLowerWeightRange_[length_3].m_count_ > 0
	                        && m_utilUpperWeightRange_[length_3].m_count_ > 0) {
	                    int start = m_utilUpperWeightRange_[length_3].m_start_;
	                    int end = m_utilLowerWeightRange_[length_3].m_end_;
	                    if (end >= start
	                            || IncWeight(end, length_3, maxByte) == start) {
	                        // lower and upper ranges collide or are directly
	                        // adjacent: merge these two and remove all shorter
	                        // ranges
	                        start = m_utilLowerWeightRange_[length_3].m_start_;
	                        end = m_utilLowerWeightRange_[length_3].m_end_ = m_utilUpperWeightRange_[length_3].m_end_;
	                        // merging directly adjacent ranges needs to subtract
	                        // the 0/1 gaps in between;
	                        // it may result in a range with count>countBytes
	                        m_utilLowerWeightRange_[length_3].m_count_ = GetWeightByte(
	                                end, length_3)
	                                - GetWeightByte(start, length_3)
	                                + 1
	                                + countBytes
	                                * (GetWeightByte(end, length_3 - 1) - GetWeightByte(
	                                        start, length_3 - 1));
	                        m_utilUpperWeightRange_[length_3].m_count_ = 0;
	                        while (--length_3 >= 2) {
	                            m_utilLowerWeightRange_[length_3].m_count_ = m_utilUpperWeightRange_[length_3].m_count_ = 0;
	                        }
	                        break;
	                    }
	                }
	            }
	        }
	
	        // copy the ranges, shortest first, into the result array
	        int rangeCount = 0;
	        if (m_utilWeightRange_.m_count_ > 0) {
	            ranges[0] = new CollationParsedRuleBuilder.WeightRange (m_utilWeightRange_);
	            rangeCount = 1;
	        }
	        for (int length_4 = 2; length_4 <= 4; ++length_4) {
	            // copy upper first so that later the middle range is more likely
	            // the first one to use
	            if (m_utilUpperWeightRange_[length_4].m_count_ > 0) {
	                ranges[rangeCount] = new CollationParsedRuleBuilder.WeightRange (
	                        m_utilUpperWeightRange_[length_4]);
	                ++rangeCount;
	            }
	            if (m_utilLowerWeightRange_[length_4].m_count_ > 0) {
	                ranges[rangeCount] = new CollationParsedRuleBuilder.WeightRange (
	                        m_utilLowerWeightRange_[length_4]);
	                ++rangeCount;
	            }
	        }
	        return rangeCount;
	    }
	
	    /// <summary>
	    /// Truncates the weight with length
	    /// </summary>
	    ///
	    /// <param name="weight"></param>
	    /// <param name="length"></param>
	    /// <returns>truncated weight</returns>
	    private static int TruncateWeight(int weight, int length) {
	        return weight & (-1 << ((4 - length) << 3));
	    }
	
	    /// <summary>
	    /// Length of the weight
	    /// </summary>
	    ///
	    /// <param name="weight"></param>
	    /// <returns>length of the weight</returns>
	    private static int LengthOfWeight(int weight) {
	        if ((weight & 0xffffff) == 0) {
	            return 1;
	        } else if ((weight & 0xffff) == 0) {
	            return 2;
	        } else if ((weight & 0xff) == 0) {
	            return 3;
	        }
	        return 4;
	    }
	
	    /// <summary>
	    /// Increment the weight trail
	    /// </summary>
	    ///
	    /// <param name="weight"></param>
	    /// <param name="length"></param>
	    /// <returns>new weight</returns>
	    private static int IncWeightTrail(int weight, int length) {
	        return weight + (1 << ((4 - length) << 3));
	    }
	
	    /// <summary>
	    /// Decrement the weight trail
	    /// </summary>
	    ///
	    /// <param name="weight"></param>
	    /// <param name="length"></param>
	    /// <returns>new weight</returns>
	    private static int DecWeightTrail(int weight, int length) {
	        return weight - (1 << ((4 - length) << 3));
	    }
	
	    /// <summary>
	    /// Gets the codepoint
	    /// </summary>
	    ///
	    /// <param name="tbl">contraction table</param>
	    /// <param name="codePoint">code point to look for</param>
	    /// <returns>the offset to the code point</returns>
	    private static int FindCP(CollationParsedRuleBuilder.BasicContractionTable  tbl, char codePoint) {
	        int position = 0;
	        while (codePoint > tbl.m_codePoints_[position]) {
	            position++;
	            if (position > tbl.m_codePoints_.Length) {
	                return -1;
	            }
	        }
	        if (codePoint == tbl.m_codePoints_[position]) {
	            return position;
	        } else {
	            return -1;
	        }
	    }
	
	    /// <summary>
	    /// Finds a contraction ce
	    /// </summary>
	    ///
	    /// <param name="table"></param>
	    /// <param name="element"></param>
	    /// <param name="ch"></param>
	    /// <returns>ce</returns>
	    private static int FindCE(CollationParsedRuleBuilder.ContractionTable  table, int element, char ch) {
	        if (table == null) {
	            return CE_NOT_FOUND_;
	        }
	        CollationParsedRuleBuilder.BasicContractionTable  tbl = GetBasicContractionTable(table, element);
	        if (tbl == null) {
	            return CE_NOT_FOUND_;
	        }
	        int position = FindCP(tbl, ch);
	        if (position > tbl.m_CEs_.Count || position < 0) {
	            return CE_NOT_FOUND_;
	        }
	        return ((Int32) tbl.m_CEs_[position]);
	    }
	
	    /// <summary>
	    /// Checks if the string is tailored in the contraction
	    /// </summary>
	    ///
	    /// <param name="table">contraction table</param>
	    /// <param name="element"></param>
	    /// <param name="array">character array to check</param>
	    /// <param name="offset">array offset</param>
	    /// <returns>true if it is tailored</returns>
	    private static bool IsTailored(CollationParsedRuleBuilder.ContractionTable  table, int element,
	            char[] array, int offset) {
	        while (array[offset] != 0) {
	            element = FindCE(table, element, array[offset]);
	            if (element == CE_NOT_FOUND_) {
	                return false;
	            }
	            if (!IsContractionTableElement(element)) {
	                return true;
	            }
	            offset++;
	        }
	        if (GetCE(table, element, 0) != CE_NOT_FOUND_) {
	            return true;
	        } else {
	            return false;
	        }
	    }
	
	    /// <summary>
	    /// Assemble RuleBasedCollator
	    /// </summary>
	    ///
	    /// <param name="t">build table</param>
	    /// <param name="collator">to update</param>
	    private void AssembleTable(CollationParsedRuleBuilder.BuildTable  t, RuleBasedCollator collator) {
	        IntTrieBuilder mapping = t.m_mapping_;
	        ArrayList expansions = t.m_expansions_;
	        CollationParsedRuleBuilder.ContractionTable  contractions = t.m_contractions_;
	        CollationParsedRuleBuilder.MaxExpansionTable  maxexpansion = t.m_maxExpansions_;
	
	        // contraction offset has to be in since we are building on the
	        // UCA contractions
	        // int beforeContractions = (HEADER_SIZE_
	        // + paddedsize(expansions.size() << 2)) >>> 1;
	        collator.m_contractionOffset_ = 0;
	        int contractionsSize = ConstructTable(contractions);
	
	        // the following operation depends on the trie data. Therefore, we have
	        // to do it before the trie is compacted
	        // sets jamo expansions
	        GetMaxExpansionJamo(mapping, maxexpansion, t.m_maxJamoExpansions_,
	                collator.m_isJamoSpecial_);
	
	        // TODO: LATIN1 array is now in the utrie - it should be removed from
	        // the calculation
	        SetAttributes(collator, t.m_options_);
	        // copy expansions
	        int size_0 = expansions.Count;
	        collator.m_expansion_ = new int[size_0];
	        for (int i = 0; i < size_0; i++) {
	            collator.m_expansion_[i] = ((Int32) expansions[i]);
	        }
	        // contractions block
	        if (contractionsSize != 0) {
	            // copy contraction index
	            collator.m_contractionIndex_ = new char[contractionsSize];
	            contractions.m_codePoints_.CopyTo(0,collator.m_contractionIndex_,0,contractionsSize);
	            // copy contraction collation elements
	            collator.m_contractionCE_ = new int[contractionsSize];
	            for (int i_1 = 0; i_1 < contractionsSize; i_1++) {
	                collator.m_contractionCE_[i_1] = ((Int32) contractions.m_CEs_[i_1]);
	            }
        }
	        // copy mapping table
	        collator.m_trie_ = mapping.Serialize(t,
	                RuleBasedCollator.DataManipulate.GetInstance());
	        // copy max expansion table
	        // not copying the first element which is a dummy
	        // to be in synch with icu4c's builder, we continue to use the
	        // expansion offset
	        // omitting expansion offset in builder
	        collator.m_expansionOffset_ = 0;
	        size_0 = maxexpansion.m_endExpansionCE_.Count;
	        collator.m_expansionEndCE_ = new int[size_0 - 1];
	        for(int i_2 = 1; i_2 < size_0; i_2++) {
	            collator.m_expansionEndCE_[i_2 - 1] = ((Int32) maxexpansion.m_endExpansionCE_[i_2]);
	        }
	        collator.m_expansionEndCEMaxSize_ = new sbyte[size_0 - 1];
	        for (int i_3 = 1; i_3 < size_0; i_3++) {
	            collator.m_expansionEndCEMaxSize_[i_3 - 1] = Convert.ToSByte(maxexpansion.m_expansionCESize_[i_3]);
	        }
	        // Unsafe chars table. Finish it off, then copy it.
	        UnsafeCPAddCCNZ(t);
	        // Or in unsafebits from UCA, making a combined table.
	        for (int i_4 = 0; i_4 < UNSAFECP_TABLE_SIZE_; i_4++) {
	            t.m_unsafeCP_[i_4] |= RuleBasedCollator.UCA_.m_unsafe_[i_4];
	        }
	        collator.m_unsafe_ = t.m_unsafeCP_;
	
	        // Finish building Contraction Ending chars hash table and then copy it
	        // out.
	        // Or in unsafebits from UCA, making a combined table
	        for (int i_5 = 0; i_5 < UNSAFECP_TABLE_SIZE_; i_5++) {
	            t.m_contrEndCP_[i_5] |= RuleBasedCollator.UCA_.m_contractionEnd_[i_5];
	        }
	        collator.m_contractionEnd_ = t.m_contrEndCP_;
	    }
	
	    /// <summary>
	    /// Sets this collator to use the all options and tables in UCA.
	    /// </summary>
	    ///
	    /// <param name="collator">which attribute is to be set</param>
	    /// <param name="option">to set with</param>
	    private static void SetAttributes(RuleBasedCollator collator,
	            CollationRuleParser.OptionSet option) {
	        collator.latinOneFailed_ = true;
	        collator.m_caseFirst_ = option.m_caseFirst_;
	        collator.SetDecomposition(option.m_decomposition_);
	        collator.SetAlternateHandlingShifted(option.m_isAlternateHandlingShifted_);
	        collator.SetCaseLevel(option.m_isCaseLevel_);
	        collator.SetFrenchCollation(option.m_isFrenchCollation_);
	        collator.m_isHiragana4_ = option.m_isHiragana4_;
	        collator.SetStrength(option.m_strength_);
	        collator.m_variableTopValue_ = option.m_variableTopValue_;
	        collator.latinOneFailed_ = false;
	    }
	
	    /// <summary>
	    /// Constructing the contraction table
	    /// </summary>
	    ///
	    /// <param name="table">contraction table</param>
	    /// <returns></returns>
	    private int ConstructTable(CollationParsedRuleBuilder.ContractionTable  table) {
	        // See how much memory we need
	        int tsize = table.m_elements_.Count;
	        if (tsize == 0) {
	            return 0;
	        }
	        ILOG.J2CsMapping.Collections.Collections.Clear(table.m_offsets_);
	        int position = 0;
	        for (int i = 0; i < tsize; i++) {
	            table.m_offsets_.Add(((int)(position)));
	            position += ((CollationParsedRuleBuilder.BasicContractionTable ) table.m_elements_[i]).m_CEs_.Count;
	        }
	        ILOG.J2CsMapping.Collections.Collections.Clear(table.m_CEs_);
	        table.m_codePoints_.Remove(0,table.m_codePoints_.Length-(0));
	        // Now stuff the things in
	        StringBuilder cpPointer = table.m_codePoints_;
	        ArrayList CEPointer = table.m_CEs_;
	        for (int i_0 = 0; i_0 < tsize; i_0++) {
	            CollationParsedRuleBuilder.BasicContractionTable  bct = (CollationParsedRuleBuilder.BasicContractionTable ) table.m_elements_[i_0];
	            int size_1 = bct.m_CEs_.Count;
	            char ccMax = (char) (0);
	            char ccMin = (char) (255);
	            int offset = CEPointer.Count;
	            CEPointer.Add(bct.m_CEs_[0]);
	            for (int j = 1; j < size_1; j++) {
	                char ch = bct.m_codePoints_[j];
	                char cc = (char) (IBM.ICU.Lang.UCharacter.GetCombiningClass(ch) & 0xFF);
	                if (cc > ccMax) {
	                    ccMax = cc;
	                }
	                if (cc < ccMin) {
	                    ccMin = cc;
	                }
	                cpPointer.Append(ch);
	                CEPointer.Add(bct.m_CEs_[j]);
	            }
	            cpPointer.Insert(offset,
	                    (char) (((ccMin == ccMax) ? 1 : 0 << 8) | ccMax));
	            for (int j_2 = 0; j_2 < size_1; j_2++) {
	                if (IsContractionTableElement(((Int32) CEPointer[offset
	                                                        + j_2]))) {
	                    int ce = ((Int32) CEPointer[offset + j_2]);
	                    CEPointer[offset + j_2]=((int)(ConstructSpecialCE(GetCETag(ce),
	                                                                                    ((Int32) table.m_offsets_[GetContractionOffset(ce)]))));
	                }
	            }
	        }
	
	        for (int i_3 = 0; i_3 <= 0x10FFFF; i_3++) {
	            int CE = table.m_mapping_.GetValue(i_3);
	            if (IsContractionTableElement(CE)) {
	                CE = ConstructSpecialCE(GetCETag(CE),
	                        ((Int32) table.m_offsets_[GetContractionOffset(CE)]));
	                table.m_mapping_.SetValue(i_3, CE);
	            }
	        }
	        return position;
	    }
	
	    /// <summary>
	    /// Get contraction offset
	    /// </summary>
	    ///
	    /// <param name="ce">collation element</param>
	    /// <returns>contraction offset</returns>
	    private static int GetContractionOffset(int ce) {
	        return ce & 0xFFFFFF;
	    }
	
	    /// <summary>
	    /// Gets the maximum Jamo expansion
	    /// </summary>
	    ///
	    /// <param name="mapping">trie table</param>
	    /// <param name="maxexpansion">maximum expansion table</param>
	    /// <param name="maxjamoexpansion">maximum jamo expansion table</param>
	    /// <param name="jamospecial">is jamo special?</param>
	    private static void GetMaxExpansionJamo(IntTrieBuilder mapping,
	            CollationParsedRuleBuilder.MaxExpansionTable  maxexpansion,
	            CollationParsedRuleBuilder.MaxJamoExpansionTable  maxjamoexpansion, bool jamospecial) {
	        int VBASE = 0x1161;
	        int TBASE = 0x11A8;
	        int VCOUNT = 21;
	        int TCOUNT = 28;
	        int v = VBASE + VCOUNT - 1;
	        int t = TBASE + TCOUNT - 1;
	
	        while (v >= VBASE) {
	            int ce = mapping.GetValue(v);
	            if ((ce & IBM.ICU.Text.RuleBasedCollator.CE_SPECIAL_FLAG_) != IBM.ICU.Text.RuleBasedCollator.CE_SPECIAL_FLAG_) {
	                SetMaxExpansion(ce, (byte) 2, maxexpansion);
	            }
	            v--;
	        }
	
	        while (t >= TBASE) {
	            int ce_0 = mapping.GetValue(t);
	            if ((ce_0 & IBM.ICU.Text.RuleBasedCollator.CE_SPECIAL_FLAG_) != IBM.ICU.Text.RuleBasedCollator.CE_SPECIAL_FLAG_) {
	                SetMaxExpansion(ce_0, (byte) 3, maxexpansion);
	            }
	            t--;
	        }
	        // According to the docs, 99% of the time, the Jamo will not be special
	        if (jamospecial) {
	            // gets the max expansion in all unicode characters
	            int count = maxjamoexpansion.m_endExpansionCE_.Count;
	            byte maxTSize = (byte) (maxjamoexpansion.m_maxLSize_
	                    + maxjamoexpansion.m_maxVSize_ + maxjamoexpansion.m_maxTSize_);
	            byte maxVSize = (byte) (maxjamoexpansion.m_maxLSize_ + maxjamoexpansion.m_maxVSize_);
	
	            while (count > 0) {
	                count--;
	                if ((bool)(((Boolean) maxjamoexpansion.m_isV_[count])) == true) {
	                    SetMaxExpansion(
	                            ((Int32) maxjamoexpansion.m_endExpansionCE_[count]), maxVSize, maxexpansion);
	                } else {
	                    SetMaxExpansion(
	                            ((Int32) maxjamoexpansion.m_endExpansionCE_[count]), maxTSize, maxexpansion);
	                }
	            }
	        }
	    }
	
	    /// <summary>
	    /// To the UnsafeCP hash table, add all chars with combining class != 0
	    /// </summary>
	    ///
	    /// <param name="t">build table</param>
	    private static void UnsafeCPAddCCNZ(CollationParsedRuleBuilder.BuildTable  t) {
	        bool buildCMTable = (buildCMTabFlag & (t.cmLookup == null));
	        char[] cm = null; // combining mark array
	        int[] index_0 = new int[256];
	        int count = 0;
	
	        if (buildCMTable) {
	            cm = new char[0x10000];
	        }
	        for (char c = (char) (0); c < 0xffff; c++) {
	            char fcd = IBM.ICU.Impl.NormalizerImpl.GetFCD16(c);
	            if (fcd >= 0x100 || // if the leading combining class(c) > 0 ||
	                    (IBM.ICU.Text.UTF16.IsLeadSurrogate(c) && fcd != 0)) {
	                // c is a leading surrogate with some FCD data
	                UnsafeCPSet(t.m_unsafeCP_, c);
	                if (buildCMTable && (fcd != 0)) {
	                    int cc = (fcd & 0xff);
	                    int pos_1 = (cc << 8) + index_0[cc];
	                    cm[pos_1] = c;
	                    index_0[cc]++;
	                    count++;
	                }
	            }
	        }
	
	        if (t.m_prefixLookup_ != null) {
	            IIterator els = new ILOG.J2CsMapping.Collections.IteratorAdapter(t.m_prefixLookup_.Values.GetEnumerator());
	            while (els.HasNext()) {
	                CollationParsedRuleBuilder.Elements  e = (CollationParsedRuleBuilder.Elements ) els.Next();
	                // codepoints here are in the NFD form. We need to add the
	                // first code point of the NFC form to unsafe, because
	                // strcoll needs to backup over them.
	                // weiv: This is wrong! See the comment above.
	                // String decomp = Normalizer.decompose(e.m_cPoints_, true);
	                // unsafeCPSet(t.m_unsafeCP_, decomp.charAt(0));
	                // it should be:
	                String comp = IBM.ICU.Text.Normalizer.Compose(e.m_cPoints_, false);
	                UnsafeCPSet(t.m_unsafeCP_, comp[0]);
	            }
	        }
	
	        if (buildCMTable) {
	            t.cmLookup = new CollationParsedRuleBuilder.CombinClassTable ();
	            t.cmLookup.Generate(cm, count, index_0);
	        }
	    }
	
	    /// <summary>
	    /// Create closure
	    /// </summary>
	    ///
	    /// <param name="t">build table</param>
	    /// <param name="collator">RuleBasedCollator</param>
	    /// <param name="colEl">collation element iterator</param>
	    /// <param name="start"></param>
	    /// <param name="limit"></param>
	    /// <param name="type">character type</param>
	    /// <returns></returns>
	    private bool EnumCategoryRangeClosureCategory(CollationParsedRuleBuilder.BuildTable  t,
	            RuleBasedCollator collator, CollationElementIterator colEl,
	            int start, int limit, int type) {
	        if (type != IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.UNASSIGNED
	                && type != IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.PRIVATE_USE) {
	            // if the range is assigned - we might ommit more categories later
	
	            for (int u32 = start; u32 < limit; u32++) {
	                int noOfDec = IBM.ICU.Impl.NormalizerImpl.GetDecomposition(u32, false,
	                        m_utilCharBuffer_, 0, 256);
	                if (noOfDec > 0) {
	                    // if we're positive, that means there is no decomposition
	                    String comp = IBM.ICU.Lang.UCharacter.ToString(u32);
	                    String decomp = new String(m_utilCharBuffer_, 0, noOfDec);
	                    if (!collator.Equals(comp, decomp)) {
	                        m_utilElement_.m_cPoints_ = decomp;
	                        m_utilElement_.m_prefix_ = 0;
	                        CollationParsedRuleBuilder.Elements  prefix = (CollationParsedRuleBuilder.Elements ) t.m_prefixLookup_[m_utilElement_];
	                        if (prefix == null) {
	                            m_utilElement_.m_cPoints_ = comp;
	                            m_utilElement_.m_prefix_ = 0;
	                            m_utilElement_.m_prefixChars_ = null;
	                            colEl.SetText(decomp);
	                            int ce = colEl.Next();
	                            m_utilElement_.m_CELength_ = 0;
	                            while (ce != IBM.ICU.Text.CollationElementIterator.NULLORDER) {
	                                m_utilElement_.m_CEs_[m_utilElement_.m_CELength_++] = ce;
	                                ce = colEl.Next();
	                            }
	                        } else {
	                            m_utilElement_.m_cPoints_ = comp;
	                            m_utilElement_.m_prefix_ = 0;
	                            m_utilElement_.m_prefixChars_ = null;
	                            m_utilElement_.m_CELength_ = 1;
	                            m_utilElement_.m_CEs_[0] = prefix.m_mapCE_;
	                            // This character uses a prefix. We have to add it
	                            // to the unsafe table, as it decomposed form is
	                            // already in. In Japanese, this happens for \u309e
	                            // & \u30fe
	                            // Since unsafeCPSet is static in ucol_elm, we are
	                            // going to wrap it up in the unsafeCPAddCCNZ
	                            // function
	                        }
	                        AddAnElement(t, m_utilElement_);
	                    }
	                }
	            }
	        }
	        return true;
	    }
	
	    /// <summary>
	    /// Determine if a character is a Jamo
	    /// </summary>
	    ///
	    /// <param name="ch">character to test</param>
	    /// <returns>true if ch is a Jamo, false otherwise</returns>
	    private static bool IsJamo(char ch) {
	        return (ch >= 0x1100 && ch <= 0x1112) || (ch >= 0x1175 && ch <= 0x1161)
	                || (ch >= 0x11A8 && ch <= 0x11C2);
	    }
	
	    /// <summary>
	    /// Produces canonical closure
	    /// </summary>
	    ///
	    private void CanonicalClosure(CollationParsedRuleBuilder.BuildTable  t) {
	        CollationParsedRuleBuilder.BuildTable  temp = new CollationParsedRuleBuilder.BuildTable (t);
	        AssembleTable(temp, temp.m_collator_);
	        // produce canonical closure
	        CollationElementIterator coleiter = temp.m_collator_
	                .GetCollationElementIterator("");
	        RangeValueIterator typeiter = IBM.ICU.Lang.UCharacter.GetTypeIterator();
	        RangeValueIterator_Constants.Element element = new RangeValueIterator_Constants.Element();
	        while (typeiter.Next(element)) {
	            EnumCategoryRangeClosureCategory(t, temp.m_collator_, coleiter,
	                    element.start, element.limit, element.value_ren);
	        }
	
	        t.cmLookup = temp.cmLookup;
	        temp.cmLookup = null;
	
	        for (int i = 0; i < m_parser_.m_resultLength_; i++) {
	            char baseChar, firstCM;
	            // now we need to generate the CEs
	            // We stuff the initial value in the buffers, and increase the
	            // appropriate buffer according to strength */
	            // createElements(t, m_parser_.m_listHeader_[i]);
	            CollationRuleParser.Token tok = m_parser_.m_listHeader_[i].m_first_;
	            m_utilElement_.Clear();
	            while (tok != null) {
	                m_utilElement_.m_prefix_ = 0;// el.m_prefixChars_;
	                m_utilElement_.m_cPointsOffset_ = 0; // el.m_uchars_;
	                if (tok.m_prefix_ != 0) {
	                    // we will just copy the prefix here, and adjust accordingly
	                    // in
	                    // the addPrefix function in ucol_elm. The reason is that we
	                    // need to add both composed AND decomposed elements to the
	                    // unsafe table.
	                    int size_0 = tok.m_prefix_ >> 24;
	                    int offset = tok.m_prefix_ & 0x00FFFFFF;
	                    m_utilElement_.m_prefixChars_ = m_parser_.m_source_.ToString(offset,offset + size_0-offset);
	                    size_0 = (tok.m_source_ >> 24) - (tok.m_prefix_ >> 24);
	                    offset = (tok.m_source_ & 0x00FFFFFF)
	                            + (tok.m_prefix_ >> 24);
	                    m_utilElement_.m_uchars_ = m_parser_.m_source_.ToString(offset,offset + size_0-offset);
	                } else {
	                    m_utilElement_.m_prefixChars_ = null;
	                    int offset_1 = tok.m_source_ & 0x00FFFFFF;
	                    int size_2 = MathUtil.URS(tok.m_source_,  24);
	                    m_utilElement_.m_uchars_ = m_parser_.m_source_.ToString(offset_1,offset_1 + size_2-offset_1);
	                }
	                m_utilElement_.m_cPoints_ = m_utilElement_.m_uchars_;
	
	                baseChar = firstCM = ((Char)0); // reset
	                for (int j = 0; j < m_utilElement_.m_cPoints_.Length
	                        - m_utilElement_.m_cPointsOffset_; j++) {
	
	                    char fcd = IBM.ICU.Impl.NormalizerImpl
	                            .GetFCD16(m_utilElement_.m_cPoints_[j]);
	                    if ((fcd & 0xff) == 0) {
	                        baseChar = m_utilElement_.m_cPoints_[j];
	                    } else {
	                        if ((baseChar != 0) && (firstCM == 0)) {
	                            firstCM = m_utilElement_.m_cPoints_[j]; // first
	                                                                           // combining
	                                                                           // mark
	                        }
	                    }
	                }
	
	                if ((baseChar != 0) && (firstCM != 0)) {
	                    AddTailCanonicalClosures(t, temp.m_collator_, coleiter,
	                            baseChar, firstCM);
	                }
	                tok = tok.m_next_;
	            }
	        }
	    }
	
	    private void AddTailCanonicalClosures(CollationParsedRuleBuilder.BuildTable  t,
	            RuleBasedCollator m_collator, CollationElementIterator colEl,
	            char baseChar, char cMark) {
	        if (t.cmLookup == null) {
	            return;
	        }
	        CollationParsedRuleBuilder.CombinClassTable  cmLookup_0 = t.cmLookup;
	        int[] index_1 = cmLookup_0.index;
	        int cClass = IBM.ICU.Impl.NormalizerImpl.GetFCD16(cMark) & 0xff;
	        int maxIndex = 0;
	        char[] precompCh = new char[256];
	        int[] precompClass = new int[256];
	        int precompLen = 0;
	        CollationParsedRuleBuilder.Elements  element = new CollationParsedRuleBuilder.Elements ();
	
	        if (cClass > 0) {
	            maxIndex = index_1[cClass - 1];
	        }
	        for (int i = 0; i < maxIndex; i++) {
	            StringBuilder decompBuf = new StringBuilder();
	            decompBuf.Append(baseChar).Append(cmLookup_0.cPoints[i]);
	            String comp = IBM.ICU.Text.Normalizer.Compose(decompBuf.ToString(), false);
	            if (comp.Length == 1) {
	                precompCh[precompLen] = comp[0];
	                precompClass[precompLen] = (IBM.ICU.Impl.NormalizerImpl
	                        .GetFCD16(cmLookup_0.cPoints[i]) & 0xff);
	                precompLen++;
	                StringBuilder decomp = new StringBuilder();
	                for (int j = 0; j < m_utilElement_.m_cPoints_.Length; j++) {
	                    if (m_utilElement_.m_cPoints_[j] == cMark) {
	                        decomp.Append(cmLookup_0.cPoints[i]);
	                    } else {
	                        decomp.Append(m_utilElement_.m_cPoints_[j]);
	                    }
	                }
	                comp = IBM.ICU.Text.Normalizer.Compose(decomp.ToString(), false);
	                StringBuilder buf = new StringBuilder(comp);
	                buf.Append(cMark);
	                decomp.Append(cMark);
	                comp = buf.ToString();
	
	                element.m_cPoints_ = decomp.ToString();
	                element.m_CELength_ = 0;
	                element.m_prefix_ = 0;
	                CollationParsedRuleBuilder.Elements  prefix = (CollationParsedRuleBuilder.Elements ) t.m_prefixLookup_[element];
	                element.m_cPoints_ = comp;
	                element.m_uchars_ = comp;
	
	                if (prefix == null) {
	                    element.m_prefix_ = 0;
	                    element.m_prefixChars_ = null;
	                    colEl.SetText(decomp.ToString());
	                    int ce = colEl.Next();
	                    element.m_CELength_ = 0;
	                    while (ce != IBM.ICU.Text.CollationElementIterator.NULLORDER) {
	                        element.m_CEs_[element.m_CELength_++] = ce;
	                        ce = colEl.Next();
	                    }
	                } else {
	                    element.m_cPoints_ = comp;
	                    element.m_prefix_ = 0;
	                    element.m_prefixChars_ = null;
	                    element.m_CELength_ = 1;
	                    element.m_CEs_[0] = prefix.m_mapCE_;
	                }
	                SetMapCE(t, element);
	                FinalizeAddition(t, element);
	
	                if (comp.Length > 2) {
	                    // This is a fix for tailoring contractions with accented
	                    // character at the end of contraction string.
	                    AddFCD4AccentedContractions(t, colEl, comp, element);
	                }
	                if (precompLen > 1) {
	                    precompLen = AddMultiCMontractions(t, colEl, element,
	                            precompCh, precompClass, precompLen, cMark, i,
	                            decomp.ToString());
	                }
	            }
	        }
	
	    }
	
	    private void SetMapCE(CollationParsedRuleBuilder.BuildTable  t, CollationParsedRuleBuilder.Elements  element) {
	        ArrayList expansions = t.m_expansions_;
	        element.m_mapCE_ = 0;
	
	        if (element.m_CELength_ == 2 // a two CE expansion
	                && IBM.ICU.Text.RuleBasedCollator.IsContinuation(element.m_CEs_[1])
	                && (element.m_CEs_[1] & (~(0xFF << 24 | IBM.ICU.Text.RuleBasedCollator.CE_CONTINUATION_MARKER_))) == 0 // that
	                                                                                                          // has
	                                                                                                          // only
	                                                                                                          // primaries
	                                                                                                          // in
	                                                                                                          // continuation
	                && (((element.m_CEs_[0] >> 8) & 0xFF) == IBM.ICU.Text.RuleBasedCollator.BYTE_COMMON_)
	                // a common secondary
	                && ((element.m_CEs_[0] & 0xFF) == IBM.ICU.Text.RuleBasedCollator.BYTE_COMMON_)) { // and
	                                                                                     // a
	                                                                                     // common
	                                                                                     // tertiary
	
	            element.m_mapCE_ = IBM.ICU.Text.RuleBasedCollator.CE_SPECIAL_FLAG_
	            // a long primary special
	                    | (CE_LONG_PRIMARY_TAG_ << 24)
	                    // first and second byte of primary
	                    | ((element.m_CEs_[0] >> 8) & 0xFFFF00)
	                    // third byte of primary
	                    | ((element.m_CEs_[1] >> 24) & 0xFF);
	        } else {
	            // omitting expansion offset in builder
	            // (HEADER_SIZE_ >> 2)
	            int expansion = IBM.ICU.Text.RuleBasedCollator.CE_SPECIAL_FLAG_
	                    | (CE_EXPANSION_TAG_ << IBM.ICU.Text.RuleBasedCollator.CE_TAG_SHIFT_)
	                    | (AddExpansion(expansions, element.m_CEs_[0]) << 4)
	                    & 0xFFFFF0;
	
	            for (int i = 1; i < element.m_CELength_; i++) {
	                AddExpansion(expansions, element.m_CEs_[i]);
	            }
	            if (element.m_CELength_ <= 0xF) {
	                expansion |= element.m_CELength_;
	            } else {
	                AddExpansion(expansions, 0);
	            }
	            element.m_mapCE_ = expansion;
	            SetMaxExpansion(element.m_CEs_[element.m_CELength_ - 1],
	                    (byte) element.m_CELength_, t.m_maxExpansions_);
	        }
	    }
	
	    private int AddMultiCMontractions(CollationParsedRuleBuilder.BuildTable  t,
	            CollationElementIterator colEl, CollationParsedRuleBuilder.Elements  element, char[] precompCh,
	            int[] precompClass, int maxComp, char cMark, int cmPos,
	            String decomp) {
	
	        CollationParsedRuleBuilder.CombinClassTable  cmLookup_0 = t.cmLookup;
	        char[] combiningMarks = { cMark };
	        int cMarkClass = (int) (IBM.ICU.Lang.UCharacter.GetCombiningClass(cMark) & 0xFF);
	        String comMark = ILOG.J2CsMapping.Util.StringUtil.NewString(combiningMarks);
	        int noOfPrecomposedChs = maxComp;
	
	        for (int j = 0; j < maxComp; j++) {
	            int count = 0;
	            StringBuilder temp;
	
	            do {
	                String newDecomp, comp;
	
	                if (count == 0) { // Decompose the saved precomposed char.
	                    newDecomp = IBM.ICU.Text.Normalizer.Decompose(
	                            new String(precompCh, j, 1), false);
	                    temp = new StringBuilder(newDecomp);
	                    temp.Append(cmLookup_0.cPoints[cmPos]);
	                    newDecomp = temp.ToString();
	                } else {
	                    temp = new StringBuilder(decomp);
	                    temp.Append(precompCh[j]);
	                    newDecomp = temp.ToString();
	                }
	                comp = IBM.ICU.Text.Normalizer.Compose(newDecomp, false);
	                if (comp.Length == 1) {
	                    temp.Append(cMark);
	                    element.m_cPoints_ = temp.ToString();
	                    element.m_CELength_ = 0;
	                    element.m_prefix_ = 0;
	                    CollationParsedRuleBuilder.Elements  prefix = (CollationParsedRuleBuilder.Elements ) t.m_prefixLookup_[element];
	                    element.m_cPoints_ = comp + comMark;
	                    if (prefix == null) {
	                        element.m_prefix_ = 0;
	                        element.m_prefixChars_ = null;
	                        colEl.SetText(temp.ToString());
	                        int ce = colEl.Next();
	                        element.m_CELength_ = 0;
	                        while (ce != IBM.ICU.Text.CollationElementIterator.NULLORDER) {
	                            element.m_CEs_[element.m_CELength_++] = ce;
	                            ce = colEl.Next();
	                        }
	                    } else {
	                        element.m_cPoints_ = comp;
	                        element.m_prefix_ = 0;
	                        element.m_prefixChars_ = null;
	                        element.m_CELength_ = 1;
	                        element.m_CEs_[0] = prefix.m_mapCE_;
	                    }
	                    SetMapCE(t, element);
	                    FinalizeAddition(t, element);
	                    precompCh[noOfPrecomposedChs] = comp[0];
	                    precompClass[noOfPrecomposedChs] = cMarkClass;
	                    noOfPrecomposedChs++;
	                }
	            } while (++count < 2 && (precompClass[j] == cMarkClass));
	        }
	        return noOfPrecomposedChs;
	    }
	
	    private void AddFCD4AccentedContractions(CollationParsedRuleBuilder.BuildTable  t,
	            CollationElementIterator colEl, String data, CollationParsedRuleBuilder.Elements  element) {
	        String decomp = IBM.ICU.Text.Normalizer.Decompose(data, false);
	        String comp = IBM.ICU.Text.Normalizer.Compose(data, false);
	
	        element.m_cPoints_ = decomp;
	        element.m_CELength_ = 0;
	        element.m_prefix_ = 0;
	        CollationParsedRuleBuilder.Elements  prefix = (CollationParsedRuleBuilder.Elements ) t.m_prefixLookup_[element];
	        if (prefix == null) {
	            element.m_cPoints_ = comp;
	            element.m_prefix_ = 0;
	            element.m_prefixChars_ = null;
	            element.m_CELength_ = 0;
	            colEl.SetText(decomp);
	            int ce = colEl.Next();
	            element.m_CELength_ = 0;
	            while (ce != IBM.ICU.Text.CollationElementIterator.NULLORDER) {
	                element.m_CEs_[element.m_CELength_++] = ce;
	                ce = colEl.Next();
	            }
	            AddAnElement(t, element);
	        }
	    }
	
	    private void ProcessUCACompleteIgnorables(CollationParsedRuleBuilder.BuildTable  t) {
	        TrieIterator trieiterator = new TrieIterator(
	                RuleBasedCollator.UCA_.m_trie_);
	        RangeValueIterator_Constants.Element element = new RangeValueIterator_Constants.Element();
	        while (trieiterator.Next(element)) {
	            int start = element.start;
	            int limit = element.limit;
	            if (element.value_ren == 0) {
	                while (start < limit) {
	                    int CE = t.m_mapping_.GetValue(start);
	                    if (CE == CE_NOT_FOUND_) {
	                        m_utilElement_.m_prefix_ = 0;
	                        m_utilElement_.m_uchars_ = IBM.ICU.Lang.UCharacter.ToString(start);
	                        m_utilElement_.m_cPoints_ = m_utilElement_.m_uchars_;
	                        m_utilElement_.m_cPointsOffset_ = 0;
	                        m_utilElement_.m_CELength_ = 1;
	                        m_utilElement_.m_CEs_[0] = 0;
	                        AddAnElement(t, m_utilElement_);
	                    }
	                    start++;
	                }
	            }
	        }
	    }
	
	    static CollationParsedRuleBuilder() {
	            CollationParsedRuleBuilder.InverseUCA  temp = null;
	            try {
	                temp = IBM.ICU.Text.CollatorReader.GetInverseUCA();
	            } catch (IOException e) {
	            }
	            if (temp != null && IBM.ICU.Text.RuleBasedCollator.UCA_ != null) {
	                if (!temp.m_UCA_version_
	                        .Equals(RuleBasedCollator.UCA_.m_UCA_version_)) {
	                    throw new Exception(INV_UCA_VERSION_MISMATCH_);
	                }
	            } else {
	                throw new Exception(UCA_NOT_INSTANTIATED_);
	            }
	            INVERSE_UCA_ = temp;
	        }
	}
}
