/*
 **********************************************************************
 *   Copyright (c) 2001-2005, International Business Machines
 *   Corporation and others.  All Rights Reserved.
 **********************************************************************
 *   Date        Name        Description
 *   08/19/2001  aliu        Creation.
 **********************************************************************
 */

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:30 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Text {
	
	using IBM.ICU.Impl;
	using IBM.ICU.Util;
	using ILOG.J2CsMapping.Collections;
	using ILOG.J2CsMapping.Collections.Generics;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.Globalization;
	using System.IO;
	using System.Reflection;
	using System.Resources;
	using System.Runtime.CompilerServices;
	using System.Text;
     using ILOG.J2CsMapping.Util;
     using ILOG.J2CsMapping.Util;
	
	internal class TransliteratorRegistry {
	
	    // char constants
	    private const char LOCALE_SEP = '_';
	
	    // String constants
	    private const String NO_VARIANT = ""; // empty string
	
	    private const String ANY = "Any";
	
	    /// <summary>
	    /// Dynamic registry mapping full IDs to Entry objects. This contains both
	    /// public and internal entities. The visibility is controlled by whether an
	    /// entry is listed in availableIDs and specDAG or not.
	    /// Keys are CaseInsensitiveString objects. Values are objects of class Class
	    /// (subclass of Transliterator), RuleBasedTransliterator.Data,
	    /// Transliterator.Factory, or one of the entry classes defined here
	    /// (AliasEntry or ResourceEntry).
	    /// </summary>
	    ///
	    private Hashtable registry;
	
	    /// <summary>
	    /// DAG of visible IDs by spec. Hashtable: source => (Hashtable: target =>
	    /// (Vector: variant)) The Vector of variants is never empty. For a
	    /// source-target with no variant, the special variant NO_VARIANT (the empty
	    /// string) is stored in slot zero of the UVector.
	    /// Keys are CaseInsensitiveString objects. Values are Hashtable of
	    /// (CaseInsensitiveString -> Vector of CaseInsensitiveString)
	    /// </summary>
	    ///
	    private Hashtable specDAG;
	
	    /// <summary>
	    /// Vector of public full IDs (CaseInsensitiveString objects).
	    /// </summary>
	    ///
	    private ArrayList availableIDs;
	
	    // ----------------------------------------------------------------------
	    // class Spec
	    // ----------------------------------------------------------------------
	
	    /// <summary>
	    /// A Spec is a string specifying either a source or a target. In more
	    /// general terms, it may also specify a variant, but we only use the Spec
	    /// class for sources and targets.
	    /// A Spec may be a locale or a script. If it is a locale, it has a fallback
	    /// chain that goes xx_YY_ZZZ -> xx_YY -> xx -> ssss, where ssss is the
	    /// script mapping of xx_YY_ZZZ. The Spec API methods hasFallback(), next(),
	    /// and reset() iterate over this fallback sequence.
	    /// The Spec class canonicalizes itself, so the locale is put into canonical
	    /// form, or the script is transformed from an abbreviation to a full name.
	    /// </summary>
	    ///
	    internal class Spec {
	
	        private String top; // top spec
	
	        private String spec; // current spec
	
	        private String nextSpec; // next spec
	
	        private String scriptName; // script name equivalent of top, if != top
	
	        private bool isSpecLocale; // TRUE if spec is a locale
	
	        private bool isNextLocale; // TRUE if nextSpec is a locale
	
	        private ICUResourceBundle res;
	
	        public Spec(String theSpec) {
	            top = theSpec;
	            spec = null;
	            scriptName = null;
	            try {
	                // Canonicalize script name. If top is a script name then
	                // script != UScript.INVALID_CODE.
	                int script = IBM.ICU.Lang.UScript.GetCodeFromName(top);
	
	                // Canonicalize script name -or- do locale->script mapping
	                int[] s = IBM.ICU.Lang.UScript.GetCode(top);
	                if (s != null) {
	                    scriptName = IBM.ICU.Lang.UScript.GetName(s[0]);
	                    // If the script name is the same as top then it's redundant
	                    if (scriptName.Equals(top,StringComparison.InvariantCultureIgnoreCase)) {
	                        scriptName = null;
	                    }
	                }
	
	                isSpecLocale = false;
	                res = null;
	                // If 'top' is not a script name, try a locale lookup
	                if (script == IBM.ICU.Lang.UScript.INVALID_CODE) {
	                    Locale toploc = IBM.ICU.Impl.LocaleUtility.GetLocaleFromName(top);
	                    res = (ICUResourceBundle) IBM.ICU.Util.UResourceBundle
	                            .GetBundleInstance(
	                                    IBM.ICU.Impl.ICUResourceBundle.ICU_TRANSLIT_BASE_NAME,
	                                    toploc);
	                    // Make sure we got the bundle we wanted; otherwise, don't
	                    // use it
	                    if (res != null
	                            && IBM.ICU.Impl.LocaleUtility.IsFallbackOf(res.GetULocale()
	                                    .ToString(), top)) {
	                        isSpecLocale = true;
	                    }
	                }
	            } catch (MissingManifestResourceException e) {
	                scriptName = null;
	            }
	            // assert(spec != top);
	            Reset();
	        }
	
	        public bool HasFallback() {
	            return nextSpec != null;
	        }
	
	        public void Reset() {
	            if (spec != top) { // [sic] pointer comparison
	                spec = top;
	                isSpecLocale = (res != null);
	                SetupNext();
	            }
	        }
	
	        public void SetupNext() {
	            isNextLocale = false;
	            if (isSpecLocale) {
	                nextSpec = spec;
	                int i = nextSpec.LastIndexOf(IBM.ICU.Text.TransliteratorRegistry.LOCALE_SEP);
	                // If i == 0 then we have _FOO, so we fall through
	                // to the scriptName.
	                if (i > 0) {
	                    nextSpec = spec.Substring(0,(i)-(0));
	                    isNextLocale = true;
	                } else {
	                    nextSpec = scriptName; // scriptName may be null
	                }
	            } else {
	                // Fallback to the script, which may be null
	                if (nextSpec != scriptName) {
	                    nextSpec = scriptName;
	                } else {
	                    nextSpec = null;
	                }
	            }
	        }
	
	        // Protocol:
	        // for(String& s(spec.get());
	        // spec.hasFallback(); s(spec.next())) { ...
	
	        public String Next() {
	            spec = nextSpec;
	            isSpecLocale = isNextLocale;
	            SetupNext();
	            return spec;
	        }
	
	        public String Get() {
	            return spec;
	        }
	
	        public bool IsLocale() {
	            return isSpecLocale;
	        }
	
	        /// <summary>
	        /// Return the ResourceBundle for this spec, at the current level of
	        /// iteration. The level of iteration goes from aa_BB_CCC to aa_BB to aa.
	        /// If the bundle does not correspond to the current level of iteration,
	        /// return null. If isLocale() is false, always return null.
	        /// </summary>
	        ///
	        public ResourceBundle GetBundle() {
	            if (res != null && res.GetULocale().ToString().Equals(spec)) {
	                return res;
	            }
	            return null;
	        }
	
	        public String GetTop() {
	            return top;
	        }
	    }
	
	    // ----------------------------------------------------------------------
	    // Entry classes
	    // ----------------------------------------------------------------------
	
	    internal class ResourceEntry {
	        public String resource;
	
	        public String encoding;
	
	        public int direction;
	
	        public ResourceEntry(String n, String enc, int d) {
	            resource = n;
	            encoding = enc;
	            direction = d;
	        }
	    }
	
	    // An entry representing a rule in a locale resource bundle
	    internal class LocaleEntry {
	        public String rule;
	
	        public int direction;
	
	        public LocaleEntry(String r, int d) {
	            rule = r;
	            direction = d;
	        }
	    }
	
	    internal class AliasEntry {
	        public String alias;
	
	        public AliasEntry(String a) {
	            alias = a;
	        }
	    }
	
	    internal class CompoundRBTEntry {
	        private String ID;
	
	        private ArrayList idBlockVector;
	
	        private ArrayList dataVector;
	
	        private UnicodeSet compoundFilter;
	
	        public CompoundRBTEntry(String theID, ArrayList theIDBlockVector,
	                ArrayList theDataVector, UnicodeSet theCompoundFilter) {
	            ID = theID;
	            idBlockVector = theIDBlockVector;
	            dataVector = theDataVector;
	            compoundFilter = theCompoundFilter;
	        }
	
	        public Transliterator GetInstance() {
	            ArrayList transliterators = new ArrayList();
	            int passNumber = 1;
	
	            int limit = Math.Max(idBlockVector.Count,dataVector.Count);
	            for (int i = 0; i < limit; i++) {
	                if (i < idBlockVector.Count) {
	                    String idBlock = (String) idBlockVector[i];
	                    if (idBlock.Length > 0)
	                        transliterators
	                                .Add(IBM.ICU.Text.Transliterator.GetInstance(idBlock));
	                }
	                if (i < dataVector.Count) {
	                    RuleBasedTransliterator.Data data = (RuleBasedTransliterator.Data) dataVector[i];
	                    transliterators.Add(new RuleBasedTransliterator("%Pass"
	                            + passNumber++, data, null));
	                }
	            }
	
	            Transliterator t = new CompoundTransliterator(transliterators,
	                    passNumber - 1);
	            t.SetID(ID);
	            if (compoundFilter != null) {
	                t.SetFilter(compoundFilter);
	            }
	            return t;
	        }
	    }
	
	    // ----------------------------------------------------------------------
	    // class TransliteratorRegistry: Basic public API
	    // ----------------------------------------------------------------------
	
	    public TransliteratorRegistry() {
	        registry = new Hashtable();
	        specDAG = new Hashtable();
	        availableIDs = new ArrayList();
	    }
	
	    /// <summary>
	    /// Given a simple ID (forward direction, no inline filter, not compound)
	    /// attempt to instantiate it from the registry. Return 0 on failure.
	    /// Return a non-empty aliasReturn value if the ID points to an alias. We
	    /// cannot instantiate it ourselves because the alias may contain filters or
	    /// compounds, which we do not understand. Caller should make aliasReturn
	    /// empty before calling.
	    /// </summary>
	    ///
	    public Transliterator Get(String ID_0, StringBuilder aliasReturn) {
	        Object[] entry = Find(ID_0);
	        return (entry == null) ? null
	                : InstantiateEntry(ID_0, entry, aliasReturn);
	    }
	
	    /// <summary>
	    /// Register a class. This adds an entry to the dynamic store, or replaces an
	    /// existing entry. Any entry in the underlying static locale resource store
	    /// is masked.
	    /// </summary>
	    ///
	    public void Put(String ID_0, Type transliteratorSubclass, bool visible) {
	        RegisterEntry(ID_0, transliteratorSubclass, visible);
	    }
	
	    /// <summary>
	    /// Register an ID and a factory function pointer. This adds an entry to the
	    /// dynamic store, or replaces an existing entry. Any entry in the underlying
	    /// static locale resource store is masked.
	    /// </summary>
	    ///
	    public void Put(String ID_0, Transliterator.Factory factory, bool visible) {
	        RegisterEntry(ID_0, factory, visible);
	    }
	
	    /// <summary>
	    /// Register an ID and a resource name. This adds an entry to the dynamic
	    /// store, or replaces an existing entry. Any entry in the underlying static
	    /// locale resource store is masked.
	    /// </summary>
	    ///
	    public void Put(String ID_0, String resourceName, String encoding_1, int dir,
	            bool visible) {
	        RegisterEntry(ID_0, new TransliteratorRegistry.ResourceEntry (resourceName, encoding_1, dir),
	                visible);
	    }
	
	    /// <summary>
	    /// Register an ID and an alias ID. This adds an entry to the dynamic store,
	    /// or replaces an existing entry. Any entry in the underlying static locale
	    /// resource store is masked.
	    /// </summary>
	    ///
	    public void Put(String ID_0, String alias_1, bool visible) {
	        RegisterEntry(ID_0, new TransliteratorRegistry.AliasEntry (alias_1), visible);
	    }
	
	    /// <summary>
	    /// Register an ID and a Transliterator object. This adds an entry to the
	    /// dynamic store, or replaces an existing entry. Any entry in the underlying
	    /// static locale resource store is masked.
	    /// </summary>
	    ///
	    public void Put(String ID_0, Transliterator trans, bool visible) {
	        RegisterEntry(ID_0, trans, visible);
	    }
	
	    /// <summary>
	    /// Unregister an ID. This removes an entry from the dynamic store if there
	    /// is one. The static locale resource store is unaffected.
	    /// </summary>
	    ///
	    public void Remove(String ID_0) {
	        String[] stv = IBM.ICU.Text.TransliteratorIDParser.IDtoSTV(ID_0);
	        // Only need to do this if ID.indexOf('-') < 0
	        String id = IBM.ICU.Text.TransliteratorIDParser.STVtoID(stv[0], stv[1], stv[2]);
	        ILOG.J2CsMapping.Collections.Collections.Remove(registry,new CaseInsensitiveString(id));
	        RemoveSTV(stv[0], stv[1], stv[2]);
	        ILOG.J2CsMapping.Collections.Collections.Remove(availableIDs,new CaseInsensitiveString(id));
	    }
	
	    // ----------------------------------------------------------------------
	    // class TransliteratorRegistry: Public ID and spec management
	    // ----------------------------------------------------------------------
	
	    /// <summary>
	    /// An internal class that adapts an enumeration over CaseInsensitiveStrings
	    /// to an enumeration over Strings.
	    /// </summary>
	    ///
	    private class IDEnumeration : IIterator {
	        internal IIterator en;
	
	        public IDEnumeration(IIterator e) {
	            en = e;
	        }
	
	        public virtual bool HasNext() {
	            return en != null && en.HasNext();
	        }
	
	        public virtual Object NextElement() {
	            return ((CaseInsensitiveString) en.Next()).GetString();
	        }
	    		


        #region IIterator Members


        public void Remove()
        {
            throw new NotImplementedException();
        }

        #endregion

        #region IIterator Members


        public object Next()
        {
            throw new NotImplementedException();
        }

        #endregion
        }
	
	    /// <summary>
	    /// Returns an enumeration over the programmatic names of visible registered
	    /// transliterators.
	    /// </summary>
	    ///
	    /// <returns>An <c>Enumeration</c> over <c>String</c> objects</returns>
	    public IIterator GetAvailableIDs() {
	        // Since the cache contains CaseInsensitiveString objects, but
	        // the caller expects Strings, we have to use an intermediary.
	        return new TransliteratorRegistry.IDEnumeration (new ILOG.J2CsMapping.Collections.IteratorAdapter(availableIDs.GetEnumerator()));
	    }
	
	    /// <summary>
	    /// Returns an enumeration over all visible source names.
	    /// </summary>
	    ///
	    /// <returns>An <c>Enumeration</c> over <c>String</c> objects</returns>
	    public IIterator GetAvailableSources() {
	        return new TransliteratorRegistry.IDEnumeration (new ILOG.J2CsMapping.Collections.IteratorAdapter(specDAG.Keys.GetEnumerator()));
	    }
	
	    /// <summary>
	    /// Returns an enumeration over visible target names for the given source.
	    /// </summary>
	    ///
	    /// <returns>An <c>Enumeration</c> over <c>String</c> objects</returns>
	    public IIterator GetAvailableTargets(String source) {
	        CaseInsensitiveString cisrc = new CaseInsensitiveString(source);
	        Hashtable targets = (Hashtable) specDAG[cisrc];
	        if (targets == null) {
	            return new TransliteratorRegistry.IDEnumeration (null);
	        }
	        return new TransliteratorRegistry.IDEnumeration (new ILOG.J2CsMapping.Collections.IteratorAdapter(targets.Keys.GetEnumerator()));
	    }
	
	    /// <summary>
	    /// Returns an enumeration over visible variant names for the given source
	    /// and target.
	    /// </summary>
	    ///
	    /// <returns>An <c>Enumeration</c> over <c>String</c> objects</returns>
	    public IIterator GetAvailableVariants(String source, String target) {
	        CaseInsensitiveString cisrc = new CaseInsensitiveString(source);
	        CaseInsensitiveString citrg = new CaseInsensitiveString(target);
	        Hashtable targets = (Hashtable) specDAG[cisrc];
	        if (targets == null) {
	            return new TransliteratorRegistry.IDEnumeration (null);
	        }
	        ArrayList variants = (ArrayList) targets[citrg];
	        if (variants == null) {
	            return new TransliteratorRegistry.IDEnumeration (null);
	        }
	        return new TransliteratorRegistry.IDEnumeration (new ILOG.J2CsMapping.Collections.IteratorAdapter(variants.GetEnumerator()));
	    }
	
	    // ----------------------------------------------------------------------
	    // class TransliteratorRegistry: internal
	    // ----------------------------------------------------------------------
	
	    /// <summary>
	    /// Convenience method. Calls 6-arg registerEntry().
	    /// </summary>
	    ///
	    private void RegisterEntry(String source, String target, String variant,
	            Object entry, bool visible) {
	        String s = source;
	        if (s.Length == 0) {
	            s = ANY;
	        }
	        String ID_0 = IBM.ICU.Text.TransliteratorIDParser.STVtoID(source, target, variant);
	        RegisterEntry(ID_0, s, target, variant, entry, visible);
	    }
	
	    /// <summary>
	    /// Convenience method. Calls 6-arg registerEntry().
	    /// </summary>
	    ///
	    private void RegisterEntry(String ID_0, Object entry, bool visible) {
	        String[] stv = IBM.ICU.Text.TransliteratorIDParser.IDtoSTV(ID_0);
	        // Only need to do this if ID.indexOf('-') < 0
	        String id = IBM.ICU.Text.TransliteratorIDParser.STVtoID(stv[0], stv[1], stv[2]);
	        RegisterEntry(id, stv[0], stv[1], stv[2], entry, visible);
	    }
	
	    /// <summary>
	    /// Register an entry object (adopted) with the given ID, source, target, and
	    /// variant strings.
	    /// </summary>
	    ///
	    private void RegisterEntry(String ID_0, String source, String target,
	            String variant, Object entry, bool visible) {
	        CaseInsensitiveString ciID = new CaseInsensitiveString(ID_0);
	
	        // Store the entry within an array so it can be modified later
	        if (!(entry  is  Object[])) {
	            entry = new Object[] { entry };
	        }
	
	        ILOG.J2CsMapping.Collections.Collections.Put(registry,ciID,entry);
	        if (visible) {
	            RegisterSTV(source, target, variant);
	            if (!availableIDs.Contains(ciID)) {
	                availableIDs.Add(ciID);
	            }
	        } else {
	            RemoveSTV(source, target, variant);
	            ILOG.J2CsMapping.Collections.Collections.Remove(availableIDs,ciID);
	        }
	    }
	
	    /// <summary>
	    /// Register a source-target/variant in the specDAG. Variant may be empty,
	    /// but source and target must not be. If variant is empty then the special
	    /// variant NO_VARIANT is stored in slot zero of the UVector of variants.
	    /// </summary>
	    ///
	    private void RegisterSTV(String source, String target, String variant) {
	        // assert(source.length() > 0);
	        // assert(target.length() > 0);
	        CaseInsensitiveString cisrc = new CaseInsensitiveString(source);
	        CaseInsensitiveString citrg = new CaseInsensitiveString(target);
	        CaseInsensitiveString civar = new CaseInsensitiveString(variant);
	        Hashtable targets = (Hashtable) specDAG[cisrc];
	        if (targets == null) {
	            targets = new Hashtable();
	            ILOG.J2CsMapping.Collections.Collections.Put(specDAG,cisrc,targets);
	        }
	        ArrayList variants = (ArrayList) targets[citrg];
	        if (variants == null) {
	            variants = new ArrayList();
	            ILOG.J2CsMapping.Collections.Collections.Put(targets,citrg,variants);
	        }
	        // assert(NO_VARIANT == "");
	        // We add the variant string. If it is the special "no variant"
	        // string, that is, the empty string, we add it at position zero.
	        if (!variants.Contains(civar)) {
	            if (variant.Length > 0) {
	                variants.Add(civar);
	            } else {
	                variants.Insert(0,civar);
	            }
	        }
	    }
	
	    /// <summary>
	    /// Remove a source-target/variant from the specDAG.
	    /// </summary>
	    ///
	    private void RemoveSTV(String source, String target, String variant) {
	        // assert(source.length() > 0);
	        // assert(target.length() > 0);
	        CaseInsensitiveString cisrc = new CaseInsensitiveString(source);
	        CaseInsensitiveString citrg = new CaseInsensitiveString(target);
	        CaseInsensitiveString civar = new CaseInsensitiveString(variant);
	        Hashtable targets = (Hashtable) specDAG[cisrc];
	        if (targets == null) {
	            return; // should never happen for valid s-t/v
	        }
	        ArrayList variants = (ArrayList) targets[citrg];
	        if (variants == null) {
	            return; // should never happen for valid s-t/v
	        }
	        ILOG.J2CsMapping.Collections.Collections.Remove(variants,civar);
	        if (variants.Count == 0) {
	            ILOG.J2CsMapping.Collections.Collections.Remove(targets,citrg); // should delete variants
	            if (targets.Count == 0) {
	                ILOG.J2CsMapping.Collections.Collections.Remove(specDAG,cisrc); // should delete targets
	            }
	        }
	    }
	
	    private const bool DEBUG = false;
	
	    /// <summary>
	    /// Attempt to find a source-target/variant in the dynamic registry store.
	    /// Return 0 on failure.
	    /// </summary>
	    ///
	    private Object[] FindInDynamicStore(TransliteratorRegistry.Spec  src, TransliteratorRegistry.Spec  trg, String variant) {
	        String ID_0 = IBM.ICU.Text.TransliteratorIDParser.STVtoID(src.Get(), trg.Get(),
	                variant);
	        if (DEBUG) {
	            System.Console.Out.WriteLine("TransliteratorRegistry.findInDynamicStore:"
	                    + ID_0);
	        }
	        return (Object[]) registry[new CaseInsensitiveString(ID_0)];
	    }
	
	    /// <summary>
	    /// Attempt to find a source-target/variant in the static locale resource
	    /// store. Do not perform fallback. Return 0 on failure.
	    /// On success, create a new entry object, register it in the dynamic store,
	    /// and return a pointer to it, but do not make it public -- just because
	    /// someone requested something, we do not expand the available ID list (or
	    /// spec DAG).
	    /// </summary>
	    ///
	    private Object[] FindInStaticStore(TransliteratorRegistry.Spec  src, TransliteratorRegistry.Spec  trg, String variant) {
	        if (DEBUG) {
	            String ID_0 = IBM.ICU.Text.TransliteratorIDParser.STVtoID(src.Get(), trg.Get(),
	                    variant);
	            System.Console.Out
	                    .WriteLine("TransliteratorRegistry.findInStaticStore:" + ID_0);
	        }
	        Object[] entry = null;
	        if (src.IsLocale()) {
	            entry = FindInBundle(src, trg, variant, IBM.ICU.Text.Transliterator.FORWARD);
	        } else if (trg.IsLocale()) {
	            entry = FindInBundle(trg, src, variant, IBM.ICU.Text.Transliterator.REVERSE);
	        }
	
	        // If we found an entry, store it in the Hashtable for next
	        // time.
	        if (entry != null) {
	            RegisterEntry(src.GetTop(), trg.GetTop(), variant, entry, false);
	        }
	
	        return entry;
	    }
	
	    /// <summary>
	    /// Attempt to find an entry in a single resource bundle. This is a one-sided
	    /// lookup. findInStaticStore() performs up to two such lookups, one for the
	    /// source, and one for the target.
	    /// Do not perform fallback. Return 0 on failure.
	    /// On success, create a new Entry object, populate it, and return it. The
	    /// caller owns the returned object.
	    /// </summary>
	    ///
	    private Object[] FindInBundle(TransliteratorRegistry.Spec  specToOpen, TransliteratorRegistry.Spec  specToFind,
	            String variant, int direction_0) {
	        // assert(specToOpen.isLocale());
	        ResourceBundle res_1 = specToOpen.GetBundle();
	
	        if (res_1 == null) {
	            // This means that the bundle's locale does not match
	            // the current level of iteration for the spec.
	            return null;
	        }
	
	        for (int pass = 0; pass < 2; ++pass) {
	            StringBuilder tag = new StringBuilder();
	            // First try either TransliteratorTo_xxx or
	            // TransliterateFrom_xxx, then try the bidirectional
	            // Transliterate_xxx. This precedence order is arbitrary
	            // but must be consistent and documented.
	            if (pass == 0) {
	                tag.Append((direction_0 == IBM.ICU.Text.Transliterator.FORWARD) ? "TransliterateTo"
	                        : "TransliterateFrom");
	            } else {
	                tag.Append("Transliterate");
	            }
	            tag.Append(specToFind.Get().ToUpper());
	
	            try {
	                // The Transliterate*_xxx resource is an array of
	                // strings of the format { <v0>, <r0>, ... }. Each
	                // <vi> is a variant name, and each <ri> is a rule.
	                String[] subres = res_1.GetStringArray(tag.ToString());
	
	                // assert(subres != null);
	                // assert(subres.length % 2 == 0);
	                int i = 0;
	                if (variant.Length != 0) {
	                    for (i = 0; i < subres.Length; i += 2) {
	                        if (subres[i].Equals(variant,StringComparison.InvariantCultureIgnoreCase)) {
	                            break;
	                        }
	                    }
	                }
	
	                if (i < subres.Length) {
	                    // We have a match, or there is no variant and i == 0.
	                    // We have succeeded in loading a string from the
	                    // locale resources. Return the rule string which
	                    // will itself become the registry entry.
	
	                    // The direction is always forward for the
	                    // TransliterateTo_xxx and TransliterateFrom_xxx
	                    // items; those are unidirectional forward rules.
	                    // For the bidirectional Transliterate_xxx items,
	                    // the direction is the value passed in to this
	                    // function.
	                    int dir = (pass == 0) ? IBM.ICU.Text.Transliterator.FORWARD : direction_0;
	                    return new Object[] { new TransliteratorRegistry.LocaleEntry (subres[i + 1], dir) };
	                }
	
	            } catch (MissingManifestResourceException e) {
	                if (DEBUG)
	                    System.Console.Out.WriteLine("missing resource: " + e);
	            }
	        }
	
	        // If we get here we had a missing resource exception or we
	        // failed to find a desired variant.
	        return null;
	    }
	
	    /// <summary>
	    /// Convenience method. Calls 3-arg find().
	    /// </summary>
	    ///
	    private Object[] Find(String ID_0) {
	        String[] stv = IBM.ICU.Text.TransliteratorIDParser.IDtoSTV(ID_0);
	        return Find(stv[0], stv[1], stv[2]);
	    }
	
	    /// <summary>
	    /// Top-level find method. Attempt to find a source-target/variant in either
	    /// the dynamic or the static (locale resource) store. Perform fallback.
	    /// Lookup sequence for ss_SS_SSS-tt_TT_TTT/v:
	    /// ss_SS_SSS-tt_TT_TTT/v -- in hashtable ss_SS_SSS-tt_TT_TTT/v -- in
	    /// ss_SS_SSS (no fallback)
	    /// repeat with t = tt_TT_TTT, tt_TT, tt, and tscript
	    /// ss_SS_SSS-t//// ss_SS-t//// ss-t//// sscript-t/
	    /// Here/// matches the first variant listed.
	    /// Caller does NOT own returned object. Return 0 on failure.
	    /// </summary>
	    ///
	    private Object[] Find(String source, String target, String variant) {
	
	        TransliteratorRegistry.Spec  src = new TransliteratorRegistry.Spec (source);
	        TransliteratorRegistry.Spec  trg = new TransliteratorRegistry.Spec (target);
	        Object[] entry = null;
	
	        if (variant.Length != 0) {
	
	            // Seek exact match in hashtable
	            entry = FindInDynamicStore(src, trg, variant);
	            if (entry != null) {
	                return entry;
	            }
	
	            // Seek exact match in locale resources
	            entry = FindInStaticStore(src, trg, variant);
	            if (entry != null) {
	                return entry;
	            }
	        }
	
	        for (;;) {
	            src.Reset();
	            for (;;) {
	                // Seek match in hashtable
	                entry = FindInDynamicStore(src, trg, NO_VARIANT);
	                if (entry != null) {
	                    return entry;
	                }
	
	                // Seek match in locale resources
	                entry = FindInStaticStore(src, trg, NO_VARIANT);
	                if (entry != null) {
	                    return entry;
	                }
	                if (!src.HasFallback()) {
	                    break;
	                }
	                src.Next();
	            }
	            if (!trg.HasFallback()) {
	                break;
	            }
	            trg.Next();
	        }
	
	        return null;
	    }
	
	    /// <summary>
	    /// Given an Entry object, instantiate it. Caller owns result. Return 0 on
	    /// failure.
	    /// Return a non-empty aliasReturn value if the ID points to an alias. We
	    /// cannot instantiate it ourselves because the alias may contain filters or
	    /// compounds, which we do not understand. Caller should make aliasReturn
	    /// empty before calling.
	    /// The entry object is assumed to reside in the dynamic store. It may be
	    /// modified.
	    /// </summary>
	    ///
	    private Transliterator InstantiateEntry(String ID_0, Object[] entryWrapper,
	            StringBuilder aliasReturn) {
	        // We actually modify the entry object in some cases. If it
	        // is a string, we may partially parse it and turn it into a
	        // more processed precursor. This makes the next
	        // instantiation faster and allows sharing of immutable
	        // components like the RuleBasedTransliterator.Data objects.
	        // For this reason, the entry object is an Object[] of length
	        // 1.
	
	        for (;;) {
	            Object entry = entryWrapper[0];
	
	            if (entry  is  RuleBasedTransliterator.Data) {
	                RuleBasedTransliterator.Data data = (RuleBasedTransliterator.Data) entry;
	                return new RuleBasedTransliterator(ID_0, data, null);
	            } else if (entry  is  Type) {
	                try {
	                    return (Transliterator) Activator.CreateInstance(((Type) entry));
	                } catch (TargetException e) {
	                } catch (MemberAccessException e2) {
	                }
	                return null;
	            } else if (entry  is  TransliteratorRegistry.AliasEntry ) {
	                aliasReturn.Append(((TransliteratorRegistry.AliasEntry ) entry).alias);
	                return null;
	            } else if (entry  is  Transliterator.Factory) {
	                return ((Transliterator.Factory) entry).GetInstance(ID_0);
	            } else if (entry  is  TransliteratorRegistry.CompoundRBTEntry ) {
	                return ((TransliteratorRegistry.CompoundRBTEntry ) entry).GetInstance();
	            } else if (entry  is  Transliterator) {
	                return (Transliterator) entry;
	            }
	
	            // At this point entry type must be either RULES_FORWARD or
	            // RULES_REVERSE. We process the rule data into a
	            // TransliteratorRuleData object, and possibly also into an
	            // .id header and/or footer. Then we modify the registry with
	            // the parsed data and retry.
	
	            TransliteratorParser parser = new TransliteratorParser();
	
	            try {
	
	                TransliteratorRegistry.ResourceEntry  re = (TransliteratorRegistry.ResourceEntry ) entry;
	                parser.Parse(re.resource, re.direction);
	
	            } catch (InvalidCastException e_1) {
	                // If we pull a rule from a locale resource bundle it will
	                // be a LocaleEntry.
	                TransliteratorRegistry.LocaleEntry  le = (TransliteratorRegistry.LocaleEntry ) entry;
	                parser.Parse(le.rule, le.direction);
	            }
	
	            // Reset entry to something that we process at the
	            // top of the loop, then loop back to the top. As long as we
	            // do this, we only loop through twice at most.
	            // NOTE: The logic here matches that in
	            // Transliterator.createFromRules().
	            if (parser.idBlockVector.Count == 0
	                    && parser.dataVector.Count == 0) {
	                // No idBlock, no data -- this is just an
	                // alias for Null
	                entryWrapper[0] = new TransliteratorRegistry.AliasEntry (IBM.ICU.Text.NullTransliterator._ID);
	            } else if (parser.idBlockVector.Count == 0
	                    && parser.dataVector.Count == 1) {
	                // No idBlock, data != 0 -- this is an
	                // ordinary RBT_DATA
	                entryWrapper[0] = parser.dataVector[0];
	            } else if (parser.idBlockVector.Count == 1
	                    && parser.dataVector.Count == 0) {
	                // idBlock, no data -- this is an alias. The ID has
	                // been munged from reverse into forward mode, if
	                // necessary, so instantiate the ID in the forward
	                // direction.
	                if (parser.compoundFilter != null)
	                    entryWrapper[0] = new TransliteratorRegistry.AliasEntry (
	                            parser.compoundFilter.ToPattern(false) + ";"
	                                    + (String) parser.idBlockVector[0]);
	                else
	                    entryWrapper[0] = new TransliteratorRegistry.AliasEntry (
	                            (String) parser.idBlockVector[0]);
	            } else {
	                entryWrapper[0] = new TransliteratorRegistry.CompoundRBTEntry (ID_0,
	                        parser.idBlockVector, parser.dataVector,
	                        parser.compoundFilter);
	            }
	        }
	    }
	}
	
	// eof
}
