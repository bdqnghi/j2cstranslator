/*
 *******************************************************************************
 * Copyright (C) 2007, International Business Machines Corporation and         *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 */
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:47 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Impl {
	
	using IBM.ICU.Text;
	using IBM.ICU.Util;
	using ILOG.J2CsMapping.Collections;
	using ILOG.J2CsMapping.Collections.Generics;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Resources;
	using System.Runtime.CompilerServices;
	
	public class ZoneStringFormat {
	    /// <summary>
	    /// Constructs a ZoneStringFormat by zone strings array. The internal
	    /// structure of zoneStrings is compatible with the one used by
	    /// getZoneStrings/setZoneStrings in DateFormatSymbols.
	    /// </summary>
	    ///
	    /// <param name="zoneStrings">zone strings</param>
	    public ZoneStringFormat(String[][] zoneStrings) {
	        tzidToStrings = new Hashtable();
	        zoneStringsTrie = new TextTrieMap(true);
	        for (int i = 0; i < zoneStrings.Length; i++) {
	            String tzid = zoneStrings[i][0];
	            String[] names = new String[ZSIDX_MAX];
	            for (int j = 1; j < zoneStrings[i].Length; j++) {
	                if (zoneStrings[i][j] != null) {
	                    int typeIdx = GetNameTypeIndex(j);
	                    if (typeIdx != -1) {
	                        names[typeIdx] = zoneStrings[i][j];
	
	                        // Put the name into the trie
	                        int type = GetNameType(typeIdx);
	                        ZoneStringFormat.ZoneStringInfo  zsinfo = new ZoneStringFormat.ZoneStringInfo (tzid,
	                                zoneStrings[i][j], type);
	                        zoneStringsTrie.Put(zoneStrings[i][j], zsinfo);
	                    }
	
	                }
	            }
	            ZoneStringFormat.ZoneStrings  zstrings = new ZoneStringFormat.ZoneStrings (names, true, null);
	            ILOG.J2CsMapping.Collections.Collections.Put(tzidToStrings,tzid,zstrings);
	        }
	    }
	
	    /// <summary>
	    /// Gets an instance of ZoneStringFormat for the specified locale
	    /// </summary>
	    ///
	    /// <param name="locale">the locale</param>
	    /// <returns>An instance of ZoneStringFormat for the locale</returns>
	    public static ZoneStringFormat GetInstance(ULocale locale) {
	        ZoneStringFormat tzf = (ZoneStringFormat) TZFORMAT_CACHE.Get(locale);
	        if (tzf == null) {
	            tzf = new ZoneStringFormat(locale);
	            TZFORMAT_CACHE.Put(locale, tzf);
	        }
	        return tzf;
	    }
	
	    public String[][] GetZoneStrings() {
	        return GetZoneStrings(DateTime.Now.Millisecond);
	    }
	
	    // APIs used by SimpleDateFormat to get a zone string
	    public String GetSpecificLongString(Calendar cal) {
	        if (cal.Get(IBM.ICU.Util.Calendar.DST_OFFSET) == 0) {
	            return GetString(cal.GetTimeZone().GetID(), ZSIDX_LONG_STANDARD,
	                    cal.GetTimeInMillis(), false /* not used */);
	        }
	        return GetString(cal.GetTimeZone().GetID(), ZSIDX_LONG_DAYLIGHT,
	                cal.GetTimeInMillis(), false /* not used */);
	    }
	
	    public String GetSpecificShortString(Calendar cal, bool commonlyUsedOnly) {
	        if (cal.Get(IBM.ICU.Util.Calendar.DST_OFFSET) == 0) {
	            return GetString(cal.GetTimeZone().GetID(), ZSIDX_SHORT_STANDARD,
	                    cal.GetTimeInMillis(), commonlyUsedOnly);
	        }
	        return GetString(cal.GetTimeZone().GetID(), ZSIDX_SHORT_DAYLIGHT,
	                cal.GetTimeInMillis(), commonlyUsedOnly);
	    }
	
	    public String GetGenericLongString(Calendar cal) {
	        return GetGenericString(cal, false /* long */, false /* not used */);
	    }
	
	    public String GetGenericShortString(Calendar cal, bool commonlyUsedOnly) {
	        return GetGenericString(cal, true /* long */, commonlyUsedOnly);
	    }
	
	    public String GetGenericLocationString(Calendar cal) {
	        return GetString(cal.GetTimeZone().GetID(), ZSIDX_LOCATION,
	                cal.GetTimeInMillis(), false /* not used */);
	    }
	
	    // APIs used by SimpleDateFormat to lookup a zone string
	    public class ZoneStringInfo {
	        private String id;
	
	        private String str;
	
	        private int type;
	
	        public ZoneStringInfo(String id_0, String str_1, int type_2) {
	            this.id = id_0;
	            this.str = str_1;
	            this.type = type_2;
	        }
	
	        public String GetID() {
	            return id;
	        }
	
	        public String GetString() {
	            return str;
	        }
	
	        public bool IsStandard() {
	            if ((type & IBM.ICU.Impl.ZoneStringFormat.STANDARD_LONG) != 0 || (type & IBM.ICU.Impl.ZoneStringFormat.STANDARD_SHORT) != 0) {
	                return true;
	            }
	            return false;
	        }
	
	        public bool IsDaylight() {
	            if ((type & IBM.ICU.Impl.ZoneStringFormat.DAYLIGHT_LONG) != 0 || (type & IBM.ICU.Impl.ZoneStringFormat.DAYLIGHT_SHORT) != 0) {
	                return true;
	            }
	            return false;
	        }
	
	        public bool IsGeneric() {
	            return !IsStandard() && !IsDaylight();
	        }
	
	        public int GetType() {
	            return type;
	        }
	    }
	
	    public ZoneStringFormat.ZoneStringInfo  FindSpecificLong(String text, int start) {
	        return Find(text, start, STANDARD_LONG | DAYLIGHT_LONG);
	    }
	
	    public ZoneStringFormat.ZoneStringInfo  FindSpecificShort(String text, int start) {
	        return Find(text, start, STANDARD_SHORT | DAYLIGHT_SHORT);
	    }
	
	    public ZoneStringFormat.ZoneStringInfo  FindGenericLong(String text, int start) {
	        return Find(text, start, GENERIC_LONG | STANDARD_LONG | LOCATION);
	    }
	
	    public ZoneStringFormat.ZoneStringInfo  FindGenericShort(String text, int start) {
	        return Find(text, start, GENERIC_SHORT | STANDARD_SHORT | LOCATION);
	    }
	
	    public ZoneStringFormat.ZoneStringInfo  FindGenericLocation(String text, int start) {
	        return Find(text, start, LOCATION);
	    }
	
	    // Following APIs are not used by SimpleDateFormat, but public for testing
	    // purpose
	    public String GetLongStandard(String tzid, long date) {
	        return GetString(tzid, ZSIDX_LONG_STANDARD, date, false /* not used */);
	    }
	
	    public String GetLongDaylight(String tzid, long date) {
	        return GetString(tzid, ZSIDX_LONG_DAYLIGHT, date, false /* not used */);
	    }
	
	    public String GetLongGenericNonLocation(String tzid, long date) {
	        return GetString(tzid, ZSIDX_LONG_GENERIC, date, false /* not used */);
	    }
	
	    public String GetLongGenericPartialLocation(String tzid, long date) {
	        return GetGenericPartialLocationString(tzid, false, date, false /*
	                                                                         * not
	                                                                         * used
	                                                                         */);
	    }
	
	    public String GetShortStandard(String tzid, long date,
	            bool commonlyUsedOnly) {
	        return GetString(tzid, ZSIDX_SHORT_STANDARD, date, commonlyUsedOnly);
	    }
	
	    public String GetShortDaylight(String tzid, long date,
	            bool commonlyUsedOnly) {
	        return GetString(tzid, ZSIDX_SHORT_DAYLIGHT, date, commonlyUsedOnly);
	    }
	
	    public String GetShortGenericNonLocation(String tzid, long date,
	            bool commonlyUsedOnly) {
	        return GetString(tzid, ZSIDX_SHORT_GENERIC, date, commonlyUsedOnly);
	    }
	
	    public String GetShortGenericPartialLocation(String tzid, long date,
	            bool commonlyUsedOnly) {
	        return GetGenericPartialLocationString(tzid, true, date,
	                commonlyUsedOnly);
	    }
	
	    public String GetGenericLocation(String tzid) {
	        return GetString(tzid, ZSIDX_LOCATION, 0x0L, false /*
	                                                                         * not
	                                                                         * used
	                                                                         */);
	    }
	
	    /// <summary>
	    /// Constructs a ZoneStringFormat by locale. Because an instance of
	    /// ZoneStringFormat is read-only, only one instance for a locale is
	    /// sufficient. Thus, this constructor is protected and only called from
	    /// getInstance(ULocale) to create one for a locale.
	    /// </summary>
	    ///
	    /// <param name="locale">The locale</param>
	    protected internal ZoneStringFormat(ULocale locale) {
	        this.locale = locale;
	        tzidToStrings = new Hashtable();
	        mzidToStrings = new Hashtable();
	        zoneStringsTrie = new TextTrieMap(true);
	
	        ICUResourceBundle zoneStringsBundle = null;
	        try {
	            ICUResourceBundle bundle = (ICUResourceBundle) IBM.ICU.Util.UResourceBundle
	                    .GetBundleInstance(IBM.ICU.Impl.ICUResourceBundle.ICU_BASE_NAME, locale);
	            zoneStringsBundle = bundle.GetWithFallback("zoneStrings");
	        } catch (MissingManifestResourceException e) {
	            // If no locale bundles are available, zoneStringsBundle will be
	            // null.
	            // We still want to go through the rest of zone strings
	            // initialization,
	            // because generic location format is generated from tzid for the
	            // case.
	            // The rest of code should work even zoneStrings is null.
	        }
	
	        String[] zoneIDs = IBM.ICU.Util.TimeZone.GetAvailableIDs();
	        IBM.ICU.Text.MessageFormat fallbackFmt = GetFallbackFormat(locale);
	        IBM.ICU.Text.MessageFormat regionFmt = GetRegionFormat(locale);
	
	        String[] zstrarray = new String[ZSIDX_MAX];
	        String[] mzstrarray = new String[ZSIDX_MAX];
	        String[][] mzPartialLoc = (String[][])ILOG.J2CsMapping.Collections.Arrays.CreateJaggedArray(typeof(String), 10, 4); // maximum 10 metazones per
	                                                     // zone
	
	        for (int i = 0; i < zoneIDs.Length; i++) {
	            // Skip IDs that are not canonicalized...
	            if (!zoneIDs[i].Equals(IBM.ICU.Impl.ZoneMeta.GetCanonicalID(zoneIDs[i]))) {
	                continue;
	            }
	            String tzid = zoneIDs[i];
	
	            String zoneKey = tzid.Replace('/', ':');
	            zstrarray[ZSIDX_LONG_STANDARD] = GetZoneStringFromBundle(
	                    zoneStringsBundle, zoneKey, RESKEY_LONG_STANDARD);
	            zstrarray[ZSIDX_SHORT_STANDARD] = GetZoneStringFromBundle(
	                    zoneStringsBundle, zoneKey, RESKEY_SHORT_STANDARD);
	            zstrarray[ZSIDX_LONG_DAYLIGHT] = GetZoneStringFromBundle(
	                    zoneStringsBundle, zoneKey, RESKEY_LONG_DAYLIGHT);
	            zstrarray[ZSIDX_SHORT_DAYLIGHT] = GetZoneStringFromBundle(
	                    zoneStringsBundle, zoneKey, RESKEY_SHORT_DAYLIGHT);
	            zstrarray[ZSIDX_LONG_GENERIC] = GetZoneStringFromBundle(
	                    zoneStringsBundle, zoneKey, RESKEY_LONG_GENERIC);
	            zstrarray[ZSIDX_SHORT_GENERIC] = GetZoneStringFromBundle(
	                    zoneStringsBundle, zoneKey, RESKEY_SHORT_GENERIC);
	
	            // Compose location format string
	            String countryCode = IBM.ICU.Impl.ZoneMeta.GetCanonicalCountry(tzid);
	            String country = null;
	            String city = null;
	            if (countryCode != null) {
	                city = GetZoneStringFromBundle(zoneStringsBundle, zoneKey,
	                        RESKEY_EXEMPLAR_CITY);
	                if (city == null) {
	                    city = tzid.Substring(tzid.LastIndexOf('/') + 1).Replace(
	                            '_', ' ');
	                }
	                country = GetLocalizedCountry(countryCode, locale);
	                if (IBM.ICU.Impl.ZoneMeta.GetSingleCountry(tzid) != null) {
	                    // If the zone is only one zone in the country, do not add
	                    // city
	                    zstrarray[ZSIDX_LOCATION] = regionFmt
	                            .FormatObject(new Object[] { country });
	                } else {
	                    zstrarray[ZSIDX_LOCATION] = fallbackFmt
	                            .FormatObject(new Object[] { city, country });
	                }
	            } else {
	                zstrarray[ZSIDX_LOCATION] = null;
	            }
	
	            bool commonlyUsed = IsCommonlyUsed(zoneStringsBundle, zoneKey);
	
	            // Resolve metazones used by this zone
	            int mzPartialLocIdx = 0;
	            IDictionary olsonToMeta = IBM.ICU.Impl.ZoneMeta.GetOlsonToMetaMap();
	            IList metazoneMappings = (IList) ILOG.J2CsMapping.Collections.Collections.Get(olsonToMeta,tzid);
	            if (metazoneMappings != null) {
	                IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(metazoneMappings.GetEnumerator());
	                while (it.HasNext()) {
	                    ZoneMeta.OlsonToMetaMappingEntry mzmap = (ZoneMeta.OlsonToMetaMappingEntry) it
	                            .Next();
	                    ZoneStringFormat.ZoneStrings  mzStrings = (ZoneStringFormat.ZoneStrings ) ILOG.J2CsMapping.Collections.Collections.Get(mzidToStrings,mzmap.mzid);
	                    if (mzStrings == null) {
	                        // If the metazone strings are not yet processed, do it
	                        // now.
	                        String mzkey = "meta:" + mzmap.mzid;
	                        bool mzCommonlyUsed = IsCommonlyUsed(
	                                zoneStringsBundle, mzkey);
	                        mzstrarray[ZSIDX_LONG_STANDARD] = GetZoneStringFromBundle(
	                                zoneStringsBundle, mzkey, RESKEY_LONG_STANDARD);
	                        mzstrarray[ZSIDX_SHORT_STANDARD] = GetZoneStringFromBundle(
	                                zoneStringsBundle, mzkey, RESKEY_SHORT_STANDARD);
	                        mzstrarray[ZSIDX_LONG_DAYLIGHT] = GetZoneStringFromBundle(
	                                zoneStringsBundle, mzkey, RESKEY_LONG_DAYLIGHT);
	                        mzstrarray[ZSIDX_SHORT_DAYLIGHT] = GetZoneStringFromBundle(
	                                zoneStringsBundle, mzkey, RESKEY_SHORT_DAYLIGHT);
	                        mzstrarray[ZSIDX_LONG_GENERIC] = GetZoneStringFromBundle(
	                                zoneStringsBundle, mzkey, RESKEY_LONG_GENERIC);
	                        mzstrarray[ZSIDX_SHORT_GENERIC] = GetZoneStringFromBundle(
	                                zoneStringsBundle, mzkey, RESKEY_SHORT_GENERIC);
	                        mzstrarray[ZSIDX_LOCATION] = null;
	                        mzStrings = new ZoneStringFormat.ZoneStrings (mzstrarray, mzCommonlyUsed,
	                                null);
	                        ILOG.J2CsMapping.Collections.Collections.Put(mzidToStrings,mzmap.mzid,mzStrings);
	
	                        // Add metazone strings to the zone string trie
	                        String preferredIdForLocale = IBM.ICU.Impl.ZoneMeta
	                                .GetZoneIdByMetazone(mzmap.mzid, GetRegion());
	                        for (int j = 0; j < mzstrarray.Length; j++) {
	                            if (mzstrarray[j] != null) {
	                                int type_0 = GetNameType(j);
	                                ZoneStringFormat.ZoneStringInfo  zsinfo = new ZoneStringFormat.ZoneStringInfo (
	                                        preferredIdForLocale, mzstrarray[j],
	                                        type_0);
	                                zoneStringsTrie.Put(mzstrarray[j], zsinfo);
	                            }
	                        }
	                    }
	                    // Compose generic partial location format
	                    String lg = mzStrings.GetString(ZSIDX_LONG_GENERIC);
	                    String sg = mzStrings.GetString(ZSIDX_SHORT_GENERIC);
	                    if (lg != null || sg != null) {
	                        bool addMzPartialLocationNames = true;
	                        for (int j_1 = 0; j_1 < mzPartialLocIdx; j_1++) {
	                            if (mzPartialLoc[j_1][0].Equals(mzmap.mzid)) {
	                                // already added
	                                addMzPartialLocationNames = false;
	                                break;
	                            }
	                        }
	                        if (addMzPartialLocationNames) {
	                            String locationPart = null;
	                            // Check if the zone is the preferred zone for the
	                            // territory associated with the zone
	                            String preferredID = IBM.ICU.Impl.ZoneMeta.GetZoneIdByMetazone(
	                                    mzmap.mzid, countryCode);
	                            if (tzid.Equals(preferredID)) {
	                                // Use country for the location
	                                locationPart = country;
	                            } else {
	                                // Use city for the location
	                                locationPart = city;
	                            }
	                            mzPartialLoc[mzPartialLocIdx][0] = mzmap.mzid;
	                            mzPartialLoc[mzPartialLocIdx][1] = null;
	                            mzPartialLoc[mzPartialLocIdx][2] = null;
	                            mzPartialLoc[mzPartialLocIdx][3] = null;
	                            if (locationPart != null) {
	                                if (lg != null) {
	                                    mzPartialLoc[mzPartialLocIdx][1] = fallbackFmt
	                                            .FormatObject(new Object[] {
	                                                    locationPart, lg });
	                                }
	                                if (sg != null) {
	                                    mzPartialLoc[mzPartialLocIdx][2] = fallbackFmt
	                                            .FormatObject(new Object[] {
	                                                    locationPart, sg });
	                                    bool shortMzCommonlyUsed = mzStrings
	                                            .IsShortFormatCommonlyUsed();
	                                    if (shortMzCommonlyUsed) {
	                                        mzPartialLoc[mzPartialLocIdx][3] = "1";
	                                    }
	                                }
	                            }
	                            mzPartialLocIdx++;
	                        }
	                    }
	                }
	            }
	            String[][] genericPartialLocationNames = null;
	            if (mzPartialLocIdx != 0) {
	                // metazone generic partial location names are collected
	                genericPartialLocationNames = new String[mzPartialLocIdx][];
	                for (int mzi = 0; mzi < mzPartialLocIdx; mzi++) {
	                    genericPartialLocationNames[mzi] = (String[]) mzPartialLoc[mzi]
	                            .Clone();
	                }
	            }
	            // Finally, create ZoneStrings instance and put it into the
	            // tzidToStinrgs map
	            ZoneStringFormat.ZoneStrings  zstrings = new ZoneStringFormat.ZoneStrings (zstrarray, commonlyUsed,
	                    genericPartialLocationNames);
	            ILOG.J2CsMapping.Collections.Collections.Put(tzidToStrings,tzid,zstrings);
	
	            // Also add all available names to the zone string trie
	            if (zstrarray != null) {
	                for (int j_2 = 0; j_2 < zstrarray.Length; j_2++) {
	                    if (zstrarray[j_2] != null) {
	                        int type_3 = GetNameType(j_2);
	                        ZoneStringFormat.ZoneStringInfo  zsinfo_4 = new ZoneStringFormat.ZoneStringInfo (tzid,
	                                zstrarray[j_2], type_3);
	                        zoneStringsTrie.Put(zstrarray[j_2], zsinfo_4);
	                    }
	                }
	            }
	            if (genericPartialLocationNames != null) {
	                for (int j_5 = 0; j_5 < genericPartialLocationNames.Length; j_5++) {
	                    ZoneStringFormat.ZoneStringInfo  zsinfo_6;
	                    if (genericPartialLocationNames[j_5][1] != null) {
	                        zsinfo_6 = new ZoneStringFormat.ZoneStringInfo (tzid,
	                                genericPartialLocationNames[j_5][1], GENERIC_LONG);
	                        zoneStringsTrie.Put(genericPartialLocationNames[j_5][1],
	                                zsinfo_6);
	                    }
	                    if (genericPartialLocationNames[j_5][2] != null) {
	                        zsinfo_6 = new ZoneStringFormat.ZoneStringInfo (tzid,
	                                genericPartialLocationNames[j_5][1],
	                                GENERIC_SHORT);
	                        zoneStringsTrie.Put(genericPartialLocationNames[j_5][2],
	                                zsinfo_6);
	                    }
	                }
	            }
	        }
	    }
	
	    // Name types, these bit flag are used for zone string lookup
	    private const int LOCATION = 0x0001;
	
	    private const int GENERIC_LONG = 0x0002;
	
	    private const int GENERIC_SHORT = 0x0004;
	
	    private const int STANDARD_LONG = 0x0008;
	
	    private const int STANDARD_SHORT = 0x0010;
	
	    private const int DAYLIGHT_LONG = 0x0020;
	
	    private const int DAYLIGHT_SHORT = 0x0040;
	
	    // Name type index, these constants are used for index in
	    // ZoneStrings.strings
	    private const int ZSIDX_LOCATION = 0;
	
	    private const int ZSIDX_LONG_STANDARD = 1;
	
	    private const int ZSIDX_SHORT_STANDARD = 2;
	
	    private const int ZSIDX_LONG_DAYLIGHT = 3;
	
	    private const int ZSIDX_SHORT_DAYLIGHT = 4;
	
	    private const int ZSIDX_LONG_GENERIC = 5;
	
	    private const int ZSIDX_SHORT_GENERIC = 6;
	
	    private const int ZSIDX_MAX = ZSIDX_SHORT_GENERIC + 1;
	
	    // ZoneStringFormat cache
	    private static ICUCache TZFORMAT_CACHE = new SimpleCache();
	
	    /*
	     * The translation type of the translated zone strings
	     */
	    private const String RESKEY_SHORT_GENERIC = "sg",
	            RESKEY_SHORT_STANDARD = "ss", RESKEY_SHORT_DAYLIGHT = "sd",
	            RESKEY_LONG_GENERIC = "lg", RESKEY_LONG_STANDARD = "ls",
	            RESKEY_LONG_DAYLIGHT = "ld", RESKEY_EXEMPLAR_CITY = "ec",
	            RESKEY_COMMONLY_USED = "cu";
	
	    // Window size used for DST check for a zone in a metazone
	    private const long DST_CHECK_RANGE = 184L * (24 * 60 * 60 * 1000);
	
	    // Map from zone id to ZoneStrings
	    private IDictionary tzidToStrings;
	
	    // Map from metazone id to ZoneStrings
	    private IDictionary mzidToStrings;
	
	    // Zone string dictionary, used for look up
	    private TextTrieMap zoneStringsTrie;
	
	    // Locale used for initializing zone strings
	    private ULocale locale;
	
	    // Region used for resolving a zone in a metazone, initialized by locale
	    private String region;
	
	    /*
	     * Private method to get a zone string except generic partial location
	     * types.
	     */
	    private String GetString(String tzid, int typeIdx, long date,
	            bool commonlyUsedOnly) {
	        String result = null;
	        ZoneStringFormat.ZoneStrings  zstrings = (ZoneStringFormat.ZoneStrings ) ILOG.J2CsMapping.Collections.Collections.Get(tzidToStrings,tzid);
	        if (zstrings == null) {
	            // ICU's own array does not have entries for aliases
	            tzid = IBM.ICU.Impl.ZoneMeta.GetCanonicalID(tzid);
	            zstrings = (ZoneStringFormat.ZoneStrings ) ILOG.J2CsMapping.Collections.Collections.Get(tzidToStrings,tzid);
	        }
	        if (zstrings != null) {
	            switch (typeIdx) {
	            case ZSIDX_LONG_STANDARD:
	            case ZSIDX_LONG_DAYLIGHT:
	            case ZSIDX_LONG_GENERIC:
	            case ZSIDX_LOCATION:
	                result = zstrings.GetString(typeIdx);
	                break;
	            case ZSIDX_SHORT_STANDARD:
	            case ZSIDX_SHORT_DAYLIGHT:
	            case ZSIDX_SHORT_GENERIC:
	                if (!commonlyUsedOnly || zstrings.IsShortFormatCommonlyUsed()) {
	                    result = zstrings.GetString(typeIdx);
	                }
	                break;
	            }
	        }
	        if (result == null && mzidToStrings != null
	                && typeIdx != ZSIDX_LOCATION) {
	            // Try metazone
	            String mzid = IBM.ICU.Impl.ZoneMeta.GetMetazoneID(tzid, date);
	            if (mzid != null) {
	                ZoneStringFormat.ZoneStrings  mzstrings = (ZoneStringFormat.ZoneStrings ) ILOG.J2CsMapping.Collections.Collections.Get(mzidToStrings,mzid);
	                if (mzstrings != null) {
	                    switch (typeIdx) {
	                    case ZSIDX_LONG_STANDARD:
	                    case ZSIDX_LONG_DAYLIGHT:
	                    case ZSIDX_LONG_GENERIC:
	                        result = mzstrings.GetString(typeIdx);
	                        break;
	                    case ZSIDX_SHORT_STANDARD:
	                    case ZSIDX_SHORT_DAYLIGHT:
	                    case ZSIDX_SHORT_GENERIC:
	                        if (!commonlyUsedOnly
	                                || mzstrings.IsShortFormatCommonlyUsed()) {
	                            result = mzstrings.GetString(typeIdx);
	                        }
	                        break;
	                    }
	                }
	            }
	        }
	        return result;
	    }
	
	    /*
	     * Private method to get a generic string, with fallback logic involved,
	     * that is,
	     * 
	     * 1. If a generic non-location string is avaiable for the zone, return it.
	     * 2. If a generic non-location string is associated with a metazone and the
	     * zone never use daylight time around the given date, use the standard
	     * string (if available).
	     * 
	     * Note: In CLDR1.5.1, the same localization is used for generic and
	     * standard. In this case, we do not use the standard string and do the
	     * rest.
	     * 
	     * 3. If a generic non-location string is associated with a metazone and the
	     * offset at the given time is different from the preferred zone for the
	     * current locale, then return the generic partial location string (if
	     * avaiable) 4. If a generic non-location string is not available, use
	     * generic location string.
	     */
	    private String GetGenericString(Calendar cal, bool isShort,
	            bool commonlyUsedOnly) {
	        String result = null;
	        IBM.ICU.Util.TimeZone tz = cal.GetTimeZone();
	        String tzid = tz.GetID();
	        ZoneStringFormat.ZoneStrings  zstrings = (ZoneStringFormat.ZoneStrings ) ILOG.J2CsMapping.Collections.Collections.Get(tzidToStrings,tzid);
	        if (zstrings == null) {
	            // ICU's own array does not have entries for aliases
	            tzid = IBM.ICU.Impl.ZoneMeta.GetCanonicalID(tzid);
	            zstrings = (ZoneStringFormat.ZoneStrings ) ILOG.J2CsMapping.Collections.Collections.Get(tzidToStrings,tzid);
	        }
	        if (zstrings != null) {
	            if (isShort) {
	                if (!commonlyUsedOnly || zstrings.IsShortFormatCommonlyUsed()) {
	                    result = zstrings.GetString(ZSIDX_SHORT_GENERIC);
	                }
	            } else {
	                result = zstrings.GetString(ZSIDX_LONG_GENERIC);
	            }
	        }
	        if (result == null && mzidToStrings != null) {
	            // try metazone
	            long time = cal.GetTimeInMillis();
	            String mzid = IBM.ICU.Impl.ZoneMeta.GetMetazoneID(tzid, time);
	            if (mzid != null) {
	                bool useStandard = false;
	                if (cal.Get(IBM.ICU.Util.Calendar.DST_OFFSET) == 0) {
	                    useStandard = true;
	                    // Check if the zone actually uses daylight saving time
	                    // around the time
	                    if (tz  is  BasicTimeZone) {
	                        BasicTimeZone btz = (BasicTimeZone) tz;
	                        TimeZoneTransition before = btz.GetPreviousTransition(
	                                time, true);
	                        if (before != null
	                                && (time - before.GetTime() < DST_CHECK_RANGE)
	                                && before.GetFrom().GetDSTSavings() != 0) {
	                            useStandard = false;
	                        } else {
	                            TimeZoneTransition after = btz.GetNextTransition(
	                                    time, false);
	                            if (after != null
	                                    && (after.GetTime() - time < DST_CHECK_RANGE)
	                                    && after.GetTo().GetDSTSavings() != 0) {
	                                useStandard = false;
	                            }
	                        }
	                    } else {
	                        // If not BasicTimeZone... only if the instance is not
	                        // an ICU's implementation.
	                        // We may get a wrong answer in edge case, but it should
	                        // practically work OK.
	                        int[] offsets = new int[2];
	                        tz.GetOffset(time - DST_CHECK_RANGE, false, offsets);
	                        if (offsets[1] != 0) {
	                            useStandard = false;
	                        } else {
	                            tz.GetOffset(time + DST_CHECK_RANGE, false, offsets);
	                            if (offsets[1] != 0) {
	                                useStandard = false;
	                            }
	                        }
	                    }
	                }
	                if (useStandard) {
	                    result = GetString(tzid, ((isShort) ? ZSIDX_SHORT_STANDARD
	                            : ZSIDX_LONG_STANDARD), time, commonlyUsedOnly);
	
	                    // Note:
	                    // In CLDR 1.5.1, a same localization is used for both
	                    // generic and standard
	                    // for some metazones in some locales. This is actually data
	                    // bugs and should
	                    // be resolved in later versions of CLDR. For now, we check
	                    // if the standard
	                    // name is different from its generic name below.
	                    if (result != null) {
	                        String genericNonLocation = GetString(tzid,
	                                ((isShort) ? ZSIDX_SHORT_GENERIC
	                                        : ZSIDX_LONG_GENERIC), time,
	                                commonlyUsedOnly);
	                        if (genericNonLocation != null
	                                && result.Equals(genericNonLocation,StringComparison.InvariantCultureIgnoreCase)) {
	                            result = null;
	                        }
	                    }
	                }
	                if (result == null) {
	                    ZoneStringFormat.ZoneStrings  mzstrings = (ZoneStringFormat.ZoneStrings ) ILOG.J2CsMapping.Collections.Collections.Get(mzidToStrings,mzid);
	                    if (mzstrings != null) {
	                        if (isShort) {
	                            if (!commonlyUsedOnly
	                                    || mzstrings.IsShortFormatCommonlyUsed()) {
	                                result = mzstrings
	                                        .GetString(ZSIDX_SHORT_GENERIC);
	                            }
	                        } else {
	                            result = mzstrings.GetString(ZSIDX_LONG_GENERIC);
	                        }
	                    }
	                    if (result != null) {
	                        // Check if the offsets at the given time matches the
	                        // preferred zone's offsets
	                        String preferredId = IBM.ICU.Impl.ZoneMeta.GetZoneIdByMetazone(mzid,
	                                GetRegion());
	                        if (!tzid.Equals(preferredId)) {
	                            // Check if the offsets at the given time are
	                            // identical with the preferred zone
	                            int raw = cal.Get(IBM.ICU.Util.Calendar.ZONE_OFFSET);
	                            int sav = cal.Get(IBM.ICU.Util.Calendar.DST_OFFSET);
	                            IBM.ICU.Util.TimeZone preferredZone = IBM.ICU.Util.TimeZone
	                                    .GetTimeZone(preferredId);
	                            int[] preferredOffsets = new int[2];
	                            // Check offset in preferred time zone with wall
	                            // time.
	                            // With getOffset(time, false, preferredOffsets),
	                            // you may get incorrect results because of time
	                            // overlap at DST->STD
	                            // transition.
	                            preferredZone.GetOffset(time + raw + sav, true,
	                                    preferredOffsets);
	                            if (raw != preferredOffsets[0]
	                                    || sav != preferredOffsets[1]) {
	                                // Use generic partial location string as
	                                // fallback
	                                result = zstrings
	                                        .GetGenericPartialLocationString(mzid,
	                                                isShort, commonlyUsedOnly);
	                            }
	                        }
	                    }
	                }
	            }
	        }
	        if (result == null) {
	            // Use location format as the final fallback
	            result = GetString(tzid, ZSIDX_LOCATION, cal.GetTimeInMillis(),
	                    false /* not used */);
	        }
	        return result;
	    }
	
	    /*
	     * Private method to get a generic partial location string
	     */
	    private String GetGenericPartialLocationString(String tzid,
	            bool isShort, long date, bool commonlyUsedOnly) {
	        tzid = IBM.ICU.Impl.ZoneMeta.GetCanonicalID(tzid);
	        String result = null;
	        String mzid = IBM.ICU.Impl.ZoneMeta.GetMetazoneID(tzid, date);
	        if (mzid != null) {
	            ZoneStringFormat.ZoneStrings  zstrings = (ZoneStringFormat.ZoneStrings ) ILOG.J2CsMapping.Collections.Collections.Get(tzidToStrings,tzid);
	            if (zstrings != null) {
	                result = zstrings.GetGenericPartialLocationString(mzid,
	                        isShort, commonlyUsedOnly);
	            }
	        }
	        return result;
	    }
	
	    /*
	     * Gets zoneStrings compatible with DateFormatSymbols for the specified
	     * date. In CLDR 1.5, zone names can be changed time to time. This method
	     * generates flat 2-dimensional String array including zone ids and its
	     * localized strings at the moment. Thus, even you construct a new
	     * ZoneStringFormat by the zone strings array returned by this method, you
	     * will loose historic name changes. Also, commonly used flag for short
	     * types is not reflected in the result.
	     */
	    private String[][] GetZoneStrings(long date) {
	        ILOG.J2CsMapping.Collections.ISet tzids = new ILOG.J2CsMapping.Collections.ListSet(tzidToStrings.Keys);
	        String[][] zoneStrings = (String[][])ILOG.J2CsMapping.Collections.Arrays.CreateJaggedArray(typeof(String), tzids.Count, 8);
	        int idx = 0;
	        IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(tzids.GetEnumerator());
	        while (it.HasNext()) {
	            String tzid = (String) it.Next();
	            zoneStrings[idx][0] = tzid;
	            zoneStrings[idx][1] = GetLongStandard(tzid, date);
	            zoneStrings[idx][2] = GetShortStandard(tzid, date, false);
	            zoneStrings[idx][3] = GetLongDaylight(tzid, date);
	            zoneStrings[idx][4] = GetShortDaylight(tzid, date, false);
	            zoneStrings[idx][5] = GetGenericLocation(tzid);
	            zoneStrings[idx][6] = GetLongGenericNonLocation(tzid, date);
	            zoneStrings[idx][7] = GetShortGenericNonLocation(tzid, date, false);
	            idx++;
	        }
	        return zoneStrings;
	    }
	
	    /*
	     * ZoneStrings is an internal implementation class for holding localized
	     * name information for a zone/metazone
	     */
	    private class ZoneStrings {
	        private String[] strings;
	
	        private String[][] genericPartialLocationStrings;
	
	        private bool commonlyUsed;
	
	        public ZoneStrings(String[] zstrarray, bool commonlyUsed_0,
	                String[][] genericPartialLocationStrings_1) {
	            if (zstrarray != null) {
	                int lastIdx = -1;
	                for (int i = 0; i < zstrarray.Length; i++) {
	                    if (zstrarray[i] != null) {
	                        lastIdx = i;
	                    }
	                }
	                if (lastIdx != -1) {
	                    strings = new String[lastIdx + 1];
	                    System.Array.Copy((Array)(zstrarray),0,(Array)(strings),0,lastIdx + 1);
	                }
	            }
	            this.commonlyUsed = commonlyUsed_0;
	            this.genericPartialLocationStrings = genericPartialLocationStrings_1;
	        }
	
	        public String GetString(int typeIdx) {
	            if (strings != null && typeIdx >= 0 && typeIdx < strings.Length) {
	                return strings[typeIdx];
	            }
	            return null;
	        }
	
	        public bool IsShortFormatCommonlyUsed() {
	            return commonlyUsed;
	        }
	
	        public String GetGenericPartialLocationString(String mzid,
	                bool isShort, bool commonlyUsedOnly) {
	            String result = null;
	            if (genericPartialLocationStrings != null) {
	                for (int i = 0; i < genericPartialLocationStrings.Length; i++) {
	                    if (genericPartialLocationStrings[i][0].Equals(mzid)) {
	                        if (isShort) {
	                            if (!commonlyUsedOnly
	                                    || genericPartialLocationStrings[i][3] != null) {
	                                result = genericPartialLocationStrings[i][2];
	                            }
	                        } else {
	                            result = genericPartialLocationStrings[i][1];
	                        }
	                        break;
	                    }
	                }
	            }
	            return result;
	        }
	    }
	
	    /*
	     * Returns a localized zone string from bundle.
	     */
	    private static String GetZoneStringFromBundle(ICUResourceBundle bundle,
	            String key, String type_0) {
	        String zstring = null;
	        if (bundle != null) {
	            try {
	                zstring = bundle.GetStringWithFallback(key + "/" + type_0);
	            } catch (MissingManifestResourceException ex) {
	                // throw away the exception
	            }
	        }
	        return zstring;
	    }
	
	    /*
	     * Returns if the short strings of the zone/metazone is commonly used.
	     */
	    private static bool IsCommonlyUsed(ICUResourceBundle bundle, String key) {
	        bool commonlyUsed_0 = false;
	        if (bundle != null) {
	            try {
	                UResourceBundle cuRes = bundle.GetWithFallback(key + "/"
	                        + RESKEY_COMMONLY_USED);
	                int cuValue = cuRes.GetInt();
	                commonlyUsed_0 = (cuValue != 0);
	            } catch (MissingManifestResourceException ex) {
	                // throw away the exception
	            }
	        }
	        return commonlyUsed_0;
	    }
	
	    /*
	     * Returns a localized country string for the country code. If no actual
	     * localized string is found, countryCode itself is returned.
	     */
	    private static String GetLocalizedCountry(String countryCode, ULocale locale_0) {
	        String countryStr = null;
	        if (countryCode != null) {
	            ICUResourceBundle rb = (ICUResourceBundle) IBM.ICU.Util.UResourceBundle
	                    .GetBundleInstance(IBM.ICU.Impl.ICUResourceBundle.ICU_BASE_NAME, locale_0);
	            //
	            // TODO: There is a design bug in UResourceBundle and
	            // getLoadingStatus() does not work well.
	            //
	            // if (rb.getLoadingStatus() != ICUResourceBundle.FROM_ROOT &&
	            // rb.getLoadingStatus() != ICUResourceBundle.FROM_DEFAULT) {
	            // country = ULocale.getDisplayCountry("xx_" + country_code,
	            // locale);
	            // }
	            // START WORKAROUND
	            ULocale rbloc = rb.GetULocale();
	            if (!rbloc.Equals(IBM.ICU.Util.ULocale.ROOT)
	                    && rbloc.GetLanguage().Equals(locale_0.GetLanguage())) {
	                countryStr = IBM.ICU.Util.ULocale.GetDisplayCountry("xx_" + countryCode,
	                        locale_0);
	            }
	            // END WORKAROUND
	            if (countryStr == null || countryStr.Length == 0) {
	                countryStr = countryCode;
	            }
	        }
	        return countryStr;
	    }
	
	    /*
	     * Gets an instance of MessageFormat used for formatting zone fallback
	     * string
	     */
	    private static IBM.ICU.Text.MessageFormat GetFallbackFormat(ULocale locale_0) {
	        String fallbackPattern = IBM.ICU.Impl.ZoneMeta.GetTZLocalizationInfo(locale_0,
	                IBM.ICU.Impl.ZoneMeta.FALLBACK_FORMAT);
	        if (fallbackPattern == null) {
	            fallbackPattern = "{1} ({0})";
	        }
            return new IBM.ICU.Text.MessageFormat(fallbackPattern, locale_0);
	    }
	
	    /*
	     * Gets an instance of MessageFormat used for formatting zone region string
	     */
        private static IBM.ICU.Text.MessageFormat GetRegionFormat(ULocale locale_0)
        {
	        String regionPattern = IBM.ICU.Impl.ZoneMeta.GetTZLocalizationInfo(locale_0,
	                IBM.ICU.Impl.ZoneMeta.REGION_FORMAT);
	        if (regionPattern == null) {
	            regionPattern = "{0}";
	        }
            return new IBM.ICU.Text.MessageFormat(regionPattern, locale_0);
	    }
	
	    /*
	     * Index value mapping between DateFormatSymbols's zoneStrings and the
	     * string types defined in this class.
	     */
	    private static readonly int[] INDEXMAP = { -1, // 0 - zone id
	            ZSIDX_LONG_STANDARD, // 1 - long standard
	            ZSIDX_SHORT_STANDARD, // 2 - short standard
	            ZSIDX_LONG_DAYLIGHT, // 3 - long daylight
	            ZSIDX_SHORT_DAYLIGHT, // 4 - short daylight
	            ZSIDX_LOCATION, // 5 - generic location
	            ZSIDX_LONG_GENERIC, // 6 - long generic non-location
	            ZSIDX_SHORT_GENERIC // 7 - short generic non-location
	    };
	
	    /*
	     * Convert from zone string array index for zoneStrings used by
	     * DateFormatSymbols#get/setZoneStrings to the type constants defined by
	     * this class, such as ZSIDX_LONG_STANDARD.
	     */
	    private static int GetNameTypeIndex(int i) {
	        int idx = -1;
	        if (i >= 1 && i < INDEXMAP.Length) {
	            idx = INDEXMAP[i];
	        }
	        return idx;
	    }
	
	    /*
	     * Mapping from name type index to name type
	     */
	    private static readonly int[] NAMETYPEMAP = { LOCATION, // ZSIDX_LOCATION
	            STANDARD_LONG, // ZSIDX_LONG_STANDARD
	            STANDARD_SHORT, // ZSIDX_SHORT_STANDARD
	            DAYLIGHT_LONG, // ZSIDX_LONG_DAYLIGHT
	            DAYLIGHT_SHORT, // ZSIDX_SHORT_DAYLIGHT
	            GENERIC_LONG, // ZSIDX_LONG_GENERIC
	            GENERIC_SHORT, // ZSIDX_SHORT_GENERIC
	    };
	
	    private static int GetNameType(int typeIdx) {
	        int type_0 = -1;
	        if (typeIdx >= 0 && typeIdx < NAMETYPEMAP.Length) {
	            type_0 = NAMETYPEMAP[typeIdx];
	        }
	        return type_0;
	    }
	
	    /*
	     * Returns region used for ZoneMeta#getZoneIdByMetazone.
	     */
	    private String GetRegion() {
	        if (region == null) {
	            if (locale != null) {
	                region = locale.GetCountry();
	                if (region.Length == 0) {
	                    ULocale tmp = IBM.ICU.Util.ULocale.AddLikelySubtag(locale);
	                    region = tmp.GetCountry();
	                }
	            } else {
	                region = "";
	            }
	        }
	        return region;
	    }
	
	    /*
	     * Find a prefix matching time zone for the given zone string types.
	     * 
	     * @param text The text contains a time zone string
	     * 
	     * @param start The start index within the text
	     * 
	     * @param types The bit mask representing a set of requested types
	     * 
	     * @return If any zone string matched for the requested types, returns a
	     * ZoneStringInfo for the longest match. If no matches are found for the
	     * requested types, returns a ZoneStringInfo for the longest match for any
	     * other types. If nothing matches at all, returns null.
	     */
	    private ZoneStringFormat.ZoneStringInfo  Find(String text, int start, int types) {
	        ZoneStringFormat.ZoneStringInfo  result = null;
	        ZoneStringFormat.ZoneStringSearchResultHandler  handler = new ZoneStringFormat.ZoneStringSearchResultHandler ();
	        zoneStringsTrie.Find(text, start, handler);
	        IList list = handler.GetMatchedZoneStrings();
	        ZoneStringFormat.ZoneStringInfo  fallback = null;
	        if (list != null && list.Count > 0) {
	            IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(list.GetEnumerator());
	            while (it.HasNext()) {
	                ZoneStringFormat.ZoneStringInfo  tmp = (ZoneStringFormat.ZoneStringInfo ) it.Next();
	                if ((types & tmp.GetType()) != 0) {
	                    if (result == null
	                            || result.GetString().Length < tmp.GetString().Length) {
	                        result = tmp;
	                    } else if (result.GetString().Length == tmp.GetString().Length) {
	                        // Tie breaker - there are some examples that a
	                        // long standard name is identical with a location
	                        // name - for example, "Uruguay Time". In this case,
	                        // we interpret it as generic, not specific.
	                        if (tmp.IsGeneric() && !result.IsGeneric()) {
	                            result = tmp;
	                        }
	                    }
	                } else if (result == null) {
	                    if (fallback == null
	                            || fallback.GetString().Length < tmp.GetString().Length) {
	                        fallback = tmp;
	                    } else if (fallback.GetString().Length == tmp.GetString().Length) {
	                        if (tmp.IsGeneric() && !fallback.IsGeneric()) {
	                            fallback = tmp;
	                        }
	                    }
	                }
	            }
	        }
	        if (result == null && fallback != null) {
	            result = fallback;
	        }
	        return result;
	    }
	
	    private class ZoneStringSearchResultHandler : 
	            TextTrieMap.ResultHandler {
	
	        private ArrayList resultList;
	
	        public virtual bool HandlePrefixMatch(int matchLength, IIterator values) {
	            if (resultList == null) {
	                resultList = new ArrayList();
	            }
	            while (values.HasNext()) {
	                ZoneStringFormat.ZoneStringInfo  zsitem = (ZoneStringFormat.ZoneStringInfo ) values.Next();
	                if (zsitem == null) {
	                    break;
	                }
	                int i = 0;
	                for (; i < resultList.Count; i++) {
	                    ZoneStringFormat.ZoneStringInfo  tmp = (ZoneStringFormat.ZoneStringInfo ) resultList[i];
	                    if (zsitem.GetType() == tmp.GetType()) {
	                        if (matchLength > tmp.GetString().Length) {
	                            resultList[i]=zsitem;
	                        }
	                        break;
	                    }
	                }
	                if (i == resultList.Count) {
	                    // not found in the current list
	                    ILOG.J2CsMapping.Collections.Generics.Collections.Add(resultList,zsitem);
	                }
	            }
	            return true;
	        }
	
	        internal IList GetMatchedZoneStrings() {
	            if (resultList == null || resultList.Count == 0) {
	                return null;
	            }
	            return resultList;
	        }
	    }
	}
}
