/*
 *******************************************************************************
 *
 *   Copyright (C) 2004-2007, International Business Machines
 *   Corporation and others.  All Rights Reserved.
 *
 *******************************************************************************
 *   file name:  ReplaceableContextIterator.java
 *   encoding:   US-ASCII
 *   tab size:   8 (not used)
 *   indentation:4
 *
 *   created on: 2005feb04
 *   created by: Markus W. Scherer
 *
 *   Implementation of UCaseProps.ContextIterator, iterates over a Replaceable.
 *   Java port of casetrn.cpp/utrans_rep_caseContextIterator().
 */

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:30 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Text {
	
	using IBM.ICU.Impl;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	
	/// <exclude/>
	/// <summary>
	/// Implementation of UCaseProps.ContextIterator, iterates over a Replaceable.
	/// See casetrn.cpp/utrans_rep_caseContextIterator(). See also
	/// UCharacter.StringContextIterator.
	/// </summary>
	///
	internal class ReplaceableContextIterator : UCaseProps.ContextIterator {
	    /// <summary>
	    /// Constructor.
	    /// </summary>
	    ///
	    /// <param name="rep">Replaceable to iterate over.</param>
	    internal ReplaceableContextIterator() {
	        this.rep = null;
	        limit = cpStart = cpLimit = index = contextStart = contextLimit = 0;
	        dir = 0;
	        reachedLimit = false;
	    }
	
	    /// <summary>
	    /// Set the text for iteration.
	    /// </summary>
	    ///
	    /// <param name="rep">Iteration text.</param>
	    public void SetText(Replaceable rep) {
	        this.rep = rep;
	        limit = contextLimit = rep.Length();
	        cpStart = cpLimit = index = contextStart = 0;
	        dir = 0;
	        reachedLimit = false;
	    }
	
	    /// <summary>
	    /// Set the index where nextCaseMapCP() is to start iterating.
	    /// </summary>
	    ///
	    /// <param name="index">Iteration start index for nextCaseMapCP().</param>
	    public void SetIndex(int index) {
	        cpStart = cpLimit = index;
	        this.index = 0;
	        dir = 0;
	        reachedLimit = false;
	    }
	
	    /// <summary>
	    /// Get the index of where the code point currently being case-mapped starts.
	    /// </summary>
	    ///
	    /// <returns>The start index of the current code point.</returns>
	    public int GetCaseMapCPStart() {
	        return cpStart;
	    }
	
	    /// <summary>
	    /// Set the iteration limit for nextCaseMapCP() to an index within the
	    /// string. If the limit parameter is negative or past the string, then the
	    /// string length is restored as the iteration limit.
	    /// </summary>
	    ///
	    /// <param name="lim">The iteration limit.</param>
	    public void SetLimit(int lim) {
	        if (0 <= lim && lim <= rep.Length()) {
	            limit = lim;
	        } else {
	            limit = rep.Length();
	        }
	        reachedLimit = false;
	    }
	
	    /// <summary>
	    /// Set the start and limit indexes for context iteration with next().
	    /// </summary>
	    ///
	    /// <param name="contextStart">Start of context for next().</param>
	    /// <param name="contextLimit">Limit of context for next().</param>
	    public void SetContextLimits(int contextStart, int contextLimit) {
	        if (contextStart < 0) {
	            this.contextStart = 0;
	        } else if (contextStart <= rep.Length()) {
	            this.contextStart = contextStart;
	        } else {
	            this.contextStart = rep.Length();
	        }
	        if (contextLimit < this.contextStart) {
	            this.contextLimit = this.contextStart;
	        } else if (contextLimit <= rep.Length()) {
	            this.contextLimit = contextLimit;
	        } else {
	            this.contextLimit = rep.Length();
	        }
	        reachedLimit = false;
	    }
	
	    /// <summary>
	    /// Iterate forward through the string to fetch the next code point to be
	    /// case-mapped, and set the context indexes for it.
	    /// </summary>
	    ///
	    /// <returns>The next code point to be case-mapped, or <0 when the iteration
	    /// is done.</returns>
	    public int NextCaseMapCP() {
	        int c;
	        if (cpLimit < limit) {
	            cpStart = cpLimit;
	            c = rep.Char32At(cpLimit);
	            cpLimit += IBM.ICU.Text.UTF16.GetCharCount(c);
	            return c;
	        } else {
	            return -1;
	        }
	    }
	
	    /// <summary>
	    /// Replace the current code point by its case mapping, and update the
	    /// indexes.
	    /// </summary>
	    ///
	    /// <param name="text">Replacement text.</param>
	    /// <returns>The delta for the change of the text length.</returns>
	    public int Replace(String text) {
	        int delta = text.Length - (cpLimit - cpStart);
	        rep.Replace(cpStart, cpLimit, text);
	        cpLimit += delta;
	        limit += delta;
	        contextLimit += delta;
	        return delta;
	    }
	
	    /// <summary>
	    /// Did forward context iteration with next() reach the iteration limit?
	    /// </summary>
	    ///
	    /// <returns>Boolean value.</returns>
	    public bool DidReachLimit() {
	        return reachedLimit;
	    }
	
	    // implement UCaseProps.ContextIterator
	    public virtual void Reset(int dir) {
	        if (dir > 0) {
	            /* reset for forward iteration */
	            this.dir = 1;
	            index = cpLimit;
	        } else if (dir < 0) {
	            /* reset for backward iteration */
	            this.dir = -1;
	            index = cpStart;
	        } else {
	            // not a valid direction
	            this.dir = 0;
	            index = 0;
	        }
	        reachedLimit = false;
	    }
	
	    public virtual int Next() {
	        int c;
	
	        if (dir > 0) {
	            if (index < contextLimit) {
	                c = rep.Char32At(index);
	                index += IBM.ICU.Text.UTF16.GetCharCount(c);
	                return c;
	            } else {
	                // forward context iteration reached the limit
	                reachedLimit = true;
	            }
	        } else if (dir < 0 && index > contextStart) {
	            c = rep.Char32At(index - 1);
	            index -= IBM.ICU.Text.UTF16.GetCharCount(c);
	            return c;
	        }
	        return -1;
	    }
	
	    // variables
	    protected internal Replaceable rep;
	
	    protected internal int index, limit, cpStart, cpLimit, contextStart, contextLimit;
	
	    protected internal int dir; // 0=initial state >0=forward <0=backward
	
	    protected internal bool reachedLimit;
	}
}
