/*
 *******************************************************************************
 * Copyright (C) 1996-2007, International Business Machines Corporation and    *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 */
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:30 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Text {
	
	using IBM.ICU.Impl;
	using ILOG.J2CsMapping.Collections;
	using ILOG.J2CsMapping.Collections.Generics;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Text;
	
	/// <summary>
	/// This class allows one to iterate through all the strings that are canonically
	/// equivalent to a given string. For example, here are some sample results:
	/// Results for: {A WITH RING ABOVE}{d}{DOT ABOVE}{CEDILLA}
	/// <pre>
	/// 1: {A}{RING ABOVE}{d}{DOT ABOVE}{CEDILLA}
	/// 2: {A}{RING ABOVE}{d}{CEDILLA}{DOT ABOVE}
	/// 3: {A}{RING ABOVE}{d WITH DOT ABOVE}{CEDILLA}
	/// 4: {A}{RING ABOVE}{d WITH CEDILLA}{DOT ABOVE}
	/// 5: {A WITH RING ABOVE}{d}{DOT ABOVE}{CEDILLA}
	/// 6: {A WITH RING ABOVE}{d}{CEDILLA}{DOT ABOVE}
	/// 7: {A WITH RING ABOVE}{d WITH DOT ABOVE}{CEDILLA}
	/// 8: {A WITH RING ABOVE}{d WITH CEDILLA}{DOT ABOVE}
	/// 9: {ANGSTROM SIGN}{d}{DOT ABOVE}{CEDILLA}
	/// 10: {ANGSTROM SIGN}{d}{CEDILLA}{DOT ABOVE}
	/// 11: {ANGSTROM SIGN}{d WITH DOT ABOVE}{CEDILLA}
	/// 12: {ANGSTROM SIGN}{d WITH CEDILLA}{DOT ABOVE}
	/// </pre>
	/// <br>
	/// Note: the code is intended for use with small strings, and is not suitable
	/// for larger ones, since it has not been optimized for that situation.
	/// </summary>
	///
	/// @stable ICU 2.4
	
	public sealed class CanonicalIterator {
	    /// <summary>
	    /// Construct a CanonicalIterator object
	    /// </summary>
	    ///
	    /// <param name="source">string to get results for</param>
	    /// @stable ICU 2.4
	    public CanonicalIterator(String source) {
	        this.buffer = new StringBuilder();
	        SetSource(source);
	    }
	
	    /// <summary>
	    /// Gets the NFD form of the current source we are iterating over.
	    /// </summary>
	    ///
	    /// <returns>gets the source: NOTE: it is the NFD form of the source
	    /// originally passed in</returns>
	    /// @stable ICU 2.4
	    public String GetSource() {
	        return source;
	    }
	
	    /// <summary>
	    /// Resets the iterator so that one can start again from the beginning.
	    /// </summary>
	    ///
	    /// @stable ICU 2.4
	    public void Reset() {
	        done = false;
	        for (int i = 0; i < current.Length; ++i) {
	            current[i] = 0;
	        }
	    }
	
	    /// <summary>
	    /// Get the next canonically equivalent string. <br>
	    /// <b>Warning: The strings are not guaranteed to be in any particular
	    /// order.</b>
	    /// </summary>
	    ///
	    /// <returns>the next string that is canonically equivalent. The value null is
	    /// returned when the iteration is done.</returns>
	    /// @stable ICU 2.4
	    public String Next() {
	        if (done)
	            return null;
	
	        // construct return value
	
	        buffer.Length=0; // delete old contents
	        for (int i = 0; i < pieces.Length; ++i) {
	            buffer.Append(pieces[i][current[i]]);
	        }
	        String result = buffer.ToString();
	
	        // find next value for next time
	
	        for (int i_0 = current.Length - 1;; --i_0) {
	            if (i_0 < 0) {
	                done = true;
	                break;
	            }
	            current[i_0]++;
	            if (current[i_0] < pieces[i_0].Length)
	                break; // got sequence
	            current[i_0] = 0;
	        }
	        return result;
	    }
	
	    /// <summary>
	    /// Set a new source for this iterator. Allows object reuse.
	    /// </summary>
	    ///
	    /// <param name="newSource">the source string to iterate against. This allows the sameiterator to be used while changing the source string, savingobject creation.</param>
	    /// @stable ICU 2.4
	    public void SetSource(String newSource) {
	        source = IBM.ICU.Text.Normalizer.Normalize(newSource, IBM.ICU.Text.Normalizer.NFD);
	        done = false;
	
	        // catch degenerate case
	        if (newSource.Length == 0) {
	            pieces = new String[1][];
	            current = new int[1];
	            pieces[0] = new String[] { "" };
	            return;
	        }
	
	        // find the segments
	        IList segmentList = new ArrayList();
	        int cp;
	        int start = 0;
	
	        // i should be the end of the first code point
	        // break up the string into segements
	
	        int i = IBM.ICU.Text.UTF16.FindOffsetFromCodePoint(source, 1);
	
	        for (; i < source.Length; i += IBM.ICU.Text.UTF16.GetCharCount(cp)) {
	            cp = IBM.ICU.Text.UTF16.CharAt(source, i);
	            if (IBM.ICU.Impl.NormalizerImpl.IsCanonSafeStart(cp)) {
	                ILOG.J2CsMapping.Collections.Generics.Collections.Add(segmentList,source.Substring(start,(i)-(start))); // add up to i
	                start = i;
	            }
	        }
	        ILOG.J2CsMapping.Collections.Generics.Collections.Add(segmentList,source.Substring(start,(i)-(start))); // add last one
	
	        // allocate the arrays, and find the strings that are CE to each segment
	        pieces = new String[segmentList.Count][];
	        current = new int[segmentList.Count];
	        for (i = 0; i < pieces.Length; ++i) {
	            if (PROGRESS)
	                System.Console.Out.WriteLine("SEGMENT");
	            pieces[i] = GetEquivalents((String) segmentList[i]);
	        }
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Simple implementation of permutation. <br>
	    /// <b>Warning: The strings are not guaranteed to be in any particular
	    /// order.</b>
	    /// </summary>
	    ///
	    /// <param name="source">the string to find permutations for</param>
	    /// <param name="skipZeros">set to true to skip characters with canonical combining classzero</param>
	    /// <param name="output">the set to add the results to</param>
	    public static void Permute(String source, bool skipZeros, ILOG.J2CsMapping.Collections.ISet output) {
	        // TODO: optimize
	        // if (PROGRESS) System.out.println("Permute: " + source);
	
	        // optimization:
	        // if zero or one character, just return a set with it
	        // we check for length < 2 to keep from counting code points all the
	        // time
	        if (source.Length <= 2 && IBM.ICU.Text.UTF16.CountCodePoint(source) <= 1) {
	            ILOG.J2CsMapping.Collections.Generics.Collections.Add(output,source);
	            return;
	        }
	
	        // otherwise iterate through the string, and recursively permute all the
	        // other characters
	        ILOG.J2CsMapping.Collections.ISet subpermute = new HashedSet();
	        int cp;
	        for (int i = 0; i < source.Length; i += IBM.ICU.Text.UTF16.GetCharCount(cp)) {
	            cp = IBM.ICU.Text.UTF16.CharAt(source, i);
	
	            // optimization:
	            // if the character is canonical combining class zero,
	            // don't permute it
	            if (skipZeros && i != 0 && IBM.ICU.Lang.UCharacter.GetCombiningClass(cp) == 0) {
	                // System.out.println("Skipping " +
	                // Utility.hex(UTF16.valueOf(source, i)));
	                continue;
	            }
	
	            // see what the permutations of the characters before and after this
	            // one are
	            ILOG.J2CsMapping.Collections.Collections.Clear(subpermute);
	            Permute(source.Substring(0,(i)-(0))
	                    + source.Substring(i + IBM.ICU.Text.UTF16.GetCharCount(cp)), skipZeros,
	                    subpermute);
	
	            // prefix this character to all of them
	            String chStr = IBM.ICU.Text.UTF16.ValueOf(source, i);
	            IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(subpermute.GetEnumerator());
	            while (it.HasNext()) {
	                String piece = chStr + (String) it.Next();
	                // if (PROGRESS) System.out.println("  Piece: " + piece);
	                ILOG.J2CsMapping.Collections.Generics.Collections.Add(output,piece);
	            }
	        }
	    }
	
	    // FOR TESTING
	
	    /*
	     * @return the set of "safe starts", characters that are class zero AND are
	     * never non-initial in a decomposition.
	     * 
	     * @internal
	     * 
	     * public static UnicodeSet getSafeStart() { return (UnicodeSet)
	     * SAFE_START.clone(); }
	     */
	    /*
	     * @return the set of characters whose decompositions start with the given
	     * character
	     * 
	     * @internal
	     * 
	     * public static UnicodeSet getStarts(int cp) { UnicodeSet result =
	     * AT_START.get(cp); if (result == null) result = EMPTY; return (UnicodeSet)
	     * result.clone(); }
	     */
	
	    // ===================== PRIVATES ==============================
	
	    // debug
	    private static bool PROGRESS = false; // debug progress
	
	    // private static Transliterator NAME = PROGRESS ?
	    // Transliterator.getInstance("name") : null;
	    private static bool SKIP_ZEROS = true;
	
	    // fields
	    private String source;
	
	    private bool done;
	
	    private String[][] pieces;
	
	    private int[] current;
	
	    // Note: C will need two more fields, since arrays there don't have lengths
	    // int pieces_length;
	    // int[] pieces_lengths;
	
	    // transient fields
	    private StringBuilder buffer;
	
	    // we have a segment, in NFD. Find all the strings that are canonically
	    // equivalent to it.
	    private String[] GetEquivalents(String segment) {
	        ILOG.J2CsMapping.Collections.ISet result = new HashedSet();
	        ILOG.J2CsMapping.Collections.ISet basic = GetEquivalents2(segment);
	        ILOG.J2CsMapping.Collections.ISet permutations = new HashedSet();
	
	        // now get all the permutations
	        // add only the ones that are canonically equivalent
	        // TODO: optimize by not permuting any class zero.
	        IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(basic.GetEnumerator());
	        while (it.HasNext()) {
	            String item = (String) it.Next();
	            ILOG.J2CsMapping.Collections.Collections.Clear(permutations);
	            Permute(item, SKIP_ZEROS, permutations);
	            IIterator it2 = new ILOG.J2CsMapping.Collections.IteratorAdapter(permutations.GetEnumerator());
	            while (it2.HasNext()) {
	                String possible = (String) it2.Next();
	
	                /*
	                 * String attempt = Normalizer.normalize(possible,
	                 * Normalizer.DECOMP, 0); if (attempt.equals(segment)) {
	                 */
	                if (IBM.ICU.Text.Normalizer.Compare(possible, segment, 0) == 0) {
	
	                    if (PROGRESS)
	                        System.Console.Out.WriteLine("Adding Permutation: "
	                                + IBM.ICU.Impl.Utility.Hex(possible));
	                    ILOG.J2CsMapping.Collections.Generics.Collections.Add(result,possible);
	
	                } else {
	                    if (PROGRESS)
	                        System.Console.Out.WriteLine("-Skipping Permutation: "
	                                + IBM.ICU.Impl.Utility.Hex(possible));
	                }
	            }
	        }
	
	        // convert into a String[] to clean up storage
	        String[] finalResult = new String[result.Count];
	        ILOG.J2CsMapping.Collections.Generics.Collections.ToArray(result,finalResult);
	        return finalResult;
	    }
	
	    private ILOG.J2CsMapping.Collections.ISet GetEquivalents2(String segment) {
	
	        ILOG.J2CsMapping.Collections.ISet result = new HashedSet();
	
	        if (PROGRESS)
	            System.Console.Out.WriteLine("Adding: " + IBM.ICU.Impl.Utility.Hex(segment));
	
	        ILOG.J2CsMapping.Collections.Generics.Collections.Add(result,segment);
	        StringBuilder workingBuffer = new StringBuilder();
	
	        // cycle through all the characters
	        int cp = 0;
	        int[] range = new int[2];
	        for (int i = 0; i < segment.Length; i += IBM.ICU.Text.UTF16.GetCharCount(cp)) {
	
	            // see if any character is at the start of some decomposition
	            cp = IBM.ICU.Text.UTF16.CharAt(segment, i);
	            USerializedSet starts = new USerializedSet();
	
	            if (!IBM.ICU.Impl.NormalizerImpl.GetCanonStartSet(cp, starts)) {
	                continue;
	            }
	            int j = 0;
	            // if so, see which decompositions match
	            int rangeCount = starts.CountRanges();
	            for (j = 0; j < rangeCount; ++j) {
	                starts.GetRange(j, range);
	                int end = range[1];
	                for (int cp2 = range[0]; cp2 <= end; ++cp2) {
	                    ILOG.J2CsMapping.Collections.ISet remainder = Extract(cp2, segment, i, workingBuffer);
	                    if (remainder == null)
	                        continue;
	
	                    // there were some matches, so add all the possibilities to
	                    // the set.
	                    String prefix = segment.Substring(0,(i)-(0));
	                    prefix += IBM.ICU.Text.UTF16.ValueOf(cp2);
	                    // int el = -1;
	                    IIterator iter = new ILOG.J2CsMapping.Collections.IteratorAdapter(remainder.GetEnumerator());
	                    while (iter.HasNext()) {
	                        String item = (String) iter.Next();
	                        String toAdd = prefix;
	                        toAdd += item;
	                        ILOG.J2CsMapping.Collections.Generics.Collections.Add(result,toAdd);
	                        // if (PROGRESS) printf("Adding: %s\n",
	                        // UToS(Tr(*toAdd)));
	                    }
	                }
	            }
	        }
	        return result;
	        /*
	         * Set result = new HashSet(); if (PROGRESS)
	         * System.out.println("Adding: " + NAME.transliterate(segment));
	         * result.add(segment); StringBuffer workingBuffer = new StringBuffer();
	         * 
	         * // cycle through all the characters int cp;
	         * 
	         * for (int i = 0; i < segment.length(); i += UTF16.getCharCount(cp)) {
	         * // see if any character is at the start of some decomposition cp =
	         * UTF16.charAt(segment, i); NormalizerImpl.getCanonStartSet(c,fillSet)
	         * UnicodeSet starts = AT_START.get(cp); if (starts == null) continue;
	         * UnicodeSetIterator usi = new UnicodeSetIterator(starts); // if so,
	         * see which decompositions match while (usi.next()) { int cp2 =
	         * usi.codepoint; // we know that there are no strings in it // so we
	         * don't have to check CharacterIterator.IS_STRING Set remainder =
	         * extract(cp2, segment, i, workingBuffer); if (remainder == null)
	         * continue;
	         * 
	         * // there were some matches, so add all the possibilities to the set.
	         * String prefix = segment.substring(0, i) + UTF16.valueOf(cp2);
	         * Iterator it = remainder.iterator(); while (it.hasNext()) { String
	         * item = (String) it.next(); if (PROGRESS)
	         * System.out.println("Adding: " + NAME.transliterate(prefix + item));
	         * result.add(prefix + item); } } } return result;
	         */
	    }
	
	    /// <summary>
	    /// See if the decomposition of cp2 is at segment starting at segmentPos
	    /// (with canonical rearrangment!) If so, take the remainder, and return the
	    /// equivalents
	    /// </summary>
	    ///
	    private ILOG.J2CsMapping.Collections.ISet Extract(int comp, String segment, int segmentPos,
	            StringBuilder buffer_0) {
	        if (PROGRESS)
	            System.Console.Out.WriteLine(" extract: " + IBM.ICU.Impl.Utility.Hex(IBM.ICU.Text.UTF16.ValueOf(comp))
	                    + ", " + IBM.ICU.Impl.Utility.Hex(segment.Substring(segmentPos)));
	
	        // String decomp = Normalizer.normalize(UTF16.valueOf(comp),
	        // Normalizer.DECOMP, 0);
	        String decomp = IBM.ICU.Text.Normalizer.Normalize(comp, IBM.ICU.Text.Normalizer.NFD);
	
	        // See if it matches the start of segment (at segmentPos)
	        bool ok = false;
	        int cp;
	        int decompPos = 0;
	        int decompCp = IBM.ICU.Text.UTF16.CharAt(decomp, 0);
	        decompPos += IBM.ICU.Text.UTF16.GetCharCount(decompCp); // adjust position to skip
	                                                   // first char
	        // int decompClass = getClass(decompCp);
	        buffer_0.Length=0; // initialize working buffer, shared among callees
	
	        for (int i = segmentPos; i < segment.Length; i += IBM.ICU.Text.UTF16
	                .GetCharCount(cp)) {
	            cp = IBM.ICU.Text.UTF16.CharAt(segment, i);
	            if (cp == decompCp) { // if equal, eat another cp from decomp
	                if (PROGRESS)
	                    System.Console.Out.WriteLine("  matches: "
	                            + IBM.ICU.Impl.Utility.Hex(IBM.ICU.Text.UTF16.ValueOf(cp)));
	                if (decompPos == decomp.Length) { // done, have all decomp
	                                                    // characters!
	                    buffer_0.Append(segment.Substring(i + IBM.ICU.Text.UTF16.GetCharCount(cp))); // add
	                                                                                  // remaining
	                                                                                  // segment
	                                                                                  // chars
	                    ok = true;
	                    break;
	                }
	                decompCp = IBM.ICU.Text.UTF16.CharAt(decomp, decompPos);
	                decompPos += IBM.ICU.Text.UTF16.GetCharCount(decompCp);
	                // decompClass = getClass(decompCp);
	            } else {
	                if (PROGRESS)
	                    System.Console.Out.WriteLine("  buffer: "
	                            + IBM.ICU.Impl.Utility.Hex(IBM.ICU.Text.UTF16.ValueOf(cp)));
	                // brute force approach
	                IBM.ICU.Text.UTF16.Append(buffer_0, cp);
	                /*
	                 * TODO: optimize // since we know that the classes are
	                 * monotonically increasing, after zero // e.g. 0 5 7 9 0 3 //
	                 * we can do an optimization // there are only a few cases that
	                 * work: zero, less, same, greater // if both classes are the
	                 * same, we fail // if the decomp class < the segment class, we
	                 * fail
	                 * 
	                 * segClass = getClass(cp); if (decompClass <= segClass) return
	                 * null;
	                 */
	            }
	        }
	        if (!ok)
	            return null; // we failed, characters left over
	        if (PROGRESS)
	            System.Console.Out.WriteLine("Matches");
	        if (buffer_0.Length == 0)
	            return SET_WITH_NULL_STRING; // succeed, but no remainder
	        String remainder = buffer_0.ToString();
	
	        // brute force approach
	        // to check to make sure result is canonically equivalent
	        /*
	         * String trial = Normalizer.normalize(UTF16.valueOf(comp) + remainder,
	         * Normalizer.DECOMP, 0); if (!segment.regionMatches(segmentPos, trial,
	         * 0, segment.length() - segmentPos)) return null;
	         */
	
	        if (0 != IBM.ICU.Text.Normalizer.Compare(IBM.ICU.Text.UTF16.ValueOf(comp) + remainder,
	                segment.Substring(segmentPos), 0))
	            return null;
	
	        // get the remaining combinations
	        return GetEquivalents2(remainder);
	    }
	
	    /*
	     * // TODO: fix once we have a codepoint interface to get the canonical
	     * combining class // TODO: Need public access to canonical combining class
	     * in UCharacter! private static int getClass(int cp) { return
	     * Normalizer.getClass((char)cp); }
	     */
	
	    // ================= BUILDER =========================
	    // TODO: Flatten this data so it doesn't have to be reconstructed each time!
	
	    // private static final UnicodeSet EMPTY = new UnicodeSet(); // constant,
	    // don't change
	    private static readonly ILOG.J2CsMapping.Collections.ISet SET_WITH_NULL_STRING = new HashedSet(); // constant,
	                                                                   static CanonicalIterator() {
	                                                                        ILOG.J2CsMapping.Collections.Generics.Collections.Add(SET_WITH_NULL_STRING,"");
	                                                                    }
	
	    // private static UnicodeSet SAFE_START = new UnicodeSet();
	    // private static CharMap AT_START = new CharMap();
	
	    // TODO: WARNING, NORMALIZER doesn't have supplementaries yet !!;
	    // Change FFFF to 10FFFF in C, and in Java when normalizer is upgraded.
	    // private static int LAST_UNICODE = 0x10FFFF;
	    /*
	     * static { buildData(); }
	     */
	    /*
	     * private static void buildData() {
	     * 
	     * if (PROGRESS) System.out.println("Getting Safe Start"); for (int cp = 0;
	     * cp <= LAST_UNICODE; ++cp) { if (PROGRESS & (cp & 0x7FF) == 0)
	     * System.out.print('.'); int cc = UCharacter.getCombiningClass(cp); if (cc
	     * == 0) SAFE_START.add(cp); // will fix to be really safe below } if
	     * (PROGRESS) System.out.println();
	     * 
	     * if (PROGRESS) System.out.println("Getting Containment"); for (int cp = 0;
	     * cp <= LAST_UNICODE; ++cp) { if (PROGRESS & (cp & 0x7FF) == 0)
	     * System.out.print('.');
	     * 
	     * if (Normalizer.isNormalized(cp, Normalizer.NFD)) continue;
	     * 
	     * //String istr = UTF16.valueOf(cp); String decomp =
	     * Normalizer.normalize(cp, Normalizer.NFD); //if (decomp.equals(istr))
	     * continue;
	     * 
	     * // add each character in the decomposition to canBeIn
	     * 
	     * int component; for (int i = 0; i < decomp.length(); i +=
	     * UTF16.getCharCount(component)) { component = UTF16.charAt(decomp, i); if
	     * (i == 0) { AT_START.add(component, cp); } else if
	     * (UCharacter.getCombiningClass(component) == 0) {
	     * SAFE_START.remove(component); } } } if (PROGRESS) System.out.println(); }
	     * // the following is just for a map from characters to a set of characters
	     * 
	     * private static class CharMap { Map storage = new HashMap(); MutableInt
	     * probe = new MutableInt(); boolean converted = false;
	     * 
	     * public void add(int cp, int whatItIsIn) { UnicodeSet result =
	     * (UnicodeSet) storage.get(probe.set(cp)); if (result == null) { result =
	     * new UnicodeSet(); storage.put(probe, result); } result.add(whatItIsIn); }
	     * 
	     * public UnicodeSet get(int cp) { return (UnicodeSet)
	     * storage.get(probe.set(cp)); } }
	     * 
	     * private static class MutableInt { public int contents; public int
	     * hashCode() { return contents; } public boolean equals(Object other) {
	     * return ((MutableInt)other).contents == contents; } // allows chaining
	     * public MutableInt set(int contents) { this.contents = contents; return
	     * this; } }
	     */
	
	}
}
