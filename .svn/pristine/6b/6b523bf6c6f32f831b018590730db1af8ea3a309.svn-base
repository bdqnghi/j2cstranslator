/*
 *******************************************************************************
 * Copyright (C) 1996-2006, International Business Machines Corporation and    *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 */

// NOTE:  This class is identical to java.text.StringCharacterIterator
// in JDK 1.2.  It's copied here because the JDK 1.1 version of
// StringCharacterIterator has a bug that prevents it from working
// right with RuleBasedBreakIterator.  This class is unnecessary
// when using RuleBasedBreakIterator with JDK 1.2.

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:30 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Text {
	
	using ILOG.J2CsMapping.Text;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	
	/// <summary>
	/// <c>StringCharacterIterator</c> implements the
	/// <c>CharacterIterater</c> protocol for a <c>String</c>. The
	/// <c>StringCharacterIterator</c> class iterates over the entire
	/// <c>String</c>.
	/// </summary>
	///
	/// <seealso cref="null"/>
	// /CLOVER:OFF
	public sealed class StringCharacterIterator : ICharacterIterator {
	    private String text;
	
	    private int begin;
	
	    private int end;
	
	    // invariant: begin <= pos <= end
	    private int pos;
	
	    /// <summary>
	    /// Constructs an iterator with an initial index of 0.
	    /// </summary>
	    ///
	    public StringCharacterIterator(String text_0) : this(text_0, 0) {
	    }
	
	    /// <summary>
	    /// Constructs an iterator with the specified initial index.
	    /// </summary>
	    ///
	    /// <param name="text_0">The String to be iterated over</param>
	    /// <param name="pos_1">Initial iterator position</param>
	    public StringCharacterIterator(String text_0, int pos_1) : this(text_0, 0, text_0.Length, pos_1) {
	    }
	
	    /// <summary>
	    /// Constructs an iterator over the given range of the given string, with the
	    /// index set at the specified position.
	    /// </summary>
	    ///
	    /// <param name="text_0">The String to be iterated over</param>
	    /// <param name="begin_1">Index of the first character</param>
	    /// <param name="end_2">Index of the character following the last character</param>
	    /// <param name="pos_3">Initial iterator position</param>
	    public StringCharacterIterator(String text_0, int begin_1, int end_2, int pos_3) {
	        if (text_0 == null) {
	            throw new NullReferenceException();
	        }
	        this.text = text_0;
	
	        if (begin_1 < 0 || begin_1 > end_2 || end_2 > text_0.Length) {
	            throw new ArgumentException("Invalid substring range");
	        }
	
	        if (pos_3 < begin_1 || pos_3 > end_2) {
	            throw new ArgumentException("Invalid position");
	        }
	
	        this.begin = begin_1;
	        this.end = end_2;
	        this.pos = pos_3;
	    }
	
	    /// <summary>
	    /// Reset this iterator to point to a new string. This package-visible method
	    /// is used by other java.text classes that want to avoid allocating new
	    /// StringCharacterIterator objects every time their setText method is
	    /// called.
	    /// </summary>
	    ///
	    /// <param name="text_0">The String to be iterated over</param>
	    public void SetText(String text_0) {
	        if (text_0 == null) {
	            throw new NullReferenceException();
	        }
	        this.text = text_0;
	        this.begin = 0;
	        this.end = text_0.Length;
	        this.pos = 0;
	    }
	
	    /// <summary>
	    /// Implements CharacterIterator.first() for String.
	    /// </summary>
	    ///
	    /// <seealso cref="null"/>
	    public char First() {
	        pos = begin;
	        return Current();
	    }
	
	    /// <summary>
	    /// Implements CharacterIterator.last() for String.
	    /// </summary>
	    ///
	    /// <seealso cref="null"/>
	    public char Last() {
	        if (end != begin) {
	            pos = end - 1;
	        } else {
	            pos = end;
	        }
	        return Current();
	    }
	
	    /// <summary>
	    /// Implements CharacterIterator.setIndex() for String.
	    /// </summary>
	    ///
	    /// <seealso cref="null"/>
	    public char SetIndex(int p) {
	        if (p < begin || p > end) {
	            throw new ArgumentException("Invalid index");
	        }
	        pos = p;
	        return Current();
	    }
	
	    /// <summary>
	    /// Implements CharacterIterator.current() for String.
	    /// </summary>
	    ///
	    /// <seealso cref="null"/>
	    public char Current() {
	        if (pos >= begin && pos < end) {
	            return text[pos];
	        } else {
	            return ILOG.J2CsMapping.Text.CharacterIterator.Done;
	        }
	    }
	
	    /// <summary>
	    /// Implements CharacterIterator.next() for String.
	    /// </summary>
	    ///
	    /// <seealso cref="null"/>
	    public char Next() {
	        if (pos < end - 1) {
	            pos++;
	            return text[pos];
	        } else {
	            pos = end;
	            return ILOG.J2CsMapping.Text.CharacterIterator.Done;
	        }
	    }
	
	    /// <summary>
	    /// Implements CharacterIterator.previous() for String.
	    /// </summary>
	    ///
	    /// <seealso cref="null"/>
	    public char Previous() {
	        if (pos > begin) {
	            pos--;
	            return text[pos];
	        } else {
	            return ILOG.J2CsMapping.Text.CharacterIterator.Done;
	        }
	    }
	
	    /// <summary>
	    /// Implements CharacterIterator.getBeginIndex() for String.
	    /// </summary>
	    ///
	    /// <seealso cref="null"/>
	    public int GetBeginIndex() {
	        return begin;
	    }
	
	    /// <summary>
	    /// Implements CharacterIterator.getEndIndex() for String.
	    /// </summary>
	    ///
	    /// <seealso cref="null"/>
	    public int GetEndIndex() {
	        return end;
	    }
	
	    /// <summary>
	    /// Implements CharacterIterator.getIndex() for String.
	    /// </summary>
	    ///
	    /// <seealso cref="null"/>
	    public int GetIndex() {
	        return pos;
	    }
	
	    /// <summary>
	    /// Compares the equality of two StringCharacterIterator objects.
	    /// </summary>
	    ///
	    /// <param name="obj">the StringCharacterIterator object to be compared with.</param>
	    /// <returns>true if the given obj is the same as this StringCharacterIterator
	    /// object; false otherwise.</returns>
	    public override bool Equals(Object obj) {
	        if ((Object) this == obj) {
	            return true;
	        }
	        if (!(obj  is  StringCharacterIterator)) {
	            return false;
	        }
	
	        StringCharacterIterator that = (StringCharacterIterator) obj;
	
	        if (GetHashCode() != that.GetHashCode()) {
	            return false;
	        }
	        if (!text.Equals(that.text)) {
	            return false;
	        }
	        if (pos != that.pos || begin != that.begin || end != that.end) {
	            return false;
	        }
	        return true;
	    }
	
	    /// <summary>
	    /// Computes a hashcode for this iterator.
	    /// </summary>
	    ///
	    /// <returns>A hash code</returns>
	    public override int GetHashCode() {
	        return text.GetHashCode() ^ pos ^ begin ^ end;
	    }
	
	    /// <summary>
	    /// Creates a copy of this iterator.
	    /// </summary>
	    ///
	    /// <returns>A copy of this</returns>
	    public Object Clone() {
	        try {
	            StringCharacterIterator other = (StringCharacterIterator) base.MemberwiseClone();
	            return other;
	        } catch (Exception e) {
	            throw new InvalidOperationException();
	        }
	    }
	
	}
	// /CLOVER:ON
}
