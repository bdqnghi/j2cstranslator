//##header J2SE15
/*
 *******************************************************************************
 * Copyright (C) 1996-2007, International Business Machines Corporation and    *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 */

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:30 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Text {
	
	using IBM.ICU.Impl;
	using IBM.ICU.Util;
	using ILOG.J2CsMapping.Collections;
	using ILOG.J2CsMapping.Collections.Generics;
	using ILOG.J2CsMapping.IO;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.Globalization;
	using System.IO;
	using System.Resources;
	using System.Runtime.CompilerServices;
	using System.Text;
     using ILOG.J2CsMapping.Util;
     using ILOG.J2CsMapping.Util;
	
	/// <summary>
	/// <c>SimpleDateFormat</c> is a concrete class for formatting and parsing
	/// dates in a locale-sensitive manner. It allows for formatting (date -> text),
	/// parsing (text -> date), and normalization.
	/// <p>
	/// <c>SimpleDateFormat</c> allows you to start by choosing any
	/// user-defined patterns for date-time formatting. However, you are encouraged
	/// to create a date-time formatter with either <c>getTimeInstance</c>,
	/// <c>getDateInstance</c>, or <c>getDateTimeInstance</c> in
	/// <c>DateFormat</c>. Each of these class methods can return a date/time
	/// formatter initialized with a default format pattern. You may modify the
	/// format pattern using the <c>applyPattern</c> methods as desired. For
	/// more information on using these methods, see <see cref="T:IBM.ICU.Text.DateFormat"/>.
	/// <p>
	/// <strong>Time Format Syntax:</strong>
	/// <p>
	/// To specify the time format use a <em>time pattern</em> string. In this
	/// pattern, all ASCII letters are reserved as pattern letters, which are defined
	/// as the following: <blockquote>
	/// <pre>
	/// Symbol   Meaning                 Presentation        Example
	/// ------   -------                 ------------        -------
	/// G        era designator          (Text)              AD
	/// y&#x2020;       year                    (Number)            1996
	/// Y///       year (week of year)     (Number)            1997
	/// u///       extended year           (Number)            4601
	/// M        month in year           (Text & Number)     July & 07
	/// d        day in month            (Number)            10
	/// h        hour in am/pm (1~12)    (Number)            12
	/// H        hour in day (0~23)      (Number)            0
	/// m        minute in hour          (Number)            30
	/// s        second in minute        (Number)            55
	/// S        fractional second       (Number)            978
	/// E        day of week             (Text)              Tuesday
	/// e///       day of week (local 1~7) (Number)            2
	/// D        day in year             (Number)            189
	/// F        day of week in month    (Number)            2 (2nd Wed in July)
	/// w        week in year            (Number)            27
	/// W        week in month           (Number)            2
	/// a        am/pm marker            (Text)              PM
	/// k        hour in day (1~24)      (Number)            24
	/// K        hour in am/pm (0~11)    (Number)            0
	/// z        time zone               (Text)              Pacific Standard Time
	/// Z        time zone (RFC 822)     (Number)            -0800
	/// v        time zone (generic)     (Text)              Pacific Time
	/// V        time zone (location)    (Text)              United States (Los Angeles)
	/// g///       Julian day              (Number)            2451334
	/// A///       milliseconds in day     (Number)            69540000
	/// Q///       quarter in year         (Text & Number)     Q1 & 01
	/// c///       stand alone day of week (Text & Number)     Tuesday & 2
	/// L///       stand alone month       (Text & Number)     July & 07
	/// q///       stand alone quarter     (Text & Number)     Q1 & 01
	/// '        escape for text         (Delimiter)         'Date='
	/// ''       single quote            (Literal)           'o''clock'
	/// </pre>
	/// </blockquote> <tt><b>///</b></tt> These items are not supported by Java's
	/// SimpleDateFormat.<br>
	/// <tt><b>&#x2020;</b></tt> ICU interprets a single 'y' differently than Java.
	/// </p>
	/// <p>
	/// The count of pattern letters determine the format.
	/// <p>
	/// <strong>(Text)</strong>: 4 or more pattern letters--use full form, &lt;
	/// 4--use short or abbreviated form if one exists.
	/// <p>
	/// <strong>(Number)</strong>: the minimum number of digits. Shorter numbers are
	/// zero-padded to this amount. Year is handled specially; that is, if the count
	/// of 'y' is 2, the Year will be truncated to 2 digits. (e.g., if "yyyy"
	/// produces "1997", "yy" produces "97".) Unlike other fields, fractional seconds
	/// are padded on the right with zero.
	/// <p>
	/// <strong>(Text & Number)</strong>: 3 or over, use text, otherwise use number.
	/// <p>
	/// Any characters in the pattern that are not in the ranges of ['a'..'z'] and
	/// ['A'..'Z'] will be treated as quoted text. For instance, characters like ':',
	/// '.', ' ', '#' and '@' will appear in the resulting time text even they are
	/// not embraced within single quotes.
	/// <p>
	/// A pattern containing any invalid pattern letter will result in a thrown
	/// exception during formatting or parsing.
	/// <p>
	/// <strong>Examples Using the US Locale:</strong> <blockquote>
	/// <pre>
	/// Format Pattern                         Result
	/// --------------                         -------
	/// "yyyy.MM.dd G 'at' HH:mm:ss vvvv" ->>  1996.07.10 AD at 15:08:56 Pacific Time
	/// "EEE, MMM d, ''yy"                ->>  Wed, July 10, '96
	/// "h:mm a"                          ->>  12:08 PM
	/// "hh 'o''clock' a, zzzz"           ->>  12 o'clock PM, Pacific Daylight Time
	/// "K:mm a, vvv"                     ->>  0:00 PM, PT
	/// "yyyyy.MMMMM.dd GGG hh:mm aaa"    ->>  01996.July.10 AD 12:08 PM
	/// </pre>
	/// </blockquote> <strong>Code Sample:</strong> <blockquote>
	/// <pre>
	/// SimpleTimeZone pdt = new SimpleTimeZone(-8/// 60/// 60/// 1000, "PST");
	/// pdt.setStartRule(Calendar.APRIL, 1, Calendar.SUNDAY, 2///60///60///1000);
	/// pdt.setEndRule(Calendar.OCTOBER, -1, Calendar.SUNDAY, 2///60///60///1000);
	/// <br>
	/// // Format the current time.
	/// SimpleDateFormat formatter
	/// = new SimpleDateFormat ("yyyy.MM.dd G 'at' hh:mm:ss a zzz");
	/// Date currentTime_1 = new Date();
	/// String dateString = formatter.format(currentTime_1);
	/// <br>
	/// // Parse the previous string back into a Date.
	/// ParsePosition pos = new ParsePosition(0);
	/// Date currentTime_2 = formatter.parse(dateString, pos);
	/// </pre>
	/// </blockquote> In the example, the time value <c>currentTime_2</c>
	/// obtained from parsing will be equal to <c>currentTime_1</c>. However,
	/// they may not be equal if the am/pm marker 'a' is left out from the format
	/// pattern while the "hour in am/pm" pattern symbol is used. This information
	/// loss can happen when formatting the time in PM.
	/// <p>
	/// When parsing a date string using the abbreviated year pattern ("yy"),
	/// SimpleDateFormat must interpret the abbreviated year relative to some
	/// century. It does this by adjusting dates to be within 80 years before and 20
	/// years after the time the SimpleDateFormat instance is created. For example,
	/// using a pattern of "MM/dd/yy" and a SimpleDateFormat instance created on Jan
	/// 1, 1997, the string "01/11/12" would be interpreted as Jan 11, 2012 while the
	/// string "05/04/64" would be interpreted as May 4, 1964. During parsing, only
	/// strings consisting of exactly two digits, as defined by<see cref="null"/>, will be parsed into the default
	/// century. Any other numeric string, such as a one digit string, a three or
	/// more digit string, or a two digit string that isn't all digits (for example,
	/// "-1"), is interpreted literally. So "01/02/3" or "01/02/003" are parsed,
	/// using the same pattern, as Jan 2, 3 AD. Likewise, "01/02/-3" is parsed as Jan
	/// 2, 4 BC.
	/// <p>
	/// If the year pattern does not have exactly two 'y' characters, the year is
	/// interpreted literally, regardless of the number of digits. So using the
	/// pattern "MM/dd/yyyy", "01/11/12" parses to Jan 11, 12 A.D.
	/// <p>
	/// When numeric fields abut one another directly, with no intervening delimiter
	/// characters, they constitute a run of abutting numeric fields. Such runs are
	/// parsed specially. For example, the format "HHmmss" parses the input text
	/// "123456" to 12:34:56, parses the input text "12345" to 1:23:45, and fails to
	/// parse "1234". In other words, the leftmost field of the run is flexible,
	/// while the others keep a fixed width. If the parse fails anywhere in the run,
	/// then the leftmost field is shortened by one character, and the entire run is
	/// parsed again. This is repeated until either the parse succeeds or the
	/// leftmost field is one character in length. If the parse still fails at that
	/// point, the parse of the run fails.
	/// <p>
	/// For time zones that have no names, use strings GMT+hours:minutes or
	/// GMT-hours:minutes.
	/// <p>
	/// The calendar defines what is the first day of the week, the first week of the
	/// year, whether hours are zero based or not (0 vs 12 or 24), and the time zone.
	/// There is one common decimal format to handle all the numbers; the digit count
	/// is handled programmatically according to the pattern.
	/// <h4>Synchronization</h4>
	/// Date formats are not synchronized. It is recommended to create separate
	/// format instances for each thread. If multiple threads access a format
	/// concurrently, it must be synchronized externally.
	/// </summary>
	///
	/// <seealso cref="T:IBM.ICU.Text.Calendar"/>
	/// <seealso cref="T:IBM.ICU.Text.GregorianCalendar"/>
	/// <seealso cref="T:IBM.ICU.Text.TimeZone"/>
	/// <seealso cref="T:IBM.ICU.Text.DateFormat"/>
	/// <seealso cref="T:IBM.ICU.Text.DateFormatSymbols"/>
	/// <seealso cref="T:IBM.ICU.Text.DecimalFormat"/>
	/// @stable ICU 2.0
	public class SimpleDateFormat : DateFormat {
	
	    // the official serial version ID which says cryptically
	    // which version we're compatible with
	    private const long serialVersionUID = 4774881970558875024L;
	
	    // the internal serial version which says which version was written
	    // - 0 (default) for version up to JDK 1.1.3
	    // - 1 for version from JDK 1.1.4, which includes a new field
	    internal const int currentSerialVersion = 1;
	
	    /// <summary>
	    /// The version of the serialized data on the stream. Possible values:
	    /// <ul>
	    /// <li><b>0</b> or not present on stream: JDK 1.1.3. This version has no
	    /// <c>defaultCenturyStart</c> on stream.
	    /// <li><b>1</b> JDK 1.1.4 or later. This version adds
	    /// <c>defaultCenturyStart</c>.
	    /// </ul>
	    /// When streaming out this class, the most recent format and the highest
	    /// allowable <c>serialVersionOnStream</c> is written.
	    /// </summary>
	    ///
	    /// @serial
	    private int serialVersionOnStream;
	
	    /// <summary>
	    /// The pattern string of this formatter. This is always a non-localized
	    /// pattern. May not be null. See class documentation for details.
	    /// </summary>
	    ///
	    /// @serial
	    private String pattern;
	
	    /// <summary>
	    /// The symbols used by this formatter for week names, month names, etc. May
	    /// not be null.
	    /// </summary>
	    ///
	    /// @serial
	    /// <seealso cref="T:IBM.ICU.Text.DateFormatSymbols"/>
	    private DateFormatSymbols formatData;
	
	    private ULocale locale;
	
	    /// <summary>
	    /// We map dates with two-digit years into the century starting at
	    /// <c>defaultCenturyStart</c>, which may be any date. May not be null.
	    /// </summary>
	    ///
	    /// @serial
	    private DateTime defaultCenturyStart;
	
	    private int defaultCenturyStartYear;
	
	    // defaultCenturyBase is set when an instance is created
	    // and may be used for calculating defaultCenturyStart when needed.
	    private long defaultCenturyBase;
	
	    // We need to preserve time zone type when parsing specific
	    // time zone text (xxx Standard Time vs xxx Daylight Time)
	    private const int TZTYPE_UNK = 0, TZTYPE_STD = 1, TZTYPE_DST = 2;
	
	    private int tztype;
	
	    private const int millisPerHour = 60 * 60 * 1000;
	
	    private const int millisPerMinute = 60 * 1000;
	
	    private const int millisPerSecond = 1000;
	
	    // This prefix is designed to NEVER MATCH real text, in order to
	    // suppress the parsing of negative numbers. Adjust as needed (if
	    // this becomes valid Unicode).
	    private static readonly String SUPPRESS_NEGATIVE_PREFIX = "\uAB00";
	
	    /// <summary>
	    /// If true, this object supports fast formatting using the subFormat variant
	    /// that takes a StringBuffer.
	    /// </summary>
	    ///
	    private bool useFastFormat;
	
	    /// <summary>
	    /// Construct a SimpleDateFormat using the default pattern for the default
	    /// locale. <b>Note:</b> Not all locales support SimpleDateFormat; for full
	    /// generality, use the factory methods in the DateFormat class.
	    /// </summary>
	    ///
	    /// <seealso cref="T:IBM.ICU.Text.DateFormat"/>
	    /// @stable ICU 2.0
	    public SimpleDateFormat() : this(GetDefaultPattern(), null, null, null, null, true) {
	    }
	
	    /// <summary>
	    /// Construct a SimpleDateFormat using the given pattern in the default
	    /// locale. <b>Note:</b> Not all locales support SimpleDateFormat; for full
	    /// generality, use the factory methods in the DateFormat class.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public SimpleDateFormat(String pattern_0) : this(pattern_0, null, null, null, null, true) {
	    }
	
	    /// <summary>
	    /// Construct a SimpleDateFormat using the given pattern and locale.
	    /// <b>Note:</b> Not all locales support SimpleDateFormat; for full
	    /// generality, use the factory methods in the DateFormat class.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
        public SimpleDateFormat(String pattern_0, Locale loc)
            : this(pattern_0, null, null, null, IBM.ICU.Util.ULocale.ForLocale(loc), true)
        {
	    }
	
	    /// <summary>
	    /// Construct a SimpleDateFormat using the given pattern and locale.
	    /// <b>Note:</b> Not all locales support SimpleDateFormat; for full
	    /// generality, use the factory methods in the DateFormat class.
	    /// </summary>
	    ///
	    /// @stable ICU 3.2
	    public SimpleDateFormat(String pattern_0, ULocale loc) : this(pattern_0, null, null, null, loc, true) {
	    }
	
	    /// <summary>
	    /// Construct a SimpleDateFormat using the given pattern and locale-specific
	    /// symbol data. Warning: uses default locale for digits!
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public SimpleDateFormat(String pattern_0, DateFormatSymbols formatData_1) : this(pattern_0, (DateFormatSymbols)formatData_1.Clone(), null, null, null, true) {
	    }
	
	    /// <exclude/>
	    public SimpleDateFormat(String pattern_0, DateFormatSymbols formatData_1,
	            ULocale loc) : this(pattern_0, (DateFormatSymbols)formatData_1.Clone(), null, null, loc, true) {
	    }
	
	    /// <summary>
	    /// Package-private constructor that allows a subclass to specify whether it
	    /// supports fast formatting.
	    /// TODO make this API public.
	    /// </summary>
	    ///
	    internal SimpleDateFormat(String pattern_0, DateFormatSymbols formatData_1,
                IBM.ICU.Util.Calendar calendar, ULocale locale_2, bool useFastFormat_3)
            : this(pattern_0, (DateFormatSymbols)formatData_1.Clone(), (IBM.ICU.Util.Calendar)calendar.Clone(), null, locale_2, useFastFormat_3)
        {
	    }
	
	    /*
	     * The constructor called from all other SimpleDateFormat constructors
	     */
	    private SimpleDateFormat(String pattern_0, DateFormatSymbols formatData_1,
                IBM.ICU.Util.Calendar calendar, NumberFormat numberFormat, ULocale locale_2,
	            bool useFastFormat_3) {
	        this.serialVersionOnStream = currentSerialVersion;
	                this.tztype = TZTYPE_UNK;
	        this.pattern = pattern_0;
	        this.formatData = formatData_1;
	        this.calendar = calendar;
	        this.numberFormat = numberFormat;
	        this.locale = locale_2; // time zone formatting
	        this.useFastFormat = useFastFormat_3;
	        Initialize();
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Create an instance of SimpleDateForamt for the given format configuration
	    /// </summary>
	    ///
	    /// <param name="formatConfig">the format configuration</param>
	    /// <returns>A SimpleDateFormat instance</returns>
	    public static SimpleDateFormat GetInstance(
	            IBM.ICU.Util.Calendar.FormatConfiguration formatConfig) {
	        return new SimpleDateFormat(formatConfig.GetPatternString(),
	                formatConfig.GetDateFormatSymbols(),
	                formatConfig.GetCalendar(), null, formatConfig.GetLocale(),
	                true);
	    }
	
	    /*
	     * Initialized fields
	     */
	    private void Initialize() {
	        if (locale == null) {
	            locale = IBM.ICU.Util.ULocale.GetDefault();
	        }
	        if (formatData == null) {
	            formatData = new DateFormatSymbols(locale);
	        }
	        if (calendar == null) {
	            calendar = IBM.ICU.Util.Calendar.GetInstance(locale);
	        }
	        if (numberFormat == null) {
	            // Use a NumberFormat optimized for date formatting
	            numberFormat = new DateNumberFormat(locale);
	        }
	        // Note: deferring calendar calculation until when we really need it.
	        // Instead, we just record time of construction for backward
	        // compatibility.
            defaultCenturyBase = DateUtil.DotNetDateToJavaMillis(DateTime.Now); //DateTime.Now.Millisecond;
	
	        SetLocale(calendar.GetLocale(IBM.ICU.Util.ULocale.VALID_LOCALE),
	                calendar.GetLocale(IBM.ICU.Util.ULocale.ACTUAL_LOCALE));
	        InitLocalZeroPaddingNumberFormat();
	    }
	
	    // privates for the default pattern
	    private static ULocale cachedDefaultLocale = null;
	
	    private static String cachedDefaultPattern = null;
	
	    private static readonly String FALLBACKPATTERN = "yy/MM/dd HH:mm";
	
	    /*
	     * Returns the default date and time pattern (SHORT) for the default locale.
	     * This method is only used by the default SimpleDateFormat constructor.
	     */
	    [MethodImpl(MethodImplOptions.Synchronized)]
	    private static String GetDefaultPattern() {
	        ULocale defaultLocale = IBM.ICU.Util.ULocale.GetDefault();
	        if (!defaultLocale.Equals(cachedDefaultLocale)) {
	            cachedDefaultLocale = defaultLocale;
	            IBM.ICU.Util.Calendar cal = IBM.ICU.Util.Calendar.GetInstance(cachedDefaultLocale);
	            try {
	                CalendarData calData = new CalendarData(cachedDefaultLocale,
	                        cal.GetType());
	                String[] dateTimePatterns = calData
	                        .GetStringArray("DateTimePatterns");
	                cachedDefaultPattern = IBM.ICU.Text.MessageFormat.Format(
	                        dateTimePatterns[8], new Object[] {
	                                dateTimePatterns[IBM.ICU.Text.DateFormat.SHORT],
	                                dateTimePatterns[IBM.ICU.Text.DateFormat.SHORT + 4] });
	            } catch (MissingManifestResourceException e) {
	                cachedDefaultPattern = FALLBACKPATTERN;
	            }
	        }
	        return cachedDefaultPattern;
	    }
	
	    /*
	     * Define one-century window into which to disambiguate dates using
	     * two-digit years.
	     */
	    private void ParseAmbiguousDatesAsAfter(DateTime startDate) {
	        defaultCenturyStart = startDate;
	        calendar.SetTime(startDate);
	        defaultCenturyStartYear = calendar.Get(IBM.ICU.Util.Calendar.YEAR);
	    }
	
	    /*
	     * Initialize defaultCenturyStart and defaultCenturyStartYear by base time.
	     * The default start time is 80 years before the creation time of this
	     * object.
	     */
	    private void InitializeDefaultCenturyStart(long baseTime) {
	        defaultCenturyBase = baseTime;
	        // clone to avoid messing up date stored in calendar object
	        // when this method is called while parsing
	        IBM.ICU.Util.Calendar tmpCal = (IBM.ICU.Util.Calendar) calendar.Clone();
	        tmpCal.SetTimeInMillis(baseTime);
	        tmpCal.Add(IBM.ICU.Util.Calendar.YEAR, -80);
	        defaultCenturyStart = tmpCal.GetTime();
	        defaultCenturyStartYear = tmpCal.Get(IBM.ICU.Util.Calendar.YEAR);
	    }
	
	    /* Gets the default century start date for this object */
	    private DateTime GetDefaultCenturyStart() {
            if (defaultCenturyStart == default(DateTime))
            {
	            // not yet initialized
	            InitializeDefaultCenturyStart(defaultCenturyBase);
	        }
	        return defaultCenturyStart;
	    }
	
	    /* Gets the default century start year for this object */
	    private int GetDefaultCenturyStartYear() {
	        if (defaultCenturyStart == default(DateTime)) {
	            // not yet initialized
	            InitializeDefaultCenturyStart(defaultCenturyBase);
	        }
	        return defaultCenturyStartYear;
	    }
	
	    /// <summary>
	    /// Sets the 100-year period 2-digit years will be interpreted as being in to
	    /// begin on the date the user specifies.
	    /// </summary>
	    ///
	    /// <param name="startDate">During parsing, two digit years will be placed in the range<c>startDate</c> to <c>startDate + 100 years</c>.</param>
	    /// @stable ICU 2.0
	    public void Set2DigitYearStart(DateTime startDate) {
	        ParseAmbiguousDatesAsAfter(startDate);
	    }
	
	    /// <summary>
	    /// Returns the beginning date of the 100-year period 2-digit years are
	    /// interpreted as being within.
	    /// </summary>
	    ///
	    /// <returns>the start of the 100-year period into which two digit years are
	    /// parsed</returns>
	    /// @stable ICU 2.0
	    public DateTime Get2DigitYearStart() {
	        return GetDefaultCenturyStart();
	    }
	
	    /// <summary>
	    /// Overrides DateFormat.
	    /// <p>
	    /// Formats a date or time, which is the standard millis since January 1,
	    /// 1970, 00:00:00 GMT.
	    /// <p>
	    /// Example: using the US locale: "yyyy.MM.dd G 'at' HH:mm:ss zzz" ->>
	    /// 1996.07.10 AD at 15:08:56 PDT
	    /// </summary>
	    ///
	    /// <param name="cal">the calendar whose date-time value is to be formatted into adate-time string</param>
	    /// <param name="toAppendTo">where the new date-time text is to be appended</param>
	    /// <param name="pos">the formatting position. On input: an alignment field, ifdesired. On output: the offsets of the alignment field.</param>
	    /// <returns>the formatted date-time string.</returns>
	    /// <seealso cref="T:IBM.ICU.Text.DateFormat"/>
	    /// @stable ICU 2.0
        public override StringBuilder Format(IBM.ICU.Util.Calendar cal, StringBuilder toAppendTo,
	            ILOG.J2CsMapping.Text.FieldPosition pos) {
	        return Format(cal, toAppendTo, pos, null);
	    }
	
	    // The actual method to format date. If List attributes is not null,
	    // then attribute information will be recorded.
        private StringBuilder Format(IBM.ICU.Util.Calendar cal, StringBuilder toAppendTo,
	            ILOG.J2CsMapping.Text.FieldPosition pos, IList attributes) {
	        // Initialize
	        pos.SetBeginIndex(0);
	        pos.SetEndIndex(0);
	
	        // Careful: For best performance, minimize the number of calls
	        // to StringBuffer.append() by consolidating appends when
	        // possible.
	
	        Object[] items = GetPatternItems();
	        for (int i = 0; i < items.Length; i++) {
	            if (items[i]  is  String) {
	                toAppendTo.Append((String) items[i]);
	            } else {
	                SimpleDateFormat.PatternItem  item = (SimpleDateFormat.PatternItem ) items[i];
	                // #if defined(FOUNDATION10) || defined(J2SE13)
	                // #else
	                int start = 0;
	                if (attributes != null) {
	                    // Save the current length
	                    start = toAppendTo.Length;
	                }
	                // #endif
	                if (useFastFormat) {
	                    SubFormat(toAppendTo, item.type, item.length,
	                            toAppendTo.Length, pos, cal);
	                } else {
	                    toAppendTo.Append(SubFormat(item.type, item.length,
	                            toAppendTo.Length, pos, formatData, cal));
	                }
	                // #if defined(FOUNDATION10) || defined(J2SE13)
	                // #else
	                if (attributes != null) {
	                    // Check the sub format length
	                    int end = toAppendTo.Length;
	                    if (end - start > 0) {
	                        // Append the attribute to the list
	                        DateFormat.Field attr = PatternCharToDateFormatField(item.type);
	                        ILOG.J2CsMapping.Text.FieldPosition fp = new ILOG.J2CsMapping.Text.FieldPosition(attr);
	                        fp.SetBeginIndex(start);
	                        fp.SetEndIndex(end);
	                        ILOG.J2CsMapping.Collections.Generics.Collections.Add(attributes,fp);
	                    }
	                }
	                // #endif
	            }
	        }
	        return toAppendTo;
	
	    }
	
	    // Map pattern character to index
	    private const int PATTERN_CHAR_BASE = 0x40;
	
	    private static readonly int[] PATTERN_CHAR_TO_INDEX = {
	            // A B C D E F G H I J K L M N O
	            -1, 22, -1, -1, 10, 9, 11, 0, 5, -1, -1, 16, 26, 2, -1, -1,
	            // P Q R S T U V W X Y Z
	            -1, 27, -1, 8, -1, -1, 29, 13, -1, 18, 23, -1, -1, -1, -1, -1,
	            // a b c d e f g h i j k l m n o
	            -1, 14, -1, 25, 3, 19, -1, 21, 15, -1, -1, 4, -1, 6, -1, -1,
	            // p q r s t u v w x y z
	            -1, 28, -1, 7, -1, 20, 24, 12, -1, 1, 17, -1, -1, -1, -1, -1 };
	
	    // Map pattern character index to Calendar field number
	    private static readonly int[] PATTERN_INDEX_TO_CALENDAR_FIELD = {
	    IBM.ICU.Util.Calendar.ERA, IBM.ICU.Util.Calendar.YEAR, IBM.ICU.Util.Calendar.MONTH,
	    IBM.ICU.Util.Calendar.DATE, IBM.ICU.Util.Calendar.HOUR_OF_DAY, IBM.ICU.Util.Calendar.HOUR_OF_DAY,
	    IBM.ICU.Util.Calendar.MINUTE, IBM.ICU.Util.Calendar.SECOND, IBM.ICU.Util.Calendar.MILLISECOND,
	    IBM.ICU.Util.Calendar.DAY_OF_WEEK, IBM.ICU.Util.Calendar.DAY_OF_YEAR,
	            IBM.ICU.Util.Calendar.DAY_OF_WEEK_IN_MONTH,
	            IBM.ICU.Util.Calendar.WEEK_OF_YEAR, IBM.ICU.Util.Calendar.WEEK_OF_MONTH,
	            IBM.ICU.Util.Calendar.AM_PM,
	            IBM.ICU.Util.Calendar.HOUR, IBM.ICU.Util.Calendar.HOUR, IBM.ICU.Util.Calendar.ZONE_OFFSET,
	            IBM.ICU.Util.Calendar.YEAR_WOY, IBM.ICU.Util.Calendar.DOW_LOCAL,
	            IBM.ICU.Util.Calendar.EXTENDED_YEAR,
	            IBM.ICU.Util.Calendar.JULIAN_DAY, IBM.ICU.Util.Calendar.MILLISECONDS_IN_DAY,
	            IBM.ICU.Util.Calendar.ZONE_OFFSET,
	            IBM.ICU.Util.Calendar.ZONE_OFFSET,
	            IBM.ICU.Util.Calendar.DAY_OF_WEEK,
	            IBM.ICU.Util.Calendar.MONTH,
	            IBM.ICU.Util.Calendar.MONTH, IBM.ICU.Util.Calendar.MONTH,
	            IBM.ICU.Util.Calendar.ZONE_OFFSET, };
	
	    // Map pattern character index to DateFormat field number
	    private static readonly int[] PATTERN_INDEX_TO_DATE_FORMAT_FIELD = {
	    IBM.ICU.Text.DateFormat.ERA_FIELD, IBM.ICU.Text.DateFormat.YEAR_FIELD,
	            IBM.ICU.Text.DateFormat.MONTH_FIELD,
	            IBM.ICU.Text.DateFormat.DATE_FIELD, IBM.ICU.Text.DateFormat.HOUR_OF_DAY1_FIELD,
	            IBM.ICU.Text.DateFormat.HOUR_OF_DAY0_FIELD,
	            IBM.ICU.Text.DateFormat.MINUTE_FIELD, IBM.ICU.Text.DateFormat.SECOND_FIELD,
	            IBM.ICU.Text.DateFormat.FRACTIONAL_SECOND_FIELD,
	            IBM.ICU.Text.DateFormat.DAY_OF_WEEK_FIELD,
	            IBM.ICU.Text.DateFormat.DAY_OF_YEAR_FIELD,
	            IBM.ICU.Text.DateFormat.DAY_OF_WEEK_IN_MONTH_FIELD,
	            IBM.ICU.Text.DateFormat.WEEK_OF_YEAR_FIELD,
	            IBM.ICU.Text.DateFormat.WEEK_OF_MONTH_FIELD, IBM.ICU.Text.DateFormat.AM_PM_FIELD,
	            IBM.ICU.Text.DateFormat.HOUR1_FIELD, IBM.ICU.Text.DateFormat.HOUR0_FIELD,
	            IBM.ICU.Text.DateFormat.TIMEZONE_FIELD,
	            IBM.ICU.Text.DateFormat.YEAR_WOY_FIELD, IBM.ICU.Text.DateFormat.DOW_LOCAL_FIELD,
	            IBM.ICU.Text.DateFormat.EXTENDED_YEAR_FIELD,
	            IBM.ICU.Text.DateFormat.JULIAN_DAY_FIELD,
	            IBM.ICU.Text.DateFormat.MILLISECONDS_IN_DAY_FIELD,
	            IBM.ICU.Text.DateFormat.TIMEZONE_RFC_FIELD,
	            IBM.ICU.Text.DateFormat.TIMEZONE_GENERIC_FIELD,
	            IBM.ICU.Text.DateFormat.STANDALONE_DAY_FIELD,
	            IBM.ICU.Text.DateFormat.STANDALONE_MONTH_FIELD,
	            IBM.ICU.Text.DateFormat.QUARTER_FIELD,
	            IBM.ICU.Text.DateFormat.STANDALONE_QUARTER_FIELD,
	            IBM.ICU.Text.DateFormat.TIMEZONE_SPECIAL_FIELD, };
	
	    // #if defined(FOUNDATION10) || defined(J2SE13)
	    // #else
	    // Map pattern character index to DateFormat.Field
	    private static readonly DateFormat.Field[] PATTERN_INDEX_TO_DATE_FORMAT_ATTRIBUTE = {
	    IBM.ICU.Text.DateFormat.Field.ERA, IBM.ICU.Text.DateFormat.Field.YEAR,
	            IBM.ICU.Text.DateFormat.Field.MONTH,
	            IBM.ICU.Text.DateFormat.Field.DAY_OF_MONTH,
	            IBM.ICU.Text.DateFormat.Field.HOUR_OF_DAY1, IBM.ICU.Text.DateFormat.Field.HOUR_OF_DAY0,
	            IBM.ICU.Text.DateFormat.Field.MINUTE, IBM.ICU.Text.DateFormat.Field.SECOND,
	            IBM.ICU.Text.DateFormat.Field.MILLISECOND,
	            IBM.ICU.Text.DateFormat.Field.DAY_OF_WEEK,
	            IBM.ICU.Text.DateFormat.Field.DAY_OF_YEAR,
	            IBM.ICU.Text.DateFormat.Field.DAY_OF_WEEK_IN_MONTH,
	            IBM.ICU.Text.DateFormat.Field.WEEK_OF_YEAR,
	            IBM.ICU.Text.DateFormat.Field.WEEK_OF_MONTH, IBM.ICU.Text.DateFormat.Field.AM_PM,
	            IBM.ICU.Text.DateFormat.Field.HOUR1, IBM.ICU.Text.DateFormat.Field.HOUR0,
	            IBM.ICU.Text.DateFormat.Field.TIME_ZONE,
	            IBM.ICU.Text.DateFormat.Field.YEAR_WOY, IBM.ICU.Text.DateFormat.Field.DOW_LOCAL,
	            IBM.ICU.Text.DateFormat.Field.EXTENDED_YEAR,
	            IBM.ICU.Text.DateFormat.Field.JULIAN_DAY,
	            IBM.ICU.Text.DateFormat.Field.MILLISECONDS_IN_DAY, IBM.ICU.Text.DateFormat.Field.TIME_ZONE,
	            IBM.ICU.Text.DateFormat.Field.TIME_ZONE,
	            IBM.ICU.Text.DateFormat.Field.DAY_OF_WEEK,
	            IBM.ICU.Text.DateFormat.Field.MONTH,
	            IBM.ICU.Text.DateFormat.Field.QUARTER, IBM.ICU.Text.DateFormat.Field.QUARTER,
	            IBM.ICU.Text.DateFormat.Field.TIME_ZONE, };
	
	    /// <summary>
	    /// Return a DateFormat.Field constant associated with the specified format
	    /// pattern character.
	    /// </summary>
	    ///
	    /// <param name="ch">The pattern character</param>
	    /// <returns>DateFormat.Field associated with the pattern character</returns>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    protected internal virtual DateFormat.Field PatternCharToDateFormatField(char ch) {
	        int patternCharIndex = -1;
	        if ('A' <= ch && ch <= 'z') {
	            patternCharIndex = PATTERN_CHAR_TO_INDEX[(int) ch
	                    - PATTERN_CHAR_BASE];
	        }
	        if (patternCharIndex != -1) {
	            return PATTERN_INDEX_TO_DATE_FORMAT_ATTRIBUTE[patternCharIndex];
	        }
	        return null;
	    }
	
	    // #endif
	
	    /// <summary>
	    /// Format a single field, given its pattern character. Subclasses may
	    /// override this method in order to modify or add formatting capabilities.
	    /// </summary>
	    ///
	    /// <param name="ch">the pattern character</param>
	    /// <param name="count">the number of times ch is repeated in the pattern</param>
	    /// <param name="beginOffset">the offset of the output string at the start of this field;used to set pos when appropriate</param>
	    /// <param name="pos">receives the position of a field, when appropriate</param>
	    /// <param name="formatData_0">the symbols for this formatter</param>
	    /// @stable ICU 2.0
	    protected internal String SubFormat(char ch, int count, int beginOffset,
                ILOG.J2CsMapping.Text.FieldPosition pos, DateFormatSymbols formatData_0, IBM.ICU.Util.Calendar cal)
        {
	        // Note: formatData is ignored
	        StringBuilder buf = new StringBuilder();
	        SubFormat(buf, ch, count, beginOffset, pos, cal);
	        return buf.ToString();
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Format a single field; useFastFormat variant. Reuses a StringBuffer for
	    /// results instead of creating a String on the heap for each call.
	    /// NOTE We don't really need the beginOffset parameter, EXCEPT for the need
	    /// to support the slow subFormat variant (above) which has to pass it in to
	    /// us.
	    /// TODO make this API public
	    /// </summary>
	    ///
	    protected internal virtual void SubFormat(StringBuilder buf, char ch, int count,
                int beginOffset, ILOG.J2CsMapping.Text.FieldPosition pos, IBM.ICU.Util.Calendar cal)
        {
	        int maxIntCount = Int32.MaxValue;
	        int bufstart = buf.Length;
	
	        // final int patternCharIndex =
	        // DateFormatSymbols.patternChars.indexOf(ch);
	        int patternCharIndex = -1;
	        if ('A' <= ch && ch <= 'z') {
	            patternCharIndex = PATTERN_CHAR_TO_INDEX[(int) ch
	                    - PATTERN_CHAR_BASE];
	        }
	
	        if (patternCharIndex == -1) {
	            throw new ArgumentException("Illegal pattern character "
	                    + "'" + ch + "' in \"" + pattern + '"');
	        }
	
	        int field = PATTERN_INDEX_TO_CALENDAR_FIELD[patternCharIndex];
	        int value_ren = cal.Get(field);
	
	        String zoneString = null;
	
	        switch (patternCharIndex) {
	        case 0: // 'G' - ERA
	            if (count == 5) {
	                buf.Append(formatData.narrowEras[value_ren]);
	            } else if (count == 4)
	                buf.Append(formatData.eraNames[value_ren]);
	            else
	                buf.Append(formatData.eras[value_ren]);
	            break;
	        case 1: // 'y' - YEAR
	            /*
	             * According to the specification, if the number of pattern letters
	             * ('y') is 2, the year is truncated to 2 digits; otherwise it is
	             * interpreted as a number. But the original code process 'y', 'yy',
	             * 'yyy' in the same way. and process patterns with 4 or more than 4
	             * 'y' characters in the same way. So I change the codes to meet the
	             * specification. [Richard/GCl]
	             */
	            if (count == 2)
	                ZeroPaddingNumber(buf, value_ren, 2, 2); // clip 1996 to 96
	            else
	                // count = 1 or count > 2
	                ZeroPaddingNumber(buf, value_ren, count, maxIntCount);
	            break;
	        case 2: // 'M' - MONTH
	            if (count == 5)
	                buf.Append(formatData.narrowMonths[value_ren]);
	            else if (count == 4)
	                buf.Append(formatData.months[value_ren]);
	            else if (count == 3)
	                buf.Append(formatData.shortMonths[value_ren]);
	            else
	                ZeroPaddingNumber(buf, value_ren + 1, count, maxIntCount);
	            break;
	        case 4: // 'k' - HOUR_OF_DAY (1..24)
	            if (value_ren == 0)
	                ZeroPaddingNumber(buf,
	                        cal.GetMaximum(IBM.ICU.Util.Calendar.HOUR_OF_DAY) + 1, count,
	                        maxIntCount);
	            else
	                ZeroPaddingNumber(buf, value_ren, count, maxIntCount);
	            break;
	        case 8: // 'S' - FRACTIONAL_SECOND
	            // Fractional seconds left-justify
	        {
	            numberFormat.SetMinimumIntegerDigits(Math.Min(3,count));
	            numberFormat.SetMaximumIntegerDigits(maxIntCount);
	            if (count == 1) {
	                value_ren = (value_ren + 50) / 100;
	            } else if (count == 2) {
	                value_ren = (value_ren + 5) / 10;
	            }
	            ILOG.J2CsMapping.Text.FieldPosition p = new ILOG.J2CsMapping.Text.FieldPosition(-1);
	            numberFormat.Format((long) value_ren, buf, p);
	            if (count > 3) {
	                numberFormat.SetMinimumIntegerDigits(count - 3);
	                numberFormat.Format(0x0L, buf, p);
	            }
	        }
	            break;
	        case 9: // 'E' - DAY_OF_WEEK
	            if (count == 5) {
	                buf.Append(formatData.narrowWeekdays[value_ren]);
	            } else if (count == 4)
	                buf.Append(formatData.weekdays[value_ren]);
	            else
	                // count <= 3, use abbreviated form if exists
	                buf.Append(formatData.shortWeekdays[value_ren]);
	            break;
	        case 14: // 'a' - AM_PM
	            buf.Append(formatData.ampms[value_ren]);
	            break;
	        case 15: // 'h' - HOUR (1..12)
	            if (value_ren == 0)
	                ZeroPaddingNumber(buf, cal.GetLeastMaximum(IBM.ICU.Util.Calendar.HOUR) + 1,
	                        count, maxIntCount);
	            else
	                ZeroPaddingNumber(buf, value_ren, count, maxIntCount);
	            break;
	        case 17: // 'z' - ZONE_OFFSET
	            if (count < 4) {
	                // "z", "zz", "zzz"
	                zoneString = formatData
	                        .GetZoneStringFormat()
	                        .GetSpecificShortString(cal, true /* commonly used only */);
	            } else {
	                zoneString = formatData.GetZoneStringFormat()
	                        .GetSpecificLongString(cal);
	            }
	            if (zoneString != null && zoneString.Length != 0) {
	                buf.Append(zoneString);
	            } else {
	                // Use localized GMT format as fallback
	                AppendGMT(buf, cal);
	            }
	            break;
	        case 23: // 'Z' - TIMEZONE_RFC
	            if (count < 4) {
	                // RFC822 format, must use ASCII digits
	                int val = (cal.Get(IBM.ICU.Util.Calendar.ZONE_OFFSET) + cal
	                        .Get(IBM.ICU.Util.Calendar.DST_OFFSET));
	                char sign = '+';
	                if (val < 0) {
	                    val = -val;
	                    sign = '-';
	                }
	                buf.Append(sign);
	
	                int offsetH = val / millisPerHour;
	                val = val % millisPerHour;
	                int offsetM = val / millisPerMinute;
	                val = val % millisPerMinute;
	                int offsetS = val / millisPerSecond;
	
	                int num = 0, denom = 0;
	                if (offsetS == 0) {
	                    val = offsetH * 100 + offsetM; // HHmm
	                    num = val % 10000;
	                    denom = 1000;
	                } else {
	                    val = offsetH * 10000 + offsetM * 100 + offsetS; // HHmmss
	                    num = val % 1000000;
	                    denom = 100000;
	                }
	                while (denom >= 1) {
	                    char digit = (char) ((num / denom) + '0');
	                    buf.Append(digit);
	                    num = num % denom;
	                    denom /= 10;
	                }
	            } else {
	                // long form, localized GMT pattern
	                AppendGMT(buf, cal);
	            }
	            break;
	        case 24: // 'v' - TIMEZONE_GENERIC
	            if (count == 1) {
	                // "v"
	                zoneString = formatData
	                        .GetZoneStringFormat()
	                        .GetGenericShortString(cal, true /* commonly used only */);
	            } else if (count == 4) {
	                // "vvvv"
	                zoneString = formatData.GetZoneStringFormat()
	                        .GetGenericLongString(cal);
	            }
	            if (zoneString != null && zoneString.Length != 0) {
	                buf.Append(zoneString);
	            } else {
	                // Use localized GMT format as fallback
	                AppendGMT(buf, cal);
	            }
	            break;
	        case 25: // 'c' - STANDALONE DAY
	            if (count == 5)
	                buf.Append(formatData.standaloneNarrowWeekdays[value_ren]);
	            else if (count == 4)
	                buf.Append(formatData.standaloneWeekdays[value_ren]);
	            else if (count == 3)
	                buf.Append(formatData.standaloneShortWeekdays[value_ren]);
	            else
	                ZeroPaddingNumber(buf, value_ren, 1, maxIntCount);
	            break;
	        case 26: // 'L' - STANDALONE MONTH
	            if (count == 5)
	                buf.Append(formatData.standaloneNarrowMonths[value_ren]);
	            else if (count == 4)
	                buf.Append(formatData.standaloneMonths[value_ren]);
	            else if (count == 3)
	                buf.Append(formatData.standaloneShortMonths[value_ren]);
	            else
	                ZeroPaddingNumber(buf, value_ren + 1, count, maxIntCount);
	            break;
	        case 27: // 'Q' - QUARTER
	            if (count >= 4)
	                buf.Append(formatData.quarters[value_ren / 3]);
	            else if (count == 3)
	                buf.Append(formatData.shortQuarters[value_ren / 3]);
	            else
	                ZeroPaddingNumber(buf, (value_ren / 3) + 1, count, maxIntCount);
	            break;
	        case 28: // 'q' - STANDALONE QUARTER
	            if (count >= 4)
	                buf.Append(formatData.standaloneQuarters[value_ren / 3]);
	            else if (count == 3)
	                buf.Append(formatData.standaloneShortQuarters[value_ren / 3]);
	            else
	                ZeroPaddingNumber(buf, (value_ren / 3) + 1, count, maxIntCount);
	            break;
	        case 29: // 'V' - TIMEZONE_SPECIAL
	            if (count == 1) {
	                // "V"
	                zoneString = formatData.GetZoneStringFormat()
	                        .GetSpecificShortString(cal, false /*
	                                                            * ignoring commonly
	                                                            * used
	                                                            */);
	            } else if (count == 4) {
	                // "VVVV"
	                zoneString = formatData.GetZoneStringFormat()
	                        .GetGenericLocationString(cal);
	            }
	            if (zoneString != null && zoneString.Length != 0) {
	                buf.Append(zoneString);
	            } else {
	                // Use localized GMT format as fallback
	                AppendGMT(buf, cal);
	            }
	            break;
	        default:
	            // case 3: // 'd' - DATE
	            // case 5: // 'H' - HOUR_OF_DAY (0..23)
	            // case 6: // 'm' - MINUTE
	            // case 7: // 's' - SECOND
	            // case 10: // 'D' - DAY_OF_YEAR
	            // case 11: // 'F' - DAY_OF_WEEK_IN_MONTH
	            // case 12: // 'w' - WEEK_OF_YEAR
	            // case 13: // 'W' - WEEK_OF_MONTH
	            // case 16: // 'K' - HOUR (0..11)
	            // case 18: // 'Y' - YEAR_WOY
	            // case 19: // 'e' - DOW_LOCAL
	            // case 20: // 'u' - EXTENDED_YEAR
	            // case 21: // 'g' - JULIAN_DAY
	            // case 22: // 'A' - MILLISECONDS_IN_DAY
	
	            ZeroPaddingNumber(buf, value_ren, count, maxIntCount);
	            break;
	        } // switch (patternCharIndex)
	
	        // Set the FieldPosition (for the first occurence only)
	        if (pos.GetBeginIndex() == pos.GetEndIndex()
	                && pos.GetField() == PATTERN_INDEX_TO_DATE_FORMAT_FIELD[patternCharIndex]) {
	            pos.SetBeginIndex(beginOffset);
	            pos.SetEndIndex(beginOffset + buf.Length - bufstart);
	        }
	    }
	
	    /*
	     * PatternItem store parsed date/time field pattern information.
	     */
	    private class PatternItem {
	        internal readonly char type;
	
	        internal readonly int length;
	
	        internal readonly bool isNumeric;
	
	        internal PatternItem(char type_0, int length_1) {
	            this.type = type_0;
	            this.length = length_1;
	            isNumeric = IBM.ICU.Text.SimpleDateFormat.IsNumeric(type_0, length_1);
	        }
	    }
	
	    private static ICUCache PARSED_PATTERN_CACHE = new SimpleCache();
	
	    private Object[] patternItems;
	
	    /*
	     * Returns parsed pattern items. Each item is either String or PatternItem.
	     */
	    private Object[] GetPatternItems() {
	        if (patternItems != null) {
	            return patternItems;
	        }
	
	        patternItems = (Object[]) PARSED_PATTERN_CACHE.Get(pattern);
	        if (patternItems != null) {
	            return patternItems;
	        }
	
	        bool isPrevQuote = false;
	        bool inQuote = false;
	        StringBuilder text = new StringBuilder();
	        char itemType = (char) (0); // 0 for string literal, otherwise date/time pattern
	                           // character
	        int itemLength = 1;
	
	        IList items = new ArrayList();
	
	        for (int i = 0; i < pattern.Length; i++) {
	            char ch = pattern[i];
	            if (ch == '\'') {
	                if (isPrevQuote) {
	                    text.Append('\'');
	                    isPrevQuote = false;
	                } else {
	                    isPrevQuote = true;
	                    if (itemType != 0) {
	                        ILOG.J2CsMapping.Collections.Generics.Collections.Add(items,new SimpleDateFormat.PatternItem (itemType, itemLength));
	                        itemType = ((Char)0);
	                    }
	                }
	                inQuote = !inQuote;
	            } else {
	                isPrevQuote = false;
	                if (inQuote) {
	                    text.Append(ch);
	                } else {
	                    if ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z')) {
	                        // a date/time pattern character
	                        if (ch == itemType) {
	                            itemLength++;
	                        } else {
	                            if (itemType == 0) {
	                                if (text.Length > 0) {
	                                    ILOG.J2CsMapping.Collections.Generics.Collections.Add(items,text.ToString());
	                                    text.Length=0;
	                                }
	                            } else {
	                                ILOG.J2CsMapping.Collections.Generics.Collections.Add(items,new SimpleDateFormat.PatternItem (itemType, itemLength));
	                            }
	                            itemType = ch;
	                            itemLength = 1;
	                        }
	                    } else {
	                        // a string literal
	                        if (itemType != 0) {
	                            ILOG.J2CsMapping.Collections.Generics.Collections.Add(items,new SimpleDateFormat.PatternItem (itemType, itemLength));
	                            itemType = ((Char)0);
	                        }
	                        text.Append(ch);
	                    }
	                }
	            }
	        }
	        // handle last item
	        if (itemType == 0) {
	            if (text.Length > 0) {
	                ILOG.J2CsMapping.Collections.Generics.Collections.Add(items,text.ToString());
	                text.Length=0;
	            }
	        } else {
	            ILOG.J2CsMapping.Collections.Generics.Collections.Add(items,new SimpleDateFormat.PatternItem (itemType, itemLength));
	        }
	
	        patternItems = new Object[items.Count];
	        ILOG.J2CsMapping.Collections.Collections.ToArray(items,patternItems);
	
	        PARSED_PATTERN_CACHE.Put(pattern, patternItems);
	
	        return patternItems;
	    }
	
	    /*
	     * Time zone localized GMT format stuffs
	     */
	    private static readonly String DEFAULT_GMT_PREFIX = "GMT";
	
	    private const int DEFAULT_GMT_PREFIX_LEN = 3;
	
	    private const char PLUS = '+';
	
	    private const char MINUS = '-';
	
	    private const char COLON = ':';

        private void AppendGMT(StringBuilder buf, IBM.ICU.Util.Calendar cal)
        {
	        int offset = cal.Get(IBM.ICU.Util.Calendar.ZONE_OFFSET)
	                + cal.Get(IBM.ICU.Util.Calendar.DST_OFFSET);
	
	        if (IsDefaultGMTFormat()) {
	            FormatGMTDefault(buf, offset);
	        } else {
	            int sign = IBM.ICU.Text.DateFormatSymbols.OFFSET_POSITIVE;
	            if (offset < 0) {
	                offset = -offset;
	                sign = IBM.ICU.Text.DateFormatSymbols.OFFSET_NEGATIVE;
	            }
	            int width = (offset % (60 * 1000) == 0) ? IBM.ICU.Text.DateFormatSymbols.OFFSET_HM
	                    : IBM.ICU.Text.DateFormatSymbols.OFFSET_HMS;
	
	            MessageFormat fmt = GetGMTFormatter(sign, width);
	            fmt.Format(new Object[] { (long)(offset) }, buf, null);
	        }
	    }
	
	    private void FormatGMTDefault(StringBuilder buf, int offset) {
	        buf.Append(DEFAULT_GMT_PREFIX);
	        if (offset >= 0) {
	            buf.Append(PLUS);
	        } else {
	            buf.Append(MINUS);
	            offset = -offset;
	        }
	        offset /= 1000; // now in seconds
	        int sec = offset % 60;
	        offset /= 60;
	        int min = offset % 60;
	        int hour = offset / 60;
	
	        ZeroPaddingNumber(buf, hour, 2, 2);
	        buf.Append(COLON);
	        ZeroPaddingNumber(buf, min, 2, 2);
	        if (sec != 0) {
	            buf.Append(COLON);
	            ZeroPaddingNumber(buf, sec, 2, 2);
	        }
	    }
	
	    private Object ParseGMT(String text, ILOG.J2CsMapping.Text.ParsePosition pos) {
	        if (!IsDefaultGMTFormat()) {
	            int start = pos.GetIndex();
	            String gmtPattern = formatData.gmtFormat;
	
	            // Quick check
	            bool prefixMatch = false;
	            int prefixLen = gmtPattern.IndexOf('{');
	            if (prefixLen > 0
	                    && StringUtil.RegionMatches(text, start, gmtPattern, 0, prefixLen)) {
	                prefixMatch = true;
	            }
	
	            if (prefixMatch) {
	                // Prefix matched
	                MessageFormat fmt;
	                Object[] parsedObjects;
	                int offset;
	
	                // Try negative Hms
	                fmt = GetGMTFormatter(IBM.ICU.Text.DateFormatSymbols.OFFSET_NEGATIVE,
	                        IBM.ICU.Text.DateFormatSymbols.OFFSET_HMS);
	                parsedObjects = fmt.Parse(text, pos);
	                if ((parsedObjects != null)
	                        && (parsedObjects[0]  is  DateTime)) {
	                    offset = (int) (((DateTime) parsedObjects[0]).Ticks/10000);
	                    return ((int)(-offset /* negative */));
	                }
	
	                // Reset ParsePosition
	                pos.SetIndex(start);
	                pos.SetErrorIndex(-1);
	
	                // Try positive Hms
	                fmt = GetGMTFormatter(IBM.ICU.Text.DateFormatSymbols.OFFSET_POSITIVE,
	                        IBM.ICU.Text.DateFormatSymbols.OFFSET_HMS);
	                parsedObjects = fmt.Parse(text, pos);
	                if ((parsedObjects != null)
	                        && (parsedObjects[0]  is  DateTime)) {
	                    offset = (int) (((DateTime) parsedObjects[0]).Ticks/10000);
	                    return ((int)(offset));
	                }
	
	                // Reset ParsePosition
	                pos.SetIndex(start);
	                pos.SetErrorIndex(-1);
	
	                // Try negative Hm
	                fmt = GetGMTFormatter(IBM.ICU.Text.DateFormatSymbols.OFFSET_NEGATIVE,
	                        IBM.ICU.Text.DateFormatSymbols.OFFSET_HM);
	                parsedObjects = fmt.Parse(text, pos);
	                if ((parsedObjects != null)
	                        && (parsedObjects[0]  is  DateTime)) {
	                    offset = (int) (((DateTime) parsedObjects[0]).Ticks/10000);
	                    return ((int)(-offset /* negative */));
	                }
	
	                // Reset ParsePosition
	                pos.SetIndex(start);
	                pos.SetErrorIndex(-1);
	
	                // Try positive Hm
	                fmt = GetGMTFormatter(IBM.ICU.Text.DateFormatSymbols.OFFSET_POSITIVE,
	                        IBM.ICU.Text.DateFormatSymbols.OFFSET_HM);
	                parsedObjects = fmt.Parse(text, pos);
	                if ((parsedObjects != null)
	                        && (parsedObjects[0]  is  DateTime)) {
	                    offset = (int) (((DateTime) parsedObjects[0]).Ticks/10000);
	                    return ((int)(offset));
	                }
	
	                // Reset ParsePosition
	                pos.SetIndex(start);
	                pos.SetErrorIndex(-1);
	            }
	        }
	
	        return ParseGMTDefault(text, pos);
	    }
	
	    private Object ParseGMTDefault(String text, ILOG.J2CsMapping.Text.ParsePosition pos) {
	        int start = pos.GetIndex();
	
	        if (start + DEFAULT_GMT_PREFIX_LEN + 1 >= text.Length) {
	            pos.SetErrorIndex(start);
	            return null;
	        }
	
	        int cur = start;
	        // "GMT"
	        if (!StringUtil.RegionMatches(text, true, start, DEFAULT_GMT_PREFIX, 0,
	                DEFAULT_GMT_PREFIX_LEN)) {
	            pos.SetErrorIndex(start);
	            return null;
	        }
	        cur += DEFAULT_GMT_PREFIX_LEN;
	        // Sign
	        bool negative = false;
	        if (text[cur] == MINUS) {
	            negative = true;
	        } else if (text[cur] != PLUS) {
	            pos.SetErrorIndex(cur);
	            return null;
	        }
	        cur++;
	
	        // Numbers
	        int numLen;
	        pos.SetIndex(cur);
	
	        object n = ParseInt(text, 6, pos, false);
	        numLen = pos.GetIndex() - cur;
	
	        if (n == null || numLen <= 0 || numLen > 6) {
	            pos.SetIndex(start);
	            pos.SetErrorIndex(cur);
	            return null;
	        }
	
	        int numVal = System.Convert.ToInt32(n);
	
	        int hour = 0;
	        int min = 0;
	        int sec = 0;
	
	        if (numLen <= 2) {
	            // H[H][:mm[:ss]]
	            hour = numVal;
	            cur += numLen;
	            if (cur + 2 < text.Length && text[cur] == COLON) {
	                cur++;
	                pos.SetIndex(cur);
	                n = ParseInt(text, 2, pos, false);
	                numLen = pos.GetIndex() - cur;
	                if (n != null && numLen == 2) {
	                    // got minute field
	                    min = System.Convert.ToInt32(n);
	                    cur += numLen;
	                    if (cur + 2 < text.Length && text[cur] == COLON) {
	                        cur++;
	                        pos.SetIndex(cur);
	                        n = ParseInt(text, 2, pos, false);
	                        numLen = pos.GetIndex() - cur;
	                        if (n != null && numLen == 2) {
	                            // got second field
	                            sec = System.Convert.ToInt32(n);
	                        } else {
	                            // reset position
	                            pos.SetIndex(cur - 1);
	                            pos.SetErrorIndex(-1);
	                        }
	                    }
	                } else {
	                    // reset postion
	                    pos.SetIndex(cur - 1);
	                    pos.SetErrorIndex(-1);
	                }
	            }
	        } else if (numLen == 3 || numLen == 4) {
	            // Hmm or HHmm
	            hour = numVal / 100;
	            min = numVal % 100;
	        } else { // numLen == 5 || numLen == 6
	            // Hmmss or HHmmss
	            hour = numVal / 10000;
	            min = (numVal % 10000) / 100;
	            sec = numVal % 100;
	        }
	
	        int offset = ((hour * 60 + min) * 60 + sec) * 1000;
	        if (negative) {
	            offset = -offset;
	        }
	        return ((int)(offset));
	    }
	
	    private WeakReference[] gmtfmtCache;
	
	    private MessageFormat GetGMTFormatter(int sign, int width) {
            IBM.ICU.Text.MessageFormat fmt = null;
	        if (gmtfmtCache == null) {
	            gmtfmtCache = new WeakReference[4];
	        }
	        int cacheIdx = sign * 2 + width;
	        if (gmtfmtCache[cacheIdx] != null) {
                fmt = (IBM.ICU.Text.MessageFormat)gmtfmtCache[cacheIdx].Target;
	        }
	        if (fmt == null) {
	            fmt = new IBM.ICU.Text.MessageFormat(formatData.gmtFormat);
	            SimpleDateFormat sdf = (SimpleDateFormat) this.Clone();
	            sdf.SetTimeZone(IBM.ICU.Util.TimeZone.GetTimeZone("Etc/UTC"));
	            sdf.ApplyPattern(formatData.GetGmtHourFormat(sign, width));
	            fmt.SetFormat(0, sdf);
	            gmtfmtCache[cacheIdx] = new WeakReference(fmt);
	        }
	        return fmt;
	    }
	
	    private bool IsDefaultGMTFormat() {
	        // GMT pattern
	        if (!IBM.ICU.Text.DateFormatSymbols.DEFAULT_GMT_PATTERN.Equals(formatData.GetGmtFormat())) {
	            return false;
	        }
	        // GMT offset hour patters
	        bool res = true;
	        for (int sign = 0; sign < 2 && res; sign++) {
	            for (int width = 0; width < 2; width++) {
	                if (!IBM.ICU.Text.DateFormatSymbols.DEFAULT_GMT_HOUR_PATTERNS[sign][width]
	                        .Equals(formatData.GetGmtHourFormat(sign, width))) {
	                    res = false;
	                    break;
	                }
	            }
	        }
	        return res;
	    }
	
	    /*
	     * Internal method. Returns null if the value of an array is empty, or if
	     * the index is out of bounds
	     */
	    /*
	     * private String getZoneArrayValue(String[] zs, int ix) { if (ix >= 0 && ix
	     * < zs.length) { String result = zs[ix]; if (result != null &&
	     * result.length() != 0) { return result; } } return null; }
	     */
	
	    /// <exclude/>
	    /// <summary>
	    /// Internal high-speed method. Reuses a StringBuffer for results instead of
	    /// creating a String on the heap for each call.
	    /// </summary>
	    ///
	    protected internal void ZeroPaddingNumber(StringBuilder buf, int value_ren,
	            int minDigits, int maxDigits) {
	        if (useLocalZeroPaddingNumberFormat) {
	            FastZeroPaddingNumber(buf, value_ren, minDigits, maxDigits);
	        } else {
	            numberFormat.SetMinimumIntegerDigits(minDigits);
	            numberFormat.SetMaximumIntegerDigits(maxDigits);
	            numberFormat.Format(value_ren, buf, new ILOG.J2CsMapping.Text.FieldPosition(-1));
	        }
	    }
	
	    /// <summary>
	    /// Overrides superclass method
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public override void SetNumberFormat(NumberFormat newNumberFormat) {
	        // Override this method to update local zero padding number formatter
	        base.SetNumberFormat(newNumberFormat);
	        InitLocalZeroPaddingNumberFormat();
	    }
	
	    private void InitLocalZeroPaddingNumberFormat() {
	        if (numberFormat  is  DecimalFormat) {
	            zeroDigit = ((DecimalFormat) numberFormat)
	                    .GetDecimalFormatSymbols().GetZeroDigit();
	            useLocalZeroPaddingNumberFormat = true;
	        } else if (numberFormat  is  DateNumberFormat) {
	            zeroDigit = ((DateNumberFormat) numberFormat).GetZeroDigit();
	            useLocalZeroPaddingNumberFormat = true;
	        } else {
	            useLocalZeroPaddingNumberFormat = false;
	        }
	
	        if (useLocalZeroPaddingNumberFormat) {
	            decimalBuf = new char[10]; // sufficient for int numbers
	        }
	    }
	
	    // If true, use local version of zero padding number format
	    private bool useLocalZeroPaddingNumberFormat;
	
	    private char zeroDigit;
	
	    private char[] decimalBuf;
	
	    /*
	     * Lightweight zero padding integer number format function.
	     * 
	     * Note: This implementation is almost equivalent to format method in
	     * DateNumberFormat. In the method zeroPaddingNumber above should be able to
	     * use the one in DateNumberFormat, but, it does not help IBM J9's JIT to
	     * optimize the performance much. In simple repeative date format test case,
	     * having local implementation is ~10% faster than using one in
	     * DateNumberFormat on IBM J9 VM. On Sun Hotspot VM, I do not see such
	     * difference.
	     * 
	     * -Yoshito
	     */
	    private void FastZeroPaddingNumber(StringBuilder buf, int value_ren,
	            int minDigits, int maxDigits) {
	        int limit = (decimalBuf.Length < maxDigits) ? decimalBuf.Length
	                : maxDigits;
	        int index = limit - 1;
	        while (true) {
	            decimalBuf[index] = (char) ((value_ren % 10) + zeroDigit);
	            value_ren /= 10;
	            if (index == 0 || value_ren == 0) {
	                break;
	            }
	            index--;
	        }
	        int padding = minDigits - (limit - index);
	        for (; padding > 0; padding--) {
	            decimalBuf[--index] = zeroDigit;
	        }
	        int length_0 = limit - index;
	        buf.Append(decimalBuf, index, length_0);
	    }
	
	    /// <summary>
	    /// Formats a number with the specified minimum and maximum number of digits.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    protected internal String ZeroPaddingNumber(long value_ren, int minDigits, int maxDigits) {
	        numberFormat.SetMinimumIntegerDigits(minDigits);
	        numberFormat.SetMaximumIntegerDigits(maxDigits);
	        return numberFormat.Format(value_ren);
	    }
	
	    /// <summary>
	    /// Format characters that indicate numeric fields. The character at index 0
	    /// is treated specially.
	    /// </summary>
	    ///
	    private static readonly String NUMERIC_FORMAT_CHARS = "MyudhHmsSDFwWkK";
	
	    /// <summary>
	    /// Return true if the given format character, occuring count times,
	    /// represents a numeric field.
	    /// </summary>
	    ///
	    private static bool IsNumeric(char formatChar, int count) {
	        int i = NUMERIC_FORMAT_CHARS.IndexOf(formatChar);
	        return (i > 0 || (i == 0 && count < 3));
	    }
	
	    /// <summary>
	    /// Overrides DateFormat
	    /// </summary>
	    ///
	    /// <seealso cref="T:IBM.ICU.Text.DateFormat"/>
	    /// @stable ICU 2.0
        public override void Parse(String text, IBM.ICU.Util.Calendar cal, ILOG.J2CsMapping.Text.ParsePosition parsePos)
        {
	        int pos = parsePos.GetIndex();
	        int start = pos;
	
	        // Reset tztype
	        tztype = TZTYPE_UNK;
	        bool[] ambiguousYear = { false };
	
	        // item index for the first numeric field within a contiguous numeric
	        // run
	        int numericFieldStart = -1;
	        // item length for the first numeric field within a contiguous numeric
	        // run
	        int numericFieldLength = 0;
	        // start index of numeric text run in the input text
	        int numericStartPos = 0;
	
	        Object[] items = GetPatternItems();
	        int i = 0;
	        while (i < items.Length) {
	            if (items[i]  is  SimpleDateFormat.PatternItem ) {
	                // Handle pattern field
	                SimpleDateFormat.PatternItem  field = (SimpleDateFormat.PatternItem ) items[i];
	                if (field.isNumeric) {
	                    // Handle fields within a run of abutting numeric fields.
	                    // Take
	                    // the pattern "HHmmss" as an example. We will try to parse
	                    // 2/2/2 characters of the input text, then if that fails,
	                    // 1/2/2. We only adjust the width of the leftmost field;
	                    // the
	                    // others remain fixed. This allows "123456" => 12:34:56,
	                    // but
	                    // "12345" => 1:23:45. Likewise, for the pattern "yyyyMMdd"
	                    // we
	                    // try 4/2/2, 3/2/2, 2/2/2, and finally 1/2/2.
	                    if (numericFieldStart == -1) {
	                        // check if this field is followed by abutting another
	                        // numeric field
	                        if ((i + 1) < items.Length
	                                && (items[i + 1]  is  SimpleDateFormat.PatternItem )
	                                && ((SimpleDateFormat.PatternItem ) items[i + 1]).isNumeric) {
	                            // record the first numeric field within a numeric
	                            // text run
	                            numericFieldStart = i;
	                            numericFieldLength = field.length;
	                            numericStartPos = pos;
	                        }
	                    }
	                }
	                if (numericFieldStart != -1) {
	                    // Handle a numeric field within abutting numeric fields
	                    int len = field.length;
	                    if (numericFieldStart == i) {
	                        len = numericFieldLength;
	                    }
	
	                    // Parse a numeric field
	                    pos = SubParse(text, pos, field.type, len, true, false,
	                            ambiguousYear, cal);
	
	                    if (pos < 0) {
	                        // If the parse fails anywhere in the numeric run, back
	                        // up to the
	                        // start of the run and use shorter pattern length for
	                        // the first
	                        // numeric field.
	                        --numericFieldLength;
	                        if (numericFieldLength == 0) {
	                            // can not make shorter any more
	                            parsePos.SetIndex(start);
	                            parsePos.SetErrorIndex(pos);
	                            return;
	                        }
	                        i = numericFieldStart;
	                        pos = numericStartPos;
	                        continue;
	                    }
	
	                } else {
	                    // Handle a non-numeric field or a non-abutting numeric
	                    // field
	                    numericFieldStart = -1;
	
	                    int s = pos;
	                    pos = SubParse(text, pos, field.type, field.length, false,
	                            true, ambiguousYear, cal);
	                    if (pos < 0) {
	                        parsePos.SetIndex(start);
	                        parsePos.SetErrorIndex(s);
	                        return;
	                    }
	                }
	            } else {
	                // Handle literal pattern text literal
	                numericFieldStart = -1;
	
	                String patl = (String) items[i];
	                int plen = patl.Length;
	                int tlen = text.Length;
	                int idx = 0;
	                while (idx < plen && pos < tlen) {
	                    char pch = patl[idx];
	                    char ich = text[pos];
	                    if (IBM.ICU.Impl.UCharacterProperty.IsRuleWhiteSpace(pch)
	                            && IBM.ICU.Impl.UCharacterProperty.IsRuleWhiteSpace(ich)) {
	                        // White space characters found in both patten and
	                        // input.
	                        // Skip contiguous white spaces.
	                        while ((idx + 1) < plen
	                                && IBM.ICU.Impl.UCharacterProperty.IsRuleWhiteSpace(patl[idx + 1])) {
	                            ++idx;
	                        }
	                        while ((pos + 1) < tlen
	                                && IBM.ICU.Impl.UCharacterProperty.IsRuleWhiteSpace(text[pos + 1])) {
	                            ++pos;
	                        }
	                    } else if (pch != ich) {
	                        break;
	                    }
	                    ++idx;
	                    ++pos;
	                }
	                if (idx != plen) {
	                    // Set the position of mismatch
	                    parsePos.SetIndex(start);
	                    parsePos.SetErrorIndex(pos);
	                    return;
	                }
	            }
	            ++i;
	        }
	
	        // At this point the fields of Calendar have been set. Calendar
	        // will fill in default values for missing fields when the time
	        // is computed.
	
	        parsePos.SetIndex(pos);
	
	        // This part is a problem: When we call parsedDate.after, we compute the
	        // time.
	        // Take the date April 3 2004 at 2:30 am. When this is first set up, the
	        // year
	        // will be wrong if we're parsing a 2-digit year pattern. It will be
	        // 1904.
	        // April 3 1904 is a Sunday (unlike 2004) so it is the DST onset day.
	        // 2:30 am
	        // is therefore an "impossible" time, since the time goes from 1:59 to
	        // 3:00 am
	        // on that day. It is therefore parsed out to fields as 3:30 am. Then we
	        // add 100 years, and get April 3 2004 at 3:30 am. Note that April 3
	        // 2004 is
	        // a Saturday, so it can have a 2:30 am -- and it should. [LIU]
	        /*
	         * Date parsedDate = cal.getTime(); if( ambiguousYear[0] &&
	         * !parsedDate.after(getDefaultCenturyStart()) ) {
	         * cal.add(Calendar.YEAR, 100); parsedDate = cal.getTime(); }
	         */
	        // Because of the above condition, save off the fields in case we need
	        // to readjust.
	        // The procedure we use here is not particularly efficient, but there is
	        // no other
	        // way to do this given the API restrictions present in Calendar. We
	        // minimize
	        // inefficiency by only performing this computation when it might apply,
	        // that is,
	        // when the two-digit year is equal to the start year, and thus might
	        // fall at the
	        // front or the back of the default century. This only works because we
	        // adjust
	        // the year correctly to start with in other cases -- see subParse().
	        try {
	            if (ambiguousYear[0] || tztype != TZTYPE_UNK) {
	                // We need a copy of the fields, and we need to avoid triggering
	                // a call to
	                // complete(), which will recalculate the fields. Since we can't
	                // access
	                // the fields[] array in Calendar, we clone the entire object.
	                // This will
	                // stop working if Calendar.clone() is ever rewritten to call
	                // complete().
	                IBM.ICU.Util.Calendar copy;
	                if (ambiguousYear[0]) { // the two-digit year == the default
	                                        // start year
	                    copy = (IBM.ICU.Util.Calendar) cal.Clone();
	                    DateTime parsedDate = copy.GetTime();
	                    if (ILOG.J2CsMapping.Util.DateUtil.Before(parsedDate,GetDefaultCenturyStart())) {
	                        // We can't use add here because that does a complete()
	                        // first.
	                        cal.Set(IBM.ICU.Util.Calendar.YEAR,
	                                GetDefaultCenturyStartYear() + 100);
	                    }
	                }
	                if (tztype != TZTYPE_UNK) {
	                    copy = (IBM.ICU.Util.Calendar) cal.Clone();
	                    IBM.ICU.Util.TimeZone tz = copy.GetTimeZone();
	                    BasicTimeZone btz = null;
	                    if (tz  is  BasicTimeZone) {
	                        btz = (BasicTimeZone) tz;
	                    }
	
	                    // Get local millis
	                    copy.Set(IBM.ICU.Util.Calendar.ZONE_OFFSET, 0);
	                    copy.Set(IBM.ICU.Util.Calendar.DST_OFFSET, 0);
	                    long localMillis = copy.GetTimeInMillis();
	
	                    // Make sure parsed time zone type (Standard or Daylight)
	                    // matches the rule used by the parsed time zone.
	                    int[] offsets = new int[2];
	                    if (btz != null) {
	                        if (tztype == TZTYPE_STD) {
	                            btz.GetOffsetFromLocal(localMillis,
	                                    IBM.ICU.Util.BasicTimeZone.LOCAL_STD,
	                                    IBM.ICU.Util.BasicTimeZone.LOCAL_STD, offsets);
	                        } else {
	                            btz.GetOffsetFromLocal(localMillis,
	                                    IBM.ICU.Util.BasicTimeZone.LOCAL_DST,
	                                    IBM.ICU.Util.BasicTimeZone.LOCAL_DST, offsets);
	                        }
	                    } else {
	                        // No good way to resolve ambiguous time at transition,
	                        // but following code work in most case.
	                        tz.GetOffset(localMillis, true, offsets);
	                    }
	
	                    // Now, compare the results with parsed type, either
	                    // standard or daylight saving time
	                    int resolvedSavings = offsets[1];
	                    if (tztype == TZTYPE_STD) {
	                        if (offsets[1] != 0) {
	                            // Override DST_OFFSET = 0 in the result calendar
	                            resolvedSavings = 0;
	                        }
	                    } else { // tztype == TZTYPE_DST
	                        if (offsets[1] == 0) {
	                            if (btz != null) {
	                                long time = localMillis + offsets[0];
	                                // We use the nearest daylight saving time rule.
	                                TimeZoneTransition beforeTrs, afterTrs;
	                                long beforeT = time, afterT = time;
	                                int beforeSav = 0, afterSav = 0;
	
	                                // Search for DST rule before or on the time
	                                while (true) {
	                                    beforeTrs = btz.GetPreviousTransition(
	                                            beforeT, true);
	                                    if (beforeTrs == null) {
	                                        break;
	                                    }
	                                    beforeT = beforeTrs.GetTime() - 1;
	                                    beforeSav = beforeTrs.GetFrom()
	                                            .GetDSTSavings();
	                                    if (beforeSav != 0) {
	                                        break;
	                                    }
	                                }
	
	                                // Search for DST rule after the time
	                                while (true) {
	                                    afterTrs = btz.GetNextTransition(afterT,
	                                            false);
	                                    if (afterTrs == null) {
	                                        break;
	                                    }
	                                    afterT = afterTrs.GetTime();
	                                    afterSav = afterTrs.GetTo().GetDSTSavings();
	                                    if (afterSav != 0) {
	                                        break;
	                                    }
	                                }
	
	                                if (beforeTrs != null && afterTrs != null) {
	                                    if (time - beforeT > afterT - time) {
	                                        resolvedSavings = afterSav;
	                                    } else {
	                                        resolvedSavings = beforeSav;
	                                    }
	                                } else if (beforeTrs != null && beforeSav != 0) {
	                                    resolvedSavings = beforeSav;
	                                } else if (afterTrs != null && afterSav != 0) {
	                                    resolvedSavings = afterSav;
	                                } else {
	                                    resolvedSavings = btz.GetDSTSavings();
	                                }
	                            } else {
	                                resolvedSavings = tz.GetDSTSavings();
	                            }
	                            if (resolvedSavings == 0) {
	                                // Final fallback
	                                resolvedSavings = millisPerHour;
	                            }
	                        }
	                    }
	                    cal.Set(IBM.ICU.Util.Calendar.ZONE_OFFSET, offsets[0]);
	                    cal.Set(IBM.ICU.Util.Calendar.DST_OFFSET, resolvedSavings);
	                }
	            }
	        }
	        // An IllegalArgumentException will be thrown by Calendar.getTime()
	        // if any fields are out of range, e.g., MONTH == 17.
	        catch (ArgumentException e) {
	            parsePos.SetErrorIndex(pos);
	            parsePos.SetIndex(start);
	        }
	    }
	
	    /// <summary>
	    /// Attempt to match the text at a given position against an array of
	    /// strings. Since multiple strings in the array may match (for example, if
	    /// the array contains "a", "ab", and "abc", all will match the input string
	    /// "abcd") the longest match is returned. As a side effect, the given field
	    /// of <c>cal</c> is set to the index of the best match, if there is
	    /// one.
	    /// </summary>
	    ///
	    /// <param name="text">the time text being parsed.</param>
	    /// <param name="start">where to start parsing.</param>
	    /// <param name="field">the date field being parsed.</param>
	    /// <param name="data">the string array to parsed.</param>
	    /// <returns>the new start position if matching succeeded; a negative number
	    /// indicating matching failure, otherwise. As a side effect, sets
	    /// the <c>cal</c> field <c>field</c> to the index of the
	    /// best match, if matching succeeded.</returns>
	    /// @stable ICU 2.0
	    protected internal int MatchString(String text, int start, int field, String[] data,
                IBM.ICU.Util.Calendar cal)
        {
	        int i = 0;
	        int count = data.Length;
	
	        if (field == IBM.ICU.Util.Calendar.DAY_OF_WEEK)
	            i = 1;
	
	        // There may be multiple strings in the data[] array which begin with
	        // the same prefix (e.g., Cerven and Cervenec (June and July) in Czech).
	        // We keep track of the longest match, and return that. Note that this
	        // unfortunately requires us to test all array elements.
	        int bestMatchLength = 0, bestMatch = -1;
	        for (; i < count; ++i) {
	            int length_0 = data[i].Length;
	            // Always compare if we have no match yet; otherwise only compare
	            // against potentially better matches (longer strings).
	            if (length_0 > bestMatchLength
	                    && StringUtil.RegionMatches(text, true, start, data[i], 0, length_0)) {
	                bestMatch = i;
	                bestMatchLength = length_0;
	            }
	        }
	        if (bestMatch >= 0) {
	            cal.Set(field, bestMatch);
	            return start + bestMatchLength;
	        }
	        return -start;
	    }
	
	    /// <summary>
	    /// Attempt to match the text at a given position against an array of quarter
	    /// strings. Since multiple strings in the array may match (for example, if
	    /// the array contains "a", "ab", and "abc", all will match the input string
	    /// "abcd") the longest match is returned. As a side effect, the given field
	    /// of <c>cal</c> is set to the index of the best match, if there is
	    /// one.
	    /// </summary>
	    ///
	    /// <param name="text">the time text being parsed.</param>
	    /// <param name="start">where to start parsing.</param>
	    /// <param name="field">the date field being parsed.</param>
	    /// <param name="data">the string array to parsed.</param>
	    /// <returns>the new start position if matching succeeded; a negative number
	    /// indicating matching failure, otherwise. As a side effect, sets
	    /// the <c>cal</c> field <c>field</c> to the index of the
	    /// best match, if matching succeeded.</returns>
	    /// @stable ICU 2.0
	    protected internal int MatchQuarterString(String text, int start, int field,
                String[] data, IBM.ICU.Util.Calendar cal)
        {
	        int i = 0;
	        int count = data.Length;
	
	        // There may be multiple strings in the data[] array which begin with
	        // the same prefix (e.g., Cerven and Cervenec (June and July) in Czech).
	        // We keep track of the longest match, and return that. Note that this
	        // unfortunately requires us to test all array elements.
	        int bestMatchLength = 0, bestMatch = -1;
	        for (; i < count; ++i) {
	            int length_0 = data[i].Length;
	            // Always compare if we have no match yet; otherwise only compare
	            // against potentially better matches (longer strings).
	            if (length_0 > bestMatchLength
	                    && StringUtil.RegionMatches(text, true, start, data[i], 0, length_0)) {
	                bestMatch = i;
	                bestMatchLength = length_0;
	            }
	        }
	
	        if (bestMatch >= 0) {
	            cal.Set(field, bestMatch * 3);
	            return start + bestMatchLength;
	        }
	
	        return -start;
	    }
	
	    /// <summary>
	    /// Protected method that converts one field of the input string into a
	    /// numeric field value in <c>cal</c>. Returns -start (for
	    /// ParsePosition) if failed. Subclasses may override this method to modify
	    /// or add parsing capabilities.
	    /// </summary>
	    ///
	    /// <param name="text">the time text to be parsed.</param>
	    /// <param name="start">where to start parsing.</param>
	    /// <param name="ch">the pattern character for the date field text to be parsed.</param>
	    /// <param name="count">the count of a pattern character.</param>
	    /// <param name="obeyCount">if true, then the next field directly abuts this one, and weshould use the count to know when to stop parsing.</param>
	    /// <param name="ambiguousYear">return parameter; upon return, if ambiguousYear[0] is true,then a two-digit year was parsed and may need to bereadjusted.</param>
	    /// <returns>the new start position if matching succeeded; a negative number
	    /// indicating matching failure, otherwise. As a side effect, set the
	    /// appropriate field of <c>cal</c> with the parsed value.</returns>
	    /// @stable ICU 2.0
	    protected internal virtual int SubParse(String text, int start, char ch, int count,
	            bool obeyCount, bool allowNegative, bool[] ambiguousYear,
                IBM.ICU.Util.Calendar cal)
        {
	        object number = null;
	        int value_ren = 0;
	        int i;
	        ILOG.J2CsMapping.Text.ParsePosition pos = new ILOG.J2CsMapping.Text.ParsePosition(0);
	        // int patternCharIndex = DateFormatSymbols.patternChars.indexOf(ch);c
	        int patternCharIndex = -1;
	        if ('A' <= ch && ch <= 'z') {
	            patternCharIndex = PATTERN_CHAR_TO_INDEX[(int) ch
	                    - PATTERN_CHAR_BASE];
	        }
	
	        if (patternCharIndex == -1) {
	            return -start;
	        }
	
	        int field = PATTERN_INDEX_TO_CALENDAR_FIELD[patternCharIndex];
	
	        // If there are any spaces here, skip over them. If we hit the end
	        // of the string, then fail.
	        for (;;) {
	            if (start >= text.Length) {
	                return -start;
	            }
	            int c = IBM.ICU.Text.UTF16.CharAt(text, start);
	            if (!IBM.ICU.Lang.UCharacter.IsUWhiteSpace(c)) {
	                break;
	            }
	            start += IBM.ICU.Text.UTF16.GetCharCount(c);
	        }
	        pos.SetIndex(start);
	
	        // We handle a few special cases here where we need to parse
	        // a number value. We handle further, more generic cases below. We need
	        // to handle some of them here because some fields require extra
	        // processing on
	        // the parsed value.
	        if (patternCharIndex == 4 /* HOUR_OF_DAY1_FIELD */
	                || patternCharIndex == 15 /* HOUR1_FIELD */
	                || (patternCharIndex == 2 /* MONTH_FIELD */&& count <= 2)
	                || patternCharIndex == 1 || patternCharIndex == 8) {
	            // It would be good to unify this with the obeyCount logic below,
	            // but that's going to be difficult.
	            if (obeyCount) {
	                if ((start + count) > text.Length)
	                    return -start;
	                number = ParseInt(text, count, pos, allowNegative);
	            } else
	                number = ParseInt(text, pos, allowNegative);
	            if (number == null)
	                return -start;
	            value_ren = System.Convert.ToInt32(number);
	        }
	
	        switch (patternCharIndex) {
	        case 0: // 'G' - ERA
	            if (count == 4) {
	                return MatchString(text, start, IBM.ICU.Util.Calendar.ERA,
	                        formatData.eraNames, cal);
	            } else {
	                return MatchString(text, start, IBM.ICU.Util.Calendar.ERA, formatData.eras,
	                        cal);
	            }
	            break;
	        case 1: // 'y' - YEAR
	            // If there are 3 or more YEAR pattern characters, this indicates
	            // that the year value is to be treated literally, without any
	            // two-digit year adjustments (e.g., from "01" to 2001). Otherwise
	            // we made adjustments to place the 2-digit year in the proper
	            // century, for parsed strings from "00" to "99". Any other string
	            // is treated literally: "2250", "-1", "1", "002".
	            /*
	             * 'yy' is the only special case, 'y' is interpreted as number.
	             * [Richard/GCL]
	             */
	            if (count == 2 && (pos.GetIndex() - start) == 2
	                    && Char.IsDigit(text[start])
	                    && Char.IsDigit(text[start + 1])) {
	                // Assume for example that the defaultCenturyStart is 6/18/1903.
	                // This means that two-digit years will be forced into the range
	                // 6/18/1903 to 6/17/2003. As a result, years 00, 01, and 02
	                // correspond to 2000, 2001, and 2002. Years 04, 05, etc.
	                // correspond
	                // to 1904, 1905, etc. If the year is 03, then it is 2003 if the
	                // other fields specify a date before 6/18, or 1903 if they
	                // specify a
	                // date afterwards. As a result, 03 is an ambiguous year. All
	                // other
	                // two-digit years are unambiguous.
	                int ambiguousTwoDigitYear = GetDefaultCenturyStartYear() % 100;
	                ambiguousYear[0] = value_ren == ambiguousTwoDigitYear;
	                value_ren += (GetDefaultCenturyStartYear() / 100) * 100
	                        + ((value_ren < ambiguousTwoDigitYear) ? 100 : 0);
	            }
	            cal.Set(IBM.ICU.Util.Calendar.YEAR, value_ren);
	            return pos.GetIndex();
	        case 2: // 'M' - MONTH
	            if (count <= 2) // i.e., M or MM.
	            {
	                // Don't want to parse the month if it is a string
	                // while pattern uses numeric style: M or MM.
	                // [We computed 'value' above.]
	                cal.Set(IBM.ICU.Util.Calendar.MONTH, value_ren - 1);
	                return pos.GetIndex();
	            } else {
	                // count >= 3 // i.e., MMM or MMMM
	                // Want to be able to parse both short and long forms.
	                // Try count == 4 first:
	                int newStart = MatchString(text, start, IBM.ICU.Util.Calendar.MONTH,
	                        formatData.months, cal);
	                if (newStart > 0) {
	                    return newStart;
	                } else { // count == 4 failed, now try count == 3
	                    return MatchString(text, start, IBM.ICU.Util.Calendar.MONTH,
	                            formatData.shortMonths, cal);
	                }
	            }
	            break;
	        case 26: // 'L' - STAND_ALONE_MONTH
	            if (count <= 2) // i.e., M or MM.
	            {
	                // Don't want to parse the month if it is a string
	                // while pattern uses numeric style: M or MM.
	                // [We computed 'value' above.]
	                cal.Set(IBM.ICU.Util.Calendar.MONTH, value_ren - 1);
	                return pos.GetIndex();
	            } else {
	                // count >= 3 // i.e., MMM or MMMM
	                // Want to be able to parse both short and long forms.
	                // Try count == 4 first:
	                int newStart_0 = MatchString(text, start, IBM.ICU.Util.Calendar.MONTH,
	                        formatData.standaloneMonths, cal);
	                if (newStart_0 > 0) {
	                    return newStart_0;
	                } else { // count == 4 failed, now try count == 3
	                    return MatchString(text, start, IBM.ICU.Util.Calendar.MONTH,
	                            formatData.standaloneShortMonths, cal);
	                }
	            }
	            break;
	        case 4: // 'k' - HOUR_OF_DAY (1..24)
	            // [We computed 'value' above.]
	            if (value_ren == cal.GetMaximum(IBM.ICU.Util.Calendar.HOUR_OF_DAY) + 1)
	                value_ren = 0;
	            cal.Set(IBM.ICU.Util.Calendar.HOUR_OF_DAY, value_ren);
	            return pos.GetIndex();
	        case 8: // 'S' - FRACTIONAL_SECOND
	            // Fractional seconds left-justify
	            i = pos.GetIndex() - start;
	            if (i < 3) {
	                while (i < 3) {
	                    value_ren *= 10;
	                    i++;
	                }
	            } else {
	                int a = 1;
	                while (i > 3) {
	                    a *= 10;
	                    i--;
	                }
	                value_ren = (value_ren + (a >> 1)) / a;
	            }
	            cal.Set(IBM.ICU.Util.Calendar.MILLISECOND, value_ren);
	            return pos.GetIndex();
	        case 9: { // 'E' - DAY_OF_WEEK
	            // Want to be able to parse both short and long forms.
	            // Try count == 4 (EEEE) first:
	            int newStart_1 = MatchString(text, start, IBM.ICU.Util.Calendar.DAY_OF_WEEK,
	                    formatData.weekdays, cal);
	            if (newStart_1 > 0) {
	                return newStart_1;
	            } else { // EEEE failed, now try EEE
	                return MatchString(text, start, IBM.ICU.Util.Calendar.DAY_OF_WEEK,
	                        formatData.shortWeekdays, cal);
	            }
	        }
	            break;
	        case 25: { // 'c' - STAND_ALONE_DAY_OF_WEEK
	            // Want to be able to parse both short and long forms.
	            // Try count == 4 (cccc) first:
	            int newStart_2 = MatchString(text, start, IBM.ICU.Util.Calendar.DAY_OF_WEEK,
	                    formatData.standaloneWeekdays, cal);
	            if (newStart_2 > 0) {
	                return newStart_2;
	            } else { // cccc failed, now try ccc
	                return MatchString(text, start, IBM.ICU.Util.Calendar.DAY_OF_WEEK,
	                        formatData.standaloneShortWeekdays, cal);
	            }
	        }
	            break;
	        case 14: // 'a' - AM_PM
	            return MatchString(text, start, IBM.ICU.Util.Calendar.AM_PM, formatData.ampms,
	                    cal);
	        case 15: // 'h' - HOUR (1..12)
	            // [We computed 'value' above.]
	            if (value_ren == cal.GetLeastMaximum(IBM.ICU.Util.Calendar.HOUR) + 1)
	                value_ren = 0;
	            cal.Set(IBM.ICU.Util.Calendar.HOUR, value_ren);
	            return pos.GetIndex();
	        case 17: // 'z' - ZONE_OFFSET
	        case 23: // 'Z' - TIMEZONE_RFC
	        case 24: // 'v' - TIMEZONE_GENERIC
	        case 29: // 'V' - TIMEZONE_SPECIAL
	        {
	            IBM.ICU.Util.TimeZone tz = null;
	            int offset = 0;
	            bool parsed = false;
	
	            // Step 1
	            // Check if this is a long GMT offset string (either localized or
	            // default)
                Int32 gmtoff = 0;
                Object tmp = ParseGMT(text, pos);
	            if (tmp != null) {
                    gmtoff = (int)tmp;
	                offset = gmtoff;
	                parsed = true;
	            }
	
	            if (!parsed) {
	                // Step 2
	                // Check if this is an RFC822 time zone offset.
	                // ICU supports the standard RFC822 format [+|-]HHmm
	                // and its extended form [+|-]HHmmSS.
	
	                do {
	                    int sign = 0;
	                    char signChar = text[start];
	                    if (signChar == '+') {
	                        sign = 1;
	                    } else if (signChar == '-') {
	                        sign = -1;
	                    } else {
	                        // Not an RFC822 offset string
	                        break;
	                    }
	
	                    // Parse digits
	                    int orgPos = start + 1;
	                    pos.SetIndex(orgPos);
	                    number = ParseInt(text, 6, pos, false);
	                    int numLen = pos.GetIndex() - orgPos;
	                    if (numLen <= 0) {
	                        break;
	                    }
	
	                    // Followings are possible format (excluding sign char)
	                    // HHmmSS
	                    // HmmSS
	                    // HHmm
	                    // Hmm
	                    // HH
	                    // H
	                    int val = System.Convert.ToInt32(number);
	                    int hour = 0, min = 0, sec = 0;
	                    switch (numLen) {
	                    case 1: // H
	                    case 2: // HH
	                        hour = val;
	                        break;
	                    case 3: // Hmm
	                    case 4: // HHmm
	                        hour = val / 100;
	                        min = val % 100;
	                        break;
	                    case 5: // Hmmss
	                    case 6: // HHmmss
	                        hour = val / 10000;
	                        min = (val % 10000) / 100;
	                        sec = val % 100;
	                        break;
	                    }
	                    if (hour > 23 || min > 59 || sec > 59) {
	                        // Invalid value range
	                        break;
	                    }
	                    offset = (((hour * 60) + min) * 60 + sec) * 1000 * sign;
	                    parsed = true;
	                } while (false);
	
	                if (!parsed) {
	                    // Failed to parse. Reset the position.
	                    pos.SetIndex(start);
	                }
	            }
	
	            if (parsed) {
	                // offset was successfully parsed as either a long GMT string or
	                // RFC822 zone offset
	                // string. Create normalized zone ID for the offset.
	                tz = IBM.ICU.Impl.ZoneMeta.GetCustomTimeZone(offset);
	                cal.SetTimeZone(tz);
	                return pos.GetIndex();
	            }
	
	            // Step 3
	            // At this point, check for named time zones by looking through
	            // the locale data from the DateFormatZoneData strings.
	            // Want to be able to parse both short and long forms.
	            // optimize for calendar's current time zone
	            IBM.ICU.Impl.ZoneStringFormat.ZoneStringInfo  zsinfo = null;
	            switch (patternCharIndex) {
	            case 17: // 'z' - ZONE_OFFSET
	                if (count < 4) {
	                    zsinfo = formatData.GetZoneStringFormat()
	                            .FindSpecificShort(text, start);
	                } else {
	                    zsinfo = formatData.GetZoneStringFormat().FindSpecificLong(
	                            text, start);
	                }
	                break;
	            case 24: // 'v' - TIMEZONE_GENERIC
	                if (count == 1) {
	                    zsinfo = formatData.GetZoneStringFormat().FindGenericShort(
	                            text, start);
	                } else if (count == 4) {
	                    zsinfo = formatData.GetZoneStringFormat().FindGenericLong(
	                            text, start);
	                }
	                break;
	            case 29: // 'V' - TIMEZONE_SPECIAL
	                if (count == 1) {
	                    zsinfo = formatData.GetZoneStringFormat()
	                            .FindSpecificShort(text, start);
	                } else if (count == 4) {
	                    zsinfo = formatData.GetZoneStringFormat()
	                            .FindGenericLocation(text, start);
	                }
	                break;
	            }
	            if (zsinfo != null) {
	                if (zsinfo.IsStandard()) {
	                    tztype = TZTYPE_STD;
	                } else if (zsinfo.IsDaylight()) {
	                    tztype = TZTYPE_DST;
	                }
	                tz = IBM.ICU.Util.TimeZone.GetTimeZone(zsinfo.GetID());
	                cal.SetTimeZone(tz);
	                return start + zsinfo.GetString().Length;
	            }
	            // complete failure
	            return -start;
	        }
	
	        case 27: // 'Q' - QUARTER
	            if (count <= 2) // i.e., Q or QQ.
	            {
	                // Don't want to parse the quarter if it is a string
	                // while pattern uses numeric style: Q or QQ.
	                // [We computed 'value' above.]
	                cal.Set(IBM.ICU.Util.Calendar.MONTH, (value_ren - 1) * 3);
	                return pos.GetIndex();
	            } else {
	                // count >= 3 // i.e., QQQ or QQQQ
	                // Want to be able to parse both short and long forms.
	                // Try count == 4 first:
	                int newStart_3 = MatchQuarterString(text, start, IBM.ICU.Util.Calendar.MONTH,
	                        formatData.quarters, cal);
	                if (newStart_3 > 0) {
	                    return newStart_3;
	                } else { // count == 4 failed, now try count == 3
	                    return MatchQuarterString(text, start, IBM.ICU.Util.Calendar.MONTH,
	                            formatData.shortQuarters, cal);
	                }
	            }
	
	            break;
	        case 28: // 'q' - STANDALONE QUARTER
	            if (count <= 2) // i.e., q or qq.
	            {
	                // Don't want to parse the quarter if it is a string
	                // while pattern uses numeric style: q or qq.
	                // [We computed 'value' above.]
	                cal.Set(IBM.ICU.Util.Calendar.MONTH, (value_ren - 1) * 3);
	                return pos.GetIndex();
	            } else {
	                // count >= 3 // i.e., qqq or qqqq
	                // Want to be able to parse both short and long forms.
	                // Try count == 4 first:
	                int newStart_4 = MatchQuarterString(text, start, IBM.ICU.Util.Calendar.MONTH,
	                        formatData.standaloneQuarters, cal);
	                if (newStart_4 > 0) {
	                    return newStart_4;
	                } else { // count == 4 failed, now try count == 3
	                    return MatchQuarterString(text, start, IBM.ICU.Util.Calendar.MONTH,
	                            formatData.standaloneShortQuarters, cal);
	                }
	            }
	
	            break;
	        default:
	            // case 3: // 'd' - DATE
	            // case 5: // 'H' - HOUR_OF_DAY (0..23)
	            // case 6: // 'm' - MINUTE
	            // case 7: // 's' - SECOND
	            // case 10: // 'D' - DAY_OF_YEAR
	            // case 11: // 'F' - DAY_OF_WEEK_IN_MONTH
	            // case 12: // 'w' - WEEK_OF_YEAR
	            // case 13: // 'W' - WEEK_OF_MONTH
	            // case 16: // 'K' - HOUR (0..11)
	            // case 18: // 'Y' - YEAR_WOY
	            // case 19: // 'e' - DOW_LOCAL
	            // case 20: // 'u' - EXTENDED_YEAR
	            // case 21: // 'g' - JULIAN_DAY
	            // case 22: // 'A' - MILLISECONDS_IN_DAY
	
	            // Handle "generic" fields
	            if (obeyCount) {
	                if ((start + count) > text.Length)
	                    return -start;
	                number = ParseInt(text, count, pos, allowNegative);
	            } else
	                number = ParseInt(text, pos, allowNegative);
	            if (number != null) {
	                cal.Set(field, System.Convert.ToInt32(number));
	                return pos.GetIndex();
	            }
	            return -start;
	        }
	    }
	
	    /// <summary>
	    /// Parse an integer using numberFormat. This method is semantically const,
	    /// but actually may modify fNumberFormat.
	    /// </summary>
	    ///
	    private object ParseInt(String text, ILOG.J2CsMapping.Text.ParsePosition pos,
	            bool allowNegative) {
	        return ParseInt(text, -1, pos, allowNegative);
	    }
	
	    /// <summary>
	    /// Parse an integer using numberFormat up to maxDigits.
	    /// </summary>
	    ///
	    private object ParseInt(String text, int maxDigits, ILOG.J2CsMapping.Text.ParsePosition pos,
	            bool allowNegative) {
	        object number;
	        int oldPos = pos.GetIndex();
	        if (allowNegative) {
	            number = numberFormat.Parse(text, pos);
	        } else {
	            // Invalidate negative numbers
	            if (numberFormat  is  DecimalFormat) {
	                String oldPrefix = ((DecimalFormat) numberFormat)
	                        .GetNegativePrefix();
	                ((DecimalFormat) numberFormat)
	                        .SetNegativePrefix(SUPPRESS_NEGATIVE_PREFIX);
	                number = numberFormat.Parse(text, pos);
	                ((DecimalFormat) numberFormat).SetNegativePrefix(oldPrefix);
	            } else {
	                bool dateNumberFormat = (numberFormat  is  DateNumberFormat);
	                if (dateNumberFormat) {
	                    ((DateNumberFormat) numberFormat)
	                            .SetParsePositiveOnly(true);
	                }
	                number = numberFormat.Parse(text, pos);
	                if (dateNumberFormat) {
	                    ((DateNumberFormat) numberFormat)
	                            .SetParsePositiveOnly(false);
	                }
	            }
	        }
	        if (maxDigits > 0) {
	            // adjust the result to fit into
	            // the maxDigits and move the position back
	            int nDigits = pos.GetIndex() - oldPos;
	            if (nDigits > maxDigits) {
	                double val = Convert.ToDouble(number);
	                nDigits -= maxDigits;
	                while (nDigits > 0) {
	                    val /= 10;
	                    nDigits--;
	                }
	                pos.SetIndex(oldPos + maxDigits);
	                number = ((int)((int) val));
	            }
	        }
	        return number;
	    }
	
	    /// <summary>
	    /// Translate a pattern, mapping each character in the from string to the
	    /// corresponding character in the to string.
	    /// </summary>
	    ///
	    private String TranslatePattern(String pat, String from, String to) {
	        StringBuilder result = new StringBuilder();
	        bool inQuote = false;
	        for (int i = 0; i < pat.Length; ++i) {
	            char c = pat[i];
	            if (inQuote) {
	                if (c == '\'')
	                    inQuote = false;
	            } else {
	                if (c == '\'')
	                    inQuote = true;
	                else if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {
	                    int ci = from.IndexOf(c);
	                    if (ci != -1) {
	                        c = to[ci];
	                    }
	                    // do not worry on translatepattern if the character is not
	                    // listed
	                    // we do the validity check elsewhere
	                }
	            }
	            result.Append(c);
	        }
	        if (inQuote)
	            throw new ArgumentException("Unfinished quote in pattern");
	        return result.ToString();
	    }
	
	    /// <summary>
	    /// Return a pattern string describing this date format.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public String ToPattern() {
	        return pattern;
	    }
	
	    /// <summary>
	    /// Return a localized pattern string describing this date format.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public String ToLocalizedPattern() {
	        return TranslatePattern(pattern, IBM.ICU.Text.DateFormatSymbols.patternChars,
	                formatData.localPatternChars);
	    }
	
	    /// <summary>
	    /// Apply the given unlocalized pattern string to this date format.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public void ApplyPattern(String pat) {
	        this.pattern = pat;
	        SetLocale(null, null);
	        // reset parsed pattern items
	        patternItems = null;
	    }
	
	    /// <summary>
	    /// Apply the given localized pattern string to this date format.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public void ApplyLocalizedPattern(String pat) {
	        this.pattern = TranslatePattern(pat, formatData.localPatternChars,
	                IBM.ICU.Text.DateFormatSymbols.patternChars);
	        SetLocale(null, null);
	    }
	
	    /// <summary>
	    /// Gets the date/time formatting data.
	    /// </summary>
	    ///
	    /// <returns>a copy of the date-time formatting data associated with this
	    /// date-time formatter.</returns>
	    /// @stable ICU 2.0
	    public DateFormatSymbols GetDateFormatSymbols() {
	        return (DateFormatSymbols) formatData.Clone();
	    }
	
	    /// <summary>
	    /// Allows you to set the date/time formatting data.
	    /// </summary>
	    ///
	    /// <param name="newFormatSymbols">the new symbols</param>
	    /// @stable ICU 2.0
	    public void SetDateFormatSymbols(DateFormatSymbols newFormatSymbols) {
	        this.formatData = (DateFormatSymbols) newFormatSymbols.Clone();
	    }
	
	    /// <summary>
	    /// Method for subclasses to access the DateFormatSymbols.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    protected internal DateFormatSymbols GetSymbols() {
	        return formatData;
	    }
	
	    /// <summary>
	    /// Overrides Cloneable
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public override Object Clone() {
	        SimpleDateFormat other = (SimpleDateFormat) base.Clone();
	        other.formatData = (DateFormatSymbols) formatData.Clone();
	        return other;
	    }
	
	    /// <summary>
	    /// Override hashCode. Generates the hash code for the SimpleDateFormat
	    /// object
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public override int GetHashCode() {
	        return pattern.GetHashCode();
	        // just enough fields for a reasonable distribution
	    }
	
	    /// <summary>
	    /// Override equals.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public override bool Equals(Object obj) {
	        if (!base.Equals(obj))
	            return false; // super does class check
	        SimpleDateFormat that = (SimpleDateFormat) obj;
	        return (pattern.Equals(that.pattern) && formatData
	                .Equals(that.formatData));
	    }
	
	    /// <summary>
	    /// Override writeObject.
	    /// </summary>
	    ///
	    private void WriteObject(IlObjectOutputStream stream) {
	        if (defaultCenturyStart == null) {
	            // if defaultCenturyStart is not yet initialized,
	            // calculate and set value before serialization.
	            InitializeDefaultCenturyStart(defaultCenturyBase);
	        }
	        stream.DefaultWriteObject();
	    }
	
	    /// <summary>
	    /// Override readObject.
	    /// </summary>
	    ///
	    private void ReadObject(IlObjectInputStream stream) {
	        stream.DefaultReadObject();
	        // /CLOVER:OFF
	        // don't have old serial data to test with
	        if (serialVersionOnStream < 1) {
	            // didn't have defaultCenturyStart field
	            defaultCenturyBase = DateUtil.DotNetDateToJavaMillis(DateTime.Now); //.Millisecond;
	        }
	        // /CLOVER:ON
	        else {
	            // fill in dependent transient field
	            ParseAmbiguousDatesAsAfter(defaultCenturyStart);
	        }
	        serialVersionOnStream = currentSerialVersion;
	        locale = GetLocale(IBM.ICU.Util.ULocale.VALID_LOCALE);
	
	        InitLocalZeroPaddingNumberFormat();
	    }
	
	    // #if defined(FOUNDATION10) || defined(J2SE13)
	    // #else
	    /// <summary>
	    /// Format the object to an attributed string, and return the corresponding
	    /// iterator Overrides superclass method.
	    /// </summary>
	    ///
	    /// <param name="obj">The object to format</param>
	    /// <returns><c>AttributedCharacterIterator</c> describing the formatted
	    /// value.</returns>
	    /// @stable ICU 3.8
	    public override ILOG.J2CsMapping.Text.AttributedCharacterIterator FormatToCharacterIterator(Object obj) {
	        IBM.ICU.Util.Calendar cal = calendar;
	        if (obj  is  IBM.ICU.Util.Calendar) {
	            cal = (IBM.ICU.Util.Calendar) obj;
	        } else if (obj  is  DateTime) {
	            calendar.SetTime((DateTime) obj);
	        } else if (obj  is  object) {
	            calendar.SetTimeInMillis(Convert.ToInt64(((object) obj)));
	        } else {
	            throw new ArgumentException(
	                    "Cannot format given Object as a Date");
	        }
	        StringBuilder toAppendTo = new StringBuilder();
	        ILOG.J2CsMapping.Text.FieldPosition pos = new ILOG.J2CsMapping.Text.FieldPosition(0);
	        IList attributes = new LinkedList();
	        Format(cal, toAppendTo, pos, attributes);
	
	        ILOG.J2CsMapping.Text.AttributedString al = new ILOG.J2CsMapping.Text.AttributedString(toAppendTo.ToString());
	
	        // add DateFormat field attributes to the AttributedString
	        for (int i = 0; i < attributes.Count; i++) {
	            ILOG.J2CsMapping.Text.FieldPosition fp = (ILOG.J2CsMapping.Text.FieldPosition) attributes[i];
                ILOG.J2CsMapping.Formatting.Format.Field attribute = fp.GetFieldAttribute();
	            al.AddAttribute(attribute, attribute, fp.GetBeginIndex(),
	                    fp.GetEndIndex());
	        }
	        // return the CharacterIterator from AttributedString
	        return al.GetIterator();
	    }
	    // #endif
	}
}
