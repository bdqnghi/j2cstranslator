/*
 *******************************************************************************
 * Copyright (C) 1996-2004, International Business Machines Corporation and    *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 */
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:30 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Text {
	
	using IBM.ICU.Impl;
	using ILOG.J2CsMapping.Text;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Text;
	
	/// <summary>
	/// Abstract class that defines an API for iteration on text objects.This is an
	/// interface for forward and backward iteration and random access into a text
	/// object. Forward iteration is done with post-increment and backward iteration
	/// is done with pre-decrement semantics, while the
	/// <c>java.text.CharacterIterator</c> interface methods provided forward
	/// iteration with "pre-increment" and backward iteration with pre-decrement
	/// semantics. This API is more efficient for forward iteration over code points.
	/// The other major difference is that this API can do both code unit and code
	/// point iteration, <c>java.text.CharacterIterator</c> can only iterate
	/// over code units and is limited to BMP (0 - 0xFFFF)
	/// </summary>
	///
	/// @stable ICU 2.4
	public abstract class UCharacterIterator : ICloneable,
	        UForwardCharacterIterator {
	
	    /// <summary>
	    /// Protected default constructor for the subclasses
	    /// </summary>
	    ///
	    /// @stable ICU 2.4
	    protected internal UCharacterIterator() {
	    }
	
	    // static final methods ----------------------------------------------------
	
	    /// <summary>
	    /// Returns a <c>UCharacterIterator</c> object given a
	    /// <c>Replaceable</c> object.
	    /// </summary>
	    ///
	    /// <param name="source">a valid source as a <c>Replaceable</c> object</param>
	    /// <returns>UCharacterIterator object</returns>
	    /// <exception cref="IllegalArgumentException">if the argument is null</exception>
	    /// @stable ICU 2.4
	    public static UCharacterIterator GetInstance(Replaceable source) {
	        return new ReplaceableUCharacterIterator(source);
	    }
	
	    /// <summary>
	    /// Returns a <c>UCharacterIterator</c> object given a source string.
	    /// </summary>
	    ///
	    /// <param name="source">a string</param>
	    /// <returns>UCharacterIterator object</returns>
	    /// <exception cref="IllegalArgumentException">if the argument is null</exception>
	    /// @stable ICU 2.4
	    public static UCharacterIterator GetInstance(String source) {
	        return new ReplaceableUCharacterIterator(source);
	    }
	
	    /// <summary>
	    /// Returns a <c>UCharacterIterator</c> object given a source character
	    /// array.
	    /// </summary>
	    ///
	    /// <param name="source">an array of UTF-16 code units</param>
	    /// <returns>UCharacterIterator object</returns>
	    /// <exception cref="IllegalArgumentException">if the argument is null</exception>
	    /// @stable ICU 2.4
	    public static UCharacterIterator GetInstance(char[] source) {
	        return GetInstance(source, 0, source.Length);
	    }
	
	    /// <summary>
	    /// Returns a <c>UCharacterIterator</c> object given a source character
	    /// array.
	    /// </summary>
	    ///
	    /// <param name="source">an array of UTF-16 code units</param>
	    /// <returns>UCharacterIterator object</returns>
	    /// <exception cref="IllegalArgumentException">if the argument is null</exception>
	    /// @stable ICU 2.4
	    public static UCharacterIterator GetInstance(char[] source,
	            int start, int limit) {
	        return new UCharArrayIterator(source, start, limit);
	    }
	
	    /// <summary>
	    /// Returns a <c>UCharacterIterator</c> object given a source
	    /// StringBuffer.
	    /// </summary>
	    ///
	    /// <param name="source">an string buffer of UTF-16 code units</param>
	    /// <returns>UCharacterIterator object</returns>
	    /// <exception cref="IllegalArgumentException">if the argument is null</exception>
	    /// @stable ICU 2.4
	    public static UCharacterIterator GetInstance(StringBuilder source) {
	        return new ReplaceableUCharacterIterator(source);
	    }
	
	    /// <summary>
	    /// Returns a <c>UCharacterIterator</c> object given a
	    /// CharacterIterator.
	    /// </summary>
	    ///
	    /// <param name="source">a valid CharacterIterator object.</param>
	    /// <returns>UCharacterIterator object</returns>
	    /// <exception cref="IllegalArgumentException">if the argument is null</exception>
	    /// @stable ICU 2.4
	    public static UCharacterIterator GetInstance(ICharacterIterator source) {
	        return new CharacterIteratorWrapper(source);
	    }
	
	    // public methods ----------------------------------------------------------
	    /// <summary>
	    /// Returns a <c>java.text.CharacterIterator</c> object for the
	    /// underlying text of this iterator. The returned iterator is independent of
	    /// this iterator.
	    /// </summary>
	    ///
	    /// <returns>java.text.CharacterIterator object</returns>
	    /// @stable ICU 2.4
	    public virtual ICharacterIterator GetCharacterIterator() {
	        return new UCharacterIteratorWrapper(this);
	    }
	
	    /// <summary>
	    /// Returns the code unit at the current index. If index is out of range,
	    /// returns DONE. Index is not changed.
	    /// </summary>
	    ///
	    /// <returns>current code unit</returns>
	    /// @stable ICU 2.4
	    public abstract int Current();
	
	    /// <summary>
	    /// Returns the codepoint at the current index. If the current index is
	    /// invalid, DONE is returned. If the current index points to a lead
	    /// surrogate, and there is a following trail surrogate, then the code point
	    /// is returned. Otherwise, the code unit at index is returned. Index is not
	    /// changed.
	    /// </summary>
	    ///
	    /// <returns>current codepoint</returns>
	    /// @stable ICU 2.4
	    public virtual int CurrentCodePoint() {
	        int ch = Current();
	        if (IBM.ICU.Text.UTF16.IsLeadSurrogate((char) ch)) {
	            // advance the index to get the
	            // next code point
	            Next();
	            // due to post increment semantics
	            // current() after next() actually
	            // returns the char we want
	            int ch2 = Current();
	            // current should never change
	            // the current index so back off
	            Previous();
	
	            if (IBM.ICU.Text.UTF16.IsTrailSurrogate((char) ch2)) {
	                // we found a surrogate pair
	                // return the codepoint
	                return IBM.ICU.Impl.UCharacterProperty.GetRawSupplementary((char) ch,
	                        (char) ch2);
	            }
	        }
	        return ch;
	    }
	
	    /// <summary>
	    /// Returns the length of the text
	    /// </summary>
	    ///
	    /// <returns>length of the text</returns>
	    /// @stable ICU 2.4
	    public abstract int GetLength();
	
	    /// <summary>
	    /// Gets the current index in text.
	    /// </summary>
	    ///
	    /// <returns>current index in text.</returns>
	    /// @stable ICU 2.4
	    public abstract int GetIndex();
	
	    /// <summary>
	    /// Returns the UTF16 code unit at index, and increments to the next code
	    /// unit (post-increment semantics). If index is out of range, DONE is
	    /// returned, and the iterator is reset to the limit of the text.
	    /// </summary>
	    ///
	    /// <returns>the next UTF16 code unit, or DONE if the index is at the limit of
	    /// the text.</returns>
	    /// @stable ICU 2.4
	    public abstract int Next();
	
	    /// <summary>
	    /// Returns the code point at index, and increments to the next code point
	    /// (post-increment semantics). If index does not point to a valid surrogate
	    /// pair, the behavior is the same as
	    /// <code>next()<code>.  Otherwise the iterator is incremented past
	    /// the surrogate pair, and the code point represented by the pair
	    /// is returned.
	    /// </summary>
	    ///
	    /// <returns>the next codepoint in text, or DONE if the index is at the limit
	    /// of the text.</returns>
	    /// @stable ICU 2.4
	    public virtual int NextCodePoint() {
	        int ch1 = Next();
	        if (IBM.ICU.Text.UTF16.IsLeadSurrogate((char) ch1)) {
	            int ch2 = Next();
	            if (IBM.ICU.Text.UTF16.IsTrailSurrogate((char) ch2)) {
	                return IBM.ICU.Impl.UCharacterProperty.GetRawSupplementary((char) ch1,
	                        (char) ch2);
	            } else if (ch2 != IBM.ICU.Text.UForwardCharacterIterator_Constants.DONE) {
	                // unmatched surrogate so back out
	                Previous();
	            }
	        }
	        return ch1;
	    }
	
	    /// <summary>
	    /// Decrement to the position of the previous code unit in the text, and
	    /// return it (pre-decrement semantics). If the resulting index is less than
	    /// 0, the index is reset to 0 and DONE is returned.
	    /// </summary>
	    ///
	    /// <returns>the previous code unit in the text, or DONE if the new index is
	    /// before the start of the text.</returns>
	    /// @stable ICU 2.4
	    public abstract int Previous();
	
	    /// <summary>
	    /// Retreat to the start of the previous code point in the text, and return
	    /// it (pre-decrement semantics). If the index is not preceeded by a valid
	    /// surrogate pair, the behavior is the same as <c>previous()</c>.
	    /// Otherwise the iterator is decremented to the start of the surrogate pair,
	    /// and the code point represented by the pair is returned.
	    /// </summary>
	    ///
	    /// <returns>the previous code point in the text, or DONE if the new index is
	    /// before the start of the text.</returns>
	    /// @stable ICU 2.4
	    public int PreviousCodePoint() {
	        int ch1 = Previous();
	        if (IBM.ICU.Text.UTF16.IsTrailSurrogate((char) ch1)) {
	            int ch2 = Previous();
	            if (IBM.ICU.Text.UTF16.IsLeadSurrogate((char) ch2)) {
	                return IBM.ICU.Impl.UCharacterProperty.GetRawSupplementary((char) ch2,
	                        (char) ch1);
	            } else if (ch2 != IBM.ICU.Text.UForwardCharacterIterator_Constants.DONE) {
	                // unmatched trail surrogate so back out
	                Next();
	            }
	        }
	        return ch1;
	    }
	
	    /// <summary>
	    /// Sets the index to the specified index in the text.
	    /// </summary>
	    ///
	    /// <param name="index">the index within the text.</param>
	    /// <exception cref="IndexOutOfBoundsException">is thrown if an invalid index is supplied</exception>
	    /// @stable ICU 2.4
	    public abstract void SetIndex(int index);
	
	    /// <summary>
	    /// Sets the current index to the limit.
	    /// </summary>
	    ///
	    /// @stable ICU 2.4
	    public virtual void SetToLimit() {
	        SetIndex(GetLength());
	    }
	
	    /// <summary>
	    /// Sets the current index to the start.
	    /// </summary>
	    ///
	    /// @stable ICU 2.4
	    public void SetToStart() {
	        SetIndex(0);
	    }
	
	    /// <summary>
	    /// Fills the buffer with the underlying text storage of the iterator If the
	    /// buffer capacity is not enough a exception is thrown. The capacity of the
	    /// fill in buffer should at least be equal to length of text in the iterator
	    /// obtained by calling <code>getLength()</code). <b>Usage:</b>
	    /// <code>
	    /// <pre>
	    /// UChacterIterator iter = new UCharacterIterator.getInstance(text);
	    /// char[] buf = new char[iter.getLength()];
	    /// iter.getText(buf);
	    /// OR
	    /// char[] buf= new char[1];
	    /// int len = 0;
	    /// for(;;){
	    /// try{
	    /// len = iter.getText(buf);
	    /// break;
	    /// }catch(IndexOutOfBoundsException e){
	    /// buf = new char[iter.getLength()];
	    /// }
	    /// }
	    /// </pre>
	    /// </code>
	    /// </summary>
	    ///
	    /// <param name="fillIn">an array of chars to fill with the underlying UTF-16 codeunits.</param>
	    /// <param name="offset">the position within the array to start putting the data.</param>
	    /// <returns>the number of code units added to fillIn, as a convenience</returns>
	    /// <exception cref="IndexOutOfBounds">exception if there is not enough room after offset in thearray, or if offset < 0.</exception>
	    /// @stable ICU 2.4
	    public abstract int GetText(char[] fillIn, int offset);
	
	    /// <summary>
	    /// Convenience override for <code>getText(char[], int)>/code> that provides
	    /// an offset of 0.
	    /// </summary>
	    ///
	    /// <param name="fillIn">an array of chars to fill with the underlying UTF-16 codeunits.</param>
	    /// <returns>the number of code units added to fillIn, as a convenience</returns>
	    /// <exception cref="IndexOutOfBounds">exception if there is not enough room in the array.</exception>
	    /// @stable ICU 2.4
	    public int GetText(char[] fillIn) {
	        return GetText(fillIn, 0);
	    }
	
	    /// <summary>
	    /// Convenience method for returning the underlying text storage as as string
	    /// </summary>
	    ///
	    /// <returns>the underlying text storage in the iterator as a string</returns>
	    /// @stable ICU 2.4
	    public virtual String GetText() {
	        char[] text = new char[GetLength()];
	        GetText(text);
	        return ILOG.J2CsMapping.Util.StringUtil.NewString(text);
	    }
	
	    /// <summary>
	    /// Moves the current position by the number of code units specified, either
	    /// forward or backward depending on the sign of delta (positive or negative
	    /// respectively). If the resulting index would be less than zero, the index
	    /// is set to zero, and if the resulting index would be greater than limit,
	    /// the index is set to limit.
	    /// </summary>
	    ///
	    /// <param name="delta">the number of code units to move the current index.</param>
	    /// <returns>the new index.</returns>
	    /// <exception cref="IndexOutOfBoundsException">is thrown if an invalid index is supplied</exception>
	    /// @stable ICU 2.4
	    public virtual int MoveIndex(int delta) {
	        int x = Math.Max(0,Math.Min(GetIndex() + delta,GetLength()));
	        SetIndex(x);
	        return x;
	    }
	
	    /// <summary>
	    /// Moves the current position by the number of code points specified, either
	    /// forward or backward depending on the sign of delta (positive or negative
	    /// respectively). If the current index is at a trail surrogate then the
	    /// first adjustment is by code unit, and the remaining adjustments are by
	    /// code points. If the resulting index would be less than zero, the index is
	    /// set to zero, and if the resulting index would be greater than limit, the
	    /// index is set to limit.
	    /// </summary>
	    ///
	    /// <param name="delta">the number of code units to move the current index.</param>
	    /// <returns>the new index</returns>
	    /// <exception cref="IndexOutOfBoundsException">is thrown if an invalid delta is supplied</exception>
	    /// @stable ICU 2.4
	    public int MoveCodePointIndex(int delta) {
	        if (delta > 0) {
	            while (delta > 0 && NextCodePoint() != IBM.ICU.Text.UForwardCharacterIterator_Constants.DONE) {
	                delta--;
	            }
	        } else {
	            while (delta < 0 && PreviousCodePoint() != IBM.ICU.Text.UForwardCharacterIterator_Constants.DONE) {
	                delta++;
	            }
	        }
	        if (delta != 0) {
	            throw new IndexOutOfRangeException();
	        }
	
	        return GetIndex();
	    }
	
	    /// <summary>
	    /// Creates a copy of this iterator, independent from other iterators. If it
	    /// is not possible to clone the iterator, returns null.
	    /// </summary>
	    ///
	    /// <returns>copy of this iterator</returns>
	    /// @stable ICU 2.4
	    public virtual Object Clone() {
	        return base.MemberwiseClone();
	    }
	
	}
}
