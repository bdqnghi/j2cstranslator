/*
 **********************************************************************
 * Copyright (c) 2003, International Business Machines
 * Corporation and others.  All Rights Reserved.
 **********************************************************************
 * Author: Alan Liu
 * Created: September 23 2003
 * Since: ICU 2.8
 **********************************************************************
 */
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:47 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Impl {
	
	using IBM.ICU.Text;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
     using ILOG.J2CsMapping.Util;
	
	/// <summary>
	/// An iterator that returns 32-bit code points. This class is deliberately
	/// <em>not</em> related to any of the JDK or ICU4J character iterator classes in
	/// order to minimize complexity.
	/// </summary>
	///
	public class RuleCharacterIterator {
	
	    // TODO: Ideas for later. (Do not implement if not needed, lest the
	    // code coverage numbers go down due to unused methods.)
	    // 1. Add a copy constructor, equals() method, clone() method.
	    // 2. Rather than return DONE, throw an exception if the end
	    // is reached -- this is an alternate usage model, probably not useful.
	    // 3. Return isEscaped from next(). If this happens,
	    // don't keep an isEscaped member variable.
	
	    /// <summary>
	    /// Text being iterated.
	    /// </summary>
	    ///
	    private String text;
	
	    /// <summary>
	    /// Position of iterator.
	    /// </summary>
	    ///
	    private ILOG.J2CsMapping.Text.ParsePosition pos;
	
	    /// <summary>
	    /// Symbol table used to parse and dereference variables. May be null.
	    /// </summary>
	    ///
	    private SymbolTable sym;
	
	    /// <summary>
	    /// Current variable expansion, or null if none.
	    /// </summary>
	    ///
	    private char[] buf;
	
	    /// <summary>
	    /// Position within buf[]. Meaningless if buf == null.
	    /// </summary>
	    ///
	    private int bufPos;
	
	    /// <summary>
	    /// Flag indicating whether the last character was parsed from an escape.
	    /// </summary>
	    ///
	    private bool isEscaped;
	
	    /// <summary>
	    /// Value returned when there are no more characters to iterate.
	    /// </summary>
	    ///
	    public const int DONE = -1;
	
	    /// <summary>
	    /// Bitmask option to enable parsing of variable names. If (options &
	    /// PARSE_VARIABLES) != 0, then an embedded variable will be expanded to its
	    /// value. Variables are parsed using the SymbolTable API.
	    /// </summary>
	    ///
	    public const int PARSE_VARIABLES = 1;
	
	    /// <summary>
	    /// Bitmask option to enable parsing of escape sequences. If (options &
	    /// PARSE_ESCAPES) != 0, then an embedded escape sequence will be expanded to
	    /// its value. Escapes are parsed using Utility.unescapeAt().
	    /// </summary>
	    ///
	    public const int PARSE_ESCAPES = 2;
	
	    /// <summary>
	    /// Bitmask option to enable skipping of whitespace. If (options &
	    /// SKIP_WHITESPACE) != 0, then whitespace characters will be silently
	    /// skipped, as if they were not present in the input. Whitespace characters
	    /// are defined by UCharacterProperty.isRuleWhiteSpace().
	    /// </summary>
	    ///
	    public const int SKIP_WHITESPACE = 4;
	
	    /// <summary>
	    /// Constructs an iterator over the given text, starting at the given
	    /// position.
	    /// </summary>
	    ///
	    /// <param name="text_0">the text to be iterated</param>
	    /// <param name="sym_1">the symbol table, or null if there is none. If sym is null,then variables will not be deferenced, even if thePARSE_VARIABLES option is set.</param>
	    /// <param name="pos_2">upon input, the index of the next character to return. If avariable has been dereferenced, then pos will <em>not</em>increment as characters of the variable value are iterated.</param>
	    public RuleCharacterIterator(String text_0, SymbolTable sym_1, ILOG.J2CsMapping.Text.ParsePosition pos_2) {
	        if (text_0 == null || pos_2.GetIndex() > text_0.Length) {
	            throw new ArgumentException();
	        }
	        this.text = text_0;
	        this.sym = sym_1;
	        this.pos = pos_2;
	        buf = null;
	    }
	
	    /// <summary>
	    /// Returns true if this iterator has no more characters to return.
	    /// </summary>
	    ///
	    public bool AtEnd() {
	        return buf == null && pos.GetIndex() == text.Length;
	    }
	
	    /// <summary>
	    /// Returns the next character using the given options, or DONE if there are
	    /// no more characters, and advance the position to the next character.
	    /// </summary>
	    ///
	    /// <param name="options">one or more of the following options, bitwise-OR-ed together:PARSE_VARIABLES, PARSE_ESCAPES, SKIP_WHITESPACE.</param>
	    /// <returns>the current 32-bit code point, or DONE</returns>
	    public int Next(int options) {
	        int c = DONE;
	        isEscaped = false;
	
	        for (;;) {
	            c = _current();
	            _advance(IBM.ICU.Text.UTF16.GetCharCount(c));
	
	            if (c == IBM.ICU.Text.SymbolTable_Constants.SYMBOL_REF && buf == null
	                    && (options & PARSE_VARIABLES) != 0 && sym != null) {
	                String name = sym.ParseReference(text, pos, text.Length);
	                // If name == null there was an isolated SYMBOL_REF;
	                // return it. Caller must be prepared for this.
	                if (name == null) {
	                    break;
	                }
	                bufPos = 0;
	                buf = sym.Lookup(name);
	                if (buf == null) {
	                    throw new ArgumentException("Undefined variable: "
	                            + name);
	                }
	                // Handle empty variable value
	                if (buf.Length == 0) {
	                    buf = null;
	                }
	                continue;
	            }
	
	            if ((options & SKIP_WHITESPACE) != 0
	                    && IBM.ICU.Impl.UCharacterProperty.IsRuleWhiteSpace(c)) {
	                continue;
	            }
	
	            if (c == '\\' && (options & PARSE_ESCAPES) != 0) {
	                int[] offset = new int[] { 0 };
	                c = IBM.ICU.Impl.Utility.UnescapeAt(Lookahead(), offset);
	                Jumpahead(offset[0]);
	                isEscaped = true;
	                if (c < 0) {
	                    throw new ArgumentException("Invalid escape");
	                }
	            }
	
	            break;
	        }
	
	        return c;
	    }
	
	    /// <summary>
	    /// Returns true if the last character returned by next() was escaped. This
	    /// will only be the case if the option passed in to next() included
	    /// PARSE_ESCAPED and the next character was an escape sequence.
	    /// </summary>
	    ///
	    public bool IsEscaped() {
	        return isEscaped;
	    }
	
	    /// <summary>
	    /// Returns true if this iterator is currently within a variable expansion.
	    /// </summary>
	    ///
	    public bool InVariable() {
	        return buf != null;
	    }
	
	    /// <summary>
	    /// Returns an object which, when later passed to setPos(), will restore this
	    /// iterator's position. Usage idiom:
	    /// RuleCharacterIterator iterator = ...; Object pos = iterator.getPos(null);
	    /// // allocate position object for (;;) { pos = iterator.getPos(pos); //
	    /// reuse position object int c = iterator.next(...); ... }
	    /// iterator.setPos(pos);
	    /// </summary>
	    ///
	    /// <param name="p">a position object previously returned by getPos(), or null. Ifnot null, it will be updated and returned. If null, a newposition object will be allocated and returned.</param>
	    /// <returns>a position object which may be passed to setPos(), either `p,' or
	    /// if `p' == null, a newly-allocated object</returns>
	    public Object GetPos(Object p) {
	        if (p == null) {
	            return new Object[] { buf, new int[] { pos.GetIndex(), bufPos } };
	        }
	        Object[] a = (Object[]) p;
	        a[0] = buf;
	        int[] v = (int[]) a[1];
	        v[0] = pos.GetIndex();
	        v[1] = bufPos;
	        return p;
	    }
	
	    /// <summary>
	    /// Restores this iterator to the position it had when getPos() returned the
	    /// given object.
	    /// </summary>
	    ///
	    /// <param name="p">a position object previously returned by getPos()</param>
	    public void SetPos(Object p) {
	        Object[] a = (Object[]) p;
	        buf = (char[]) a[0];
	        int[] v = (int[]) a[1];
	        pos.SetIndex(v[0]);
	        bufPos = v[1];
	    }
	
	    /// <summary>
	    /// Skips ahead past any ignored characters, as indicated by the given
	    /// options. This is useful in conjunction with the lookahead() method.
	    /// Currently, this only has an effect for SKIP_WHITESPACE.
	    /// </summary>
	    ///
	    /// <param name="options">one or more of the following options, bitwise-OR-ed together:PARSE_VARIABLES, PARSE_ESCAPES, SKIP_WHITESPACE.</param>
	    public void SkipIgnored(int options) {
	        if ((options & SKIP_WHITESPACE) != 0) {
	            for (;;) {
	                int a = _current();
	                if (!IBM.ICU.Impl.UCharacterProperty.IsRuleWhiteSpace(a))
	                    break;
	                _advance(IBM.ICU.Text.UTF16.GetCharCount(a));
	            }
	        }
	    }
	
	    /// <summary>
	    /// Returns a string containing the remainder of the characters to be
	    /// returned by this iterator, without any option processing. If the iterator
	    /// is currently within a variable expansion, this will only extend to the
	    /// end of the variable expansion. This method is provided so that iterators
	    /// may interoperate with string-based APIs. The typical sequence of calls is
	    /// to call skipIgnored(), then call lookahead(), then parse the string
	    /// returned by lookahead(), then call jumpahead() to resynchronize the
	    /// iterator.
	    /// </summary>
	    ///
	    /// <returns>a string containing the characters to be returned by future calls
	    /// to next()</returns>
	    public String Lookahead() {
	        if (buf != null) {
	            return new String(buf, bufPos, buf.Length - bufPos);
	        } else {
	            return text.Substring(pos.GetIndex());
	        }
	    }
	
	    /// <summary>
	    /// Advances the position by the given number of 16-bit code units. This is
	    /// useful in conjunction with the lookahead() method.
	    /// </summary>
	    ///
	    /// <param name="count">the number of 16-bit code units to jump over</param>
	    public void Jumpahead(int count) {
	        if (count < 0) {
	            throw new ArgumentException();
	        }
	        if (buf != null) {
	            bufPos += count;
	            if (bufPos > buf.Length) {
	                throw new ArgumentException();
	            }
	            if (bufPos == buf.Length) {
	                buf = null;
	            }
	        } else {
	            int i = pos.GetIndex() + count;
	            pos.SetIndex(i);
	            if (i > text.Length) {
	                throw new ArgumentException();
	            }
	        }
	    }
	
	    /// <summary>
	    /// Returns a string representation of this object, consisting of the
	    /// characters being iterated, with a '|' marking the current position.
	    /// Position within an expanded variable is <em>not</em> indicated.
	    /// </summary>
	    ///
	    /// <returns>a string representation of this object</returns>
	    public override String ToString() {
	        int b = pos.GetIndex();
	        return text.Substring(0,(b)-(0)) + '|' + text.Substring(b);
	    }
	
	    /// <summary>
	    /// Returns the current 32-bit code point without parsing escapes, parsing
	    /// variables, or skipping whitespace.
	    /// </summary>
	    ///
	    /// <returns>the current 32-bit code point</returns>
	    private int _current() {
	        if (buf != null) {
	            return IBM.ICU.Text.UTF16.CharAt(buf, 0, buf.Length, bufPos);
	        } else {
	            int i = pos.GetIndex();
	            return (i < text.Length) ? IBM.ICU.Text.UTF16.CharAt(text, i) : DONE;
	        }
	    }
	
	    /// <summary>
	    /// Advances the position by the given amount.
	    /// </summary>
	    ///
	    /// <param name="count">the number of 16-bit code units to advance past</param>
	    private void _advance(int count) {
	        if (buf != null) {
	            bufPos += count;
	            if (bufPos == buf.Length) {
	                buf = null;
	            }
	        } else {
	            pos.SetIndex(pos.GetIndex() + count);
	            if (pos.GetIndex() > text.Length) {
	                pos.SetIndex(text.Length);
	            }
	        }
	    }
	}}
