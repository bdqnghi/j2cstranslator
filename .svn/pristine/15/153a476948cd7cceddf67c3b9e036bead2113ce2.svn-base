/* Generated By:JavaCC: Do not edit this line. IlrTokenManager.java */
package com.ilog.translator.java2cs.configuration.parser;

import java.io.IOException;

public class IlrTokenManager implements IlrConstants {
	private final int jjStopAtPos(int pos, int kind) {
		jjmatchedKind = kind;
		jjmatchedPos = pos;
		return pos + 1;
	}

	private final int jjMoveStringLiteralDfa0_3() {
		switch (curChar) {
		case 42:
			return jjMoveStringLiteralDfa1_3(0x1000L);
		default:
			return 1;
		}
	}

	private final int jjMoveStringLiteralDfa1_3(long active0) {
		try {
			curChar = input_stream.readChar();
		} catch (final java.io.IOException e) {
			return 1;
		}
		switch (curChar) {
		case 47:
			if ((active0 & 0x1000L) != 0L) {
				return jjStopAtPos(1, 12);
			}
			break;
		default:
			return 2;
		}
		return 2;
	}

	private final int jjMoveStringLiteralDfa0_4() {
		switch (curChar) {
		case 125:
			return jjMoveStringLiteralDfa1_4(0x2000L);
		default:
			return 1;
		}
	}

	private final int jjMoveStringLiteralDfa1_4(long active0) {
		try {
			curChar = input_stream.readChar();
		} catch (final java.io.IOException e) {
			return 1;
		}
		switch (curChar) {
		case 59:
			if ((active0 & 0x2000L) != 0L) {
				return jjStopAtPos(1, 13);
			}
			break;
		default:
			return 2;
		}
		return 2;
	}

	private final int jjMoveStringLiteralDfa0_2() {
		switch (curChar) {
		case 42:
			return jjMoveStringLiteralDfa1_2(0x800L);
		default:
			return 1;
		}
	}

	private final int jjMoveStringLiteralDfa1_2(long active0) {
		try {
			curChar = input_stream.readChar();
		} catch (final java.io.IOException e) {
			return 1;
		}
		switch (curChar) {
		case 47:
			if ((active0 & 0x800L) != 0L) {
				return jjStopAtPos(1, 11);
			}
			break;
		default:
			return 2;
		}
		return 2;
	}

	private final int jjMoveStringLiteralDfa0_1() {
		return jjMoveNfa_1(0, 0);
	}

	private final void jjCheckNAdd(int state) {
		if (jjrounds[state] != jjround) {
			jjstateSet[jjnewStateCnt++] = state;
			jjrounds[state] = jjround;
		}
	}

	private final void jjAddStates(int start, int end) {
		do {
			jjstateSet[jjnewStateCnt++] = IlrTokenManager.jjnextStates[start];
		} while (start++ != end);
	}

	private final void jjCheckNAddTwoStates(int state1, int state2) {
		jjCheckNAdd(state1);
		jjCheckNAdd(state2);
	}

	private final void jjCheckNAddStates(int start, int end) {
		do {
			jjCheckNAdd(IlrTokenManager.jjnextStates[start]);
		} while (start++ != end);
	}

	@SuppressWarnings("unused")
	private final int jjMoveNfa_1(int startState, int curPos) {
		int startsAt = 0;
		jjnewStateCnt = 3;
		int i = 1;
		jjstateSet[0] = startState;
		int kind = 0x7fffffff;
		for (;;) {
			if (++jjround == 0x7fffffff) {
				ReInitRounds();
			}
			if (curChar < 64) {
				final long l = 1L << curChar;
				MatchLoop: do {
					switch (jjstateSet[--i]) {
					case 0:
						if ((0x2400L & l) != 0L) {
							if (kind > 10) {
								kind = 10;
							}
						}
						if (curChar == 13) {
							jjstateSet[jjnewStateCnt++] = 1;
						}
						break;
					case 1:
						if ((curChar == 10) && (kind > 10)) {
							kind = 10;
						}
						break;
					case 2:
						if (curChar == 13) {
							jjstateSet[jjnewStateCnt++] = 1;
						}
						break;
					default:
						break;
					}
				} while (i != startsAt);
			} else if (curChar < 128) {
				MatchLoop: do {
					switch (jjstateSet[--i]) {
					default:
						break;
					}
				} while (i != startsAt);
			} else {
				final int hiByte = (curChar >> 8);
				MatchLoop: do {
					switch (jjstateSet[--i]) {
					default:
						break;
					}
				} while (i != startsAt);
			}
			if (kind != 0x7fffffff) {
				jjmatchedKind = kind;
				jjmatchedPos = curPos;
				kind = 0x7fffffff;
			}
			++curPos;
			if ((i = jjnewStateCnt) == (startsAt = 3 - (jjnewStateCnt = startsAt))) {
				return curPos;
			}
			try {
				curChar = input_stream.readChar();
			} catch (final java.io.IOException e) {
				return curPos;
			}
		}
	}

	private final int jjStopStringLiteralDfa_0(int pos, long active0) {
		switch (pos) {
		case 0:
			if ((active0 & 0x20000L) != 0L) {
				jjmatchedKind = 29;
				return 10;
			}
			if ((active0 & 0x1d8000L) != 0L) {
				jjmatchedKind = 29;
				return 32;
			}
			if ((active0 & 0x10000000000L) != 0L) {
				return 16;
			}
			if ((active0 & 0x140L) != 0L) {
				jjmatchedKind = 44;
				return 2;
			}
			return -1;
		case 1:
			if ((active0 & 0x100L) != 0L) {
				return 0;
			}
			if ((active0 & 0x1f8000L) != 0L) {
				jjmatchedKind = 29;
				jjmatchedPos = 1;
				return 32;
			}
			return -1;
		case 2:
			if ((active0 & 0x1f8000L) != 0L) {
				jjmatchedKind = 29;
				jjmatchedPos = 2;
				return 32;
			}
			return -1;
		case 3:
			if ((active0 & 0x20000L) != 0L) {
				jjmatchedKind = 29;
				jjmatchedPos = 3;
				return 32;
			}
			if ((active0 & 0x18000L) != 0L) {
				return 32;
			}
			return -1;
		default:
			return -1;
		}
	}

	private final int jjStartNfa_0(int pos, long active0) {
		return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0), pos + 1);
	}

	private final int jjStartNfaWithStates_0(int pos, int kind, int state) {
		jjmatchedKind = kind;
		jjmatchedPos = pos;
		try {
			curChar = input_stream.readChar();
		} catch (final java.io.IOException e) {
			return pos + 1;
		}
		return jjMoveNfa_0(state, pos + 1);
	}

	private final int jjMoveStringLiteralDfa0_0() {
		switch (curChar) {
		case 9:
			return jjStopAtPos(0, 2);
		case 10:
			return jjStopAtPos(0, 3);
		case 12:
			return jjStopAtPos(0, 5);
		case 13:
			return jjStopAtPos(0, 4);
		case 32:
			return jjStopAtPos(0, 1);
		case 40:
			return jjStopAtPos(0, 32);
		case 41:
			return jjStopAtPos(0, 33);
		case 44:
			return jjStopAtPos(0, 39);
		case 46:
			return jjStartNfaWithStates_0(0, 40, 16);
		case 47:
			return jjMoveStringLiteralDfa1_0(0x140L);
		case 58:
			jjmatchedKind = 42;
			return jjMoveStringLiteralDfa1_0(0x20000000000L);
		case 59:
			return jjStopAtPos(0, 38);
		case 61:
			return jjStopAtPos(0, 43);
		case 91:
			return jjStopAtPos(0, 36);
		case 93:
			return jjStopAtPos(0, 37);
		case 102:
			return jjMoveStringLiteralDfa1_0(0x20000L);
		case 103:
			return jjMoveStringLiteralDfa1_0(0x40000L);
		case 110:
			return jjMoveStringLiteralDfa1_0(0x108000L);
		case 115:
			return jjMoveStringLiteralDfa1_0(0x80000L);
		case 116:
			return jjMoveStringLiteralDfa1_0(0x10000L);
		case 123:
			return jjStopAtPos(0, 34);
		case 125:
			return jjStopAtPos(0, 35);
		default:
			return jjMoveNfa_0(3, 0);
		}
	}

	private final int jjMoveStringLiteralDfa1_0(long active0) {
		try {
			curChar = input_stream.readChar();
		} catch (final java.io.IOException e) {
			jjStopStringLiteralDfa_0(0, active0);
			return 1;
		}
		switch (curChar) {
		case 42:
			if ((active0 & 0x100L) != 0L) {
				return jjStartNfaWithStates_0(1, 8, 0);
			}
			break;
		case 47:
			if ((active0 & 0x40L) != 0L) {
				return jjStopAtPos(1, 6);
			}
			break;
		case 58:
			if ((active0 & 0x20000000000L) != 0L) {
				return jjStopAtPos(1, 41);
			}
			break;
		case 97:
			return jjMoveStringLiteralDfa2_0(active0, 0x20000L);
		case 101:
			return jjMoveStringLiteralDfa2_0(active0, 0x1c0000L);
		case 114:
			return jjMoveStringLiteralDfa2_0(active0, 0x10000L);
		case 117:
			return jjMoveStringLiteralDfa2_0(active0, 0x8000L);
		default:
			break;
		}
		return jjStartNfa_0(0, active0);
	}

	private final int jjMoveStringLiteralDfa2_0(long old0, long active0) {
		if (((active0 &= old0)) == 0L) {
			return jjStartNfa_0(0, old0);
		}
		try {
			curChar = input_stream.readChar();
		} catch (final java.io.IOException e) {
			jjStopStringLiteralDfa_0(1, active0);
			return 2;
		}
		switch (curChar) {
		case 108:
			return jjMoveStringLiteralDfa3_0(active0, 0x28000L);
		case 116:
			return jjMoveStringLiteralDfa3_0(active0, 0xc0000L);
		case 117:
			return jjMoveStringLiteralDfa3_0(active0, 0x10000L);
		case 119:
			return jjMoveStringLiteralDfa3_0(active0, 0x100000L);
		default:
			break;
		}
		return jjStartNfa_0(1, active0);
	}

	private final int jjMoveStringLiteralDfa3_0(long old0, long active0) {
		if (((active0 &= old0)) == 0L) {
			return jjStartNfa_0(1, old0);
		}
		try {
			curChar = input_stream.readChar();
		} catch (final java.io.IOException e) {
			jjStopStringLiteralDfa_0(2, active0);
			return 3;
		}
		switch (curChar) {
		case 32:
			if ((active0 & 0x100000L) != 0L) {
				return jjStopAtPos(3, 20);
			}
			break;
		case 58:
			if ((active0 & 0x40000L) != 0L) {
				return jjStopAtPos(3, 18);
			} else if ((active0 & 0x80000L) != 0L) {
				return jjStopAtPos(3, 19);
			}
			break;
		case 101:
			if ((active0 & 0x10000L) != 0L) {
				return jjStartNfaWithStates_0(3, 16, 32);
			}
			break;
		case 108:
			if ((active0 & 0x8000L) != 0L) {
				return jjStartNfaWithStates_0(3, 15, 32);
			}
			break;
		case 115:
			return jjMoveStringLiteralDfa4_0(active0, 0x20000L);
		default:
			break;
		}
		return jjStartNfa_0(2, active0);
	}

	private final int jjMoveStringLiteralDfa4_0(long old0, long active0) {
		if (((active0 &= old0)) == 0L) {
			return jjStartNfa_0(2, old0);
		}
		try {
			curChar = input_stream.readChar();
		} catch (final java.io.IOException e) {
			jjStopStringLiteralDfa_0(3, active0);
			return 4;
		}
		switch (curChar) {
		case 101:
			if ((active0 & 0x20000L) != 0L) {
				return jjStartNfaWithStates_0(4, 17, 32);
			}
			break;
		default:
			break;
		}
		return jjStartNfa_0(3, active0);
	}

	static final long[] jjbitVec0 = { 0xfffffffffffffffeL, 0xffffffffffffffffL,
			0xffffffffffffffffL, 0xffffffffffffffffL };

	static final long[] jjbitVec2 = { 0x0L, 0x0L, 0xffffffffffffffffL,
			0xffffffffffffffffL };

	static final long[] jjbitVec3 = { 0x0L, 0xffffffffffffc000L,
			0xfffff0007fffffffL, 0x12000000007fffffL };

	static final long[] jjbitVec4 = { 0x0L, 0x0L, 0x420043c00000000L,
			0xff7fffffff7fffffL };

	static final long[] jjbitVec5 = { 0xffffffffffffffffL, 0xffffffffffffffffL,
			0xffffffffffffffffL, 0xfc3fffffffffffffL };

	static final long[] jjbitVec6 = { 0xffffffL, 0xffffffffffff0000L,
			0xf9ff01ffffffffffL, 0x1f00030003L };

	static final long[] jjbitVec7 = { 0x0L, 0x400000000000000L,
			0xfffffffbffffd740L, 0xffffd547f7fffL };

	static final long[] jjbitVec8 = { 0xffffffffffffdffeL, 0xffffffffdffeffffL,
			0xffffffffffff0003L, 0x33fcfffffff199fL };

	static final long[] jjbitVec9 = { 0xfffe000000000000L, 0xfffffffe027fffffL,
			0xffL, 0x707ffffff0000L };

	static final long[] jjbitVec10 = { 0x7fffffe00000000L, 0xfffe0000000007ffL,
			0x7cffffffffffffffL, 0x60002f7fffL };

	static final long[] jjbitVec11 = { 0x23ffffffffffffe0L, 0x3ff000000L,
			0x3c5fdfffff99fe0L, 0xf0003b0000000L };

	static final long[] jjbitVec12 = { 0x36dfdfffff987e0L, 0x1c00005e000000L,
			0x23edfdfffffbafe0L, 0x100000000L };

	static final long[] jjbitVec13 = { 0x23cdfdfffff99fe0L, 0x3b0000000L,
			0x3bfc718d63dc7e0L, 0x0L };

	static final long[] jjbitVec14 = { 0x3effdfffffddfe0L, 0x300000000L,
			0x3effdfffffddfe0L, 0x340000000L };

	static final long[] jjbitVec15 = { 0x3fffdfffffddfe0L, 0x300000000L, 0x0L,
			0x0L };

	static final long[] jjbitVec16 = { 0x800d7ffffffffffeL, 0x7fL,
			0x200d6caefef02596L, 0x3000005fL };

	static final long[] jjbitVec17 = { 0x0L, 0x3fffffffeffL, 0x0L, 0x0L };

	static final long[] jjbitVec18 = { 0x0L, 0x0L, 0xffffffff00000000L,
			0x7fffffffff003fL };

	static final long[] jjbitVec19 = { 0xffffffffffffffffL,
			0xffffffff83ffffffL, 0xffffff07ffffffffL, 0x3ffffffffffffffL };

	static final long[] jjbitVec20 = { 0xffffffffffffffffL,
			0xffffffffffffffffL, 0xffffffff0fffffffL, 0x3ffffffffffffffL };

	static final long[] jjbitVec21 = { 0xffffffff3f3fffffL,
			0x3fffffffaaff3f3fL, 0x5fdfffffffffffffL, 0x1fdc1fff0fcf1fdcL };

	static final long[] jjbitVec22 = { 0x8000000000000000L,
			0x8000000000000001L, 0x1fff00000000L, 0x0L };

	static final long[] jjbitVec23 = { 0x1fbfd503f2ffc84L, 0xffffffff00000000L,
			0x7L, 0x0L };

	static final long[] jjbitVec24 = { 0x3e03fe000000a0L, 0xfffffffffffffffeL,
			0xfffffffe781fffffL, 0x77ffffffffffffffL };

	static final long[] jjbitVec25 = { 0xfffe1fffffffffe0L,
			0xffffffffffffffffL, 0x7fffL, 0x0L };

	static final long[] jjbitVec26 = { 0xffffffffffffffffL,
			0xffffffffffffffffL, 0x3fffffffffL, 0x0L };

	static final long[] jjbitVec27 = { 0xffffffffffffffffL,
			0xffffffffffffffffL, 0xfffffffffL, 0x0L };

	static final long[] jjbitVec28 = { 0x3fffffffffffL, 0x0L, 0x0L, 0x0L };

	static final long[] jjbitVec29 = { 0x5f7ffdff80f8007fL,
			0xffffffffffffffdbL, 0x3ffffffffffffL, 0xfffffffffff80000L };

	static final long[] jjbitVec30 = { 0x3fffffffffffffffL,
			0xffffffffffff0000L, 0xfffffffffffcffffL, 0xfff0000000000ffL };

	static final long[] jjbitVec31 = { 0x18000000000000L, 0xffd702000000e000L,
			0xffffffffffffffffL, 0x1fffffffffffffffL };

	static final long[] jjbitVec32 = { 0x87fffffe00000010L,
			0xffffffc007fffffeL, 0x7fffffffffffffffL, 0x31cfcfcfcL };

	static final long[] jjbitVec33 = { 0x0L, 0x0L, 0x420043cffffffffL,
			0xff7fffffff7fffffL };

	static final long[] jjbitVec34 = { 0xffffffffffffffffL, 0x40000030000003fL,
			0xfffffffbffffd740L, 0xffffd547f7fffL };

	static final long[] jjbitVec35 = { 0xffffffffffffdffeL,
			0xffffffffdffeffffL, 0xffffffffffff007bL, 0x33fcfffffff199fL };

	static final long[] jjbitVec36 = { 0xfffe000000000000L,
			0xfffffffe027fffffL, 0xbbfffffbfffe00ffL, 0x707ffffff0016L };

	static final long[] jjbitVec37 = { 0x7fffffe00000000L, 0xffff03ff0007ffffL,
			0x7cffffffffffffffL, 0x3ff3dff9fef7fffL };

	static final long[] jjbitVec38 = { 0xf3ffffffffffffeeL, 0xffcfff1e3fffL,
			0xd3c5fdfffff99feeL, 0xfffcfb080399fL };

	static final long[] jjbitVec39 = { 0xd36dfdfffff987e4L, 0x1fffc05e003987L,
			0xf3edfdfffffbafeeL, 0xffc100003bbfL };

	static final long[] jjbitVec40 = { 0xf3cdfdfffff99feeL, 0xffc3b0c0398fL,
			0xc3bfc718d63dc7ecL, 0xff8000803dc7L };

	static final long[] jjbitVec41 = { 0xc3effdfffffddfeeL, 0xffc300603ddfL,
			0xc3effdfffffddfecL, 0xffc340603ddfL };

	static final long[] jjbitVec42 = { 0xc3fffdfffffddfecL, 0xffc300803dcfL,
			0x0L, 0x0L };

	static final long[] jjbitVec43 = { 0x87ff7ffffffffffeL, 0x3ff7fffL,
			0x3bff6caefef02596L, 0x33ff3f5fL };

	static final long[] jjbitVec44 = { 0xc2a003ff03000000L,
			0xfffe03fffffffeffL, 0x2fe3ffffebf0fdfL, 0x0L };

	static final long[] jjbitVec45 = { 0x80007c000000f000L,
			0x8000fc0000000001L, 0x1fff00000000L, 0x21fff0000L };

	static final long[] jjbitVec46 = { 0x3efffe000000a0L, 0xfffffffffffffffeL,
			0xfffffffe7e1fffffL, 0x77ffffffffffffffL };

	static final long[] jjbitVec47 = { 0x5f7ffdffc0f8007fL,
			0xffffffffffffffdbL, 0x3ffffffffffffL, 0xfffffffffff80000L };

	static final long[] jjbitVec48 = { 0x18000f00000000L, 0xffd702000000e000L,
			0xffffffffffffffffL, 0x9fffffffffffffffL };

	@SuppressWarnings("unused")
	private final int jjMoveNfa_0(int startState, int curPos) {
		int startsAt = 0;
		jjnewStateCnt = 53;
		int i = 1;
		jjstateSet[0] = startState;
		int kind = 0x7fffffff;
		for (;;) {
			if (++jjround == 0x7fffffff) {
				ReInitRounds();
			}
			if (curChar < 64) {
				final long l = 1L << curChar;
				MatchLoop: do {
					switch (jjstateSet[--i]) {
					case 10:
					case 32:
						if ((0x3ff00100fffc1ffL & l) == 0L) {
							break;
						}
						if (kind > 29) {
							kind = 29;
						}
						jjCheckNAdd(32);
						break;
					case 3:
						if ((0xfbffffbfffffffffL & l) != 0L) {
							if (kind > 44) {
								kind = 44;
							}
						}
						if ((0x3ff000000000000L & l) != 0L) {
							jjCheckNAddStates(0, 6);
						} else if (curChar == 36) {
							if (kind > 29) {
								kind = 29;
							}
							jjCheckNAdd(32);
						} else if (curChar == 34) {
							jjCheckNAddStates(7, 9);
						} else if (curChar == 39) {
							jjAddStates(10, 11);
						} else if (curChar == 46) {
							jjCheckNAdd(16);
						} else if (curChar == 47) {
							jjstateSet[jjnewStateCnt++] = 2;
						}
						if ((0x3fe000000000000L & l) != 0L) {
							if (kind > 21) {
								kind = 21;
							}
							jjCheckNAddTwoStates(13, 14);
						} else if (curChar == 48) {
							if (kind > 21) {
								kind = 21;
							}
							jjCheckNAddStates(12, 14);
						}
						break;
					case 0:
						if (curChar == 42) {
							jjstateSet[jjnewStateCnt++] = 1;
						}
						break;
					case 1:
						if (((0xffff7fffffffffffL & l) != 0L) && (kind > 7)) {
							kind = 7;
						}
						break;
					case 2:
						if (curChar == 42) {
							jjstateSet[jjnewStateCnt++] = 0;
						}
						break;
					case 5:
						if ((0x100003600L & l) != 0L) {
							jjAddStates(15, 16);
						}
						break;
					case 12:
						if ((0x3fe000000000000L & l) == 0L) {
							break;
						}
						if (kind > 21) {
							kind = 21;
						}
						jjCheckNAddTwoStates(13, 14);
						break;
					case 13:
						if ((0x3ff000000000000L & l) == 0L) {
							break;
						}
						if (kind > 21) {
							kind = 21;
						}
						jjCheckNAddTwoStates(13, 14);
						break;
					case 15:
						if (curChar == 46) {
							jjCheckNAdd(16);
						}
						break;
					case 16:
						if ((0x3ff000000000000L & l) == 0L) {
							break;
						}
						if (kind > 25) {
							kind = 25;
						}
						jjCheckNAddStates(17, 19);
						break;
					case 18:
						if ((0x280000000000L & l) != 0L) {
							jjCheckNAdd(19);
						}
						break;
					case 19:
						if ((0x3ff000000000000L & l) == 0L) {
							break;
						}
						if (kind > 25) {
							kind = 25;
						}
						jjCheckNAddTwoStates(19, 20);
						break;
					case 21:
						if (curChar == 39) {
							jjAddStates(10, 11);
						}
						break;
					case 22:
						if ((0xffffff7fffffdbffL & l) != 0L) {
							jjCheckNAdd(23);
						}
						break;
					case 23:
						if ((curChar == 39) && (kind > 27)) {
							kind = 27;
						}
						break;
					case 25:
						if ((0x8400000000L & l) != 0L) {
							jjCheckNAdd(23);
						}
						break;
					case 26:
						if (curChar == 34) {
							jjCheckNAddStates(7, 9);
						}
						break;
					case 27:
						if ((0xfffffffbffffdbffL & l) != 0L) {
							jjCheckNAddStates(7, 9);
						}
						break;
					case 29:
						if ((0x8400000000L & l) != 0L) {
							jjCheckNAddStates(7, 9);
						}
						break;
					case 30:
						if ((curChar == 34) && (kind > 28)) {
							kind = 28;
						}
						break;
					case 31:
						if (curChar != 36) {
							break;
						}
						if (kind > 29) {
							kind = 29;
						}
						jjCheckNAdd(32);
						break;
					case 33:
						if (((0xfbffffbfffffffffL & l) != 0L) && (kind > 44)) {
							kind = 44;
						}
						break;
					case 34:
						if ((0x3ff000000000000L & l) != 0L) {
							jjCheckNAddStates(0, 6);
						}
						break;
					case 35:
						if ((0x3ff000000000000L & l) != 0L) {
							jjCheckNAddTwoStates(35, 36);
						}
						break;
					case 36:
						if (curChar != 46) {
							break;
						}
						if (kind > 25) {
							kind = 25;
						}
						jjCheckNAddStates(20, 22);
						break;
					case 37:
						if ((0x3ff000000000000L & l) == 0L) {
							break;
						}
						if (kind > 25) {
							kind = 25;
						}
						jjCheckNAddStates(20, 22);
						break;
					case 39:
						if ((0x280000000000L & l) != 0L) {
							jjCheckNAdd(40);
						}
						break;
					case 40:
						if ((0x3ff000000000000L & l) == 0L) {
							break;
						}
						if (kind > 25) {
							kind = 25;
						}
						jjCheckNAddTwoStates(40, 20);
						break;
					case 41:
						if ((0x3ff000000000000L & l) != 0L) {
							jjCheckNAddTwoStates(41, 42);
						}
						break;
					case 43:
						if ((0x280000000000L & l) != 0L) {
							jjCheckNAdd(44);
						}
						break;
					case 44:
						if ((0x3ff000000000000L & l) == 0L) {
							break;
						}
						if (kind > 25) {
							kind = 25;
						}
						jjCheckNAddTwoStates(44, 20);
						break;
					case 45:
						if ((0x3ff000000000000L & l) != 0L) {
							jjCheckNAddStates(23, 25);
						}
						break;
					case 47:
						if ((0x280000000000L & l) != 0L) {
							jjCheckNAdd(48);
						}
						break;
					case 48:
						if ((0x3ff000000000000L & l) != 0L) {
							jjCheckNAddTwoStates(48, 20);
						}
						break;
					case 49:
						if (curChar != 48) {
							break;
						}
						if (kind > 21) {
							kind = 21;
						}
						jjCheckNAddStates(12, 14);
						break;
					case 51:
						if ((0x3ff000000000000L & l) == 0L) {
							break;
						}
						if (kind > 21) {
							kind = 21;
						}
						jjCheckNAddTwoStates(51, 14);
						break;
					case 52:
						if ((0xff000000000000L & l) == 0L) {
							break;
						}
						if (kind > 21) {
							kind = 21;
						}
						jjCheckNAddTwoStates(52, 14);
						break;
					default:
						break;
					}
				} while (i != startsAt);
			} else if (curChar < 128) {
				final long l = 1L << (curChar & 077);
				MatchLoop: do {
					switch (jjstateSet[--i]) {
					case 10:
						if ((0x87fffffe87fffffeL & l) != 0L) {
							if (kind > 29) {
								kind = 29;
							}
							jjCheckNAdd(32);
						}
						if (curChar == 111) {
							jjstateSet[jjnewStateCnt++] = 9;
						}
						break;
					case 3:
						if (kind > 44) {
							kind = 44;
						}
						if ((0x7fffffe87fffffeL & l) != 0L) {
							if (kind > 29) {
								kind = 29;
							}
							jjCheckNAdd(32);
						}
						if (curChar == 102) {
							jjstateSet[jjnewStateCnt++] = 10;
						}
						break;
					case 1:
						if (kind > 7) {
							kind = 7;
						}
						break;
					case 4:
						if (curChar == 114) {
							jjAddStates(15, 16);
						}
						break;
					case 6:
						if ((curChar == 123) && (kind > 9)) {
							kind = 9;
						}
						break;
					case 7:
						if (curChar == 101) {
							jjstateSet[jjnewStateCnt++] = 4;
						}
						break;
					case 8:
						if (curChar == 116) {
							jjstateSet[jjnewStateCnt++] = 7;
						}
						break;
					case 9:
						if (curChar == 111) {
							jjstateSet[jjnewStateCnt++] = 8;
						}
						break;
					case 11:
						if (curChar == 102) {
							jjstateSet[jjnewStateCnt++] = 10;
						}
						break;
					case 14:
						if (((0x100000001000L & l) != 0L) && (kind > 21)) {
							kind = 21;
						}
						break;
					case 17:
						if ((0x2000000020L & l) != 0L) {
							jjAddStates(26, 27);
						}
						break;
					case 20:
						if (((0x5000000050L & l) != 0L) && (kind > 25)) {
							kind = 25;
						}
						break;
					case 22:
						if ((0xffffffffefffffffL & l) != 0L) {
							jjCheckNAdd(23);
						}
						break;
					case 24:
						if (curChar == 92) {
							jjstateSet[jjnewStateCnt++] = 25;
						}
						break;
					case 25:
						if ((0x14404410000000L & l) != 0L) {
							jjCheckNAdd(23);
						}
						break;
					case 27:
						if ((0xffffffffefffffffL & l) != 0L) {
							jjCheckNAddStates(7, 9);
						}
						break;
					case 28:
						if (curChar == 92) {
							jjstateSet[jjnewStateCnt++] = 29;
						}
						break;
					case 29:
						if ((0x14404410000000L & l) != 0L) {
							jjCheckNAddStates(7, 9);
						}
						break;
					case 31:
						if ((0x7fffffe87fffffeL & l) == 0L) {
							break;
						}
						if (kind > 29) {
							kind = 29;
						}
						jjCheckNAdd(32);
						break;
					case 32:
						if ((0x87fffffe87fffffeL & l) == 0L) {
							break;
						}
						if (kind > 29) {
							kind = 29;
						}
						jjCheckNAdd(32);
						break;
					case 33:
						if (kind > 44) {
							kind = 44;
						}
						break;
					case 38:
						if ((0x2000000020L & l) != 0L) {
							jjAddStates(28, 29);
						}
						break;
					case 42:
						if ((0x2000000020L & l) != 0L) {
							jjAddStates(30, 31);
						}
						break;
					case 46:
						if ((0x2000000020L & l) != 0L) {
							jjAddStates(32, 33);
						}
						break;
					case 50:
						if ((0x100000001000000L & l) != 0L) {
							jjCheckNAdd(51);
						}
						break;
					case 51:
						if ((0x7e0000007eL & l) == 0L) {
							break;
						}
						if (kind > 21) {
							kind = 21;
						}
						jjCheckNAddTwoStates(51, 14);
						break;
					default:
						break;
					}
				} while (i != startsAt);
			} else {
				final int hiByte = (curChar >> 8);
				final int i1 = hiByte >> 6;
				final long l1 = 1L << (hiByte & 077);
				final int i2 = (curChar & 0xff) >> 6;
				final long l2 = 1L << (curChar & 077);
				MatchLoop: do {
					switch (jjstateSet[--i]) {
					case 10:
					case 32:
						if (!IlrTokenManager
								.jjCanMove_2(hiByte, i1, i2, l1, l2)) {
							break;
						}
						if (kind > 29) {
							kind = 29;
						}
						jjCheckNAdd(32);
						break;
					case 3:
						if (IlrTokenManager.jjCanMove_1(hiByte, i1, i2, l1, l2)) {
							if (kind > 29) {
								kind = 29;
							}
							jjCheckNAdd(32);
						}
						if (IlrTokenManager.jjCanMove_0(hiByte, i1, i2, l1, l2)) {
							if (kind > 44) {
								kind = 44;
							}
						}
						break;
					case 1:
						if (IlrTokenManager.jjCanMove_0(hiByte, i1, i2, l1, l2)
								&& (kind > 7)) {
							kind = 7;
						}
						break;
					case 22:
						if (IlrTokenManager.jjCanMove_0(hiByte, i1, i2, l1, l2)) {
							jjstateSet[jjnewStateCnt++] = 23;
						}
						break;
					case 27:
						if (IlrTokenManager.jjCanMove_0(hiByte, i1, i2, l1, l2)) {
							jjAddStates(7, 9);
						}
						break;
					case 31:
						if (!IlrTokenManager
								.jjCanMove_1(hiByte, i1, i2, l1, l2)) {
							break;
						}
						if (kind > 29) {
							kind = 29;
						}
						jjCheckNAdd(32);
						break;
					case 33:
						if (IlrTokenManager.jjCanMove_0(hiByte, i1, i2, l1, l2)
								&& (kind > 44)) {
							kind = 44;
						}
						break;
					default:
						break;
					}
				} while (i != startsAt);
			}
			if (kind != 0x7fffffff) {
				jjmatchedKind = kind;
				jjmatchedPos = curPos;
				kind = 0x7fffffff;
			}
			++curPos;
			if ((i = jjnewStateCnt) == (startsAt = 53 - (jjnewStateCnt = startsAt))) {
				return curPos;
			}
			try {
				curChar = input_stream.readChar();
			} catch (final java.io.IOException e) {
				return curPos;
			}
		}
	}

	static final int[] jjnextStates = { 35, 36, 41, 42, 45, 46, 20, 27, 28, 30,
			22, 24, 50, 52, 14, 5, 6, 16, 17, 20, 37, 38, 20, 45, 46, 20, 18,
			19, 39, 40, 43, 44, 47, 48, };

	private static final boolean jjCanMove_0(int hiByte, int i1, int i2,
			long l1, long l2) {
		switch (hiByte) {
		case 0:
			return ((IlrTokenManager.jjbitVec2[i2] & l2) != 0L);
		default:
			if ((IlrTokenManager.jjbitVec0[i1] & l1) != 0L) {
				return true;
			}
			return false;
		}
	}

	private static final boolean jjCanMove_1(int hiByte, int i1, int i2,
			long l1, long l2) {
		switch (hiByte) {
		case 0:
			return ((IlrTokenManager.jjbitVec4[i2] & l2) != 0L);
		case 1:
			return ((IlrTokenManager.jjbitVec5[i2] & l2) != 0L);
		case 2:
			return ((IlrTokenManager.jjbitVec6[i2] & l2) != 0L);
		case 3:
			return ((IlrTokenManager.jjbitVec7[i2] & l2) != 0L);
		case 4:
			return ((IlrTokenManager.jjbitVec8[i2] & l2) != 0L);
		case 5:
			return ((IlrTokenManager.jjbitVec9[i2] & l2) != 0L);
		case 6:
			return ((IlrTokenManager.jjbitVec10[i2] & l2) != 0L);
		case 9:
			return ((IlrTokenManager.jjbitVec11[i2] & l2) != 0L);
		case 10:
			return ((IlrTokenManager.jjbitVec12[i2] & l2) != 0L);
		case 11:
			return ((IlrTokenManager.jjbitVec13[i2] & l2) != 0L);
		case 12:
			return ((IlrTokenManager.jjbitVec14[i2] & l2) != 0L);
		case 13:
			return ((IlrTokenManager.jjbitVec15[i2] & l2) != 0L);
		case 14:
			return ((IlrTokenManager.jjbitVec16[i2] & l2) != 0L);
		case 15:
			return ((IlrTokenManager.jjbitVec17[i2] & l2) != 0L);
		case 16:
			return ((IlrTokenManager.jjbitVec18[i2] & l2) != 0L);
		case 17:
			return ((IlrTokenManager.jjbitVec19[i2] & l2) != 0L);
		case 30:
			return ((IlrTokenManager.jjbitVec20[i2] & l2) != 0L);
		case 31:
			return ((IlrTokenManager.jjbitVec21[i2] & l2) != 0L);
		case 32:
			return ((IlrTokenManager.jjbitVec22[i2] & l2) != 0L);
		case 33:
			return ((IlrTokenManager.jjbitVec23[i2] & l2) != 0L);
		case 48:
			return ((IlrTokenManager.jjbitVec24[i2] & l2) != 0L);
		case 49:
			return ((IlrTokenManager.jjbitVec25[i2] & l2) != 0L);
		case 159:
			return ((IlrTokenManager.jjbitVec26[i2] & l2) != 0L);
		case 215:
			return ((IlrTokenManager.jjbitVec27[i2] & l2) != 0L);
		case 250:
			return ((IlrTokenManager.jjbitVec28[i2] & l2) != 0L);
		case 251:
			return ((IlrTokenManager.jjbitVec29[i2] & l2) != 0L);
		case 253:
			return ((IlrTokenManager.jjbitVec30[i2] & l2) != 0L);
		case 254:
			return ((IlrTokenManager.jjbitVec31[i2] & l2) != 0L);
		case 255:
			return ((IlrTokenManager.jjbitVec32[i2] & l2) != 0L);
		default:
			if ((IlrTokenManager.jjbitVec3[i1] & l1) != 0L) {
				return true;
			}
			return false;
		}
	}

	private static final boolean jjCanMove_2(int hiByte, int i1, int i2,
			long l1, long l2) {
		switch (hiByte) {
		case 0:
			return ((IlrTokenManager.jjbitVec33[i2] & l2) != 0L);
		case 1:
			return ((IlrTokenManager.jjbitVec5[i2] & l2) != 0L);
		case 2:
			return ((IlrTokenManager.jjbitVec6[i2] & l2) != 0L);
		case 3:
			return ((IlrTokenManager.jjbitVec34[i2] & l2) != 0L);
		case 4:
			return ((IlrTokenManager.jjbitVec35[i2] & l2) != 0L);
		case 5:
			return ((IlrTokenManager.jjbitVec36[i2] & l2) != 0L);
		case 6:
			return ((IlrTokenManager.jjbitVec37[i2] & l2) != 0L);
		case 9:
			return ((IlrTokenManager.jjbitVec38[i2] & l2) != 0L);
		case 10:
			return ((IlrTokenManager.jjbitVec39[i2] & l2) != 0L);
		case 11:
			return ((IlrTokenManager.jjbitVec40[i2] & l2) != 0L);
		case 12:
			return ((IlrTokenManager.jjbitVec41[i2] & l2) != 0L);
		case 13:
			return ((IlrTokenManager.jjbitVec42[i2] & l2) != 0L);
		case 14:
			return ((IlrTokenManager.jjbitVec43[i2] & l2) != 0L);
		case 15:
			return ((IlrTokenManager.jjbitVec44[i2] & l2) != 0L);
		case 16:
			return ((IlrTokenManager.jjbitVec18[i2] & l2) != 0L);
		case 17:
			return ((IlrTokenManager.jjbitVec19[i2] & l2) != 0L);
		case 30:
			return ((IlrTokenManager.jjbitVec20[i2] & l2) != 0L);
		case 31:
			return ((IlrTokenManager.jjbitVec21[i2] & l2) != 0L);
		case 32:
			return ((IlrTokenManager.jjbitVec45[i2] & l2) != 0L);
		case 33:
			return ((IlrTokenManager.jjbitVec23[i2] & l2) != 0L);
		case 48:
			return ((IlrTokenManager.jjbitVec46[i2] & l2) != 0L);
		case 49:
			return ((IlrTokenManager.jjbitVec25[i2] & l2) != 0L);
		case 159:
			return ((IlrTokenManager.jjbitVec26[i2] & l2) != 0L);
		case 215:
			return ((IlrTokenManager.jjbitVec27[i2] & l2) != 0L);
		case 250:
			return ((IlrTokenManager.jjbitVec28[i2] & l2) != 0L);
		case 251:
			return ((IlrTokenManager.jjbitVec47[i2] & l2) != 0L);
		case 253:
			return ((IlrTokenManager.jjbitVec30[i2] & l2) != 0L);
		case 254:
			return ((IlrTokenManager.jjbitVec48[i2] & l2) != 0L);
		case 255:
			return ((IlrTokenManager.jjbitVec32[i2] & l2) != 0L);
		default:
			if ((IlrTokenManager.jjbitVec3[i1] & l1) != 0L) {
				return true;
			}
			return false;
		}
	}

	static final String[] jjstrLiteralImages = { "", null, null, null, null,
			null, null, null, null, null, null, null, null, null, null,
			"\156\165\154\154", "\164\162\165\145", "\146\141\154\163\145",
			"\147\145\164\72", "\163\145\164\72", "\156\145\167\40", null,
			null, null, null, null, null, null, null, null, null, null, "\50",
			"\51", "\173", "\175", "\133", "\135", "\73", "\54", "\56",
			"\72\72", "\72", "\75", null, };

	public static final String[] lexStateNames = { "DEFAULT",
			"IN_SINGLE_LINE_COMMENT", "IN_FORMAL_COMMENT",
			"IN_MULTI_LINE_COMMENT", "IN_FOOTER", };

	static final int[] jjnewLexState = { -1, -1, -1, -1, -1, -1, 1, 2, 3, 4, 0,
			0, 0, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,
			-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, };

	static final long[] jjtoToken = { 0x1fff3a3fa001L, };

	static final long[] jjtoSkip = { 0x1c3eL, };

	static final long[] jjtoSpecial = { 0x1c00L, };

	static final long[] jjtoMore = { 0x43c0L, };

	private CharStream input_stream;

	private final int[] jjrounds = new int[53];

	private final int[] jjstateSet = new int[106];

	StringBuffer image;

	int jjimageLen;

	int lengthOfMatch;

	protected char curChar;

	public IlrTokenManager(CharStream stream) {
		input_stream = stream;
	}

	public IlrTokenManager(CharStream stream, int lexState) {
		this(stream);
		SwitchTo(lexState);
	}

	public void ReInit(CharStream stream) {
		jjmatchedPos = jjnewStateCnt = 0;
		curLexState = defaultLexState;
		input_stream = stream;
		ReInitRounds();
	}

	private final void ReInitRounds() {
		int i;
		jjround = 0x80000001;
		for (i = 53; i-- > 0;) {
			jjrounds[i] = 0x80000000;
		}
	}

	public void ReInit(CharStream stream, int lexState) {
		this.ReInit(stream);
		SwitchTo(lexState);
	}

	public void SwitchTo(int lexState) {
		if ((lexState >= 5) || (lexState < 0)) {
			throw new TokenMgrError("Error: Ignoring invalid lexical state : "
					+ lexState + ". State unchanged.",
					TokenMgrError.INVALID_LEXICAL_STATE);
		} else {
			curLexState = lexState;
		}
	}

	private final Token jjFillToken() {
		final Token t = Token.newToken(jjmatchedKind);
		t.kind = jjmatchedKind;
		final String im = IlrTokenManager.jjstrLiteralImages[jjmatchedKind];
		t.image = (im == null) ? input_stream.GetImage() : im;
		t.beginLine = input_stream.getBeginLine();
		t.beginColumn = input_stream.getBeginColumn();
		t.endLine = input_stream.getEndLine();
		t.endColumn = input_stream.getEndColumn();
		return t;
	}

	int curLexState = 0;

	int defaultLexState = 0;

	int jjnewStateCnt;

	int jjround;

	int jjmatchedPos;

	int jjmatchedKind;

	public final String getEverythingUntilChar( char c ) throws IOException {
    StringBuffer buffer = new StringBuffer();
    try {
      while ( (this.curChar = this.input_stream.readChar()) != c ) {
        buffer.append( this.curChar );
      }
    } catch ( IOException e1 ) {
      throw e1;
      }
    return buffer.toString();
  }
	
	public final Token getNextToken() {
		Token specialToken = null;
		Token matchedToken;
		int curPos = 0;

		EOFLoop: for (;;) {
			try {
				curChar = input_stream.BeginToken();
			} catch (final java.io.IOException e) {
				jjmatchedKind = 0;
				matchedToken = jjFillToken();
				matchedToken.specialToken = specialToken;
				return matchedToken;
			}
			image = null;
			jjimageLen = 0;

			for (;;) {
				switch (curLexState) {
				case 0:
					jjmatchedKind = 0x7fffffff;
					jjmatchedPos = 0;
					curPos = jjMoveStringLiteralDfa0_0();
					break;
				case 1:
					jjmatchedKind = 0x7fffffff;
					jjmatchedPos = 0;
					curPos = jjMoveStringLiteralDfa0_1();
					if ((jjmatchedPos == 0) && (jjmatchedKind > 14)) {
						jjmatchedKind = 14;
					}
					break;
				case 2:
					jjmatchedKind = 0x7fffffff;
					jjmatchedPos = 0;
					curPos = jjMoveStringLiteralDfa0_2();
					if ((jjmatchedPos == 0) && (jjmatchedKind > 14)) {
						jjmatchedKind = 14;
					}
					break;
				case 3:
					jjmatchedKind = 0x7fffffff;
					jjmatchedPos = 0;
					curPos = jjMoveStringLiteralDfa0_3();
					if ((jjmatchedPos == 0) && (jjmatchedKind > 14)) {
						jjmatchedKind = 14;
					}
					break;
				case 4:
					jjmatchedKind = 0x7fffffff;
					jjmatchedPos = 0;
					curPos = jjMoveStringLiteralDfa0_4();
					if ((jjmatchedPos == 0) && (jjmatchedKind > 14)) {
						jjmatchedKind = 14;
					}
					break;
				}
				if (jjmatchedKind != 0x7fffffff) {
					if (jjmatchedPos + 1 < curPos) {
						input_stream.backup(curPos - jjmatchedPos - 1);
					}
					if ((IlrTokenManager.jjtoToken[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L) {
						matchedToken = jjFillToken();
						matchedToken.specialToken = specialToken;
						TokenLexicalActions(matchedToken);
						if (IlrTokenManager.jjnewLexState[jjmatchedKind] != -1) {
							curLexState = IlrTokenManager.jjnewLexState[jjmatchedKind];
						}
						return matchedToken;
					} else if ((IlrTokenManager.jjtoSkip[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L) {
						if ((IlrTokenManager.jjtoSpecial[jjmatchedKind >> 6] & (1L << (jjmatchedKind & 077))) != 0L) {
							matchedToken = jjFillToken();
							if (specialToken == null) {
								specialToken = matchedToken;
							} else {
								matchedToken.specialToken = specialToken;
								specialToken = (specialToken.next = matchedToken);
							}
							SkipLexicalActions(matchedToken);
						} else {
							SkipLexicalActions(null);
						}
						if (IlrTokenManager.jjnewLexState[jjmatchedKind] != -1) {
							curLexState = IlrTokenManager.jjnewLexState[jjmatchedKind];
						}
						continue EOFLoop;
					}
					jjimageLen += jjmatchedPos + 1;
					if (IlrTokenManager.jjnewLexState[jjmatchedKind] != -1) {
						curLexState = IlrTokenManager.jjnewLexState[jjmatchedKind];
					}
					curPos = 0;
					jjmatchedKind = 0x7fffffff;
					try {
						curChar = input_stream.readChar();
						continue;
					} catch (final java.io.IOException e1) {
					}
				}
				int error_line = input_stream.getEndLine();
				int error_column = input_stream.getEndColumn();
				String error_after = null;
				boolean EOFSeen = false;
				try {
					input_stream.readChar();
					input_stream.backup(1);
				} catch (final java.io.IOException e1) {
					EOFSeen = true;
					error_after = curPos <= 1 ? "" : input_stream.GetImage();
					if ((curChar == '\n') || (curChar == '\r')) {
						error_line++;
						error_column = 0;
					} else {
						error_column++;
					}
				}
				if (!EOFSeen) {
					input_stream.backup(1);
					error_after = curPos <= 1 ? "" : input_stream.GetImage();
				}
				throw new TokenMgrError(EOFSeen, curLexState, error_line,
						error_column, error_after, curChar,
						TokenMgrError.LEXICAL_ERROR);
			}
		}
	}

	final void SkipLexicalActions(Token matchedToken) {
		switch (jjmatchedKind) {
		case 11:
			if (image == null) {
				image = new StringBuffer(new String(input_stream
						.GetSuffix(jjimageLen
								+ (lengthOfMatch = jjmatchedPos + 1))));
			} else {
				image.append(input_stream.GetSuffix(jjimageLen
						+ (lengthOfMatch = jjmatchedPos + 1)));
			}
			// Removes the first 3 characters and the last 2 characters
			// from the matched string
			final String sstr = image.toString();
			final int slen = sstr.length();
			matchedToken.image = sstr.substring(3, slen - 2);
			break;
		default:
			break;
		}
	}

	final void TokenLexicalActions(Token matchedToken) {
		switch (jjmatchedKind) {
		case 13:
			if (image == null) {
				image = new StringBuffer(new String(input_stream
						.GetSuffix(jjimageLen
								+ (lengthOfMatch = jjmatchedPos + 1))));
			} else {
				image.append(input_stream.GetSuffix(jjimageLen
						+ (lengthOfMatch = jjmatchedPos + 1)));
			}
			// Removes the first 3 characters and the last 2 characters
			// from the matched string
			final String sstr2 = image.toString();
			// int slen2 = sstr2.length();
			final int i1 = sstr2.indexOf('{');
			final String sss = sstr2.substring(i1 + 1);
			matchedToken.image = sss.substring(0, sss.length() - 2);
			break;
		case 27:
			if (image == null) {
				image = new StringBuffer(new String(input_stream
						.GetSuffix(jjimageLen
								+ (lengthOfMatch = jjmatchedPos + 1))));
			} else {
				image.append(input_stream.GetSuffix(jjimageLen
						+ (lengthOfMatch = jjmatchedPos + 1)));
			}
			final String cstr = image.toString();
			final int clen = cstr.length();
			matchedToken.image = cstr.substring(1, clen - 1);
			break;
		case 28:
			if (image == null) {
				image = new StringBuffer(new String(input_stream
						.GetSuffix(jjimageLen
								+ (lengthOfMatch = jjmatchedPos + 1))));
			} else {
				image.append(input_stream.GetSuffix(jjimageLen
						+ (lengthOfMatch = jjmatchedPos + 1)));
			}
			final String sstr = image.toString();
			final int slen = sstr.length();
			matchedToken.image = sstr.substring(1, slen - 1);
			break;
		default:
			break;
		}
	}
}
