//##header J2SE15
/*
 *******************************************************************************
 * Copyright (C) 1996-2007, International Business Machines Corporation and    *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 */

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:30 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Text {
	
	using IBM.ICU.Impl;
	using IBM.ICU.Util;
	using ILOG.J2CsMapping.Collections;
	using ILOG.J2CsMapping.Collections.Generics;
	using ILOG.J2CsMapping.IO;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.Globalization;
	using System.IO;
	using System.Resources;
	using System.Runtime.CompilerServices;
	using System.Text;
     using ILOG.J2CsMapping.Text;
     using ILOG.J2CsMapping.Util;
     using ILOG.J2CsMapping.Formatting;
	
	/// <summary>
	/// <c>NumberFormat</c> is the abstract base class for all number formats.
	/// This class provides the interface for formatting and parsing numbers.
	/// <c>NumberFormat</c> also provides methods for determining which locales
	/// have number formats, and what their names are.
	/// <p>
	/// <strong>This is an enhanced version of <c>NumberFormat</c> that is
	/// based on the standard version in the JDK. New or changed functionality is
	/// labeled <strong><font face=helvetica color=red>NEW</font></strong> or
	/// <strong><font face=helvetica color=red>CHANGED</font></strong>.</strong>
	/// <p>
	/// <c>NumberFormat</c> helps you to format and parse numbers for any
	/// locale. Your code can be completely independent of the locale conventions for
	/// decimal points, thousands-separators, or even the particular decimal digits
	/// used, or whether the number format is even decimal.
	/// <p>
	/// To format a number for the current Locale, use one of the factory class
	/// methods: <blockquote>
	/// <pre>
	/// myString = NumberFormat.getInstance().format(myNumber);
	/// </pre>
	/// </blockquote> If you are formatting multiple numbers, it is more efficient to
	/// get the format and use it multiple times so that the system doesn't have to
	/// fetch the information about the local language and country conventions
	/// multiple times. <blockquote>
	/// <pre>
	/// NumberFormat nf = NumberFormat.getInstance();
	/// for (int i = 0; i &lt; a.length; ++i) {
	/// output.println(nf.format(myNumber[i]) + &quot;; &quot;);
	/// }
	/// </pre>
	/// </blockquote> To format a number for a different Locale, specify it in the
	/// call to <c>getInstance</c>. <blockquote>
	/// <pre>
	/// NumberFormat nf = NumberFormat.getInstance(Locale.FRENCH);
	/// </pre>
	/// </blockquote> You can also use a <c>NumberFormat</c> to parse numbers:
	/// <blockquote>
	/// <pre>
	/// myNumber = nf.parse(myString);
	/// </pre>
	/// </blockquote> Use <c>getInstance</c> or <c>getNumberInstance</c>
	/// to get the normal number format. Use <c>getIntegerInstance</c> to get
	/// an integer number format. Use <c>getCurrencyInstance</c> to get the
	/// currency number format. And use <c>getPercentInstance</c> to get a
	/// format for displaying percentages. With this format, a fraction like 0.53 is
	/// displayed as 53%.
	/// <p>
	/// You can also control the display of numbers with such methods as
	/// <c>setMinimumFractionDigits</c>. If you want even more control over the
	/// format or parsing, or want to give your users more control, you can try
	/// casting the <c>NumberFormat</c> you get from the factory methods to a
	/// <c>DecimalFormat</c>. This will work for the vast majority of locales;
	/// just remember to put it in a <c>try</c> block in case you encounter an
	/// unusual one.
	/// <p>
	/// NumberFormat is designed such that some controls work for formatting and
	/// others work for parsing. The following is the detailed description for each
	/// these control methods,
	/// <p>
	/// setParseIntegerOnly : only affects parsing, e.g. if true, "3456.78" -> 3456
	/// (and leaves the parse position just after '6') if false, "3456.78" -> 3456.78
	/// (and leaves the parse position just after '8') This is independent of
	/// formatting. If you want to not show a decimal point where there might be no
	/// digits after the decimal point, use setDecimalSeparatorAlwaysShown on
	/// DecimalFormat.
	/// <p>
	/// You can also use forms of the <c>parse</c> and <c>format</c>
	/// methods with <c>ParsePosition</c> and <c>FieldPosition</c> to
	/// allow you to:
	/// <ul>
	/// <li>progressively parse through pieces of a string
	/// <li>align the decimal point and other areas
	/// </ul>
	/// For example, you can align numbers in two ways:
	/// <ol>
	/// <li>If you are using a monospaced font with spacing for alignment, you can
	/// pass the <c>FieldPosition</c> in your format call, with
	/// <c>field</c> = <c>INTEGER_FIELD</c>. On output,
	/// <c>getEndIndex</c> will be set to the offset between the last character
	/// of the integer and the decimal. Add (desiredSpaceCount - getEndIndex) spaces
	/// at the front of the string.
	/// <li>If you are using proportional fonts, instead of padding with spaces,
	/// measure the width of the string in pixels from the start to
	/// <c>getEndIndex</c>. Then move the pen by (desiredPixelWidth -
	/// widthToAlignmentPoint) before drawing the text. It also works where there is
	/// no decimal, but possibly additional characters at the end, e.g., with
	/// parentheses in negative numbers: "(12)" for -12.
	/// </ol>
	/// <h4>Synchronization</h4>
	/// <p>
	/// Number formats are generally not synchronized. It is recommended to create
	/// separate format instances for each thread. If multiple threads access a
	/// format concurrently, it must be synchronized externally.
	/// <p>
	/// <h4>DecimalFormat</h4>
	/// <p>
	/// DecimalFormat is the concrete implementation of NumberFormat, and the
	/// NumberFormat API is essentially an abstraction from DecimalFormat's API.
	/// Refer to DecimalFormat for more information about this API.
	/// </p>
	/// see DecimalFormat see java.text.ChoiceFormat
	/// </summary>
	///
	/// @stable ICU 2.0
	public abstract class NumberFormat : UFormat {
	
	    // Constants used by factory methods to specify a style of format.
	    private const int NUMBERSTYLE = 0;
	
	    private const int CURRENCYSTYLE = 1;
	
	    private const int PERCENTSTYLE = 2;
	
	    private const int SCIENTIFICSTYLE = 3;
	
	    private const int INTEGERSTYLE = 4;
	
	    /// <summary>
	    /// Field constant used to construct a FieldPosition object. Signifies that
	    /// the position of the integer part of a formatted number should be
	    /// returned.
	    /// </summary>
	    ///
	    /// <seealso cref="T:IBM.ICU.Text.FieldPosition"/>
	    /// @stable ICU 2.0
	    public const int INTEGER_FIELD = 0;
	
	    /// <summary>
	    /// Field constant used to construct a FieldPosition object. Signifies that
	    /// the position of the fraction part of a formatted number should be
	    /// returned.
	    /// </summary>
	    ///
	    /// <seealso cref="T:IBM.ICU.Text.FieldPosition"/>
	    /// @stable ICU 2.0
	    public const int FRACTION_FIELD = 1;
	
	    /// <summary>
	    /// <strong><font face=helvetica color=red>CHANGED</font></strong> Format an
	    /// object. Change: recognizes <c>BigInteger</c> and
	    /// <c>BigDecimal</c> objects.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public override StringBuilder FormatObject(Object number, StringBuilder toAppendTo,
	            FieldPosition pos) {
	        if (number  is  Int64) {
	            return Format(((Int64) number), toAppendTo, pos);
	        } else if (number  is  Int64) {
	            return Format((Int64) number, toAppendTo, pos);
	            // #if defined(FOUNDATION10) || defined(J2SE13)
	            // #else
	        } else if (number  is  Decimal) {
	            return Format((Decimal) number, toAppendTo, pos);
	            // #endif
	        } else if (number  is  IBM.ICU.Math.BigDecimal) {
	            return Format((IBM.ICU.Math.BigDecimal) number, toAppendTo, pos);
	        } else if (number  is  CurrencyAmount) {
	            return Format((CurrencyAmount) number, toAppendTo, pos);
	        } else if (number  is  ValueType) {
	            return Format(Convert.ToDouble(((object) number)), toAppendTo, pos);
	        } else {
	            throw new ArgumentException(
	                    "Cannot format given Object as a Number");
	        }
	    }
	
	    
	    /// @stable ICU 2.0
	    public sealed override Object ParseObject(String source, ParsePosition parsePosition) {
	        return Parse(source, parsePosition);
	    }
	
	    /// <summary>
	    /// Specialization of format.
	    /// </summary>
	    ///
	    /// <seealso cref="M:ILOG.J2CsMapping.Text.IlFormat.Format(System.Object)"/>
	    /// @stable ICU 2.0
	    public String Format(double number) {
	        return Format(number, new StringBuilder(), new FieldPosition(0))
	                .ToString();
	    }
	
	    /// <summary>
	    /// Specialization of format.
	    /// </summary>
	    ///
	    /// <seealso cref="M:ILOG.J2CsMapping.Text.IlFormat.Format(System.Object)"/>
	    /// @stable ICU 2.0
	    public String Format(long number) {
	        StringBuilder buf = new StringBuilder(19);
	        FieldPosition pos = new FieldPosition(0);
	        Format(number, buf, pos);
	        return buf.ToString();
	    }
	
	    /// <summary>
	    /// <strong><font face=helvetica color=red>NEW</font></strong> Convenience
	    /// method to format a BigInteger.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public String FormatObject(Int64 number) {
	        return Format(number, new StringBuilder(), new FieldPosition(0))
	                .ToString();
	    }
	
	    // #if defined(FOUNDATION10) || defined(J2SE13)
	    // #else
	    /// <summary>
	    /// <strong><font face=helvetica color=red>NEW</font></strong> Convenience
	    /// method to format a BigDecimal.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public String Format(Decimal number) {
	        return Format(number, new StringBuilder(), new FieldPosition(0))
	                .ToString();
	    }
	
	    // #endif
	
	    /// <summary>
	    /// <strong><font face=helvetica color=red>NEW</font></strong> Convenience
	    /// method to format an ICU BigDecimal.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public String Format(IBM.ICU.Math.BigDecimal number) {
	        return Format(number, new StringBuilder(), new FieldPosition(0))
	                .ToString();
	    }
	
	    /// <summary>
	    /// <strong><font face=helvetica color=red>NEW</font></strong> Convenience
	    /// method to format a CurrencyAmount.
	    /// </summary>
	    ///
	    /// @stable ICU 3.0
	    public String Format(CurrencyAmount currAmt) {
	        return Format(currAmt, new StringBuilder(), new FieldPosition(0))
	                .ToString();
	    }
	
	    /// <summary>
	    /// Specialization of format.
	    /// </summary>
	    ///
	    /// <seealso cref="M:ILOG.J2CsMapping.Text.IlFormat.Format(System.Object, System.Text.StringBuilder, null)"/>
	    /// @stable ICU 2.0
	    public abstract StringBuilder Format(double number, StringBuilder toAppendTo,
	            FieldPosition pos);
	
	    /// <summary>
	    /// Specialization of format.
	    /// </summary>
	    ///
	    /// <seealso cref="M:ILOG.J2CsMapping.Text.IlFormat.Format(System.Object, System.Text.StringBuilder, null)"/>
	    /// @stable ICU 2.0
	    public abstract StringBuilder Format(long number, StringBuilder toAppendTo,
	            FieldPosition pos);
	
	    /// <summary>
	    /// <strong><font face=helvetica color=red>NEW</font></strong> Format a
	    /// BigInteger.
	    /// </summary>
	    ///
	    /// <seealso cref="M:ILOG.J2CsMapping.Text.IlFormat.Format(System.Object, System.Text.StringBuilder, null)"/>
	    /// @stable ICU 2.0
	    public abstract StringBuilder FormatObject(Int64 number,
	            StringBuilder toAppendTo, FieldPosition pos);
	
	    // #if defined(FOUNDATION10) || defined(J2SE13)
	    // #else
	    /// <summary>
	    /// <strong><font face=helvetica color=red>NEW</font></strong> Format a
	    /// BigDecimal.
	    /// </summary>
	    ///
	    /// <seealso cref="M:ILOG.J2CsMapping.Text.IlFormat.Format(System.Object, System.Text.StringBuilder, null)"/>
	    /// @stable ICU 2.0
	    public abstract StringBuilder Format(Decimal number,
	            StringBuilder toAppendTo, FieldPosition pos);
	
	    // #endif
	
	    /// <summary>
	    /// <strong><font face=helvetica color=red>NEW</font></strong> Format a
	    /// BigDecimal.
	    /// </summary>
	    ///
	    /// <seealso cref="M:ILOG.J2CsMapping.Text.IlFormat.Format(System.Object, System.Text.StringBuilder, null)"/>
	    /// @stable ICU 2.0
	    public abstract StringBuilder Format(IBM.ICU.Math.BigDecimal number,
	            StringBuilder toAppendTo, FieldPosition pos);
	
	    /// <summary>
	    /// <strong><font face=helvetica color=red>NEW</font></strong> Format a
	    /// CurrencyAmount.
	    /// </summary>
	    ///
	    /// <seealso cref="M:ILOG.J2CsMapping.Text.IlFormat.Format(System.Object, System.Text.StringBuilder, null)"/>
	    /// @stable ICU 3.0
	    public StringBuilder Format(CurrencyAmount currAmt, StringBuilder toAppendTo,
	            FieldPosition pos) {
	        // Default implementation -- subclasses may override
	        Currency save = GetCurrency(), curr = currAmt.GetCurrency();
	        bool same = curr.Equals(save);
	        if (!same)
	            SetCurrency(curr);
	        FormatObject(currAmt.GetNumber(), toAppendTo, pos);
	        if (!same)
	            SetCurrency(save);
	        return toAppendTo;
	    }
	
	    /// <summary>
	    /// Returns a Long if possible (e.g., within the range [Long.MIN_VALUE,
	    /// Long.MAX_VALUE] and with no decimals), otherwise a Double. If IntegerOnly
	    /// is set, will stop at a decimal point (or equivalent; e.g., for rational
	    /// numbers "1 2/3", will stop after the 1). Does not throw an exception; if
	    /// no object can be parsed, index is unchanged!
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.NumberFormat.IsParseIntegerOnly"/>
	    /// <seealso cref="M:ILOG.J2CsMapping.Text.IlFormat.ParseObject(System.String, null)"/>
	    /// @stable ICU 2.0
	    public abstract object Parse(String text, ParsePosition parsePosition);
	
	    /// <summary>
	    /// Parses text from the beginning of the given string to produce a number.
	    /// The method might not use the entire text of the given string.
	    /// </summary>
	    ///
	    /// <param name="text">A String whose beginning should be parsed.</param>
	    /// <returns>A Number parsed from the string.</returns>
	    /// <exception cref="ParseException">if the beginning of the specified string cannot be parsed.</exception>
	    /// <seealso cref="M:IBM.ICU.Text.NumberFormat.Format(System.Object, System.Text.StringBuilder, null)"/>
	    /// @stable ICU 2.0
	    // Bug 4375399 [Richard/GCL]
	    public object Parse(String text) {
	        ParsePosition parsePosition = new ParsePosition(0);
	        object result = Parse(text, parsePosition);
	        if (parsePosition.GetIndex() == 0) {
	            throw new ILOG.J2CsMapping.Util.ParseException("Unparseable number: \"" + text + '"'+parsePosition.GetErrorIndex());
	        }
	        return result;
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// <strong><font face=helvetica color=red>NEW</font></strong> Parses text
	    /// from the given string as a CurrencyAmount. Unlike the parse() method,
	    /// this method will attempt to parse a generic currency name, searching for
	    /// a match of this object's locale's currency display names, or for a
	    /// 3-letter ISO currency code. This method will fail if this format is not a
	    /// currency format, that is, if it does not contain the currency pattern
	    /// symbol (U+00A4) in its prefix or suffix.
	    /// </summary>
	    ///
	    /// <param name="text">the string to parse</param>
	    /// <param name="pos">input-output position; on input, the position within text tomatch; must have 0 <= pos.getIndex() < text.length(); onoutput, the position after the last matched character. If theparse fails, the position in unchanged upon output.</param>
	    /// <returns>a CurrencyAmount, or null upon failure</returns>
	    internal virtual CurrencyAmount ParseCurrency(String text, ParsePosition pos) {
	        // Default implementation only -- subclasses should override
	        object n = Parse(text, pos);
	        return (n == null) ? null : new CurrencyAmount(n, GetEffectiveCurrency());
	    }
	
	    /// <summary>
	    /// Returns true if this format will parse numbers as integers only. For
	    /// example in the English locale, with ParseIntegerOnly true, the string
	    /// "1234." would be parsed as the integer value 1234 and parsing would stop
	    /// at the "." character. The decimal separator accepted by the parse
	    /// operation is locale-dependent and determined by the subclass.
	    /// </summary>
	    ///
	    /// <returns>true if this will parse integers only</returns>
	    /// @stable ICU 2.0
	    public bool IsParseIntegerOnly() {
	        return parseIntegerOnly;
	    }
	
	    /// <summary>
	    /// Sets whether or not numbers should be parsed as integers only.
	    /// </summary>
	    ///
	    /// <param name="value">true if this should parse integers only</param>
	    /// <seealso cref="M:IBM.ICU.Text.NumberFormat.IsParseIntegerOnly"/>
	    /// @stable ICU 2.0
	    public void SetParseIntegerOnly(bool value_ren) {
	        parseIntegerOnly = value_ren;
	    }
	
	    /// <summary>
	    /// Sets whether strict parsing is in effect. When this is true, the
	    /// following conditions cause a parse failure (examples use the pattern
	    /// "#,##0.#"):
	    /// <ul>
	    /// <li>Leading zeros<br>
	    /// '00', '0123' fail the parse, but '0' and '0.001' pass</li>
	    /// <li>Leading or doubled grouping separators<br>
	    /// ',123' and '1,,234" fail</li>
	    /// <li>Groups of incorrect length when grouping is used<br>
	    /// '1,23' and '1234,567' fail, but '1234' passes</li>
	    /// <li>Grouping separators used in numbers followed by exponents<br>
	    /// '1,234E5' fails, but '1234E5' and '1,234E' pass ('E' is not an exponent
	    /// when not followed by a number)</li>
	    /// </ul>
	    /// When strict parsing is off, leading zeros and all grouping separators are
	    /// ignored. This is the default behavior.
	    /// </summary>
	    ///
	    /// <param name="value">True to enable strict parsing. Default is false.</param>
	    /// <seealso cref="M:IBM.ICU.Text.NumberFormat.IsParseStrict"/>
	    /// @draft ICU 3.6
	    /// @provisional This API might change or be removed in a future release.
	    public void SetParseStrict(bool value_ren) {
	        parseStrict = value_ren;
	    }
	
	    /// <summary>
	    /// Return whether strict parsing is in effect.
	    /// </summary>
	    ///
	    /// <returns>true if strict parsing is in effect</returns>
	    /// <seealso cref="M:IBM.ICU.Text.NumberFormat.SetParseStrict(System.Boolean)"/>
	    /// @draft ICU 3.6
	    /// @provisional This API might change or be removed in a future release.
	    public bool IsParseStrict() {
	        return parseStrict;
	    }
	
	    // ============== Locale Stuff =====================
	
	    /// <summary>
	    /// Returns the default number format for the current default locale. The
	    /// default format is one of the styles provided by the other factory
	    /// methods: getNumberInstance, getIntegerInstance, getCurrencyInstance or
	    /// getPercentInstance. Exactly which one is locale-dependent.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    // Bug 4408066 [Richard/GCL]
	    public static NumberFormat GetInstance() {
	        return GetInstance(IBM.ICU.Util.ULocale.GetDefault(), NUMBERSTYLE);
	    }
	
	    /// <summary>
	    /// Returns the default number format for the specified locale. The default
	    /// format is one of the styles provided by the other factory methods:
	    /// getNumberInstance, getCurrencyInstance or getPercentInstance. Exactly
	    /// which one is locale-dependent.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
        public static NumberFormat GetInstance(Locale inLocale)
        {
	        return GetInstance(IBM.ICU.Util.ULocale.ForLocale(inLocale), NUMBERSTYLE);
	    }
	
	    /// <summary>
	    /// Returns the default number format for the specified locale. The default
	    /// format is one of the styles provided by the other factory methods:
	    /// getNumberInstance, getCurrencyInstance or getPercentInstance. Exactly
	    /// which one is locale-dependent.
	    /// </summary>
	    ///
	    /// @stable ICU 3.2
	    public static NumberFormat GetInstance(ULocale inLocale) {
	        return GetInstance(inLocale, NUMBERSTYLE);
	    }
	
	    /// <summary>
	    /// Returns a general-purpose number format for the current default locale.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public static NumberFormat GetNumberInstance() {
	        return GetInstance(IBM.ICU.Util.ULocale.GetDefault(), NUMBERSTYLE);
	    }
	
	    /// <summary>
	    /// Returns a general-purpose number format for the specified locale.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
        public static NumberFormat GetNumberInstance(Locale inLocale)
        {
	        return GetInstance(IBM.ICU.Util.ULocale.ForLocale(inLocale), NUMBERSTYLE);
	    }
	
	    /// <summary>
	    /// Returns a general-purpose number format for the specified locale.
	    /// </summary>
	    ///
	    /// @stable ICU 3.2
	    public static NumberFormat GetNumberInstance(ULocale inLocale) {
	        return GetInstance(inLocale, NUMBERSTYLE);
	    }
	
	    /// <summary>
	    /// Returns an integer number format for the current default locale. The
	    /// returned number format is configured to round floating point numbers to
	    /// the nearest integer using IEEE half-even rounding (see<see cref="M:IBM.ICU.Text.BigDecimal.ROUND_HALF_EVEN ROUND_HALF_EVEN"/>) for
	    /// formatting, and to parse only the integer part of an input string (see<see cref="M:IBM.ICU.Text.NumberFormat.IsParseIntegerOnly isParseIntegerOnly"/>).
	    /// </summary>
	    ///
	    /// <returns>a number format for integer values</returns>
	    /// @stable ICU 2.0
	    // Bug 4408066 [Richard/GCL]
	    public static NumberFormat GetIntegerInstance() {
	        return GetInstance(IBM.ICU.Util.ULocale.GetDefault(), INTEGERSTYLE);
	    }
	
	    /// <summary>
	    /// Returns an integer number format for the specified locale. The returned
	    /// number format is configured to round floating point numbers to the
	    /// nearest integer using IEEE half-even rounding (see<see cref="M:IBM.ICU.Text.BigDecimal.ROUND_HALF_EVEN ROUND_HALF_EVEN"/>) for
	    /// formatting, and to parse only the integer part of an input string (see<see cref="M:IBM.ICU.Text.NumberFormat.IsParseIntegerOnly isParseIntegerOnly"/>).
	    /// </summary>
	    ///
	    /// <param name="inLocale">the locale for which a number format is needed</param>
	    /// <returns>a number format for integer values</returns>
	    /// @stable ICU 2.0
	    // Bug 4408066 [Richard/GCL]
        public static NumberFormat GetIntegerInstance(Locale inLocale)
        {
	        return GetInstance(IBM.ICU.Util.ULocale.ForLocale(inLocale), INTEGERSTYLE);
	    }
	
	    /// <summary>
	    /// Returns an integer number format for the specified locale. The returned
	    /// number format is configured to round floating point numbers to the
	    /// nearest integer using IEEE half-even rounding (see<see cref="M:IBM.ICU.Text.BigDecimal.ROUND_HALF_EVEN ROUND_HALF_EVEN"/>) for
	    /// formatting, and to parse only the integer part of an input string (see<see cref="M:IBM.ICU.Text.NumberFormat.IsParseIntegerOnly isParseIntegerOnly"/>).
	    /// </summary>
	    ///
	    /// <param name="inLocale">the locale for which a number format is needed</param>
	    /// <returns>a number format for integer values</returns>
	    /// @stable ICU 3.2
	    public static NumberFormat GetIntegerInstance(ULocale inLocale) {
	        return GetInstance(inLocale, INTEGERSTYLE);
	    }
	
	    /// <summary>
	    /// Returns a currency format for the current default locale.
	    /// </summary>
	    ///
	    /// <returns>a number format for currency</returns>
	    /// @stable ICU 2.0
	    public static NumberFormat GetCurrencyInstance() {
	        return GetInstance(IBM.ICU.Util.ULocale.GetDefault(), CURRENCYSTYLE);
	    }
	
	    /// <summary>
	    /// Returns a currency format for the specified locale.
	    /// </summary>
	    ///
	    /// <returns>a number format for currency</returns>
	    /// @stable ICU 2.0
        public static NumberFormat GetCurrencyInstance(Locale inLocale)
        {
	        return GetInstance(IBM.ICU.Util.ULocale.ForLocale(inLocale), CURRENCYSTYLE);
	    }
	
	    /// <summary>
	    /// Returns a currency format for the specified locale.
	    /// </summary>
	    ///
	    /// <returns>a number format for currency</returns>
	    /// @stable ICU 3.2
	    public static NumberFormat GetCurrencyInstance(ULocale inLocale) {
	        return GetInstance(inLocale, CURRENCYSTYLE);
	    }
	
	    /// <summary>
	    /// Returns a percentage format for the current default locale.
	    /// </summary>
	    ///
	    /// <returns>a number format for percents</returns>
	    /// @stable ICU 2.0
	    public static NumberFormat GetPercentInstance() {
	        return GetInstance(IBM.ICU.Util.ULocale.GetDefault(), PERCENTSTYLE);
	    }
	
	    /// <summary>
	    /// Returns a percentage format for the specified locale.
	    /// </summary>
	    ///
	    /// <returns>a number format for percents</returns>
	    /// @stable ICU 2.0
        public static NumberFormat GetPercentInstance(Locale inLocale)
        {
	        return GetInstance(IBM.ICU.Util.ULocale.ForLocale(inLocale), PERCENTSTYLE);
	    }
	
	    /// <summary>
	    /// Returns a percentage format for the specified locale.
	    /// </summary>
	    ///
	    /// <returns>a number format for percents</returns>
	    /// @stable ICU 3.2
	    public static NumberFormat GetPercentInstance(ULocale inLocale) {
	        return GetInstance(inLocale, PERCENTSTYLE);
	    }
	
	    /// <summary>
	    /// <strong><font face=helvetica color=red>NEW</font></strong> Returns a
	    /// scientific format for the current default locale.
	    /// </summary>
	    ///
	    /// <returns>a scientific number format</returns>
	    /// @stable ICU 2.0
	    public static NumberFormat GetScientificInstance() {
	        return GetInstance(IBM.ICU.Util.ULocale.GetDefault(), SCIENTIFICSTYLE);
	    }
	
	    /// <summary>
	    /// <strong><font face=helvetica color=red>NEW</font></strong> Returns a
	    /// scientific format for the specified locale.
	    /// </summary>
	    ///
	    /// <returns>a scientific number format</returns>
	    /// @stable ICU 2.0
        public static NumberFormat GetScientificInstance(Locale inLocale)
        {
	        return GetInstance(IBM.ICU.Util.ULocale.ForLocale(inLocale), SCIENTIFICSTYLE);
	    }
	
	    /// <summary>
	    /// <strong><font face=helvetica color=red>NEW</font></strong> Returns a
	    /// scientific format for the specified locale.
	    /// </summary>
	    ///
	    /// <returns>a scientific number format</returns>
	    /// @stable ICU 3.2
	    public static NumberFormat GetScientificInstance(ULocale inLocale) {
	        return GetInstance(inLocale, SCIENTIFICSTYLE);
	    }
	
	    // ===== Factory stuff =====
	    /// <summary>
	    /// A NumberFormatFactory is used to register new number formats. The factory
	    /// should be able to create any of the predefined formats for each locale it
	    /// supports. When registered, the locales it supports extend or override the
	    /// locales already supported by ICU.
	    /// <p>
	    /// <b>Note:</b> as of ICU4J 3.2, the default API for NumberFormatFactory
	    /// uses ULocale instead of Locale. Instead of overriding
	    /// createFormat(Locale, int), new implementations should override
	    /// createFactory(ULocale, int). Note that one of these two methods
	    /// <b>MUST</b> be overridden or else an infinite loop will occur.
	    /// </summary>
	    ///
	    /// @stable ICU 2.6
	    public abstract class NumberFormatFactory {
	        /// <summary>
	        /// Value passed to format requesting a default number format.
	        /// </summary>
	        ///
	        /// @stable ICU 2.6
	        public const int FORMAT_NUMBER = IBM.ICU.Text.NumberFormat.NUMBERSTYLE;
	
	        /// <summary>
	        /// Value passed to format requesting a currency format.
	        /// </summary>
	        ///
	        /// @stable ICU 2.6
	        public const int FORMAT_CURRENCY = IBM.ICU.Text.NumberFormat.CURRENCYSTYLE;
	
	        /// <summary>
	        /// Value passed to format requesting a percent format.
	        /// </summary>
	        ///
	        /// @stable ICU 2.6
	        public const int FORMAT_PERCENT = IBM.ICU.Text.NumberFormat.PERCENTSTYLE;
	
	        /// <summary>
	        /// Value passed to format requesting a scientific format.
	        /// </summary>
	        ///
	        /// @stable ICU 2.6
	        public const int FORMAT_SCIENTIFIC = IBM.ICU.Text.NumberFormat.SCIENTIFICSTYLE;
	
	        /// <summary>
	        /// Value passed to format requesting an integer format.
	        /// </summary>
	        ///
	        /// @stable ICU 2.6
	        public const int FORMAT_INTEGER = IBM.ICU.Text.NumberFormat.INTEGERSTYLE;
	
	        /// <summary>
	        /// Returns true if this factory is visible. Default is true. If not
	        /// visible, the locales supported by this factory will not be listed by
	        /// getAvailableLocales. This value must not change.
	        /// </summary>
	        ///
	        /// <returns>true if the factory is visible.</returns>
	        /// @stable ICU 2.6
	        // /CLOVER:OFF
	        public virtual bool Visible() {
	            return true;
	        }
	
	        // /CLOVER:ON
	
	        /// <summary>
	        /// Returns an immutable collection of the locale names directly
	        /// supported by this factory.
	        /// </summary>
	        ///
	        /// <returns>the supported locale names.</returns>
	        /// @stable ICU 2.6
	        public abstract ILOG.J2CsMapping.Collections.ISet GetSupportedLocaleNames();
	
	        /// <summary>
	        /// Returns a number format of the appropriate type. If the locale is not
	        /// supported, return null. If the locale is supported, but the type is
	        /// not provided by this service, return null. Otherwise return an
	        /// appropriate instance of NumberFormat. <b>Note:</b> as of ICU4J 3.2,
	        /// implementations should override this method instead of
	        /// createFormat(Locale, int).
	        /// </summary>
	        ///
	        /// <param name="loc">the locale for which to create the format</param>
	        /// <param name="formatType">the type of format</param>
	        /// <returns>the NumberFormat, or null.</returns>
	        /// @stable ICU 3.2
	        public virtual NumberFormat CreateFormat(ULocale loc, int formatType) {
	            return CreateFormat(loc.ToLocale(), formatType);
	        }
	
	        /// <summary>
	        /// Returns a number format of the appropriate type. If the locale is not
	        /// supported, return null. If the locale is supported, but the type is
	        /// not provided by this service, return null. Otherwise return an
	        /// appropriate instance of NumberFormat. <b>Note:</b> as of ICU4J 3.2,
	        /// createFormat(ULocale, int) should be overridden instead of this
	        /// method. This method is no longer abstract and delegates to that
	        /// method.
	        /// </summary>
	        ///
	        /// <param name="loc">the locale for which to create the format</param>
	        /// <param name="formatType">the type of format</param>
	        /// <returns>the NumberFormat, or null.</returns>
	        /// @stable ICU 2.6
            public NumberFormat CreateFormat(Locale loc, int formatType)
            {
	            return CreateFormat(IBM.ICU.Util.ULocale.ForLocale(loc), formatType);
	        }
	
	        
	        /// @stable ICU 2.6
	        protected internal NumberFormatFactory() {
	        }
	    }
	
	    /// <summary>
	    /// A NumberFormatFactory that supports a single locale. It can be visible or
	    /// invisible.
	    /// </summary>
	    ///
	    /// @stable ICU 2.6
	    public abstract class SimpleNumberFormatFactory : 
	            NumberFormat.NumberFormatFactory  {
	        internal readonly ILOG.J2CsMapping.Collections.ISet localeNames;
	
	        internal readonly bool visible;
	
	        /// <summary>
	        /// Constructs a SimpleNumberFormatFactory with the given locale.
	        /// </summary>
	        ///
	        /// @stable ICU 2.6
            public SimpleNumberFormatFactory(Locale locale)
                : this(locale, true)
            {
	        }
	
	        /// <summary>
	        /// Constructs a SimpleNumberFormatFactory with the given locale and the
	        /// visibility.
	        /// </summary>
	        ///
	        /// @stable ICU 2.6
            public SimpleNumberFormatFactory(Locale locale, bool visible_0)
            {
	            localeNames = ILOG.J2CsMapping.Collections.Collections.Singleton(IBM.ICU.Util.ULocale.ForLocale(locale)
	                                .GetBaseName());
	            this.visible = visible_0;
	        }
	
	        /// <summary>
	        /// Constructs a SimpleNumberFormatFactory with the given locale.
	        /// </summary>
	        ///
	        /// @stable ICU 3.2
	        public SimpleNumberFormatFactory(ULocale locale) : this(locale, true) {
	        }
	
	        /// <summary>
	        /// Constructs a SimpleNumberFormatFactory with the given locale and the
	        /// visibility.
	        /// </summary>
	        ///
	        /// @stable ICU 3.2
	        public SimpleNumberFormatFactory(ULocale locale, bool visible_0) {
	            localeNames = ILOG.J2CsMapping.Collections.Collections.Singleton(locale.GetBaseName());
	            this.visible = visible_0;
	        }
	
	        /// <summary>
	        /// 
	        /// </summary>
	        ///
	        /// @stable ICU 2.6
	        public sealed override bool Visible() {
	            return visible;
	        }
	
	        /// <summary>
	        /// 
	        /// </summary>
	        ///
	        /// @stable ICU 2.6
	        public sealed override ILOG.J2CsMapping.Collections.ISet GetSupportedLocaleNames() {
	            return localeNames;
	        }
	    }
	
	    // shim so we can build without service code
	    abstract internal class NumberFormatShim {
            abstract internal Locale[] GetAvailableLocales();
	
	        abstract internal ULocale[] GetAvailableULocales();
	
	        abstract internal Object RegisterFactory(NumberFormat.NumberFormatFactory  f);
	
	        abstract internal bool Unregister(Object k);
	
	        abstract internal NumberFormat CreateInstance(ULocale l, int k);
	    }
	
	    private static NumberFormat.NumberFormatShim  shim;
	
	    private static NumberFormat.NumberFormatShim  GetShim() {
	        // Note: this instantiation is safe on loose-memory-model configurations
	        // despite lack of synchronization, since the shim instance has no
	        // state--
	        // it's all in the class init. The worst problem is we might instantiate
	        // two shim instances, but they'll share the same state so that's ok.
	        if (shim == null) {
	            try {
	                Type cls = ILOG.J2CsMapping.Reflect.Helper.GetNativeType("IBM.ICU.Text.NumberFormatServiceShim");
	                shim = (NumberFormat.NumberFormatShim ) Activator.CreateInstance(cls);
	            } catch (MissingManifestResourceException e) {
	                throw e;
	            } catch (Exception e_0) {
	                // /CLOVER:OFF
	                // e.printStackTrace();
	                throw new Exception(e_0.Message);
	                // /CLOVER:ON
	            }
	        }
	        return shim;
	    }
	
	    /// <summary>
	    /// Get the list of Locales for which NumberFormats are available.
	    /// </summary>
	    ///
	    /// <returns>the available locales</returns>
	    /// @stable ICU 2.0
        public static Locale[] GetAvailableLocales()
        {
	        if (shim == null) {
	            return IBM.ICU.Impl.ICUResourceBundle
	                    .GetAvailableLocales(IBM.ICU.Impl.ICUResourceBundle.ICU_BASE_NAME);
	        }
	        return GetShim().GetAvailableLocales();
	    }
	
	    /// <summary>
	    /// Get the list of Locales for which NumberFormats are available.
	    /// </summary>
	    ///
	    /// <returns>the available locales</returns>
	    /// @draft ICU 3.2
	    /// @provisional This API might change or be removed in a future release.
	    public static ULocale[] GetAvailableULocales() {
	        if (shim == null) {
	            return IBM.ICU.Impl.ICUResourceBundle
	                    .GetAvailableULocales(IBM.ICU.Impl.ICUResourceBundle.ICU_BASE_NAME);
	        }
	        return GetShim().GetAvailableULocales();
	    }
	
	    /// <summary>
	    /// Registers a new NumberFormatFactory. The factory is adopted by the
	    /// service and must not be modified. The returned object is a key that can
	    /// be used to unregister this factory.
	    /// </summary>
	    ///
	    /// <param name="factory">the factory to register</param>
	    /// <returns>a key with which to unregister the factory</returns>
	    /// @stable ICU 2.6
	    public static Object RegisterFactory(NumberFormat.NumberFormatFactory  factory) {
	        if (factory == null) {
	            throw new ArgumentException("factory must not be null");
	        }
	        return GetShim().RegisterFactory(factory);
	    }
	
	    /// <summary>
	    /// Unregister the factory or instance associated with this key (obtained
	    /// from registerInstance or registerFactory).
	    /// </summary>
	    ///
	    /// <param name="registryKey">a key obtained from registerFactory</param>
	    /// <returns>true if the object was successfully unregistered</returns>
	    /// @stable ICU 2.6
	    public static bool Unregister(Object registryKey) {
	        if (registryKey == null) {
	            throw new ArgumentException("registryKey must not be null");
	        }
	
	        if (shim == null) {
	            return false;
	        }
	
	        return shim.Unregister(registryKey);
	    }
	
	    // ===== End of factory stuff =====
	
	    /// <summary>
	    /// Overrides hashCode
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public override int GetHashCode() {
	        return maximumIntegerDigits * 37 + maxFractionDigits;
	        // just enough fields for a reasonable distribution
	    }
	
	    /// <summary>
	    /// Overrides equals. Two NumberFormats are equal if they are of the same
	    /// class and the settings (groupingUsed, parseIntegerOnly,
	    /// maximumIntegerDigits, etc. are equal.
	    /// </summary>
	    ///
	    /// <param name="obj">the object to compare against</param>
	    /// <returns>true if the object is equal to this.</returns>
	    /// @stable ICU 2.0
	    public override bool Equals(Object obj) {
	        if (obj == null)
	            return false;
	        if ((Object) this == obj)
	            return true;
	        if ((Object) GetType() != (Object) obj.GetType())
	            return false;
	        NumberFormat other = (NumberFormat) obj;
	        return maximumIntegerDigits == other.maximumIntegerDigits
	                && minimumIntegerDigits == other.minimumIntegerDigits
	                && maximumFractionDigits == other.maximumFractionDigits
	                && minimumFractionDigits == other.minimumFractionDigits
	                && groupingUsed == other.groupingUsed
	                && parseIntegerOnly == other.parseIntegerOnly
	                && parseStrict == other.parseStrict;
	    }
	
	    /// <summary>
	    /// Overrides Cloneable.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public override Object Clone() {
	        NumberFormat other = (NumberFormat) base.Clone();
	        return other;
	    }
	
	    /// <summary>
	    /// Returns true if grouping is used in this format. For example, in the
	    /// en_US locale, with grouping on, the number 1234567 will be formatted as
	    /// "1,234,567". The grouping separator as well as the size of each group is
	    /// locale-dependent and is determined by subclasses of NumberFormat.
	    /// Grouping affects both parsing and formatting.
	    /// </summary>
	    ///
	    /// <returns>true if grouping is used</returns>
	    /// <seealso cref="M:IBM.ICU.Text.NumberFormat.SetGroupingUsed(System.Boolean)"/>
	    /// @stable ICU 2.0
	    public bool IsGroupingUsed() {
	        return groupingUsed;
	    }
	
	    /// <summary>
	    /// Sets whether or not grouping will be used in this format. Grouping
	    /// affects both parsing and formatting.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.NumberFormat.IsGroupingUsed"/>
	    /// <param name="newValue">true to use grouping.</param>
	    /// @stable ICU 2.0
	    public void SetGroupingUsed(bool newValue) {
	        groupingUsed = newValue;
	    }
	
	    /// <summary>
	    /// Returns the maximum number of digits allowed in the integer portion of a
	    /// number. The default value is 40, which subclasses can override. When
	    /// formatting, the exact behavior when this value is exceeded is
	    /// subclass-specific. When parsing, this has no effect.
	    /// </summary>
	    ///
	    /// <returns>the maximum number of integer digits</returns>
	    /// <seealso cref="M:IBM.ICU.Text.NumberFormat.SetMaximumIntegerDigits(System.Int32)"/>
	    /// @stable ICU 2.0
	    public virtual int GetMaximumIntegerDigits() {
	        return maximumIntegerDigits;
	    }
	
	    /// <summary>
	    /// Sets the maximum number of digits allowed in the integer portion of a
	    /// number. This must be >= minimumIntegerDigits. If the new value for
	    /// maximumIntegerDigits is less than the current value of
	    /// minimumIntegerDigits, then minimumIntegerDigits will also be set to the
	    /// new value.
	    /// </summary>
	    ///
	    /// <param name="newValue">the maximum number of integer digits to be shown; if less thanzero, then zero is used. Subclasses might enforce an upperlimit to this value appropriate to the numeric type beingformatted.</param>
	    /// <seealso cref="M:IBM.ICU.Text.NumberFormat.GetMaximumIntegerDigits"/>
	    /// @stable ICU 2.0
	    public virtual void SetMaximumIntegerDigits(int newValue) {
	        maximumIntegerDigits = Math.Max(0,newValue);
	        if (minimumIntegerDigits > maximumIntegerDigits)
	            minimumIntegerDigits = maximumIntegerDigits;
	    }
	
	    /// <summary>
	    /// Returns the minimum number of digits allowed in the integer portion of a
	    /// number. The default value is 1, which subclasses can override. When
	    /// formatting, if this value is not reached, numbers are padded on the left
	    /// with the locale-specific '0' character to ensure at least this number of
	    /// integer digits. When parsing, this has no effect.
	    /// </summary>
	    ///
	    /// <returns>the minimum number of integer digits</returns>
	    /// <seealso cref="M:IBM.ICU.Text.NumberFormat.SetMinimumIntegerDigits(System.Int32)"/>
	    /// @stable ICU 2.0
        public virtual int GetMinimumIntegerDigits()
        {
	        return minimumIntegerDigits;
	    }
	
	    /// <summary>
	    /// Sets the minimum number of digits allowed in the integer portion of a
	    /// number. This must be <= maximumIntegerDigits. If the new value for
	    /// minimumIntegerDigits is more than the current value of
	    /// maximumIntegerDigits, then maximumIntegerDigits will also be set to the
	    /// new value.
	    /// </summary>
	    ///
	    /// <param name="newValue">the minimum number of integer digits to be shown; if less thanzero, then zero is used. Subclasses might enforce an upperlimit to this value appropriate to the numeric type beingformatted.</param>
	    /// <seealso cref="M:IBM.ICU.Text.NumberFormat.GetMinimumIntegerDigits"/>
	    /// @stable ICU 2.0
	    public virtual void SetMinimumIntegerDigits(int newValue) {
	        minimumIntegerDigits = Math.Max(0,newValue);
	        if (minimumIntegerDigits > maximumIntegerDigits)
	            maximumIntegerDigits = minimumIntegerDigits;
	    }
	
	    /// <summary>
	    /// Returns the maximum number of digits allowed in the fraction portion of a
	    /// number. The default value is 3, which subclasses can override. When
	    /// formatting, the exact behavior when this value is exceeded is
	    /// subclass-specific. When parsing, this has no effect.
	    /// </summary>
	    ///
	    /// <returns>the maximum number of fraction digits</returns>
	    /// <seealso cref="M:IBM.ICU.Text.NumberFormat.SetMaximumFractionDigits(System.Int32)"/>
	    /// @stable ICU 2.0
	    public int GetMaximumFractionDigits() {
	        return maximumFractionDigits;
	    }
	
	    /// <summary>
	    /// Sets the maximum number of digits allowed in the fraction portion of a
	    /// number. This must be >= minimumFractionDigits. If the new value for
	    /// maximumFractionDigits is less than the current value of
	    /// minimumFractionDigits, then minimumFractionDigits will also be set to the
	    /// new value.
	    /// </summary>
	    ///
	    /// <param name="newValue">the maximum number of fraction digits to be shown; if lessthan zero, then zero is used. The concrete subclass mayenforce an upper limit to this value appropriate to thenumeric type being formatted.</param>
	    /// <seealso cref="M:IBM.ICU.Text.NumberFormat.GetMaximumFractionDigits"/>
	    /// @stable ICU 2.0
	    public virtual void SetMaximumFractionDigits(int newValue) {
	        maximumFractionDigits = Math.Max(0,newValue);
	        if (maximumFractionDigits < minimumFractionDigits)
	            minimumFractionDigits = maximumFractionDigits;
	    }
	
	    /// <summary>
	    /// Returns the minimum number of digits allowed in the fraction portion of a
	    /// number. The default value is 0, which subclasses can override. When
	    /// formatting, if this value is not reached, numbers are padded on the right
	    /// with the locale-specific '0' character to ensure at least this number of
	    /// fraction digits. When parsing, this has no effect.
	    /// </summary>
	    ///
	    /// <returns>the minimum number of fraction digits</returns>
	    /// <seealso cref="M:IBM.ICU.Text.NumberFormat.SetMinimumFractionDigits(System.Int32)"/>
	    /// @stable ICU 2.0
	    public int GetMinimumFractionDigits() {
	        return minimumFractionDigits;
	    }
	
	    /// <summary>
	    /// Sets the minimum number of digits allowed in the fraction portion of a
	    /// number. This must be <= maximumFractionDigits. If the new value for
	    /// minimumFractionDigits exceeds the current value of maximumFractionDigits,
	    /// then maximumFractionDigits will also be set to the new value.
	    /// </summary>
	    ///
	    /// <param name="newValue">the minimum number of fraction digits to be shown; if lessthan zero, then zero is used. Subclasses might enforce anupper limit to this value appropriate to the numeric typebeing formatted.</param>
	    /// <seealso cref="M:IBM.ICU.Text.NumberFormat.GetMinimumFractionDigits"/>
	    /// @stable ICU 2.0
	    public virtual void SetMinimumFractionDigits(int newValue) {
	        minimumFractionDigits = Math.Max(0,newValue);
	        if (maximumFractionDigits < minimumFractionDigits)
	            maximumFractionDigits = minimumFractionDigits;
	    }
	
	    /// <summary>
	    /// Sets the <tt>Currency</tt> object used to display currency amounts. This
	    /// takes effect immediately, if this format is a currency format. If this
	    /// format is not a currency format, then the currency object is used if and
	    /// when this object becomes a currency format.
	    /// </summary>
	    ///
	    /// <param name="theCurrency">new currency object to use. May be null for some subclasses.</param>
	    /// @stable ICU 2.6
	    public virtual void SetCurrency(Currency theCurrency) {
	        currency = theCurrency;
	    }
	
	    /// <summary>
	    /// Gets the <tt>Currency</tt> object used to display currency amounts. This
	    /// may be null.
	    /// </summary>
	    ///
	    /// @stable ICU 2.6
	    public Currency GetCurrency() {
	        return currency;
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Returns the currency in effect for this formatter. Subclasses should
	    /// override this method as needed. Unlike getCurrency(), this method should
	    /// never return null.
	    /// </summary>
	    ///
	    /// <returns>a non-null Currency</returns>
	    protected internal virtual Currency GetEffectiveCurrency() {
	        Currency c = GetCurrency();
	        if (c == null) {
	            ULocale uloc = GetLocale(IBM.ICU.Util.ULocale.VALID_LOCALE);
	            if (uloc == null) {
	                uloc = IBM.ICU.Util.ULocale.GetDefault();
	            }
	            c = IBM.ICU.Util.Currency.GetInstance(uloc);
	        }
	        return c;
	    }
	
	    // =======================privates===============================
	
	    // Hook for service
	    private static NumberFormat GetInstance(ULocale desiredLocale, int choice) {
	        // if (shim == null) {
	        // return createInstance(desiredLocale, choice);
	        // } else {
	        // // TODO: shims must call setLocale() on object they create
	        // return getShim().createInstance(desiredLocale, choice);
	        // }
	        return GetShim().CreateInstance(desiredLocale, choice);
	    }
	
	    // [NEW]
	    static internal NumberFormat CreateInstance(ULocale desiredLocale, int choice) {
	        String pattern = GetPattern(desiredLocale, choice);
	        DecimalFormatSymbols symbols = new DecimalFormatSymbols(desiredLocale);
	
	        // Here we assume that the locale passed in is in the canonical
	        // form, e.g: pt_PT_@currency=PTE not pt_PT_PREEURO
	        if (choice == CURRENCYSTYLE) {
	            String temp = symbols.GetCurrencyPattern();
	            if (temp != null) {
	                pattern = temp;
	            }
	        }
	
	        DecimalFormat format = new DecimalFormat(pattern, symbols);
	        // System.out.println("loc: " + desiredLocale + " choice: " + choice +
	        // " pat: " + pattern + " sym: " + symbols + " result: " + format);
	
	        /*
	         * Bug 4408066 Add codes for the new method getIntegerInstance()
	         * [Richard/GCL]
	         */
	        // TODO: revisit this -- this is almost certainly not the way we want
	        // to do this. aliu 1/6/2004
	        if (choice == INTEGERSTYLE) {
	            format.SetMaximumFractionDigits(0);
	            format.SetDecimalSeparatorAlwaysShown(false);
	            format.SetParseIntegerOnly(true);
	        }
	
	        // TODO: the actual locale of the *pattern* may differ from that
	        // for the *symbols*. For now, we use the data for the symbols.
	        // Revisit this.
	        ULocale valid = symbols.GetLocale(IBM.ICU.Util.ULocale.VALID_LOCALE);
	        ULocale actual = symbols.GetLocale(IBM.ICU.Util.ULocale.ACTUAL_LOCALE);
	        format.SetLocale(valid, actual);
	
	        return format;
	    }
	
	    /// <summary>
	    /// Returns the pattern for the provided locale and choice.
	    /// </summary>
	    ///
	    /// <param name="forLocale">the locale of the data.</param>
	    /// <param name="choice">the pattern format.</param>
	    /// <returns>the pattern</returns>
        protected static internal String GetPattern(Locale forLocale, int choice)
        {
	        return GetPattern(IBM.ICU.Util.ULocale.ForLocale(forLocale), choice);
	    }
	
	    /// <summary>
	    /// Returns the pattern for the provided locale and choice.
	    /// </summary>
	    ///
	    /// <param name="forLocale">the locale of the data.</param>
	    /// <param name="choice">the pattern format.</param>
	    /// <returns>the pattern</returns>
	    /// @stable ICU 3.2
	    protected static internal String GetPattern(ULocale forLocale, int choice) {
	
	        /*
	         * The following code takes care of a few cases where the resource data
	         * in the underlying JDK lags the new features we have added to ICU4J:
	         * scientific notation, rounding, and secondary grouping.
	         * 
	         * We detect these cases here and return various hard-coded resource
	         * data. This is the simplest solution for now, but it is not a good
	         * long-term mechanism.
	         * 
	         * We should replace this code with a data-driven mechanism that reads
	         * the bundle com.ibm.icu.impl.data.LocaleElements and parses an
	         * exception table that overrides the standard data at
	         * java.text.resource.LocaleElements*.java. Alternatively, we should
	         * create our own copy of the resource data, and use that exclusively.
	         */
	
	        // TEMPORARY, until we get scientific patterns into the main
	        // resources: Retrieve scientific patterns from our resources.
	        if (choice == SCIENTIFICSTYLE) {
	            // Temporarily hard code; retrieve from resource later
	            /* For ICU compatibility [Richard/GCL] */
	            return "#E0";
	            // return
	            // NumberFormat.getBaseStringArray("NumberPatterns")[SCIENTIFICSTYLE];
	        }
	        // TEMPORARY: Use rounding for Swiss currency
	        // if (choice == CURRENCYSTYLE &&
	        // forLocale.getCountry().equals("CH")) {
	        // return "'Fr. '#,##0.05;'Fr.-'#,##0.05";
	        // }
	        // TEMPORARY: Special case IN number format
	        // if (choice == NUMBERSTYLE &&
	        // forLocale.getCountry().equals("IN")) {
	        // return "#,##,##0.###";
	        // }
	
	        // {dlf}
	        ICUResourceBundle rb = (ICUResourceBundle) IBM.ICU.Util.UResourceBundle
	                .GetBundleInstance(IBM.ICU.Impl.ICUResourceBundle.ICU_BASE_NAME, forLocale);
	        String[] numberPatterns = rb.GetStringArray("NumberPatterns");
	
	        /*
	         * {dlf} // Try the cache first String[] numberPatterns = (String[])
	         * cachedLocaleData.get(forLocale); if (numberPatterns == null) {
	         * OverlayBundle resource = new OverlayBundle(new String[] {
	         * "com.ibm.icu.impl.data.LocaleElements", RESOURCE_BASE }, forLocale);
	         * numberPatterns = resource.getStringArray("NumberPatterns"); // Update
	         * the cache cachedLocaleData.put(forLocale, numberPatterns); }
	         */
	
	        /*
	         * Bug 4408066 Add codes for the new method getIntegerInstance()
	         * [Richard/GCL]
	         */
	        int entry = (choice == INTEGERSTYLE) ? NUMBERSTYLE : choice; // [Richard/GCL]
	        return numberPatterns[entry]; // [Richard/GCL]
	    }
	
	    /// <summary>
	    /// First, read in the default serializable data.
	    /// Then, if <c>serialVersionOnStream</c> is less than 1, indicating
	    /// that the stream was written by JDK 1.1, set the <c>int</c> fields
	    /// such as <c>maximumIntegerDigits</c> to be equal to the
	    /// <c>byte</c> fields such as <c>maxIntegerDigits</c>, since the
	    /// <c>int</c> fields were not present in JDK 1.1. Finally, set
	    /// serialVersionOnStream back to the maximum allowed value so that default
	    /// serialization will work properly if this object is streamed out again.
	    /// </summary>
	    ///
	    private void ReadObject(IlObjectInputStream stream) {
	        stream.DefaultReadObject();
	        // /CLOVER:OFF
	        // we don't have serialization data for this format
	        if (serialVersionOnStream < 1) {
	            // Didn't have additional int fields, reassign to use them.
	            maximumIntegerDigits = maxIntegerDigits;
	            minimumIntegerDigits = minIntegerDigits;
	            maximumFractionDigits = maxFractionDigits;
	            minimumFractionDigits = minFractionDigits;
	        }
	        // /CLOVER:ON
	        /*
	         * Bug 4185761 Validate the min and max fields [Richard/GCL]
	         */
	        if (minimumIntegerDigits > maximumIntegerDigits
	                || minimumFractionDigits > maximumFractionDigits
	                || minimumIntegerDigits < 0 || minimumFractionDigits < 0) {
	            throw new IOException("Digit count range invalid");
	        }
	        serialVersionOnStream = currentSerialVersion;
	    }
	
	    /// <summary>
	    /// Write out the default serializable data, after first setting the
	    /// <c>byte</c> fields such as <c>maxIntegerDigits</c> to be
	    /// equal to the <c>int</c> fields such as
	    /// <c>maximumIntegerDigits</c> (or to <c>Byte.MAX_VALUE</c>,
	    /// whichever is smaller), for compatibility with the JDK 1.1 version of the
	    /// stream format.
	    /// </summary>
	    ///
	    private void WriteObject(IlObjectOutputStream stream) {
	        maxIntegerDigits = (maximumIntegerDigits > Byte.MaxValue) ? Byte.MaxValue
	                : (byte) maximumIntegerDigits;
	        minIntegerDigits = (minimumIntegerDigits > Byte.MaxValue) ? Byte.MaxValue
	                : (byte) minimumIntegerDigits;
	        maxFractionDigits = (maximumFractionDigits > Byte.MaxValue) ? Byte.MaxValue
	                : (byte) maximumFractionDigits;
	        minFractionDigits = (minimumFractionDigits > Byte.MaxValue) ? Byte.MaxValue
	                : (byte) minimumFractionDigits;
	        stream.DefaultWriteObject();
	    }
	
	    // Unused -- Alan 2003-05
	    // /**
	    // * Cache to hold the NumberPatterns of a Locale.
	    // */
	    // private static final Hashtable cachedLocaleData = new Hashtable(3);
	
	    /*
	     * Bug 4408066 Add Field for the new method getIntegerInstance()
	     * [Richard/GCL]
	     */
	
	    /// <summary>
	    /// True if the the grouping (i.e. thousands) separator is used when
	    /// formatting and parsing numbers.
	    /// </summary>
	    ///
	    /// @serial
	    /// <seealso cref="M:IBM.ICU.Text.NumberFormat.IsGroupingUsed"/>
	    private bool groupingUsed;
	
	    /// <summary>
	    /// The maximum number of digits allowed in the integer portion of a number.
	    /// <c>maxIntegerDigits</c> must be greater than or equal to
	    /// <c>minIntegerDigits</c>.
	    /// <p>
	    /// <strong>Note:</strong> This field exists only for serialization
	    /// compatibility with JDK 1.1. In JDK 1.2 and higher, the new
	    /// <c>int</c> field <c>maximumIntegerDigits</c> is used instead.
	    /// When writing to a stream, <c>maxIntegerDigits</c> is set to
	    /// <c>maximumIntegerDigits</c> or <c>Byte.MAX_VALUE</c>,
	    /// whichever is smaller. When reading from a stream, this field is used only
	    /// if <c>serialVersionOnStream</c> is less than 1.
	    /// </summary>
	    ///
	    /// @serial
	    /// <seealso cref="M:IBM.ICU.Text.NumberFormat.GetMaximumIntegerDigits"/>
	    private byte maxIntegerDigits;
	
	    /// <summary>
	    /// The minimum number of digits allowed in the integer portion of a number.
	    /// <c>minimumIntegerDigits</c> must be less than or equal to
	    /// <c>maximumIntegerDigits</c>.
	    /// <p>
	    /// <strong>Note:</strong> This field exists only for serialization
	    /// compatibility with JDK 1.1. In JDK 1.2 and higher, the new
	    /// <c>int</c> field <c>minimumIntegerDigits</c> is used instead.
	    /// When writing to a stream, <c>minIntegerDigits</c> is set to
	    /// <c>minimumIntegerDigits</c> or <c>Byte.MAX_VALUE</c>,
	    /// whichever is smaller. When reading from a stream, this field is used only
	    /// if <c>serialVersionOnStream</c> is less than 1.
	    /// </summary>
	    ///
	    /// @serial
	    /// <seealso cref="M:IBM.ICU.Text.NumberFormat.GetMinimumIntegerDigits"/>
	    private byte minIntegerDigits;
	
	    /// <summary>
	    /// The maximum number of digits allowed in the fractional portion of a
	    /// number. <c>maximumFractionDigits</c> must be greater than or equal
	    /// to <c>minimumFractionDigits</c>.
	    /// <p>
	    /// <strong>Note:</strong> This field exists only for serialization
	    /// compatibility with JDK 1.1. In JDK 1.2 and higher, the new
	    /// <c>int</c> field <c>maximumFractionDigits</c> is used
	    /// instead. When writing to a stream, <c>maxFractionDigits</c> is set
	    /// to <c>maximumFractionDigits</c> or <c>Byte.MAX_VALUE</c>,
	    /// whichever is smaller. When reading from a stream, this field is used only
	    /// if <c>serialVersionOnStream</c> is less than 1.
	    /// </summary>
	    ///
	    /// @serial
	    /// <seealso cref="M:IBM.ICU.Text.NumberFormat.GetMaximumFractionDigits"/>
	    private byte maxFractionDigits; // invariant, >= minFractionDigits
	
	    /// <summary>
	    /// The minimum number of digits allowed in the fractional portion of a
	    /// number. <c>minimumFractionDigits</c> must be less than or equal to
	    /// <c>maximumFractionDigits</c>.
	    /// <p>
	    /// <strong>Note:</strong> This field exists only for serialization
	    /// compatibility with JDK 1.1. In JDK 1.2 and higher, the new
	    /// <c>int</c> field <c>minimumFractionDigits</c> is used
	    /// instead. When writing to a stream, <c>minFractionDigits</c> is set
	    /// to <c>minimumFractionDigits</c> or <c>Byte.MAX_VALUE</c>,
	    /// whichever is smaller. When reading from a stream, this field is used only
	    /// if <c>serialVersionOnStream</c> is less than 1.
	    /// </summary>
	    ///
	    /// @serial
	    /// <seealso cref="M:IBM.ICU.Text.NumberFormat.GetMinimumFractionDigits"/>
	    private byte minFractionDigits;
	
	    /// <summary>
	    /// True if this format will parse numbers as integers only.
	    /// </summary>
	    ///
	    /// @serial
	    /// <seealso cref="M:IBM.ICU.Text.NumberFormat.IsParseIntegerOnly"/>
	    private bool parseIntegerOnly;
	
	    // new fields for 1.2. byte is too small for integer digits.
	
	    /// <summary>
	    /// The maximum number of digits allowed in the integer portion of a number.
	    /// <c>maximumIntegerDigits</c> must be greater than or equal to
	    /// <c>minimumIntegerDigits</c>.
	    /// </summary>
	    ///
	    /// @serial
	    /// <seealso cref="M:IBM.ICU.Text.NumberFormat.GetMaximumIntegerDigits"/>
	    private int maximumIntegerDigits;
	
	    /// <summary>
	    /// The minimum number of digits allowed in the integer portion of a number.
	    /// <c>minimumIntegerDigits</c> must be less than or equal to
	    /// <c>maximumIntegerDigits</c>.
	    /// </summary>
	    ///
	    /// @serial
	    /// <seealso cref="M:IBM.ICU.Text.NumberFormat.GetMinimumIntegerDigits"/>
	    private int minimumIntegerDigits;
	
	    /// <summary>
	    /// The maximum number of digits allowed in the fractional portion of a
	    /// number. <c>maximumFractionDigits</c> must be greater than or equal
	    /// to <c>minimumFractionDigits</c>.
	    /// </summary>
	    ///
	    /// @serial
	    /// <seealso cref="M:IBM.ICU.Text.NumberFormat.GetMaximumFractionDigits"/>
	    private int maximumFractionDigits; // invariant, >= minFractionDigits
	
	    /// <summary>
	    /// The minimum number of digits allowed in the fractional portion of a
	    /// number. <c>minimumFractionDigits</c> must be less than or equal to
	    /// <c>maximumFractionDigits</c>.
	    /// </summary>
	    ///
	    /// @serial
	    /// <seealso cref="M:IBM.ICU.Text.NumberFormat.GetMinimumFractionDigits"/>
	    private int minimumFractionDigits;
	
	    /// <summary>
	    /// Currency object used to format currencies. Subclasses may ignore this if
	    /// they are not currency formats. This will be null unless a subclass sets
	    /// it to a non-null value.
	    /// </summary>
	    ///
	    private Currency currency;
	
	    internal const int currentSerialVersion = 1;
	
	    /// <summary>
	    /// Describes the version of <c>NumberFormat</c> present on the stream.
	    /// Possible values are:
	    /// <ul>
	    /// <li><b>0</b> (or uninitialized): the JDK 1.1 version of the stream
	    /// format. In this version, the <c>int</c> fields such as
	    /// <c>maximumIntegerDigits</c> were not present, and the
	    /// <c>byte</c> fields such as <c>maxIntegerDigits</c> are used
	    /// instead.
	    /// <li><b>1</b>: the JDK 1.2 version of the stream format. The values of the
	    /// <c>byte</c> fields such as <c>maxIntegerDigits</c> are
	    /// ignored, and the <c>int</c> fields such as
	    /// <c>maximumIntegerDigits</c> are used instead.
	    /// </ul>
	    /// When streaming out a <c>NumberFormat</c>, the most recent format
	    /// (corresponding to the highest allowable
	    /// <c>serialVersionOnStream</c>) is always written.
	    /// </summary>
	    ///
	    /// @serial
	    private int serialVersionOnStream;
	
	    // Removed "implements Cloneable" clause. Needs to update serialization
	    // ID for backward compatibility.
	    private const long serialVersionUID = -2308460125733713944L;
	
	    /// <summary>
	    /// Empty constructor. Public for compatibily with JDK which lets the
	    /// compiler generate a default public constructor even though this is an
	    /// abstract class.
	    /// </summary>
	    ///
	    /// @stable ICU 2.6
	    public NumberFormat() {
	        this.groupingUsed = true;
	        this.maxIntegerDigits = 40;
	        this.minIntegerDigits = 1;
	        this.maxFractionDigits = 3;
	        this.minFractionDigits = 0;
	        this.parseIntegerOnly = false;
	        this.maximumIntegerDigits = 40;
	        this.minimumIntegerDigits = 1;
	        this.maximumFractionDigits = 3;
	        this.minimumFractionDigits = 0;
	        this.serialVersionOnStream = currentSerialVersion;
	    }
	
	    // new in ICU4J 3.6
	    private bool parseStrict;
	
	    // #if defined(FOUNDATION10) || defined(J2SE13)
	    // #else
	    /// <summary>
	    /// The instances of this inner class are used as attribute keys and values
	    /// in AttributedCharacterIterator that
	    /// NumberFormat.formatToCharacterIterator() method returns.
	    /// <p>
	    /// There is no public constructor to this class, the only instances are the
	    /// constants defined here.
	    /// <p>
	    /// </summary>
	    ///
	    /// @stable ICU 3.6
	    [Serializable]
	    public class Field : Format.Field {
	        // generated by serialver from JDK 1.4.1_01
	        internal const long serialVersionUID = -4516273749929385842L;
	
	        
	        /// @stable ICU 3.6
	        public static readonly NumberFormat.Field  SIGN = new NumberFormat.Field ("sign");
	
	        
	        /// @stable ICU 3.6
	        public static readonly NumberFormat.Field  INTEGER = new NumberFormat.Field ("integer");
	
	        
	        /// @stable ICU 3.6
	        public static readonly NumberFormat.Field  FRACTION = new NumberFormat.Field ("fraction");
	
	        
	        /// @stable ICU 3.6
	        public static readonly NumberFormat.Field  EXPONENT = new NumberFormat.Field ("exponent");
	
	        
	        /// @stable ICU 3.6
	        public static readonly NumberFormat.Field  EXPONENT_SIGN = new NumberFormat.Field ("exponent sign");
	
	        
	        /// @stable ICU 3.6
	        public static readonly NumberFormat.Field  EXPONENT_SYMBOL = new NumberFormat.Field ("exponent symbol");
	
	        
	        /// @stable ICU 3.6
	        public static readonly NumberFormat.Field  DECIMAL_SEPARATOR = new NumberFormat.Field (
	                "decimal separator");
	
	        
	        /// @stable ICU 3.6
	        public static readonly NumberFormat.Field  GROUPING_SEPARATOR = new NumberFormat.Field (
	                "grouping separator");
	
	        
	        /// @stable ICU 3.6
	        public static readonly NumberFormat.Field  PERCENT = new NumberFormat.Field ("percent");
	
	        
	        /// @stable ICU 3.6
	        public static readonly NumberFormat.Field  PERMILLE = new NumberFormat.Field ("per mille");
	
	        
	        /// @stable ICU 3.6
	        public static readonly NumberFormat.Field  CURRENCY = new NumberFormat.Field ("currency");
	
	        /// <summary>
	        /// Constructs a new instance of NumberFormat.Field with the given field
	        /// name.
	        /// </summary>
	        ///
	        /// @stable ICU 3.6
	        protected internal Field(String fieldName) : base(fieldName) {
	        }
	
	        /// <summary>
	        /// serizalization method resolve instances to the constant
	        /// NumberFormat.Field values
	        /// </summary>
	        ///
	        /// @stable ICU 3.6
	        protected internal override Object ReadResolve() {
	            if (this.GetName().Equals(INTEGER.GetName()))
	                return INTEGER;
	            if (this.GetName().Equals(FRACTION.GetName()))
	                return FRACTION;
	            if (this.GetName().Equals(EXPONENT.GetName()))
	                return EXPONENT;
	            if (this.GetName().Equals(EXPONENT_SIGN.GetName()))
	                return EXPONENT_SIGN;
	            if (this.GetName().Equals(EXPONENT_SYMBOL.GetName()))
	                return EXPONENT_SYMBOL;
	            if (this.GetName().Equals(CURRENCY.GetName()))
	                return CURRENCY;
	            if (this.GetName().Equals(DECIMAL_SEPARATOR.GetName()))
	                return DECIMAL_SEPARATOR;
	            if (this.GetName().Equals(GROUPING_SEPARATOR.GetName()))
	                return GROUPING_SEPARATOR;
	            if (this.GetName().Equals(PERCENT.GetName()))
	                return PERCENT;
	            if (this.GetName().Equals(PERMILLE.GetName()))
	                return PERMILLE;
	            if (this.GetName().Equals(SIGN.GetName()))
	                return SIGN;
	
	            throw new IOException("An invalid object.");
	        }
	    }
	    // #endif
	}
}
