/*
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 11/30/10 3:38 PM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace ILOG.J2CsMapping.RegEx {
	
	using ILOG.J2CsMapping.Text;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Resources;
	using System.Runtime.CompilerServices;
	using System.Text;
     using ILOG.J2CsMapping.Util;
	
	//import org.apache.harmony.regex.internal.nls.Messages;
	
	/// <summary>
	/// The purpose of this class is to break given pattern into RE tokens; 
	/// </summary>
	///
	internal class Lexer {
	
		public const int CHAR_DOLLAR = -536870912 | '$';
	
		public const int CHAR_RIGHT_PARENTHESIS = -536870912 | ')';
	
		public const int CHAR_LEFT_SQUARE_BRACKET = -536870912 | '[';
	
		public const int CHAR_RIGHT_SQUARE_BRACKET = -536870912 | ']';
	
		public const int CHAR_CARET = -536870912 | '^';
	
		public const int CHAR_VERTICAL_BAR = -536870912 | '|';
	
		public const int CHAR_AMPERSAND = -536870912 | '&';
	
		public const int CHAR_HYPHEN = -536870912 | '-';
	
		public const int CHAR_DOT = -536870912 | '.';
	
		public const int QMOD_GREEDY = -536870912;
	
		public const int QMOD_RELUCTANT = -1073741824;
	
		public const int QMOD_POSSESSIVE = -2147483648;
	
		public const int QUANT_STAR = QMOD_GREEDY | '*';
	
		public const int QUANT_STAR_P = QMOD_POSSESSIVE | '*';
	
		public const int QUANT_STAR_R = QMOD_RELUCTANT | '*';
	
		public const int QUANT_PLUS = QMOD_GREEDY | '+';
	
		public const int QUANT_PLUS_P = QMOD_POSSESSIVE | '+';
	
		public const int QUANT_PLUS_R = QMOD_RELUCTANT | '+';
	
		public const int QUANT_ALT = QMOD_GREEDY | '?';
	
		public const int QUANT_ALT_P = QMOD_POSSESSIVE | '?';
	
		public const int QUANT_ALT_R = QMOD_RELUCTANT | '?';
	
		public const int QUANT_COMP = QMOD_GREEDY | '{';
	
		public const int QUANT_COMP_P = QMOD_POSSESSIVE | '{';
	
		public const int QUANT_COMP_R = QMOD_RELUCTANT | '{';
	
		public const int CHAR_LEFT_PARENTHESIS = -2147483648 | '(';
	
		public const int CHAR_NONCAP_GROUP = -1073741824 | '(';
	
		public const int CHAR_POS_LOOKAHEAD = -536870912 | '(';
	
		public const int CHAR_NEG_LOOKAHEAD = -268435456 | '(';
	
		public const int CHAR_POS_LOOKBEHIND = -134217728 | '(';
	
		public const int CHAR_NEG_LOOKBEHIND = -67108864 | '(';
	
		public const int CHAR_ATOMIC_GROUP = -33554432 | '(';
	
		public const int CHAR_FLAGS = -16777216 | '(';
	
		public const int CHAR_START_OF_INPUT = -2147483648 | 'A';
	
		public const int CHAR_WORD_BOUND = -2147483648 | 'b';
	
		public const int CHAR_NONWORD_BOUND = -2147483648 | 'B';
	
		public const int CHAR_PREVIOUS_MATCH = -2147483648 | 'G';
	
		public const int CHAR_END_OF_INPUT = -2147483648 | 'z';
	
		public const int CHAR_END_OF_LINE = -2147483648 | 'Z';
	
		public const int MODE_PATTERN = 1 << 0;
	
		public const int MODE_RANGE = 1 << 1;
	
		public const int MODE_ESCAPE = 1 << 2;
	
		//maximum length of decomposition
		internal const int MAX_DECOMPOSITION_LENGTH = 4;
	
		/*
		 * maximum length of Hangul decomposition
		 * note that MAX_HANGUL_DECOMPOSITION_LENGTH <= MAX_DECOMPOSITION_LENGTH
		 */
		internal const int MAX_HANGUL_DECOMPOSITION_LENGTH = 3;
	
		/*
		 * Following constants are needed for Hangul canonical decomposition.
		 * Hangul decomposition algorithm and constants are taken according
		 * to description at http://www.unicode.org/versions/Unicode4.0.0/ch03.pdf
		 * "3.12 Conjoining Jamo Behavior"
		 */
		internal const int SBase = 0xAC00;
	
		internal const int LBase = 0x1100;
	
		internal const int VBase = 0x1161;
	
		internal const int TBase = 0x11A7;
	
		internal const int SCount = 11172;
	
		internal const int LCount = 19;
	
		internal const int VCount = 21;
	
		internal const int TCount = 28;
	
		internal const int NCount = 588;
	
		//table that contains canonical decomposition mappings
		private static IntArrHash decompTable = null;
	
		//table that contains canonical combining classes
		private static IntHash canonClassesTable = null;
	
		private static int canonClassesTableSize;
	
		/*
		 * Table that contains information about Unicode codepoints with
		 * single codepoint decomposition
		 */
		private static IntHash singleDecompTable = null;
	
		private static int singleDecompTableSize;
	
		private char[] pattern;
	
		private int flags;
	
		private int mode;
	
		// when in literal mode, this field will save the previous one
		private int saved_mode;
	
		// previous char read
		private int lookBack;
	
		//current character read
		private int ch;
	
		//next character
		private int lookAhead;
	
		//index of last char in pattern plus one
		private int patternFullLength;
	
		// cur special token
		private SpecialToken curST;
	
		// next special token
		private SpecialToken lookAheadST;
	
		//  cur char being processed
		private int index;
	
		//  previous non-whitespace character index;
		private int prevNW;
	
		//  cur token start index
		private int curToc;
	
		//  look ahead token index
		private int lookAheadToc;
	
		//  original string representing pattern    
		private String orig;
	
		public Lexer(String pattern_0, int flags_1) {
			this.pattern = null;
			this.flags = 0;
			this.mode = 1;
			this.saved_mode = 0;
			this.patternFullLength = 0;
			this.curST = null;
			this.lookAheadST = null;
			this.index = 0;
			this.prevNW = 0;
			this.curToc = 0;
			this.lookAheadToc = 0;
			this.orig = null;
			orig = pattern_0;
			if ((flags_1 & Pattern.LITERAL) > 0) {
				pattern_0 = Pattern.Quote(pattern_0);
			} else if ((flags_1 & Pattern.CANON_EQ) > 0) {
				pattern_0 = Lexer.Normalize(pattern_0);
			}
	
			this.pattern = new char[pattern_0.Length + 2];
			System.Array.Copy((Array)(pattern_0.ToCharArray()),0,(Array)(this.pattern),0,pattern_0.Length);
			this.pattern[this.pattern.Length - 1] = ((Char)0);
			this.pattern[this.pattern.Length - 2] = ((Char)0);
			patternFullLength = this.pattern.Length;
			this.flags = flags_1;
			// read first two tokens;
			MovePointer();
			MovePointer();
	
		}
	
		/// <summary>
		/// Returns current character w/o reading next one; if there are no more
		/// characters returns 0;
		/// </summary>
		///
		/// <returns>current character;</returns>
		public int Peek() {
			return ch;
		}
	
		/// <summary>
		/// Set the Lexer to PATTERN or RANGE mode; Lexer interpret character two
		/// different ways in parser or range modes.
		/// </summary>
		///
		/// <param name="mode_0">Lexer.PATTERN or Lexer.RANGE</param>
		public void SetMode(int mode_0) {
			if (mode_0 > 0 && mode_0 < 3) {
				this.mode = mode_0;
			}
	
			if (mode_0 == Lexer.MODE_PATTERN) {
				Reread();
			}
		}
	
		/// <summary>
		/// Restores flags for Lexer
		/// </summary>
		///
		/// <param name="flags_0"></param>
		public void RestoreFlags(int flags_0) {
			this.flags = flags_0;
			lookAhead = ch;
			lookAheadST = curST;
	
			//curToc is an index of closing bracket )
			index = curToc + 1;
			lookAheadToc = curToc;
			MovePointer();
		}
	
		public SpecialToken PeekSpecial() {
			return curST;
		}
	
		/// <summary>
		/// Returns true, if current token is special, i.e. quantifier, or other 
		/// compound token.
		/// </summary>
		///
		/// <returns>- true if current token is special, false otherwise.</returns>
		public bool IsSpecial() {
			return curST != null;
		}
	
		public bool IsQuantifier() {
			return IsSpecial() && curST.GetType() == ILOG.J2CsMapping.RegEx.SpecialToken.TOK_QUANTIFIER;
		}
	
		public bool IsNextSpecial() {
			return lookAheadST != null;
		}
	
		/// <summary>
		/// Returns current character and moves string index to the next one;
		/// </summary>
		///
		public int Next() {
			MovePointer();
			return lookBack;
		}
	
		/// <summary>
		/// Returns current special token and moves string index to the next one;
		/// </summary>
		///
		public SpecialToken NextSpecial() {
			SpecialToken res = curST;
			MovePointer();
			return res;
		}
	
		/// <summary>
		/// Returns nest symbol read.
		/// </summary>
		///
		public int LookAhead() {
			return lookAhead;
		}
	
		/// <summary>
		/// Returns previous character.
		/// </summary>
		///
		public int Back() {
			return lookBack;
		}
	
		/// <summary>
		/// Normalize given expression.
		/// </summary>
		///
		/// <param name="input">- expression to normalize</param>
		/// <returns>normalized expression.</returns>
		static internal String Normalize(String input) {
			char[] inputChars = input.ToCharArray();
			int inputLength = inputChars.Length;
			int resCodePointsIndex = 0;
			int inputCodePointsIndex = 0;
			int decompHangulIndex = 0;
	
			//codePoints of input
			int[] inputCodePoints = new int[inputLength];
	
			//result of canonical decomposition of input
			int[] resCodePoints = new int[inputLength * MAX_DECOMPOSITION_LENGTH];
	
			//current symbol's codepoint
			int ch_0;
	
			//current symbol's decomposition
			int[] decomp;
	
			//result of canonical and Hangul decomposition of input
			int[] decompHangul;
	
			//result of canonical decomposition of input in UTF-16 encoding
			StringBuilder result = new StringBuilder();
	
			decompTable = ILOG.J2CsMapping.RegEx.HashDecompositions.GetHashDecompositions();
			canonClassesTable = ILOG.J2CsMapping.RegEx.CanClasses.GetHashCanClasses();
			canonClassesTableSize = canonClassesTable.size;
			singleDecompTable = ILOG.J2CsMapping.RegEx.SingleDecompositions.GetHashSingleDecompositions();
			singleDecompTableSize = singleDecompTable.size;

            for (int i = 0; i < inputLength; i += Character.CharCount(ch_0))
            {
                ch_0 = Character.CodePointAt(inputChars, i);
				inputCodePoints[inputCodePointsIndex++] = ch_0;
			}
	
			/*
			 * Canonical decomposition based on mappings in decompTable
			 */
			for (int i_1 = 0; i_1 < inputCodePointsIndex; i_1++) {
				ch_0 = inputCodePoints[i_1];
	
				decomp = Lexer.GetDecomposition(ch_0);
				if (decomp == null) {
					resCodePoints[resCodePointsIndex++] = ch_0;
				} else {
					int curSymbDecompLength = decomp.Length;
	
					for (int j = 0; j < curSymbDecompLength; j++) {
						resCodePoints[resCodePointsIndex++] = decomp[j];
					}
				}
			}
	
			/*
			 * Canonical ordering.
			 * See http://www.unicode.org/reports/tr15/#Decomposition for
			 * details
			 */
			resCodePoints = Lexer.GetCanonicalOrder(resCodePoints,
					resCodePointsIndex);
	
			/*
			 * Decomposition for Hangul syllables.
			 * See http://www.unicode.org/reports/tr15/#Hangul for
			 * details
			 */
			decompHangul = new int[resCodePoints.Length];
	
			for (int i_2 = 0; i_2 < resCodePointsIndex; i_2++) {
				int curSymb = resCodePoints[i_2];
	
				decomp = GetHangulDecomposition(curSymb);
				if (decomp == null) {
					decompHangul[decompHangulIndex++] = curSymb;
				} else {
	
					/*
					 * Note that Hangul decompositions have length that is
					 * equal 2 or 3.
					 */
					decompHangul[decompHangulIndex++] = decomp[0];
					decompHangul[decompHangulIndex++] = decomp[1];
					if (decomp.Length == 3) {
						decompHangul[decompHangulIndex++] = decomp[2];
					}
				}
			}
	
			/*
			 * Translating into UTF-16 encoding
			 */
			for (int i_3 = 0; i_3 < decompHangulIndex; i_3++) {
                result.Append(Character.ToChars(decompHangul[i_3]));
			}
	
			return result.ToString();
		}
	
		/// <summary>
		/// Rearrange codepoints according
		/// to canonical order.
		/// </summary>
		///
		/// <param name="inputInts">- array that contains Unicode codepoints</param>
		/// <param name="length">- index of last Unicode codepoint plus 1</param>
		/// <returns>array that contains rearranged codepoints.</returns>
		static internal int[] GetCanonicalOrder(int[] inputInts, int length) {
			int inputLength = (length < inputInts.Length) ? length
					: inputInts.Length;
	
			/*
			 * Simple bubble-sort algorithm.
			 * Note that many codepoints have 0
			 * canonical class, so this algorithm works
			 * almost lineary in overwhelming majority
			 * of cases. This is due to specific of Unicode
			 * combining classes and codepoints.
			 */
			for (int i = 1; i < inputLength; i++) {
				int j = i - 1;
				int iCanonicalClass = GetCanonicalClass(inputInts[i]);
				int ch_0;
	
				if (iCanonicalClass == 0) {
					continue;
				}
	
				while (j > -1) {
					if (GetCanonicalClass(inputInts[j]) > iCanonicalClass) {
						j = j - 1;
					} else {
						break;
					}
				}
	
				ch_0 = inputInts[i];
				for (int k = i; k > j + 1; k--) {
					inputInts[k] = inputInts[k - 1];
				}
				inputInts[j + 1] = ch_0;
			}
	
			return inputInts;
		}
	
		/// <summary>
		/// Reread current character, may be require if previous token changes mode
		/// to one with different character interpretation.
		/// </summary>
		///
		private void Reread() {
			lookAhead = ch;
			lookAheadST = curST;
			index = lookAheadToc;
			lookAheadToc = curToc;
			MovePointer();
		}
	
		/// <summary>
		/// Moves pointer one position right; save current character to lookBack;
		/// lookAhead to current one and finally read one more to lookAhead;
		/// </summary>
		///
		private void MovePointer() {
			// swap pointers
			lookBack = ch;
			ch = lookAhead;
			curST = lookAheadST;
			curToc = lookAheadToc;
			lookAheadToc = index;
			bool reread;
			do {
				reread = false;
				// read next character analyze it and construct token:
				// //
	
				lookAhead = (index < pattern.Length) ? NextCodePoint() : 0;
				lookAheadST = null;
	
				if (mode == Lexer.MODE_ESCAPE) {
					if (lookAhead == '\\') {
	
						//need not care about supplementary codepoints here 
						lookAhead = (index < pattern.Length) ? (char) (pattern[NextIndex()])
								: (char) (0);
	
						switch (lookAhead) {
						case 'E': {
							mode = saved_mode;
	
							lookAhead = (index <= pattern.Length - 2) ? NextCodePoint()
									: 0;
							break;
						}
	
						default: {
							lookAhead = '\\';
							index = prevNW;
							return;
						}
						}
					} else {
						return;
					}
				}
	
				if (lookAhead == '\\') {
	
					lookAhead = (index < pattern.Length - 2) ? NextCodePoint() : -1;
					switch (lookAhead) {
					case -1:
						throw new PatternSyntaxException(
								"regex.10", this.ToString(), index); //$NON-NLS-1$
					case 'P':
					case 'p': {
						String cs = ParseCharClassName();
						bool negative = false;
	
						if (lookAhead == 'P')
							negative = true;
						;
						try {
							lookAheadST = ILOG.J2CsMapping.RegEx.AbstractCharClass.GetPredefinedClass(cs,
									negative);
						} catch (MissingManifestResourceException mre) {
							throw new PatternSyntaxException("regex.11" //$NON-NLS-1$
									+ cs, this.ToString(), index);
						}
						lookAhead = 0;
						break;
					}
	
					case 'w':
					case 's':
					case 'd':
					case 'W':
					case 'S':
					case 'D': {
						lookAheadST = ILOG.J2CsMapping.RegEx.AbstractCharClass.GetPredefinedClass(new String(
								pattern, prevNW, 1), false);
						lookAhead = 0;
						break;
					}
	
					case 'Q': {
						saved_mode = mode;
						mode = Lexer.MODE_ESCAPE;
						reread = true;
						break;
					}
	
					case 't':
						lookAhead = '\t';
						break;
					case 'n':
						lookAhead = '\n';
						break;
					case 'r':
						lookAhead = '\r';
						break;
					case 'f':
						lookAhead = '\f';
						break;
					case 'a':
						lookAhead = '\u0007';
						break;
					case 'e':
						lookAhead = '\u001B';
						break;
	
					case '1':
					case '2':
					case '3':
					case '4':
					case '5':
					case '6':
					case '7':
					case '8':
					case '9': {
						if (mode == Lexer.MODE_PATTERN) {
							lookAhead = -2147483648 | lookAhead;
						}
						break;
					}
	
					case '0':
						lookAhead = ReadOctals();
						break;
					case 'x':
						lookAhead = ReadHex("hexadecimal", 2); //$NON-NLS-1$
						break;
					case 'u':
						lookAhead = ReadHex("Unicode", 4); //$NON-NLS-1$
						break;
	
					case 'b':
						lookAhead = CHAR_WORD_BOUND;
						break;
					case 'B':
						lookAhead = CHAR_NONWORD_BOUND;
						break;
					case 'A':
						lookAhead = CHAR_START_OF_INPUT;
						break;
					case 'G':
						lookAhead = CHAR_PREVIOUS_MATCH;
						break;
					case 'Z':
						lookAhead = CHAR_END_OF_LINE;
						break;
					case 'z':
						lookAhead = CHAR_END_OF_INPUT;
						break;
					case 'c': {
						if (index < pattern.Length - 2) {
	
							//need not care about supplementary codepoints here
							lookAhead = (pattern[NextIndex()] & 0x1f);
							break;
						} else {
							throw new PatternSyntaxException("regex.12" //$NON-NLS-1$
									, this.ToString(), index);
						}
					}
						break;
					case 'C':
					case 'E':
					case 'F':
					case 'H':
					case 'I':
					case 'J':
					case 'K':
					case 'L':
					case 'M':
					case 'N':
					case 'O':
					case 'R':
					case 'T':
					case 'U':
					case 'V':
					case 'X':
					case 'Y':
					case 'g':
					case 'h':
					case 'i':
					case 'j':
					case 'k':
					case 'l':
					case 'm':
					case 'o':
					case 'q':
					case 'y':
						throw new PatternSyntaxException("regex.13" //$NON-NLS-1$
								, this.ToString(), index);
	
					default:
						break;
					}
				} else if (mode == Lexer.MODE_PATTERN) {
					switch (lookAhead) {
					case '+':
					case '*':
					case '?': {
						char mod = (index < pattern.Length) ? pattern[index] : '*';
						switch ((int) mod) {
						case '+': {
							lookAhead = lookAhead | Lexer.QMOD_POSSESSIVE;
							NextIndex();
							break;
						}
						case '?': {
							lookAhead = lookAhead | Lexer.QMOD_RELUCTANT;
							NextIndex();
							break;
						}
						default: {
							lookAhead = lookAhead | Lexer.QMOD_GREEDY;
							break;
						}
						}
	
						break;
					}
	
					case '{': {
						lookAheadST = ProcessQuantifier(lookAhead);
						break;
					}
	
					case '$':
						lookAhead = CHAR_DOLLAR;
						break;
					case '(': {
						if (pattern[index] == '?') {
							NextIndex();
							char nonCap = pattern[index];
							bool behind = false;
							do {
								if (!behind) {
									switch ((int) nonCap) {
									case '!':
										lookAhead = CHAR_NEG_LOOKAHEAD;
										NextIndex();
										break;
									case '=':
										lookAhead = CHAR_POS_LOOKAHEAD;
										NextIndex();
										break;
									case '>':
										lookAhead = CHAR_ATOMIC_GROUP;
										NextIndex();
										break;
									case '<': {
										NextIndex();
										nonCap = pattern[index];
										behind = true;
										break;
									}
									default: {
										lookAhead = ReadFlags();
	
										/*
										 * We return res = res | 1 << 8
										 * from readFlags() if we read
										 * (?idmsux-idmsux)
										 */
										if (lookAhead >= 256) {
	
											//Erase auxiliary bit
											lookAhead = (lookAhead & 0xff);
											flags = lookAhead;
											lookAhead = lookAhead << 16;
											lookAhead = CHAR_FLAGS | lookAhead;
										} else {
											flags = lookAhead;
											lookAhead = lookAhead << 16;
											lookAhead = CHAR_NONCAP_GROUP
													| lookAhead;
										}
										break;
									}
									}
								} else {
									behind = false;
									switch ((int) nonCap) {
									case '!':
										lookAhead = CHAR_NEG_LOOKBEHIND;
										NextIndex();
										break;
									case '=':
										lookAhead = CHAR_POS_LOOKBEHIND;
										NextIndex();
										break;
									default:
										throw new PatternSyntaxException("regex.14" //$NON-NLS-1$
												, this.ToString(), index);
									}
								}
							} while (behind);
						} else {
							lookAhead = CHAR_LEFT_PARENTHESIS;
						}
						break;
					}
	
					case ')':
						lookAhead = CHAR_RIGHT_PARENTHESIS;
						break;
					case '[': {
						lookAhead = CHAR_LEFT_SQUARE_BRACKET;
						SetMode(Lexer.MODE_RANGE);
						break;
					}
					case ']': {
						if (mode == Lexer.MODE_RANGE) {
							lookAhead = CHAR_RIGHT_SQUARE_BRACKET;
						}
						break;
					}
					case '^':
						lookAhead = CHAR_CARET;
						break;
					case '|':
						lookAhead = CHAR_VERTICAL_BAR;
						break;
					case '.':
						lookAhead = CHAR_DOT;
						break;
					default:
						break;
					}
				} else if (mode == Lexer.MODE_RANGE) {
					switch (lookAhead) {
					case '[':
						lookAhead = CHAR_LEFT_SQUARE_BRACKET;
						break;
					case ']':
						lookAhead = CHAR_RIGHT_SQUARE_BRACKET;
						break;
					case '^':
						lookAhead = CHAR_CARET;
						break;
					case '&':
						lookAhead = CHAR_AMPERSAND;
						break;
					case '-':
						lookAhead = CHAR_HYPHEN;
						break;
					default:
						break;
					}
				}
			} while (reread);
		}
	
		/// <summary>
		/// Parse character classes names and verifies correction of the syntax;
		/// </summary>
		///
		private String ParseCharClassName() {
			StringBuilder sb = new StringBuilder(10);
			if (index < pattern.Length - 2) {
				// one symbol family
				if (pattern[index] != '{') {
					return "Is" + new String(pattern, NextIndex(), 1); //$NON-NLS-1$
				}
	
				NextIndex();
				char ch_0 = (char) (0);
				while (index < pattern.Length - 2
						&& (ch_0 = pattern[NextIndex()]) != '}') {
					sb.Append((char) ch_0);
				}
				if (ch_0 != '}')
					throw new PatternSyntaxException("regex.15", this //$NON-NLS-1$
							.ToString(), index);
			}
	
			if (sb.Length == 0)
				throw new PatternSyntaxException("regex.16", this.ToString(), //$NON-NLS-1$
						index);
	
			String res = sb.ToString();
			if (res.Length == 1)
				return "Is" + res; //$NON-NLS-1$
			return (res.Length > 3 && (res.StartsWith("Is") || res.StartsWith("In"))) ? res.Substring(2) : res; //$NON-NLS-1$
		}
	
		/// <summary>
		/// Process given character in assumption that it's quantifier.
		/// </summary>
		///
		private Quantifier ProcessQuantifier(int ch_0) {
			StringBuilder sb = new StringBuilder(4);
			int min = -1;
			int max = Int32.MaxValue;
			while (index < pattern.Length && (ch_0 = pattern[NextIndex()]) != '}') {
				if (ch_0 == ',' && min < 0) {
					try {
						min = ((Int32 )Convert.ToInt32(sb.ToString(),10));
						sb.Remove(0,sb.Length-(0));
					} catch (FormatException nfe) {
						throw new PatternSyntaxException("regex.17", this //$NON-NLS-1$
								.ToString(), index);
					}
				} else {
					sb.Append((char) ch_0);
				}
			}
			if (ch_0 != '}') {
				throw new PatternSyntaxException("regex.17", //$NON-NLS-1$
						this.ToString(), index);
			}
			if (sb.Length > 0) {
				try {
					max = ((Int32 )Convert.ToInt32(sb.ToString(),10));
					if (min < 0)
						min = max;
				} catch (FormatException nfe_1) {
					throw new PatternSyntaxException("regex.17", this //$NON-NLS-1$
							.ToString(), index);
				}
			} else if (min < 0) {
				throw new PatternSyntaxException("regex.17", //$NON-NLS-1$
						this.ToString(), index);
			}
			if ((min | max | max - min) < 0) {
				throw new PatternSyntaxException("regex.17", //$NON-NLS-1$
						this.ToString(), index);
			}
	
			char mod = (index < pattern.Length) ? pattern[index] : '*';
	
			switch ((int) mod) {
			case '+':
				lookAhead = Lexer.QUANT_COMP_P;
				NextIndex();
				break;
			case '?':
				lookAhead = Lexer.QUANT_COMP_R;
				NextIndex();
				break;
			default:
				lookAhead = Lexer.QUANT_COMP;
				break;
			}
			return new Quantifier(min, max);
		}
	
		public override String ToString() {
			return orig;
		}
	
		/// <summary>
		/// Checks if there are any characters in the pattern.
		/// </summary>
		///
		/// <returns>true if there are no more characters in the pattern.</returns>
		public bool IsEmpty() {
			return ch == 0 && lookAhead == 0 && index == patternFullLength
					&& !IsSpecial();
		}
	
		/// <summary>
		/// Returns true if current character is plain token.
		/// </summary>
		///
		public static bool IsLetter(int ch_0) {
	
			//all supplementary codepoints have integer value that is >= 0;
			return ch_0 >= 0;
		}
	
		/// <summary>
		/// Return true if current character is letter, false otherwise; This is
		/// shortcut to static method isLetter to check the current character.
		/// </summary>
		///
		/// <returns>true if current character is letter, false otherwise</returns>
		public bool IsLetter() {
			return !IsEmpty() && !IsSpecial() && IsLetter(ch);
		}
	
		/*
		 * Note that Character class methods
		 * isHighSurrogate(), isLowSurrogate()
		 * take char parameter while we need an int
		 * parameter without truncation to char value
		 */
		public bool IsHighSurrogate() {
			return (ch <= 0xDBFF) && (ch >= 0xD800);
		}
	
		public bool IsLowSurrogate() {
			return (ch <= 0xDFFF) && (ch >= 0xDC00);
		}
	
		public static bool IsHighSurrogate(int ch_0) {
			return (ch_0 <= 0xDBFF) && (ch_0 >= 0xD800);
		}
	
		public static bool IsLowSurrogate(int ch_0) {
			return (ch_0 <= 0xDFFF) && (ch_0 >= 0xDC00);
		}
	
		/// <summary>
		/// Process hexadecimal integer. 
		/// </summary>
		///
		private int ReadHex(String radixName, int max) {
			StringBuilder st = new StringBuilder(max);
			int length = pattern.Length - 2;
			int i;
			for (i = 0; i < max && index < length; i++) {
				st.Append((char) pattern[NextIndex()]);
			}
			if (i == max) {
				try {
					return ((Int32 )Convert.ToInt32(st.ToString(),16));
				} catch (FormatException nfe) {
				}
			}
	
			throw new PatternSyntaxException("regex.18" + radixName //$NON-NLS-1$
			, this.ToString(), index);
		}
	
		/// <summary>
		/// Process octal integer.
		/// </summary>
		///
		private int ReadOctals() {
			char ch_0;
			int max = 3;
			int i = 1;
			int first;
			int res;
			int length = pattern.Length - 2;
	
			switch (first = ILOG.J2CsMapping.Util.Character.Digit((ch_0 = pattern[index]),8)) {
			case -1:
				throw new PatternSyntaxException("regex.19" //$NON-NLS-1$
						, this.ToString(), index);
			default: {
				if (first > 3)
					max--;
				NextIndex();
				res = first;
			}
				break;
			}
	
			while (i < max && index < length
					&& (first = ILOG.J2CsMapping.Util.Character.Digit((ch_0 = pattern[index]),8)) >= 0) {
				res = res * 8 + first;
				NextIndex();
				i++;
			}
	
			return res;
		}
	
		/// <summary>
		/// Process expression flags given with (?idmsux-idmsux)
		/// </summary>
		///
		private int ReadFlags() {
			char ch_0;
			bool pos = true;
			int res = flags;
	
			while (index < pattern.Length) {
				ch_0 = pattern[index];
				switch ((int) ch_0) {
				case '-':
					if (!pos) {
						throw new PatternSyntaxException("regex.1A" //$NON-NLS-1$
								, this.ToString(), index);
					}
					pos = false;
					break;
	
				case 'i':
					res = (pos) ? res | Pattern.CASE_INSENSITIVE
							: (res ^ Pattern.CASE_INSENSITIVE) & res;
					break;
	
				case 'd':
					res = (pos) ? res | Pattern.UNIX_LINES
							: (res ^ Pattern.UNIX_LINES) & res;
					break;
	
				case 'm':
					res = (pos) ? res | Pattern.MULTILINE : (res ^ Pattern.MULTILINE)
							& res;
					break;
	
				case 's':
					res = (pos) ? res | Pattern.DOTALL : (res ^ Pattern.DOTALL) & res;
					break;
	
				case 'u':
					res = (pos) ? res | Pattern.UNICODE_CASE
							: (res ^ Pattern.UNICODE_CASE) & res;
					break;
	
				case 'x':
					res = (pos) ? res | Pattern.COMMENTS : (res ^ Pattern.COMMENTS)
							& res;
					break;
	
				case ':':
					NextIndex();
					return res;
	
				case ')':
					NextIndex();
					return res | (1 << 8);
	
				default:
					// ignore invalid flags (HARMONY-2127)
					break;
				}
				NextIndex();
			}
			throw new PatternSyntaxException("regex.1A", //$NON-NLS-1$
					this.ToString(), index);
		}
	
		/// <summary>
		/// Returns next character index to read and moves pointer to the next one.
		/// If comments flag is on this method will skip comments and whitespaces.
		/// The following actions are equivalent if comments flag is off ch =
		/// pattern[index++] == ch = pattern[nextIndex]
		/// </summary>
		///
		/// <returns>next character index to read.</returns>
		private int NextIndex() {
			prevNW = index;
			if ((flags & Pattern.COMMENTS) != 0) {
				SkipComments();
			} else {
				index++;
			}
			return prevNW;
		}
	
		/// <summary>
		/// Skips comments and whitespaces
		/// </summary>
		///
		private int SkipComments() {
			int length = pattern.Length - 2;
			index++;
			do {
				while (index < length && Char.IsWhiteSpace(pattern[index]))
					index++;
				if (index < length && pattern[index] == '#') {
					index++;
					while (index < length && !IsLineSeparator(pattern[index]))
						index++;
				} else
					return index;
			} while (true);
		}
	
		private bool IsLineSeparator(int ch_0) {
			return (ch_0 == '\n' || ch_0 == '\r' || ch_0 == '\u0085' || (ch_0 | 1) == '\u2029');
		}
	
		/// <summary>
		/// Gets decomposition for given codepoint from
		/// decomposition mappings table.
		/// </summary>
		///
		/// <param name="ch_0">- Unicode codepoint</param>
		/// <returns>array of codepoints that is a canonical
		/// decomposition of ch.</returns>
		static internal int[] GetDecomposition(int ch_0) {
			return decompTable.Get(ch_0);
		}
	
		/// <summary>
		/// Gets decomposition for given Hangul syllable. 
		/// This is an implementation of Hangul decomposition algorithm 
		/// according to http://www.unicode.org/versions/Unicode4.0.0/ch03.pdf
		/// "3.12 Conjoining Jamo Behavior".
		/// </summary>
		///
		/// <param name="ch_0">- given Hangul syllable</param>
		/// <returns>canonical decomposition of ch.</returns>
		static internal int[] GetHangulDecomposition(int ch_0) {
			int SIndex = ch_0 - SBase;
	
			if (SIndex < 0 || SIndex >= SCount) {
				return null;
			} else {
				int L = LBase + SIndex / NCount;
				int V = VBase + (SIndex % NCount) / TCount;
				int T = SIndex % TCount;
				int[] decomp;
	
				if (T == 0) {
					decomp = new int[] { L, V };
				} else {
					T = TBase + T;
					decomp = new int[] { L, V, T };
				}
				return decomp;
			}
		}
	
		/// <summary>
		/// Gets canonical class for given codepoint from
		/// decomposition mappings table.
		/// </summary>
		///
		/// <param name=" - ch Unicode codepoint"></param>
		/// <returns>canonical class for given Unicode codepoint
		/// that is represented by ch.</returns>
		static internal int GetCanonicalClass(int ch_0) {
			int canClass = canonClassesTable.Get(ch_0);
	
			return (canClass == canonClassesTableSize) ? 0 : canClass;
		}
	
		/// <summary>
		/// Tests if given codepoint is a canonical decomposition of another
		/// codepoint.
		/// </summary>
		///
		/// <param name="ch_0">- codepoint to test</param>
		/// <returns>true if ch is a decomposition.</returns>
		static internal bool HasSingleCodepointDecomposition(int ch_0) {
			int hasSingleDecomp = singleDecompTable.Get(ch_0);
	
			/*
			 * singleDecompTable doesn't contain ch 
			 * == (hasSingleDecomp == singleDecompTableSize)
			 */
			return (hasSingleDecomp == singleDecompTableSize) ? false : true;
		}
	
		/// <summary>
		/// Tests if given codepoint has canonical decomposition
		/// and given codepoint's canonical class is not 0.
		/// </summary>
		///
		/// <param name="ch_0">- codepoint to test</param>
		/// <returns>true if canonical class is not 0 and ch has a decomposition.</returns>
		static internal bool HasDecompositionNonNullCanClass(int ch_0) {
			return ch_0 == 0x0340 | ch_0 == 0x0341 | ch_0 == 0x0343 | ch_0 == 0x0344;
		}
	
		private int NextCodePoint() {
			char high = pattern[NextIndex()];
	
			if (System.Char.IsHighSurrogate(high)) {
	
				//low and high char may be delimited by spaces
				int lowExpectedIndex = prevNW + 1;
	
				if (lowExpectedIndex < pattern.Length) {
					char low = pattern[lowExpectedIndex];
					if (System.Char.IsLowSurrogate(low)) {
						NextIndex();
                        return Character.ToCodePoint(high, low);
					}
				}
			}
	
			return (int) high;
		}
	
		/// <summary>
		/// Tests Unicode codepoint if it is a boundary
		/// of decomposed Unicode codepoint. 
		/// </summary>
		///
		/// <param name="ch_0">- Unicode codepoint to test</param>
		/// <returns>true if given codepoint is a boundary.</returns>
		static internal bool IsDecomposedCharBoundary(int ch_0) {
			int canClass = canonClassesTable.Get(ch_0);
	
			//Lexer.getCanonicalClass(ch) == 0
			bool isBoundary = (canClass == canonClassesTableSize);
	
			return isBoundary;
		}
	
		/// <summary>
		/// Returns the curr. character index.
		/// </summary>
		///
		public int GetIndex() {
			return curToc;
		}
	}
}
