/* 
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/1/10 3:36 PM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
namespace ILOG.J2CsMapping.Formatting
{

    using ILOG.J2CsMapping.Text;
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.IO;
    using System.Runtime.CompilerServices;
    using System.Text;

    /// <summary>
    /// ChoiceFormat is used to associate strings with ranges of double values. The
    /// strings and ranges are either specified using arrays or with a pattern which
    /// is parsed to determine the Strings and ranges.
    /// </summary>
    ///

    public class ChoiceFormat : NumberFormat
    {

        private const long serialVersionUID = 1795184449645032964L;

        private double[] choiceLimits;

        private String[] choiceFormats;

        /// <summary>
        /// Constructs a new ChoiceFormat with the specified ranges and associated
        /// strings.
        /// </summary>
        ///
        /// <param name="limits">an array of double, the ranges are greater or equal to thevalue in lower index up to less than the value in the nexthigher index. The bounds of the lowest and highest indexes arenegative and positive infinity.</param>
        /// <param name="formats">the strings associated with the ranges. The lower bound of theassociated range is at the same index as the string.</param>
        public ChoiceFormat(double[] limits, String[] formats)
        {
            SetChoices(limits, formats);
        }

        /// <summary>
        /// Constructs a new ChoiceFormat with the strings and ranges parsed from the
        /// specified pattern.
        /// </summary>
        ///
        /// <param name="template">the pattern of strings and ranges</param>
        /// <exception cref="IllegalArgumentException">then an error occurs parsing the pattern</exception>
        public ChoiceFormat(String template)
        {
            ApplyPattern(template);
        }

        /// <summary>
        /// Parses the pattern to determine new strings and ranges for this
        /// ChoiceFormat.
        /// </summary>
        ///
        /// <param name="template">the pattern of strings and ranges</param>
        /// <exception cref="IllegalArgumentException">then an error occurs parsing the pattern</exception>
        public void ApplyPattern(String template)
        {
            double[] limits = new double[5];
            IList<String> formats = new List<String>();
            int length = template.Length, limitCount = 0, index = 0;
            StringBuilder buffer = new StringBuilder();
            IBM.ICU.Text.NumberFormat format = IBM.ICU.Text.NumberFormat.GetInstance(ILOG.J2CsMapping.Util.Locale.US);
            ParsePosition position = new ParsePosition(0);
            while (true)
            {
                index = SkipWhitespace(template, index);
                if (index >= length)
                {
                    if (limitCount == limits.Length)
                    {
                        choiceLimits = limits;
                    }
                    else
                    {
                        choiceLimits = new double[limitCount];
                        System.Array.Copy((Array)(limits), 0, (Array)(choiceLimits), 0, limitCount);
                    }
                    choiceFormats = new String[formats.Count];
                    for (int i = 0; i < formats.Count; i++)
                    {
                        choiceFormats[i] = formats[i];
                    }
                    return;
                }

                position.SetIndex(index);
                object value_ren = format.Parse(template, position);
                index = SkipWhitespace(template, position.GetIndex());
                if (position.GetErrorIndex() != -1 || index >= length)
                {
                    // Fix Harmony 540
                    choiceLimits = new double[0];
                    choiceFormats = new String[0];
                    return;
                }
                char ch = template[index++];
                if (limitCount == limits.Length)
                {
                    double[] newLimits = new double[limitCount * 2];
                    System.Array.Copy((Array)(limits), 0, (Array)(newLimits), 0, limitCount);
                    limits = newLimits;
                }
                double next;
                switch ((int)ch)
                {
                    case '#':
                    case '\u2264':
                        next = Convert.ToDouble(value_ren);
                        break;
                    case '<':
                        next = NextDouble(Convert.ToDouble(value_ren));
                        break;
                    default:
                        throw new ArgumentException();
                }
                if (limitCount > 0 && next <= limits[limitCount - 1])
                {
                    throw new ArgumentException();
                }
                buffer.Length = 0;
                position.SetIndex(index);
                ILOG.J2CsMapping.Formatting.Format.UpTo(template, position, buffer, '|');
                index = position.GetIndex();
                limits[limitCount++] = next;
                ILOG.J2CsMapping.Collections.Generics.Collections.Add(formats, buffer.ToString());
            }
        }

        /// <summary>
        /// Answers a new instance of ChoiceFormat with the same ranges and strings
        /// as this ChoiceFormat.
        /// </summary>
        ///
        /// <returns>a shallow copy of this ChoiceFormat</returns>
        /// <seealso cref="T:System.ICloneable"/>
        public override Object Clone()
        {
            ChoiceFormat clone = (ChoiceFormat)base.Clone();
            clone.choiceLimits = (double[])choiceLimits.Clone();
            clone.choiceFormats = (string[])choiceFormats.Clone();
            return clone;
        }

        /// <summary>
        /// Compares the specified object to this ChoiceFormat and answer if they are
        /// equal. The object must be an instance of ChoiceFormat and have the same
        /// limits and formats.
        /// </summary>
        ///
        /// <param name="object">the object to compare with this object</param>
        /// <returns>true if the specified object is equal to this ChoiceFormat, false
        /// otherwise</returns>
        /// <seealso cref="M:ILOG.J2CsMapping.Text2.ChoiceFormat.HashCode"/>
        public override bool Equals(Object obj0)
        {
            if ((Object)this == obj0)
            {
                return true;
            }
            if (!(obj0 is ChoiceFormat))
            {
                return false;
            }
            ChoiceFormat choice = (ChoiceFormat)obj0;
            return ILOG.J2CsMapping.Collections.Arrays.Equals(choiceLimits, choice.choiceLimits)
                    && ILOG.J2CsMapping.Collections.Arrays.Equals(choiceFormats, choice.choiceFormats);
        }

        /// <summary>
        /// Appends to the specified StringBuffer the string associated with the
        /// range in which the specified double value fits.
        /// </summary>
        ///
        /// <param name="value">the double to format</param>
        /// <param name="buffer">the StringBuffer</param>
        /// <param name="field">a FieldPosition which is ignored</param>
        /// <returns>the StringBuffer parameter <c>buffer</c></returns>
        public override StringBuilder Format(double value_ren, StringBuilder buffer,
                FieldPosition field)
        {
            for (int i = choiceLimits.Length - 1; i >= 0; i--)
            {
                if (choiceLimits[i] <= value_ren)
                {
                    return buffer.Append(choiceFormats[i]);
                }
            }
            return (choiceFormats.Length == 0) ? buffer : buffer
                    .Append(choiceFormats[0]);
        }

        /// <summary>
        /// Appends to the specified StringBuffer the string associated with the
        /// range in which the specified long value fits.
        /// </summary>
        ///
        /// <param name="value">the long to format</param>
        /// <param name="buffer">the StringBuffer</param>
        /// <param name="field">a FieldPosition which is ignored</param>
        /// <returns>the StringBuffer parameter <c>buffer</c></returns>
        public override StringBuilder Format(long value_ren, StringBuilder buffer,
                FieldPosition field)
        {
            return Format((double)value_ren, buffer, field);
        }

        /// <summary>
        /// Answers the Strings associated with the ranges of this ChoiceFormat.
        /// </summary>
        ///
        /// <returns>an array of String</returns>
        public Object[] GetFormats()
        {
            return choiceFormats;
        }

        /// <summary>
        /// Answers the ranges of this ChoiceFormat.
        /// </summary>
        ///
        /// <returns>an array of double, the ranges are greater or equal to the value
        /// in lower index up to less than the value in the next higher
        /// index. The bounds of the lowest and highest indexes are negative
        /// and positive infinity.</returns>
        public double[] GetLimits()
        {
            return choiceLimits;
        }

        /// <summary>
        /// Answers an integer hash code for the receiver. Objects which are equal
        /// answer the same value for this method.
        /// </summary>
        ///
        /// <returns>the receiver's hash</returns>
        /// <seealso cref="M:ILOG.J2CsMapping.Text2.ChoiceFormat.Equals(System.Object)"/>
        public override int GetHashCode()
        {
            int hashCode = 0;
            for (int i = 0; i < choiceLimits.Length; i++)
            {
                long v = BitConverter.DoubleToInt64Bits(choiceLimits[i]);
                hashCode += (int)(v ^ ((long)(((ulong)v) >> 32))) + choiceFormats[i].GetHashCode();
            }
            return hashCode;
        }

        /// <summary>
        /// Answers the double value which is closest to the specified double but
        /// larger.
        /// </summary>
        ///
        /// <param name="value">a double value</param>
        /// <returns>the next larger double value</returns>
        public static double NextDouble(double value_ren)
        {
            if (value_ren == System.Double.PositiveInfinity)
            {
                return value_ren;
            }
            long bits;
            // Handle -0.0
            if (value_ren == 0)
            {
                bits = 0;
            }
            else
            {
                bits = BitConverter.DoubleToInt64Bits(value_ren);
            }
            return BitConverter.Int64BitsToDouble((value_ren < 0) ? bits - 1 : bits + 1);
        }

        /// <summary>
        /// Answers the double value which is closest to the specified double but
        /// either larger or smaller as specified.
        /// </summary>
        ///
        /// <param name="value">a double value</param>
        /// <param name="increment">true to get a larger value, false to get a smaller value</param>
        /// <returns>the next larger or smaller double value</returns>
        public static double NextDouble(double value_ren, bool increment)
        {
            return (increment) ? NextDouble(value_ren) : PreviousDouble(value_ren);
        }

        /// <summary>
        /// Parse a Double from the specified String starting at the index specified
        /// by the ParsePosition. The String is compared to the strings of this
        /// ChoiceFormat and if a match occurs, the answer is the lower bound of the
        /// corresponding range. If the string is successfully parsed, the index of
        /// the ParsePosition is updated to the index following the parsed text.
        /// </summary>
        ///
        /// <param name="string">the String to parse</param>
        /// <param name="position">the ParsePosition, updated on return with the index followingthe parsed text, or on error the index is unchanged and theerror index is set to the index where the error occurred</param>
        /// <returns>a Double resulting from the parse, or Double.NaN if there is an
        /// error</returns>
        public override object Parse(String str0, ParsePosition position)
        {
            int offset = position.GetIndex();
            for (int i = 0; i < choiceFormats.Length; i++)
            {
                if (ILOG.J2CsMapping.Util.StringUtil.StartsWith(str0, choiceFormats[i], offset))
                {
                    position.SetIndex(offset + choiceFormats[i].Length);
                    return (double)(choiceLimits[i]);
                }
            }
            position.SetErrorIndex(offset);
            return (double)(System.Double.NaN);
        }

        /// <summary>
        /// Answers the double value which is closest to the specified double but
        /// smaller.
        /// </summary>
        ///
        /// <param name="value">a double value</param>
        /// <returns>the next smaller double value</returns>
        public static double PreviousDouble(double value_ren)
        {
            if (value_ren == System.Double.NegativeInfinity)
            {
                return value_ren;
            }
            long bits;
            // Handle 0.0
            if (value_ren == 0)
            {
                bits = -9223372036854775808;
            }
            else
            {
                bits = BitConverter.DoubleToInt64Bits(value_ren);
            }
            return BitConverter.Int64BitsToDouble((value_ren <= 0) ? bits + 1 : bits - 1);
        }

        /// <summary>
        /// Sets the ranges and associated strings of this ChoiceFormat.
        /// </summary>
        ///
        /// <param name="limits">an array of double, the ranges are greater or equal to thevalue in lower index up to less than the value in the nexthigher index. The bounds of the lowest and highest indexes arenegative and positive infinity.</param>
        /// <param name="formats">the strings associated with the ranges. The lower bound of therange is at the same index as the string.</param>
        public void SetChoices(double[] limits, String[] formats)
        {
            if (limits.Length != formats.Length)
            {
                throw new ArgumentException();
            }
            choiceLimits = limits;
            choiceFormats = formats;
        }

        private int SkipWhitespace(String str0, int index)
        {
            int length = str0.Length;
            while (index < length && Char.IsWhiteSpace(str0[index]))
            {
                index++;
            }
            return index;
        }

        /// <summary>
        /// Answers the pattern of this ChoiceFormat which specified the ranges and
        /// their associated strings.
        /// </summary>
        ///
        /// <returns>the pattern</returns>
        public String ToPattern()
        {
            StringBuilder buffer = new StringBuilder();
            for (int i = 0; i < choiceLimits.Length; i++)
            {
                if (i != 0)
                {
                    buffer.Append('|');
                }
                String previous = PreviousDouble(choiceLimits[i]).ToString();
                String limit = choiceLimits[i].ToString();
                if (previous.Length < limit.Length)
                {
                    buffer.Append(previous);
                    buffer.Append('<');
                }
                else
                {
                    buffer.Append(limit);
                    buffer.Append('#');
                }
                bool quote = (choiceFormats[i].IndexOf('|') != -1);
                if (quote)
                {
                    buffer.Append('\'');
                }
                buffer.Append(choiceFormats[i]);
                if (quote)
                {
                    buffer.Append('\'');
                }
            }
            return buffer.ToString();
        }
    }
}
