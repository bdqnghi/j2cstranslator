/*
 *******************************************************************************
 * Copyright (C) 1996-2007, International Business Machines Corporation and    *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 */
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:30 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Text {
	
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Text;
	
	/// <exclude/>
	/// <summary>
	/// A transliterator that is composed of two or more other transliterator objects
	/// linked together. For example, if one transliterator transliterates from
	/// script A to script B, and another transliterates from script B to script C,
	/// the two may be combined to form a new transliterator from A to C.
	/// <p>
	/// Composed transliterators may not behave as expected. For example, inverses
	/// may not combine to form the identity transliterator. See the class
	/// documentation for <see cref="T:IBM.ICU.Text.Transliterator"/> for details.
	/// <p>
	/// Copyright &copy; IBM Corporation 1999. All rights reserved.
	/// </summary>
	///
	internal class CompoundTransliterator : Transliterator {
	
	    private Transliterator[] trans;
	
	    private int numAnonymousRBTs;
	
	    /**
	     * Constructs a new compound transliterator given an array of
	     * transliterators. The array of transliterators may be of any length,
	     * including zero or one, however, useful compound transliterators have at
	     * least two components.
	     * 
	     * @param transliterators
	     *            array of <code>Transliterator</code> objects
	     * @param filter
	     *            the filter. Any character for which <tt>filter.contains()</tt>
	     *            returns <tt>false</tt> will not be altered by this
	     *            transliterator. If <tt>filter</tt> is <tt>null</tt> then no
	     *            filtering is applied.
	     * @internal
	     */
	    /*
	     * public CompoundTransliterator(Transliterator[] transliterators,
	     * UnicodeFilter filter) { super(joinIDs(transliterators), filter); trans =
	     * new Transliterator[transliterators.length];
	     * System.arraycopy(transliterators, 0, trans, 0, trans.length);
	     * computeMaximumContextLength(); }
	     */
	
	    /**
	     * Constructs a new compound transliterator given an array of
	     * transliterators. The array of transliterators may be of any length,
	     * including zero or one, however, useful compound transliterators have at
	     * least two components.
	     * 
	     * @param transliterators
	     *            array of <code>Transliterator</code> objects
	     * @internal
	     */
	    /*
	     * public CompoundTransliterator(Transliterator[] transliterators) {
	     * this(transliterators, null); }
	     */
	
	    /**
	     * Constructs a new compound transliterator.
	     * 
	     * @param ID
	     *            compound ID
	     * @param direction
	     *            either Transliterator.FORWARD or Transliterator.REVERSE
	     * @param filter
	     *            a global filter for this compound transliterator or null
	     * @internal
	     */
	    /*
	     * public CompoundTransliterator(String ID, int direction, UnicodeFilter
	     * filter) { super(ID, filter); init(ID, direction, true); }
	     */
	
	    /**
	     * Constructs a new compound transliterator with no filter.
	     * 
	     * @param ID
	     *            compound ID
	     * @param direction
	     *            either Transliterator.FORWARD or Transliterator.REVERSE
	     * @internal
	     */
	    /*
	     * public CompoundTransliterator(String ID, int direction) { this(ID,
	     * direction, null); }
	     */
	
	    /**
	     * Constructs a new forward compound transliterator with no filter.
	     * 
	     * @param ID
	     *            compound ID
	     * @internal
	     */
	    /*
	     * public CompoundTransliterator(String ID) { this(ID, FORWARD, null); }
	     */
	
	    /// <summary>
	    /// Package private constructor for Transliterator from a vector of
	    /// transliterators. The caller is responsible for fixing up the ID.
	    /// </summary>
	    ///
	    internal CompoundTransliterator(ArrayList list) : this(list, 0) {
	    }
	
	    internal CompoundTransliterator(ArrayList list, int numAnonymousRBTs_0) : base("", null) {
	        this.numAnonymousRBTs = 0;
	        trans = null;
	        Init(list, IBM.ICU.Text.Transliterator.FORWARD, false);
	        this.numAnonymousRBTs = numAnonymousRBTs_0;
	        // assume caller will fixup ID
	    }
	
	    /**
	     * Finish constructing a transliterator: only to be called by constructors.
	     * Before calling init(), set trans and filter to NULL.
	     * 
	     * @param id
	     *            the id containing ';'-separated entries
	     * @param direction
	     *            either FORWARD or REVERSE
	     * @param idSplitPoint
	     *            the index into id at which the splitTrans should be inserted,
	     *            if there is one, or -1 if there is none.
	     * @param splitTrans
	     *            a transliterator to be inserted before the entry at offset
	     *            idSplitPoint in the id string. May be NULL to insert no entry.
	     * @param fixReverseID
	     *            if TRUE, then reconstruct the ID of reverse entries by calling
	     *            getID() of component entries. Some constructors do not require
	     *            this because they apply a facade ID anyway.
	     */
	    /*
	     * private void init(String id, int direction, boolean fixReverseID) { //
	     * assert(trans == 0);
	     * 
	     * Vector list = new Vector(); UnicodeSet[] compoundFilter = new
	     * UnicodeSet[1]; StringBuffer regenID = new StringBuffer(); if
	     * (!TransliteratorIDParser.parseCompoundID(id, direction, regenID, list,
	     * compoundFilter)) { throw new IllegalArgumentException("Invalid ID " +
	     * id); }
	     * 
	     * TransliteratorIDParser.instantiateList(list);
	     * 
	     * init(list, direction, fixReverseID);
	     * 
	     * if (compoundFilter[0] != null) { setFilter(compoundFilter[0]); } }
	     */
	
	    /// <summary>
	    /// Finish constructing a transliterator: only to be called by constructors.
	    /// Before calling init(), set trans and filter to NULL.
	    /// </summary>
	    ///
	    /// <param name="list">a vector of transliterator objects to be adopted. It shouldNOT be empty. The list should be in declared order. That is,it should be in the FORWARD order; if direction is REVERSEthen the list order will be reversed.</param>
	    /// <param name="direction">either FORWARD or REVERSE</param>
	    /// <param name="fixReverseID">if TRUE, then reconstruct the ID of reverse entries by callinggetID() of component entries. Some constructors do not requirethis because they apply a facade ID anyway.</param>
	    private void Init(ArrayList list, int direction, bool fixReverseID) {
	        // assert(trans == 0);
	
	        // Allocate array
	        int count = list.Count;
	        trans = new Transliterator[count];
	
	        // Move the transliterators from the vector into an array.
	        // Reverse the order if necessary.
	        int i;
	        for (i = 0; i < count; ++i) {
	            int j = (direction == IBM.ICU.Text.Transliterator.FORWARD) ? i : count - 1 - i;
	            trans[i] = (Transliterator) list[j];
	        }
	
	        // If the direction is UTRANS_REVERSE then we may need to fix the
	        // ID.
	        if (direction == IBM.ICU.Text.Transliterator.REVERSE && fixReverseID) {
	            StringBuilder newID = new StringBuilder();
	            for (i = 0; i < count; ++i) {
	                if (i > 0) {
	                    newID.Append(IBM.ICU.Text.Transliterator.ID_DELIM);
	                }
	                newID.Append(trans[i].GetID());
	            }
	            SetID(newID.ToString());
	        }
	
	        ComputeMaximumContextLength();
	    }
	
	    /**
	     * Return the IDs of the given list of transliterators, concatenated with
	     * ';' delimiting them. Equivalent to the perlish expression join(';',
	     * map($_.getID(), transliterators).
	     */
	    /*
	     * private static String joinIDs(Transliterator[] transliterators) {
	     * StringBuffer id = new StringBuffer(); for (int i=0;
	     * i<transliterators.length; ++i) { if (i > 0) { id.append(';'); }
	     * id.append(transliterators[i].getID()); } return id.toString(); }
	     */
	
	    /// <exclude/>
	    /// <summary>
	    /// Returns the number of transliterators in this chain.
	    /// </summary>
	    ///
	    /// <returns>number of transliterators in this chain.</returns>
	    public int GetCount() {
	        return trans.Length;
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Returns the transliterator at the given index in this chain.
	    /// </summary>
	    ///
	    /// <param name="index">index into chain, from 0 to <c>getCount() - 1</c></param>
	    /// <returns>transliterator at the given index</returns>
	    public Transliterator GetTransliterator(int index) {
	        return trans[index];
	    }
	
	    /// <summary>
	    /// Append c to buf, unless buf is empty or buf already ends in c.
	    /// </summary>
	    ///
	    private static void _smartAppend(StringBuilder buf, char c) {
	        if (buf.Length != 0 && buf[buf.Length - 1] != c) {
	            buf.Append(c);
	        }
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Override Transliterator: Create a rule string that can be passed to
	    /// createFromRules() to recreate this transliterator.
	    /// </summary>
	    ///
	    /// <param name="escapeUnprintable">if TRUE then convert unprintable character to their hex escaperepresentations, \\uxxxx or \\Uxxxxxxxx. Unprintablecharacters are those other than U+000A, U+0020..U+007E.</param>
	    /// <returns>the rule string</returns>
	    public override String ToRules(bool escapeUnprintable) {
	        // We do NOT call toRules() on our component transliterators, in
	        // general. If we have several rule-based transliterators, this
	        // yields a concatenation of the rules -- not what we want. We do
	        // handle compound RBT transliterators specially -- those for which
	        // compoundRBTIndex >= 0. For the transliterator at compoundRBTIndex,
	        // we do call toRules() recursively.
	        StringBuilder rulesSource = new StringBuilder();
	        if (numAnonymousRBTs >= 1 && GetFilter() != null) {
	            // If we are a compound RBT and if we have a global
	            // filter, then emit it at the top.
	            rulesSource.Append("::")
	                    .Append(GetFilter().ToPattern(escapeUnprintable))
	                    .Append(IBM.ICU.Text.Transliterator.ID_DELIM);
	        }
	        for (int i = 0; i < trans.Length; ++i) {
	            String rule;
	
	            // Anonymous RuleBasedTransliterators (inline rules and
	            // ::BEGIN/::END blocks) are given IDs that begin with
	            // "%Pass": use toRules() to write all the rules to the output
	            // (and insert "::Null;" if we have two in a row)
	            if (trans[i].GetID().StartsWith("%Pass")) {
	                rule = trans[i].ToRules(escapeUnprintable);
	                if (numAnonymousRBTs > 1 && i > 0
	                        && trans[i - 1].GetID().StartsWith("%Pass"))
	                    rule = "::Null;" + rule;
	
	                // we also use toRules() on CompoundTransliterators (which we
	                // check for by looking for a semicolon in the ID)-- this gets
	                // the list of their child transliterators output in the right
	                // format
	            } else if (trans[i].GetID().IndexOf(';') >= 0) {
	                rule = trans[i].ToRules(escapeUnprintable);
	
	                // for everything else, use baseToRules()
	            } else {
	                rule = trans[i].BaseToRules(escapeUnprintable);
	            }
	            _smartAppend(rulesSource, '\n');
	            rulesSource.Append(rule);
	            _smartAppend(rulesSource, IBM.ICU.Text.Transliterator.ID_DELIM);
	        }
	        return rulesSource.ToString();
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Return the set of all characters that may be modified by this
	    /// Transliterator, ignoring the effect of our filter.
	    /// </summary>
	    ///
	    protected internal override UnicodeSet HandleGetSourceSet() {
	        UnicodeSet set = new UnicodeSet();
	        for (int i = 0; i < trans.Length; ++i) {
	            set.AddAll(trans[i].GetSourceSet());
	            // Take the example of Hiragana-Latin. This is really
	            // Hiragana-Katakana; Katakana-Latin. The source set of
	            // these two is roughly [:Hiragana:] and [:Katakana:].
	            // But the source set for the entire transliterator is
	            // actually [:Hiragana:] ONLY -- that is, the first
	            // non-empty source set.
	
	            // This is a heuristic, and not 100% reliable.
	            if (!set.IsEmpty()) {
	                break;
	            }
	        }
	        return set;
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Returns the set of all characters that may be generated as replacement
	    /// text by this transliterator.
	    /// </summary>
	    ///
	    public override UnicodeSet GetTargetSet() {
	        UnicodeSet set = new UnicodeSet();
	        for (int i = 0; i < trans.Length; ++i) {
	            // This is a heuristic, and not 100% reliable.
	            set.AddAll(trans[i].GetTargetSet());
	        }
	        return set;
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Implements <see cref="M:IBM.ICU.Text.Transliterator.HandleTransliterate(IBM.ICU.Text.Replaceable, null, System.Boolean)"/>.
	    /// </summary>
	    ///
	    protected internal override void HandleTransliterate(Replaceable text, Transliterator.Position  index,
	            bool incremental) {
	        /*
	         * Call each transliterator with the same start value and initial cursor
	         * index, but with the limit index as modified by preceding
	         * transliterators. The cursor index must be reset for each
	         * transliterator to give each a chance to transliterate the text. The
	         * initial cursor index is known to still point to the same place after
	         * each transliterator is called because each transliterator will not
	         * change the text between start and the initial value of cursor.
	         * 
	         * IMPORTANT: After the first transliterator, each subsequent
	         * transliterator only gets to transliterate text committed by preceding
	         * transliterators; that is, the cursor (output value) of transliterator
	         * i becomes the limit (input value) of transliterator i+1. Finally, the
	         * overall limit is fixed up before we return.
	         * 
	         * Assumptions we make here: (1) contextStart <= start <= limit <=
	         * contextLimit <= text.length() (2) start <= start' <= limit' ;cursor
	         * doesn't move back (3) start <= limit' ;text before cursor unchanged -
	         * start' is the value of start after calling handleKT - limit' is the
	         * value of limit after calling handleKT
	         */
	
	        /**
	         * Example: 3 transliterators. This example illustrates the mechanics we
	         * need to implement. C, S, and L are the contextStart, start, and
	         * limit. gl is the globalLimit. contextLimit is equal to limit
	         * throughout.
	         * 
	         * 1. h-u, changes hex to Unicode
	         * 
	         * 4 7 a d 0 4 7 a abc/u0061/u => abca/u C S L C S L gl=f->a
	         * 
	         * 2. upup, changes "x" to "XX"
	         * 
	         * 4 7 a 4 7 a abca/u => abcAA/u C SL C S L gl=a->b 3. u-h, changes
	         * Unicode to hex
	         * 
	         * 4 7 a 4 7 a d 0 3 abcAA/u => abc/u0041/u0041/u C S L C S L gl=b->15
	         * 4. return
	         * 
	         * 4 7 a d 0 3 abc/u0041/u0041/u C S L
	         */
	
	        if (trans.Length < 1) {
	            index.start = index.limit;
	            return; // Short circuit for empty compound transliterators
	        }
	
	        // compoundLimit is the limit value for the entire compound
	        // operation. We overwrite index.limit with the previous
	        // index.start. After each transliteration, we update
	        // compoundLimit for insertions or deletions that have happened.
	        int compoundLimit = index.limit;
	
	        // compoundStart is the start for the entire compound
	        // operation.
	        int compoundStart = index.start;
	
	        int delta = 0; // delta in length
	
	        StringBuilder log = null;
	        if (IBM.ICU.Text.Transliterator.DEBUG) {
	            log = new StringBuilder("CompoundTransliterator{" + GetID()
	                    + ((incremental) ? "}i: IN=" : "}: IN="));
	            IBM.ICU.Impl.UtilityExtensions.FormatInput(log, text, index);
	            System.Console.Out.WriteLine(IBM.ICU.Impl.Utility.Escape(log.ToString()));
	        }
	
	        // Give each transliterator a crack at the run of characters.
	        // See comments at the top of the method for more detail.
	        for (int i = 0; i < trans.Length; ++i) {
	            index.start = compoundStart; // Reset start
	            int limit = index.limit;
	
	            if (index.start == index.limit) {
	                // Short circuit for empty range
	                if (IBM.ICU.Text.Transliterator.DEBUG) {
	                    System.Console.Out.WriteLine("CompoundTransliterator[" + i + ".."
	                            + (trans.Length - 1)
	                            + ((incremental) ? "]i: " : "]: ")
	                            + IBM.ICU.Impl.UtilityExtensions.FormatInput(text, index)
	                            + " (NOTHING TO DO)");
	                }
	                break;
	            }
	
	            if (IBM.ICU.Text.Transliterator.DEBUG) {
	                log.Length=0;
	                log.Append("CompoundTransliterator[" + i + "="
	                        + trans[i].GetID() + ((incremental) ? "]i: " : "]: "));
	                IBM.ICU.Impl.UtilityExtensions.FormatInput(log, text, index);
	            }
	
	            trans[i].FilteredTransliterate(text, index, incremental);
	
	            // In a properly written transliterator, start == limit after
	            // handleTransliterate() returns when incremental is false.
	            // Catch cases where the subclass doesn't do this, and throw
	            // an exception. (Just pinning start to limit is a bad idea,
	            // because what's probably happening is that the subclass
	            // isn't transliterating all the way to the end, and it should
	            // in non-incremental mode.)
	            if (!incremental && index.start != index.limit) {
	                throw new Exception(
	                        "ERROR: Incomplete non-incremental transliteration by "
	                                + trans[i].GetID());
	            }
	
	            if (IBM.ICU.Text.Transliterator.DEBUG) {
	                log.Append(" => ");
	                IBM.ICU.Impl.UtilityExtensions.FormatInput(log, text, index);
	                System.Console.Out.WriteLine(IBM.ICU.Impl.Utility.Escape(log.ToString()));
	            }
	
	            // Cumulative delta for insertions/deletions
	            delta += index.limit - limit;
	
	            if (incremental) {
	                // In the incremental case, only allow subsequent
	                // transliterators to modify what has already been
	                // completely processed by prior transliterators. In the
	                // non-incrmental case, allow each transliterator to
	                // process the entire text.
	                index.limit = index.start;
	            }
	        }
	
	        compoundLimit += delta;
	
	        // Start is good where it is -- where the last transliterator left
	        // it. Limit needs to be put back where it was, modulo
	        // adjustments for deletions/insertions.
	        index.limit = compoundLimit;
	
	        if (IBM.ICU.Text.Transliterator.DEBUG) {
	            log.Length=0;
	            log.Append("CompoundTransliterator{" + GetID()
	                    + ((incremental) ? "}i: OUT=" : "}: OUT="));
	            IBM.ICU.Impl.UtilityExtensions.FormatInput(log, text, index);
	            System.Console.Out.WriteLine(IBM.ICU.Impl.Utility.Escape(log.ToString()));
	        }
	    }
	
	    /// <summary>
	    /// Compute and set the length of the longest context required by this
	    /// transliterator. This is <em>preceding</em> context.
	    /// </summary>
	    ///
	    private void ComputeMaximumContextLength() {
	        int max = 0;
	        for (int i = 0; i < trans.Length; ++i) {
	            int len = trans[i].GetMaximumContextLength();
	            if (len > max) {
	                max = len;
	            }
	        }
	        SetMaximumContextLength(max);
	    }
	}
}
