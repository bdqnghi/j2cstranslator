// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:47 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 1996-2007, International Business Machines Corporation and    
/// others. All Rights Reserved.                                                
/// </summary>
///
namespace IBM.ICU.Impl {
	
	using IBM.ICU.Text;
	using IBM.ICU.Util;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Resources;
	using System.Runtime.CompilerServices;
	
	/// <summary>
	/// <p>
	/// Internal class used for Unicode character property database.
	/// </p>
	/// <p>
	/// This classes store binary data read from uprops.icu. It does not have the
	/// capability to parse the data into more high-level information. It only
	/// returns bytes of information when required.
	/// </p>
	/// <p>
	/// Due to the form most commonly used for retrieval, array of char is used to
	/// store the binary data.
	/// </p>
	/// <p>
	/// UCharacterPropertyDB also contains information on accessing indexes to
	/// significant points in the binary data.
	/// </p>
	/// <p>
	/// Responsibility for molding the binary data into more meaning form lies on <a
	/// href=UCharacter.html>UCharacter</a>.
	/// </p>
	/// </summary>
	///
	/// @draft 2.1
	
	public sealed class UCharacterProperty {
	    // public data members -----------------------------------------------
	
	    /// <summary>
	    /// Trie data
	    /// </summary>
	    ///
	    public CharTrie m_trie_;
	
	    /// <summary>
	    /// Optimization CharTrie index array
	    /// </summary>
	    ///
	    public char[] m_trieIndex_;
	
	    /// <summary>
	    /// Optimization CharTrie data array
	    /// </summary>
	    ///
	    public char[] m_trieData_;
	
	    /// <summary>
	    /// Optimization CharTrie data offset
	    /// </summary>
	    ///
	    public int m_trieInitialValue_;
	
	    /// <summary>
	    /// Unicode version
	    /// </summary>
	    ///
	    public VersionInfo m_unicodeVersion_;
	
	    /// <summary>
	    /// Latin capital letter i with dot above
	    /// </summary>
	    ///
	    public const char LATIN_CAPITAL_LETTER_I_WITH_DOT_ABOVE_ = (char) (0x130);
	
	    /// <summary>
	    /// Latin small letter i with dot above
	    /// </summary>
	    ///
	    public const char LATIN_SMALL_LETTER_DOTLESS_I_ = (char) (0x131);
	
	    /// <summary>
	    /// Latin lowercase i
	    /// </summary>
	    ///
	    public const char LATIN_SMALL_LETTER_I_ = (char) (0x69);
	
	    /// <summary>
	    /// Character type mask
	    /// </summary>
	    ///
	    public const int TYPE_MASK = 0x1F;
	
	    // uprops.h enum UPropertySource --------------------------------------- ***
	
	    /// <summary>
	    /// No source, not a supported property. 
	    /// </summary>
	    ///
	    public const int SRC_NONE = 0;
	
	    /// <summary>
	    /// From uchar.c/uprops.icu main trie 
	    /// </summary>
	    ///
	    public const int SRC_CHAR = 1;
	
	    /// <summary>
	    /// From uchar.c/uprops.icu properties vectors trie 
	    /// </summary>
	    ///
	    public const int SRC_PROPSVEC = 2;
	
	    /// <summary>
	    /// Hangul_Syllable_Type, from uchar.c/uprops.icu 
	    /// </summary>
	    ///
	    public const int SRC_HST = 3;
	
	    /// <summary>
	    /// From unames.c/unames.icu 
	    /// </summary>
	    ///
	    public const int SRC_NAMES = 4;
	
	    /// <summary>
	    /// From unorm.cpp/unorm.icu 
	    /// </summary>
	    ///
	    public const int SRC_NORM = 5;
	
	    /// <summary>
	    /// From ucase.c/ucase.icu 
	    /// </summary>
	    ///
	    public const int SRC_CASE = 6;
	
	    /// <summary>
	    /// From ubidi_props.c/ubidi.icu 
	    /// </summary>
	    ///
	    public const int SRC_BIDI = 7;
	
	    /// <summary>
	    /// From uchar.c/uprops.icu main trie as well as properties vectors trie 
	    /// </summary>
	    ///
	    public const int SRC_CHAR_AND_PROPSVEC = 8;
	
	    /// <summary>
	    /// One more than the highest UPropertySource (SRC_) constant. 
	    /// </summary>
	    ///
	    public const int SRC_COUNT = 9;
	
	    // public methods ----------------------------------------------------
	
	    /// <summary>
	    /// Java friends implementation
	    /// </summary>
	    ///
	    public void SetIndexData(CharTrie.FriendAgent friendagent) {
	        m_trieIndex_ = friendagent.GetPrivateIndex();
	        m_trieData_ = friendagent.GetPrivateData();
	        m_trieInitialValue_ = friendagent.GetPrivateInitialValue();
	    }
	
	    /// <summary>
	    /// Gets the property value at the index. This is optimized. Note this is
	    /// alittle different from CharTrie the index m_trieData_ is never negative.
	    /// </summary>
	    ///
	    /// <param name="ch">code point whose property value is to be retrieved</param>
	    /// <returns>property value of code point</returns>
	    public int GetProperty(int ch) {
	        if (ch < IBM.ICU.Text.UTF16.LEAD_SURROGATE_MIN_VALUE
	                || (ch > IBM.ICU.Text.UTF16.LEAD_SURROGATE_MAX_VALUE && ch < IBM.ICU.Text.UTF16.SUPPLEMENTARY_MIN_VALUE)) {
	            // BMP codepoint 0000..D7FF or DC00..FFFF
	            // optimized
	            try { // using try for ch < 0 is faster than using an if statement
	                return m_trieData_[(m_trieIndex_[ch >> IBM.ICU.Impl.Trie.INDEX_STAGE_1_SHIFT_] << IBM.ICU.Impl.Trie.INDEX_STAGE_2_SHIFT_)
	                        + (ch & IBM.ICU.Impl.Trie.INDEX_STAGE_3_MASK_)];
	            } catch (IndexOutOfRangeException e) {
	                return m_trieInitialValue_;
	            }
	        }
	        if (ch <= IBM.ICU.Text.UTF16.LEAD_SURROGATE_MAX_VALUE) {
	            // lead surrogate D800..DBFF
	            return m_trieData_[(m_trieIndex_[IBM.ICU.Impl.Trie.LEAD_INDEX_OFFSET_
	                    + (ch >> IBM.ICU.Impl.Trie.INDEX_STAGE_1_SHIFT_)] << IBM.ICU.Impl.Trie.INDEX_STAGE_2_SHIFT_)
	                    + (ch & IBM.ICU.Impl.Trie.INDEX_STAGE_3_MASK_)];
	        }
	        if (ch <= IBM.ICU.Text.UTF16.CODEPOINT_MAX_VALUE) {
	            // supplementary code point 10000..10FFFF
	            // look at the construction of supplementary characters
	            // trail forms the ends of it.
	            return m_trie_.GetSurrogateValue(IBM.ICU.Text.UTF16.GetLeadSurrogate(ch),
	                    (char) (ch & IBM.ICU.Impl.Trie.SURROGATE_MASK_));
	        }
	        // ch is out of bounds
	        // return m_dataOffset_ if there is an error, in this case we return
	        // the default value: m_initialValue_
	        // we cannot assume that m_initialValue_ is at offset 0
	        // this is for optimization.
	        return m_trieInitialValue_;
	
	        // this all is an inlined form of return m_trie_.getCodePointValue(ch);
	    }
	
	    /*
	     * Getting the signed numeric value of a character embedded in the property
	     * argument
	     * 
	     * @param prop the character
	     * 
	     * @return signed numberic value
	     */
	    // public static int getSignedValue(int prop)
	    // {
	    // return ((short)prop >> VALUE_SHIFT_);
	    // }
	
	    /// <summary>
	    /// Getting the unsigned numeric value of a character embedded in the
	    /// property argument
	    /// </summary>
	    ///
	    /// <param name="prop">the character</param>
	    /// <returns>unsigned numberic value</returns>
	    public static int GetUnsignedValue(int prop) {
	        return (prop >> VALUE_SHIFT_) & UNSIGNED_VALUE_MASK_AFTER_SHIFT_;
	    }
	
	    /* internal numeric pseudo-types for special encodings of numeric values */
	    public const int NT_FRACTION = 4; /*
	                                              * ==UCharacter.NumericType.COUNT,
	                                              * must not change unless binary
	                                              * format version changes
	                                              */
	
	    public const int NT_LARGE = 5;
	
	    public const int NT_COUNT = 6;
	
	    /// <summary>
	    /// Gets the unicode additional properties. C version getUnicodeProperties.
	    /// </summary>
	    ///
	    /// <param name="codepoint">codepoint whose additional properties is to be retrieved</param>
	    /// <param name="column"></param>
	    /// <returns>unicode properties</returns>
	    public int GetAdditional(int codepoint, int column) {
	        if (column == -1) {
	            return GetProperty(codepoint);
	        }
	        if (column < 0 || column >= m_additionalColumnsCount_) {
	            return 0;
	        }
	        return m_additionalVectors_[m_additionalTrie_
	                .GetCodePointValue(codepoint) + column];
	    }
	
	    internal const int MY_MASK = UCharacterProperty.TYPE_MASK
	            & ((1 << IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.UPPERCASE_LETTER)
	                    | (1 << IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.LOWERCASE_LETTER)
	                    | (1 << IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.TITLECASE_LETTER)
	                    | (1 << IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.MODIFIER_LETTER) | (1 << IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.OTHER_LETTER));
	
	    /// <summary>
	    /// <p>
	    /// Get the "age" of the code point.
	    /// </p>
	    /// <p>
	    /// The "age" is the Unicode version when the code point was first designated
	    /// (as a non-character or for Private Use) or assigned a character.
	    /// </p>
	    /// <p>
	    /// This can be useful to avoid emitting code points to receiving processes
	    /// that do not accept newer characters.
	    /// </p>
	    /// <p>
	    /// The data is from the UCD file DerivedAge.txt.
	    /// </p>
	    /// <p>
	    /// This API does not check the validity of the codepoint.
	    /// </p>
	    /// </summary>
	    ///
	    /// <param name="codepoint">The code point.</param>
	    /// <returns>the Unicode version number</returns>
	    /// @draft ICU 2.1
	    public VersionInfo GetAge(int codepoint) {
	        int version = GetAdditional(codepoint, 0) >> AGE_SHIFT_;
	        return IBM.ICU.Util.VersionInfo.GetInstance((version >> FIRST_NIBBLE_SHIFT_)
	                & LAST_NIBBLE_MASK_, version & LAST_NIBBLE_MASK_, 0, 0);
	    }
	
	    private const long UNSIGNED_INT_MASK = 0xffffffffL;
	
	    private static readonly int GC_CN_MASK = GetMask(IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.UNASSIGNED);
	
	    private static readonly int GC_CC_MASK = GetMask(IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.CONTROL);
	
	    private static readonly int GC_CS_MASK = GetMask(IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.SURROGATE);
	
	    private static readonly int GC_ZS_MASK = GetMask(IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.SPACE_SEPARATOR);
	
	    private static readonly int GC_ZL_MASK = GetMask(IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.LINE_SEPARATOR);
	
	    private static readonly int GC_ZP_MASK = GetMask(IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.PARAGRAPH_SEPARATOR);
	
	    /// <summary>
	    /// Mask constant for multiple UCharCategory bits (Z Separators). 
	    /// </summary>
	    ///
	    private static readonly int GC_Z_MASK = GC_ZS_MASK | GC_ZL_MASK | GC_ZP_MASK;
	
	    /// <exclude/>
	    /// <summary>
	    /// Checks if c is in
	    /// [^\p{space}\p{gc=Control}\p{gc=Surrogate}\p{gc=Unassigned}] with
	    /// space=\p{Whitespace} and Control=Cc. Implements UCHAR_POSIX_GRAPH.
	    /// </summary>
	    ///
	    private static bool IsgraphPOSIX(int c) {
	        /* \p{space}\p{gc=Control} == \p{gc=Z}\p{Control} */
	        /* comparing ==0 returns FALSE for the categories mentioned */
	        return (GetMask(IBM.ICU.Lang.UCharacter.GetType(c)) & (GC_CC_MASK | GC_CS_MASK
	                | GC_CN_MASK | GC_Z_MASK)) == 0;
	    }
	
	    public sealed class BinaryProperties {
	        internal int column;
	
	        internal long mask;
	
	        public BinaryProperties(int column_0, long mask_1) {
	            this.column = column_0;
	            this.mask = mask_1;
	        }
	    }
	
	    internal UCharacterProperty.BinaryProperties [] binProps;
	
	    /// <summary>
	    /// <p>
	    /// Check a binary Unicode property for a code point.
	    /// </p>
	    /// <p>
	    /// Unicode, especially in version 3.2, defines many more properties than the
	    /// original set in UnicodeData.txt.
	    /// </p>
	    /// <p>
	    /// This API is intended to reflect Unicode properties as defined in the
	    /// Unicode Character Database (UCD) and Unicode Technical Reports (UTR).
	    /// </p>
	    /// <p>
	    /// For details about the properties see <a
	    /// href=http://www.unicode.org/>http://www.unicode.org/</a>.
	    /// </p>
	    /// <p>
	    /// For names of Unicode properties see the UCD file PropertyAliases.txt.
	    /// </p>
	    /// <p>
	    /// This API does not check the validity of the codepoint.
	    /// </p>
	    /// <p>
	    /// Important: If ICU is built with UCD files from Unicode versions below
	    /// 3.2, then properties marked with "new" are not or not fully available.
	    /// </p>
	    /// </summary>
	    ///
	    /// <param name="codepoint">Code point to test.</param>
	    /// <param name="property">selector constant from com.ibm.icu.lang.UProperty, identifieswhich binary property to check.</param>
	    /// <returns>true or false according to the binary Unicode property value for
	    /// ch. Also false if property is out of bounds or if the Unicode
	    /// version does not have data for the property at all, or not for
	    /// this code point.</returns>
	    /// <seealso cref="T:IBM.ICU.Impl.UProperty"/>
	    /// @draft ICU 2.1
	
	    public bool HasBinaryProperty(int codepoint, int property) {
            if (property < IBM.ICU.Lang.UProperty_Constants.BINARY_START
                    || IBM.ICU.Lang.UProperty_Constants.BINARY_LIMIT <= property)
            {
	            // not a known binary property
	            return false;
	        } else {
	            long mask_0 = binProps[property].mask;
	            int column_1 = binProps[property].column;
	            if (mask_0 != 0) {
	                // systematic, directly stored properties
	                return ((UNSIGNED_INT_MASK & GetAdditional(codepoint, column_1)) & mask_0) != 0;
	            } else {
	                if (column_1 == SRC_CASE) {
	                    /* case mapping properties */
	                    UCaseProps csp;
	                    try {
	                        csp = IBM.ICU.Impl.UCaseProps.GetSingleton();
	                    } catch (IOException e) {
	                        return false;
	                    }
	                    switch (property) {
                            case IBM.ICU.Lang.UProperty_Constants.LOWERCASE:
	                        return IBM.ICU.Impl.UCaseProps.LOWER == csp.GetType(codepoint);
                        case IBM.ICU.Lang.UProperty_Constants.UPPERCASE:
	                        return IBM.ICU.Impl.UCaseProps.UPPER == csp.GetType(codepoint);
                        case IBM.ICU.Lang.UProperty_Constants.SOFT_DOTTED:
	                        return csp.IsSoftDotted(codepoint);
                        case IBM.ICU.Lang.UProperty_Constants.CASE_SENSITIVE:
	                        return csp.IsCaseSensitive(codepoint);
	                    default:
	                        break;
	                    }
	                } else if (column_1 == SRC_NORM) {
	                    /* normalization properties from unorm.icu */
	                    switch (property) {
                            case IBM.ICU.Lang.UProperty_Constants.FULL_COMPOSITION_EXCLUSION:
	                        return IBM.ICU.Impl.NormalizerImpl
	                                .IsFullCompositionExclusion(codepoint);
                        case IBM.ICU.Lang.UProperty_Constants.NFD_INERT:
	                        return IBM.ICU.Text.Normalizer.IsNFSkippable(codepoint,
	                                IBM.ICU.Text.Normalizer.NFD);
                        case IBM.ICU.Lang.UProperty_Constants.NFKD_INERT:
	                        return IBM.ICU.Text.Normalizer.IsNFSkippable(codepoint,
	                                IBM.ICU.Text.Normalizer.NFKD);
                        case IBM.ICU.Lang.UProperty_Constants.NFC_INERT:
	                        return IBM.ICU.Text.Normalizer.IsNFSkippable(codepoint,
	                                IBM.ICU.Text.Normalizer.NFC);
                        case IBM.ICU.Lang.UProperty_Constants.NFKC_INERT:
	                        return IBM.ICU.Text.Normalizer.IsNFSkippable(codepoint,
	                                IBM.ICU.Text.Normalizer.NFKC);
                        case IBM.ICU.Lang.UProperty_Constants.SEGMENT_STARTER:
	                        return IBM.ICU.Impl.NormalizerImpl.IsCanonSafeStart(codepoint);
	                    default:
	                        break;
	                    }
	                } else if (column_1 == SRC_BIDI) {
	                    /* bidi/shaping properties */
	                    UBiDiProps bdp;
	                    try {
	                        bdp = IBM.ICU.Impl.UBiDiProps.GetSingleton();
	                    } catch (IOException e_2) {
	                        return false;
	                    }
	                    switch (property) {
                            case IBM.ICU.Lang.UProperty_Constants.BIDI_MIRRORED:
	                        return bdp.IsMirrored(codepoint);
                        case IBM.ICU.Lang.UProperty_Constants.BIDI_CONTROL:
	                        return bdp.IsBidiControl(codepoint);
                        case IBM.ICU.Lang.UProperty_Constants.JOIN_CONTROL:
	                        return bdp.IsJoinControl(codepoint);
	                    default:
	                        break;
	                    }
	                } else if (column_1 == SRC_CHAR) {
	                    switch (property) {
                            case IBM.ICU.Lang.UProperty_Constants.POSIX_BLANK:
	                        // "horizontal space"
	                        if (codepoint <= 0x9f) {
	                            return codepoint == 9 || codepoint == 0x20; /*
	                                                                         * TAB
	                                                                         * or
	                                                                         * SPACE
	                                                                         */
	                        } else {
	                            /* Zs */
	                            return IBM.ICU.Lang.UCharacter.GetType(codepoint) == IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.SPACE_SEPARATOR;
	                        }
	                        break;
                        case IBM.ICU.Lang.UProperty_Constants.POSIX_GRAPH:
	                        return IsgraphPOSIX(codepoint);
                        case IBM.ICU.Lang.UProperty_Constants.POSIX_PRINT:
	                        /*
	                         * Checks if codepoint is in \p{graph}\p{blank} -
	                         * \p{cntrl}.
	                         * 
	                         * The only cntrl character in graph+blank is TAB (in
	                         * blank). Here we implement (blank-TAB)=Zs instead of
	                         * calling u_isblank().
	                         */
	                        return (IBM.ICU.Lang.UCharacter.GetType(codepoint) == IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.SPACE_SEPARATOR)
	                                || IsgraphPOSIX(codepoint);
                        case IBM.ICU.Lang.UProperty_Constants.POSIX_XDIGIT:
	                        /* check ASCII and Fullwidth ASCII a-fA-F */
	                        if ((codepoint <= 0x66 && codepoint >= 0x41 && (codepoint <= 0x46 || codepoint >= 0x61))
	                                || (codepoint >= 0xff21 && codepoint <= 0xff46 && (codepoint <= 0xff26 || codepoint >= 0xff41))) {
	                            return true;
	                        }
	
	                        return IBM.ICU.Lang.UCharacter.GetType(codepoint) == IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.DECIMAL_DIGIT_NUMBER;
	                    default:
	                        break;
	                    }
	                } else if (column_1 == SRC_CHAR_AND_PROPSVEC) {
	                    switch (property) {
	                    case IBM.ICU.Lang.UProperty_Constants.POSIX_ALNUM:
	                        return IBM.ICU.Lang.UCharacter.IsUAlphabetic(codepoint)
	                                || IBM.ICU.Lang.UCharacter.IsDigit(codepoint);
	                    default:
	                        break;
	                    }
	                }
	            }
	        }
	        return false;
	    }
	
	    public int GetSource(int which) {
	        if (which < IBM.ICU.Lang.UProperty_Constants.BINARY_START) {
	            return SRC_NONE; /* undefined */
            }
            else if (which < IBM.ICU.Lang.UProperty_Constants.BINARY_LIMIT)
            {
	            if (binProps[which].mask != 0) {
	                return SRC_PROPSVEC;
	            } else {
	                return binProps[which].column;
	            }
            }
            else if (which < IBM.ICU.Lang.UProperty_Constants.INT_START)
            {
	            return SRC_NONE; /* undefined */
            }
            else if (which < IBM.ICU.Lang.UProperty_Constants.INT_LIMIT)
            {
	            switch (which) {
                    case IBM.ICU.Lang.UProperty_Constants.GENERAL_CATEGORY:
                    case IBM.ICU.Lang.UProperty_Constants.NUMERIC_TYPE:
	                return SRC_CHAR;

                    case IBM.ICU.Lang.UProperty_Constants.HANGUL_SYLLABLE_TYPE:
	                return SRC_HST;

                    case IBM.ICU.Lang.UProperty_Constants.CANONICAL_COMBINING_CLASS:
                    case IBM.ICU.Lang.UProperty_Constants.NFD_QUICK_CHECK:
                    case IBM.ICU.Lang.UProperty_Constants.NFKD_QUICK_CHECK:
                    case IBM.ICU.Lang.UProperty_Constants.NFC_QUICK_CHECK:
                    case IBM.ICU.Lang.UProperty_Constants.NFKC_QUICK_CHECK:
                    case IBM.ICU.Lang.UProperty_Constants.LEAD_CANONICAL_COMBINING_CLASS:
                    case IBM.ICU.Lang.UProperty_Constants.TRAIL_CANONICAL_COMBINING_CLASS:
	                return SRC_NORM;

                    case IBM.ICU.Lang.UProperty_Constants.BIDI_CLASS:
                    case IBM.ICU.Lang.UProperty_Constants.JOINING_GROUP:
                    case IBM.ICU.Lang.UProperty_Constants.JOINING_TYPE:
	                return SRC_BIDI;
	
	            default:
	                return SRC_PROPSVEC;
	            }
            }
            else if (which < IBM.ICU.Lang.UProperty_Constants.STRING_START)
            {
	            switch (which) {
                    case IBM.ICU.Lang.UProperty_Constants.GENERAL_CATEGORY_MASK:
                    case IBM.ICU.Lang.UProperty_Constants.NUMERIC_VALUE:
	                return SRC_CHAR;
	
	            default:
	                return SRC_NONE;
	            }
            }
            else if (which < IBM.ICU.Lang.UProperty_Constants.STRING_LIMIT)
            {
	            switch (which) {
                    case IBM.ICU.Lang.UProperty_Constants.AGE:
	                return SRC_PROPSVEC;
	
	            case IBM.ICU.Lang.UProperty_Constants.BIDI_MIRRORING_GLYPH:
	                return SRC_BIDI;

                case IBM.ICU.Lang.UProperty_Constants.CASE_FOLDING:
                case IBM.ICU.Lang.UProperty_Constants.LOWERCASE_MAPPING:
                case IBM.ICU.Lang.UProperty_Constants.SIMPLE_CASE_FOLDING:
                case IBM.ICU.Lang.UProperty_Constants.SIMPLE_LOWERCASE_MAPPING:
                case IBM.ICU.Lang.UProperty_Constants.SIMPLE_TITLECASE_MAPPING:
                case IBM.ICU.Lang.UProperty_Constants.SIMPLE_UPPERCASE_MAPPING:
                case IBM.ICU.Lang.UProperty_Constants.TITLECASE_MAPPING:
                case IBM.ICU.Lang.UProperty_Constants.UPPERCASE_MAPPING:
	                return SRC_CASE;

                case IBM.ICU.Lang.UProperty_Constants.ISO_COMMENT:
                case IBM.ICU.Lang.UProperty_Constants.NAME:
                case IBM.ICU.Lang.UProperty_Constants.UNICODE_1_NAME:
	                return SRC_NAMES;
	
	            default:
	                return SRC_NONE;
	            }
	        } else {
	            return SRC_NONE; /* undefined */
	        }
	    }
	
	    /// <summary>
	    /// Forms a supplementary code point from the argument character<br>
	    /// Note this is for internal use hence no checks for the validity of the
	    /// surrogate characters are done
	    /// </summary>
	    ///
	    /// <param name="lead">lead surrogate character</param>
	    /// <param name="trail">trailing surrogate character</param>
	    /// <returns>code point of the supplementary character</returns>
	    public static int GetRawSupplementary(char lead, char trail) {
	        return (lead << LEAD_SURROGATE_SHIFT_) + trail + SURROGATE_OFFSET_;
	    }
	
	    /// <summary>
	    /// Loads the property data and initialize the UCharacterProperty instance.
	    /// </summary>
	    ///
	    /// <exception cref="MissingResourceException">when data is missing or data has been corrupted</exception>
	    public static UCharacterProperty GetInstance() {
	        if (INSTANCE_ == null) {
	            try {
	                INSTANCE_ = new UCharacterProperty();
	            } catch (Exception e) {
	                throw new MissingManifestResourceException(e.Message);
	            }
	        }
	        return INSTANCE_;
	    }
	
	    /**
	     * <p>
	     * Unicode property names and property value names are compared "loosely".
	     * Property[Value]Aliases.txt say: <quote> "With loose matching of property
	     * names, the case distinctions, whitespace, and '_' are ignored." </quote>
	     * </p>
	     * <p>
	     * This function does just that, for ASCII (char *) name strings. It is
	     * almost identical to ucnv_compareNames() but also ignores ASCII
	     * White_Space characters (U+0009..U+000d).
	     * </p>
	     * 
	     * @param name1
	     *            name to compare
	     * @param name2
	     *            name to compare
	     * @return 0 if names are equal, < 0 if name1 is less than name2 and > 0 if
	     *         name1 is greater than name2.
	     */
	    /*
	     * to be implemented in 2.4 public static int comparePropertyNames(String
	     * name1, String name2) { int result = 0; int i1 = 0; int i2 = 0; while
	     * (true) { char ch1 = 0; char ch2 = 0; // Ignore delimiters '-', '_', and
	     * ASCII White_Space if (i1 < name1.length()) { ch1 = name1.charAt(i1 ++); }
	     * while (ch1 == '-' || ch1 == '_' || ch1 == ' ' || ch1 == '\t' || ch1 ==
	     * '\n' // synwee what is || ch1 == '\v' || ch1 == '\f' || ch1=='\r') { if
	     * (i1 < name1.length()) { ch1 = name1.charAt(i1 ++); } else { ch1 = 0; } }
	     * if (i2 < name2.length()) { ch2 = name2.charAt(i2 ++); } while (ch2 == '-'
	     * || ch2 == '_' || ch2 == ' ' || ch2 == '\t' || ch2 == '\n' // synwee what
	     * is || ch1 == '\v' || ch2 == '\f' || ch2=='\r') { if (i2 < name2.length())
	     * { ch2 = name2.charAt(i2 ++); } else { ch2 = 0; } }
	     * 
	     * // If we reach the ends of both strings then they match if (ch1 == 0 &&
	     * ch2 == 0) { return 0; }
	     * 
	     * // Case-insensitive comparison if (ch1 != ch2) { result =
	     * Character.toLowerCase(ch1) - Character.toLowerCase(ch2); if (result != 0)
	     * { return result; } } } }
	     */
	
	    /// <summary>
	    /// Checks if the argument c is to be treated as a white space in ICU rules.
	    /// Usually ICU rule white spaces are ignored unless quoted. Equivalent to
	    /// test for Pattern_White_Space Unicode property. Stable set of characters,
	    /// won't change. See UAX #31 Identifier and Pattern Syntax:
	    /// http://www.unicode.org/reports/tr31/
	    /// </summary>
	    ///
	    /// <param name="c">codepoint to check</param>
	    /// <returns>true if c is a ICU white space</returns>
	    public static bool IsRuleWhiteSpace(int c) {
	        /*
	         * "white space" in the sense of ICU rule parsers This is a FIXED LIST
	         * that is NOT DEPENDENT ON UNICODE PROPERTIES. See UAX #31 Identifier
	         * and Pattern Syntax: http://www.unicode.org/reports/tr31/
	         * U+0009..U+000D, U+0020, U+0085, U+200E..U+200F, and U+2028..U+2029
	         * Equivalent to test for Pattern_White_Space Unicode property.
	         */
	        return (c >= 0x0009 && c <= 0x2029 && (c <= 0x000D || c == 0x0020
	                || c == 0x0085 || c == 0x200E || c == 0x200F || c >= 0x2028));
	    }
	
	    /// <summary>
	    /// Get the the maximum values for some enum/int properties.
	    /// </summary>
	    ///
	    /// <returns>maximum values for the integer properties.</returns>
	    public int GetMaxValues(int column_0) {
	        // return m_maxBlockScriptValue_;
	
	        switch (column_0) {
	        case 0:
	            return m_maxBlockScriptValue_;
	        case 2:
	            return m_maxJTGValue_;
	        default:
	            return 0;
	        }
	    }
	
	    /// <summary>
	    /// Gets the type mask
	    /// </summary>
	    ///
	    /// <param name="type">character type</param>
	    /// <returns>mask</returns>
	    public static int GetMask(int type) {
	        return 1 << type;
	    }
	
	    // protected variables -----------------------------------------------
	
	    /// <summary>
	    /// Extra property trie
	    /// </summary>
	    ///
	    internal CharTrie m_additionalTrie_;
	
	    /// <summary>
	    /// Extra property vectors, 1st column for age and second for binary properties.
	    /// </summary>
	    ///
	    internal int[] m_additionalVectors_;
	
	    /// <summary>
	    /// Number of additional columns
	    /// </summary>
	    ///
	    internal int m_additionalColumnsCount_;
	
	    /// <summary>
	    /// Maximum values for block, bits used as in vector word 0
	    /// </summary>
	    ///
	    internal int m_maxBlockScriptValue_;
	
	    /// <summary>
	    /// Maximum values for script, bits used as in vector word 0
	    /// </summary>
	    ///
	    internal int m_maxJTGValue_;
	
	    // private variables -------------------------------------------------
	
	    /// <summary>
	    /// UnicodeData.txt property object
	    /// </summary>
	    ///
	    private static UCharacterProperty INSTANCE_ = null;
	
	    /// <summary>
	    /// Default name of the datafile
	    /// </summary>
	    ///
        private const String DATA_FILE_NAME_ = IBM.ICU.Impl.ICUResourceBundle.ICU_DATA_PATH + IBM.ICU.Impl.ICUResourceBundle.ICU_BUNDLE
	            + "/uprops.icu";
	
	    /// <summary>
	    /// Default buffer size of datafile
	    /// </summary>
	    ///
	    private const int DATA_BUFFER_SIZE_ = 25000;
	
	    /// <summary>
	    /// Numeric value shift
	    /// </summary>
	    ///
	    private const int VALUE_SHIFT_ = 8;
	
	    /// <summary>
	    /// Mask to be applied after shifting to obtain an unsigned numeric value
	    /// </summary>
	    ///
	    private const int UNSIGNED_VALUE_MASK_AFTER_SHIFT_ = 0xFF;
	
	    /*
	     *
	     */
	    // private static final int NUMERIC_TYPE_SHIFT = 5;
	
	    /*
	     * To get the last 5 bits out from a data type
	     */
	    // private static final int LAST_5_BIT_MASK_ = 0x1F;
	
	    /// <summary>
	    /// Shift value for lead surrogate to form a supplementary character.
	    /// </summary>
	    ///
	    private const int LEAD_SURROGATE_SHIFT_ = 10;
	
	    /// <summary>
	    /// Offset to add to combined surrogate pair to avoid msking.
	    /// </summary>
	    ///
	    private const int SURROGATE_OFFSET_ = IBM.ICU.Text.UTF16.SUPPLEMENTARY_MIN_VALUE
	            - (IBM.ICU.Text.UTF16.SURROGATE_MIN_VALUE << LEAD_SURROGATE_SHIFT_)
	            - IBM.ICU.Text.UTF16.TRAIL_SURROGATE_MIN_VALUE;
	
	    // additional properties ----------------------------------------------
	
	    /// <summary>
	    /// Additional properties used in internal trie data
	    /// </summary>
	    ///
	    /*
	     * Properties in vector word 1 Each bit encodes one binary property. The
	     * following constants represent the bit number, use 1<<UPROPS_XYZ.
	     * UPROPS_BINARY_1_TOP<=32!
	     * 
	     * Keep this list of property enums in sync with propListNames[] in
	     * icu/source/tools/genprops/props2.c!
	     * 
	     * ICU 2.6/uprops format version 3.2 stores full properties instead of
	     * "Other_".
	     */
	    private const int WHITE_SPACE_PROPERTY_ = 0;
	
	    // private static final int BIDI_CONTROL_PROPERTY_ = 1;
	    // private static final int JOIN_CONTROL_PROPERTY_ = 2;
	    private const int DASH_PROPERTY_ = 3;
	
	    private const int HYPHEN_PROPERTY_ = 4;
	
	    private const int QUOTATION_MARK_PROPERTY_ = 5;
	
	    private const int TERMINAL_PUNCTUATION_PROPERTY_ = 6;
	
	    private const int MATH_PROPERTY_ = 7;
	
	    private const int HEX_DIGIT_PROPERTY_ = 8;
	
	    private const int ASCII_HEX_DIGIT_PROPERTY_ = 9;
	
	    private const int ALPHABETIC_PROPERTY_ = 10;
	
	    private const int IDEOGRAPHIC_PROPERTY_ = 11;
	
	    private const int DIACRITIC_PROPERTY_ = 12;
	
	    private const int EXTENDER_PROPERTY_ = 13;
	
	    // private static final int LOWERCASE_PROPERTY_ = 14;
	    // private static final int UPPERCASE_PROPERTY_ = 15;
	    private const int NONCHARACTER_CODE_POINT_PROPERTY_ = 16;
	
	    private const int GRAPHEME_EXTEND_PROPERTY_ = 17;
	
	    private const int GRAPHEME_LINK_PROPERTY_ = 18;
	
	    private const int IDS_BINARY_OPERATOR_PROPERTY_ = 19;
	
	    private const int IDS_TRINARY_OPERATOR_PROPERTY_ = 20;
	
	    private const int RADICAL_PROPERTY_ = 21;
	
	    private const int UNIFIED_IDEOGRAPH_PROPERTY_ = 22;
	
	    private const int DEFAULT_IGNORABLE_CODE_POINT_PROPERTY_ = 23;
	
	    private const int DEPRECATED_PROPERTY_ = 24;
	
	    // private static final int SOFT_DOTTED_PROPERTY_ = 25;
	    private const int LOGICAL_ORDER_EXCEPTION_PROPERTY_ = 26;
	
	    private const int XID_START_PROPERTY_ = 27;
	
	    private const int XID_CONTINUE_PROPERTY_ = 28;
	
	    private const int ID_START_PROPERTY_ = 29;
	
	    private const int ID_CONTINUE_PROPERTY_ = 30;
	
	    private const int GRAPHEME_BASE_PROPERTY_ = 31;
	
	    // private static final int BINARY_1_TOP_PROPERTY_ = 32;
	
	    /// <summary>
	    /// First nibble shift
	    /// </summary>
	    ///
	    private const int FIRST_NIBBLE_SHIFT_ = 0x4;
	
	    /// <summary>
	    /// Second nibble mask
	    /// </summary>
	    ///
	    private const int LAST_NIBBLE_MASK_ = 0xF;
	
	    /// <summary>
	    /// Age value shift
	    /// </summary>
	    ///
	    private const int AGE_SHIFT_ = 24;
	
	    // boolean properties in vector word 2
	    private const int V2_S_TERM_PROPERTY_ = 24;
	
	    private const int V2_VARIATION_SELECTOR_PROPERTY_ = 25;
	
	    private const int V2_PATTERN_SYNTAX = 26; /*
	                                                      * new in ICU 3.4 and
	                                                      * Unicode 4.1
	                                                      */
	
	    private const int V2_PATTERN_WHITE_SPACE = 27;
	
	    // private constructors --------------------------------------------------
	
	    /// <summary>
	    /// Constructor
	    /// </summary>
	    ///
	    /// <exception cref="IOException">thrown when data reading fails or data corrupted</exception>
	    private UCharacterProperty() {
	        this.binProps = new UCharacterProperty.BinaryProperties [] {
	                /*
	                 * column and mask values for binary properties from
	                 * u_getUnicodeProperties(). Must be in order of corresponding
	                 * UProperty, and there must be exacly one entry per binary
	                 * UProperty.
	                 */
	                new UCharacterProperty.BinaryProperties (1, (1 << ALPHABETIC_PROPERTY_)),
	                new UCharacterProperty.BinaryProperties (1, (1 << ASCII_HEX_DIGIT_PROPERTY_)),
	                new UCharacterProperty.BinaryProperties (SRC_BIDI, 0), /* UCHAR_BIDI_CONTROL */
	                new UCharacterProperty.BinaryProperties (SRC_BIDI, 0), /* UCHAR_BIDI_MIRRORED */
	                new UCharacterProperty.BinaryProperties (1, (1 << DASH_PROPERTY_)),
	                new UCharacterProperty.BinaryProperties (1,
	                        (1 << DEFAULT_IGNORABLE_CODE_POINT_PROPERTY_)),
	                new UCharacterProperty.BinaryProperties (1, (1 << DEPRECATED_PROPERTY_)),
	                new UCharacterProperty.BinaryProperties (1, (1 << DIACRITIC_PROPERTY_)),
	                new UCharacterProperty.BinaryProperties (1, (1 << EXTENDER_PROPERTY_)),
	                new UCharacterProperty.BinaryProperties (SRC_NORM, 0), /* UCHAR_FULL_COMPOSITION_EXCLUSION */
	                new UCharacterProperty.BinaryProperties (1, (1 << GRAPHEME_BASE_PROPERTY_)),
	                new UCharacterProperty.BinaryProperties (1, (1 << GRAPHEME_EXTEND_PROPERTY_)),
	                new UCharacterProperty.BinaryProperties (1, (1 << GRAPHEME_LINK_PROPERTY_)),
	                new UCharacterProperty.BinaryProperties (1, (1 << HEX_DIGIT_PROPERTY_)),
	                new UCharacterProperty.BinaryProperties (1, (1 << HYPHEN_PROPERTY_)),
	                new UCharacterProperty.BinaryProperties (1, (1 << ID_CONTINUE_PROPERTY_)),
	                new UCharacterProperty.BinaryProperties (1, (1 << ID_START_PROPERTY_)),
	                new UCharacterProperty.BinaryProperties (1, (1 << IDEOGRAPHIC_PROPERTY_)),
	                new UCharacterProperty.BinaryProperties (1, (1 << IDS_BINARY_OPERATOR_PROPERTY_)),
	                new UCharacterProperty.BinaryProperties (1, (1 << IDS_TRINARY_OPERATOR_PROPERTY_)),
	                new UCharacterProperty.BinaryProperties (SRC_BIDI, 0), /* UCHAR_JOIN_CONTROL */
	                new UCharacterProperty.BinaryProperties (1, (1 << LOGICAL_ORDER_EXCEPTION_PROPERTY_)),
	                new UCharacterProperty.BinaryProperties (SRC_CASE, 0), /* UCHAR_LOWERCASE */
	                new UCharacterProperty.BinaryProperties (1, (1 << MATH_PROPERTY_)),
	                new UCharacterProperty.BinaryProperties (1, (1 << NONCHARACTER_CODE_POINT_PROPERTY_)),
	                new UCharacterProperty.BinaryProperties (1, (1 << QUOTATION_MARK_PROPERTY_)),
	                new UCharacterProperty.BinaryProperties (1, (1 << RADICAL_PROPERTY_)),
	                new UCharacterProperty.BinaryProperties (SRC_CASE, 0), /* UCHAR_SOFT_DOTTED */
	                new UCharacterProperty.BinaryProperties (1, (1 << TERMINAL_PUNCTUATION_PROPERTY_)),
	                new UCharacterProperty.BinaryProperties (1, (1 << UNIFIED_IDEOGRAPH_PROPERTY_)),
	                new UCharacterProperty.BinaryProperties (SRC_CASE, 0), /* UCHAR_UPPERCASE */
	                new UCharacterProperty.BinaryProperties (1, (1 << WHITE_SPACE_PROPERTY_)),
	                new UCharacterProperty.BinaryProperties (1, (1 << XID_CONTINUE_PROPERTY_)),
	                new UCharacterProperty.BinaryProperties (1, (1 << XID_START_PROPERTY_)),
	                new UCharacterProperty.BinaryProperties (SRC_CASE, 0), /* UCHAR_CASE_SENSITIVE */
	                new UCharacterProperty.BinaryProperties (2, (1 << V2_S_TERM_PROPERTY_)),
	                new UCharacterProperty.BinaryProperties (2, (1 << V2_VARIATION_SELECTOR_PROPERTY_)),
	                new UCharacterProperty.BinaryProperties (SRC_NORM, 0), /* UCHAR_NFD_INERT */
	                new UCharacterProperty.BinaryProperties (SRC_NORM, 0), /* UCHAR_NFKD_INERT */
	                new UCharacterProperty.BinaryProperties (SRC_NORM, 0), /* UCHAR_NFC_INERT */
	                new UCharacterProperty.BinaryProperties (SRC_NORM, 0), /* UCHAR_NFKC_INERT */
	                new UCharacterProperty.BinaryProperties (SRC_NORM, 0), /* UCHAR_SEGMENT_STARTER */
	                new UCharacterProperty.BinaryProperties (2, (1 << V2_PATTERN_SYNTAX)),
	                new UCharacterProperty.BinaryProperties (2, (1 << V2_PATTERN_WHITE_SPACE)),
	                new UCharacterProperty.BinaryProperties (SRC_CHAR_AND_PROPSVEC, 0), /* UCHAR_POSIX_ALNUM */
	                new UCharacterProperty.BinaryProperties (SRC_CHAR, 0), /* UCHAR_POSIX_BLANK */
	                new UCharacterProperty.BinaryProperties (SRC_CHAR, 0), /* UCHAR_POSIX_GRAPH */
	                new UCharacterProperty.BinaryProperties (SRC_CHAR, 0), /* UCHAR_POSIX_PRINT */
	                new UCharacterProperty.BinaryProperties (SRC_CHAR, 0) /* UCHAR_POSIX_XDIGIT */
	        };
	        // jar access
	         Stream 
	                mask0 = IBM.ICU.Impl.ICUData.GetRequiredStream(DATA_FILE_NAME_);
	        BufferedStream b = new BufferedStream(mask0,DATA_BUFFER_SIZE_);
	        UCharacterPropertyReader reader = new UCharacterPropertyReader(b);
	        reader.Read(this);
	        b.Close();
	
	        m_trie_.PutIndexData(this);
	    }
	
	    // private methods -------------------------------------------------------
	
	    /*
	     * Compare additional properties to see if it has argument type
	     * 
	     * @param property 32 bit properties
	     * 
	     * @param type character type
	     * 
	     * @return true if property has type
	     */
	    /*
	     * private boolean compareAdditionalType(int property, int type) { return
	     * (property & (1 << type)) != 0; }
	     */
	
	    // property starts for UnicodeSet -------------------------------------- ***
	
	    private const int TAB = 0x0009;
	
	    // private static final int LF = 0x000a;
	    // private static final int FF = 0x000c;
	    private const int CR = 0x000d;
	
	    private const int U_A = 0x0041;
	
	    private const int U_F = 0x0046;
	
	    private const int U_Z = 0x005a;
	
	    private const int U_a = 0x0061;
	
	    private const int U_f = 0x0066;
	
	    private const int U_z = 0x007a;
	
	    private const int DEL = 0x007f;
	
	    private const int NL = 0x0085;
	
	    private const int NBSP = 0x00a0;
	
	    private const int CGJ = 0x034f;
	
	    private const int FIGURESP = 0x2007;
	
	    private const int HAIRSP = 0x200a;
	
	    // private static final int ZWNJ = 0x200c;
	    // private static final int ZWJ = 0x200d;
	    private const int RLM = 0x200f;
	
	    private const int NNBSP = 0x202f;
	
	    private const int WJ = 0x2060;
	
	    private const int INHSWAP = 0x206a;
	
	    private const int NOMDIG = 0x206f;
	
	    private const int U_FW_A = 0xff21;
	
	    private const int U_FW_F = 0xff26;
	
	    private const int U_FW_Z = 0xff3a;
	
	    private const int U_FW_a = 0xff41;
	
	    private const int U_FW_f = 0xff46;
	
	    private const int U_FW_z = 0xff5a;
	
	    private const int ZWNBSP = 0xfeff;
	
	    /* for Hangul_Syllable_Type */
	    public void Uhst_addPropertyStarts(UnicodeSet set) {
	        /*
	         * add code points with hardcoded properties, plus the ones following
	         * them
	         */
	
	        /*
	         * Add Jamo type boundaries for UCHAR_HANGUL_SYLLABLE_TYPE. First, we
	         * add fixed boundaries for the blocks of Jamos. Then we check in loops
	         * to see where the current Unicode version actually stops assigning
	         * such Jamos. We start each loop at the end of the per-Jamo-block
	         * assignments in Unicode 4 or earlier. (These have not changed since
	         * Unicode 2.)
	         */
	        int c, value_ren, value2;
	
	        set.Add(0x1100);
	        value_ren = IBM.ICU.Lang.UCharacter.HangulSyllableType.LEADING_JAMO;
	        for (c = 0x115a; c <= 0x115f; ++c) {
	            value2 = IBM.ICU.Lang.UCharacter.GetIntPropertyValue(c,
                        IBM.ICU.Lang.UProperty_Constants.HANGUL_SYLLABLE_TYPE);
	            if (value_ren != value2) {
	                value_ren = value2;
	                set.Add(c);
	            }
	        }
	
	        set.Add(0x1160);
	        value_ren = IBM.ICU.Lang.UCharacter.HangulSyllableType.VOWEL_JAMO;
	        for (c = 0x11a3; c <= 0x11a7; ++c) {
	            value2 = IBM.ICU.Lang.UCharacter.GetIntPropertyValue(c,
                        IBM.ICU.Lang.UProperty_Constants.HANGUL_SYLLABLE_TYPE);
	            if (value_ren != value2) {
	                value_ren = value2;
	                set.Add(c);
	            }
	        }
	
	        set.Add(0x11a8);
	        value_ren = IBM.ICU.Lang.UCharacter.HangulSyllableType.TRAILING_JAMO;
	        for (c = 0x11fa; c <= 0x11ff; ++c) {
	            value2 = IBM.ICU.Lang.UCharacter.GetIntPropertyValue(c,
                        IBM.ICU.Lang.UProperty_Constants.HANGUL_SYLLABLE_TYPE);
	            if (value_ren != value2) {
	                value_ren = value2;
	                set.Add(c);
	            }
	        }
	
	        /* Add Hangul type boundaries for UCHAR_HANGUL_SYLLABLE_TYPE. */
	        for (c = IBM.ICU.Impl.NormalizerImpl.HANGUL_BASE; c < (IBM.ICU.Impl.NormalizerImpl.HANGUL_BASE + IBM.ICU.Impl.NormalizerImpl.HANGUL_COUNT); c += IBM.ICU.Impl.NormalizerImpl.JAMO_T_COUNT) {
	            set.Add(c);
	            set.Add(c + 1);
	        }
	        set.Add(c);
	    }
	
	    public UnicodeSet AddPropertyStarts(UnicodeSet set) {
	        /* add the start code point of each same-value range of the main trie */
	        TrieIterator propsIter = new TrieIterator(m_trie_);
	        RangeValueIterator_Constants.Element propsResult = new RangeValueIterator_Constants.Element();
	        while (propsIter.Next(propsResult)) {
	            set.Add(propsResult.start);
	        }
	
	        /*
	         * add code points with hardcoded properties, plus the ones following
	         * them
	         */
	
	        /* add for u_isblank() */
	        set.Add(TAB);
	        set.Add(TAB + 1);
	
	        /* add for IS_THAT_CONTROL_SPACE() */
	        set.Add(CR + 1); /* range TAB..CR */
	        set.Add(0x1c);
	        set.Add(0x1f + 1);
	        set.Add(NL);
	        set.Add(NL + 1);
	
	        /* add for u_isIDIgnorable() what was not added above */
	        set.Add(DEL); /* range DEL..NBSP-1, NBSP added below */
	        set.Add(HAIRSP);
	        set.Add(RLM + 1);
	        set.Add(INHSWAP);
	        set.Add(NOMDIG + 1);
	        set.Add(ZWNBSP);
	        set.Add(ZWNBSP + 1);
	
	        /* add no-break spaces for u_isWhitespace() what was not added above */
	        set.Add(NBSP);
	        set.Add(NBSP + 1);
	        set.Add(FIGURESP);
	        set.Add(FIGURESP + 1);
	        set.Add(NNBSP);
	        set.Add(NNBSP + 1);
	
	        /* add for u_charDigitValue() */
	        // TODO remove when UCharacter.getHanNumericValue() is changed to just
	        // return
	        // Unicode numeric values
	        set.Add(0x3007);
	        set.Add(0x3008);
	        set.Add(0x4e00);
	        set.Add(0x4e01);
	        set.Add(0x4e8c);
	        set.Add(0x4e8d);
	        set.Add(0x4e09);
	        set.Add(0x4e0a);
	        set.Add(0x56db);
	        set.Add(0x56dc);
	        set.Add(0x4e94);
	        set.Add(0x4e95);
	        set.Add(0x516d);
	        set.Add(0x516e);
	        set.Add(0x4e03);
	        set.Add(0x4e04);
	        set.Add(0x516b);
	        set.Add(0x516c);
	        set.Add(0x4e5d);
	        set.Add(0x4e5e);
	
	        /* add for u_digit() */
	        set.Add(U_a);
	        set.Add(U_z + 1);
	        set.Add(U_A);
	        set.Add(U_Z + 1);
	        set.Add(U_FW_a);
	        set.Add(U_FW_z + 1);
	        set.Add(U_FW_A);
	        set.Add(U_FW_Z + 1);
	
	        /* add for u_isxdigit() */
	        set.Add(U_f + 1);
	        set.Add(U_F + 1);
	        set.Add(U_FW_f + 1);
	        set.Add(U_FW_F + 1);
	
	        /* add for UCHAR_DEFAULT_IGNORABLE_CODE_POINT what was not added above */
	        set.Add(WJ); /* range WJ..NOMDIG */
	        set.Add(0xfff0);
	        set.Add(0xfffb + 1);
	        set.Add(0xe0000);
	        set.Add(0xe0fff + 1);
	
	        /* add for UCHAR_GRAPHEME_BASE and others */
	        set.Add(CGJ);
	        set.Add(CGJ + 1);
	
	        return set; // for chaining
	    }
	
	    public void Upropsvec_addPropertyStarts(UnicodeSet set) {
	        /*
	         * add the start code point of each same-value range of the properties
	         * vectors trie
	         */
	        if (m_additionalColumnsCount_ > 0) {
	            /*
	             * if m_additionalColumnsCount_==0 then the properties vectors trie
	             * may not be there at all
	             */
	            TrieIterator propsVectorsIter = new TrieIterator(m_additionalTrie_);
	            RangeValueIterator_Constants.Element propsVectorsResult = new RangeValueIterator_Constants.Element();
	            while (propsVectorsIter.Next(propsVectorsResult)) {
	                set.Add(propsVectorsResult.start);
	            }
	        }
	    }
	
	    /*----------------------------------------------------------------
	     * Inclusions list
	     *----------------------------------------------------------------*/
	
	    /*
	     * Return a set of characters for property enumeration. The set implicitly
	     * contains 0x110000 as well, which is one more than the highest Unicode
	     * code point.
	     * 
	     * This set is used as an ordered list - its code points are ordered, and
	     * consecutive code points (in Unicode code point order) in the set define a
	     * range. For each two consecutive characters (start, limit) in the set, all
	     * of the UCD/normalization and related properties for all code points
	     * start..limit-1 are all the same, except for character names and ISO
	     * comments.
	     * 
	     * All Unicode code points U+0000..U+10ffff are covered by these ranges. The
	     * ranges define a partition of the Unicode code space. ICU uses the
	     * inclusions set to enumerate properties for generating UnicodeSets
	     * containing all code points that have a certain property value.
	     * 
	     * The Inclusion List is generated from the UCD. It is generated by
	     * enumerating the data tries, and code points for hardcoded properties are
	     * added as well.
	     * 
	     * --------------------------------------------------------------------------
	     * 
	     * The following are ideas for getting properties-unique code point ranges,
	     * with possible optimizations beyond the current implementation. These
	     * optimizations would require more code and be more fragile. The current
	     * implementation generates one single list (set) for all properties.
	     * 
	     * To enumerate properties efficiently, one needs to know ranges of
	     * repetitive values, so that the value of only each start code point can be
	     * applied to the whole range. This information is in principle available in
	     * the uprops.icu/unorm.icu data.
	     * 
	     * There are two obstacles:
	     * 
	     * 1. Some properties are computed from multiple data structures, making it
	     * necessary to get repetitive ranges by intersecting ranges from multiple
	     * tries.
	     * 
	     * 2. It is not economical to write code for getting repetitive ranges that
	     * are precise for each of some 50 properties.
	     * 
	     * Compromise ideas:
	     * 
	     * - Get ranges per trie, not per individual property. Each range contains
	     * the same values for a whole group of properties. This would generate
	     * currently five range sets, two for uprops.icu tries and three for
	     * unorm.icu tries.
	     * 
	     * - Combine sets of ranges for multiple tries to get sufficient sets for
	     * properties, e.g., the uprops.icu main and auxiliary tries for all
	     * non-normalization properties.
	     * 
	     * Ideas for representing ranges and combining them:
	     * 
	     * - A UnicodeSet could hold just the start code points of ranges. Multiple
	     * sets are easily combined by or-ing them together.
	     * 
	     * - Alternatively, a UnicodeSet could hold each even-numbered range. All
	     * ranges could be enumerated by using each start code point (for the
	     * even-numbered ranges) as well as each limit (end+1) code point (for the
	     * odd-numbered ranges). It should be possible to combine two such sets by
	     * xor-ing them, but no more than two.
	     * 
	     * The second way to represent ranges may(?!) yield smaller UnicodeSet
	     * arrays, but the first one is certainly simpler and applicable for
	     * combining more than two range sets.
	     * 
	     * It is possible to combine all range sets for all uprops/unorm tries into
	     * one set that can be used for all properties. As an optimization, there
	     * could be less-combined range sets for certain groups of properties. The
	     * relationship of which less-combined range set to use for which property
	     * depends on the implementation of the properties and must be hardcoded -
	     * somewhat error-prone and higher maintenance but can be tested easily by
	     * building property sets "the simple way" in test code.
	     * 
	     * ---
	     * 
	     * Do not use a UnicodeSet pattern because that causes infinite recursion;
	     * UnicodeSet depends on the inclusions set.
	     * 
	     * ---
	     * 
	     * getInclusions() is commented out starting 2005-feb-12 because UnicodeSet
	     * now calls the uxyz_addPropertyStarts() directly, and only for the
	     * relevant property source.
	     */
	    /*
	     * public UnicodeSet getInclusions() { UnicodeSet set = new UnicodeSet();
	     * NormalizerImpl.addPropertyStarts(set); addPropertyStarts(set); return
	     * set; }
	     */
	}
}
