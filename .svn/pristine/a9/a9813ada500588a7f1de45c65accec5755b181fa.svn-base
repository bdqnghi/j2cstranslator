/*
 *****************************************************************
 * Copyright (c) 2002-2006, International Business Machines Corporation
 * and others.  All Rights Reserved.
 *****************************************************************
 * Date        Name        Description
 * 06/06/2002  aliu        Creation.
 *****************************************************************
 */
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:30 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Text {
	
	using ILOG.J2CsMapping.Collections;
	using ILOG.J2CsMapping.Collections.Generics;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Resources;
	using System.Runtime.CompilerServices;
	
	/// <summary>
	/// A transliterator that translates multiple input scripts to a single output
	/// script. It is named Any-T or Any-T/V, where T is the target and V is the
	/// optional variant. The target T is a script.
	/// <p>
	/// An AnyTransliterator partitions text into runs of the same script, together
	/// with adjacent COMMON or INHERITED characters. After determining the script of
	/// each run, it transliterates from that script to the given target/variant. It
	/// does so by instantiating a transliterator from the source script to the
	/// target/variant. If a run consists only of the target script, COMMON, or
	/// INHERITED characters, then the run is not changed.
	/// <p>
	/// At startup, all possible AnyTransliterators are registered with the system,
	/// as determined by examining the registered script transliterators.
	/// </summary>
	///
	internal class AnyTransliterator : Transliterator {
	
	    // ------------------------------------------------------------
	    // Constants
	
	    internal const char TARGET_SEP = '-';
	
	    internal const char VARIANT_SEP = '/';
	
	    internal const String ANY = "Any";
	
	    internal const String NULL_ID = "Null";
	
	    internal const String LATIN_PIVOT = "-Latin;Latin-";
	
	    /// <summary>
	    /// Cache mapping UScriptCode values to Transliterator///.
	    /// </summary>
	    ///
	    private IDictionary cache;
	
	    /// <summary>
	    /// The target or target/variant string.
	    /// </summary>
	    ///
	    private String target;
	
	    /// <summary>
	    /// The target script code. Never USCRIPT_INVALID_CODE.
	    /// </summary>
	    ///
	    private int targetScript;
	
	    /// <summary>
	    /// Implements <see cref="M:IBM.ICU.Text.Transliterator.HandleTransliterate(IBM.ICU.Text.Replaceable, null, System.Boolean)"/>.
	    /// </summary>
	    ///
	    protected internal override void HandleTransliterate(Replaceable text, Transliterator.Position  pos,
	            bool isIncremental) {
	        int allStart = pos.start;
	        int allLimit = pos.limit;
	
	        AnyTransliterator.ScriptRunIterator  it = new AnyTransliterator.ScriptRunIterator (text, pos.contextStart,
	                pos.contextLimit);
	
	        while (it.Next()) {
	            // Ignore runs in the ante context
	            if (it.limit <= allStart)
	                continue;
	
	            // Try to instantiate transliterator from it.scriptCode to
	            // our target or target/variant
	            Transliterator t = GetTransliterator(it.scriptCode);
	
	            if (t == null) {
	                // We have no transliterator. Do nothing, but keep
	                // pos.start up to date.
	                pos.start = it.limit;
	                continue;
	            }
	
	            // If the run end is before the transliteration limit, do
	            // a non-incremental transliteration. Otherwise do an
	            // incremental one.
	            bool incremental = isIncremental && (it.limit >= allLimit);
	
	            pos.start = Math.Max(allStart,it.start);
	            pos.limit = Math.Min(allLimit,it.limit);
	            int limit = pos.limit;
	            t.FilteredTransliterate(text, pos, incremental);
	            int delta = pos.limit - limit;
	            allLimit += delta;
	            it.AdjustLimit(delta);
	
	            // We're done if we enter the post context
	            if (it.limit >= allLimit)
	                break;
	        }
	
	        // Restore limit. pos.start is fine where the last transliterator
	        // left it, or at the end of the last run.
	        pos.limit = allLimit;
	    }
	
	    /// <summary>
	    /// Private constructor
	    /// </summary>
	    ///
	    /// <param name="id">the ID of the form S-T or S-T/V, where T is theTarget and V istheVariant. Must not be empty.</param>
	    /// <param name="theTarget">the target name. Must not be empty, and must name a scriptcorresponding to theTargetScript.</param>
	    /// <param name="theVariant">the variant name, or the empty string if there is no variant</param>
	    /// <param name="theTargetScript">the script code corresponding to theTarget.</param>
	    private AnyTransliterator(String id, String theTarget, String theVariant,
	            int theTargetScript) : base(id, null) {
	        targetScript = theTargetScript;
	        cache = new Hashtable();
	
	        target = theTarget;
	        if (theVariant.Length > 0) {
	            target = theTarget + VARIANT_SEP + theVariant;
	        }
	    }
	
	    /// <summary>
	    /// Returns a transliterator from the given source to our target or
	    /// target/variant. Returns NULL if the source is the same as our target
	    /// script, or if the source is USCRIPT_INVALID_CODE. Caches the result and
	    /// returns the same transliterator the next time. The caller does NOT own
	    /// the result and must not delete it.
	    /// </summary>
	    ///
	    private Transliterator GetTransliterator(int source) {
	        if (source == targetScript || source == IBM.ICU.Lang.UScript.INVALID_CODE) {
	            return null;
	        }
	
	        Int32 key = ((int)(source));
	        Transliterator t = (Transliterator) ILOG.J2CsMapping.Collections.Collections.Get(cache,key);
	        if (t == null) {
	            String sourceName = IBM.ICU.Lang.UScript.GetName(source);
	            String id = sourceName + TARGET_SEP + target;
	
	            try {
	                t = IBM.ICU.Text.Transliterator.GetInstance(id, IBM.ICU.Text.Transliterator.FORWARD);
	            } catch (Exception e) {
	            }
	            if (t == null) {
	
	                // Try to pivot around Latin, our most common script
	                id = sourceName + LATIN_PIVOT + target;
	                try {
	                    t = IBM.ICU.Text.Transliterator.GetInstance(id, IBM.ICU.Text.Transliterator.FORWARD);
	                } catch (Exception e_0) {
	                }
	            }
	
	            if (t != null) {
	                ILOG.J2CsMapping.Collections.Collections.Put(cache,key,t);
	            }
	        }
	
	        return t;
	    }
	
	    /// <summary>
	    /// Registers standard transliterators with the system. Called by
	    /// Transliterator during initialization. Scan all current targets and
	    /// register those that are scripts T as Any-T/V.
	    /// </summary>
	    ///
	    static internal void Register() {
	
	        HashedSet seen = new HashedSet();
	
	        for (IIterator s = IBM.ICU.Text.Transliterator.GetAvailableSources(); s
	                .HasNext();) {
	            String source = (String) s.Next();
	
	            // Ignore the "Any" source
	            if (source.Equals(ANY,StringComparison.InvariantCultureIgnoreCase))
	                continue;
	
	            for (IIterator t = IBM.ICU.Text.Transliterator.GetAvailableTargets(source); t
	                    .HasNext();) {
	                String target_0 = (String) t.Next();
	
	                // Only process each target once
	                if (ILOG.J2CsMapping.Collections.Collections.Contains(target_0,seen))
	                    continue;
	                ILOG.J2CsMapping.Collections.Generics.Collections.Add(seen,target_0);
	
	                // Get the script code for the target. If not a script, ignore.
	                int targetScript_1 = ScriptNameToCode(target_0);
	                if (targetScript_1 == IBM.ICU.Lang.UScript.INVALID_CODE)
	                    continue;
	
	                for (IIterator v = IBM.ICU.Text.Transliterator.GetAvailableVariants(
	                        source, target_0); v.HasNext();) {
	                    String variant = (String) v.Next();
	
	                    String id;
	                    id = IBM.ICU.Text.TransliteratorIDParser.STVtoID(ANY, target_0, variant);
	                    AnyTransliterator trans = new AnyTransliterator(id, target_0,
	                            variant, targetScript_1);
	                    IBM.ICU.Text.Transliterator.RegisterInstance(trans);
	                    IBM.ICU.Text.Transliterator.RegisterSpecialInverse(target_0, NULL_ID,
	                            false);
	                }
	            }
	        }
	    }
	
	    /// <summary>
	    /// Return the script code for a given name, or UScript.INVALID_CODE if not
	    /// found.
	    /// </summary>
	    ///
	    private static int ScriptNameToCode(String name) {
	        try {
	            int[] codes = IBM.ICU.Lang.UScript.GetCode(name);
	            return (codes != null) ? codes[0] : IBM.ICU.Lang.UScript.INVALID_CODE;
	        } catch (MissingManifestResourceException e) {
	            return IBM.ICU.Lang.UScript.INVALID_CODE;
	        }
	    }
	
	    // ------------------------------------------------------------
	    // ScriptRunIterator
	
	    /// <summary>
	    /// Returns a series of ranges corresponding to scripts. They will be of the
	    /// form:
	    /// ccccSScSSccccTTcTcccc - c = common, S = first script, T = second | | -
	    /// first run (start, limit) | | - second run (start, limit)
	    /// That is, the runs will overlap. The reason for this is so that a
	    /// transliterator can consider common characters both before and after the
	    /// scripts.
	    /// </summary>
	    ///
	    private class ScriptRunIterator {
	
	        private Replaceable text;
	
	        private int textStart;
	
	        private int textLimit;
	
	        /// <summary>
	        /// The code of the current run, valid after next() returns. May be
	        /// UScript.INVALID_CODE if and only if the entire text is
	        /// COMMON/INHERITED.
	        /// </summary>
	        ///
	        public int scriptCode;
	
	        /// <summary>
	        /// The start of the run, inclusive, valid after next() returns.
	        /// </summary>
	        ///
	        public int start;
	
	        /// <summary>
	        /// The end of the run, exclusive, valid after next() returns.
	        /// </summary>
	        ///
	        public int limit;
	
	        /// <summary>
	        /// Constructs a run iterator over the given text from start (inclusive)
	        /// to limit (exclusive).
	        /// </summary>
	        ///
	        public ScriptRunIterator(Replaceable text_0, int start_1, int limit_2) {
	            this.text = text_0;
	            this.textStart = start_1;
	            this.textLimit = limit_2;
	            this.limit = start_1;
	        }
	
	        /// <summary>
	        /// Returns TRUE if there are any more runs. TRUE is always returned at
	        /// least once. Upon return, the caller should examine scriptCode, start,
	        /// and limit.
	        /// </summary>
	        ///
	        public bool Next() {
	            int ch;
	            int s;
	
	            scriptCode = IBM.ICU.Lang.UScript.INVALID_CODE; // don't know script yet
	            start = limit;
	
	            // Are we done?
	            if (start == textLimit) {
	                return false;
	            }
	
	            // Move start back to include adjacent COMMON or INHERITED
	            // characters
	            while (start > textStart) {
	                ch = text.Char32At(start - 1); // look back
	                s = IBM.ICU.Lang.UScript.GetScript(ch);
	                if (s == IBM.ICU.Lang.UScript.COMMON || s == IBM.ICU.Lang.UScript.INHERITED) {
	                    --start;
	                } else {
	                    break;
	                }
	            }
	
	            // Move limit ahead to include COMMON, INHERITED, and characters
	            // of the current script.
	            while (limit < textLimit) {
	                ch = text.Char32At(limit); // look ahead
	                s = IBM.ICU.Lang.UScript.GetScript(ch);
	                if (s != IBM.ICU.Lang.UScript.COMMON && s != IBM.ICU.Lang.UScript.INHERITED) {
	                    if (scriptCode == IBM.ICU.Lang.UScript.INVALID_CODE) {
	                        scriptCode = s;
	                    } else if (s != scriptCode) {
	                        break;
	                    }
	                }
	                ++limit;
	            }
	
	            // Return TRUE even if the entire text is COMMON / INHERITED, in
	            // which case scriptCode will be UScript.INVALID_CODE.
	            return true;
	        }
	
	        /// <summary>
	        /// Adjusts internal indices for a change in the limit index of the given
	        /// delta. A positive delta means the limit has increased.
	        /// </summary>
	        ///
	        public void AdjustLimit(int delta) {
	            limit += delta;
	            textLimit += delta;
	        }
	    }
	}
	
	// eof
}
