/*
 *******************************************************************************
 * Copyright (C) 1996-2007, International Business Machines Corporation and    *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 */
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:30 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Text {
	
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Text;
     using ILOG.J2CsMapping.Util;
	
	
	/// <summary>
	/// A transliteration rule used by <c>RuleBasedTransliterator</c>.
	/// <c>TransliterationRule</c> is an immutable object.
	/// <p>
	/// A rule consists of an input pattern and an output string. When the input
	/// pattern is matched, the output string is emitted. The input pattern consists
	/// of zero or more characters which are matched exactly (the key) and optional
	/// context. Context must match if it is specified. Context may be specified
	/// before the key, after the key, or both. The key, preceding context, and
	/// following context may contain variables. Variables represent a set of Unicode
	/// characters, such as the letters <i>a</i> through <i>z</i>. Variables are
	/// detected by looking up each character in a supplied variable list to see if
	/// it has been so defined.
	/// <p>
	/// A rule may contain segments in its input string and segment references in its
	/// output string. A segment is a substring of the input pattern, indicated by an
	/// offset and limit. The segment may be in the preceding or following context.
	/// It may not span a context boundary. A segment reference is a special
	/// character in the output string that causes a segment of the input string (not
	/// the input pattern) to be copied to the output string. The range of special
	/// characters that represent segment references is defined by
	/// RuleBasedTransliterator.Data.
	/// <p>
	/// Example: The rule "([a-z]) . ([0-9]) > $2 . $1" will change the input string
	/// "abc.123" to "ab1.c23".
	/// <p>
	/// Copyright &copy; IBM Corporation 1999. All rights reserved.
	/// </summary>
	///
	internal class TransliterationRule {
	
	    // TODO Eliminate the pattern and keyLength data members. They
	    // are used only by masks() and getIndexValue() which are called
	    // only during build time, not during run-time. Perhaps these
	    // methods and pattern/keyLength can be isolated into a separate
	    // object.
	
	    /// <summary>
	    /// The match that must occur before the key, or null if there is no
	    /// preceding context.
	    /// </summary>
	    ///
	    private StringMatcher anteContext;
	
	    /// <summary>
	    /// The matcher object for the key. If null, then the key is empty.
	    /// </summary>
	    ///
	    private StringMatcher key;
	
	    /// <summary>
	    /// The match that must occur after the key, or null if there is no following
	    /// context.
	    /// </summary>
	    ///
	    private StringMatcher postContext;
	
	    /// <summary>
	    /// The object that performs the replacement if the key, anteContext, and
	    /// postContext are matched. Never null.
	    /// </summary>
	    ///
	    private UnicodeReplacer output;
	
	    /// <summary>
	    /// The string that must be matched, consisting of the anteContext, key, and
	    /// postContext, concatenated together, in that order. Some components may be
	    /// empty (zero length).
	    /// </summary>
	    ///
	    /// <seealso cref="null"/>
	    /// <seealso cref="null"/>
	    private String pattern;
	
	    /// <summary>
	    /// An array of matcher objects corresponding to the input pattern segments.
	    /// If there are no segments this is null. N.B. This is a UnicodeMatcher for
	    /// generality, but in practice it is always a StringMatcher. In the future
	    /// we may generalize this, but for now we sometimes cast down to
	    /// StringMatcher.
	    /// </summary>
	    ///
	    internal UnicodeMatcher[] segments;
	
	    /// <summary>
	    /// The length of the string that must match before the key. If zero, then
	    /// there is no matching requirement before the key. Substring
	    /// [0,anteContextLength) of pattern is the anteContext.
	    /// </summary>
	    ///
	    private int anteContextLength;
	
	    /// <summary>
	    /// The length of the key. Substring [anteContextLength, anteContextLength +
	    /// keyLength) is the key.
	    /// </summary>
	    ///
	    private int keyLength;
	
	    /// <summary>
	    /// Miscellaneous attributes.
	    /// </summary>
	    ///
	    internal byte flags;
	
	    /// <summary>
	    /// Flag attributes.
	    /// </summary>
	    ///
	    internal const int ANCHOR_START = 1;
	
	    internal const int ANCHOR_END = 2;
	
	    /// <summary>
	    /// An alias pointer to the data for this rule. The data provides lookup
	    /// services for matchers and segments.
	    /// </summary>
	    ///
	    private readonly RuleBasedTransliterator.Data data;
	
	    /// <summary>
	    /// Construct a new rule with the given input, output text, and other
	    /// attributes. A cursor position may be specified for the output text.
	    /// </summary>
	    ///
	    /// <param name="input">input string, including key and optional ante and post context</param>
	    /// <param name="anteContextPos">offset into input to end of ante context, or -1 if none. Mustbe <= input.length() if not -1.</param>
	    /// <param name="postContextPos">offset into input to start of post context, or -1 if none.Must be <= input.length() if not -1, and must be >=anteContextPos.</param>
	    /// <param name="output_0">output string</param>
	    /// <param name="cursorPos">offset into output at which cursor is located, or -1 if none.If less than zero, then the cursor is placed after the<c>output</c>; that is, -1 is equivalent to<c>output.length()</c>. If greater than<c>output.length()</c> then an exception is thrown.</param>
	    /// <param name="cursorOffset">an offset to be added to cursorPos to position the cursoreither in the ante context, if < 0, or in the post context, if> 0. For example, the rule "abc{def} > | @@@ xyz;" changes"def" to "xyz" and moves the cursor to before "a". It wouldhave a cursorOffset of -3.</param>
	    /// <param name="segs">array of UnicodeMatcher corresponding to input patternsegments, or null if there are none</param>
	    /// <param name="anchorStart">true if the the rule is anchored on the left to the contextstart</param>
	    /// <param name="anchorEnd">true if the rule is anchored on the right to the context limit</param>
	    public TransliterationRule(String input, int anteContextPos,
	            int postContextPos, String output_0, int cursorPos, int cursorOffset,
	            UnicodeMatcher[] segs, bool anchorStart, bool anchorEnd,
	            RuleBasedTransliterator.Data theData) {
	        data = theData;
	
	        // Do range checks only when warranted to save time
	        if (anteContextPos < 0) {
	            anteContextLength = 0;
	        } else {
	            if (anteContextPos > input.Length) {
	                throw new ArgumentException("Invalid ante context");
	            }
	            anteContextLength = anteContextPos;
	        }
	        if (postContextPos < 0) {
	            keyLength = input.Length - anteContextLength;
	        } else {
	            if (postContextPos < anteContextLength
	                    || postContextPos > input.Length) {
	                throw new ArgumentException("Invalid post context");
	            }
	            keyLength = postContextPos - anteContextLength;
	        }
	        if (cursorPos < 0) {
	            cursorPos = output_0.Length;
	        } else if (cursorPos > output_0.Length) {
	            throw new ArgumentException("Invalid cursor position");
	        }
	
	        // We don't validate the segments array. The caller must
	        // guarantee that the segments are well-formed (that is, that
	        // all $n references in the output refer to indices of this
	        // array, and that no array elements are null).
	        this.segments = segs;
	
	        pattern = input;
	        flags = 0;
	        if (anchorStart) {
	            flags |= ANCHOR_START;
	        }
	        if (anchorEnd) {
	            flags |= ANCHOR_END;
	        }
	
	        anteContext = null;
	        if (anteContextLength > 0) {
	            anteContext = new StringMatcher(pattern.Substring(0,(anteContextLength)-(0)), 0, data);
	        }
	
	        key = null;
	        if (keyLength > 0) {
	            key = new StringMatcher(pattern.Substring(anteContextLength,(anteContextLength + keyLength)-(anteContextLength)), 0, data);
	        }
	
	        int postContextLength = pattern.Length - keyLength
	                - anteContextLength;
	        postContext = null;
	        if (postContextLength > 0) {
	            postContext = new StringMatcher(pattern.Substring(anteContextLength
	                                + keyLength), 0, data);
	        }
	
	        this.output = new StringReplacer(output_0, cursorPos + cursorOffset, data);
	    }
	
	    /// <summary>
	    /// Return the preceding context length. This method is needed to support the
	    /// <c>Transliterator</c> method <c>getMaximumContextLength()</c>
	    /// .
	    /// </summary>
	    ///
	    public int GetAnteContextLength() {
	        return anteContextLength + (((flags & ANCHOR_START) != 0) ? 1 : 0);
	    }
	
	    /// <summary>
	    /// Internal method. Returns 8-bit index value for this rule. This is the low
	    /// byte of the first character of the key, unless the first character of the
	    /// key is a set. If it's a set, or otherwise can match multiple keys, the
	    /// index value is -1.
	    /// </summary>
	    ///
	    internal int GetIndexValue() {
	        if (anteContextLength == pattern.Length) {
	            // A pattern with just ante context {such as foo)>bar} can
	            // match any key.
	            return -1;
	        }
	        int c = IBM.ICU.Text.UTF16.CharAt(pattern, anteContextLength);
	        return (data.LookupMatcher(c) == null) ? (c & 0xFF) : -1;
	    }
	
	    /// <summary>
	    /// Internal method. Returns true if this rule matches the given index value.
	    /// The index value is an 8-bit integer, 0..255, representing the low byte of
	    /// the first character of the key. It matches this rule if it matches the
	    /// first character of the key, or if the first character of the key is a
	    /// set, and the set contains any character with a low byte equal to the
	    /// index value. If the rule contains only ante context, as in foo)>bar, then
	    /// it will match any key.
	    /// </summary>
	    ///
	    internal bool MatchesIndexValue(int v) {
	        // Delegate to the key, or if there is none, to the postContext.
	        // If there is neither then we match any key; return true.
	        UnicodeMatcher m = (key != null) ? key : postContext;
	        return (m != null) ? m.MatchesIndexValue(v) : true;
	    }
	
	    /// <summary>
	    /// Return true if this rule masks another rule. If r1 masks r2 then r1
	    /// matches any input string that r2 matches. If r1 masks r2 and r2 masks r1
	    /// then r1 == r2. Examples: "a>x" masks "ab>y". "a>x" masks "a[b]>y".
	    /// "[c]a>x" masks "[dc]a>y".
	    /// </summary>
	    ///
	    public bool Masks(TransliterationRule r2) {
	        /*
	         * Rule r1 masks rule r2 if the string formed of the antecontext, key,
	         * and postcontext overlaps in the following way:
	         * 
	         * r1: aakkkpppp r2: aaakkkkkpppp ^
	         * 
	         * The strings must be aligned at the first character of the key. The
	         * length of r1 to the left of the alignment point must be <= the length
	         * of r2 to the left; ditto for the right. The characters of r1 must
	         * equal (or be a superset of) the corresponding characters of r2. The
	         * superset operation should be performed to check for UnicodeSet
	         * masking.
	         * 
	         * Anchors: Two patterns that differ only in anchors only mask one
	         * another if they are exactly equal, and r2 has all the anchors r1 has
	         * (optionally, plus some). Here Y means the row masks the column, N
	         * means it doesn't.
	         * 
	         * ab ^ab ab$ ^ab$ ab Y Y Y Y ^ab N Y N Y ab$ N N Y Y ^ab$ N N N Y
	         * 
	         * Post context: {a}b masks ab, but not vice versa, since {a}b matches
	         * everything ab matches, and {a}b matches {|a|}b but ab does not. Pre
	         * context is different (a{b} does not align with ab).
	         */
	
	        /*
	         * LIMITATION of the current mask algorithm: Some rule maskings are
	         * currently not detected. For example, "{Lu}]a>x" masks "A]a>y". This
	         * can be added later. TODO
	         */
	
	        int len = pattern.Length;
	        int left = anteContextLength;
	        int left2 = r2.anteContextLength;
	        int right = pattern.Length - left;
	        int right2 = r2.pattern.Length - left2;
	
	        // TODO Clean this up -- some logic might be combinable with the
	        // next statement.
	
	        // Test for anchor masking
	        if (left == left2 && right == right2 && keyLength <= r2.keyLength
	                && StringUtil.RegionMatches( r2.pattern, 0, pattern, 0, len)) {
	            // The following boolean logic : the table above
	            return (flags == r2.flags)
	                    || (!((flags & ANCHOR_START) != 0) && !((flags & ANCHOR_END) != 0))
	                    || (((r2.flags & ANCHOR_START) != 0) && ((r2.flags & ANCHOR_END) != 0));
	        }
	
	        return left <= left2
	                && (right < right2 || (right == right2 && keyLength <= r2.keyLength))
	                && StringUtil.RegionMatches( r2.pattern, left2 - left, pattern, 0, len);
	    }
	
	    static internal int PosBefore(Replaceable str, int pos) {
	        return (pos > 0) ? pos - IBM.ICU.Text.UTF16.GetCharCount(str.Char32At(pos - 1))
	                : pos - 1;
	    }
	
	    static internal int PosAfter(Replaceable str, int pos) {
	        return (pos >= 0 && pos < str.Length()) ? pos
	                + IBM.ICU.Text.UTF16.GetCharCount(str.Char32At(pos)) : pos + 1;
	    }
	
	    /// <summary>
	    /// Attempt a match and replacement at the given position. Return the degree
	    /// of match between this rule and the given text. The degree of match may be
	    /// mismatch, a partial match, or a full match. A mismatch means at least one
	    /// character of the text does not match the context or key. A partial match
	    /// means some context and key characters match, but the text is not long
	    /// enough to match all of them. A full match means all context and key
	    /// characters match.
	    /// If a full match is obtained, perform a replacement, update pos, and
	    /// return U_MATCH. Otherwise both text and pos are unchanged.
	    /// </summary>
	    ///
	    /// <param name="text">the text</param>
	    /// <param name="pos">the position indices</param>
	    /// <param name="incremental">if TRUE, test for partial matches that may be completed byadditional text inserted at pos.limit.</param>
	    /// <returns>one of <c>U_MISMATCH</c>, <c>U_PARTIAL_MATCH</c>, or
	    /// <c>U_MATCH</c>. If incremental is FALSE then
	    /// U_PARTIAL_MATCH will not be returned.</returns>
	    public int MatchAndReplace(Replaceable text, Transliterator.Position pos,
	            bool incremental) {
	        // Matching and replacing are done in one method because the
	        // replacement operation needs information obtained during the
	        // match. Another way to do this is to have the match method
	        // create a match result struct with relevant offsets, and to pass
	        // this into the replace method.
	
	        // ============================ MATCH ===========================
	
	        // Reset segment match data
	        if (segments != null) {
	            for (int i = 0; i < segments.Length; ++i) {
	                ((StringMatcher) segments[i]).ResetMatch();
	            }
	        }
	
	        int keyLimit;
	        int[] intRef = new int[1];
	
	        // ------------------------ Ante Context ------------------------
	
	        // A mismatch in the ante context, or with the start anchor,
	        // is an outright U_MISMATCH regardless of whether we are
	        // incremental or not.
	        int oText; // offset into 'text'
	        int minOText;
	
	        // Note (1): We process text in 16-bit code units, rather than
	        // 32-bit code points. This works because stand-ins are
	        // always in the BMP and because we are doing a literal match
	        // operation, which can be done 16-bits at a time.
	
	        int anteLimit = PosBefore(text, pos.contextStart);
	
	        int match;
	
	        // Start reverse match at char before pos.start
	        intRef[0] = PosBefore(text, pos.start);
	
	        if (anteContext != null) {
	            match = anteContext.Matches(text, intRef, anteLimit, false);
	            if (match != IBM.ICU.Text.UnicodeMatcher_Constants.U_MATCH) {
	                return IBM.ICU.Text.UnicodeMatcher_Constants.U_MISMATCH;
	            }
	        }
	
	        oText = intRef[0];
	
	        minOText = PosAfter(text, oText);
	
	        // ------------------------ Start Anchor ------------------------
	
	        if (((flags & ANCHOR_START) != 0) && oText != anteLimit) {
	            return IBM.ICU.Text.UnicodeMatcher_Constants.U_MISMATCH;
	        }
	
	        // -------------------- Key and Post Context --------------------
	
	        intRef[0] = pos.start;
	
	        if (key != null) {
	            match = key.Matches(text, intRef, pos.limit, incremental);
	            if (match != IBM.ICU.Text.UnicodeMatcher_Constants.U_MATCH) {
	                return match;
	            }
	        }
	
	        keyLimit = intRef[0];
	
	        if (postContext != null) {
	            if (incremental && keyLimit == pos.limit) {
	                // The key matches just before pos.limit, and there is
	                // a postContext. Since we are in incremental mode,
	                // we must assume more characters may be inserted at
	                // pos.limit -- this is a partial match.
	                return IBM.ICU.Text.UnicodeMatcher_Constants.U_PARTIAL_MATCH;
	            }
	
	            match = postContext.Matches(text, intRef, pos.contextLimit,
	                    incremental);
	            if (match != IBM.ICU.Text.UnicodeMatcher_Constants.U_MATCH) {
	                return match;
	            }
	        }
	
	        oText = intRef[0];
	
	        // ------------------------- Stop Anchor ------------------------
	
	        if (((flags & ANCHOR_END)) != 0) {
	            if (oText != pos.contextLimit) {
	                return IBM.ICU.Text.UnicodeMatcher_Constants.U_MISMATCH;
	            }
	            if (incremental) {
	                return IBM.ICU.Text.UnicodeMatcher_Constants.U_PARTIAL_MATCH;
	            }
	        }
	
	        // =========================== REPLACE ==========================
	
	        // We have a full match. The key is between pos.start and
	        // keyLimit.
	
	        int newLength = output.Replace(text, pos.start, keyLimit, intRef);
	        int lenDelta = newLength - (keyLimit - pos.start);
	        int newStart = intRef[0];
	
	        oText += lenDelta;
	        pos.limit += lenDelta;
	        pos.contextLimit += lenDelta;
	        // Restrict new value of start to [minOText, min(oText, pos.limit)].
	        pos.start = Math.Max(minOText,Math.Min(Math.Min(oText,pos.limit),newStart));
	        return IBM.ICU.Text.UnicodeMatcher_Constants.U_MATCH;
	    }
	
	    /// <summary>
	    /// Create a source string that represents this rule. Append it to the given
	    /// string.
	    /// </summary>
	    ///
	    public String ToRule(bool escapeUnprintable) {
	        // int i;
	
	        StringBuilder rule = new StringBuilder();
	
	        // Accumulate special characters (and non-specials following them)
	        // into quoteBuf. Append quoteBuf, within single quotes, when
	        // a non-quoted element must be inserted.
	        StringBuilder quoteBuf = new StringBuilder();
	
	        // Do not emit the braces '{' '}' around the pattern if there
	        // is neither anteContext nor postContext.
	        bool emitBraces = (anteContext != null) || (postContext != null);
	
	        // Emit start anchor
	        if ((flags & ANCHOR_START) != 0) {
	            rule.Append('^');
	        }
	
	        // Emit the input pattern
	        IBM.ICU.Impl.Utility.AppendToRule(rule, anteContext, escapeUnprintable, quoteBuf);
	
	        if (emitBraces) {
	            IBM.ICU.Impl.Utility.AppendToRule(rule, '{', true, escapeUnprintable, quoteBuf);
	        }
	
	        IBM.ICU.Impl.Utility.AppendToRule(rule, key, escapeUnprintable, quoteBuf);
	
	        if (emitBraces) {
	            IBM.ICU.Impl.Utility.AppendToRule(rule, '}', true, escapeUnprintable, quoteBuf);
	        }
	
	        IBM.ICU.Impl.Utility.AppendToRule(rule, postContext, escapeUnprintable, quoteBuf);
	
	        // Emit end anchor
	        if ((flags & ANCHOR_END) != 0) {
	            rule.Append('$');
	        }
	
	        IBM.ICU.Impl.Utility.AppendToRule(rule, " > ", true, escapeUnprintable, quoteBuf);
	
	        // Emit the output pattern
	
	        IBM.ICU.Impl.Utility.AppendToRule(rule, output.ToReplacerPattern(escapeUnprintable),
	                true, escapeUnprintable, quoteBuf);
	
	        IBM.ICU.Impl.Utility.AppendToRule(rule, ';', true, escapeUnprintable, quoteBuf);
	
	        return rule.ToString();
	    }
	
	    /// <summary>
	    /// Return a string representation of this object.
	    /// </summary>
	    ///
	    /// <returns>string representation of this object</returns>
	    public override String ToString() {
	        return '{' + ToRule(true) + '}';
	    }
	
	    /// <summary>
	    /// Union the set of all characters that may be modified by this rule into
	    /// the given set.
	    /// </summary>
	    ///
	    internal void AddSourceSetTo(UnicodeSet toUnionTo) {
	        int limit = anteContextLength + keyLength;
	        for (int i = anteContextLength; i < limit;) {
	            int ch = IBM.ICU.Text.UTF16.CharAt(pattern, i);
	            i += IBM.ICU.Text.UTF16.GetCharCount(ch);
	            UnicodeMatcher matcher = data.LookupMatcher(ch);
	            if (matcher == null) {
	                toUnionTo.Add(ch);
	            } else {
	                matcher.AddMatchSetTo(toUnionTo);
	            }
	        }
	    }
	
	    /// <summary>
	    /// Union the set of all characters that may be emitted by this rule into the
	    /// given set.
	    /// </summary>
	    ///
	    internal void AddTargetSetTo(UnicodeSet toUnionTo) {
	        output.AddReplacementSetTo(toUnionTo);
	    }
	}
}
