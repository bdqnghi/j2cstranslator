// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:48 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2001-2007, International Business Machines Corporation and    
/// others. All Rights Reserved.                                                
/// </summary>
///
namespace IBM.ICU.Util {
	
	using IBM.ICU.Impl;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.Globalization;
	using System.IO;
	using System.Resources;
	using System.Runtime.CompilerServices;
	using System.Runtime.Serialization;
    using ILOG.J2CsMapping.Util;
    using ILOG.J2CsMapping.Formatting;
	
	/// <summary>
	/// A class encapsulating a currency, as defined by ISO 4217. A <tt>Currency</tt>
	/// object can be created given a <tt>Locale</tt> or given an ISO 4217 code. Once
	/// created, the <tt>Currency</tt> object can return various data necessary to
	/// its proper display:
	/// <ul>
	/// <li>A display symbol, for a specific locale
	/// <li>The number of fraction digits to display
	/// <li>A rounding increment
	/// </ul>
	/// The <tt>DecimalFormat</tt> class uses these data to display currencies.
	/// <p>
	/// Note: This class deliberately resembles <tt>java.util.Currency</tt> but it
	/// has a completely independent implementation, and adds features not present in
	/// the JDK.
	/// </summary>
	///
	/// @stable ICU 2.2
	[Serializable]
	public class Currency : MeasureUnit {
	    // using serialver from jdk1.4.2_05
	    private const long serialVersionUID = -5839973855554750484L;
	
	    private static readonly bool DEBUG = IBM.ICU.Impl.ICUDebug.Enabled("currency");
	
	    /// <summary>
	    /// ISO 4217 3-letter code.
	    /// </summary>
	    ///
	    private String isoCode;
	
	    /// <summary>
	    /// Selector for getName() indicating a symbolic name for a currency, such as
	    /// "$" for USD.
	    /// </summary>
	    ///
	    /// @stable ICU 2.6
	    public const int SYMBOL_NAME = 0;
	
	    /// <summary>
	    /// Selector for ucurr_getName indicating the long name for a currency, such
	    /// as "US Dollar" for USD.
	    /// </summary>
	    ///
	    /// @stable ICU 2.6
	    public const int LONG_NAME = 1;
	
	    // begin registry stuff
	
	    // shim for service code
	    /* package */abstract internal class ServiceShim {
	        abstract internal ULocale[] GetAvailableULocales();

            abstract internal Locale[] GetAvailableLocales();
	
	        abstract internal Currency CreateInstance(ULocale l);
	
	        abstract internal Object RegisterInstance(Currency c, ULocale l);
	
	        abstract internal bool Unregister(Object f);
	    }
	
	    private static Currency.ServiceShim  shim;
	
	    private static Currency.ServiceShim  GetShim() {
	        // Note: this instantiation is safe on loose-memory-model configurations
	        // despite lack of synchronization, since the shim instance has no
	        // state--
	        // it's all in the class init. The worst problem is we might instantiate
	        // two shim instances, but they'll share the same state so that's ok.
	        if (shim == null) {
	            try {
	                Type cls = ILOG.J2CsMapping.Reflect.Helper.GetNativeType("com.ibm.icu.util.CurrencyServiceShim");
	                shim = (Currency.ServiceShim ) Activator.CreateInstance(cls);
	            } catch (Exception e) {
	                if (DEBUG) {
	                    Console.Error.WriteLine(e.StackTrace);
	                }
	                throw new Exception(e.Message);
	            }
	        }
	        return shim;
	    }
	
	    /// <summary>
	    /// Returns a currency object for the default currency in the given locale.
	    /// </summary>
	    ///
	    /// <param name="locale">the locale</param>
	    /// <returns>the currency object for this locale</returns>
	    /// @stable ICU 2.2
        public static Currency GetInstance(Locale locale)
        {
	        return GetInstance(IBM.ICU.Util.ULocale.ForLocale(locale));
	    }
	
	    /// <summary>
	    /// Returns a currency object for the default currency in the given locale.
	    /// </summary>
	    ///
	    /// @stable ICU 3.2
	    public static Currency GetInstance(ULocale locale) {
	        String currency = locale.GetKeywordValue("currency");
	        if (currency != null) {
	            return GetInstance(currency);
	        }
	
	        if (shim == null) {
	            return CreateCurrency(locale);
	        }
	
	        return shim.CreateInstance(locale);
	    }
	
	    private const String EUR_STR = "EUR";
	
	    /// <summary>
	    /// Instantiate a currency from a resource bundle found in Locale loc.
	    /// </summary>
	    ///
	    /* package */static internal Currency CreateCurrency(ULocale loc) {
	        String country = loc.GetCountry();
	        String variant = loc.GetVariant();
	        bool isPreEuro = variant.Equals("PREEURO");
	        bool isEuro = variant.Equals("EURO");
	        // TODO: ICU4C has service registration, and the currency is requested
	        // from the service here.
	        ICUResourceBundle bundle = (ICUResourceBundle) IBM.ICU.Util.UResourceBundle
	                .GetBundleInstance(IBM.ICU.Impl.ICUResourceBundle.ICU_BASE_NAME,
	                        "supplementalData",
	                        IBM.ICU.Impl.ICUResourceBundle.ICU_DATA_CLASS_LOADER);
	        if (bundle == null) {
	            // throw new MissingResourceException()
	            return null;
	        }
	        try {
	            UResourceBundle cm = bundle.Get("CurrencyMap");
	            String curriso = null;
	            UResourceBundle countryArray = cm.Get(country);
	            // Some regions can have more than one current currency in use.
	            // The latest default currency is always the first one.
	            UResourceBundle currencyReq = countryArray.Get(0);
	            curriso = currencyReq.GetString("id");
	            if (isPreEuro && curriso.Equals(EUR_STR)) {
	                currencyReq = countryArray.Get(1);
	                curriso = currencyReq.GetString("id");
	            } else if (isEuro) {
	                curriso = EUR_STR;
	            }
	            if (curriso != null) {
	                return new Currency(curriso);
	            }
	        } catch (MissingManifestResourceException ex) {
	            // We don't know about this region.
	            // As of CLDR 1.5.1, the data includes deprecated region history
	            // too.
	            // So if we get here, either the region doesn't exist, or the data
	            // is really bad.
	            // Deprecated regions should return the last valid currency for that
	            // region in the data.
	            // We don't try to resolve it to a new region.
	        }
	        return null;
	    }
	
	    /// <summary>
	    /// Returns a currency object given an ISO 4217 3-letter code.
	    /// </summary>
	    ///
	    /// <param name="theISOCode">the iso code</param>
	    /// <returns>the currency for this iso code</returns>
	    /// @stable ICU 2.2
	    public static Currency GetInstance(String theISOCode) {
	        return new Currency(theISOCode);
	    }
	
	    /// <summary>
	    /// Registers a new currency for the provided locale. The returned object is
	    /// a key that can be used to unregister this currency object.
	    /// </summary>
	    ///
	    /// <param name="currency">the currency to register</param>
	    /// <param name="locale">the ulocale under which to register the currency</param>
	    /// <returns>a registry key that can be used to unregister this currency</returns>
	    /// <seealso cref="M:IBM.ICU.Util.Currency.Unregister(System.Object)"/>
	    /// @stable ICU 3.2
	    public static Object RegisterInstance(Currency currency, ULocale locale) {
	        return GetShim().RegisterInstance(currency, locale);
	    }
	
	    /// <summary>
	    /// Unregister the currency associated with this key (obtained from
	    /// registerInstance).
	    /// </summary>
	    ///
	    /// <param name="registryKey">the registry key returned from registerInstance</param>
	    /// <seealso cref="M:IBM.ICU.Util.Currency.RegisterInstance(IBM.ICU.Util.Currency, IBM.ICU.Util.ULocale)"/>
	    /// @stable ICU 2.6
	    public static bool Unregister(Object registryKey) {
	        if (registryKey == null) {
	            throw new ArgumentException("registryKey must not be null");
	        }
	        if (shim == null) {
	            return false;
	        }
	        return shim.Unregister(registryKey);
	    }
	
	    /// <summary>
	    /// Return an array of the locales for which a currency is defined.
	    /// </summary>
	    ///
	    /// <returns>an array of the available locales</returns>
	    /// @stable ICU 2.2
        public static Locale[] GetAvailableLocales()
        {
	        if (shim == null) {
	            return IBM.ICU.Impl.ICUResourceBundle
	                    .GetAvailableLocales(IBM.ICU.Impl.ICUResourceBundle.ICU_BASE_NAME);
	        } else {
	            return shim.GetAvailableLocales();
	        }
	    }
	
	    /// <summary>
	    /// Return an array of the ulocales for which a currency is defined.
	    /// </summary>
	    ///
	    /// <returns>an array of the available ulocales</returns>
	    /// @stable ICU 3.2
	    public static ULocale[] GetAvailableULocales() {
	        if (shim == null) {
	            return IBM.ICU.Impl.ICUResourceBundle
	                    .GetAvailableULocales(IBM.ICU.Impl.ICUResourceBundle.ICU_BASE_NAME);
	        } else {
	            return shim.GetAvailableULocales();
	        }
	    }
	
	    // end registry stuff
	
	    /// <summary>
	    /// Return a hashcode for this currency.
	    /// </summary>
	    ///
	    /// @stable ICU 2.2
	    public override int GetHashCode() {
	        return isoCode.GetHashCode();
	    }
	
	    /// <summary>
	    /// Return true if rhs is a Currency instance, is non-null, and has the same
	    /// currency code.
	    /// </summary>
	    ///
	    /// @stable ICU 2.2
	    public override bool Equals(Object rhs) {
	        if (rhs == null)
	            return false;
	        if (rhs == (Object) this)
	            return true;
	        try {
	            Currency c = (Currency) rhs;
	            return isoCode.Equals(c.isoCode);
	        } catch (InvalidCastException e) {
	            return false;
	        }
	    }
	
	    /// <summary>
	    /// Returns the ISO 4217 3-letter code for this currency object.
	    /// </summary>
	    ///
	    /// @stable ICU 2.2
	    public String GetCurrencyCode() {
	        return isoCode;
	    }
	
	    /// <summary>
	    /// Convenience and compatibility override of getName that requests the
	    /// symbol name.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Util.Currency.GetName(null, System.Int32, null)"/>
	    /// @stable ICU 3.4
	    public String GetSymbol() {
	        return GetSymbol(IBM.ICU.Util.ULocale.GetDefault());
	    }
	
	    /// <summary>
	    /// Convenience and compatibility override of getName that requests the
	    /// symbol name.
	    /// </summary>
	    ///
	    /// <param name="loc">the Locale for the symbol</param>
	    /// <seealso cref="M:IBM.ICU.Util.Currency.GetName(null, System.Int32, null)"/>
	    /// @stable ICU 3.4
        public String GetSymbol(Locale loc)
        {
	        return GetSymbol(IBM.ICU.Util.ULocale.ForLocale(loc));
	    }
	
	    /// <summary>
	    /// Convenience and compatibility override of getName that requests the
	    /// symbol name.
	    /// </summary>
	    ///
	    /// <param name="uloc">the ULocale for the symbol</param>
	    /// <seealso cref="M:IBM.ICU.Util.Currency.GetName(null, System.Int32, null)"/>
	    /// @stable ICU 3.4
	    public String GetSymbol(ULocale uloc) {
	        return GetName(uloc, SYMBOL_NAME, new bool[1]);
	    }
	
	    /// <summary>
	    /// Returns the display name for the given currency in the given locale. For
	    /// example, the display name for the USD currency object in the en_US locale
	    /// is "$".
	    /// </summary>
	    ///
	    /// <param name="locale">locale in which to display currency</param>
	    /// <param name="nameStyle">selector for which kind of name to return</param>
	    /// <param name="isChoiceFormat">fill-in; isChoiceFormat[0] is set to true if the returnedvalue is a ChoiceFormat pattern; otherwise it is set to false</param>
	    /// <returns>display string for this currency. If the resource data contains
	    /// no entry for this currency, then the ISO 4217 code is returned.
	    /// If isChoiceFormat[0] is true, then the result is a ChoiceFormat
	    /// pattern. Otherwise it is a static string.</returns>
	    /// @stable ICU 3.2
        public String GetName(Locale locale, int nameStyle, bool[] isChoiceFormat)
        {
	        return GetName(IBM.ICU.Util.ULocale.ForLocale(locale), nameStyle, isChoiceFormat);
	    }
	
	    /// <summary>
	    /// Returns the display name for the given currency in the given locale. For
	    /// example, the display name for the USD currency object in the en_US locale
	    /// is "$".
	    /// </summary>
	    ///
	    /// <param name="locale">locale in which to display currency</param>
	    /// <param name="nameStyle">selector for which kind of name to return</param>
	    /// <param name="isChoiceFormat">fill-in; isChoiceFormat[0] is set to true if the returnedvalue is a ChoiceFormat pattern; otherwise it is set to false</param>
	    /// <returns>display string for this currency. If the resource data contains
	    /// no entry for this currency, then the ISO 4217 code is returned.
	    /// If isChoiceFormat[0] is true, then the result is a ChoiceFormat
	    /// pattern. Otherwise it is a static string.</returns>
	    /// @stable ICU 3.2
	    public String GetName(ULocale locale, int nameStyle,
	            bool[] isChoiceFormat) {
	
	        // Look up the Currencies resource for the given locale. The
	        // Currencies locale data looks like this:
	        // |en {
	        // | Currencies {
	        // | USD { "US$", "US Dollar" }
	        // | CHF { "Sw F", "Swiss Franc" }
	        // | INR { "=0#Rs|1#Re|1<Rs", "=0#Rupees|1#Rupee|1<Rupees" }
	        // | //...
	        // | }
	        // |}
	
	        if (nameStyle < 0 || nameStyle > 1) {
	            throw new ArgumentException();
	        }
	
	        String s = null;
	
	        try {
	            UResourceBundle rb = IBM.ICU.Util.UResourceBundle.GetBundleInstance(
	                    IBM.ICU.Impl.ICUResourceBundle.ICU_BASE_NAME, locale);
	            ICUResourceBundle currencies = (ICUResourceBundle) rb
	                    .Get("Currencies");
	
	            // Fetch resource with multi-level resource inheritance fallback
	            s = currencies.GetWithFallback(isoCode).GetString(nameStyle);
	        } catch (MissingManifestResourceException e) {
	            // TODO what should be done here?
	        }
	
	        // Determine if this is a ChoiceFormat pattern. One leading mark
	        // indicates a ChoiceFormat. Two indicates a static string that
	        // starts with a mark. In either case, the first mark is ignored,
	        // if present. Marks in the rest of the string have no special
	        // meaning.
	        isChoiceFormat[0] = false;
	        if (s != null) {
	            int i = 0;
	            while (i < s.Length && s[i] == '=' && i < 2) {
	                ++i;
	            }
	            isChoiceFormat[0] = (i == 1);
	            if (i != 0) {
	                // Skip over first mark
	                s = s.Substring(1);
	            }
	            return s;
	        }
	
	        // If we fail to find a match, use the ISO 4217 code
	        return isoCode;
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Attempt to parse the given string as a currency, either as a display name
	    /// in the given locale, or as a 3-letter ISO 4217 code. If multiple display
	    /// names match, then the longest one is selected. If both a display name and
	    /// a 3-letter ISO code match, then the display name is preferred, unless
	    /// it's length is less than 3.
	    /// </summary>
	    ///
	    /// <param name="locale">the locale of the display names to match</param>
	    /// <param name="text">the text to parse</param>
	    /// <param name="pos">input-output position; on input, the position within text tomatch; must have 0 <= pos.getIndex() < text.length(); onoutput, the position after the last matched character. If theparse fails, the position in unchanged upon output.</param>
	    /// <returns>the ISO 4217 code, as a string, of the best match, or null if
	    /// there is no match</returns>
	    public static String Parse(ULocale locale, String text, ILOG.J2CsMapping.Text.ParsePosition pos) {
	
	        // TODO: There is a slight problem with the pseudo-multi-level
	        // fallback implemented here. More-specific locales don't
	        // properly shield duplicate entries in less-specific locales.
	        // This problem will go away when real multi-level fallback is
	        // implemented. We could also fix this by recording (in a
	        // hash) which codes are used at each level of fallback, but
	        // this doesn't seem warranted.
	
	        int start = pos.GetIndex();
	        String fragment = text.Substring(start);
	
	        String iso = null;
	        int max = 0;
	
	        // Look up the Currencies resource for the given locale. The
	        // Currencies locale data looks like this:
	        // |en {
	        // | Currencies {
	        // | USD { "US$", "US Dollar" }
	        // | CHF { "Sw F", "Swiss Franc" }
	        // | INR { "=0#Rs|1#Re|1<Rs", "=0#Rupees|1#Rupee|1<Rupees" }
	        // | //...
	        // | }
	        // |}
	
	        // In the future, resource bundles may implement multi-level
	        // fallback. That is, if a currency is not found in the en_US
	        // Currencies data, then the en Currencies data will be searched.
	        // Currently, if a Currencies datum exists in en_US and en, the
	        // en_US entry hides that in en.
	
	        // We want multi-level fallback for this resource, so we implement
	        // it manually.
	
	        // Multi-level resource inheritance fallback loop
	
	        while (locale != null) {
	            UResourceBundle rb = IBM.ICU.Util.UResourceBundle.GetBundleInstance(
	                    IBM.ICU.Impl.ICUResourceBundle.ICU_BASE_NAME, locale);
	            // We can't cast this to String[][]; the cast has to happen later
	
	            try {
	                UResourceBundle currencies = rb.Get("Currencies");
	                // Do a linear search
	                for (int i = 0; i < currencies.GetSize(); ++i) {
	                    // String name = ((String[]) currencies[i][1])[0];
	                    UResourceBundle item = currencies.Get(i);
	                    String name = item.GetString(0);
	                    if (name.Length < 1) {
	                        // Ignore zero-length names -- later, change this
	                        // when zero-length is used to mean something.
	                        continue;
	                    } else if (name[0] == '=') {
	                        name = name.Substring(1);
	                        if (name.Length > 0 && name[0] != '=') {
	                            ChoiceFormat choice = new ChoiceFormat(name);
	                            // Number n =
	                            choice.Parse(text, pos);
	                            int len = pos.GetIndex() - start;
	                            if (len > max) {
	                                iso = item.GetKey();
	                                max = len;
	                            }
	                            pos.SetIndex(start);
	                            continue;
	                        }
	                    }
	                    if (name.Length > max && fragment.StartsWith(name)) {
	                        iso = item.GetKey();
	                        max = name.Length;
	                    }
	                }
	            } catch (MissingManifestResourceException e) {
	            }
	
	            locale = locale.GetFallback();
	        }
	
	        /*
	         * 1. Look at the Currencies array from the locale 1a. Iterate through
	         * it, and check each row to see if row[1] matches 1a1. If row[1] is a
	         * pattern, use ChoiceFormat to attempt a parse 1b. Upon a match, return
	         * the ISO code stored at row[0] 2. If there is no match, fall back to
	         * "en" and try again 3. If there is no match, fall back to root and try
	         * again 4. If still no match, parse 3-letter ISO {this code is probably
	         * unchanged}.
	         * 
	         * ICUResourceBundle rb =
	         * (ICUResourceBundle)UResourceBundle.getBundleInstance
	         * (UResourceBundle.ICU_BASE_NAME, locale); ICUResourceBundle currencies
	         * = rb.get("Currencies");
	         */
	        // If display name parse fails or if it matches fewer than 3
	        // characters, try to parse 3-letter ISO. Do this after the
	        // display name processing so 3-letter display names are
	        // preferred. Consider /[A-Z]{3}/ to be valid ISO, and parse
	        // it manually--UnicodeSet/regex are too slow and heavy.
	        if (max < 3 && (text.Length - start) >= 3) {
	            bool valid = true;
	            for (int k = 0; k < 3; ++k) {
	                char ch = text[start + k]; // 16-bit ok
	                if (ch < 'A' || ch > 'Z') {
	                    valid = false;
	                    break;
	                }
	            }
	            if (valid) {
	                iso = text.Substring(start,(start + 3)-(start));
	                max = 3;
	            }
	        }
	
	        pos.SetIndex(start + max);
	        return iso;
	    }
	
	    /// <summary>
	    /// Returns the number of the number of fraction digits that should be
	    /// displayed for this currency.
	    /// </summary>
	    ///
	    /// <returns>a non-negative number of fraction digits to be displayed</returns>
	    /// @stable ICU 2.2
	    public int GetDefaultFractionDigits() {
	        return (FindData())[0];
	    }
	
	    /// <summary>
	    /// Returns the rounding increment for this currency, or 0.0 if no rounding
	    /// is done by this currency.
	    /// </summary>
	    ///
	    /// <returns>the non-negative rounding increment, or 0.0 if none</returns>
	    /// @stable ICU 2.2
	    public double GetRoundingIncrement() {
	        int[] data = FindData();
	
	        int data1 = data[1]; // rounding increment
	
	        // If there is no rounding return 0.0 to indicate no rounding.
	        // This is the high-runner case, by far.
	        if (data1 == 0) {
	            return 0.0d;
	        }
	
	        int data0 = data[0]; // fraction digits
	
	        // If the meta data is invalid, return 0.0 to indicate no rounding.
	        if (data0 < 0 || data0 >= POW10.Length) {
	            return 0.0d;
	        }
	
	        // Return data[1] / 10^(data[0]). The only actual rounding data,
	        // as of this writing, is CHF { 2, 25 }.
	        return (double) data1 / POW10[data0];
	    }
	
	    /// <summary>
	    /// Returns the ISO 4217 code for this currency.
	    /// </summary>
	    ///
	    /// @stable ICU 2.2
	    public override String ToString() {
	        return isoCode;
	    }
	
	    /// <summary>
	    /// Constructs a currency object for the given ISO 4217 3-letter code. This
	    /// constructor assumes that the code is valid.
	    /// </summary>
	    ///
	    /// <param name="theISOCode">The iso code used to construct the currency.</param>
	    /// @draft ICU 3.4
	    /// @provisional This API might change or be removed in a future release.
	    protected internal Currency(String theISOCode) {
	        isoCode = theISOCode;
	    }
	
	    /// <summary>
	    /// Internal function to look up currency data. Result is an array of two
	    /// Integers. The first is the fraction digits. The second is the rounding
	    /// increment, or 0 if none. The rounding increment is in units of
	    /// 10^(-fraction_digits).
	    /// </summary>
	    ///
	    private int[] FindData() {
	
	        try {
	            // Get CurrencyMeta resource out of root locale file. [This may
	            // move out of the root locale file later; if it does, update this
	            // code.]
	            UResourceBundle root = IBM.ICU.Util.UResourceBundle.GetBundleInstance(
	                    IBM.ICU.Impl.ICUResourceBundle.ICU_BASE_NAME, "supplementalData",
	                    IBM.ICU.Impl.ICUResourceBundle.ICU_DATA_CLASS_LOADER);
	            UResourceBundle currencyMeta = root.Get("CurrencyMeta");
	
	            // Integer[] i = null;
	            // int defaultPos = -1;
	            int[] i = currencyMeta.Get(isoCode).GetIntVector();
	
	            // Do a linear search for isoCode. At the same time,
	            // record the position of the DEFAULT meta data. If the
	            // meta data becomes large, make this faster.
	            /*
	             * for (int j=0; j<currencyMeta.length; ++j) { Object[] row =
	             * currencyMeta[j]; String s = (String) row[0]; int c =
	             * isoCode.compareToIgnoreCase(s); if (c == 0) { i = (Integer[])
	             * row[1]; break; } if ("DEFAULT".equalsIgnoreCase(s)) { defaultPos
	             * = j; } if (c < 0 && defaultPos >= 0) { break; } }
	             */
	            if (i == null) {
	                i = currencyMeta.Get("DEFAULT").GetIntVector();
	            }
	
	            if (i != null && i.Length >= 2) {
	                return i;
	            }
	        } catch (MissingManifestResourceException e) {
	        }
	
	        // Config/build error; return hard-coded defaults
	        return LAST_RESORT_DATA;
	    }
	
	    // Default currency meta data of last resort. We try to use the
	    // defaults encoded in the meta data resource bundle. If there is a
	    // configuration/build error and these are not available, we use these
	    // hard-coded defaults (which should be identical).
	    private static readonly int[] LAST_RESORT_DATA = new int[] { 2, 0 };
	
	    // POW10[i] = 10^i
	    private static readonly int[] POW10 = { 1, 10, 100, 1000, 10000, 100000,
	            1000000, 10000000, 100000000, 1000000000 };
	
	    // -------- BEGIN ULocale boilerplate --------
	
	    /// <summary>
	    /// Return the locale that was used to create this object, or null. This may
	    /// may differ from the locale requested at the time of this object's
	    /// creation. For example, if an object is created for locale
	    /// <tt>en_US_CALIFORNIA</tt>, the actual data may be drawn from <tt>en</tt>
	    /// (the <i>actual</i> locale), and <tt>en_US</tt> may be the most specific
	    /// locale that exists (the <i>valid</i> locale).
	    /// <p>
	    /// Note: This method will be obsoleted. The implementation is no longer
	    /// locale-specific and so there is no longer a valid or actual locale
	    /// associated with the Currency object. Until it is removed, this method
	    /// will return the root locale.
	    /// </summary>
	    ///
	    /// <param name="type">type of information requested, either<see cref="M:IBM.ICU.Util.ULocale.VALID_LOCALE"/> or<see cref="M:IBM.ICU.Util.ULocale.ACTUAL_LOCALE"/>.</param>
	    /// <returns>the information specified by <i>type</i>, or null if this object
	    /// was not constructed from locale data.</returns>
	    /// <seealso cref="T:IBM.ICU.Util.ULocale"/>
	    /// <seealso cref="M:IBM.ICU.Util.ULocale.VALID_LOCALE"/>
	    /// <seealso cref="M:IBM.ICU.Util.ULocale.ACTUAL_LOCALE"/>
	    /// @obsolete ICU 3.2 to be removed
	    public ULocale GetLocale(ULocale.Type type) {
	        return IBM.ICU.Util.ULocale.ROOT;
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Set information about the locales that were used to create this object.
	    /// If the object was not constructed from locale data, both arguments should
	    /// be set to null. Otherwise, neither should be null. The actual locale must
	    /// be at the same level or less specific than the valid locale. This method
	    /// is intended for use by factories or other entities that create objects of
	    /// this class.
	    /// </summary>
	    ///
	    /// <param name="valid">the most specific locale containing any resource data, or null</param>
	    /// <param name="actual">the locale containing data used to construct this object, ornull</param>
	    /// <seealso cref="T:IBM.ICU.Util.ULocale"/>
	    /// <seealso cref="M:IBM.ICU.Util.ULocale.VALID_LOCALE"/>
	    /// <seealso cref="M:IBM.ICU.Util.ULocale.ACTUAL_LOCALE"/>
	    internal void SetLocale(ULocale valid, ULocale actual) {
	        // Change the following to an assertion later
	        if ((valid == null) != (actual == null)) {
	            // /CLOVER:OFF
	            throw new ArgumentException();
	            // /CLOVER:ON
	        }
	        // Another check we could do is that the actual locale is at
	        // the same level or less specific than the valid locale.
	        this.validLocale = valid;
	        this.actualLocale = actual;
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// The most specific locale containing any resource data, or null.
	    /// </summary>
	    ///
	    /// <seealso cref="T:IBM.ICU.Util.ULocale"/>
	    private ULocale validLocale;
	
	    /// <exclude/>
	    /// <summary>
	    /// The locale containing data used to construct this object, or null.
	    /// </summary>
	    ///
	    /// <seealso cref="T:IBM.ICU.Util.ULocale"/>
	    private ULocale actualLocale;
	
	    // -------- END ULocale boilerplate --------
	}
	
	// eof
}
