// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:47 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 1996-2006, International Business Machines Corporation and    
/// others. All Rights Reserved.                                                
/// </summary>
///
namespace IBM.ICU.Util {
	
	using IBM.ICU.Text;
	using ILOG.J2CsMapping.Collections;
	using ILOG.J2CsMapping.Collections.Generics;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	
	/// <summary>
	/// <p>
	/// The string tokenizer class allows an application to break a string into
	/// tokens by performing code point comparison. The <c>StringTokenizer</c>
	/// methods do not distinguish among identifiers, numbers, and quoted strings,
	/// nor do they recognize and skip comments.
	/// </p>
	/// <p>
	/// The set of delimiters (the codepoints that separate tokens) may be specified
	/// either at creation time or on a per-token basis.
	/// </p>
	/// <p>
	/// An instance of <c>StringTokenizer</c> behaves in one of three ways,
	/// depending on whether it was created with the <c>returnDelims</c> and
	/// <c>coalesceDelims</c> flags having the value <c>true</c> or
	/// <c>false</c>:
	/// <ul>
	/// <li>If returnDelims is <c>false</c>, delimiter code points serve to
	/// separate tokens. A token is a maximal sequence of consecutive code points
	/// that are not delimiters.
	/// <li>If returnDelims is <c>true</c>, delimiter code points are
	/// themselves considered to be tokens. In this case, if coalesceDelims is
	/// <c>true</c>, such tokens will be the maximal sequence of consecutive
	/// code points that <em>are</em> delimiters. If coalesceDelims is false, a token
	/// will be received for each delimiter code point.
	/// </ul>
	/// <p>
	/// A token is thus either one delimiter code point, a maximal sequence of
	/// consecutive code points that are delimiters, or a maximal sequence of
	/// consecutive code points that are not delimiters.
	/// </p>
	/// <p>
	/// A <tt>StringTokenizer</tt> object internally maintains a current position
	/// within the string to be tokenized. Some operations advance this current
	/// position past the code point processed.
	/// </p>
	/// <p>
	/// A token is returned by taking a substring of the string that was used to
	/// create the <tt>StringTokenizer</tt> object.
	/// </p>
	/// <p>
	/// Example of the use of the default delimiter tokenizer. <blockquote>
	/// <pre>
	/// StringTokenizer st = new StringTokenizer(&quot;this is a test&quot;);
	/// while (st.hasMoreTokens()) {
	/// println(st.nextToken());
	/// }
	/// </pre>
	/// </blockquote>
	/// </p>
	/// <p>
	/// prints the following output: <blockquote>
	/// <pre>
	/// this
	/// is
	/// a
	/// test
	/// </pre>
	/// </blockquote>
	/// </p>
	/// <p>
	/// Example of the use of the tokenizer with user specified delimiter.
	/// <blockquote>
	/// <pre>
	/// StringTokenizer st = new StringTokenizer(
	/// &quot;this is a test with supplementary characters \ud800\ud800\udc00\udc00&quot;,
	/// &quot; \ud800\udc00&quot;);
	/// while (st.hasMoreTokens()) {
	/// println(st.nextToken());
	/// }
	/// </pre>
	/// </blockquote>
	/// </p>
	/// <p>
	/// prints the following output: <blockquote>
	/// <pre>
	/// this
	/// is
	/// a
	/// test
	/// with
	/// supplementary
	/// characters
	/// &#92;ud800
	/// &#92;udc00
	/// </pre>
	/// </blockquote>
	/// </p>
	/// </summary>
	///
	/// @stable ICU 2.4
	public sealed class StringTokenizer : IIterator {
	    // public constructors ---------------------------------------------
	
	    /// <summary>
	    /// <p>
	    /// Constructs a string tokenizer for the specified string. All characters in
	    /// the delim argument are the delimiters for separating tokens.
	    /// </p>
	    /// <p>
	    /// If the returnDelims flag is false, the delimiter characters are skipped
	    /// and only serve as separators between tokens.
	    /// </p>
	    /// <p>
	    /// If the returnDelims flag is true, then the delimiter characters are also
	    /// returned as tokens, one per delimiter.
	    /// </summary>
	    ///
	    /// <param name="str">a string to be parsed.</param>
	    /// <param name="delim">the delimiters.</param>
	    /// <param name="returndelims">flag indicating whether to return the delimiters as tokens.</param>
	    /// <exception cref=" throws a NullPointerException if str is null"></exception>
	    /// @stable ICU 2.4
	    public StringTokenizer(String str, UnicodeSet delim, bool returndelims) : this(str, delim, returndelims, false) {
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// <p>
	    /// Constructs a string tokenizer for the specified string. All characters in
	    /// the delim argument are the delimiters for separating tokens.
	    /// </p>
	    /// <p>
	    /// If the returnDelims flag is false, the delimiter characters are skipped
	    /// and only serve as separators between tokens.
	    /// </p>
	    /// <p>
	    /// If the returnDelims flag is true, then the delimiter characters are also
	    /// returned as tokens. If coalescedelims is true, one token is returned for
	    /// each run of delimiter characters, otherwise one token is returned per
	    /// delimiter. Since surrogate pairs can be delimiters, the returned token
	    /// might be two chars in length.
	    /// </p>
	    /// </summary>
	    ///
	    /// <param name="str">a string to be parsed.</param>
	    /// <param name="delim">the delimiters.</param>
	    /// <param name="returndelims">flag indicating whether to return the delimiters as tokens.</param>
	    /// <param name="coalescedelims">flag indicating whether to return a run of delimiters as asingle token or as one token per delimiter. This only takeseffect if returndelims is true.</param>
	    /// <exception cref=" throws a NullPointerException if str is null"></exception>
	    public StringTokenizer(String str, UnicodeSet delim, bool returndelims,
	            bool coalescedelims) {
	        m_source_ = str;
	        m_length_ = str.Length;
	        if (delim == null) {
	            m_delimiters_ = EMPTY_DELIMITER_;
	        } else {
	            m_delimiters_ = delim;
	        }
	        m_returnDelimiters_ = returndelims;
	        m_coalesceDelimiters_ = coalescedelims;
	        m_tokenOffset_ = -1;
	        m_tokenSize_ = -1;
	        if (m_length_ == 0) {
	            // string length 0, no tokens
	            m_nextOffset_ = -1;
	        } else {
	            m_nextOffset_ = 0;
	            if (!returndelims) {
	                m_nextOffset_ = GetNextNonDelimiter(0);
	            }
	        }
	    }
	
	    /// <summary>
	    /// <p>
	    /// Constructs a string tokenizer for the specified string. The characters in
	    /// the delim argument are the delimiters for separating tokens.
	    /// </p>
	    /// <p>
	    /// Delimiter characters themselves will not be treated as tokens.
	    /// </p>
	    /// </summary>
	    ///
	    /// <param name="str">a string to be parsed.</param>
	    /// <param name="delim">the delimiters.</param>
	    /// <exception cref=" throws a NullPointerException if str is null"></exception>
	    /// @stable ICU 2.4
	    public StringTokenizer(String str, UnicodeSet delim) : this(str, delim, false, false) {
	    }
	
	    /// <summary>
	    /// <p>
	    /// Constructs a string tokenizer for the specified string. All characters in
	    /// the delim argument are the delimiters for separating tokens.
	    /// </p>
	    /// <p>
	    /// If the returnDelims flag is false, the delimiter characters are skipped
	    /// and only serve as separators between tokens.
	    /// </p>
	    /// <p>
	    /// If the returnDelims flag is true, then the delimiter characters are also
	    /// returned as tokens, one per delimiter.
	    /// </summary>
	    ///
	    /// <param name="str">a string to be parsed.</param>
	    /// <param name="delim">the delimiters.</param>
	    /// <param name="returndelims">flag indicating whether to return the delimiters as tokens.</param>
	    /// <exception cref=" throws a NullPointerException if str is null"></exception>
	    /// @stable ICU 2.4
	    public StringTokenizer(String str, String delim, bool returndelims) : this(str, delim, returndelims, false) {
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// <p>
	    /// Constructs a string tokenizer for the specified string. All characters in
	    /// the delim argument are the delimiters for separating tokens.
	    /// </p>
	    /// <p>
	    /// If the returnDelims flag is false, the delimiter characters are skipped
	    /// and only serve as separators between tokens.
	    /// </p>
	    /// <p>
	    /// If the returnDelims flag is true, then the delimiter characters are also
	    /// returned as tokens. If coalescedelims is true, one token is returned for
	    /// each run of delimiter characters, otherwise one token is returned per
	    /// delimiter. Since surrogate pairs can be delimiters, the returned token
	    /// might be two chars in length.
	    /// </p>
	    /// </summary>
	    ///
	    /// <param name="str">a string to be parsed.</param>
	    /// <param name="delim">the delimiters.</param>
	    /// <param name="returndelims">flag indicating whether to return the delimiters as tokens.</param>
	    /// <param name="coalescedelims">flag indicating whether to return a run of delimiters as asingle token or as one token per delimiter. This only takeseffect if returndelims is true.</param>
	    /// <exception cref=" throws a NullPointerException if str is null"></exception>
	    public StringTokenizer(String str, String delim, bool returndelims,
	            bool coalescedelims) {
	        // don't ignore whitespace
	        m_delimiters_ = EMPTY_DELIMITER_;
	        if (delim != null && delim.Length > 0) {
	            m_delimiters_ = new UnicodeSet();
	            m_delimiters_.AddAll(delim);
	            CheckDelimiters();
	        }
	        m_coalesceDelimiters_ = coalescedelims;
	        m_source_ = str;
	        m_length_ = str.Length;
	        m_returnDelimiters_ = returndelims;
	        m_tokenOffset_ = -1;
	        m_tokenSize_ = -1;
	        if (m_length_ == 0) {
	            // string length 0, no tokens
	            m_nextOffset_ = -1;
	        } else {
	            m_nextOffset_ = 0;
	            if (!returndelims) {
	                m_nextOffset_ = GetNextNonDelimiter(0);
	            }
	        }
	    }
	
	    /// <summary>
	    /// <p>
	    /// Constructs a string tokenizer for the specified string. The characters in
	    /// the delim argument are the delimiters for separating tokens.
	    /// </p>
	    /// <p>
	    /// Delimiter characters themselves will not be treated as tokens.
	    /// </p>
	    /// </summary>
	    ///
	    /// <param name="str">a string to be parsed.</param>
	    /// <param name="delim">the delimiters.</param>
	    /// <exception cref=" throws a NullPointerException if str is null"></exception>
	    /// @stable ICU 2.4
	    public StringTokenizer(String str, String delim) : this(str, delim, false, false) {
	    }
	
	    /// <summary>
	    /// <p>
	    /// Constructs a string tokenizer for the specified string. The tokenizer
	    /// uses the default delimiter set, which is " &#92;t&#92;n&#92;r&#92;f": the
	    /// space character, the tab character, the newline character, the
	    /// carriage-return character, and the form-feed character.
	    /// </p>
	    /// <p>
	    /// Delimiter characters themselves will not be treated as tokens.
	    /// </p>
	    /// </summary>
	    ///
	    /// <param name="str">a string to be parsed</param>
	    /// <exception cref=" throws a NullPointerException if str is null"></exception>
	    /// @stable ICU 2.4
	    public StringTokenizer(String str) : this(str, DEFAULT_DELIMITERS_, false, false) {
	    }
	
	    // public methods --------------------------------------------------
	
	    /// <summary>
	    /// Tests if there are more tokens available from this tokenizer's string. If
	    /// this method returns <tt>true</tt>, then a subsequent call to
	    /// <tt>nextToken</tt> with no argument will successfully return a token.
	    /// </summary>
	    ///
	    /// <returns><c>true</c> if and only if there is at least one token in
	    /// the string after the current position; <c>false</c>
	    /// otherwise.</returns>
	    /// @stable ICU 2.4
	    public bool HasMoreTokens() {
	        return m_nextOffset_ >= 0;
	    }
	
	    /// <summary>
	    /// Returns the next token from this string tokenizer.
	    /// </summary>
	    ///
	    /// <returns>the next token from this string tokenizer.</returns>
	    /// <exception cref="NoSuchElementException">if there are no more tokens in this tokenizer's string.</exception>
	    /// @stable ICU 2.4
	    public String NextToken() {
	        if (m_tokenOffset_ < 0) {
	            if (m_nextOffset_ < 0) {
	                throw new InvalidOperationException("No more tokens in String");
	            }
	            // pre-calculations of tokens not done
	            if (m_returnDelimiters_) {
	                int tokenlimit = 0;
	                int c = IBM.ICU.Text.UTF16.CharAt(m_source_, m_nextOffset_);
	                bool contains = (delims == null) ? m_delimiters_.Contains(c)
	                        : c < delims.Length && delims[c];
	                if (contains) {
	                    if (m_coalesceDelimiters_) {
	                        tokenlimit = GetNextNonDelimiter(m_nextOffset_);
	                    } else {
	                        tokenlimit = m_nextOffset_ + IBM.ICU.Text.UTF16.GetCharCount(c);
	                        if (tokenlimit == m_length_) {
	                            tokenlimit = -1;
	                        }
	                    }
	                } else {
	                    tokenlimit = GetNextDelimiter(m_nextOffset_);
	                }
	                String result;
	                if (tokenlimit < 0) {
	                    result = m_source_.Substring(m_nextOffset_);
	                } else {
	                    result = m_source_.Substring(m_nextOffset_,(tokenlimit)-(m_nextOffset_));
	                }
	                m_nextOffset_ = tokenlimit;
	                return result;
	            } else {
	                int tokenlimit_0 = GetNextDelimiter(m_nextOffset_);
	                String result_1;
	                if (tokenlimit_0 < 0) {
	                    result_1 = m_source_.Substring(m_nextOffset_);
	                    m_nextOffset_ = tokenlimit_0;
	                } else {
	                    result_1 = m_source_.Substring(m_nextOffset_,(tokenlimit_0)-(m_nextOffset_));
	                    m_nextOffset_ = GetNextNonDelimiter(tokenlimit_0);
	                }
	
	                return result_1;
	            }
	        }
	        // count was called before and we have all the tokens
	        if (m_tokenOffset_ >= m_tokenSize_) {
	            throw new InvalidOperationException("No more tokens in String");
	        }
	        String result_2;
	        if (m_tokenLimit_[m_tokenOffset_] >= 0) {
	            result_2 = m_source_.Substring(m_tokenStart_[m_tokenOffset_],(m_tokenLimit_[m_tokenOffset_])-(m_tokenStart_[m_tokenOffset_]));
	        } else {
	            result_2 = m_source_.Substring(m_tokenStart_[m_tokenOffset_]);
	        }
	        m_tokenOffset_++;
	        m_nextOffset_ = -1;
	        if (m_tokenOffset_ < m_tokenSize_) {
	            m_nextOffset_ = m_tokenStart_[m_tokenOffset_];
	        }
	        return result_2;
	    }
	
	    /// <summary>
	    /// Returns the next token in this string tokenizer's string. First, the set
	    /// of characters considered to be delimiters by this
	    /// <tt>StringTokenizer</tt> object is changed to be the characters in the
	    /// string <tt>delim</tt>. Then the next token in the string after the
	    /// current position is returned. The current position is advanced beyond the
	    /// recognized token. The new delimiter set remains the default after this
	    /// call.
	    /// </summary>
	    ///
	    /// <param name="delim">the new delimiters.</param>
	    /// <returns>the next token, after switching to the new delimiter set.</returns>
	    /// <exception cref="NoSuchElementException">if there are no more tokens in this tokenizer's string.</exception>
	    /// @stable ICU 2.4
	    public String NextToken(String delim) {
	        m_delimiters_ = EMPTY_DELIMITER_;
	        if (delim != null && delim.Length > 0) {
	            m_delimiters_ = new UnicodeSet();
	            m_delimiters_.AddAll(delim);
	        }
	        return NextToken(m_delimiters_);
	    }
	
	    /// <summary>
	    /// Returns the next token in this string tokenizer's string. First, the set
	    /// of characters considered to be delimiters by this
	    /// <tt>StringTokenizer</tt> object is changed to be the characters in the
	    /// string <tt>delim</tt>. Then the next token in the string after the
	    /// current position is returned. The current position is advanced beyond the
	    /// recognized token. The new delimiter set remains the default after this
	    /// call.
	    /// </summary>
	    ///
	    /// <param name="delim">the new delimiters.</param>
	    /// <returns>the next token, after switching to the new delimiter set.</returns>
	    /// <exception cref="NoSuchElementException">if there are no more tokens in this tokenizer's string.</exception>
	    /// @stable ICU 2.4
	    public String NextToken(UnicodeSet delim) {
	        m_delimiters_ = delim;
	        CheckDelimiters();
	        m_tokenOffset_ = -1;
	        m_tokenSize_ = -1;
	        if (!m_returnDelimiters_) {
	            m_nextOffset_ = GetNextNonDelimiter(m_nextOffset_);
	        }
	        return NextToken();
	    }
	
	    /// <summary>
	    /// Returns the same value as the <c>hasMoreTokens</c> method. It
	    /// exists so that this class can implement the <c>Enumeration</c>
	    /// interface.
	    /// </summary>
	    ///
	    /// <returns><c>true</c> if there are more tokens; <c>false</c>
	    /// otherwise.</returns>
	    /// <seealso cref="M:IBM.ICU.Util.StringTokenizer.HasMoreTokens"/>
	    /// @stable ICU 2.4
	    public bool HasNext() {
	        return HasMoreTokens();
	    }
	
	    /// <summary>
	    /// Returns the same value as the <c>nextToken</c> method, except that
	    /// its declared return value is <c>Object</c> rather than
	    /// <c>String</c>. It exists so that this class can implement the
	    /// <c>Enumeration</c> interface.
	    /// </summary>
	    ///
	    /// <returns>the next token in the string.</returns>
	    /// <exception cref="NoSuchElementException">if there are no more tokens in this tokenizer's string.</exception>
	    /// <seealso cref="M:IBM.ICU.Util.StringTokenizer.NextToken"/>
	    /// @stable ICU 2.4
	    public Object NextElement() {
	        return NextToken();
	    }
	
	    /// <summary>
	    /// Calculates the number of times that this tokenizer's
	    /// <c>nextToken</c> method can be called before it generates an
	    /// exception. The current position is not advanced.
	    /// </summary>
	    ///
	    /// <returns>the number of tokens remaining in the string using the current
	    /// delimiter set.</returns>
	    /// <seealso cref="M:IBM.ICU.Util.StringTokenizer.NextToken"/>
	    /// @stable ICU 2.4
	    public int CountTokens() {
	        int result = 0;
	        if (HasMoreTokens()) {
	            if (m_tokenOffset_ >= 0) {
	                return m_tokenSize_ - m_tokenOffset_;
	            }
	            if (m_tokenStart_ == null) {
	                m_tokenStart_ = new int[TOKEN_SIZE_];
	                m_tokenLimit_ = new int[TOKEN_SIZE_];
	            }
	            do {
	                if (m_tokenStart_.Length == result) {
	                    int[] temptokenindex = m_tokenStart_;
	                    int[] temptokensize = m_tokenLimit_;
	                    int originalsize = temptokenindex.Length;
	                    int newsize = originalsize + TOKEN_SIZE_;
	                    m_tokenStart_ = new int[newsize];
	                    m_tokenLimit_ = new int[newsize];
	                    System.Array.Copy((Array)(temptokenindex),0,(Array)(m_tokenStart_),0,originalsize);
	                    System.Array.Copy((Array)(temptokensize),0,(Array)(m_tokenLimit_),0,originalsize);
	                }
	                m_tokenStart_[result] = m_nextOffset_;
	                if (m_returnDelimiters_) {
	                    int c = IBM.ICU.Text.UTF16.CharAt(m_source_, m_nextOffset_);
	                    bool contains = (delims == null) ? m_delimiters_
	                            .Contains(c) : c < delims.Length && delims[c];
	                    if (contains) {
	                        if (m_coalesceDelimiters_) {
	                            m_tokenLimit_[result] = GetNextNonDelimiter(m_nextOffset_);
	                        } else {
	                            int p = m_nextOffset_ + 1;
	                            if (p == m_length_) {
	                                p = -1;
	                            }
	                            m_tokenLimit_[result] = p;
	
	                        }
	                    } else {
	                        m_tokenLimit_[result] = GetNextDelimiter(m_nextOffset_);
	                    }
	                    m_nextOffset_ = m_tokenLimit_[result];
	                } else {
	                    m_tokenLimit_[result] = GetNextDelimiter(m_nextOffset_);
	                    m_nextOffset_ = GetNextNonDelimiter(m_tokenLimit_[result]);
	                }
	                result++;
	            } while (m_nextOffset_ >= 0);
	            m_tokenOffset_ = 0;
	            m_tokenSize_ = result;
	            m_nextOffset_ = m_tokenStart_[0];
	        }
	        return result;
	    }
	
	    // private data members -------------------------------------------------
	
	    /// <summary>
	    /// Current offset to the token array. If the array token is not set up yet,
	    /// this value is a -1
	    /// </summary>
	    ///
	    private int m_tokenOffset_;
	
	    /// <summary>
	    /// Size of the token array. If the array token is not set up yet, this value
	    /// is a -1
	    /// </summary>
	    ///
	    private int m_tokenSize_;
	
	    /// <summary>
	    /// Array of pre-calculated tokens start indexes in source string terminated by -1. This is only set up during countTokens() and only stores the remaining tokens, not all tokens including parsed ones
	    /// </summary>
	    ///
	    private int[] m_tokenStart_;
	
	    /// <summary>
	    /// Array of pre-calculated tokens limit indexes in source string. This is only set up during countTokens() and only stores the remaining tokens, not all tokens including parsed ones
	    /// </summary>
	    ///
	    private int[] m_tokenLimit_;
	
	    /// <summary>
	    /// UnicodeSet containing delimiters
	    /// </summary>
	    ///
	    private UnicodeSet m_delimiters_;
	
	    /// <summary>
	    /// String to parse for tokens
	    /// </summary>
	    ///
	    private String m_source_;
	
	    /// <summary>
	    /// Length of m_source_
	    /// </summary>
	    ///
	    private int m_length_;
	
	    /// <summary>
	    /// Current position in string to parse for tokens
	    /// </summary>
	    ///
	    private int m_nextOffset_;
	
	    /// <summary>
	    /// Flag indicator if delimiters are to be treated as tokens too
	    /// </summary>
	    ///
	    private bool m_returnDelimiters_;
	
	    /// <summary>
	    /// Flag indicating whether to coalesce runs of delimiters into single tokens
	    /// </summary>
	    ///
	    private bool m_coalesceDelimiters_;
	
	    /// <summary>
	    /// Default set of delimiters &#92;t&#92;n&#92;r&#92;f
	    /// </summary>
	    ///
	    private static readonly UnicodeSet DEFAULT_DELIMITERS_ = new UnicodeSet(
	            "[ \t\n\r\f]", false);
	
	    /// <summary>
	    /// Array size increments
	    /// </summary>
	    ///
	    private const int TOKEN_SIZE_ = 100;
	
	    /// <summary>
	    /// A empty delimiter UnicodeSet, used when user specified null delimiters
	    /// </summary>
	    ///
	    private static readonly UnicodeSet EMPTY_DELIMITER_ = new UnicodeSet();
	
	    // private methods ------------------------------------------------------
	
	    /// <summary>
	    /// Gets the index of the next delimiter after offset
	    /// </summary>
	    ///
	    /// <param name="offset">to the source string</param>
	    /// <returns>offset of the immediate next delimiter, otherwise (- source
	    /// string length - 1) if there are no more delimiters after
	    /// m_nextOffset</returns>
	    private int GetNextDelimiter(int offset) {
	        if (offset >= 0) {
	            int result = offset;
	            int c = 0;
	            if (delims == null) {
	                do {
	                    c = IBM.ICU.Text.UTF16.CharAt(m_source_, result);
	                    if (m_delimiters_.Contains(c)) {
	                        break;
	                    }
	                    result++;
	                } while (result < m_length_);
	            } else {
	                do {
	                    c = IBM.ICU.Text.UTF16.CharAt(m_source_, result);
	                    if (c < delims.Length && delims[c]) {
	                        break;
	                    }
	                    result++;
	                } while (result < m_length_);
	            }
	            if (result < m_length_) {
	                return result;
	            }
	        }
	        return -1 - m_length_;
	    }
	
	    /// <summary>
	    /// Gets the index of the next non-delimiter after m_nextOffset_
	    /// </summary>
	    ///
	    /// <param name="offset">to the source string</param>
	    /// <returns>offset of the immediate next non-delimiter, otherwise (- source
	    /// string length - 1) if there are no more delimiters after
	    /// m_nextOffset</returns>
	    private int GetNextNonDelimiter(int offset) {
	        if (offset >= 0) {
	            int result = offset;
	            int c = 0;
	            if (delims == null) {
	                do {
	                    c = IBM.ICU.Text.UTF16.CharAt(m_source_, result);
	                    if (!m_delimiters_.Contains(c)) {
	                        break;
	                    }
	                    result++;
	                } while (result < m_length_);
	            } else {
	                do {
	                    c = IBM.ICU.Text.UTF16.CharAt(m_source_, result);
	                    if (!(c < delims.Length && delims[c])) {
	                        break;
	                    }
	                    result++;
	                } while (result < m_length_);
	            }
	            if (result < m_length_) {
	                return result;
	            }
	        }
	        return -1 - m_length_;
	    }
	
	    internal void CheckDelimiters() {
	        if (m_delimiters_ == null || m_delimiters_.Size() == 0) {
	            delims = new bool[0];
	        } else {
	            int maxChar = m_delimiters_.GetRangeEnd(m_delimiters_
	                    .GetRangeCount() - 1);
	            if (maxChar < 0x7f) {
	                delims = new bool[maxChar + 1];
	                for (int i = 0, ch; -1 != (ch = m_delimiters_.CharAt(i)); ++i) {
	                    delims[ch] = true;
	                }
	            } else {
	                delims = null;
	            }
	        }
	    }
	
	    private bool[] delims;
	
		#region AddedByTranslator
	
		object ILOG.J2CsMapping.Collections.IIterator.Next()
	            {
	                //return this.Next();
                    throw new NotImplementedException();
	            }
	
		#endregion


        #region IIterator Members


        public void Remove()
        {
            throw new NotImplementedException();
        }

        #endregion
    }
}
