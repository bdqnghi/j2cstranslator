//##header J2SE15
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:30 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /*
 *******************************************************************************
 * Copyright (C) 2005-2007 International Business Machines Corporation and          *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 */
namespace IBM.ICU.Text {
	
	using ILOG.J2CsMapping.Text;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	
	/// <summary>
	/// Rule Based Break Iterator This is a port of the C++ class
	/// RuleBasedBreakIterator from ICU4C.
	/// </summary>
	///
	/// @stable ICU 2.0
	public class RuleBasedBreakIterator : BreakIterator {
	
	    // =======================================================================
	    // Constructors & Factories
	    // =======================================================================
	
	    /// <exclude/>
	    public RuleBasedBreakIterator() {
	        this.fText = new ILOG.J2CsMapping.Text.StringCharacterIterator("");
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Create a break iterator from a precompiled set of rules.
	    /// </summary>
	    ///
	    public static RuleBasedBreakIterator GetInstanceFromCompiledRules(
	            Stream mask0) {
	        RuleBasedBreakIterator This = new RuleBasedBreakIterator();
	        This.fRData = IBM.ICU.Text.RBBIDataWrapper.Get(mask0);
	        return This;
	    }
	
	    private RuleBasedBreakIterator(RuleBasedBreakIterator other) {
	        this.fText = new ILOG.J2CsMapping.Text.StringCharacterIterator("");
	        // TODO: check types.
	        fRData = other.fRData;
	        if (fText != null) {
	            // TODO: fText = (ICharacterIterator) (other.fText.Clone());
	        }
	    }
	
	    /// <summary>
	    /// Construct a RuleBasedBreakIterator from a set of rules supplied as a
	    /// string.
	    /// </summary>
	    ///
	    /// <param name="rules">The break rules to be used.</param>
	    /// @stable ICU 2.2
	    public RuleBasedBreakIterator(String rules) {
	        this.fText = new ILOG.J2CsMapping.Text.StringCharacterIterator("");
	        Init();
	        try {
	            MemoryStream ruleOS = new MemoryStream();
	            CompileRules(rules, ruleOS);
	            byte[] ruleBA = ruleOS.ToArray();
	            Stream ruleIS = new MemoryStream(ruleBA);
	            fRData = IBM.ICU.Text.RBBIDataWrapper.Get(ruleIS);
	        } catch (IOException e) {
	            // An IO exception can only arrive here if there is a bug in the
	            // RBBI Rule compiler,
	            // causing bogus compiled rules to be produced, but with no compile
	            // error raised.
	            // #if defined(FOUNDATION10) || defined(J2SE13)
	            // ## RuntimeException rte = new
	            // RuntimeException("RuleBasedBreakIterator rule compilation internal error:");
	            // #else
	            Exception rte = new Exception(
	                    "RuleBasedBreakIterator rule compilation internal error:",
	                    e);
	            // #endif
	            throw rte;
	        }
	    }
	
	    // =======================================================================
	    // Boilerplate
	    // =======================================================================
	
	    /// <summary>
	    /// Clones this iterator.
	    /// </summary>
	    ///
	    /// <returns>A newly-constructed RuleBasedBreakIterator with the same behavior
	    /// as this one.</returns>
	    /// @stable ICU 2.0
	    public override Object Clone() {
	        RuleBasedBreakIterator result = (RuleBasedBreakIterator) base.Clone();
	        if (fText != null) {
	            // TODO: result.fText = (ICharacterIterator) (fText.Clone());
	        }
	        return result;
	    }
	
	    /// <summary>
	    /// Returns true if both BreakIterators are of the same class, have the same
	    /// rules, and iterate over the same text.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public override bool Equals(Object that) {
	        try {
	            RuleBasedBreakIterator other = (RuleBasedBreakIterator) that;
	            if (fRData != other.fRData
	                    && (fRData == null || other.fRData == null)) {
	                return false;
	            }
	            if (fRData != null && other.fRData != null
	                    && (!fRData.fRuleSource.Equals(other.fRData.fRuleSource))) {
	                return false;
	            }
	            if (fText == null && other.fText == null) {
	                return true;
	            }
	            if (fText == null || other.fText == null) {
	                return false;
	            }
	            return fText.Equals(other.fText);
	        } catch (InvalidCastException e) {
	            return false;
	        }
	    }
	
	    /// <summary>
	    /// Returns the description (rules) used to create this iterator. (In ICU4C,
	    /// the same function is RuleBasedBreakIterator::getRules())
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public override String ToString() {
	        String retStr = null;
	        if (fRData != null) {
	            retStr = fRData.fRuleSource;
	        }
	        return retStr;
	    }
	
	    /// <summary>
	    /// Compute a hashcode for this BreakIterator
	    /// </summary>
	    ///
	    /// <returns>A hash code</returns>
	    /// @stable ICU 2.0
	    public override int GetHashCode() {
	        return fRData.fRuleSource.GetHashCode();
	    }
	
	    /// <summary>
	    /// Tag value for "words" that do not fit into any of other categories.
	    /// Includes spaces and most punctuation.
	    /// </summary>
	    ///
	    /// @draft ICU 3.0
	    /// @provisional This is a draft API and might change in a future release of
	    /// ICU.
	    public const int WORD_NONE = 0;
	
	    /// <summary>
	    /// Upper bound for tags for uncategorized words.
	    /// </summary>
	    ///
	    /// @draft ICU 3.0
	    /// @provisional This is a draft API and might change in a future release of
	    /// ICU.
	    public const int WORD_NONE_LIMIT = 100;
	
	    /// <summary>
	    /// Tag value for words that appear to be numbers, lower limit.
	    /// </summary>
	    ///
	    /// @draft ICU 3.0
	    /// @provisional This is a draft API and might change in a future release of
	    /// ICU.
	    public const int WORD_NUMBER = 100;
	
	    /// <summary>
	    /// Tag value for words that appear to be numbers, upper limit.
	    /// </summary>
	    ///
	    /// @draft ICU 3.0
	    /// @provisional This is a draft API and might change in a future release of
	    /// ICU.
	    public const int WORD_NUMBER_LIMIT = 200;
	
	    /// <summary>
	    /// Tag value for words that contain letters, excluding hiragana, katakana or
	    /// ideographic characters, lower limit.
	    /// </summary>
	    ///
	    /// @draft ICU 3.0
	    /// @provisional This is a draft API and might change in a future release of
	    /// ICU.
	    public const int WORD_LETTER = 200;
	
	    /// <summary>
	    /// Tag value for words containing letters, upper limit
	    /// </summary>
	    ///
	    /// @draft ICU 3.0
	    /// @provisional This is a draft API and might change in a future release of
	    /// ICU.
	    public const int WORD_LETTER_LIMIT = 300;
	
	    /// <summary>
	    /// Tag value for words containing kana characters, lower limit
	    /// </summary>
	    ///
	    /// @draft ICU 3.0
	    /// @provisional This is a draft API and might change in a future release of
	    /// ICU.
	    public const int WORD_KANA = 300;
	
	    /// <summary>
	    /// Tag value for words containing kana characters, upper limit
	    /// </summary>
	    ///
	    /// @draft ICU 3.0
	    /// @provisional This is a draft API and might change in a future release of
	    /// ICU.
	    public const int WORD_KANA_LIMIT = 400;
	
	    /// <summary>
	    /// Tag value for words containing ideographic characters, lower limit
	    /// </summary>
	    ///
	    /// @draft ICU 3.0
	    /// @provisional This is a draft API and might change in a future release of
	    /// ICU.
	    public const int WORD_IDEO = 400;
	
	    /// <summary>
	    /// Tag value for words containing ideographic characters, upper limit
	    /// </summary>
	    ///
	    /// @draft ICU 3.0
	    /// @provisional This is a draft API and might change in a future release of
	    /// ICU.
	    public const int WORD_IDEO_LIMIT = 500;
	
	    private const int START_STATE = 1; // The state number of the
	                                              // starting state
	
	    private const int STOP_STATE = 0; // The state-transition value
	                                             // indicating "stop"
	
	    // RBBIRunMode - the state machine runs an extra iteration at the beginning
	    // and end
	    // of user text. A variable with this enum type keeps track of where we
	    // are. The state machine only fetches user text input while in RUN mode.
	    private const int RBBI_START = 0;
	
	    private const int RBBI_RUN = 1;
	
	    private const int RBBI_END = 2;
	
	    /*
	     * The character iterator through which this BreakIterator accesses the
	     * text.
	     */
	    private ICharacterIterator fText;
	
	    /// <exclude/>
	    /// <summary>
	    /// The rule data for this BreakIterator instance
	    /// </summary>
	    ///
	    protected internal RBBIDataWrapper fRData;
	
	    /*
	     * Index of the Rule {tag} values for the most recent match.
	     */
	    private int fLastRuleStatusIndex;
	
	    /*
	     * Rule tag value valid flag. Some iterator operations don't intrinsically
	     * set the correct tag value. This flag lets us lazily compute the value if
	     * we are ever asked for it.
	     */
	    private bool fLastStatusIndexValid;
	
	    /// <exclude/>
	    /// <summary>
	    /// Counter for the number of characters encountered with the "dictionary"
	    /// flag set. Normal RBBI iterators don't use it, although the code for
	    /// updating it is live. Dictionary Based break iterators (a subclass of us)
	    /// access this field directly.
	    /// </summary>
	    ///
	    protected internal int fDictionaryCharCount;
	
	    /// <exclude/>
	    /// <summary>
	    /// Debugging flag. Trace operation of state machine when true.
	    /// </summary>
	    ///
	    public static bool fTrace;
	
	    /*
	     * ICU debug argument name for RBBI
	     */
	    private const String RBBI_DEBUG_ARG = "rbbi";
	
	    /// <exclude/>
	    /// <summary>
	    /// Dump the contents of the state table and character classes for this break
	    /// iterator. For debugging only.
	    /// </summary>
	    ///
	    public void Dump() {
	        this.fRData.Dump();
	    }
	
	    private static bool debugInitDone = false;
	
	    private void Init() {
	        fLastStatusIndexValid = true;
	        fDictionaryCharCount = 0;
	
	        if (debugInitDone == false) {
	            fTrace = IBM.ICU.Impl.ICUDebug.Enabled(RBBI_DEBUG_ARG)
	                    && IBM.ICU.Impl.ICUDebug.Value(RBBI_DEBUG_ARG).IndexOf("trace") >= 0;
	            debugInitDone = true;
	        }
	    }
	
	    private static void CompileRules(String rules, Stream ruleBinary) {
	        IBM.ICU.Text.RBBIRuleBuilder.CompileRules(rules, ruleBinary);
	    }
	
	    // =======================================================================
	    // BreakIterator overrides
	    // =======================================================================
	
	    /// <summary>
	    /// Sets the current iteration position to the beginning of the text. (i.e.,
	    /// the CharacterIterator's starting offset).
	    /// </summary>
	    ///
	    /// <returns>The offset of the beginning of the text.</returns>
	    /// @stable ICU 2.0
	    public override int First() {
	        fLastRuleStatusIndex = 0;
	        fLastStatusIndexValid = true;
	        if (fText == null) {
	            return IBM.ICU.Text.BreakIterator.DONE;
	        }
	        fText.First();
	        return fText.GetIndex();
	    }
	
	    /// <summary>
	    /// Sets the current iteration position to the end of the text. (i.e., the
	    /// CharacterIterator's ending offset).
	    /// </summary>
	    ///
	    /// <returns>The text's past-the-end offset.</returns>
	    /// @stable ICU 2.0
	    public override int Last() {
	        if (fText == null) {
	            fLastRuleStatusIndex = 0;
	            fLastStatusIndexValid = true;
	            return IBM.ICU.Text.BreakIterator.DONE;
	        }
	
	        // I'm not sure why, but t.last() returns the offset of the last
	        // character,
	        // rather than the past-the-end offset
	        //
	        // (It's so a loop like for(p=it.last(); p!=DONE; p=it.previous()) ...
	        // will work correctly.)
	
	        fLastStatusIndexValid = false;
	        int pos = fText.GetEndIndex();
	        fText.SetIndex(pos);
	        return pos;
	    }
	
	    /// <summary>
	    /// Advances the iterator either forward or backward the specified number of
	    /// steps. Negative values move backward, and positive values move forward.
	    /// This is equivalent to repeatedly calling next() or previous().
	    /// </summary>
	    ///
	    /// <param name="n">The number of steps to move. The sign indicates the direction(negative is backwards, and positive is forwards).</param>
	    /// <returns>The character offset of the boundary position n boundaries away
	    /// from the current one.</returns>
	    /// @stable ICU 2.0
	    public override int Next(int n) {
	        int result = Current();
	        while (n > 0) {
	            result = HandleNext();
	            --n;
	        }
	        while (n < 0) {
	            result = Previous();
	            ++n;
	        }
	        return result;
	    }
	
	    /// <summary>
	    /// Advances the iterator to the next boundary position.
	    /// </summary>
	    ///
	    /// <returns>The position of the first boundary after this one.</returns>
	    /// @stable ICU 2.0
	    public override int Next() {
	        return HandleNext();
	    }
	
	    /// <summary>
	    /// Moves the iterator backwards, to the last boundary preceding this one.
	    /// </summary>
	    ///
	    /// <returns>The position of the last boundary position preceding this one.</returns>
	    /// @stable ICU 2.0
	    public override int Previous() {
	        // if we're already sitting at the beginning of the text, return DONE
	        if (fText == null || Current() == fText.GetBeginIndex()) {
	            fLastRuleStatusIndex = 0;
	            fLastStatusIndexValid = true;
	            return IBM.ICU.Text.BreakIterator.DONE;
	        }
	
	        if (fRData.fSRTable != null || fRData.fSFTable != null) {
	            return HandlePrevious(fRData.fRTable);
	        }
	
	        // old rule syntax
	        // set things up. handlePrevious() will back us up to some valid
	        // break position before the current position (we back our internal
	        // iterator up one step to prevent handlePrevious() from returning
	        // the current position), but not necessarily the last one before
	        // where we started
	
	        int start = Current();
	
	        CIPrevious32(fText);
	        int lastResult = HandlePrevious(fRData.fRTable);
	        if (lastResult == IBM.ICU.Text.BreakIterator.DONE) {
	            lastResult = fText.GetBeginIndex();
	            fText.SetIndex(lastResult);
	        }
	        int result = lastResult;
	        int lastTag = 0;
	        bool breakTagValid = false;
	
	        // iterate forward from the known break position until we pass our
	        // starting point. The last break position before the starting
	        // point is our return value
	
	        for (;;) {
	            result = HandleNext();
	            if (result == IBM.ICU.Text.BreakIterator.DONE || result >= start) {
	                break;
	            }
	            lastResult = result;
	            lastTag = fLastRuleStatusIndex;
	            breakTagValid = true;
	        }
	
	        // fLastBreakTag wants to have the value for section of text preceding
	        // the result position that we are to return (in lastResult.) If
	        // the backwards rules overshot and the above loop had to do two or more
	        // handleNext()s to move up to the desired return position, we will have
	        // a valid
	        // tag value. But, if handlePrevious() took us to exactly the correct
	        // result positon,
	        // we wont have a tag value for that position, which is only set by
	        // handleNext().
	
	        // set the current iteration position to be the last break position
	        // before where we started, and then return that value
	        fText.SetIndex(lastResult);
	        fLastRuleStatusIndex = lastTag; // for use by getRuleStatus()
	        fLastStatusIndexValid = breakTagValid;
	        return lastResult;
	    }
	
	    /// <summary>
	    /// Sets the iterator to refer to the first boundary position following the
	    /// specified position.
	    /// </summary>
	    ///
	    /// <param name="offset">The position from which to begin searching for a breakposition.</param>
	    /// <returns>The position of the first break after the current position.</returns>
	    /// @stable ICU 2.0
	    public override int Following(int offset) {
	        // if the offset passed in is already past the end of the text,
	        // just return DONE; if it's before the beginning, return the
	        // text's starting offset
	        fLastRuleStatusIndex = 0;
	        fLastStatusIndexValid = true;
	        if (fText == null || offset >= fText.GetEndIndex()) {
	            Last();
	            return Next();
	        } else if (offset < fText.GetBeginIndex()) {
	            return First();
	        }
	
	        // otherwise, set our internal iteration position (temporarily)
	        // to the position passed in. If this is the _beginning_ position,
	        // then we can just use next() to get our return value
	
	        int result = 0;
	
	        if (fRData.fSRTable != null) {
	            // Safe Point Reverse rules exist.
	            // This allows us to use the optimum algorithm.
	            fText.SetIndex(offset);
	            // move forward one codepoint to prepare for moving back to a
	            // safe point.
	            // this handles offset being between a supplementary character
	            CINext32(fText);
	            // handlePrevious will move most of the time to < 1 boundary away
	            HandlePrevious(fRData.fSRTable);
	            result = Next();
	            while (result <= offset) {
	                result = Next();
	            }
	            return result;
	        }
	        if (fRData.fSFTable != null) {
	            // No Safe point reverse table, but there is a safe pt forward
	            // table.
	            //
	            fText.SetIndex(offset);
	            CIPrevious32(fText);
	            // handle next will give result >= offset
	            HandleNext(fRData.fSFTable);
	            // previous will give result 0 or 1 boundary away from offset,
	            // most of the time
	            // we have to
	            int oldresult = Previous();
	            while (oldresult > offset) {
	                result = Previous();
	                if (result <= offset) {
	                    return oldresult;
	                }
	                oldresult = result;
	            }
	            result = Next();
	            if (result <= offset) {
	                return Next();
	            }
	            return result;
	        }
	        // otherwise, we have to sync up first. Use handlePrevious() to back
	        // us up to a known break position before the specified position (if
	        // we can determine that the specified position is a break position,
	        // we don't back up at all). This may or may not be the last break
	        // position at or before our starting position. Advance forward
	        // from here until we've passed the starting position. The position
	        // we stop on will be the first break position after the specified one.
	        // old rule syntax
	
	        fText.SetIndex(offset);
	        if (offset == fText.GetBeginIndex()) {
	            return HandleNext();
	        }
	        result = Previous();
	
	        while (result != IBM.ICU.Text.BreakIterator.DONE && result <= offset) {
	            result = Next();
	        }
	
	        return result;
	    }
	
	    /// <summary>
	    /// Sets the iterator to refer to the last boundary position before the
	    /// specified position.
	    /// </summary>
	    ///
	    /// <param name="offset">The position to begin searching for a break from.</param>
	    /// <returns>The position of the last boundary before the starting position.</returns>
	    /// @stable ICU 2.0
	    public override int Preceding(int offset) {
	        // if the offset passed in is already past the end of the text,
	        // just return DONE; if it's before the beginning, return the
	
	        // text's starting offset
	        if (fText == null || offset > fText.GetEndIndex()) {
	            // return BreakIterator::DONE;
	            return Last();
	        } else if (offset < fText.GetBeginIndex()) {
	            return First();
	        }
	
	        // if we start by updating the current iteration position to the
	        // position specified by the caller, we can just use previous()
	        // to carry out this operation
	
	        int result;
	        if (fRData.fSFTable != null) {
	            // / todo synwee
	            // new rule syntax
	            fText.SetIndex(offset);
	            // move backwards one codepoint to prepare for moving forwards to a
	            // safe point.
	            // this handles offset being between a supplementary character
	            CIPrevious32(fText);
	            HandleNext(fRData.fSFTable);
	            result = Previous();
	            while (result >= offset) {
	                result = Previous();
	            }
	            return result;
	        }
	        if (fRData.fSRTable != null) {
	            // backup plan if forward safe table is not available
	            fText.SetIndex(offset);
	            CINext32(fText);
	            // handle previous will give result <= offset
	            HandlePrevious(fRData.fSRTable);
	
	            // next will give result 0 or 1 boundary away from offset,
	            // most of the time
	            // we have to
	            int oldresult = Next();
	            while (oldresult < offset) {
	                result = Next();
	                if (result >= offset) {
	                    return oldresult;
	                }
	                oldresult = result;
	            }
	            result = Previous();
	            if (result >= offset) {
	                return Previous();
	            }
	            return result;
	        }
	
	        // old rule syntax
	        fText.SetIndex(offset);
	        return Previous();
	    }
	
	    /// <summary>
	    /// Throw IllegalArgumentException unless begin <= offset < end.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    protected static internal void CheckOffset(int offset, ICharacterIterator text) {
	        if (offset < text.GetBeginIndex() || offset > text.GetEndIndex()) {
	            throw new ArgumentException("offset out of bounds");
	        }
	    }
	
	    /// <summary>
	    /// Returns true if the specfied position is a boundary position. As a side
	    /// effect, leaves the iterator pointing to the first boundary position at or
	    /// after "offset".
	    /// </summary>
	    ///
	    /// <param name="offset">the offset to check.</param>
	    /// <returns>True if "offset" is a boundary position.</returns>
	    /// @stable ICU 2.0
	    public override bool IsBoundary(int offset) {
	        CheckOffset(offset, fText);
	
	        // the beginning index of the iterator is always a boundary position by
	        // definition
	        if (offset == fText.GetBeginIndex()) {
	            First(); // For side effects on current position, tag values.
	            return true;
	        }
	
	        if (offset == fText.GetEndIndex()) {
	            Last(); // For side effects on current position, tag values.
	            return true;
	        }
	
	        // otherwise, we can use following() on the position before the
	        // specified
	        // one and return true if the position we get back is the one the user
	        // specified
	
	        // return following(offset - 1) == offset;
	        // TODO: check whether it is safe to revert to the simpler offset-1 code
	        // The safe rules may take care of unpaired surrogates ok.
	        fText.SetIndex(offset);
	        CIPrevious32(fText);
	        int pos = fText.GetIndex();
	        bool result = Following(pos) == offset;
	        return result;
	    }
	
	    /// <summary>
	    /// Returns the current iteration position.
	    /// </summary>
	    ///
	    /// <returns>The current iteration position.</returns>
	    /// @stable ICU 2.0
	    public override int Current() {
	        return (fText != null) ? fText.GetIndex() : IBM.ICU.Text.BreakIterator.DONE;
	    }
	
	    private void MakeRuleStatusValid() {
	        if (fLastStatusIndexValid == false) {
	            // No cached status is available.
	            if (fText == null || Current() == fText.GetBeginIndex()) {
	                // At start of text, or there is no text. Status is always zero.
	                fLastRuleStatusIndex = 0;
	                fLastStatusIndexValid = true;
	            } else {
	                // Not at start of text. Find status the tedious way.
	                int pa = Current();
	                Previous();
	                int pb = Next();
	                IBM.ICU.Impl.Assert.Assrt(pa == pb);
	            }
	            IBM.ICU.Impl.Assert.Assrt(fLastStatusIndexValid == true);
	            IBM.ICU.Impl.Assert.Assrt(fLastRuleStatusIndex >= 0
	                    && fLastRuleStatusIndex < fRData.fStatusTable.Length);
	        }
	    }
	
	    /// <summary>
	    /// Return the status tag from the break rule that determined the most
	    /// recently returned break position. The values appear in the rule source
	    /// within brackets, {123}, for example. For rules that do not specify a
	    /// status, a default value of 0 is returned. If more than one rule applies,
	    /// the numerically largest of the possible status values is returned.
	    /// <p>
	    /// Of the standard types of ICU break iterators, only the word break
	    /// iterator provides status values. The values are defined in class
	    /// RuleBasedBreakIterator, and allow distinguishing between words that
	    /// contain alphabetic letters, "words" that appear to be numbers,
	    /// punctuation and spaces, words containing ideographic characters, and
	    /// more. Call <c>getRuleStatus</c> after obtaining a boundary position
	    /// from <code>next()<code>, <c>previous()</c>, or any other break
	    /// iterator functions that returns a boundary position.
	    /// <p>
	    /// </summary>
	    ///
	    /// <returns>the status from the break rule that determined the most recently
	    /// returned break position.</returns>
	    /// @draft ICU 3.0
	    /// @provisional This is a draft API and might change in a future release of
	    /// ICU.
	
	    public virtual int GetRuleStatus() {
	        MakeRuleStatusValid();
	        // Status records have this form:
	        // Count N <-- fLastRuleStatusIndex points here.
	        // Status val 0
	        // Status val 1
	        // ...
	        // Status val N-1 <-- the value we need to return
	        // The status values are sorted in ascending order.
	        // This function returns the last (largest) of the array of status
	        // values.
	        int idx = fLastRuleStatusIndex
	                + fRData.fStatusTable[fLastRuleStatusIndex];
	        int tagVal = fRData.fStatusTable[idx];
	
	        return tagVal;
	    }
	
	    /// <summary>
	    /// Get the status (tag) values from the break rule(s) that determined the
	    /// most recently returned break position. The values appear in the rule
	    /// source within brackets, {123}, for example. The default status value for
	    /// rules that do not explicitly provide one is zero.
	    /// <p>
	    /// The status values used by the standard ICU break rules are defined as
	    /// public constants in class RuleBasedBreakIterator.
	    /// <p>
	    /// If the size of the output array is insufficient to hold the data, the
	    /// output will be truncated to the available length. No exception will be
	    /// thrown.
	    /// </summary>
	    ///
	    /// <param name="fillInArray">an array to be filled in with the status values.</param>
	    /// <returns>The number of rule status values from rules that determined the
	    /// most recent boundary returned by the break iterator. In the event
	    /// that the array is too small, the return value is the total number
	    /// of status values that were available, not the reduced number that
	    /// were actually returned.</returns>
	    /// @draft ICU 3.0
	    /// @provisional This is a draft API and might change in a future release of
	    /// ICU.
	    public virtual int GetRuleStatusVec(int[] fillInArray) {
	        MakeRuleStatusValid();
	        int numStatusVals = fRData.fStatusTable[fLastRuleStatusIndex];
	        if (fillInArray != null) {
	            int numToCopy = Math.Min(numStatusVals,fillInArray.Length);
	            for (int i = 0; i < numToCopy; i++) {
	                fillInArray[i] = fRData.fStatusTable[fLastRuleStatusIndex + i
	                        + 1];
	            }
	        }
	        return numStatusVals;
	    }
	
	    /// <summary>
	    /// Return a CharacterIterator over the text being analyzed. This version of
	    /// this method returns the actual CharacterIterator we're using internally.
	    /// Changing the state of this iterator can have undefined consequences. If
	    /// you need to change it, clone it first.
	    /// </summary>
	    ///
	    /// <returns>An iterator over the text being analyzed.</returns>
	    /// @stable ICU 2.0
	    public override ICharacterIterator GetText() {
	        return fText;
	    }
	
	    /// <summary>
	    /// Set the iterator to analyze a new piece of text. This function resets the
	    /// current iteration position to the beginning of the text.
	    /// </summary>
	    ///
	    /// <param name="newText">An iterator over the text to analyze.</param>
	    /// @stable ICU 2.0
	    public override void SetText(ICharacterIterator newText) {
	        fText = newText;
	        this.First();
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Control debug, trace and dump options.
	    /// </summary>
	    ///
	    protected static internal String fDebugEnv = (IBM.ICU.Impl.ICUDebug.Enabled(RBBI_DEBUG_ARG)) ? IBM.ICU.Impl.ICUDebug
	            .Value(RBBI_DEBUG_ARG) : null;
	
	    // 32 bit Char value returned from when an iterator has run out of range.
	    // Positive value so fast case (not end, not surrogate) can be checked
	    // with a single test.
	    private static int CI_DONE32 = 0x7fffffff;
	
	    /// <summary>
	    /// Move the iterator forward to the next code point, and return that code
	    /// point, leaving the iterator positioned at char returned. For
	    /// Supplementary chars, the iterator is left positioned at the lead
	    /// surrogate.
	    /// </summary>
	    ///
	    /// <param name="ci">The character iterator</param>
	    /// <returns>The next code point.</returns>
	    static internal int CINext32(ICharacterIterator ci) {
	        // If the current position is at a surrogate pair, move to the trail
	        // surrogate
	        // which leaves it in positon for underlying iterator's next() to work.
	        int c = ci.Current();
	        if (c >= IBM.ICU.Text.UTF16.LEAD_SURROGATE_MIN_VALUE
	                && c <= IBM.ICU.Text.UTF16.LEAD_SURROGATE_MAX_VALUE) {
	            c = ci.Next();
	            if (c < IBM.ICU.Text.UTF16.TRAIL_SURROGATE_MIN_VALUE
	                    || c > IBM.ICU.Text.UTF16.TRAIL_SURROGATE_MAX_VALUE) {
	                c = ci.Previous();
	            }
	        }
	
	        // For BMP chars, this next() is the real deal.
	        c = ci.Next();
	
	        // If we might have a lead surrogate, we need to peak ahead to get the
	        // trail
	        // even though we don't want to really be positioned there.
	        if (c >= IBM.ICU.Text.UTF16.LEAD_SURROGATE_MIN_VALUE) {
	            c = CINextTrail32(ci, c);
	        }
	
	        if (c >= IBM.ICU.Text.UTF16.SUPPLEMENTARY_MIN_VALUE && c != CI_DONE32) {
	            // We got a supplementary char. Back the iterator up to the postion
	            // of the lead surrogate.
	            ci.Previous();
	        }
	        return c;
	    }
	
	    // Out-of-line portion of the in-line Next32 code.
	    // The call site does an initial ci.next() and calls this function
	    // if the 16 bit value it gets is >= LEAD_SURROGATE_MIN_VALUE.
	    // NOTE: we leave the underlying char iterator positioned in the
	    // middle of a surroage pair. ci.next() will work correctly
	    // from there, but the ci.getIndex() will be wrong, and needs
	    // adjustment.
	    private static int CINextTrail32(ICharacterIterator ci, int lead) {
	        int retVal = lead;
	        if (lead <= IBM.ICU.Text.UTF16.LEAD_SURROGATE_MAX_VALUE) {
	            char cTrail = ci.Next();
	            if (IBM.ICU.Text.UTF16.IsTrailSurrogate(cTrail)) {
	                retVal = ((lead - IBM.ICU.Text.UTF16.LEAD_SURROGATE_MIN_VALUE) << 10)
	                        + (cTrail - IBM.ICU.Text.UTF16.TRAIL_SURROGATE_MIN_VALUE)
	                        + IBM.ICU.Text.UTF16.SUPPLEMENTARY_MIN_VALUE;
	            } else {
	                ci.Previous();
	            }
	        } else {
	            if (lead == ILOG.J2CsMapping.Text.CharacterIterator.Done
	                    && ci.GetIndex() >= ci.GetEndIndex()) {
	                retVal = CI_DONE32;
	            }
	        }
	        return retVal;
	    }
	
	    private static int CIPrevious32(ICharacterIterator ci) {
	        if (ci.GetIndex() <= ci.GetBeginIndex()) {
	            return CI_DONE32;
	        }
	        char trail = ci.Previous();
	        int retVal = trail;
	        if (IBM.ICU.Text.UTF16.IsTrailSurrogate(trail) && ci.GetIndex() > ci.GetBeginIndex()) {
	            char lead = ci.Previous();
	            if (IBM.ICU.Text.UTF16.IsLeadSurrogate(lead)) {
	                retVal = (((int) lead - IBM.ICU.Text.UTF16.LEAD_SURROGATE_MIN_VALUE) << 10)
	                        + ((int) trail - IBM.ICU.Text.UTF16.TRAIL_SURROGATE_MIN_VALUE)
	                        + IBM.ICU.Text.UTF16.SUPPLEMENTARY_MIN_VALUE;
	            } else {
	                ci.Next();
	            }
	        }
	        return retVal;
	    }
	
	    static internal int CICurrent32(ICharacterIterator ci) {
	        char lead = ci.Current();
	        int retVal = lead;
	        if (retVal < IBM.ICU.Text.UTF16.LEAD_SURROGATE_MIN_VALUE) {
	            return retVal;
	        }
	        if (IBM.ICU.Text.UTF16.IsLeadSurrogate(lead)) {
	            int trail = (int) ci.Next();
	            ci.Previous();
	            if (IBM.ICU.Text.UTF16.IsTrailSurrogate((char) trail)) {
	                retVal = ((lead - IBM.ICU.Text.UTF16.LEAD_SURROGATE_MIN_VALUE) << 10)
	                        + (trail - IBM.ICU.Text.UTF16.TRAIL_SURROGATE_MIN_VALUE)
	                        + IBM.ICU.Text.UTF16.SUPPLEMENTARY_MIN_VALUE;
	            }
	        } else {
	            if (lead == ILOG.J2CsMapping.Text.CharacterIterator.Done) {
	                if (ci.GetIndex() >= ci.GetEndIndex()) {
	                    retVal = CI_DONE32;
	                }
	            }
	        }
	        return retVal;
	    }
	
	    // -----------------------------------------------------------------------------------
	    //
	    // handleNext(void) All forward iteration vectors through this function.
	    // NOTE: This function is overridden by the dictionary base break iterator.
	    // User level API functions go to the dbbi implementation
	    // when the break iterator type is dbbi.
	    // The DBBI implementation sometimes explicitly calls back to here,
	    // its inherited handleNext().
	    //
	    // -----------------------------------------------------------------------------------
	    internal virtual int HandleNext() {
	        return HandleNext(fRData.fFTable);
	    }
	
	    /// <summary>
	    /// The State Machine Engine for moving forward is here. This function is the
	    /// heart of the RBBI run time engine.
	    /// </summary>
	    ///
	    /// <param name="stateTable"></param>
	    /// <returns>the new iterator position
	    /// A note on supplementary characters and the position of underlying
	    /// Java CharacterIterator: Normally, a character iterator is
	    /// positioned at the char most recently returned by next(). Within
	    /// this function, when a supplementary char is being processed, the
	    /// char iterator is left sitting on the trail surrogate, in the
	    /// middle of the code point. This is different from everywhere else,
	    /// where an iterator always points at the lead surrogate of a
	    /// supplementary.</returns>
	    private int HandleNext(short[] stateTable) {
	        int state;
	        short category = 0;
	        int mode;
	        int row;
	        int c;
	        int lookaheadStatus = 0;
	        int lookaheadTagIdx = 0;
	        int result = 0;
	        int initialPosition = 0;
	        int lookaheadResult = 0;
	        bool lookAheadHardBreak = (stateTable[IBM.ICU.Text.RBBIDataWrapper.FLAGS + 1] & IBM.ICU.Text.RBBIDataWrapper.RBBI_LOOKAHEAD_HARD_BREAK) != 0;
	
	        if (fTrace) {
	            System.Console.Out.WriteLine("Handle Next   pos      char  state category");
	        }
	
	        // No matter what, handleNext alway correctly sets the break tag value.
	        fLastStatusIndexValid = true;
	        fLastRuleStatusIndex = 0;
	
	        // if we're already at the end of the text, return DONE.
	        if (fText == null) {
	            fLastRuleStatusIndex = 0;
	            return IBM.ICU.Text.BreakIterator.DONE;
	        }
	
	        // Set up the starting char
	        initialPosition = fText.GetIndex();
	        result = initialPosition;
	        c = fText.Current();
	        if (c >= IBM.ICU.Text.UTF16.LEAD_SURROGATE_MIN_VALUE) {
	            c = CINextTrail32(fText, c);
	            if (c == CI_DONE32) {
	                fLastRuleStatusIndex = 0;
	                return IBM.ICU.Text.BreakIterator.DONE;
	            }
	        }
	
	        // Set the initial state for the state machine
	        state = START_STATE;
	        row = fRData.GetRowIndex(state);
	        category = 3;
	        mode = RBBI_RUN;
	        if ((stateTable[IBM.ICU.Text.RBBIDataWrapper.FLAGS + 1] & IBM.ICU.Text.RBBIDataWrapper.RBBI_BOF_REQUIRED) != 0) {
	            category = 2;
	            mode = RBBI_START;
	        }
	
	        // loop until we reach the end of the text or transition to state 0
	        while (state != STOP_STATE) {
	            if (c == CI_DONE32) {
	                // Reached end of input string.
	                if (mode == RBBI_END) {
	                    // We have already run the loop one last time with the
	                    // character set to the pseudo {eof} value. Now it is time
	                    // to unconditionally bail out.
	
	                    if (lookaheadResult > result) {
	                        // We ran off the end of the string with a pending
	                        // look-ahead match.
	                        // Treat this as if the look-ahead condition had been
	                        // met, and return
	                        // the match at the / position from the look-ahead rule.
	                        result = lookaheadResult;
	                        fLastRuleStatusIndex = lookaheadTagIdx;
	                        lookaheadStatus = 0;
	                    } else if (result == initialPosition) {
	                        // Ran off end, no match found.
	                        // move forward one
	                        fText.SetIndex(initialPosition);
	                        CINext32(fText);
	                    }
	                    break;
	                }
	                // Run the loop one last time with the fake end-of-input
	                // character category
	                mode = RBBI_END;
	                category = 1;
	            }
	
	            // Get the char category. An incoming category of 1 or 2 mens that
	            // we are preset for doing the beginning or end of input, and
	            // that we shouldn't get a category from an actual text input
	            // character.
	            //
	            if (mode == RBBI_RUN) {
	                // look up the current character's character category, which
	                // tells us
	                // which column in the state table to look at.
	                //
	                category = (short) fRData.fTrie.GetCodePointValue(c);
	
	                // Check the dictionary bit in the character's category.
	                // Counter is only used by dictionary based iterators
	                // (subclasses).
	                // Chars that need to be handled by a dictionary have a flag bit
	                // set
	                // in their category values.
	                //
	                if ((category & 0x4000) != 0) {
	                    fDictionaryCharCount++;
	                    // And off the dictionary flag bit.
	                    category &= ~0x4000;
	                }
	            }
	
	            if (fTrace) {
	                System.Console.Out.Write("            "
	                        + IBM.ICU.Text.RBBIDataWrapper.IntToString(fText.GetIndex(), 5));
	                System.Console.Out.Write(IBM.ICU.Text.RBBIDataWrapper.IntToHexString(c, 10));
	                System.Console.Out.WriteLine(IBM.ICU.Text.RBBIDataWrapper.IntToString(state, 7)
	                        + IBM.ICU.Text.RBBIDataWrapper.IntToString(category, 6));
	            }
	
	            // look up a state transition in the state table
	            // state = row->fNextState[category];
	            state = stateTable[row + IBM.ICU.Text.RBBIDataWrapper.NEXTSTATES + category];
	            row = fRData.GetRowIndex(state);
	
	            // Advance to the next character.
	            // If this is a beginning-of-input loop iteration, don't advance.
	            // The next iteration will be processing the first real input
	            // character.
	            if (mode == RBBI_RUN) {
	                c = (int) fText.Next();
	                if (c >= IBM.ICU.Text.UTF16.LEAD_SURROGATE_MIN_VALUE) {
	                    c = CINextTrail32(fText, c);
	                }
	            } else {
	                if (mode == RBBI_START) {
	                    mode = RBBI_RUN;
	                }
	            }
	
	            if (stateTable[row + IBM.ICU.Text.RBBIDataWrapper.ACCEPTING] == -1) {
	                // Match found, common case
	                result = fText.GetIndex();
	                if (c >= IBM.ICU.Text.UTF16.SUPPLEMENTARY_MIN_VALUE && c != CI_DONE32) {
	                    // The iterator has been left in the middle of a surrogate
	                    // pair.
	                    // We want the start of it.
	                    result--;
	                }
	
	                // Remember the break status (tag) values.
	                fLastRuleStatusIndex = stateTable[row + IBM.ICU.Text.RBBIDataWrapper.TAGIDX];
	            }
	
	            if (stateTable[row + IBM.ICU.Text.RBBIDataWrapper.LOOKAHEAD] != 0) {
	                if (lookaheadStatus != 0
	                        && stateTable[row + IBM.ICU.Text.RBBIDataWrapper.ACCEPTING] == lookaheadStatus) {
	                    // Lookahead match is completed. Set the result accordingly,
	                    // but only
	                    // if no other rule has matched further in the mean time.
	                    result = lookaheadResult;
	                    fLastRuleStatusIndex = lookaheadTagIdx;
	                    lookaheadStatus = 0;
	                    // TODO: make a standalone hard break in a rule work.
	                    if (lookAheadHardBreak) {
	                        return result;
	                    }
	                    // Look-ahead completed, but other rules may match further.
	                    // Continue on.
	                    // TODO: junk this feature? I don't think it's used
	                    // anywhere.
	                    continue;
	                }
	
	                lookaheadResult = fText.GetIndex();
	                if (c >= IBM.ICU.Text.UTF16.SUPPLEMENTARY_MIN_VALUE && c != CI_DONE32) {
	                    // The iterator has been left in the middle of a surrogate
	                    // pair.
	                    // We want the beginning of it.
	                    lookaheadResult--;
	                }
	                lookaheadStatus = stateTable[row + IBM.ICU.Text.RBBIDataWrapper.LOOKAHEAD];
	                lookaheadTagIdx = stateTable[row + IBM.ICU.Text.RBBIDataWrapper.TAGIDX];
	                continue;
	            }
	
	            if (stateTable[row + IBM.ICU.Text.RBBIDataWrapper.ACCEPTING] != 0) {
	                // Because this is an accepting state, any in-progress
	                // look-ahead match
	                // is no longer relavant. Clear out the pending lookahead
	                // status.
	                lookaheadStatus = 0;
	            }
	
	        } // End of state machine main loop
	
	        // The state machine is done. Check whether it found a match...
	
	        // If the iterator failed to advance in the match engine, force it ahead
	        // by one.
	        // (This really indicates a defect in the break rules. They should
	        // always match
	        // at least one character.)
	        if (result == initialPosition) {
	            result = fText.SetIndex(initialPosition);
	            CINext32(fText);
	            result = fText.GetIndex();
	        }
	
	        // Leave the iterator at our result position.
	        // (we may have advanced beyond the last accepting position chasing
	        // after
	        // longer matches that never completed.)
	        fText.SetIndex(result);
	        if (fTrace) {
	            System.Console.Out.WriteLine("result = " + result);
	        }
	        return result;
	    }
	
	    private int HandlePrevious(short[] stateTable) {
	        int state;
	        int category = 0;
	        int mode;
	        int row;
	        int c;
	        int lookaheadStatus = 0;
	        int result = 0;
	        int initialPosition = 0;
	        int lookaheadResult = 0;
	        bool lookAheadHardBreak = (stateTable[IBM.ICU.Text.RBBIDataWrapper.FLAGS + 1] & IBM.ICU.Text.RBBIDataWrapper.RBBI_LOOKAHEAD_HARD_BREAK) != 0;
	
	        if (fText == null || stateTable == null) {
	            return 0;
	        }
	        // handlePrevious() never gets the rule status.
	        // Flag the status as invalid; if the user ever asks for status, we will
	        // need
	        // to back up, then re-find the break position using handleNext(), which
	        // does
	        // get the status value.
	        fLastStatusIndexValid = false;
	        fLastRuleStatusIndex = 0;
	
	        // set up the starting char
	        initialPosition = fText.GetIndex();
	        result = initialPosition;
	        c = CIPrevious32(fText);
	
	        // Set up the initial state for the state machine
	        state = START_STATE;
	        row = fRData.GetRowIndex(state);
	        category = 3; // TODO: obsolete? from the old start/run mode scheme?
	        mode = RBBI_RUN;
	        if ((stateTable[IBM.ICU.Text.RBBIDataWrapper.FLAGS + 1] & IBM.ICU.Text.RBBIDataWrapper.RBBI_BOF_REQUIRED) != 0) {
	            category = 2;
	            mode = RBBI_START;
	        }
	
	        if (fTrace) {
	            System.Console.Out.WriteLine("Handle Prev   pos   char  state category ");
	        }
	
	        // loop until we reach the beginning of the text or transition to state
	        // 0
	        //
	        mainLoop: {
	            for (;;) {
	                innerBlock: {
	                    {
	                        if (c == CI_DONE32) {
	                            // Reached end of input string.
	                            if (mode == RBBI_END || fRData.fHeader.fVersion == 1) {
	                                // Either this is the old (ICU 3.2 and earlier) format
	                                // data which
	                                // does not support explicit support for matching {eof},
	                                // or
	                                // we have already done the {eof} iteration. Now is the
	                                // time
	                                // to unconditionally bail out.
	                                if (lookaheadResult < result) {
	                                    // We ran off the end of the string with a pending
	                                    // look-ahead match.
	                                    // Treat this as if the look-ahead condition had
	                                    // been met, and return
	                                    // the match at the / position from the look-ahead
	                                    // rule.
	                                    result = lookaheadResult;
	                                    lookaheadStatus = 0;
	                                } else if (result == initialPosition) {
	                                    // Ran off start, no match found.
	                                    // Move one position (towards the start, since we
	                                    // are doing previous.)
	                                    fText.SetIndex(initialPosition);
	                                    CIPrevious32(fText);
	                                }
	                                goto gotomainLoop;
	                            }
	                            mode = RBBI_END;
	                            category = 1;
	                        }
	
	                        if (mode == RBBI_RUN) {
	                            // look up the current character's category, which tells us
	                            // which column in the state table to look at.
	                            //
	                            category = (short) fRData.fTrie.GetCodePointValue(c);
	
	                            // Check the dictionary bit in the character's category.
	                            // Counter is only used by dictionary based iterators
	                            // (subclasses).
	                            // Chars that need to be handled by a dictionary have a flag
	                            // bit set
	                            // in their category values.
	                            //
	                            if ((category & 0x4000) != 0) {
	                                fDictionaryCharCount++;
	                                // And off the dictionary flag bit.
	                                category &= ~0x4000;
	                            }
	                        }
	
	                        if (fTrace) {
	                            System.Console.Out
	                                    .Write("             " + fText.GetIndex() + "   ");
	                            if (0x20 <= c && c < 0x7f) {
	                                System.Console.Out.Write("  " + c + "  ");
	                            } else {
	                                System.Console.Out.Write(" " + ILOG.J2CsMapping.Util.IlNumber.ToString(c,16) + " ");
	                            }
	                            System.Console.Out.WriteLine(" " + state + "  " + category + " ");
	                        }
	
	                        // State Transition - move machine to its next state
	                        //
	                        state = stateTable[row + IBM.ICU.Text.RBBIDataWrapper.NEXTSTATES + category];
	                        row = fRData.GetRowIndex(state);
	
	                        if (stateTable[row + IBM.ICU.Text.RBBIDataWrapper.ACCEPTING] == -1) {
	                            // Match found, common case, could have lookahead so we move
	                            // on to check it
	                            result = fText.GetIndex();
	                        }
	
	                        if (stateTable[row + IBM.ICU.Text.RBBIDataWrapper.LOOKAHEAD] != 0) {
	                            if (lookaheadStatus != 0
	                                    && stateTable[row + IBM.ICU.Text.RBBIDataWrapper.ACCEPTING] == lookaheadStatus) {
	                                // Lookahead match is completed. Set the result
	                                // accordingly, but only
	                                // if no other rule has matched further in the mean
	                                // time.
	                                result = lookaheadResult;
	                                lookaheadStatus = 0;
	                                // TODO: make a standalone hard break in a rule work.
	
	                                if (lookAheadHardBreak) {
	                                    goto gotomainLoop;
	                                }
	                                goto gotomainLoop;
	                            }
	                            // Hit a possible look-ahead match. We are at the
	                            // position of the '/'. Remember this position.
	                            lookaheadResult = fText.GetIndex();
	                            lookaheadStatus = stateTable[row
	                                    + IBM.ICU.Text.RBBIDataWrapper.LOOKAHEAD];
	                            goto gotomainLoop;
	                        }
	
	                        // not lookahead...
	                        if (stateTable[row + IBM.ICU.Text.RBBIDataWrapper.ACCEPTING] != 0) {
	                            // This is a plain (non-look-ahead) accepting state.
	                            if (!lookAheadHardBreak) {
	                                // Clear out any pending look-ahead matches,
	                                // but only if not doing the lookAheadHardBreak option
	                                // which needs to force a break no matter what is going
	                                // on with the rest of the match, i.e. we can't abandon
	                                // a partially completed look-ahead match because
	                                // some other rule matched further than the '/' position
	                                // in the look-ahead match.
	                                lookaheadStatus = 0;
	                            }
	                        }
	
	                    } // end of innerBlock. "break innerBlock" in above code comes out
	                      // here.
	                }
	                gotoinnerBlock:
	                ;
	
	                if (state == STOP_STATE) {
	                    goto gotomainLoop;
	                }
	
	                // then move iterator position backwards one character
	                //
	                if (mode == RBBI_RUN) {
	                    c = CIPrevious32(fText);
	                } else {
	                    if (mode == RBBI_START) {
	                        mode = RBBI_RUN;
	                    }
	                }
	
	            } // End of the main loop.
	        }
	        gotomainLoop:
	        ;
	
	        // The state machine is done. Check whether it found a match...
	        //
	        // If the iterator failed to advance in the match engine, force it ahead
	        // by one.
	        // (This really indicates a defect in the break rules. They should
	        // always match
	        // at least one character.)
	        if (result == initialPosition) {
	            result = fText.SetIndex(initialPosition);
	            CIPrevious32(fText);
	            result = fText.GetIndex();
	        }
	
	        fText.SetIndex(result);
	        if (fTrace) {
	            System.Console.Out.WriteLine("Result = " + result);
	        }
	
	        return result;
	    }
	
	    // -------------------------------------------------------------------------------
	
	    //
	
	    // isDictionaryChar Return true if the category lookup for this char
	
	    // indicates that it is in the set of dictionary lookup
	
	    // chars.
	
	    //
	
	    // This function is intended for use by dictionary based
	
	    // break iterators.
	
	    //
	
	    // -------------------------------------------------------------------------------
	
	    internal bool IsDictionaryChar(int c) {
	
	        short category = (short) fRData.fTrie.GetCodePointValue(c);
	
	        return (category & 0x4000) != 0;
	
	    }
	
	}
	// eof
}
