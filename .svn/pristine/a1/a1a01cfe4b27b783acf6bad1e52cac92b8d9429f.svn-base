/*
 *******************************************************************************
 *   Copyright (C) 2001-2007, International Business Machines
 *   Corporation and others.  All Rights Reserved.
 *******************************************************************************
 */

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/13/10 10:46 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Charset {
	
	using IBM.ICU.Text;
	using NUnit;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	
	/// <summary>
	/// Regression test for variants to the UBA.
	/// </summary>
	///
	
	[NUnit.Framework.TestFixture]
	public class TestReorderingMode : BidiTest {
	
	    static internal readonly String[] textIn = {
	    /* (0) 123 */
	    "123",
	    /* (1) .123->4.5 */
	    ".123->4.5",
	    /* (2) 678 */
	    "678",
	    /* (3) .678->8.9 */
	    ".678->8.9",
	    /* (4) JIH1.2,3MLK */
	    "JIH1.2,3MLK",
	    /* (5) FE.>12-> */
	    "FE.>12->",
	    /* (6) JIH.>12->a */
	    "JIH.>12->a",
	    /* (7) CBA.>67->89=a */
	    "CBA.>67->89=a",
	    /* (8) CBA.123->xyz */
	    "CBA.123->xyz",
	    /* (9) .>12->xyz */
	    ".>12->xyz",
	    /* (10) a.>67->xyz */
	    "a.>67->xyz",
	    /* (11) 123JIH */
	    "123JIH",
	    /* (12) 123 JIH */
	    "123 JIH" };
	
	    static internal readonly String[] textOut = {
	    /* TC 0: 123 */
	    "123", /* (0) */
	    /* TC 1: .123->4.5 */
	    ".123->4.5", /* (1) */
	    "4.5<-123.", /* (2) */
	    /* TC 2: 678 */
	    "678", /* (3) */
	    /* TC 3: .678->8.9 */
	    ".8.9<-678", /* (4) */
	    "8.9<-678.", /* (5) */
	    ".678->8.9", /* (6) */
	    /* TC 4: MLK1.2,3JIH */
	    "KLM1.2,3HIJ", /* (7) */
	    /* TC 5: FE.>12-> */
	    "12<.EF->", /* (8) */
	    "<-12<.EF", /* (9) */
	    "EF.>@12->", /* (10) */
	    /* TC 6: JIH.>12->a */
	    "12<.HIJ->a", /* (11) */
	    "a<-12<.HIJ", /* (12) */
	    "HIJ.>@12->a", /* (13) */
	    "a&<-12<.HIJ", /* (14) */
	    /* TC 7: CBA.>67->89=a */
	    "ABC.>@67->89=a", /* (15) */
	    "a=89<-67<.ABC", /* (16) */
	    "a&=89<-67<.ABC", /* (17) */
	    "89<-67<.ABC=a", /* (18) */
	    /* TC 8: CBA.123->xyz */
	    "123.ABC->xyz", /* (19) */
	    "xyz<-123.ABC", /* (20) */
	    "ABC.@123->xyz", /* (21) */
	    "xyz&<-123.ABC", /* (22) */
	    /* TC 9: .>12->xyz */
	    ".>12->xyz", /* (23) */
	    "xyz<-12<.", /* (24) */
	    "xyz&<-12<.", /* (25) */
	    /* TC 10: a.>67->xyz */
	    "a.>67->xyz", /* (26) */
	    "a.>@67@->xyz", /* (27) */
	    "xyz<-67<.a", /* (28) */
	    /* TC 11: 123JIH */
	    "123HIJ", /* (29) */
	    "HIJ123", /* (30) */
	    /* TC 12: 123 JIH */
	    "123 HIJ", /* (31) */
	    "HIJ 123", /* (32) */
	    };
	
	    static internal readonly int[][][][] outIndices = {
	            new int[][][] {new int[][] { new int[]{ 0, 0 }, new int[]{ 0, 0 } }, 
                               new int[][] { new int[]{ 0, 0 }, new int[]{ 0, 0 } },
	                           new int[][] { new int[]{ 0, 0 }, new int[]{ 0, 0 } },
                               new int[][] { new int[]{ 0, 0 }, new int[]{ 0, 0 } } },
	            new int[][][] {new int[][] {  new int[]{ 1, 2 },  new int[]{ 1, 2 } }, 
                        new int[][] {  new int[]{ 1, 2 },  new int[]{ 1, 2 } },
	                    new int[][] {  new int[]{ 1, 2 },  new int[]{ 1, 2 } },
                        new int[][] {  new int[]{ 1, 2 },  new int[]{ 1, 2 } } },
	            new int[][][] {new int[][] {  new int[]{ 3, 3 },  new int[]{ 3, 3 } }, 
                        new int[][] {  new int[]{ 3, 3 }, new int[] { 3, 3 } },
	                    new int[][] {  new int[]{ 3, 3 },  new int[]{ 3, 3 } }, 
                        new int[][] {  new int[]{ 3, 3 },  new int[]{ 3, 3 } } },
	            new int[][][] {new int[][] { new int[] { 6, 5 },  new int[]{ 6, 5 } }, 
                        new int[][] { new int[] { 4, 5 },  new int[]{ 4, 5 } },
	                    new int[][] { new int[] { 6, 5 },  new int[]{ 6, 5 } }, 
                        new int[][] { new int[] { 6, 5 },  new int[]{ 6, 5 } } },
	            new int[][][] {new int[][] {  new int[]{ 7, 7 }, new int[] { 7, 7 } }, 
                        new int[][] {  new int[]{ 7, 7 },  new int[]{ 7, 7 } },
	                    new int[][] { new int[] { 7, 7 },  new int[]{ 7, 7 } }, 
                        new int[][] {  new int[]{ 7, 7 },  new int[]{ 7, 7 } } },
	            new int[][][] {new int[][] {  new int[]{ 8, 9 },  new int[]{ 8, 9 } }, 
                        new int[][] {  new int[]{ 10, 9 },  new int[]{ 8, 9 } },
	                    new int[][] {  new int[]{ 8, 9 },  new int[]{ 8, 9 } }, 
                        new int[][] {  new int[]{ 10, 9 },  new int[]{ 8, 9 } } },
	            new int[][][] { new int[][]{ new int[]{ 11, 12 },  new int[]{ 11, 12 } },
	                    new int[][] {  new int[]{ 13, 14 },  new int[]{ 11, 12 } }, 
                        new int[][] { new int[] { 11, 12 }, new int[] { 11, 12 } },
	                    new int[][] { new int[] { 13, 14 }, new int[] { 11, 12 } } },
	            new int[][][] { new int[][]{ new int[]{ 18, 16 },  new int[]{ 18, 16 } },
	                    new int[][] {  new int[]{ 18, 17 },  new int[]{ 18, 16 } }, 
                        new int[][] {  new int[]{ 18, 16 },  new int[]{ 18, 16 } },
	                    new int[][] {  new int[]{ 15, 17 },  new int[]{ 18, 16 } } },
	            new int[][][] {new int[][] { new int[]{ 19, 20 },  new int[]{ 19, 20 } },
	                    new int[][] {  new int[]{ 21, 22 },  new int[]{ 19, 20 } }, 
                        new int[][] {  new int[]{ 19, 20 }, new int[] { 19, 20 } },
	                    new int[][] {  new int[]{ 21, 22 },  new int[]{ 19, 20 } } },
	            new int[][][] {new int[][] { new int[]{ 23, 24 },  new int[]{ 23, 24 } },
	                    new int[][] {  new int[]{ 23, 25 },  new int[]{ 23, 24 } }, 
                        new int[][] {  new int[]{ 23, 24 },  new int[]{ 23, 24 } },
	                    new int[][] {  new int[]{ 23, 25 },  new int[]{ 23, 24 } } },
	            new int[][][] {new int[][] { new int[]{ 26, 26 },  new int[]{ 26, 26 } },
	                    new int[][] {  new int[]{ 26, 27 },  new int[]{ 26, 28 } }, 
                        new int[][] {  new int[]{ 26, 28 },  new int[]{ 26, 28 } },
	                    new int[][] {  new int[]{ 26, 27 },  new int[]{ 26, 28 } } },
	            new int[][][] { new int[][]{ new int[]{ 30, 30 },  new int[]{ 30, 30 } },
	                    new int[][] {  new int[]{ 29, 30 },  new int[]{ 29, 30 } }, 
                        new int[][] {  new int[]{ 30, 30 },  new int[]{ 30, 30 } },
	                    new int[][] {  new int[]{ 30, 30 },  new int[]{ 30, 30 } } },
	            new int[][][] {new int[][] { new int[]{ 32, 32 },  new int[]{ 32, 32 } },
	                    new int[][] {  new int[]{ 31, 32 },  new int[]{ 31, 32 } }, 
                        new int[][] {  new int[]{ 31, 32 },  new int[]{ 31, 32 } },
	                    new int[][] {  new int[]{ 31, 32 },  new int[]{ 31, 32 } } } };
	
	    static internal readonly short[] modes = { IBM.ICU.Text.Bidi.REORDER_GROUP_NUMBERS_WITH_R,
	            IBM.ICU.Text.Bidi.REORDER_INVERSE_LIKE_DIRECT, IBM.ICU.Text.Bidi.REORDER_NUMBERS_SPECIAL,
	            IBM.ICU.Text.Bidi.REORDER_INVERSE_FOR_NUMBERS_SPECIAL,
	            IBM.ICU.Text.Bidi.REORDER_INVERSE_NUMBERS_AS_L };
	
	    static internal readonly int[] options = { IBM.ICU.Text.Bidi.OPTION_INSERT_MARKS, 0 };
	
	    static internal readonly sbyte[] paraLevels = { IBM.ICU.Text.Bidi.LTR, IBM.ICU.Text.Bidi.RTL };
	
	    static internal readonly int TC_COUNT = textIn.Length;
	
	    static internal readonly int MODES_COUNT = modes.Length;
	
	    static internal readonly int OPTIONS_COUNT = options.Length;
	
	    static internal readonly int LEVELS_COUNT = paraLevels.Length;
	
	    [NUnit.Framework.Test]
	    public void TestReorderingMode2() {
	
	        String src, dest;
	        Bidi bidi = new Bidi();
	        Bidi bidi2 = new Bidi();
	        Bidi bidi3 = new Bidi();
	        int tc, mode, option, level;
	        int modeValue, modeBack;
	        int optionValue, optionBack;
	        int index;
	        String expected;
	        bool testOK = true;
	
	        Logln("\nEntering TestReorderingMode\n");
	
	        bidi2.SetInverse(true);
	
	        for (tc = 0; tc < TC_COUNT; tc++) {
	            src = textIn[tc];
	
	            for (mode = 0; mode < MODES_COUNT; mode++) {
	                modeValue = modes[mode];
	                bidi.SetReorderingMode(modeValue);
	                modeBack = bidi.GetReorderingMode();
	                if (modeValue != modeBack) {
	                    Errln("Error while setting reordering mode to " + modeValue
	                            + ", returned " + modeBack);
	                }
	
	                for (option = 0; option < OPTIONS_COUNT; option++) {
	                    optionValue = options[option];
	                    bidi.SetReorderingOptions(optionValue);
	                    optionBack = bidi.GetReorderingOptions();
	                    if (optionValue != optionBack) {
	                        Errln("Error while setting reordering options to "
	                                + modeValue + ", returned " + modeBack);
	                    }
	
	                    for (level = 0; level < LEVELS_COUNT; level++) {
	                        Logln("starting test " + tc + " mode=" + modeValue
	                                + " option=" + optionValue + " level=" + level);
	                        bidi.SetPara(IBM.ICU.Charset.BidiTest.PseudoToU16(src), paraLevels[level], null);
	
	                        dest = bidi.WriteReordered(IBM.ICU.Text.Bidi.DO_MIRRORING);
	                        dest = IBM.ICU.Charset.BidiTest.U16ToPseudo(dest);
	                        if (!((modeValue == IBM.ICU.Text.Bidi.REORDER_INVERSE_NUMBERS_AS_L) && (optionValue == IBM.ICU.Text.Bidi.OPTION_INSERT_MARKS))) {
	                            CheckWhatYouCan(bidi, src, dest);
	                        }
	                        String modeDesc = IBM.ICU.Charset.BidiTest.ModeToString(modeValue);
	                        String optDesc = IBM.ICU.Charset.BidiTest.SpOptionsToString(optionValue);
	
	                        if (modeValue == IBM.ICU.Text.Bidi.REORDER_INVERSE_NUMBERS_AS_L) {
	                            index = -1;
	                            expected = InverseBasic(bidi2, src, optionValue,
	                                    paraLevels[level]);
	                        } else {
	                            index = outIndices[tc][mode][option][level];
	                            expected = textOut[index];
	                        }
	                        if (!AssertEquals(
	                                "Actual and expected output mismatch",
	                                expected, dest, src, modeDesc, optDesc,
	                                level.ToString())) {
	                            testOK = false;
	                            continue;
	                        }
	                        if ((optionValue == IBM.ICU.Text.Bidi.OPTION_INSERT_MARKS)
	                                && !AssertRoundTrip(bidi3, tc, index, src,
	                                        dest, mode, option, paraLevels[level])) {
	                            testOK = false;
	                            continue;
	                        }
	                        if (!CheckResultLength(bidi, src, dest, modeDesc,
	                                optDesc, paraLevels[level])) {
	                            testOK = false;
	                            continue;
	                        }
	                        if ((index > -1)
	                                && !CheckMaps(bidi, index, src, dest, modeDesc,
	                                        optDesc, paraLevels[level], true)) {
	                            testOK = false;
	                        }
	                    }
	                }
	            }
	        }
	        if (testOK) {
	            Logln("Reordering mode test OK");
	        }
	
	        Logln("\nExiting TestReorderingMode\n");
	    }
	
	    internal String InverseBasic(Bidi bidi, String src, int option, sbyte level) {
	        String dest2;
	
	        if (bidi == null || src == null) {
	            return null;
	        }
	        bidi.SetReorderingOptions(option);
	        bidi.SetPara(IBM.ICU.Charset.BidiTest.PseudoToU16(src), level, null);
	        dest2 = IBM.ICU.Charset.BidiTest.U16ToPseudo(bidi.WriteReordered(IBM.ICU.Text.Bidi.DO_MIRRORING));
	        if (!(option == IBM.ICU.Text.Bidi.OPTION_INSERT_MARKS)) {
	            CheckWhatYouCan(bidi, src, dest2);
	        }
	        return dest2;
	    }
	
	    static internal readonly byte[][][][] roundtrip = {
	            new byte[][][] { new byte[][]{ new byte[]{ 1, 1 }, new byte[]{ 1, 1 } }, new byte[][]{ new byte[]{ 1, 1 }, new byte[]{ 1, 1 } },
	                    new byte[][]{ new byte[]{ 1, 1 }, new byte[]{ 1, 1 } }, new byte[][]{ new byte[]{ 1, 1 }, new byte[]{ 1, 1 } },
	                    new byte[][]{ new byte[]{ 1, 1 }, new byte[]{ 1, 1 } } },
	            new byte[][][] {new byte[][] { new byte[]{ 1, 1 },new byte[] { 1, 1 } }, new byte[][]{ new byte[]{ 1, 1 }, new byte[]{ 1, 1 } },
	                    new byte[][]{new byte[] { 1, 1 }, new byte[]{ 1, 1 } }, new byte[][]{ new byte[]{ 1, 1 }, new byte[]{ 1, 1 } },
	                    new byte[][]{ new byte[]{ 1, 1 },new byte[] { 1, 1 } } },
	            new byte[][][] {new byte[][] { new byte[]{ 1, 1 }, new byte[]{ 1, 1 } },new byte[][] { new byte[]{ 1, 1 }, new byte[]{ 1, 1 } },
	                    new byte[][]{new byte[] { 1, 1 }, new byte[]{ 1, 1 } }, new byte[][]{ new byte[]{ 1, 1 }, new byte[]{ 1, 1 } },
	                    new byte[][]{ new byte[]{ 1, 1 }, new byte[]{ 1, 1 } } },
	            new byte[][][] { new byte[][]{ new byte[]{ 1, 1 }, new byte[]{ 1, 1 } },new byte[][] {new byte[] { 1, 1 },new byte[] { 1, 1 } },
	                    new byte[][]{ new byte[]{ 1, 1 }, new byte[]{ 1, 1 } }, new byte[][]{ new byte[]{ 1, 1 }, new byte[]{ 1, 1 } },
	                    new byte[][]{ new byte[]{ 0, 0 }, new byte[]{ 1, 1 } } },
	            new byte[][][] { new byte[][]{ new byte[]{ 1, 1 }, new byte[]{ 1, 1 } }, new byte[][]{new byte[] { 1, 1 }, new byte[]{ 1, 1 } },
	                    new byte[][]{ new byte[]{ 1, 1 }, new byte[]{ 1, 1 } }, new byte[][]{new byte[] { 1, 1 }, new byte[]{ 1, 1 } },
	                    new byte[][]{ new byte[]{ 1, 1 }, new byte[]{ 1, 1 } } },
	            new byte[][][] { new byte[][]{new byte[] { 1, 1 },new byte[] { 1, 1 } }, new byte[][]{ new byte[]{ 1, 1 }, new byte[]{ 1, 1 } },
	                   new byte[][] { new byte[]{ 0, 1 }, new byte[]{ 1, 1 } },new byte[][] { new byte[]{ 1, 1 },new byte[] { 1, 1 } },
	                    new byte[][]{ new byte[]{ 1, 1 }, new byte[]{ 1, 1 } } },
	            new byte[][][] { new byte[][]{ new byte[]{ 1, 1 }, new byte[]{ 1, 1 } }, new byte[][]{ new byte[]{ 1, 1 }, new byte[]{ 1, 1 } },
	                    new byte[][]{ new byte[]{ 0, 0 }, new byte[]{ 1, 1 } }, new byte[][]{ new byte[]{ 1, 1 },new byte[] { 1, 1 } },
	                    new byte[][]{ new byte[]{ 1, 1 },new byte[] { 1, 1 } } },
	            new byte[][][] { new byte[][]{ new byte[]{ 1, 1 }, new byte[]{ 1, 1 } }, new byte[][]{ new byte[]{ 1, 1 }, new byte[]{ 1, 1 } },
	                    new byte[][]{ new byte[]{ 0, 1 }, new byte[]{ 1, 1 } },new byte[][] { new byte[]{ 1, 1 }, new byte[]{ 1, 1 } },
	                    new byte[][]{ new byte[]{ 0, 0 }, new byte[]{ 1, 1 } } },
	            new byte[][][] { new byte[][]{ new byte[]{ 1, 1 }, new byte[]{ 1, 1 } }, new byte[][]{ new byte[]{ 1, 1 }, new byte[]{ 1, 1 } },
	                    new byte[][]{new byte[] { 0, 0 }, new byte[]{ 1, 1 } }, new byte[][]{ new byte[]{ 1, 1 }, new byte[]{ 1, 1 } },
	                    new byte[][]{ new byte[]{ 1, 1 }, new byte[]{ 1, 1 } } },
	            new byte[][][] {new byte[][] { new byte[]{ 1, 1 }, new byte[]{ 1, 1 } }, new byte[][]{ new byte[]{ 1, 1 }, new byte[]{ 1, 1 } },
	                    new byte[][]{ new byte[]{ 1, 0 }, new byte[]{ 1, 1 } }, new byte[][]{ new byte[]{ 1, 1 },new byte[] { 1, 1 } },
	                    new byte[][]{ new byte[]{ 1, 1 },new byte[] { 1, 1 } } },
	            new byte[][][] { new byte[][]{ new byte[]{ 1, 1 },new byte[] { 1, 1 } }, new byte[][]{ new byte[]{ 1, 1 }, new byte[]{ 1, 1 } },
	                    new byte[][]{ new byte[]{ 1, 1 }, new byte[]{ 1, 1 } }, new byte[][]{ new byte[]{ 1, 1 }, new byte[]{ 1, 1 } },
	                    new byte[][]{ new byte[]{ 1, 0 }, new byte[]{ 1, 1 } } },
	            new byte[][][] { new byte[][]{ new byte[]{ 1, 1 }, new byte[]{ 1, 1 } }, new byte[][]{ new byte[]{ 1, 1 },new byte[] { 1, 1 } },
	                    new byte[][]{ new byte[]{ 1, 1 }, new byte[]{ 1, 1 } }, new byte[][]{new byte[] { 1, 1 }, new byte[]{ 1, 1 } },
	                    new byte[][]{ new byte[]{ 1, 1 },new byte[] { 1, 1 } } },
	            new byte[][][] { new byte[][]{ new byte[]{ 1, 1 }, new byte[]{ 1, 1 } }, new byte[][]{ new byte[]{ 1, 1 }, new byte[]{ 1, 1 } },
	                    new byte[][]{ new byte[]{ 1, 1 }, new byte[]{ 1, 1 } }, new byte[][]{ new byte[]{ 1, 1 }, new byte[]{ 1, 1 } },
	                    new byte[][]{ new byte[]{ 1, 1 }, new byte[]{ 1, 1 } } } };
	
	    private bool AssertRoundTrip(Bidi bidi, int tc, int outIndex,
	            String src, String dest, int mode, int option, sbyte level) {
	        String descMode, descOption;
	        String dest2;
	
	        switch (modes[mode]) {
	        case IBM.ICU.Text.Bidi.REORDER_NUMBERS_SPECIAL:
	            bidi.SetReorderingMode(IBM.ICU.Text.Bidi.REORDER_INVERSE_FOR_NUMBERS_SPECIAL);
	            break;
	        case IBM.ICU.Text.Bidi.REORDER_GROUP_NUMBERS_WITH_R:
	            bidi.SetReorderingMode(IBM.ICU.Text.Bidi.REORDER_GROUP_NUMBERS_WITH_R);
	            break;
	        case IBM.ICU.Text.Bidi.REORDER_RUNS_ONLY:
	            bidi.SetReorderingMode(IBM.ICU.Text.Bidi.REORDER_RUNS_ONLY);
	            break;
	        case IBM.ICU.Text.Bidi.REORDER_INVERSE_NUMBERS_AS_L:
	            bidi.SetReorderingMode(IBM.ICU.Text.Bidi.REORDER_DEFAULT);
	            break;
	        case IBM.ICU.Text.Bidi.REORDER_INVERSE_LIKE_DIRECT:
	            bidi.SetReorderingMode(IBM.ICU.Text.Bidi.REORDER_DEFAULT);
	            break;
	        case IBM.ICU.Text.Bidi.REORDER_INVERSE_FOR_NUMBERS_SPECIAL:
	            bidi.SetReorderingMode(IBM.ICU.Text.Bidi.REORDER_NUMBERS_SPECIAL);
	            break;
	        default:
	            bidi.SetReorderingMode(IBM.ICU.Text.Bidi.REORDER_INVERSE_LIKE_DIRECT);
	            break;
	        }
	        bidi.SetReorderingOptions(IBM.ICU.Text.Bidi.OPTION_REMOVE_CONTROLS);
	
	        bidi.SetPara(IBM.ICU.Charset.BidiTest.PseudoToU16(dest), level, null);
	        dest2 = bidi.WriteReordered(IBM.ICU.Text.Bidi.DO_MIRRORING);
	
	        dest2 = IBM.ICU.Charset.BidiTest.U16ToPseudo(dest2);
	        CheckWhatYouCan(bidi, dest, dest2);
	        descMode = IBM.ICU.Charset.BidiTest.ModeToString(modes[mode]);
	        descOption = IBM.ICU.Charset.BidiTest.SpOptionsToString(options[option]);
	        if (!src.Equals(dest2)) {
	            if (roundtrip[tc][mode][option][level] == 1) {
	                Errln("\nRound trip failed for case=" + tc + " mode=" + mode
	                        + " option=" + option + "\nOriginal text:      " + src
	                        + "\nRound-tripped text: " + dest2
	                        + "\nIntermediate text:  " + dest
	                        + "\nReordering mode:    " + descMode
	                        + "\nReordering option:  " + descOption
	                        + "\nParagraph level:    " + level);
	            } else {
	                Logln("\nExpected round trip failure for case=" + tc + " mode="
	                        + mode + " option=" + option + "\nOriginal text:      "
	                        + src + "\nRound-tripped text: " + dest2
	                        + "\nIntermediate text:  " + dest
	                        + "\nReordering mode:    " + descMode
	                        + "\nReordering option:  " + descOption
	                        + "\nParagraph level:    " + level);
	            }
	            return false;
	        }
	        if (!CheckResultLength(bidi, dest, dest2, descMode,
	                "OPTION_REMOVE_CONTROLS", level)) {
	            return false;
	        }
	        if ((outIndex > -1)
	                && !CheckMaps(bidi, outIndex, src, dest, descMode,
	                        "OPTION_REMOVE_CONTROLS", level, false)) {
	            return false;
	        }
	        return true;
	    }
	
	    private bool CheckResultLength(Bidi bidi, String src, String dest,
	            String mode, String option, sbyte level) {
	        int actualLen;
	        if (mode.Equals("REORDER_INVERSE_NUMBERS_AS_L"))
	            actualLen = dest.Length;
	        else
	            actualLen = bidi.GetResultLength();
	        if (actualLen != dest.Length) {
	            Errln("\nBidi.getResultLength failed." + "\nExpected:           "
	                    + dest.Length + "\nActual:             " + actualLen
	                    + "\nInput:              " + src + "\nOutput:             "
	                    + dest + "\nReordering mode:    " + mode
	                    + "\nReordering option:  " + option
	                    + "\nParagraph level:    " + level);
	            return false;
	        }
	        return true;
	    }
	
	    static internal String FormatMap(int[] map) {
	        char[] buffer = new char[map.Length];
	        int i, k;
	        char c;
	        for (i = 0; i < map.Length; i++) {
	            k = map[i];
	            if (k < 0)
	                c = '-';
	            else if (k >= columns.Length)
	                c = '+';
	            else
	                c = IBM.ICU.Charset.BidiTest.columns[k];
	            buffer[i] = c;
	        }
	        return ILOG.J2CsMapping.Util.StringUtil.NewString(buffer);
	    }
	
	    internal const int NO = IBM.ICU.Text.Bidi.MAP_NOWHERE;
	
	    static internal readonly int[][] forwardMap = { new int[] { 0, 1, 2 },
	            new int[] { 0, 1, 2, 3, 4, 5, 6, 7, 8 },
	            new int[] { 8, 5, 6, 7, 4, 3, 0, 1, 2 }, new int[] { 0, 1, 2 },
	            new int[] { 0, 6, 7, 8, 5, 4, 1, 2, 3 },
	            new int[] { 8, 5, 6, 7, 4, 3, 0, 1, 2 },
	            new int[] { 0, 1, 2, 3, 4, 5, 6, 7, 8 },
	            new int[] { 10, 9, 8, 3, 4, 5, 6, 7, 2, 1, 0 },
	            new int[] { 5, 4, 3, 2, 0, 1, 6, 7 },
	            new int[] { 7, 6, 5, 4, 2, 3, 1, 0 },
	            new int[] { 1, 0, 2, 3, 5, 6, 7, 8 },
	            new int[] { 6, 5, 4, 3, 2, 0, 1, 7, 8, 9 },
	            new int[] { 9, 8, 7, 6, 5, 3, 4, 2, 1, 0 },
	            new int[] { 2, 1, 0, 3, 4, 6, 7, 8, 9, 10 },
	            new int[] { 10, 9, 8, 7, 6, 4, 5, 3, 2, 0 },
	            new int[] { 2, 1, 0, 3, 4, 6, 7, 8, 9, 10, 11, 12, 13 },
	            new int[] { 12, 11, 10, 9, 8, 6, 7, 5, 4, 2, 3, 1, 0 },
	            new int[] { 13, 12, 11, 10, 9, 7, 8, 6, 5, 3, 4, 2, 0 },
	            new int[] { 10, 9, 8, 7, 6, 4, 5, 3, 2, 0, 1, 11, 12 },
	            new int[] { 6, 5, 4, 3, 0, 1, 2, 7, 8, 9, 10, 11 },
	            new int[] { 11, 10, 9, 8, 5, 6, 7, 4, 3, 0, 1, 2 },
	            new int[] { 2, 1, 0, 3, 5, 6, 7, 8, 9, 10, 11, 12 },
	            new int[] { 12, 11, 10, 9, 6, 7, 8, 5, 4, 0, 1, 2 },
	            new int[] { 0, 1, 2, 3, 4, 5, 6, 7, 8 },
	            new int[] { 8, 7, 5, 6, 4, 3, 0, 1, 2 },
	            new int[] { 9, 8, 6, 7, 5, 4, 0, 1, 2 },
	            new int[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 },
	            new int[] { 0, 1, 2, 4, 5, 7, 8, 9, 10, 11 },
	            new int[] { 9, 8, 7, 5, 6, 4, 3, 0, 1, 2 },
	            new int[] { 0, 1, 2, 5, 4, 3 }, new int[] { 3, 4, 5, 2, 1, 0 },
	            new int[] { 0, 1, 2, 3, 6, 5, 4 },
	            new int[] { 4, 5, 6, 3, 2, 1, 0 } };
	
	    static internal readonly int[][] inverseMap = { new int[] { 0, 1, 2 },
	            new int[] { 0, 1, 2, 3, 4, 5, 6, 7, 8 },
	            new int[] { 6, 7, 8, 5, 4, 1, 2, 3, 0 }, new int[] { 0, 1, 2 },
	            new int[] { 0, 6, 7, 8, 5, 4, 1, 2, 3 },
	            new int[] { 6, 7, 8, 5, 4, 1, 2, 3, 0 },
	            new int[] { 0, 1, 2, 3, 4, 5, 6, 7, 8 },
	            new int[] { 10, 9, 8, 3, 4, 5, 6, 7, 2, 1, 0 },
	            new int[] { 4, 5, 3, 2, 1, 0, 6, 7 },
	            new int[] { 7, 6, 4, 5, 3, 2, 1, 0 },
	            new int[] { 1, 0, 2, 3, NO, 4, 5, 6, 7 },
	            new int[] { 5, 6, 4, 3, 2, 1, 0, 7, 8, 9 },
	            new int[] { 9, 8, 7, 5, 6, 4, 3, 2, 1, 0 },
	            new int[] { 2, 1, 0, 3, 4, NO, 5, 6, 7, 8, 9 },
	            new int[] { 9, NO, 8, 7, 5, 6, 4, 3, 2, 1, 0 },
	            new int[] { 2, 1, 0, 3, 4, NO, 5, 6, 7, 8, 9, 10, 11, 12 },
	            new int[] { 12, 11, 9, 10, 8, 7, 5, 6, 4, 3, 2, 1, 0 },
	            new int[] { 12, NO, 11, 9, 10, 8, 7, 5, 6, 4, 3, 2, 1, 0 },
	            new int[] { 9, 10, 8, 7, 5, 6, 4, 3, 2, 1, 0, 11, 12 },
	            new int[] { 4, 5, 6, 3, 2, 1, 0, 7, 8, 9, 10, 11 },
	            new int[] { 9, 10, 11, 8, 7, 4, 5, 6, 3, 2, 1, 0 },
	            new int[] { 2, 1, 0, 3, NO, 4, 5, 6, 7, 8, 9, 10, 11 },
	            new int[] { 9, 10, 11, NO, 8, 7, 4, 5, 6, 3, 2, 1, 0 },
	            new int[] { 0, 1, 2, 3, 4, 5, 6, 7, 8 },
	            new int[] { 6, 7, 8, 5, 4, 2, 3, 1, 0 },
	            new int[] { 6, 7, 8, NO, 5, 4, 2, 3, 1, 0 },
	            new int[] { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 },
	            new int[] { 0, 1, 2, NO, 3, 4, NO, 5, 6, 7, 8, 9 },
	            new int[] { 7, 8, 9, 6, 5, 3, 4, 2, 1, 0 },
	            new int[] { 0, 1, 2, 5, 4, 3 }, new int[] { 5, 4, 3, 0, 1, 2 },
	            new int[] { 0, 1, 2, 3, 6, 5, 4 },
	            new int[] { 6, 5, 4, 3, 0, 1, 2 } };
	
	    private bool CheckMaps(Bidi bidi, int stringIndex, String src,
	            String dest, String mode, String option, sbyte level, bool forward) {
	
	        int[] actualLogicalMap;
	        int[] actualVisualMap;
	        int[] getIndexMap;
	        int i, srcLen, resLen, index;
	        int[] expectedLogicalMap, expectedVisualMap;
	        bool testOK = true;
	
	        if (forward) {
	            expectedLogicalMap = forwardMap[stringIndex];
	            expectedVisualMap = inverseMap[stringIndex];
	        } else {
	            expectedLogicalMap = inverseMap[stringIndex];
	            expectedVisualMap = forwardMap[stringIndex];
	        }
	        actualLogicalMap = bidi.GetLogicalMap();
	        srcLen = bidi.GetProcessedLength();
	        if (!ILOG.J2CsMapping.Collections.Arrays.Equals(expectedLogicalMap,actualLogicalMap)) {
	            Err("Bidi.getLogicalMap returned unexpected map for output "
	                    + "string index "
	                    + stringIndex
	                    + "\n"
	                    + "source: "
	                    + src
	                    + "\n"
	                    + "dest  : "
	                    + dest
	                    + "\n"
	                    + "Scale : "
	                    + IBM.ICU.Charset.BidiTest.columnString
	                    + "\n"
	                    + "ExpMap: "
	                    + FormatMap(expectedLogicalMap)
	                    + "\n"
	                    + "Actual: "
	                    + FormatMap(actualLogicalMap)
	                    + "\n"
	                    + "Paragraph level  : "
	                    + level
	                    + " == "
	                    + bidi.GetParaLevel()
	                    + "\n"
	                    + "Reordering mode  : "
	                    + mode
	                    + " == "
	                    + bidi.GetReorderingMode()
	                    + "\n"
	                    + "Reordering option: "
	                    + option
	                    + " == "
	                    + bidi.GetReorderingOptions()
	                    + "\n"
	                    + "Forward flag     : " + forward + "\n");
	            testOK = false;
	        }
	        resLen = bidi.GetResultLength();
	        actualVisualMap = bidi.GetVisualMap();
	        if (!ILOG.J2CsMapping.Collections.Arrays.Equals(expectedVisualMap,actualVisualMap)) {
	            Err("Bidi.getVisualMap returned unexpected map for output "
	                    + "string index "
	                    + stringIndex
	                    + "\n"
	                    + "source: "
	                    + src
	                    + "\n"
	                    + "dest  : "
	                    + dest
	                    + "\n"
	                    + "Scale : "
	                    + IBM.ICU.Charset.BidiTest.columnString
	                    + "\n"
	                    + "ExpMap: "
	                    + FormatMap(expectedVisualMap)
	                    + "\n"
	                    + "Actual: "
	                    + FormatMap(actualVisualMap)
	                    + "\n"
	                    + "Paragraph level  : "
	                    + level
	                    + " == "
	                    + bidi.GetParaLevel()
	                    + "\n"
	                    + "Reordering mode  : "
	                    + mode
	                    + " == "
	                    + bidi.GetReorderingMode()
	                    + "\n"
	                    + "Reordering option: "
	                    + option
	                    + " == "
	                    + bidi.GetReorderingOptions()
	                    + "\n"
	                    + "Forward flag     : " + forward + "\n");
	            testOK = false;
	        }
	        getIndexMap = new int[srcLen];
	        for (i = 0; i < srcLen; i++) {
	            index = bidi.GetVisualIndex(i);
	            getIndexMap[i] = index;
	        }
	        if (!ILOG.J2CsMapping.Collections.Arrays.Equals(actualLogicalMap,getIndexMap)) {
	            Err("Mismatch between getLogicalMap and getVisualIndex for output "
	                    + "string index "
	                    + stringIndex
	                    + "\n"
	                    + "source: "
	                    + src
	                    + "\n"
	                    + "dest  : "
	                    + dest
	                    + "\n"
	                    + "Scale : "
	                    + IBM.ICU.Charset.BidiTest.columnString
	                    + "\n"
	                    + "ActMap: "
	                    + FormatMap(actualLogicalMap)
	                    + "\n"
	                    + "IdxMap: "
	                    + FormatMap(getIndexMap)
	                    + "\n"
	                    + "Paragraph level  : "
	                    + level
	                    + " == "
	                    + bidi.GetParaLevel()
	                    + "\n"
	                    + "Reordering mode  : "
	                    + mode
	                    + " == "
	                    + bidi.GetReorderingMode()
	                    + "\n"
	                    + "Reordering option: "
	                    + option
	                    + " == "
	                    + bidi.GetReorderingOptions()
	                    + "\n"
	                    + "Forward flag     : " + forward + "\n");
	            testOK = false;
	        }
	        getIndexMap = new int[resLen];
	        for (i = 0; i < resLen; i++) {
	            index = bidi.GetLogicalIndex(i);
	            getIndexMap[i] = index;
	        }
	        if (!ILOG.J2CsMapping.Collections.Arrays.Equals(actualVisualMap,getIndexMap)) {
	            Err("Mismatch between getVisualMap and getLogicalIndex for output "
	                    + "string index "
	                    + stringIndex
	                    + "\n"
	                    + "source: "
	                    + src
	                    + "\n"
	                    + "dest  : "
	                    + dest
	                    + "\n"
	                    + "Scale : "
	                    + IBM.ICU.Charset.BidiTest.columnString
	                    + "\n"
	                    + "ActMap: "
	                    + FormatMap(actualVisualMap)
	                    + "\n"
	                    + "IdxMap: "
	                    + FormatMap(getIndexMap)
	                    + "\n"
	                    + "Paragraph level  : "
	                    + level
	                    + " == "
	                    + bidi.GetParaLevel()
	                    + "\n"
	                    + "Reordering mode  : "
	                    + mode
	                    + " == "
	                    + bidi.GetReorderingMode()
	                    + "\n"
	                    + "Reordering option: "
	                    + option
	                    + " == "
	                    + bidi.GetReorderingOptions()
	                    + "\n"
	                    + "Forward flag     : " + forward + "\n");
	            testOK = false;
	        }
	        return testOK;
	    }
	
	    public static void Main(String[] args) {
	        try {
	            new TestReorderingMode().Run(args);
	        } catch (Exception e) {
	            System.Console.Out.WriteLine(e);
	        }
	    }
	
	}
}
