/*
 **********************************************************************
 *   Copyright (c) 2002-2007, International Business Machines
 *   Corporation and others.  All Rights Reserved.
 **********************************************************************
 */

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:30 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Text {
	
	using ILOG.J2CsMapping.Collections;
	using ILOG.J2CsMapping.Collections.Generics;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	
	//
	//  class RBBITableBuilder is part of the RBBI rule compiler.
	//                         It builds the state transition table used by the RBBI runtime
	//                         from the expression syntax tree generated by the rule scanner.
	//
	//                         This class is part of the RBBI implementation only.
	//                         There is no user-visible public API here.
	//
	internal class RBBITableBuilder {
	
	    //
	    // RBBIStateDescriptor - The DFA is initially constructed as a set of these
	    // descriptors,
	    // one for each state.
	    internal class RBBIStateDescriptor {
	        internal bool fMarked;
	
	        internal int fAccepting;
	
	        internal int fLookAhead;
	
	        internal SortedSet fTagVals;
	
	        internal int fTagsIdx;
	
	        internal ILOG.J2CsMapping.Collections.ISet fPositions; // Set of parse tree positions associated
	                        // with this state. Unordered (it's a set).
	                        // UVector contents are RBBINode *
	
	        internal int[] fDtran; // Transitions out of this state.
	                      // indexed by input character
	                      // contents is int index of dest state
	                      // in RBBITableBuilder.fDStates
	
	        internal RBBIStateDescriptor(int maxInputSymbol) {
	            fTagVals = new SortedSet();
	            fPositions = new HashedSet();
	            fDtran = new int[maxInputSymbol + 1]; // fDtran needs to be
	                                                  // pre-sized.
	                                                  // It is indexed by input
	                                                  // symbols, and will
	                                                  // hold the next state number
	                                                  // for each
	                                                  // symbol.
	        }
	    }
	
	    private RBBIRuleBuilder fRB;
	
	    private int fRootIx; // The array index into RBBIRuleBuilder.fTreeRoots
	                         // for the parse tree to operate on.
	                         // Too bad Java can't do indirection more easily!
	
	    private IList fDStates; // D states (Aho's terminology)
	                           // Index is state number
	                           // Contents are RBBIStateDescriptor pointers.
	
	    // -----------------------------------------------------------------------------
	    //
	    // Constructor for RBBITableBuilder.
	    //
	    // rootNode is an index into the array of root nodes that is held by
	    // the overall RBBIRuleBuilder.
	    // -----------------------------------------------------------------------------
	    internal RBBITableBuilder(RBBIRuleBuilder rb, int rootNodeIx) {
	        fRootIx = rootNodeIx;
	        fRB = rb;
	        fDStates = new ArrayList();
	    }
	
	    // -----------------------------------------------------------------------------
	    //
	    // RBBITableBuilder::build - This is the main function for building the DFA
	    // state transtion
	    // table from the RBBI rules parse tree.
	    //
	    // -----------------------------------------------------------------------------
	    internal void Build() {
	        // If there were no rules, just return. This situation can easily arise
	        // for the reverse rules.
	        if (fRB.fTreeRoots[fRootIx] == null) {
	            return;
	        }
	
	        //
	        // Walk through the tree, replacing any references to $variables with a
	        // copy of the
	        // parse tree for the substition expression.
	        //
	        fRB.fTreeRoots[fRootIx] = fRB.fTreeRoots[fRootIx].FlattenVariables();
	        if (fRB.fDebugEnv != null && fRB.fDebugEnv.IndexOf("ftree") >= 0) {
	            System.Console.Out
	                    .WriteLine("Parse tree after flattening variable references.");
	            fRB.fTreeRoots[fRootIx].PrintTree(true);
	        }
	
	        //
	        // If the rules contained any references to {bof}
	        // add a {bof} <cat> <former root of tree> to the
	        // tree. Means that all matches must start out with the
	        // {bof} fake character.
	        //
	        if (fRB.fSetBuilder.SawBOF()) {
	            RBBINode bofTop = new RBBINode(IBM.ICU.Text.RBBINode.opCat);
	            RBBINode bofLeaf = new RBBINode(IBM.ICU.Text.RBBINode.leafChar);
	            bofTop.fLeftChild = bofLeaf;
	            bofTop.fRightChild = fRB.fTreeRoots[fRootIx];
	            bofLeaf.fParent = bofTop;
	            bofLeaf.fVal = 2; // Reserved value for {bof}.
	            fRB.fTreeRoots[fRootIx] = bofTop;
	        }
	
	        //
	        // Add a unique right-end marker to the expression.
	        // Appears as a cat-node, left child being the original tree,
	        // right child being the end marker.
	        //
	        RBBINode cn = new RBBINode(IBM.ICU.Text.RBBINode.opCat);
	        cn.fLeftChild = fRB.fTreeRoots[fRootIx];
	        fRB.fTreeRoots[fRootIx].fParent = cn;
	        cn.fRightChild = new RBBINode(IBM.ICU.Text.RBBINode.endMark);
	        cn.fRightChild.fParent = cn;
	        fRB.fTreeRoots[fRootIx] = cn;
	
	        //
	        // Replace all references to UnicodeSets with the tree for the
	        // equivalent
	        // expression.
	        //
	        fRB.fTreeRoots[fRootIx].FlattenSets();
	        if (fRB.fDebugEnv != null && fRB.fDebugEnv.IndexOf("stree") >= 0) {
	            System.Console.Out
	                    .WriteLine("Parse tree after flattening Unicode Set references.");
	            fRB.fTreeRoots[fRootIx].PrintTree(true);
	        }
	
	        //
	        // calculate the functions nullable, firstpos, lastpos and followpos on
	        // nodes in the parse tree.
	        // See the alogrithm description in Aho.
	        // Understanding how this works by looking at the code alone will be
	        // nearly impossible.
	        //
	        CalcNullable(fRB.fTreeRoots[fRootIx]);
	        CalcFirstPos(fRB.fTreeRoots[fRootIx]);
	        CalcLastPos(fRB.fTreeRoots[fRootIx]);
	        CalcFollowPos(fRB.fTreeRoots[fRootIx]);
	        if (fRB.fDebugEnv != null && fRB.fDebugEnv.IndexOf("pos") >= 0) {
	            System.Console.Out.Write("\n");
	            PrintPosSets(fRB.fTreeRoots[fRootIx]);
	        }
	
	        //
	        // For "chained" rules, modify the followPos sets
	        //
	        if (fRB.fChainRules) {
	            CalcChainedFollowPos(fRB.fTreeRoots[fRootIx]);
	        }
	
	        //
	        // BOF (start of input) test fixup.
	        //
	        if (fRB.fSetBuilder.SawBOF()) {
	            BofFixup();
	        }
	
	        //
	        // Build the DFA state transition tables.
	        //
	        BuildStateTable();
	        FlagAcceptingStates();
	        FlagLookAheadStates();
	        FlagTaggedStates();
	
	        //
	        // Update the global table of rule status {tag} values
	        // The rule builder has a global vector of status values that are common
	        // for all tables. Merge the ones from this table into the global set.
	        //
	        MergeRuleStatusVals();
	
	        if (fRB.fDebugEnv != null && fRB.fDebugEnv.IndexOf("states") >= 0) {
	            PrintStates();
	        }
	    }
	
	    // -----------------------------------------------------------------------------
	    //
	    // calcNullable. Impossible to explain succinctly. See Aho, section 3.9
	    //
	    // -----------------------------------------------------------------------------
	    internal void CalcNullable(RBBINode n) {
	        if (n == null) {
	            return;
	        }
	        if (n.fType == IBM.ICU.Text.RBBINode.setRef || n.fType == IBM.ICU.Text.RBBINode.endMark) {
	            // These are non-empty leaf node types.
	            n.fNullable = false;
	            return;
	        }
	
	        if (n.fType == IBM.ICU.Text.RBBINode.lookAhead || n.fType == IBM.ICU.Text.RBBINode.tag) {
	            // Lookahead marker node. It's a leaf, so no recursion on children.
	            // It's nullable because it does not match any literal text from the
	            // input stream.
	            n.fNullable = true;
	            return;
	        }
	
	        // The node is not a leaf.
	        // Calculate nullable on its children.
	        CalcNullable(n.fLeftChild);
	        CalcNullable(n.fRightChild);
	
	        // Apply functions from table 3.40 in Aho
	        if (n.fType == IBM.ICU.Text.RBBINode.opOr) {
	            n.fNullable = n.fLeftChild.fNullable || n.fRightChild.fNullable;
	        } else if (n.fType == IBM.ICU.Text.RBBINode.opCat) {
	            n.fNullable = n.fLeftChild.fNullable && n.fRightChild.fNullable;
	        } else if (n.fType == IBM.ICU.Text.RBBINode.opStar || n.fType == IBM.ICU.Text.RBBINode.opQuestion) {
	            n.fNullable = true;
	        } else {
	            n.fNullable = false;
	        }
	    }
	
	    // -----------------------------------------------------------------------------
	    //
	    // calcFirstPos. Impossible to explain succinctly. See Aho, section 3.9
	    //
	    // -----------------------------------------------------------------------------
	    internal void CalcFirstPos(RBBINode n) {
	        if (n == null) {
	            return;
	        }
	        if (n.fType == IBM.ICU.Text.RBBINode.leafChar || n.fType == IBM.ICU.Text.RBBINode.endMark
	                || n.fType == IBM.ICU.Text.RBBINode.lookAhead || n.fType == IBM.ICU.Text.RBBINode.tag) {
	            // These are non-empty leaf node types.
	            ILOG.J2CsMapping.Collections.Generics.Collections.Add(n.fFirstPosSet,n);
	            return;
	        }
	
	        // The node is not a leaf.
	        // Calculate firstPos on its children.
	        CalcFirstPos(n.fLeftChild);
	        CalcFirstPos(n.fRightChild);
	
	        // Apply functions from table 3.40 in Aho
	        if (n.fType == IBM.ICU.Text.RBBINode.opOr) {
	            ILOG.J2CsMapping.Collections.Generics.Collections.AddAll(n.fLeftChild.fFirstPosSet,n.fFirstPosSet);
	            ILOG.J2CsMapping.Collections.Generics.Collections.AddAll(n.fRightChild.fFirstPosSet,n.fFirstPosSet);
	        } else if (n.fType == IBM.ICU.Text.RBBINode.opCat) {
	            ILOG.J2CsMapping.Collections.Generics.Collections.AddAll(n.fLeftChild.fFirstPosSet,n.fFirstPosSet);
	            if (n.fLeftChild.fNullable) {
	                ILOG.J2CsMapping.Collections.Generics.Collections.AddAll(n.fRightChild.fFirstPosSet,n.fFirstPosSet);
	            }
	        } else if (n.fType == IBM.ICU.Text.RBBINode.opStar || n.fType == IBM.ICU.Text.RBBINode.opQuestion
	                || n.fType == IBM.ICU.Text.RBBINode.opPlus) {
	            ILOG.J2CsMapping.Collections.Generics.Collections.AddAll(n.fLeftChild.fFirstPosSet,n.fFirstPosSet);
	        }
	    }
	
	    // -----------------------------------------------------------------------------
	    //
	    // calcLastPos. Impossible to explain succinctly. See Aho, section 3.9
	    //
	    // -----------------------------------------------------------------------------
	    internal void CalcLastPos(RBBINode n) {
	        if (n == null) {
	            return;
	        }
	        if (n.fType == IBM.ICU.Text.RBBINode.leafChar || n.fType == IBM.ICU.Text.RBBINode.endMark
	                || n.fType == IBM.ICU.Text.RBBINode.lookAhead || n.fType == IBM.ICU.Text.RBBINode.tag) {
	            // These are non-empty leaf node types.
	            ILOG.J2CsMapping.Collections.Generics.Collections.Add(n.fLastPosSet,n);
	            return;
	        }
	
	        // The node is not a leaf.
	        // Calculate lastPos on its children.
	        CalcLastPos(n.fLeftChild);
	        CalcLastPos(n.fRightChild);
	
	        // Apply functions from table 3.40 in Aho
	        if (n.fType == IBM.ICU.Text.RBBINode.opOr) {
	            ILOG.J2CsMapping.Collections.Generics.Collections.AddAll(n.fLeftChild.fLastPosSet,n.fLastPosSet);
	            ILOG.J2CsMapping.Collections.Generics.Collections.AddAll(n.fRightChild.fLastPosSet,n.fLastPosSet);
	        } else if (n.fType == IBM.ICU.Text.RBBINode.opCat) {
	            ILOG.J2CsMapping.Collections.Generics.Collections.AddAll(n.fRightChild.fLastPosSet,n.fLastPosSet);
	            if (n.fRightChild.fNullable) {
	                ILOG.J2CsMapping.Collections.Generics.Collections.AddAll(n.fLeftChild.fLastPosSet,n.fLastPosSet);
	            }
	        } else if (n.fType == IBM.ICU.Text.RBBINode.opStar || n.fType == IBM.ICU.Text.RBBINode.opQuestion
	                || n.fType == IBM.ICU.Text.RBBINode.opPlus) {
	            ILOG.J2CsMapping.Collections.Generics.Collections.AddAll(n.fLeftChild.fLastPosSet,n.fLastPosSet);
	        }
	    }
	
	    // -----------------------------------------------------------------------------
	    //
	    // calcFollowPos. Impossible to explain succinctly. See Aho, section 3.9
	    //
	    // -----------------------------------------------------------------------------
	    internal void CalcFollowPos(RBBINode n) {
	        if (n == null || n.fType == IBM.ICU.Text.RBBINode.leafChar
	                || n.fType == IBM.ICU.Text.RBBINode.endMark) {
	            return;
	        }
	
	        CalcFollowPos(n.fLeftChild);
	        CalcFollowPos(n.fRightChild);
	
	        // Aho rule #1
	        if (n.fType == IBM.ICU.Text.RBBINode.opCat) {
	            RBBINode i; // is 'i' in Aho's description
	
	            ILOG.J2CsMapping.Collections.ISet LastPosOfLeftChild = n.fLeftChild.fLastPosSet;
	
	            IIterator ix = new ILOG.J2CsMapping.Collections.IteratorAdapter(LastPosOfLeftChild.GetEnumerator());
	            while (ix.HasNext()) {
	                i = (RBBINode) ix.Next();
	                ILOG.J2CsMapping.Collections.Generics.Collections.AddAll(n.fRightChild.fFirstPosSet,i.fFollowPos);
	            }
	        }
	
	        // Aho rule #2
	        if (n.fType == IBM.ICU.Text.RBBINode.opStar || n.fType == IBM.ICU.Text.RBBINode.opPlus) {
	            RBBINode i_0; // again, n and i are the names from Aho's description.
	            IIterator ix_1 = new ILOG.J2CsMapping.Collections.IteratorAdapter(n.fLastPosSet.GetEnumerator());
	            while (ix_1.HasNext()) {
	                i_0 = (RBBINode) ix_1.Next();
	                ILOG.J2CsMapping.Collections.Generics.Collections.AddAll(n.fFirstPosSet,i_0.fFollowPos);
	            }
	
	        }
	
	    }
	
	    // -----------------------------------------------------------------------------
	    //
	    // calcChainedFollowPos. Modify the previously calculated followPos sets
	    // to implement rule chaining. NOT described by Aho
	    //
	    // -----------------------------------------------------------------------------
	    internal void CalcChainedFollowPos(RBBINode tree) {
	
	        IList endMarkerNodes = new ArrayList();
	        IList leafNodes = new ArrayList();
	
	        // get a list of all endmarker nodes.
	        tree.FindNodes(endMarkerNodes, IBM.ICU.Text.RBBINode.endMark);
	
	        // get a list all leaf nodes
	        tree.FindNodes(leafNodes, IBM.ICU.Text.RBBINode.leafChar);
	
	        // Get all nodes that can be the start a match, which is FirstPosition()
	        // of the portion of the tree corresponding to user-written rules.
	        // See the tree description in bofFixup().
	        RBBINode userRuleRoot = tree;
	        if (fRB.fSetBuilder.SawBOF()) {
	            userRuleRoot = tree.fLeftChild.fRightChild;
	        }
	        IBM.ICU.Impl.Assert.Assrt(userRuleRoot != null);
	        ILOG.J2CsMapping.Collections.ISet matchStartNodes = userRuleRoot.fFirstPosSet;
	
	        // Iteratate over all leaf nodes,
	        //
	        IIterator endNodeIx = new ILOG.J2CsMapping.Collections.IteratorAdapter(leafNodes.GetEnumerator());
	
	        while (endNodeIx.HasNext()) {
	            RBBINode tNode = (RBBINode) endNodeIx.Next();
	            RBBINode endNode = null;
	
	            // Identify leaf nodes that correspond to overall rule match
	            // positions.
	            // These include an endMarkerNode in their followPos sets.
	            IIterator i = new ILOG.J2CsMapping.Collections.IteratorAdapter(endMarkerNodes.GetEnumerator());
	            while (i.HasNext()) {
	                RBBINode endMarkerNode = (RBBINode) i.Next();
	                if (ILOG.J2CsMapping.Collections.Collections.Contains(endMarkerNode,tNode.fFollowPos)) {
	                    endNode = tNode;
	                    break;
	                }
	            }
	            if (endNode == null) {
	                // node wasn't an end node. Try again with the next.
	                continue;
	            }
	
	            // We've got a node that can end a match.
	
	            // Line Break Specific hack: If this node's val correspond to the
	            // $CM char class,
	            // don't chain from it.
	            // TODO: Add rule syntax for this behavior, get specifics out of
	            // here and
	            // into the rule file.
	            if (fRB.fLBCMNoChain) {
	                int c = this.fRB.fSetBuilder.GetFirstChar(endNode.fVal);
	                if (c != -1) {
	                    // c == -1 occurs with sets containing only the {eof} marker
	                    // string.
	                    int cLBProp = IBM.ICU.Lang.UCharacter.GetIntPropertyValue(c,
	                            IBM.ICU.Lang.UProperty_Constants.LINE_BREAK);
	                    if (cLBProp == IBM.ICU.Lang.UCharacter.LineBreak.COMBINING_MARK) {
	                        continue;
	                    }
	                }
	            }
	
	            // Now iterate over the nodes that can start a match, looking for
	            // ones
	            // with the same char class as our ending node.
	            RBBINode startNode;
	            IIterator startNodeIx = new ILOG.J2CsMapping.Collections.IteratorAdapter(matchStartNodes.GetEnumerator());
	            while (startNodeIx.HasNext()) {
	                startNode = (RBBINode) startNodeIx.Next();
	                if (startNode.fType != IBM.ICU.Text.RBBINode.leafChar) {
	                    continue;
	                }
	
	                if (endNode.fVal == startNode.fVal) {
	                    // The end val (character class) of one possible match is
	                    // the
	                    // same as the start of another.
	
	                    // Add all nodes from the followPos of the start node to the
	                    // followPos set of the end node, which will have the effect
	                    // of
	                    // letting matches transition from a match state at endNode
	                    // to the second char of a match starting with startNode.
	                    ILOG.J2CsMapping.Collections.Generics.Collections.AddAll(startNode.fFollowPos,endNode.fFollowPos);
	                }
	            }
	        }
	    }
	
	    // -----------------------------------------------------------------------------
	    //
	    // bofFixup. Fixup for state tables that include {bof} beginning of input
	    // testing.
	    // Do an swizzle similar to chaining, modifying the followPos set of
	    // the bofNode to include the followPos nodes from other {bot} nodes
	    // scattered through the tree.
	    //
	    // This function has much in common with calcChainedFollowPos().
	    //
	    // -----------------------------------------------------------------------------
	    internal void BofFixup() {
	        //
	        // The parse tree looks like this ...
	        // fTree root --. <cat>
	        // / \
	        // <cat> <#end node>
	        // / \
	        // <bofNode> rest
	        // of tree
	        //
	        // We will be adding things to the followPos set of the <bofNode>
	        //
	        RBBINode bofNode = fRB.fTreeRoots[fRootIx].fLeftChild.fLeftChild;
	        IBM.ICU.Impl.Assert.Assrt(bofNode.fType == IBM.ICU.Text.RBBINode.leafChar);
	        IBM.ICU.Impl.Assert.Assrt(bofNode.fVal == 2);
	
	        // Get all nodes that can be the start a match of the user-written rules
	        // (excluding the fake bofNode)
	        // We want the nodes that can start a match in the
	        // part labeled "rest of tree"
	        //
	        ILOG.J2CsMapping.Collections.ISet matchStartNodes = fRB.fTreeRoots[fRootIx].fLeftChild.fRightChild.fFirstPosSet;
	        IIterator startNodeIt = new ILOG.J2CsMapping.Collections.IteratorAdapter(matchStartNodes.GetEnumerator());
	        while (startNodeIt.HasNext()) {
	            RBBINode startNode = (RBBINode) startNodeIt.Next();
	            if (startNode.fType != IBM.ICU.Text.RBBINode.leafChar) {
	                continue;
	            }
	
	            if (startNode.fVal == bofNode.fVal) {
	                // We found a leaf node corresponding to a {bof} that was
	                // explicitly written into a rule.
	                // Add everything from the followPos set of this node to the
	                // followPos set of the fake bofNode at the start of the tree.
	                //
	                ILOG.J2CsMapping.Collections.Generics.Collections.AddAll(startNode.fFollowPos,bofNode.fFollowPos);
	            }
	        }
	    }
	
	    // -----------------------------------------------------------------------------
	    //
	    // buildStateTable() Determine the set of runtime DFA states and the
	    // transition tables for these states, by the algorithm
	    // of fig. 3.44 in Aho.
	    //
	    // Most of the comments are quotes of Aho's psuedo-code.
	    //
	    // -----------------------------------------------------------------------------
	    internal void BuildStateTable() {
	        //
	        // Add a dummy state 0 - the stop state. Not from Aho.
	        int lastInputSymbol = fRB.fSetBuilder.GetNumCharCategories() - 1;
	        RBBITableBuilder.RBBIStateDescriptor  failState = new RBBITableBuilder.RBBIStateDescriptor (lastInputSymbol);
	        ILOG.J2CsMapping.Collections.Generics.Collections.Add(fDStates,failState);
	
	        // initially, the only unmarked state in Dstates is firstpos(root),
	        // where toot is the root of the syntax tree for (r)#;
	        RBBITableBuilder.RBBIStateDescriptor  initialState = new RBBITableBuilder.RBBIStateDescriptor (
	                lastInputSymbol);
	        ILOG.J2CsMapping.Collections.Generics.Collections.AddAll(fRB.fTreeRoots[fRootIx].fFirstPosSet,initialState.fPositions);
	        ILOG.J2CsMapping.Collections.Generics.Collections.Add(fDStates,initialState);
	
	        // while there is an unmarked state T in Dstates do begin
	        for (;;) {
	            RBBITableBuilder.RBBIStateDescriptor  T = null;
	            int tx;
	            for (tx = 1; tx < fDStates.Count; tx++) {
	                RBBITableBuilder.RBBIStateDescriptor  temp = (RBBITableBuilder.RBBIStateDescriptor ) fDStates[tx];
	                if (temp.fMarked == false) {
	                    T = temp;
	                    break;
	                }
	            }
	            if (T == null) {
	                break;
	            }
	
	            // mark T;
	            T.fMarked = true;
	
	            // for each input symbol a do begin
	            int a;
	            for (a = 1; a <= lastInputSymbol; a++) {
	                // let U be the set of positions that are in followpos(p)
	                // for some position p in T
	                // such that the symbol at position p is a;
	                ILOG.J2CsMapping.Collections.ISet U = null;
	                RBBINode p;
	                IIterator pit = new ILOG.J2CsMapping.Collections.IteratorAdapter(T.fPositions.GetEnumerator());
	                while (pit.HasNext()) {
	                    p = (RBBINode) pit.Next();
	                    if ((p.fType == IBM.ICU.Text.RBBINode.leafChar) && (p.fVal == a)) {
	                        if (U == null) {
	                            U = new HashedSet();
	                        }
	                        ILOG.J2CsMapping.Collections.Generics.Collections.AddAll(p.fFollowPos,U);
	                    }
	                }
	
	                // if U is not empty and not in DStates then
	                int ux = 0;
	                bool UinDstates = false;
	                if (U != null) {
	                    IBM.ICU.Impl.Assert.Assrt(U.Count > 0);
	                    int ix;
	                    for (ix = 0; ix < fDStates.Count; ix++) {
	                        RBBITableBuilder.RBBIStateDescriptor  temp2;
	                        temp2 = (RBBITableBuilder.RBBIStateDescriptor ) fDStates[ix];
	                        if (U.Equals(temp2.fPositions)) {
	                            U = temp2.fPositions;
	                            ux = ix;
	                            UinDstates = true;
	                            break;
	                        }
	                    }
	
	                    // Add U as an unmarked state to Dstates
	                    if (!UinDstates) {
	                        RBBITableBuilder.RBBIStateDescriptor  newState = new RBBITableBuilder.RBBIStateDescriptor (
	                                lastInputSymbol);
	                        newState.fPositions = U;
	                        ILOG.J2CsMapping.Collections.Generics.Collections.Add(fDStates,newState);
	                        ux = fDStates.Count - 1;
	                    }
	
	                    // Dtran[T, a] := U;
	                    T.fDtran[a] = ux;
	                }
	            }
	        }
	    }
	
	    // -----------------------------------------------------------------------------
	    //
	    // flagAcceptingStates Identify accepting states.
	    // First get a list of all of the end marker nodes.
	    // Then, for each state s,
	    // if s contains one of the end marker nodes in its list of tree positions
	    // then
	    // s is an accepting state.
	    //
	    // -----------------------------------------------------------------------------
	    internal void FlagAcceptingStates() {
	        IList endMarkerNodes = new ArrayList();
	        RBBINode endMarker;
	        int i;
	        int n;
	
	        fRB.fTreeRoots[fRootIx].FindNodes(endMarkerNodes, IBM.ICU.Text.RBBINode.endMark);
	
	        for (i = 0; i < endMarkerNodes.Count; i++) {
	            endMarker = (RBBINode) endMarkerNodes[i];
	            for (n = 0; n < fDStates.Count; n++) {
	                RBBITableBuilder.RBBIStateDescriptor  sd = (RBBITableBuilder.RBBIStateDescriptor ) fDStates[n];
	                // if (sd.fPositions.indexOf(endMarker) >= 0) {
	                if (ILOG.J2CsMapping.Collections.Collections.Contains(endMarker,sd.fPositions)) {
	                    // Any non-zero value for fAccepting means this is an
	                    // accepting node.
	                    // The value is what will be returned to the user as the
	                    // break status.
	                    // If no other value was specified, force it to -1.
	
	                    if (sd.fAccepting == 0) {
	                        // State hasn't been marked as accepting yet. Do it now.
	                        sd.fAccepting = endMarker.fVal;
	                        if (sd.fAccepting == 0) {
	                            sd.fAccepting = -1;
	                        }
	                    }
	                    if (sd.fAccepting == -1 && endMarker.fVal != 0) {
	                        // Both lookahead and non-lookahead accepting for this
	                        // state.
	                        // Favor the look-ahead. Expedient for line break.
	                        // TODO: need a more elegant resolution for conflicting
	                        // rules.
	                        sd.fAccepting = endMarker.fVal;
	                    }
	                    // implicit else:
	                    // if sd.fAccepting already had a value other than 0 or -1,
	                    // leave it be.
	
	                    // If the end marker node is from a look-ahead rule, set
	                    // the fLookAhead field or this state also.
	                    if (endMarker.fLookAheadEnd) {
	                        // TODO: don't change value if already set?
	                        // TODO: allow for more than one active look-ahead rule
	                        // in engine.
	                        // Make value here an index to a side array in engine?
	                        sd.fLookAhead = sd.fAccepting;
	                    }
	                }
	            }
	        }
	    }
	
	    // -----------------------------------------------------------------------------
	    //
	    // flagLookAheadStates Very similar to flagAcceptingStates, above.
	    //
	    // -----------------------------------------------------------------------------
	    internal void FlagLookAheadStates() {
	        IList lookAheadNodes = new ArrayList();
	        RBBINode lookAheadNode;
	        int i;
	        int n;
	
	        fRB.fTreeRoots[fRootIx].FindNodes(lookAheadNodes, IBM.ICU.Text.RBBINode.lookAhead);
	        for (i = 0; i < lookAheadNodes.Count; i++) {
	            lookAheadNode = (RBBINode) lookAheadNodes[i];
	
	            for (n = 0; n < fDStates.Count; n++) {
	                RBBITableBuilder.RBBIStateDescriptor  sd = (RBBITableBuilder.RBBIStateDescriptor ) fDStates[n];
	                if (ILOG.J2CsMapping.Collections.Collections.Contains(lookAheadNode,sd.fPositions)) {
	                    sd.fLookAhead = lookAheadNode.fVal;
	                }
	            }
	        }
	    }
	
	    // -----------------------------------------------------------------------------
	    //
	    // flagTaggedStates
	    //
	    // -----------------------------------------------------------------------------
	    internal void FlagTaggedStates() {
	        IList tagNodes = new ArrayList();
	        RBBINode tagNode;
	        int i;
	        int n;
	
	        fRB.fTreeRoots[fRootIx].FindNodes(tagNodes, IBM.ICU.Text.RBBINode.tag);
	        for (i = 0; i < tagNodes.Count; i++) { // For each tag node t (all of
	                                                // 'em)
	            tagNode = (RBBINode) tagNodes[i];
	
	            for (n = 0; n < fDStates.Count; n++) { // For each state s (row in
	                                                    // the state table)
	                RBBITableBuilder.RBBIStateDescriptor  sd = (RBBITableBuilder.RBBIStateDescriptor ) fDStates[n];
	                if (ILOG.J2CsMapping.Collections.Collections.Contains(tagNode,sd.fPositions)) { // if s include the tag
	                                                       // node t
	                    ILOG.J2CsMapping.Collections.Generics.Collections.Add(sd.fTagVals,((int)(tagNode.fVal)));
	                }
	            }
	        }
	    }
	
	    // -----------------------------------------------------------------------------
	    //
	    // mergeRuleStatusVals
	    //
	    // Allocate positions in the global array of rule status {tag} values
	    //
	    // The RBBI runtime uses an array of {sets of status values} that can
	    // be returned for boundaries. Each accepting state that has non-zero
	    // status includes an index into this array. The format of the array
	    // is
	    // Num of status values in group 1
	    // status val
	    // status val
	    // ...
	    // Num of status vals in group 2
	    // status val
	    // status val
	    // ...
	    // etc.
	    //
	    //
	    // -----------------------------------------------------------------------------
	
	    internal void MergeRuleStatusVals() {
	        //
	        // The basic outline of what happens here is this...
	        //
	        // for each state in this state table
	        // if the status tag list for this state is in the global statuses list
	        // record where and
	        // continue with the next state
	        // else
	        // add the tag list for this state to the global list.
	        //
	        int n;
	
	        // Pre-load a single tag of {0} into the table.
	        // We will need this as a default, for rule sets with no explicit
	        // tagging,
	        // or with explicit tagging of {0}.
	        if (fRB.fRuleStatusVals.Count == 0) {
	            ILOG.J2CsMapping.Collections.Generics.Collections.Add(fRB.fRuleStatusVals,((int)(1))); // Num of statuses in group
	            ILOG.J2CsMapping.Collections.Generics.Collections.Add(fRB.fRuleStatusVals,((int)(0))); // and our single status of
	                                                     // zero
	
	            SortedSet s0 = new SortedSet();
	            Int32 izero = ((int)(0));
	            ILOG.J2CsMapping.Collections.Collections.Put(fRB.fStatusSets,s0,izero);
	            SortedSet s1 = new SortedSet();
	            ILOG.J2CsMapping.Collections.Generics.Collections.Add(s1,izero);
	            ILOG.J2CsMapping.Collections.Collections.Put(fRB.fStatusSets,s0,izero);
	        }
	
	        // For each state, check whether the state's status tag values are
	        // already entered into the status values array, and add them if not.
	        for (n = 0; n < fDStates.Count; n++) {
	            RBBITableBuilder.RBBIStateDescriptor  sd = (RBBITableBuilder.RBBIStateDescriptor ) fDStates[n];
	            ILOG.J2CsMapping.Collections.ISet statusVals = sd.fTagVals;
	            Int32 arrayIndexI = (Int32) ILOG.J2CsMapping.Collections.Collections.Get(fRB.fStatusSets,statusVals);
	            if (arrayIndexI == null) {
	                // This is the first encounter of this set of status values.
	                // Add them to the statusSets map, This map associates
	                // the set of status values with an index in the runtime status
	                // values array.
	                arrayIndexI = ((int)(fRB.fRuleStatusVals.Count));
	                ILOG.J2CsMapping.Collections.Collections.Put(fRB.fStatusSets,statusVals,arrayIndexI);
	
	                // Add the new set of status values to the vector of values that
	                // will eventually become the array used by the runtime engine.
	                ILOG.J2CsMapping.Collections.Generics.Collections.Add(fRB.fRuleStatusVals,((int)(statusVals.Count)));
	                IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(statusVals.GetEnumerator());
	                while (it.HasNext()) {
	                    ILOG.J2CsMapping.Collections.Generics.Collections.Add(fRB.fRuleStatusVals,it.Next());
	                }
	
	            }
	
	            // Save the runtime array index back into the state descriptor.
	            sd.fTagsIdx = arrayIndexI;
	        }
	    }
	
	    // -----------------------------------------------------------------------------
	    //
	    // printPosSets Debug function. Dump Nullable, firstpos, lastpos and
	    // followpos
	    // for each node in the tree.
	    //
	    // -----------------------------------------------------------------------------
	
	    internal void PrintPosSets(RBBINode n) {
	        if (n == null) {
	            return;
	        }
	        IBM.ICU.Text.RBBINode.PrintNode(n);
	        System.Console.Out.Write("         Nullable:  " + n.fNullable);
	
	        System.Console.Out.Write("         firstpos:  ");
	        PrintSet(n.fFirstPosSet);
	
	        System.Console.Out.Write("         lastpos:   ");
	        PrintSet(n.fLastPosSet);
	
	        System.Console.Out.Write("         followpos: ");
	        PrintSet(n.fFollowPos);
	
	        PrintPosSets(n.fLeftChild);
	        PrintPosSets(n.fRightChild);
	    }
	
	    // -----------------------------------------------------------------------------
	    //
	    // getTableSize() Calculate the size in bytes of the runtime form of this
	    // state transition table.
	    //
	    // Note: Refer to common/rbbidata.h from ICU4C for the declarations
	    // of the structures being matched by this calculation.
	    //
	    // -----------------------------------------------------------------------------
	    internal int GetTableSize() {
	        int size = 0;
	        int numRows;
	        int numCols;
	        int rowSize;
	
	        if (fRB.fTreeRoots[fRootIx] == null) {
	            return 0;
	        }
	
	        size = /* sizeof(RBBIStateTable) - 4 */16; // The header, with no rows
	                                                   // to the table.
	
	        numRows = fDStates.Count;
	        numCols = fRB.fSetBuilder.GetNumCharCategories();
	
	        // Note The declaration of RBBIStateTableRow is for a table of two
	        // columns.
	        // Therefore we subtract two from numCols when determining
	        // how much storage to add to a row for the total columns.
	        // rowSize = sizeof(RBBIStateTableRow) + sizeof(uint16_t)*(numCols-2);
	        rowSize = 8 + 2 * numCols;
	        size += numRows * rowSize;
	        while (size % 8 > 0) { // Size must be multiple of 8 bytes in size.
	            size++;
	        }
	
	        return size;
	    }
	
	    // -----------------------------------------------------------------------------
	    //
	    // exportTable() export the state transition table in the ICU4C format.
	    //
	    // Most of the table is 16 bit shorts. This function exports
	    // the whole thing as an array of shorts.
	    //
	    // The size of the array must be rounded up to a multiple of
	    // 8 bytes.
	    //
	    // See struct RBBIStateTable in ICU4C, common/rbbidata.h
	    //
	    // -----------------------------------------------------------------------------
	
	    internal short[] ExportTable() {
	        int state;
	        int col;
	
	        if (fRB.fTreeRoots[fRootIx] == null) {
	            return new short[0];
	        }
	
	        IBM.ICU.Impl.Assert.Assrt(fRB.fSetBuilder.GetNumCharCategories() < 0x7fff
	                && fDStates.Count < 0x7fff);
	
	        int numStates = fDStates.Count;
	
	        // Size of table size in shorts.
	        // the "4" is the size of struct RBBIStateTableRow, the row header part
	        // only.
	        int rowLen = 4 + fRB.fSetBuilder.GetNumCharCategories();
	        int tableSize = GetTableSize() / 2;
	
	        short[] table = new short[tableSize];
	
	        //
	        // Fill in the header fields.
	        // Annoying because they really want to be ints, not shorts.
	        //
	        // RBBIStateTable.fNumStates
	        table[IBM.ICU.Text.RBBIDataWrapper.NUMSTATES] = (short) ((int) (((uint) numStates) >> 16));
	        table[IBM.ICU.Text.RBBIDataWrapper.NUMSTATES + 1] = (short) (numStates & 0x0000ffff);
	
	        // RBBIStateTable.fRowLen
	        table[IBM.ICU.Text.RBBIDataWrapper.ROWLEN] = (short) ((int) (((uint) rowLen) >> 16));
	        table[IBM.ICU.Text.RBBIDataWrapper.ROWLEN + 1] = (short) (rowLen & 0x0000ffff);
	
	        // RBBIStateTable.fFlags
	        int flags = 0;
	        if (fRB.fLookAheadHardBreak) {
	            flags |= IBM.ICU.Text.RBBIDataWrapper.RBBI_LOOKAHEAD_HARD_BREAK;
	        }
	        if (fRB.fSetBuilder.SawBOF()) {
	            flags |= IBM.ICU.Text.RBBIDataWrapper.RBBI_BOF_REQUIRED;
	        }
	        table[IBM.ICU.Text.RBBIDataWrapper.FLAGS] = (short) ((int) (((uint) flags) >> 16));
	        table[IBM.ICU.Text.RBBIDataWrapper.FLAGS + 1] = (short) (flags & 0x0000ffff);
	
	        int numCharCategories = fRB.fSetBuilder.GetNumCharCategories();
	        for (state = 0; state < numStates; state++) {
	            RBBITableBuilder.RBBIStateDescriptor  sd = (RBBITableBuilder.RBBIStateDescriptor ) fDStates[state];
	            int row = 8 + state * rowLen;
	            IBM.ICU.Impl.Assert.Assrt(-32768 < sd.fAccepting && sd.fAccepting <= 32767);
	            IBM.ICU.Impl.Assert.Assrt(-32768 < sd.fLookAhead && sd.fLookAhead <= 32767);
	            table[row + IBM.ICU.Text.RBBIDataWrapper.ACCEPTING] = (short) sd.fAccepting;
	            table[row + IBM.ICU.Text.RBBIDataWrapper.LOOKAHEAD] = (short) sd.fLookAhead;
	            table[row + IBM.ICU.Text.RBBIDataWrapper.TAGIDX] = (short) sd.fTagsIdx;
	            for (col = 0; col < numCharCategories; col++) {
	                table[row + IBM.ICU.Text.RBBIDataWrapper.NEXTSTATES + col] = (short) sd.fDtran[col];
	            }
	        }
	        return table;
	    }
	
	    // -----------------------------------------------------------------------------
	    //
	    // printSet Debug function. Print the contents of a set of Nodes
	    //
	    // -----------------------------------------------------------------------------
	
	    internal void PrintSet(ICollection s) {
	        IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(s.GetEnumerator());
	        while (it.HasNext()) {
	            RBBINode n = (RBBINode) it.Next();
	            IBM.ICU.Text.RBBINode.PrintInt(n.fSerialNum, 8);
	        }
	        System.Console.Out.WriteLine();
	    }
	
	    // -----------------------------------------------------------------------------
	    //
	    // printStates Debug Function. Dump the fully constructed state transition
	    // table.
	    //
	    // -----------------------------------------------------------------------------
	
	    internal void PrintStates() {
	        int c; // input "character"
	        int n; // state number
	
	        System.Console.Out.Write("state |           i n p u t     s y m b o l s \n");
	        System.Console.Out.Write("      | Acc  LA    Tag");
	        for (c = 0; c < fRB.fSetBuilder.GetNumCharCategories(); c++) {
	            IBM.ICU.Text.RBBINode.PrintInt((int) c, 3);
	        }
	        System.Console.Out.Write("\n");
	        System.Console.Out.Write("      |---------------");
	        for (c = 0; c < fRB.fSetBuilder.GetNumCharCategories(); c++) {
	            System.Console.Out.Write("---");
	        }
	        System.Console.Out.Write("\n");
	
	        for (n = 0; n < fDStates.Count; n++) {
	            RBBITableBuilder.RBBIStateDescriptor  sd = (RBBITableBuilder.RBBIStateDescriptor ) fDStates[n];
	            IBM.ICU.Text.RBBINode.PrintInt(n, 5);
	            System.Console.Out.Write(" | ");
	
	            IBM.ICU.Text.RBBINode.PrintInt(sd.fAccepting, 3);
	            IBM.ICU.Text.RBBINode.PrintInt(sd.fLookAhead, 4);
	            IBM.ICU.Text.RBBINode.PrintInt(sd.fTagsIdx, 6);
	            System.Console.Out.Write(" ");
	            for (c = 0; c < fRB.fSetBuilder.GetNumCharCategories(); c++) {
	                IBM.ICU.Text.RBBINode.PrintInt(sd.fDtran[c], 3);
	            }
	            System.Console.Out.Write("\n");
	        }
	        System.Console.Out.Write("\n\n");
	    }
	
	    // -----------------------------------------------------------------------------
	    //
	    // printRuleStatusTable Debug Function. Dump the common rule status table
	    //
	    // -----------------------------------------------------------------------------
	
	    internal void PrintRuleStatusTable() {
	        int thisRecord = 0;
	        int nextRecord = 0;
	        int i;
	        IList tbl = fRB.fRuleStatusVals;
	
	        System.Console.Out.Write("index |  tags \n");
	        System.Console.Out.Write("-------------------\n");
	
	        while (nextRecord < tbl.Count) {
	            thisRecord = nextRecord;
	            nextRecord = thisRecord
	                    + ((Int32) tbl[thisRecord]) + 1;
	            IBM.ICU.Text.RBBINode.PrintInt(thisRecord, 7);
	            for (i = thisRecord + 1; i < nextRecord; i++) {
	                int val = ((Int32) tbl[i]);
	                IBM.ICU.Text.RBBINode.PrintInt(val, 7);
	            }
	            System.Console.Out.Write("\n");
	        }
	        System.Console.Out.Write("\n\n");
	    }
	
	}
}
