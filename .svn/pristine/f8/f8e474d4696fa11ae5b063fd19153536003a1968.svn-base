// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:47 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2001-2006, International Business Machines Corporation and    
/// others. All Rights Reserved.                                                
/// </summary>
///
namespace IBM.ICU.Impl {
	
	using ILOG.J2CsMapping.Collections;
	using ILOG.J2CsMapping.Collections.Generics;
	using ILOG.J2CsMapping.Threading;
	using ILOG.J2CsMapping.Util;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Threading;
	
	/// <summary>
	/// <p>
	/// Abstract implementation of a notification facility. Clients add
	/// EventListeners with addListener and remove them with removeListener.
	/// Notifiers call notifyChanged when they wish to notify listeners. This queues
	/// the listener list on the notification thread, which eventually dequeues the
	/// list and calls notifyListener on each listener in the list.
	/// </p>
	/// <p>
	/// Subclasses override acceptsListener and notifyListener to add type-safe
	/// notification. AcceptsListener should return true if the listener is of the
	/// appropriate type; ICUNotifier itself will ensure the listener is non-null and
	/// that the identical listener is not already registered with the Notifier.
	/// NotifyListener should cast the listener to the appropriate type and call the
	/// appropriate method on the listener.
	/// </summary>
	///
	public abstract class ICUNotifier {
	    public ICUNotifier() {
	        this.notifyLock = new Object();
	    }
	
	    private readonly Object notifyLock;
	
	    private ICUNotifier.NotifyThread  notifyThread;
	
	    private IList listeners;
	
	    /// <summary>
	    /// Add a listener to be notified when notifyChanged is called. The listener
	    /// must not be null. AcceptsListener must return true for the listener.
	    /// Attempts to concurrently register the identical listener more than once
	    /// will be silently ignored.
	    /// </summary>
	    ///
	    public void AddListener(IEventListener l) {
	        if (l == null) {
	            throw new NullReferenceException();
	        }
	
	        if (AcceptsListener(l)) {
	             lock (notifyLock) {
	                            if (listeners == null) {
	                                listeners = new ArrayList(5);
	                            } else {
	                                // identity equality check
	                                IIterator iter = new ILOG.J2CsMapping.Collections.IteratorAdapter(listeners.GetEnumerator());
	                                while (iter.HasNext()) {
	                                    if (iter.Next() == (Object) l) {
	                                        return;
	                                    }
	                                }
	                            }
	            
	                            ILOG.J2CsMapping.Collections.Generics.Collections.Add(listeners,l);
	                        }
	        } else {
	            throw new InvalidOperationException(
	                    "Listener invalid for this notifier.");
	        }
	    }
	
	    /// <summary>
	    /// Stop notifying this listener. The listener must not be null. Attemps to
	    /// remove a listener that is not registered will be silently ignored.
	    /// </summary>
	    ///
	    public void RemoveListener(IEventListener l) {
	        if (l == null) {
	            throw new NullReferenceException();
	        }
	         lock (notifyLock) {
	                    if (listeners != null) {
	                        // identity equality check
	                        IIterator iter = new ILOG.J2CsMapping.Collections.IteratorAdapter(listeners.GetEnumerator());
	                        while (iter.HasNext()) {
	                            if (iter.Next() == (Object) l) {
	                                iter.Remove();
	                                if (listeners.Count == 0) {
	                                    listeners = null;
	                                }
	                                return;
	                            }
	                        }
	                    }
	                }
	    }
	
	    /// <summary>
	    /// Queue a notification on the notification thread for the current
	    /// listeners. When the thread unqueues the notification, notifyListener is
	    /// called on each listener from the notification thread.
	    /// </summary>
	    ///
	    public void NotifyChanged() {
	        if (listeners != null) {
	             lock (notifyLock) {
	                            if (listeners != null) {
	                                if (notifyThread == null) {
	                                    notifyThread = new ICUNotifier.NotifyThread (this);
	                                    notifyThread.IsDaemon = true;
	                                    notifyThread.Start();
	                                }
	                                notifyThread.Queue(ILOG.J2CsMapping.Collections.Collections.ToArray(listeners));
	                            }
	                        }
	        }
	    }
	
	    /// <summary>
	    /// The notification thread.
	    /// </summary>
	    ///
	    private class NotifyThread : ThreadWrapper {
	        private readonly ICUNotifier notifier;
	
	        private readonly IList queue;
	
	        internal NotifyThread(ICUNotifier notifier_0) {
	            this.queue = new LinkedList();
	            this.notifier = notifier_0;
	        }
	
	        /// <summary>
	        /// Queue the notification on the thread.
	        /// </summary>
	        ///
	        public void Queue(Object[] list) {
	             lock (this) {
	                            ILOG.J2CsMapping.Collections.Generics.Collections.Add(queue,list);
                     
	                            ThreadUtil.Notify(this);
	                        }
	        }
	
	        /// <summary>
	        /// Wait for a notification to be queued, then notify all listeners
	        /// listed in the notification.
	        /// </summary>
	        ///
	        public override void Run() {
	            Object[] list;
	            while (true) {
	                try {
	                     lock (this) {
	                                            while ((queue.Count==0)) {
	                                                ILOG.J2CsMapping.Threading.ThreadUtil.Wait(this);
	                                            }
	                                            list = (Object[]) ILOG.J2CsMapping.Collections.Collections.RemoveAt(queue,0);
	                                        }
	
	                    for (int i = 0; i < list.Length; ++i) {
	                        notifier.NotifyListener((IEventListener) list[i]);
	                    }
	                } catch (ThreadInterruptedException e) {
	                }
	            }
	        }
	    }
	
	    /// <summary>
	    /// Subclasses implement this to return true if the listener is of the
	    /// appropriate type.
	    /// </summary>
	    ///
	    protected abstract internal bool AcceptsListener(IEventListener l);
	
	    /// <summary>
	    /// Subclasses implement this to notify the listener.
	    /// </summary>
	    ///
	    protected abstract internal void NotifyListener(IEventListener l);
	}
}
