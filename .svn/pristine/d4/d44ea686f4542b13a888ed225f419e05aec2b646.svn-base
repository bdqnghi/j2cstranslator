// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/13/10 10:46 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2002-2004, International Business Machines Corporation and    
/// others. All Rights Reserved.                                                
/// </summary>
///
namespace IBM.ICU.Charset {
	
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Text;
	
	/// <summary>
	/// Utility class for supplementary code point support. This one is written
	/// purely for updating Normalization sample from the unicode.org site. If you
	/// want the real thing, use UTF16 class from ICU4J
	/// </summary>
	///
	public class UTF16Util {
	    internal const int suppOffset = (0xd800 << 10) + 0xdc00 - 0x10000;
	
	    /// <summary>
	    /// Method nextCodePoint. Returns the next code point in a string.
	    /// </summary>
	    ///
	    /// <param name="s">String in question</param>
	    /// <param name="i">index from which we want a code point</param>
	    /// <returns>int codepoint at index i</returns>
	    public static int NextCodePoint(String s, int i) {
	        int ch = s[i];
	        if (0xd800 <= ch && ch <= 0xdbff && ++i < s.Length) {
	            int ch2 = s[i];
	            if (0xdc00 <= ch2 && ch2 <= 0xdfff) {
	                ch = (ch << 10) + ch2 - suppOffset;
	            }
	        }
	        return ch;
	    }
	
	    /// <summary>
	    /// Method prevCodePoint. Gets the code point preceding index i
	    /// (predecrement).
	    /// </summary>
	    ///
	    /// <param name="s">String in question</param>
	    /// <param name="i">index in string</param>
	    /// <returns>int codepoint at index --i</returns>
	    public static int PrevCodePoint(String s, int i) {
	        int ch = s[--i];
	        if (0xdc00 <= ch && ch <= 0xdfff && --i >= 0) {
	            int ch2 = s[i];
	            if (0xd800 <= ch2 && ch2 <= 0xdbff) {
	                ch = (ch2 << 10) + ch - suppOffset;
	            }
	        }
	        return ch;
	    }
	
	    /// <summary>
	    /// Method nextCodePoint. Returns the next code point in a string.
	    /// </summary>
	    ///
	    /// <param name="s">StringBuffer in question</param>
	    /// <param name="i">index from which we want a code point</param>
	    /// <returns>int codepoint at index i</returns>
	    public static int NextCodePoint(StringBuilder s, int i) {
	        int ch = s[i];
	        if (0xd800 <= ch && ch <= 0xdbff && ++i < s.Length) {
	            int ch2 = s[i];
	            if (0xdc00 <= ch2 && ch2 <= 0xdfff) {
	                ch = (ch << 10) + ch2 - suppOffset;
	            }
	        }
	        return ch;
	    }
	
	    /// <summary>
	    /// Method prevCodePoint. Gets the code point preceding index i
	    /// (predecrement).
	    /// </summary>
	    ///
	    /// <param name="s">StringBuffer in question</param>
	    /// <param name="i">index in string</param>
	    /// <returns>int codepoint at index --i</returns>
	    public static int PrevCodePoint(StringBuilder s, int i) {
	        int ch = s[--i];
	        if (0xdc00 <= ch && ch <= 0xdfff && --i >= 0) {
	            int ch2 = s[i];
	            if (0xd800 <= ch2 && ch2 <= 0xdbff) {
	                ch = (ch2 << 10) + ch - suppOffset;
	            }
	        }
	        return ch;
	    }
	
	    /// <summary>
	    /// Method codePointLength. Returns the length in UTF-16 code units of a
	    /// given code point
	    /// </summary>
	    ///
	    /// <param name="c">code point in question</param>
	    /// <returns>int length in UTF-16 code units. Can be 1 or 2</returns>
	    public static int CodePointLength(int c) {
	        return (c <= 0xffff) ? 1 : 2;
	    }
	
	    /// <summary>
	    /// Method appendCodePoint. Appends a code point to a StringBuffer
	    /// </summary>
	    ///
	    /// <param name="buffer">StringBuffer in question</param>
	    /// <param name="ch">code point to append</param>
	    public static void AppendCodePoint(StringBuilder buffer, int ch) {
	        if (ch <= 0xffff) {
	            buffer.Append((char) ch);
	        } else {
	            buffer.Append((char) (0xd7c0 + (ch >> 10)));
	            buffer.Append((char) (0xdc00 + (ch & 0x3ff)));
	        }
	    }
	
	    /// <summary>
	    /// Method insertCodePoint. Inserts a code point in a StringBuffer
	    /// </summary>
	    ///
	    /// <param name="buffer">StringBuffer in question</param>
	    /// <param name="i">index at which we want code point to be inserted</param>
	    /// <param name="ch">code point to be inserted</param>
	    public static void InsertCodePoint(StringBuilder buffer, int i, int ch) {
	        if (ch <= 0xffff) {
	            buffer.Insert(i, (char) ch);
	        } else {
	            buffer.Insert(i, (char) (0xd7c0 + (ch >> 10))).Insert(i + 1,
	                    (char) (0xdc00 + (ch & 0x3ff)));
	        }
	    }
	
	    /// <summary>
	    /// Method setCodePointAt. Changes a code point at a given index. Can change
	    /// the length of the string.
	    /// </summary>
	    ///
	    /// <param name="buffer">StringBuffer in question</param>
	    /// <param name="i">index at which we want to change the contents</param>
	    /// <param name="ch">replacement code point</param>
	    /// <returns>int difference in resulting StringBuffer length</returns>
	    public static int SetCodePointAt(StringBuilder buffer, int i, int ch) {
	        int cp = NextCodePoint(buffer, i);
	
	        if (ch <= 0xffff && cp <= 0xffff) { // Both BMP
	            buffer[i]=(char) ch;
	            return 0;
	        } else if (ch > 0xffff && cp > 0xffff) { // Both supplementary
	            buffer[i]=(char) (0xd7c0 + (ch >> 10));
	            buffer[i + 1]=(char) (0xdc00 + (ch & 0x3ff));
	            return 0;
	        } else if (ch <= 0xffff && cp > 0xffff) { // putting BMP instead of
	                                                  // supplementary, buffer
	                                                  // shrinks
	            buffer[i]=(char) ch;
	            buffer.Remove(i + 1,1);
	            return -1;
	        } else { // if (ch > 0xffff && cp <= 0xffff) { // putting supplementary
	                 // instead of BMP, buffer grows
	            buffer[i]=(char) (0xd7c0 + (ch >> 10));
	            buffer.Insert(i + 1, (char) (0xdc00 + (ch & 0x3ff)));
	            return 1;
	        }
	    }
	
	    /// <summary>
	    /// Method countCodePoint. Counts the UTF-32 code points in a UTF-16 encoded
	    /// string.
	    /// </summary>
	    ///
	    /// <param name="source">String in question.</param>
	    /// <returns>int number of code points in this string</returns>
	    public static int CountCodePoint(String source) {
	        int result = 0;
	        char ch;
	        bool hadLeadSurrogate = false;
	
	        for (int i = 0; i < source.Length; ++i) {
	            ch = source[i];
	            if (hadLeadSurrogate && 0xdc00 <= ch && ch <= 0xdfff) {
	                hadLeadSurrogate = false; // count valid trail as zero
	            } else {
	                hadLeadSurrogate = (0xd800 <= ch && ch <= 0xdbff);
	                ++result; // count others as 1
	            }
	        }
	
	        return result;
	    }
	
	    /// <summary>
	    /// Method countCodePoint. Counts the UTF-32 code points in a UTF-16 encoded
	    /// string.
	    /// </summary>
	    ///
	    /// <param name="source">StringBuffer in question.</param>
	    /// <returns>int number of code points in this string</returns>
	    public static int CountCodePoint(StringBuilder source) {
	        int result = 0;
	        char ch;
	        bool hadLeadSurrogate = false;
	
	        for (int i = 0; i < source.Length; ++i) {
	            ch = source[i];
	            if (hadLeadSurrogate && 0xdc00 <= ch && ch <= 0xdfff) {
	                hadLeadSurrogate = false; // count valid trail as zero
	            } else {
	                hadLeadSurrogate = (0xd800 <= ch && ch <= 0xdbff);
	                ++result; // count others as 1
	            }
	        }
	
	        return result;
	    }
	
	    /// <summary>
	    /// The minimum value for Supplementary code points
	    /// </summary>
	    ///
	    public const int SUPPLEMENTARY_MIN_VALUE = 0x10000;
	
	    /// <summary>
	    /// Determines how many chars this char32 requires. If a validity check is
	    /// required, use <code>
	    /// <a href="../UCharacter.html#isLegal(char)">isLegal()</a></code> on char32
	    /// before calling.
	    /// </summary>
	    ///
	    /// <param name="char32">the input codepoint.</param>
	    /// <returns>2 if is in supplementary space, otherwise 1.</returns>
	    public static int GetCharCount(int char32) {
	        if (char32 < SUPPLEMENTARY_MIN_VALUE) {
	            return 1;
	        }
	        return 2;
	    }
	
	    /// <summary>
	    /// Lead surrogate maximum value
	    /// </summary>
	    ///
	    /// @stable ICU 2.1
	    public const int LEAD_SURROGATE_MAX_VALUE = 0xDBFF;
	
	    /// <summary>
	    /// Lead surrogate minimum value
	    /// </summary>
	    ///
	    /// @stable ICU 2.1
	    public const int LEAD_SURROGATE_MIN_VALUE = 0xD800;
	
	    /// <summary>
	    /// Trail surrogate minimum value
	    /// </summary>
	    ///
	    /// @stable ICU 2.1
	    public const int TRAIL_SURROGATE_MIN_VALUE = 0xDC00;
	
	    /// <summary>
	    /// Trail surrogate maximum value
	    /// </summary>
	    ///
	    /// @stable ICU 2.1
	    public const int TRAIL_SURROGATE_MAX_VALUE = 0xDFFF;
	
	    /// <summary>
	    /// Determines whether the code value is a surrogate.
	    /// </summary>
	    ///
	    /// <param name="char16">the input character.</param>
	    /// <returns>true iff the input character is a surrogate.</returns>
	    /// @stable ICU 2.1
	    public static bool IsSurrogate(char char16) {
	        return LEAD_SURROGATE_MIN_VALUE <= char16
	                && char16 <= TRAIL_SURROGATE_MAX_VALUE;
	    }
	
	    /// <summary>
	    /// Determines whether the character is a trail surrogate.
	    /// </summary>
	    ///
	    /// <param name="char16">the input character.</param>
	    /// <returns>true iff the input character is a trail surrogate.</returns>
	    /// @stable ICU 2.1
	    public static bool IsTrailSurrogate(char char16) {
	        return (TRAIL_SURROGATE_MIN_VALUE <= char16 && char16 <= TRAIL_SURROGATE_MAX_VALUE);
	    }
	
	    /// <summary>
	    /// Determines whether the character is a lead surrogate.
	    /// </summary>
	    ///
	    /// <param name="char16">the input character.</param>
	    /// <returns>true iff the input character is a lead surrogate</returns>
	    /// @stable ICU 2.1
	    public static bool IsLeadSurrogate(char char16) {
	        return LEAD_SURROGATE_MIN_VALUE <= char16
	                && char16 <= LEAD_SURROGATE_MAX_VALUE;
	    }
	
	    /// <summary>
	    /// Extract a single UTF-32 value from a substring. Used when iterating
	    /// forwards or backwards (with <c>UTF16.getCharCount()</c>, as well as
	    /// random access. If a validity check is required, use
	    /// <code><a href="../UCharacter.html#isLegal(char)">UCharacter.isLegal()
	    /// </a></code> on the return value. If the char retrieved is part of a
	    /// surrogate pair, its supplementary character will be returned. If a
	    /// complete supplementary character is not found the incomplete character
	    /// will be returned
	    /// </summary>
	    ///
	    /// <param name="source">array of UTF-16 chars</param>
	    /// <param name="start">offset to substring in the source array for analyzing</param>
	    /// <param name="limit">offset to substring in the source array for analyzing</param>
	    /// <param name="offset16">UTF-16 offset relative to start</param>
	    /// <returns>UTF-32 value for the UTF-32 value that contains the char at
	    /// offset16. The boundaries of that codepoint are the same as in
	    /// <c>bounds32()</c>.</returns>
	    /// <exception cref="IndexOutOfBoundsException">thrown if offset16 is not within the range of start andlimit.</exception>
	    /// @stable ICU 2.1
	    public static int CharAt(char[] source, int start, int limit, int offset16) {
	        offset16 += start;
	        if (offset16 < start || offset16 >= limit) {
	            throw new IndexOutOfRangeException(offset16.ToString());
	        }
	
	        char single = source[offset16];
	        if (!IsSurrogate(single)) {
	            return single;
	        }
	
	        // Convert the UTF-16 surrogate pair if necessary.
	        // For simplicity in usage, and because the frequency of pairs is
	        // low, look both directions.
	        if (single <= LEAD_SURROGATE_MAX_VALUE) {
	            offset16++;
	            if (offset16 >= limit) {
	                return single;
	            }
	            char trail = source[offset16];
	            if (IsTrailSurrogate(trail)) {
	                return GetRawSupplementary(single, trail);
	            }
	        } else { // isTrailSurrogate(single), so
	            if (offset16 == start) {
	                return single;
	            }
	            offset16--;
	            char lead = source[offset16];
	            if (IsLeadSurrogate(lead))
	                return GetRawSupplementary(lead, single);
	        }
	        return single; // return unmatched surrogate
	    }
	
	    /// <summary>
	    /// Shift value for lead surrogate to form a supplementary character.
	    /// </summary>
	    ///
	    private const int LEAD_SURROGATE_SHIFT_ = 10;
	
	    /// <summary>
	    /// Offset to add to combined surrogate pair to avoid msking.
	    /// </summary>
	    ///
	    private const int SURROGATE_OFFSET_ = SUPPLEMENTARY_MIN_VALUE
	            - (LEAD_SURROGATE_MIN_VALUE << LEAD_SURROGATE_SHIFT_)
	            - TRAIL_SURROGATE_MIN_VALUE;
	
	    /// <summary>
	    /// Forms a supplementary code point from the argument character<br>
	    /// Note this is for internal use hence no checks for the validity of the
	    /// surrogate characters are done
	    /// </summary>
	    ///
	    /// <param name="lead">lead surrogate character</param>
	    /// <param name="trail">trailing surrogate character</param>
	    /// <returns>code point of the supplementary character</returns>
	    public static int GetRawSupplementary(char lead, char trail) {
	        return (lead << LEAD_SURROGATE_SHIFT_) + trail + SURROGATE_OFFSET_;
	    }
	
	}
}
