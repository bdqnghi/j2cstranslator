/*
 *******************************************************************************
 * Copyright (C) 2007, International Business Machines Corporation and         *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 */
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:48 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Util {
	
	using ILOG.J2CsMapping.Collections;
	using ILOG.J2CsMapping.Collections.Generics;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	
	/// <summary>
	/// <c>RuleBasedTimeZone</c> is a concrete subclass of
	/// <c>TimeZone</c> that allows users to define custom historic time
	/// transition rules.
	/// </summary>
	///
	/// <seealso cref="T:IBM.ICU.Util.TimeZoneRule"/>
	/// @draft ICU 3.8
	/// @provisional This API might change or be removed in a future release.
	public class RuleBasedTimeZone : BasicTimeZone {
	
	    private const long serialVersionUID = 7580833058949327935L;
	
	    private readonly InitialTimeZoneRule initialRule;
	
	    private IList historicRules;
	
	    private AnnualTimeZoneRule[] finalRules;
	
	    private IList historicTransitions;
	
	    private bool upToDate;
	
	    /// <summary>
	    /// Constructs a <c>RuleBasedTimeZone</c> object with the ID and the
	    /// <c>InitialTimeZoneRule</c>
	    /// </summary>
	    ///
	    /// <param name="id">The time zone ID.</param>
	    /// <param name="initialRule_0">The initial time zone rule.</param>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public RuleBasedTimeZone(String id, InitialTimeZoneRule initialRule_0) {
	        base.SetID(id);
	        this.initialRule = initialRule_0;
	    }
	
	    /// <summary>
	    /// Adds the <c>TimeZoneRule</c> which represents time transitions. The
	    /// <c>TimeZoneRule</c> must have start times, that is, the result of<see cref="M:IBM.ICU.Util.TimeZoneRule.IsTransitionRule"/> must be true.
	    /// Otherwise, <c>IllegalArgumentException</c> is thrown.
	    /// </summary>
	    ///
	    /// <param name="rule">The <c>TimeZoneRule</c>.</param>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public void AddTransitionRule(TimeZoneRule rule) {
	        if (!rule.IsTransitionRule()) {
	            throw new ArgumentException("Rule must be a transition rule");
	        }
	        if (rule  is  AnnualTimeZoneRule
	                && ((AnnualTimeZoneRule) rule).GetEndYear() == IBM.ICU.Util.AnnualTimeZoneRule.MAX_YEAR) {
	            // One of the final rules applicable in future forever
	            if (finalRules == null) {
	                finalRules = new AnnualTimeZoneRule[2];
	                finalRules[0] = (AnnualTimeZoneRule) rule;
	            } else if (finalRules[1] == null) {
	                finalRules[1] = (AnnualTimeZoneRule) rule;
	            } else {
	                // Only a pair of AnnualTimeZoneRule is allowed.
	                throw new InvalidOperationException("Too many final rules");
	            }
	        } else {
	            // If this is not a final rule, add it to the historic rule list
	            if (historicRules == null) {
	                historicRules = new ArrayList();
	            }
	            ILOG.J2CsMapping.Collections.Generics.Collections.Add(historicRules,rule);
	        }
	        // Mark dirty, so transitions are recalculated when offset information
	        // is
	        // accessed next time.
	        upToDate = false;
	    }
	
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public override int GetOffset(int era, int year, int month, int day, int dayOfWeek,
	            int milliseconds) {
	        if (era == IBM.ICU.Util.GregorianCalendar.BC) {
	            // Convert to extended year
	            year = 1 - year;
	        }
	        long time = IBM.ICU.Impl.Grego.FieldsToDay(year, month, day) * IBM.ICU.Impl.Grego.MILLIS_PER_DAY
	                + milliseconds;
	        int[] offsets = new int[2];
	        GetOffset(time, true, IBM.ICU.Util.BasicTimeZone.LOCAL_DST, IBM.ICU.Util.BasicTimeZone.LOCAL_STD, offsets);
	        return (offsets[0] + offsets[1]);
	    }
	
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public override void GetOffset(long time, bool local, int[] offsets) {
	        GetOffset(time, local, IBM.ICU.Util.BasicTimeZone.LOCAL_FORMER, IBM.ICU.Util.BasicTimeZone.LOCAL_LATTER, offsets);
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    public override void GetOffsetFromLocal(long date, int nonExistingTimeOpt,
	            int duplicatedTimeOpt, int[] offsets) {
	        GetOffset(date, true, nonExistingTimeOpt, duplicatedTimeOpt, offsets);
	    }
	
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public override int GetRawOffset() {
	        // Note: This implementation returns standard GMT offset
	        // as of current time.
	        long now = DateTime.Now.Millisecond;
	        int[] offsets = new int[2];
	        GetOffset(now, false, offsets);
	        return offsets[0];
	    }
	
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public override bool InDaylightTime(DateTime date) {
	        int[] offsets = new int[2];
	        GetOffset((date.Ticks/10000), false, offsets);
	        return (offsets[1] != 0);
	    }
	
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    // /CLOVER:OFF
	    public override void SetRawOffset(int offsetMillis) {
	        // TODO: Do nothing for now..
	        throw new NotSupportedException(
	                "setRawOffset in RuleBasedTimeZone is not supported.");
	    }
	
	    // /CLOVER:ON
	
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public override bool UseDaylightTime() {
	        // Note: This implementation returns true when
	        // daylight saving time is used as of now or
	        // after the next transition.
	        long now = DateTime.Now.Millisecond;
	        int[] offsets = new int[2];
	        GetOffset(now, false, offsets);
	        if (offsets[1] != 0) {
	            return true;
	        }
	        // If DST is not used now, check if DST is used after the next
	        // transition
	        TimeZoneTransition tt = GetNextTransition(now, false);
	        if (tt != null && tt.GetTo().GetDSTSavings() != 0) {
	            return true;
	        }
	        return false;
	    }
	
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public override bool HasSameRules(TimeZone other) {
	        if (!(other  is  RuleBasedTimeZone)) {
	            // We cannot reasonably compare rules in different types
	            return false;
	        }
	        RuleBasedTimeZone otherRBTZ = (RuleBasedTimeZone) other;
	
	        // initial rule
	        if (!initialRule.IsEquivalentTo(otherRBTZ.initialRule)) {
	            return false;
	        }
	
	        // final rules
	        if (finalRules != null && otherRBTZ.finalRules != null) {
	            for (int i = 0; i < finalRules.Length; i++) {
	                if (finalRules[i] == null && otherRBTZ.finalRules[i] == null) {
	                    continue;
	                }
	                if (finalRules[i] != null
	                        && otherRBTZ.finalRules[i] != null
	                        && finalRules[i]
	                                .IsEquivalentTo(otherRBTZ.finalRules[i])) {
	                    continue;
	
	                }
	                return false;
	            }
	        } else if (finalRules != null || otherRBTZ.finalRules != null) {
	            return false;
	        }
	
	        // historic rules
	        if (historicRules != null && otherRBTZ.historicRules != null) {
	            if (historicRules.Count != otherRBTZ.historicRules.Count) {
	                return false;
	            }
	            IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(historicRules.GetEnumerator());
	            while (it.HasNext()) {
	                TimeZoneRule rule = (TimeZoneRule) it.Next();
	                IIterator oit = new ILOG.J2CsMapping.Collections.IteratorAdapter(otherRBTZ.historicRules.GetEnumerator());
	                bool foundSameRule = false;
	                while (oit.HasNext()) {
	                    TimeZoneRule orule = (TimeZoneRule) oit.Next();
	                    if (rule.IsEquivalentTo(orule)) {
	                        foundSameRule = true;
	                        break;
	                    }
	                }
	                if (!foundSameRule) {
	                    return false;
	                }
	            }
	        } else if (historicRules != null || otherRBTZ.historicRules != null) {
	            return false;
	        }
	        return true;
	    }
	
	    // BasicTimeZone methods
	
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public override TimeZoneRule[] GetTimeZoneRules() {
	        int size = 1;
	        if (historicRules != null) {
	            size += historicRules.Count;
	        }
	
	        if (finalRules != null) {
	            if (finalRules[1] != null) {
	                size += 2;
	            } else {
	                size++;
	            }
	        }
	        TimeZoneRule[] rules = new TimeZoneRule[size];
	        rules[0] = initialRule;
	
	        int idx = 1;
	        if (historicRules != null) {
	            for (; idx < historicRules.Count + 1; idx++) {
	                rules[idx] = (TimeZoneRule) historicRules[idx - 1];
	            }
	        }
	        if (finalRules != null) {
	            rules[idx++] = finalRules[0];
	            if (finalRules[1] != null) {
	                rules[idx] = finalRules[1];
	            }
	        }
	        return rules;
	    }
	
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public override TimeZoneTransition GetNextTransition(long bs, bool inclusive) {
	        Complete();
	        if (historicTransitions == null) {
	            return null;
	        }
	        bool isFinal = false;
	        TimeZoneTransition result = null;
	        TimeZoneTransition tzt = (TimeZoneTransition) historicTransitions[0];
	        long tt = tzt.GetTime();
	        if (tt > bs || (inclusive && tt == bs)) {
	            result = tzt;
	        } else {
	            int idx = historicTransitions.Count - 1;
	            tzt = (TimeZoneTransition) historicTransitions[idx];
	            tt = tzt.GetTime();
	            if (inclusive && tt == bs) {
	                result = tzt;
	            } else if (tt <= bs) {
	                if (finalRules != null) {
	                    // Find a transion time with finalRules
	                    DateTime start0 = finalRules[0].GetNextStart(bs,
	                            finalRules[1].GetRawOffset(),
	                            finalRules[1].GetDSTSavings(), inclusive);
	                    DateTime start1 = finalRules[1].GetNextStart(bs,
	                            finalRules[0].GetRawOffset(),
	                            finalRules[0].GetDSTSavings(), inclusive);
	
	                    if (ILOG.J2CsMapping.Util.DateUtil.After(start1,start0)) {
	                        tzt = new TimeZoneTransition((start0.Ticks/10000),
	                                finalRules[1], finalRules[0]);
	                    } else {
	                        tzt = new TimeZoneTransition((start1.Ticks/10000),
	                                finalRules[0], finalRules[1]);
	                    }
	                    result = tzt;
	                    isFinal = true;
	                } else {
	                    return null;
	                }
	            } else {
	                // Find a transition within the historic transitions
	                idx--;
	                TimeZoneTransition prev = tzt;
	                while (idx > 0) {
	                    tzt = (TimeZoneTransition) historicTransitions[idx];
	                    tt = tzt.GetTime();
	                    if (tt < bs || (!inclusive && tt == bs)) {
	                        break;
	                    }
	                    idx--;
	                    prev = tzt;
	                }
	                result = prev;
	            }
	        }
	        if (result != null) {
	            // For now, this implementation ignore transitions with only zone
	            // name changes.
	            TimeZoneRule from = result.GetFrom();
	            TimeZoneRule to = result.GetTo();
	            if (from.GetRawOffset() == to.GetRawOffset()
	                    && from.GetDSTSavings() == to.GetDSTSavings()) {
	                // No offset changes. Try next one if not final
	                if (isFinal) {
	                    return null;
	                } else {
	                    result = GetNextTransition(result.GetTime(), false /*
	                                                                        * always
	                                                                        * exclusive
	                                                                        */);
	                }
	            }
	        }
	        return result;
	    }
	
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public override TimeZoneTransition GetPreviousTransition(long bs, bool inclusive) {
	        Complete();
	        if (historicTransitions == null) {
	            return null;
	        }
	        TimeZoneTransition result = null;
	        TimeZoneTransition tzt = (TimeZoneTransition) historicTransitions[0];
	        long tt = tzt.GetTime();
	        if (inclusive && tt == bs) {
	            result = tzt;
	        } else if (tt >= bs) {
	            return null;
	        } else {
	            int idx = historicTransitions.Count - 1;
	            tzt = (TimeZoneTransition) historicTransitions[idx];
	            tt = tzt.GetTime();
	            if (inclusive && tt == bs) {
	                result = tzt;
	            } else if (tt < bs) {
	                if (finalRules != null) {
	                    // Find a transion time with finalRules
	                    DateTime start0 = finalRules[0].GetPreviousStart(bs,
	                            finalRules[1].GetRawOffset(),
	                            finalRules[1].GetDSTSavings(), inclusive);
	                    DateTime start1 = finalRules[1].GetPreviousStart(bs,
	                            finalRules[0].GetRawOffset(),
	                            finalRules[0].GetDSTSavings(), inclusive);
	
	                    if (ILOG.J2CsMapping.Util.DateUtil.Before(start1,start0)) {
	                        tzt = new TimeZoneTransition((start0.Ticks/10000),
	                                finalRules[1], finalRules[0]);
	                    } else {
	                        tzt = new TimeZoneTransition((start1.Ticks/10000),
	                                finalRules[0], finalRules[1]);
	                    }
	                }
	                result = tzt;
	            } else {
	                // Find a transition within the historic transitions
	                idx--;
	                while (idx >= 0) {
	                    tzt = (TimeZoneTransition) historicTransitions[idx];
	                    tt = tzt.GetTime();
	                    if (tt < bs || (inclusive && tt == bs)) {
	                        break;
	                    }
	                    idx--;
	                }
	                result = tzt;
	            }
	        }
	        if (result != null) {
	            // For now, this implementation ignore transitions with only zone
	            // name changes.
	            TimeZoneRule from = result.GetFrom();
	            TimeZoneRule to = result.GetTo();
	            if (from.GetRawOffset() == to.GetRawOffset()
	                    && from.GetDSTSavings() == to.GetDSTSavings()) {
	                // No offset changes. Try previous one
	                result = GetPreviousTransition(result.GetTime(), false /*
	                                                                        * always
	                                                                        * exclusive
	                                                                        */);
	            }
	        }
	        return result;
	    }
	
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public override Object Clone() {
	        RuleBasedTimeZone other = (RuleBasedTimeZone) base.Clone();
	        if (historicRules != null) {
	            other.historicRules = (IList) ((ArrayList) historicRules).Clone(); // rules
	                                                                              // are
	                                                                              // immutable
	        }
	        if (finalRules != null) {
	            other.finalRules = (AnnualTimeZoneRule[]) finalRules.Clone();
	        }
	        return other;
	    }
	
	    // private stuff
	
	    /*
	     * Resolve historic transition times and update fields used for offset
	     * calculation.
	     */
	    private void Complete() {
	        if (upToDate) {
	            // No rules were added since last time.
	            return;
	        }
	
	        // Make sure either no final rules or a pair of AnnualTimeZoneRules
	        // are available.
	        if (finalRules != null && finalRules[1] == null) {
	            throw new InvalidOperationException("Incomplete final rules");
	        }
	
	        // Create a TimezoneTransition and add to the list
	        if (historicRules != null || finalRules != null) {
	            TimeZoneRule curRule = initialRule;
	            long lastTransitionTime = IBM.ICU.Impl.Grego.MIN_MILLIS;
	
	            // Build the transition array which represents historical time zone
	            // transitions.
	            if (historicRules != null) {
	                BitSet done = new BitSet(historicRules.Count); // for skipping
	                                                                // rules already
	                                                                // processed
	
	                while (true) {
	                    int curStdOffset = curRule.GetRawOffset();
	                    int curDstSavings = curRule.GetDSTSavings();
	                    long nextTransitionTime = IBM.ICU.Impl.Grego.MAX_MILLIS;
	                    TimeZoneRule nextRule = null;
	                    DateTime d;
	                    long tt;
	
	                    for (int i = 0; i < historicRules.Count; i++) {
	                        if (done.Get(i)) {
	                            continue;
	                        }
	                        TimeZoneRule r = (TimeZoneRule) historicRules[i];
	                        d = r.GetNextStart(lastTransitionTime, curStdOffset,
	                                curDstSavings, false);
	                        if (d == null) {
	                            // No more transitions from this rule - skip this
	                            // rule next time
	                            done.Set(i);
	                        } else {
	                            if (r == curRule
	                                    || (r.GetName().Equals(curRule.GetName())
	                                            && r.GetRawOffset() == curRule
	                                                    .GetRawOffset() && r
	                                            .GetDSTSavings() == curRule
	                                            .GetDSTSavings())) {
	                                continue;
	                            }
	                            tt = (d.Ticks/10000);
	                            if (tt < nextTransitionTime) {
	                                nextTransitionTime = tt;
	                                nextRule = r;
	                            }
	                        }
	                    }
	
	                    if (nextRule == null) {
	                        // Check if all historic rules are done
	                        bool bDoneAll = true;
	                        for (int j = 0; j < historicRules.Count; j++) {
	                            if (!done.Get(j)) {
	                                bDoneAll = false;
	                                break;
	                            }
	                        }
	                        if (bDoneAll) {
	                            break;
	                        }
	                    }
	
	                    if (finalRules != null) {
	                        // Check if one of final rules has earlier transition
	                        // date
	                        for (int i_0 = 0; i_0 < 2 /* finalRules.length */; i_0++) {
	                            if ((Object) finalRules[i_0] == (Object) curRule) {
	                                continue;
	                            }
	                            d = finalRules[i_0].GetNextStart(lastTransitionTime,
	                                    curStdOffset, curDstSavings, false);
	                            if (d != null) {
	                                tt = (d.Ticks/10000);
	                                if (tt < nextTransitionTime) {
	                                    nextTransitionTime = tt;
	                                    nextRule = finalRules[i_0];
	                                }
	                            }
	                        }
	                    }
	
	                    if (nextRule == null) {
	                        // Nothing more
	                        break;
	                    }
	
	                    if (historicTransitions == null) {
	                        historicTransitions = new ArrayList();
	                    }
	                    ILOG.J2CsMapping.Collections.Generics.Collections.Add(historicTransitions,new TimeZoneTransition(
	                                                nextTransitionTime, curRule, nextRule));
	                    lastTransitionTime = nextTransitionTime;
	                    curRule = nextRule;
	                }
	            }
	            if (finalRules != null) {
	                if (historicTransitions == null) {
	                    historicTransitions = new ArrayList();
	                }
	                // Append the first transition for each
	                DateTime d0 = finalRules[0].GetNextStart(lastTransitionTime,
	                        curRule.GetRawOffset(), curRule.GetDSTSavings(), false);
	                DateTime d1 = finalRules[1].GetNextStart(lastTransitionTime,
	                        curRule.GetRawOffset(), curRule.GetDSTSavings(), false);
	                if (ILOG.J2CsMapping.Util.DateUtil.After(d1,d0)) {
	                    ILOG.J2CsMapping.Collections.Generics.Collections.Add(historicTransitions,new TimeZoneTransition(
	                                                (d0.Ticks/10000), curRule, finalRules[0]));
	                    d1 = finalRules[1].GetNextStart((d0.Ticks/10000),
	                            finalRules[0].GetRawOffset(),
	                            finalRules[0].GetDSTSavings(), false);
	                    ILOG.J2CsMapping.Collections.Generics.Collections.Add(historicTransitions,new TimeZoneTransition(
	                                                (d1.Ticks/10000), finalRules[0], finalRules[1]));
	                } else {
	                    ILOG.J2CsMapping.Collections.Generics.Collections.Add(historicTransitions,new TimeZoneTransition(
	                                                (d1.Ticks/10000), curRule, finalRules[1]));
	                    d0 = finalRules[0].GetNextStart((d1.Ticks/10000),
	                            finalRules[1].GetRawOffset(),
	                            finalRules[1].GetDSTSavings(), false);
	                    ILOG.J2CsMapping.Collections.Generics.Collections.Add(historicTransitions,new TimeZoneTransition(
	                                                (d0.Ticks/10000), finalRules[1], finalRules[0]));
	                }
	            }
	        }
	        upToDate = true;
	    }
	
	    /*
	     * getOffset internal implementation
	     */
	    private void GetOffset(long time, bool local, int NonExistingTimeOpt,
	            int DuplicatedTimeOpt, int[] offsets) {
	        Complete();
	        TimeZoneRule rule;
	        if (historicTransitions == null) {
	            rule = initialRule;
	        } else {
	            long tstart = GetTransitionTime(
	                    (TimeZoneTransition) historicTransitions[0], local,
	                    NonExistingTimeOpt, DuplicatedTimeOpt);
	            if (time < tstart) {
	                rule = initialRule;
	            } else {
	                int idx = historicTransitions.Count - 1;
	                long tend = GetTransitionTime(
	                        (TimeZoneTransition) historicTransitions[idx],
	                        local, NonExistingTimeOpt, DuplicatedTimeOpt);
	                if (time > tend) {
	                    if (finalRules != null) {
	                        rule = FindRuleInFinal(time, local, NonExistingTimeOpt,
	                                DuplicatedTimeOpt);
	                    } else {
	                        // no final rule, use the last rule
	                        rule = ((TimeZoneTransition) historicTransitions[idx]).GetTo();
	                    }
	                } else {
	                    // Find a historical transition
	                    while (idx >= 0) {
	                        if (time >= GetTransitionTime(
	                                (TimeZoneTransition) historicTransitions[idx],
	                                local, NonExistingTimeOpt, DuplicatedTimeOpt)) {
	                            break;
	                        }
	                        idx--;
	                    }
	                    rule = ((TimeZoneTransition) historicTransitions[idx])
	                            .GetTo();
	                }
	            }
	        }
	        offsets[0] = rule.GetRawOffset();
	        offsets[1] = rule.GetDSTSavings();
	    }
	
	    /*
	     * Find a time zone rule applicable to the specified time
	     */
	    private TimeZoneRule FindRuleInFinal(long time, bool local,
	            int NonExistingTimeOpt, int DuplicatedTimeOpt) {
	        if (finalRules == null || finalRules.Length != 2
	                || finalRules[0] == null || finalRules[1] == null) {
	            return null;
	        }
	
	        DateTime start0, start1;
	        long bs;
	        int localDelta;
	
	        bs = time;
	        if (local) {
	            localDelta = GetLocalDelta(finalRules[1].GetRawOffset(),
	                    finalRules[1].GetDSTSavings(),
	                    finalRules[0].GetRawOffset(),
	                    finalRules[0].GetDSTSavings(), NonExistingTimeOpt,
	                    DuplicatedTimeOpt);
	            bs -= localDelta;
	        }
	        start0 = finalRules[0].GetPreviousStart(bs,
	                finalRules[1].GetRawOffset(), finalRules[1].GetDSTSavings(),
	                true);
	
	        bs = time;
	        if (local) {
	            localDelta = GetLocalDelta(finalRules[0].GetRawOffset(),
	                    finalRules[0].GetDSTSavings(),
	                    finalRules[1].GetRawOffset(),
	                    finalRules[1].GetDSTSavings(), NonExistingTimeOpt,
	                    DuplicatedTimeOpt);
	            bs -= localDelta;
	        }
	        start1 = finalRules[1].GetPreviousStart(bs,
	                finalRules[0].GetRawOffset(), finalRules[0].GetDSTSavings(),
	                true);
	
	        return (ILOG.J2CsMapping.Util.DateUtil.After(start0,start1)) ? finalRules[0] : finalRules[1];
	    }
	
	    /*
	     * Get the transition time in local wall clock
	     */
	    private static long GetTransitionTime(TimeZoneTransition tzt,
	            bool local, int NonExistingTimeOpt, int DuplicatedTimeOpt) {
	        long time = tzt.GetTime();
	        if (local) {
	            time += GetLocalDelta(tzt.GetFrom().GetRawOffset(), tzt.GetFrom()
	                    .GetDSTSavings(), tzt.GetTo().GetRawOffset(), tzt.GetTo()
	                    .GetDSTSavings(), NonExistingTimeOpt, DuplicatedTimeOpt);
	        }
	        return time;
	    }
	
	    /*
	     * Returns amount of local time adjustment used for checking rule
	     * transitions
	     */
	    private static int GetLocalDelta(int rawBefore, int dstBefore,
	            int rawAfter, int dstAfter, int NonExistingTimeOpt,
	            int DuplicatedTimeOpt) {
	        int delta = 0;
	
	        int offsetBefore = rawBefore + dstBefore;
	        int offsetAfter = rawAfter + dstAfter;
	
	        bool dstToStd = (dstBefore != 0) && (dstAfter == 0);
	        bool stdToDst = (dstBefore == 0) && (dstAfter != 0);
	
	        if (offsetAfter - offsetBefore >= 0) {
	            // Positive transition, which makes a non-existing local time range
	            if (((NonExistingTimeOpt & IBM.ICU.Util.BasicTimeZone.STD_DST_MASK) == IBM.ICU.Util.BasicTimeZone.LOCAL_STD && dstToStd)
	                    || ((NonExistingTimeOpt & IBM.ICU.Util.BasicTimeZone.STD_DST_MASK) == IBM.ICU.Util.BasicTimeZone.LOCAL_DST && stdToDst)) {
	                delta = offsetBefore;
	            } else if (((NonExistingTimeOpt & IBM.ICU.Util.BasicTimeZone.STD_DST_MASK) == IBM.ICU.Util.BasicTimeZone.LOCAL_STD && stdToDst)
	                    || ((NonExistingTimeOpt & IBM.ICU.Util.BasicTimeZone.STD_DST_MASK) == IBM.ICU.Util.BasicTimeZone.LOCAL_DST && dstToStd)) {
	                delta = offsetAfter;
	            } else if ((NonExistingTimeOpt & IBM.ICU.Util.BasicTimeZone.FORMER_LATTER_MASK) == IBM.ICU.Util.BasicTimeZone.LOCAL_LATTER) {
	                delta = offsetBefore;
	            } else {
	                // Interprets the time with rule before the transition,
	                // default for non-existing time range
	                delta = offsetAfter;
	            }
	        } else {
	            // Negative transition, which makes a duplicated local time range
	            if (((DuplicatedTimeOpt & IBM.ICU.Util.BasicTimeZone.STD_DST_MASK) == IBM.ICU.Util.BasicTimeZone.LOCAL_STD && dstToStd)
	                    || ((DuplicatedTimeOpt & IBM.ICU.Util.BasicTimeZone.STD_DST_MASK) == IBM.ICU.Util.BasicTimeZone.LOCAL_DST && stdToDst)) {
	                delta = offsetAfter;
	            } else if (((DuplicatedTimeOpt & IBM.ICU.Util.BasicTimeZone.STD_DST_MASK) == IBM.ICU.Util.BasicTimeZone.LOCAL_STD && stdToDst)
	                    || ((DuplicatedTimeOpt & IBM.ICU.Util.BasicTimeZone.STD_DST_MASK) == IBM.ICU.Util.BasicTimeZone.LOCAL_DST && dstToStd)) {
	                delta = offsetBefore;
	            } else if ((DuplicatedTimeOpt & IBM.ICU.Util.BasicTimeZone.FORMER_LATTER_MASK) == IBM.ICU.Util.BasicTimeZone.LOCAL_FORMER) {
	                delta = offsetBefore;
	            } else {
	                // Interprets the time with rule after the transition,
	                // default for duplicated local time range
	                delta = offsetAfter;
	            }
	        }
	        return delta;
	    }
	}
}
