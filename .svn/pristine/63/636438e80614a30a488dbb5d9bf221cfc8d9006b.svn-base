/*
 *********************************************************************************
 * Copyright (C) 2004-2007, International Business Machines Corporation and    *
 * others. All Rights Reserved.                                                  *
 *********************************************************************************
 *
 */

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:47 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Util {
	
	using IBM.ICU.Math;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	
	/// <summary>
	/// There are quite a few different conventions for binary datetime, depending on
	/// different platforms and protocols. Some of these have severe drawbacks. For
	/// example, people using Unix time (seconds since Jan 1, 1970, usually in a
	/// 32-bit integer) think that they are safe until near the year 2038. But cases
	/// can and do arise where arithmetic manipulations causes serious problems.
	/// Consider the computation of the average of two datetimes, for example: if one
	/// calculates them with <code>averageTime = (time1 + time2)/2</code>, there will
	/// be overflow even with dates beginning in 2004. Moreover, even if these
	/// problems don't occur, there is the issue of conversion back and forth between
	/// different systems.
	/// <p>
	/// Binary datetimes differ in a number of ways: the datatype, the unit, and the
	/// epoch (origin). We refer to these as time scales.
	/// </p>
	/// <p>
	/// ICU implements a universal time scale that is similar to the .NET framework's
	/// System.DateTime. The universal time scale is a 64-bit integer that holds
	/// ticks since midnight, January 1st, 0001. (One tick is 100 nanoseconds.)
	/// Negative values are supported. This has enough range to guarantee that
	/// calculations involving dates around the present are safe.
	/// </p>
	/// <p>
	/// The universal time scale always measures time according to the proleptic
	/// Gregorian calendar. That is, the Gregorian calendar's leap year rules are
	/// used for all times, even before 1582 when it was introduced. (This is
	/// different from the default ICU calendar which switches from the Julian to the
	/// Gregorian calendar in 1582. See GregorianCalendar.setGregorianChange() and
	/// ucal_setGregorianChange().)
	/// </p>
	/// ICU provides conversion functions to and from all other major time scales,
	/// allowing datetimes in any time scale to be converted to the universal time
	/// scale, safely manipulated, and converted back to any other datetime time
	/// scale.</p>
	/// <p>
	/// For more details and background, see the <a
	/// href="http://www.icu-project.org/userguide/universalTimeScale.html">Universal
	/// Time Scale</a> chapter in the ICU User Guide.
	/// </p>
	/// </summary>
	///
	/// @stable ICU 3.2
	
	public sealed class UniversalTimeScale {
	    /// <summary>
	    /// Used in the JDK. Data is a <c>long</c>. Value is milliseconds since
	    /// January 1, 1970.
	    /// </summary>
	    ///
	    /// @stable ICU 3.2
	    public const int JAVA_TIME = 0;
	
	    /// <summary>
	    /// Used in Unix systems. Data is an <c>int</c> or a <c>long</c>.
	    /// Value is seconds since January 1, 1970.
	    /// </summary>
	    ///
	    /// @stable ICU 3.2
	    public const int UNIX_TIME = 1;
	
	    /// <summary>
	    /// Used in the ICU4C. Data is a <c>double</c>. Value is milliseconds
	    /// since January 1, 1970.
	    /// </summary>
	    ///
	    /// @stable ICU 3.2
	    public const int ICU4C_TIME = 2;
	
	    /// <summary>
	    /// Used in Windows for file times. Data is a <c>long</c>. Value is
	    /// ticks (1 tick == 100 nanoseconds) since January 1, 1601.
	    /// </summary>
	    ///
	    /// @stable ICU 3.2
	    public const int WINDOWS_FILE_TIME = 3;
	
	    /// <summary>
	    /// Used in the .NET framework's <c>System.DateTime</c> structure. Data
	    /// is a <c>long</c>. Value is ticks (1 tick == 100 nanoseconds) since
	    /// January 1, 0001.
	    /// </summary>
	    ///
	    /// @stable ICU 3.2
	    public const int DOTNET_DATE_TIME = 4;
	
	    /// <summary>
	    /// Used in older Macintosh systems. Data is an <c>int</c>. Value is
	    /// seconds since January 1, 1904.
	    /// </summary>
	    ///
	    /// @stable ICU 3.2
	    public const int MAC_OLD_TIME = 5;
	
	    /// <summary>
	    /// Used in the JDK. Data is a <c>double</c>. Value is milliseconds
	    /// since January 1, 2001.
	    /// </summary>
	    ///
	    /// @stable ICU 3.2
	    public const int MAC_TIME = 6;
	
	    /// <summary>
	    /// Used in Excel. Data is a <c>?unknown?</c>. Value is days since
	    /// December 31, 1899.
	    /// </summary>
	    ///
	    /// @stable ICU 3.2
	    public const int EXCEL_TIME = 7;
	
	    /// <summary>
	    /// Used in DB2. Data is a <c>?unknown?</c>. Value is days since
	    /// December 31, 1899.
	    /// </summary>
	    ///
	    /// @stable ICU 3.2
	    public const int DB2_TIME = 8;
	
	    /// <summary>
	    /// Data is a <c>long</c>. Value is microseconds since January 1, 1970.
	    /// Similar to Unix time (linear value from 1970) and struct timeval
	    /// (microseconds resolution).
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const int UNIX_MICROSECONDS_TIME = 9;
	
	    /// <summary>
	    /// This is the first unused time scale value.
	    /// </summary>
	    ///
	    /// @stable ICU 3.2
	    public const int MAX_SCALE = 10;
	
	    /// <summary>
	    /// The constant used to select the units value for a time scale.
	    /// </summary>
	    ///
	    /// @stable ICU 3.2
	    public const int UNITS_VALUE = 0;
	
	    /// <summary>
	    /// The constant used to select the epoch offset value for a time scale.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Util.UniversalTimeScale.GetTimeScaleValue(System.Int32, System.Int32)"/>
	    /// @stable ICU 3.2
	    public const int EPOCH_OFFSET_VALUE = 1;
	
	    /// <summary>
	    /// The constant used to select the minimum from value for a time scale.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Util.UniversalTimeScale.GetTimeScaleValue(System.Int32, System.Int32)"/>
	    /// @stable ICU 3.2
	    public const int FROM_MIN_VALUE = 2;
	
	    /// <summary>
	    /// The constant used to select the maximum from value for a time scale.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Util.UniversalTimeScale.GetTimeScaleValue(System.Int32, System.Int32)"/>
	    /// @stable ICU 3.2
	    public const int FROM_MAX_VALUE = 3;
	
	    /// <summary>
	    /// The constant used to select the minimum to value for a time scale.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Util.UniversalTimeScale.GetTimeScaleValue(System.Int32, System.Int32)"/>
	    /// @stable ICU 3.2
	    public const int TO_MIN_VALUE = 4;
	
	    /// <summary>
	    /// The constant used to select the maximum to value for a time scale.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Util.UniversalTimeScale.GetTimeScaleValue(System.Int32, System.Int32)"/>
	    /// @stable ICU 3.2
	    public const int TO_MAX_VALUE = 5;
	
	    /// <summary>
	    /// The constant used to select the epoch plus one value for a time scale.
	    /// NOTE: This is an internal value. DO NOT USE IT. May not actually be equal
	    /// to the epoch offset value plus one.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Util.UniversalTimeScale.GetTimeScaleValue(System.Int32, System.Int32)"/>
	    /// @stable ICU 3.2
	    public const int EPOCH_OFFSET_PLUS_1_VALUE = 6;
	
	    /// <exclude/>
	    /// <summary>
	    /// The constant used to select the epoch offset minus one value for a time
	    /// scale.
	    /// NOTE: This is an internal value. DO NOT USE IT. May not actually be equal
	    /// to the epoch offset value minus one.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Util.UniversalTimeScale.GetTimeScaleValue(System.Int32, System.Int32)"/>
	    public const int EPOCH_OFFSET_MINUS_1_VALUE = 7;
	
	    /// <exclude/>
	    /// <summary>
	    /// The constant used to select the units round value for a time scale.
	    /// NOTE: This is an internal value. DO NOT USE IT.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Util.UniversalTimeScale.GetTimeScaleValue(System.Int32, System.Int32)"/>
	    public const int UNITS_ROUND_VALUE = 8;
	
	    /// <exclude/>
	    /// <summary>
	    /// The constant used to select the minimum safe rounding value for a time
	    /// scale.
	    /// NOTE: This is an internal value. DO NOT USE IT.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Util.UniversalTimeScale.GetTimeScaleValue(System.Int32, System.Int32)"/>
	    public const int MIN_ROUND_VALUE = 9;
	
	    /// <exclude/>
	    /// <summary>
	    /// The constant used to select the maximum safe rounding value for a time
	    /// scale.
	    /// NOTE: This is an internal value. DO NOT USE IT.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Util.UniversalTimeScale.GetTimeScaleValue(System.Int32, System.Int32)"/>
	    public const int MAX_ROUND_VALUE = 10;
	
	    /// <exclude/>
	    /// <summary>
	    /// The number of time scale values.
	    /// NOTE: This is an internal value. DO NOT USE IT.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Util.UniversalTimeScale.GetTimeScaleValue(System.Int32, System.Int32)"/>
	    public const int MAX_SCALE_VALUE = 11;
	
	    private const long ticks = 1;
	
	    private const long microseconds = ticks * 10;
	
	    private const long milliseconds = microseconds * 1000;
	
	    private const long seconds = milliseconds * 1000;
	
	    private const long minutes = seconds * 60;
	
	    private const long hours = minutes * 60;
	
	    private const long days = hours * 24;
	
	    /// <exclude/>
	    /// <summary>
	    /// This class holds the data that describes a particular time scale.
	    /// </summary>
	    ///
	    private sealed class TimeScaleData {
	        internal TimeScaleData(long theUnits, long theEpochOffset, long theToMin,
	                long theToMax, long theFromMin, long theFromMax) {
	            units = theUnits;
	            unitsRound = theUnits / 2;
	
	            minRound = Int64.MinValue + unitsRound;
	            maxRound = Int64.MaxValue - unitsRound;
	
	            epochOffset = theEpochOffset / theUnits;
	
	            if (theUnits == 1) {
	                epochOffsetP1 = epochOffsetM1 = epochOffset;
	            } else {
	                epochOffsetP1 = epochOffset + 1;
	                epochOffsetM1 = epochOffset - 1;
	            }
	
	            toMin = theToMin;
	            toMax = theToMax;
	
	            fromMin = theFromMin;
	            fromMax = theFromMax;
	        }
	
	        internal long units;
	
	        internal long epochOffset;
	
	        internal long fromMin;
	
	        internal long fromMax;
	
	        internal long toMin;
	
	        internal long toMax;
	
	        internal long epochOffsetP1;
	
	        internal long epochOffsetM1;
	
	        internal long unitsRound;
	
	        internal long minRound;
	
	        internal long maxRound;
	    }
	
	    private static readonly UniversalTimeScale.TimeScaleData [] timeScaleTable = {
	            new UniversalTimeScale.TimeScaleData (milliseconds, 621355968000000000L,
	                    -9223372036854774999L, 9223372036854774999L,
	                    -984472800485477L, 860201606885477L), // JAVA_TIME
	            new UniversalTimeScale.TimeScaleData (seconds, 621355968000000000L,
	                    -9223372036854775808L, 9223372036854775807L,
	                    -984472800485L, 860201606885L), // UNIX_TIME
	            new UniversalTimeScale.TimeScaleData (milliseconds, 621355968000000000L,
	                    -9223372036854774999L, 9223372036854774999L,
	                    -984472800485477L, 860201606885477L), // ICU4C_TIME
	            new UniversalTimeScale.TimeScaleData (ticks, 504911232000000000L,
	                    -8718460804854775808L, 9223372036854775807L,
	                    -9223372036854775808L, 8718460804854775807L), // WINDOWS_FILE_TIME
	            new UniversalTimeScale.TimeScaleData (ticks, 0x0L,
	                    -9223372036854775808L, 9223372036854775807L,
	                    -9223372036854775808L, 9223372036854775807L), // DOTNET_DATE_TIME
	            new UniversalTimeScale.TimeScaleData (seconds, 600527520000000000L,
	                    -9223372036854775808L, 9223372036854775807L,
	                    -982389955685L, 862284451685L), // MAC_OLD_TIME
	            new UniversalTimeScale.TimeScaleData (seconds, 631139040000000000L,
	                    -9223372036854775808L, 9223372036854775807L,
	                    -985451107685L, 859223299685L), // MAC_TIME
	            new UniversalTimeScale.TimeScaleData (days, 599265216000000000L, -9223372036854775808L,
	                    9223372036854775807L, -11368793L, 9981605L), // EXCEL_TIME
	            new UniversalTimeScale.TimeScaleData (days, 599265216000000000L, -9223372036854775808L,
	                    9223372036854775807L, -11368793L, 9981605L), // DB2_TIME
	            new UniversalTimeScale.TimeScaleData (microseconds, 621355968000000000L,
	                    -9223372036854775804L, 9223372036854775804L,
	                    -984472800485477580L, 860201606885477580L) // UNIX_MICROSECONDS_TIME
	    };
	
	    /*
	     * Prevent construction of this class.
	     */
	    // /CLOVER:OFF
	    private UniversalTimeScale() {
	        // nothing to do
	    }
	
	    // /CLOVER:ON
	
	    /// <summary>
	    /// Convert a <c>long</c> datetime from the given time scale to the
	    /// universal time scale.
	    /// </summary>
	    ///
	    /// <param name="otherTime">The <c>long</c> datetime</param>
	    /// <param name="timeScale">The time scale to convert from</param>
	    /// <returns>The datetime converted to the universal time scale</returns>
	    /// @stable ICU 3.2
	    public static long From(long otherTime, int timeScale) {
	        UniversalTimeScale.TimeScaleData  data = FromRangeCheck(otherTime, timeScale);
	
	        return (otherTime + data.epochOffset) * data.units;
	    }
	
	    /// <summary>
	    /// Convert a <c>double</c> datetime from the given time scale to the
	    /// universal time scale. All calculations are done using
	    /// <c>BigDecimal</c> to guarantee that the value does not go out of
	    /// range.
	    /// </summary>
	    ///
	    /// <param name="otherTime">The <c>double</c> datetime</param>
	    /// <param name="timeScale">The time scale to convert from</param>
	    /// <returns>The datetime converted to the universal time scale</returns>
	    /// @stable ICU 3.2
	    public static BigDecimal BigDecimalFrom(double otherTime, int timeScale) {
	        UniversalTimeScale.TimeScaleData  data = GetTimeScaleData(timeScale);
	        BigDecimal other = new BigDecimal(otherTime.ToString());
	        BigDecimal units_0 = new BigDecimal(data.units);
	        BigDecimal epochOffset_1 = new BigDecimal(data.epochOffset);
	
	        return other.Add(epochOffset_1).Multiply(units_0);
	    }
	
	    /// <summary>
	    /// Convert a <c>long</c> datetime from the given time scale to the
	    /// universal time scale. All calculations are done using
	    /// <c>BigDecimal</c> to guarantee that the value does not go out of
	    /// range.
	    /// </summary>
	    ///
	    /// <param name="otherTime">The <c>long</c> datetime</param>
	    /// <param name="timeScale">The time scale to convert from</param>
	    /// <returns>The datetime converted to the universal time scale</returns>
	    /// @stable ICU 3.2
	    public static BigDecimal BigDecimalFrom(long otherTime, int timeScale) {
	        UniversalTimeScale.TimeScaleData  data = GetTimeScaleData(timeScale);
	        BigDecimal other = new BigDecimal(otherTime);
	        BigDecimal units_0 = new BigDecimal(data.units);
	        BigDecimal epochOffset_1 = new BigDecimal(data.epochOffset);
	
	        return other.Add(epochOffset_1).Multiply(units_0);
	    }
	
	    /// <summary>
	    /// Convert a <c>BigDecimal</c> datetime from the given time scale to
	    /// the universal time scale. All calculations are done using
	    /// <c>BigDecimal</c> to guarantee that the value does not go out of
	    /// range.
	    /// </summary>
	    ///
	    /// <param name="otherTime">The <c>BigDecimal</c> datetime</param>
	    /// <param name="timeScale">The time scale to convert from</param>
	    /// <returns>The datetime converted to the universal time scale</returns>
	    /// @stable ICU 3.2
	    public static BigDecimal BigDecimalFrom(BigDecimal otherTime, int timeScale) {
	        UniversalTimeScale.TimeScaleData  data = GetTimeScaleData(timeScale);
	
	        BigDecimal units_0 = new BigDecimal(data.units);
	        BigDecimal epochOffset_1 = new BigDecimal(data.epochOffset);
	
	        return otherTime.Add(epochOffset_1).Multiply(units_0);
	    }
	
	    /// <summary>
	    /// Convert a datetime from the universal time scale stored as a
	    /// <c>BigDecimal</c> to a <c>long</c> in the given time scale.
	    /// Since this calculation requires a divide, we must round. The straight
	    /// forward way to round by adding half of the divisor will push the sum out
	    /// of range for values within have the divisor of the limits of the
	    /// precision of a <c>long</c>. To get around this, we do the rounding
	    /// like this:
	    /// <p>
	    /// <code>
	    /// (universalTime - units + units/2) / units + 1
	    /// </code>
	    /// <p>
	    /// (i.e. we subtract units first to guarantee that we'll still be in range
	    /// when we add <code>units/2</code>. We then need to add one to the quotent
	    /// to make up for the extra subtraction. This simplifies to:
	    /// <p>
	    /// <code>
	    /// (universalTime - units/2) / units - 1
	    /// </code>
	    /// <p>
	    /// For negative values to round away from zero, we need to flip the signs:
	    /// <p>
	    /// <code>
	    /// (universalTime + units/2) / units + 1
	    /// </code>
	    /// <p>
	    /// Since we also need to subtract the epochOffset, we fold the
	    /// <code>+/- 1</code> into the offset value. (i.e.
	    /// <c>epochOffsetP1</c>, <c>epochOffsetM1</c>.)
	    /// </summary>
	    ///
	    /// <param name="universalTime">The datetime in the universal time scale</param>
	    /// <param name="timeScale">The time scale to convert to</param>
	    /// <returns>The datetime converted to the given time scale</returns>
	    /// @stable ICU 3.2
	    public static long ToLong(long universalTime, int timeScale) {
	        UniversalTimeScale.TimeScaleData  data = ToRangeCheck(universalTime, timeScale);
	
	        if (universalTime < 0) {
	            if (universalTime < data.minRound) {
	                return (universalTime + data.unitsRound) / data.units
	                        - data.epochOffsetP1;
	            }
	
	            return (universalTime - data.unitsRound) / data.units
	                    - data.epochOffset;
	        }
	
	        if (universalTime > data.maxRound) {
	            return (universalTime - data.unitsRound) / data.units
	                    - data.epochOffsetM1;
	        }
	
	        return (universalTime + data.unitsRound) / data.units
	                - data.epochOffset;
	    }
	
	    /// <summary>
	    /// Convert a datetime from the universal time scale to a
	    /// <c>BigDecimal</c> in the given time scale.
	    /// </summary>
	    ///
	    /// <param name="universalTime">The datetime in the universal time scale</param>
	    /// <param name="timeScale">The time scale to convert to</param>
	    /// <returns>The datetime converted to the given time scale</returns>
	    /// @stable ICU 3.2
	    public static BigDecimal ToBigDecimal(long universalTime, int timeScale) {
	        UniversalTimeScale.TimeScaleData  data = GetTimeScaleData(timeScale);
	        BigDecimal universal = new BigDecimal(universalTime);
	        BigDecimal units_0 = new BigDecimal(data.units);
	        BigDecimal epochOffset_1 = new BigDecimal(data.epochOffset);
	
	        return universal.Divide(units_0, IBM.ICU.Math.BigDecimal.ROUND_HALF_UP).Subtract(
	                epochOffset_1);
	    }
	
	    /// <summary>
	    /// Convert a datetime from the universal time scale to a
	    /// <c>BigDecimal</c> in the given time scale.
	    /// </summary>
	    ///
	    /// <param name="universalTime">The datetime in the universal time scale</param>
	    /// <param name="timeScale">The time scale to convert to</param>
	    /// <returns>The datetime converted to the given time scale</returns>
	    /// @stable ICU 3.2
	    public static BigDecimal ToBigDecimal(BigDecimal universalTime,
	            int timeScale) {
	        UniversalTimeScale.TimeScaleData  data = GetTimeScaleData(timeScale);
	        BigDecimal units_0 = new BigDecimal(data.units);
	        BigDecimal epochOffset_1 = new BigDecimal(data.epochOffset);
	
	        return universalTime.Divide(units_0, IBM.ICU.Math.BigDecimal.ROUND_HALF_UP).Subtract(
	                epochOffset_1);
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Return the <c>TimeScaleData</c> object for the given time scale.
	    /// </summary>
	    ///
	    /// <param name="scale">- the time scale</param>
	    /// <returns>the <c>TimeScaleData</c> object for the given time scale</returns>
	    private static UniversalTimeScale.TimeScaleData  GetTimeScaleData(int scale) {
	        if (scale < 0 || scale >= MAX_SCALE) {
	            throw new ArgumentException("scale out of range: " + scale);
	        }
	
	        return timeScaleTable[scale];
	    }
	
	    /// <summary>
	    /// Get a value associated with a particular time scale.
	    /// </summary>
	    ///
	    /// <param name="scale">- the time scale</param>
	    /// <param name="value">- a constant representing the value to get</param>
	    /// <returns>- the value.</returns>
	    /// @stable ICU 3.2
	    public static long GetTimeScaleValue(int scale, int value_ren) {
	        UniversalTimeScale.TimeScaleData  data = GetTimeScaleData(scale);
	
	        switch (value_ren) {
	        case UNITS_VALUE:
	            return data.units;
	
	        case EPOCH_OFFSET_VALUE:
	            return data.epochOffset;
	
	        case FROM_MIN_VALUE:
	            return data.fromMin;
	
	        case FROM_MAX_VALUE:
	            return data.fromMax;
	
	        case TO_MIN_VALUE:
	            return data.toMin;
	
	        case TO_MAX_VALUE:
	            return data.toMax;
	
	        case EPOCH_OFFSET_PLUS_1_VALUE:
	            return data.epochOffsetP1;
	
	        case EPOCH_OFFSET_MINUS_1_VALUE:
	            return data.epochOffsetM1;
	
	        case UNITS_ROUND_VALUE:
	            return data.unitsRound;
	
	        case MIN_ROUND_VALUE:
	            return data.minRound;
	
	        case MAX_ROUND_VALUE:
	            return data.maxRound;
	
	        default:
	            throw new ArgumentException("value out of range: " + value_ren);
	        }
	    }
	
	    private static UniversalTimeScale.TimeScaleData  ToRangeCheck(long universalTime, int scale) {
	        UniversalTimeScale.TimeScaleData  data = GetTimeScaleData(scale);
	
	        if (universalTime >= data.toMin && universalTime <= data.toMax) {
	            return data;
	        }
	
	        throw new ArgumentException("universalTime out of range:"
	                + universalTime);
	    }
	
	    private static UniversalTimeScale.TimeScaleData  FromRangeCheck(long otherTime, int scale) {
	        UniversalTimeScale.TimeScaleData  data = GetTimeScaleData(scale);
	
	        if (otherTime >= data.fromMin && otherTime <= data.fromMax) {
	            return data;
	        }
	
	        throw new ArgumentException("otherTime out of range:"
	                + otherTime);
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Convert a time in the Universal Time Scale into another time scale. The
	    /// division used to do the conversion rounds down.
	    /// NOTE: This is an internal routine used by the tool that generates the to
	    /// and from limits. Use it at your own risk.
	    /// </summary>
	    ///
	    /// <param name="universalTime">the time in the Universal Time scale</param>
	    /// <param name="timeScale">the time scale to convert to</param>
	    /// <returns>the time in the given time scale</returns>
	    public static BigDecimal ToBigDecimalTrunc(BigDecimal universalTime,
	            int timeScale) {
	        UniversalTimeScale.TimeScaleData  data = GetTimeScaleData(timeScale);
	        BigDecimal units_0 = new BigDecimal(data.units);
	        BigDecimal epochOffset_1 = new BigDecimal(data.epochOffset);
	
	        return universalTime.Divide(units_0, IBM.ICU.Math.BigDecimal.ROUND_DOWN).Subtract(
	                epochOffset_1);
	    }
	}
}
