/*
 *******************************************************************************
 * Copyright (C) 1996-2007, International Business Machines Corporation and    *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 */

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:47 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Impl {
	
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	
	/// <exclude/>
	/// <summary>
	/// <c>CalendarAstronomer</c> is a class that can perform the calculations
	/// to determine the positions of the sun and moon, the time of sunrise and
	/// sunset, and other astronomy-related data. The calculations it performs are in
	/// some cases quite complicated, and this utility class saves you the trouble of
	/// worrying about them.
	/// <p>
	/// The measurement of time is a very important part of astronomy. Because
	/// astronomical bodies are constantly in motion, observations are only valid at
	/// a given moment in time. Accordingly, each <c>CalendarAstronomer</c>
	/// object has a <c>time</c> property that determines the date and time for
	/// which its calculations are performed. You can set and retrieve this property
	/// with <see cref="M:IBM.ICU.Impl.CalendarAstronomer.SetDate setDate"/>, <see cref="M:IBM.ICU.Impl.CalendarAstronomer.GetDate getDate"/> and related methods.
	/// <p>
	/// Almost all of the calculations performed by this class, or by any astronomer,
	/// are approximations to various degrees of accuracy. The calculations in this
	/// class are mostly modelled after those described in the book <a
	/// href="http://www.amazon.com/exec/obidos/ISBN=0521356997" target="_top">
	/// Practical Astronomy With Your Calculator</a>, by Peter J. Duffett-Smith,
	/// Cambridge University Press, 1990. This is an excellent book, and if you want
	/// a greater understanding of how these calculations are performed it a very
	/// good, readable starting point.
	/// <p>
	/// <strong>WARNING:</strong> This class is very early in its development, and it
	/// is highly likely that its API will change to some degree in the future. At
	/// the moment, it basically does just enough to support<see cref="T:IBM.ICU.Impl.IslamicCalendar"/> and<see cref="T:IBM.ICU.Impl.ChineseCalendar"/>.
	/// </summary>
	///
	public class CalendarAstronomer {
	
	    // -------------------------------------------------------------------------
	    // Astronomical constants
	    // -------------------------------------------------------------------------
	
	    /// <exclude/>
	    /// <summary>
	    /// The number of standard hours in one sidereal day. Approximately 24.93.
	    /// </summary>
	    ///
	    public const double SIDEREAL_DAY = 23.93446960027d;
	
	    /// <exclude/>
	    /// <summary>
	    /// The number of sidereal hours in one mean solar day. Approximately 24.07.
	    /// </summary>
	    ///
	    public const double SOLAR_DAY = 24.065709816d;
	
	    /// <exclude/>
	    /// <summary>
	    /// The average number of solar days from one new moon to the next. This is
	    /// the time it takes for the moon to return the same ecliptic longitude as
	    /// the sun. It is longer than the sidereal month because the sun's longitude
	    /// increases during the year due to the revolution of the earth around the
	    /// sun. Approximately 29.53.
	    /// </summary>
	    ///
	    /// <seealso cref="F:IBM.ICU.Impl.CalendarAstronomer.SIDEREAL_MONTH"/>
	    public const double SYNODIC_MONTH = 29.530588853d;
	
	    /// <exclude/>
	    /// <summary>
	    /// The average number of days it takes for the moon to return to the same
	    /// ecliptic longitude relative to the stellar background. This is referred
	    /// to as the sidereal month. It is shorter than the synodic month due to the
	    /// revolution of the earth around the sun. Approximately 27.32.
	    /// </summary>
	    ///
	    /// <seealso cref="F:IBM.ICU.Impl.CalendarAstronomer.SYNODIC_MONTH"/>
	    public const double SIDEREAL_MONTH = 27.32166d;
	
	    /// <exclude/>
	    /// <summary>
	    /// The average number number of days between successive vernal equinoxes.
	    /// Due to the precession of the earth's axis, this is not precisely the same
	    /// as the sidereal year. Approximately 365.24
	    /// </summary>
	    ///
	    /// <seealso cref="F:IBM.ICU.Impl.CalendarAstronomer.SIDEREAL_YEAR"/>
	    public const double TROPICAL_YEAR = 365.242191d;
	
	    /// <exclude/>
	    /// <summary>
	    /// The average number of days it takes for the sun to return to the same
	    /// position against the fixed stellar background. This is the duration of
	    /// one orbit of the earth about the sun as it would appear to an outside
	    /// observer. Due to the precession of the earth's axis, this is not
	    /// precisely the same as the tropical year. Approximately 365.25.
	    /// </summary>
	    ///
	    /// <seealso cref="F:IBM.ICU.Impl.CalendarAstronomer.TROPICAL_YEAR"/>
	    public const double SIDEREAL_YEAR = 365.25636d;
	
	    // -------------------------------------------------------------------------
	    // Time-related constants
	    // -------------------------------------------------------------------------
	
	    /// <exclude/>
	    /// <summary>
	    /// The number of milliseconds in one second.
	    /// </summary>
	    ///
	    public const int SECOND_MS = 1000;
	
	    /// <exclude/>
	    /// <summary>
	    /// The number of milliseconds in one minute.
	    /// </summary>
	    ///
	    public const int MINUTE_MS = 60 * SECOND_MS;
	
	    /// <exclude/>
	    /// <summary>
	    /// The number of milliseconds in one hour.
	    /// </summary>
	    ///
	    public const int HOUR_MS = 60 * MINUTE_MS;
	
	    /// <exclude/>
	    /// <summary>
	    /// The number of milliseconds in one day.
	    /// </summary>
	    ///
	    public const long DAY_MS = 24 * HOUR_MS;
	
	    /// <exclude/>
	    /// <summary>
	    /// The start of the julian day numbering scheme used by astronomers, which
	    /// is 1/1/4713 BC (Julian), 12:00 GMT. This is given as the number of
	    /// milliseconds since 1/1/1970 AD (Gregorian), a negative number. Note that
	    /// julian day numbers and the Julian calendar are <em>not</em> the same
	    /// thing. Also note that julian days start at <em>noon</em>, not midnight.
	    /// </summary>
	    ///
	    public const long JULIAN_EPOCH_MS = -210866760000000L;
	
	    // static {
	    // Calendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT"));
	    // cal.clear();
	    // cal.set(cal.ERA, 0);
	    // cal.set(cal.YEAR, 4713);
	    // cal.set(cal.MONTH, cal.JANUARY);
	    // cal.set(cal.DATE, 1);
	    // cal.set(cal.HOUR_OF_DAY, 12);
	    // System.out.println("1.5 Jan 4713 BC = " + cal.getTime().getTime());
	
	    // cal.clear();
	    // cal.set(cal.YEAR, 2000);
	    // cal.set(cal.MONTH, cal.JANUARY);
	    // cal.set(cal.DATE, 1);
	    // cal.add(cal.DATE, -1);
	    // System.out.println("0.0 Jan 2000 = " + cal.getTime().getTime());
	    // }
	
	    /// <summary>
	    /// Milliseconds value for 0.0 January 2000 AD.
	    /// </summary>
	    ///
	    internal const long EPOCH_2000_MS = 946598400000L;
	
	    // -------------------------------------------------------------------------
	    // Assorted private data used for conversions
	    // -------------------------------------------------------------------------
	
	    // My own copies of these so compilers are more likely to optimize them away
	    private const double PI = 3.14159265358979323846d;
	
	    private const double PI2 = PI * 2.0d;
	
	    private const double RAD_HOUR = 12 / PI; // radians -> hours
	
	    private const double DEG_RAD = PI / 180; // degrees -> radians
	
	    private const double RAD_DEG = 180 / PI; // radians -> degrees
	
	    // -------------------------------------------------------------------------
	    // Constructors
	    // -------------------------------------------------------------------------
	
	    /// <exclude/>
	    /// <summary>
	    /// Construct a new <c>CalendarAstronomer</c> object that is
	    /// initialized to the current date and time.
	    /// </summary>
	    ///
	    public CalendarAstronomer() : this(DateTime.Now.Millisecond) {
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Construct a new <c>CalendarAstronomer</c> object that is
	    /// initialized to the specified date and time.
	    /// </summary>
	    ///
	    public CalendarAstronomer(DateTime d) : this((d.Ticks / 10000)) {
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Construct a new <c>CalendarAstronomer</c> object that is
	    /// initialized to the specified time. The time is expressed as a number of
	    /// milliseconds since January 1, 1970 AD (Gregorian).
	    /// </summary>
	    ///
	    /// <seealso cref="null"/>
	    public CalendarAstronomer(long aTime) {
	        this.fLongitude = 0.0d;
	        this.fLatitude = 0.0d;
	        this.fGmtOffset = 0;
	        this.julianDay = INVALID;
	        this.julianCentury = INVALID;
	        this.sunLongitude = INVALID;
	        this.meanAnomalySun = INVALID;
	        this.moonLongitude = INVALID;
	        this.moonEclipLong = INVALID;
	        this.eclipObliquity = INVALID;
	        this.siderealT0 = INVALID;
	        this.siderealTime = INVALID;
	        this.moonPosition = null;
	        time = aTime;
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Construct a new <c>CalendarAstronomer</c> object with the given
	    /// latitude and longitude. The object's time is set to the current date and
	    /// time.
	    /// <p>
	    /// </summary>
	    ///
	    /// <param name="longitude">The desired longitude, in <em>degrees</em> east of theGreenwich meridian.</param>
	    /// <param name="latitude">The desired latitude, in <em>degrees</em>. Positive valuessignify North, negative South.</param>
	    /// <seealso cref="null"/>
	    public CalendarAstronomer(double longitude, double latitude) : this() {
	        fLongitude = NormPI(longitude * DEG_RAD);
	        fLatitude = NormPI(latitude * DEG_RAD);
	        fGmtOffset = (long) (fLongitude * 24 * HOUR_MS / PI2);
	    }
	
	    // -------------------------------------------------------------------------
	    // Time and date getters and setters
	    // -------------------------------------------------------------------------
	
	    /// <exclude/>
	    /// <summary>
	    /// Set the current date and time of this <c>CalendarAstronomer</c>
	    /// object. All astronomical calculations are performed based on this time
	    /// setting.
	    /// </summary>
	    ///
	    /// <param name="aTime">the date and time, expressed as the number of millisecondssince 1/1/1970 0:00 GMT (Gregorian).</param>
	    /// <seealso cref="M:IBM.ICU.Impl.CalendarAstronomer.SetDate(null)"/>
	    /// <seealso cref="M:IBM.ICU.Impl.CalendarAstronomer.GetTime"/>
	    public void SetTime(long aTime) {
	        time = aTime;
	        ClearCache();
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Set the current date and time of this <c>CalendarAstronomer</c>
	    /// object. All astronomical calculations are performed based on this time
	    /// setting.
	    /// </summary>
	    ///
	    /// <param name="date">the time and date, expressed as a <c>Date</c> object.</param>
	    /// <seealso cref="M:IBM.ICU.Impl.CalendarAstronomer.SetTime(System.Int64)"/>
	    /// <seealso cref="M:IBM.ICU.Impl.CalendarAstronomer.GetDate"/>
	    public void SetDate(DateTime date) {
	        SetTime((date.Ticks/10000));
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Set the current date and time of this <c>CalendarAstronomer</c>
	    /// object. All astronomical calculations are performed based on this time
	    /// setting.
	    /// </summary>
	    ///
	    /// <param name="jdn">the desired time, expressed as a "julian day number", which isthe number of elapsed days since 1/1/4713 BC (Julian), 12:00GMT. Note that julian day numbers start at <em>noon</em>. Toget the jdn for the corresponding midnight, subtract 0.5.</param>
	    /// <seealso cref="M:IBM.ICU.Impl.CalendarAstronomer.GetJulianDay"/>
	    /// <seealso cref="F:IBM.ICU.Impl.CalendarAstronomer.JULIAN_EPOCH_MS"/>
	    public void SetJulianDay(double jdn) {
	        time = (long) (jdn * DAY_MS) + JULIAN_EPOCH_MS;
	        ClearCache();
	        julianDay = jdn;
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Get the current time of this <c>CalendarAstronomer</c> object,
	    /// represented as the number of milliseconds since 1/1/1970 AD 0:00 GMT
	    /// (Gregorian).
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Impl.CalendarAstronomer.SetTime(System.Int64)"/>
	    /// <seealso cref="M:IBM.ICU.Impl.CalendarAstronomer.GetDate"/>
	    public long GetTime() {
	        return time;
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Get the current time of this <c>CalendarAstronomer</c> object,
	    /// represented as a <c>Date</c> object.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Impl.CalendarAstronomer.SetDate(null)"/>
	    /// <seealso cref="M:IBM.ICU.Impl.CalendarAstronomer.GetTime"/>
	    public DateTime GetDate() {
	        return new DateTime((time)*10000);
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Get the current time of this <c>CalendarAstronomer</c> object,
	    /// expressed as a "julian day number", which is the number of elapsed days
	    /// since 1/1/4713 BC (Julian), 12:00 GMT.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Impl.CalendarAstronomer.SetJulianDay(System.Double)"/>
	    /// <seealso cref="F:IBM.ICU.Impl.CalendarAstronomer.JULIAN_EPOCH_MS"/>
	    public double GetJulianDay() {
	        if (julianDay == INVALID) {
	            julianDay = (double) (time - JULIAN_EPOCH_MS) / (double) DAY_MS;
	        }
	        return julianDay;
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Return this object's time expressed in julian centuries: the number of
	    /// centuries after 1/1/1900 AD, 12:00 GMT
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Impl.CalendarAstronomer.GetJulianDay"/>
	    public double GetJulianCentury() {
	        if (julianCentury == INVALID) {
	            julianCentury = (GetJulianDay() - 2415020.0d) / 36525;
	        }
	        return julianCentury;
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Returns the current Greenwich sidereal time, measured in hours
	    /// </summary>
	    ///
	    public double GetGreenwichSidereal() {
	        if (siderealTime == INVALID) {
	            // See page 86 of "Practial Astronomy with your Calculator",
	            // by Peter Duffet-Smith, for details on the algorithm.
	
	            double UT = Normalize((double) time / HOUR_MS, 24);
	
	            siderealTime = Normalize(GetSiderealOffset() + UT * 1.002737909d, 24);
	        }
	        return siderealTime;
	    }
	
	    private double GetSiderealOffset() {
	        if (siderealT0 == INVALID) {
	            double JD = Math.Floor(GetJulianDay() - 0.5d) + 0.5d;
	            double S = JD - 2451545.0d;
	            double T = S / 36525.0d;
	            siderealT0 = Normalize(6.697374558d + 2400.051336d * T + 0.000025862d
	                    * T * T, 24);
	        }
	        return siderealT0;
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Returns the current local sidereal time, measured in hours
	    /// </summary>
	    ///
	    public double GetLocalSidereal() {
	        return Normalize(
	                GetGreenwichSidereal() + (double) fGmtOffset / HOUR_MS, 24);
	    }
	
	    /// <summary>
	    /// Converts local sidereal time to Universal Time.
	    /// </summary>
	    ///
	    /// <param name="lst">The Local Sidereal Time, in hours since sidereal midnight onthis object's current date.</param>
	    /// <returns>The corresponding Universal Time, in milliseconds since 1 Jan
	    /// 1970, GMT.</returns>
	    private long LstToUT(double lst) {
	        // Convert to local mean time
	        double lt = Normalize((lst - GetSiderealOffset()) * 0.9972695663d, 24);
	
	        // Then find local midnight on this day
	        long // Then find local midnight on this day
	                bs = DAY_MS * ((time + fGmtOffset) / DAY_MS) - fGmtOffset;
	
	        // out("    lt  =" + lt + " hours");
	        // out("    base=" + new Date(base));
	
	        return bs + (long) (lt * HOUR_MS);
	    }
	
	    // -------------------------------------------------------------------------
	    // Coordinate transformations, all based on the current time of this object
	    // -------------------------------------------------------------------------
	
	    /// <exclude/>
	    /// <summary>
	    /// Convert from ecliptic to equatorial coordinates.
	    /// </summary>
	    ///
	    /// <param name="ecliptic">A point in the sky in ecliptic coordinates.</param>
	    /// <returns>The corresponding point in equatorial coordinates.</returns>
	    public CalendarAstronomer.Equatorial  EclipticToEquatorial(CalendarAstronomer.Ecliptic  ecliptic) {
	        return EclipticToEquatorial(ecliptic.longitude, ecliptic.latitude);
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Convert from ecliptic to equatorial coordinates.
	    /// </summary>
	    ///
	    /// <param name="eclipLong">The ecliptic longitude</param>
	    /// <param name="eclipLat">The ecliptic latitude</param>
	    /// <returns>The corresponding point in equatorial coordinates.</returns>
	    public CalendarAstronomer.Equatorial  EclipticToEquatorial(double eclipLong,
	            double eclipLat) {
	        // See page 42 of "Practial Astronomy with your Calculator",
	        // by Peter Duffet-Smith, for details on the algorithm.
	
	        double obliq = EclipticObliquity();
	        double sinE = System.Math.Sin(obliq);
	        double cosE = System.Math.Cos(obliq);
	
	        double sinL = System.Math.Sin(eclipLong);
	        double cosL = System.Math.Cos(eclipLong);
	
	        double sinB = System.Math.Sin(eclipLat);
	        double cosB = System.Math.Cos(eclipLat);
	        double tanB = System.Math.Tan(eclipLat);
	
	        return new CalendarAstronomer.Equatorial (System.Math.Atan2(sinL * cosE - tanB * sinE, cosL),
	                System.Math.Asin(sinB * cosE + cosB * sinE * sinL));
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Convert from ecliptic longitude to equatorial coordinates.
	    /// </summary>
	    ///
	    /// <param name="eclipLong">The ecliptic longitude</param>
	    /// <returns>The corresponding point in equatorial coordinates.</returns>
	    public CalendarAstronomer.Equatorial  EclipticToEquatorial(double eclipLong) {
	        return EclipticToEquatorial(eclipLong, 0); // TODO: optimize
	    }
	
	    /// <exclude/>
	    public CalendarAstronomer.Horizon  EclipticToHorizon(double eclipLong) {
	        CalendarAstronomer.Equatorial  equatorial = EclipticToEquatorial(eclipLong);
	
	        double H = GetLocalSidereal() * PI / 12 - equatorial.ascension; // Hour-angle
	
	        double sinH = System.Math.Sin(H);
	        double cosH = System.Math.Cos(H);
	        double sinD = System.Math.Sin(equatorial.declination);
	        double cosD = System.Math.Cos(equatorial.declination);
	        double sinL = System.Math.Sin(fLatitude);
	        double cosL = System.Math.Cos(fLatitude);
	
	        double altitude = System.Math.Asin(sinD * sinL + cosD * cosL * cosH);
	        double azimuth = System.Math.Atan2(-cosD * cosL * sinH,
	                sinD - sinL * System.Math.Sin(altitude));
	
	        return new CalendarAstronomer.Horizon (azimuth, altitude);
	    }
	
	    // -------------------------------------------------------------------------
	    // The Sun
	    // -------------------------------------------------------------------------
	
	    //
	    // Parameters of the Sun's orbit as of the epoch Jan 0.0 1990
	    // Angles are in radians (after multiplying by PI/180)
	    //
	    internal const double JD_EPOCH = 2447891.5d; // Julian day of epoch
	
	    internal const double SUN_ETA_G = 279.403303d * PI / 180; // Ecliptic longitude
	                                                           // at epoch
	
	    internal const double SUN_OMEGA_G = 282.768422d * PI / 180; // Ecliptic
	                                                             // longitude of
	                                                             // perigee
	
	    internal const double SUN_E = 0.016713d; // Eccentricity of orbit
	
	    // double sunR0 = 1.495585e8; // Semi-major axis in KM
	    // double sunTheta0 = 0.533128 * PI/180; // Angular diameter at R0
	
	    // The following three methods, which compute the sun parameters
	    // given above for an arbitrary epoch (whatever time the object is
	    // set to), make only a small difference as compared to using the
	    // above constants. E.g., Sunset times might differ by ~12
	    // seconds. Furthermore, the eta-g computation is befuddled by
	    // Duffet-Smith's incorrect coefficients (p.86). I've corrected
	    // the first-order coefficient but the others may be off too - no
	    // way of knowing without consulting another source.
	
	    // /**
	    // * Return the sun's ecliptic longitude at perigee for the current time.
	    // * See Duffett-Smith, p. 86.
	    // * @return radians
	    // */
	    // private double getSunOmegaG() {
	    // double T = getJulianCentury();
	    // return (281.2208444 + (1.719175 + 0.000452778*T)*T) * DEG_RAD;
	    // }
	
	    // /**
	    // * Return the sun's ecliptic longitude for the current time.
	    // * See Duffett-Smith, p. 86.
	    // * @return radians
	    // */
	    // private double getSunEtaG() {
	    // double T = getJulianCentury();
	    // //return (279.6966778 + (36000.76892 + 0.0003025*T)*T) * DEG_RAD;
	    // //
	    // // The above line is from Duffett-Smith, and yields manifestly wrong
	    // // results. The below constant is derived empirically to match the
	    // // constant he gives for the 1990 EPOCH.
	    // //
	    // return (279.6966778 + (-0.3262541582718024 + 0.0003025*T)*T) * DEG_RAD;
	    // }
	
	    // /**
	    // * Return the sun's eccentricity of orbit for the current time.
	    // * See Duffett-Smith, p. 86.
	    // * @return double
	    // */
	    // private double getSunE() {
	    // double T = getJulianCentury();
	    // return 0.01675104 - (0.0000418 + 0.000000126*T)*T;
	    // }
	
	    /// <exclude/>
	    /// <summary>
	    /// The longitude of the sun at the time specified by this object. The
	    /// longitude is measured in radians along the ecliptic from the
	    /// "first point of Aries," the point at which the ecliptic crosses the
	    /// earth's equatorial plane at the vernal equinox.
	    /// <p>
	    /// Currently, this method uses an approximation of the two-body Kepler's
	    /// equation for the earth and the sun. It does not take into account the
	    /// perturbations caused by the other planets, the moon, etc.
	    /// </summary>
	    ///
	    public double GetSunLongitude() {
	        // See page 86 of "Practial Astronomy with your Calculator",
	        // by Peter Duffet-Smith, for details on the algorithm.
	
	        if (sunLongitude == INVALID) {
	            double[] result = GetSunLongitude(GetJulianDay());
	            sunLongitude = result[0];
	            meanAnomalySun = result[1];
	        }
	        return sunLongitude;
	    }
	
	    /// <summary>
	    /// TODO Make this public when the entire class is package-private.
	    /// </summary>
	    ///
	    internal /* public */double[] GetSunLongitude(double julianDay) {
	        // See page 86 of "Practial Astronomy with your Calculator",
	        // by Peter Duffet-Smith, for details on the algorithm.
	
	        double day = julianDay - JD_EPOCH; // Days since epoch
	
	        // Find the angular distance the sun in a fictitious
	        // circular orbit has travelled since the epoch.
	        double epochAngle = Norm2PI(PI2 / TROPICAL_YEAR * day);
	
	        // The epoch wasn't at the sun's perigee; find the angular distance
	        // since perigee, which is called the "mean anomaly"
	        double meanAnomaly = Norm2PI(epochAngle + SUN_ETA_G - SUN_OMEGA_G);
	
	        // Now find the "true anomaly", e.g. the real solar longitude
	        // by solving Kepler's equation for an elliptical orbit
	        // NOTE: The 3rd ed. of the book lists omega_g and eta_g in different
	        // equations; omega_g is to be correct.
	        return new double[] {
	                Norm2PI(TrueAnomaly(meanAnomaly, SUN_E) + SUN_OMEGA_G),
	                meanAnomaly };
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// The position of the sun at this object's current date and time, in
	    /// equatorial coordinates.
	    /// </summary>
	    ///
	    public CalendarAstronomer.Equatorial  GetSunPosition() {
	        return EclipticToEquatorial(GetSunLongitude(), 0);
	    }
	
	    public sealed class Anonymous_C3 : CalendarAstronomer.AngleFunc {
	            private readonly CalendarAstronomer outer_CalendarAstronomer;
	    
	            
	            /// <param name="paramouter_CalendarAstronomer"></param>
	            public Anonymous_C3(CalendarAstronomer paramouter_CalendarAstronomer) {
	                this.outer_CalendarAstronomer = paramouter_CalendarAstronomer;
	            }
	    
	            public double Eval() {
	                return outer_CalendarAstronomer.GetSunLongitude();
	            }
	        }
	
	    public sealed class Anonymous_C2 : CalendarAstronomer.CoordFunc {
	            private readonly CalendarAstronomer outer_CalendarAstronomer;
	    
	            
	            /// <param name="paramouter_CalendarAstronomer"></param>
	            public Anonymous_C2(CalendarAstronomer paramouter_CalendarAstronomer) {
	                this.outer_CalendarAstronomer = paramouter_CalendarAstronomer;
	            }
	    
	            public CalendarAstronomer.Equatorial  Eval() {
	                return outer_CalendarAstronomer.GetSunPosition();
	            }
	        }
	
	    public sealed class Anonymous_C1 : CalendarAstronomer.AngleFunc {
	            private readonly CalendarAstronomer outer_CalendarAstronomer;
	    
	            
	            /// <param name="paramouter_CalendarAstronomer"></param>
	            public Anonymous_C1(CalendarAstronomer paramouter_CalendarAstronomer) {
	                this.outer_CalendarAstronomer = paramouter_CalendarAstronomer;
	            }
	    
	            public double Eval() {
	                return outer_CalendarAstronomer.GetMoonAge();
	            }
	        }
	
	    public sealed class Anonymous_C0 : CalendarAstronomer.CoordFunc {
	            private readonly CalendarAstronomer outer_CalendarAstronomer;
	    
	            
	            /// <param name="paramouter_CalendarAstronomer"></param>
	            public Anonymous_C0(CalendarAstronomer paramouter_CalendarAstronomer) {
	                this.outer_CalendarAstronomer = paramouter_CalendarAstronomer;
	            }
	    
	            public CalendarAstronomer.Equatorial  Eval() {
	                return outer_CalendarAstronomer.GetMoonPosition();
	            }
	        }
	
	    public class SolarLongitude {
	        internal double value_ren;
	
	        internal SolarLongitude(double val) {
	            value_ren = val;
	        }
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Constant representing the vernal equinox. For use with<see cref="M:IBM.ICU.Impl.CalendarAstronomer.GetSunTime(null, null)"/>. Note: In this
	    /// case, "vernal" refers to the northern hemisphere's seasons.
	    /// </summary>
	    ///
	    public static readonly CalendarAstronomer.SolarLongitude  VERNAL_EQUINOX = new CalendarAstronomer.SolarLongitude (0);
	
	    /// <exclude/>
	    /// <summary>
	    /// Constant representing the summer solstice. For use with<see cref="M:IBM.ICU.Impl.CalendarAstronomer.GetSunTime(null, null)"/>. Note: In this
	    /// case, "summer" refers to the northern hemisphere's seasons.
	    /// </summary>
	    ///
	    public static readonly CalendarAstronomer.SolarLongitude  SUMMER_SOLSTICE = new CalendarAstronomer.SolarLongitude (
	            PI / 2);
	
	    /// <exclude/>
	    /// <summary>
	    /// Constant representing the autumnal equinox. For use with<see cref="M:IBM.ICU.Impl.CalendarAstronomer.GetSunTime(null, null)"/>. Note: In this
	    /// case, "autumn" refers to the northern hemisphere's seasons.
	    /// </summary>
	    ///
	    public static readonly CalendarAstronomer.SolarLongitude  AUTUMN_EQUINOX = new CalendarAstronomer.SolarLongitude (PI);
	
	    /// <exclude/>
	    /// <summary>
	    /// Constant representing the winter solstice. For use with<see cref="M:IBM.ICU.Impl.CalendarAstronomer.GetSunTime(null, null)"/>. Note: In this
	    /// case, "winter" refers to the northern hemisphere's seasons.
	    /// </summary>
	    ///
	    public static readonly CalendarAstronomer.SolarLongitude  WINTER_SOLSTICE = new CalendarAstronomer.SolarLongitude (
	            (PI * 3) / 2);
	
	    /// <exclude/>
	    /// <summary>
	    /// Find the next time at which the sun's ecliptic longitude will have the
	    /// desired value.
	    /// </summary>
	    ///
	    public long GetSunTime(double desired, bool next) {
	        return TimeOfAngle(new CalendarAstronomer.Anonymous_C3 (this), desired, TROPICAL_YEAR, MINUTE_MS, next);
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Find the next time at which the sun's ecliptic longitude will have the
	    /// desired value.
	    /// </summary>
	    ///
	    public long GetSunTime(CalendarAstronomer.SolarLongitude  desired, bool next) {
	        return GetSunTime(desired.value_ren, next);
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Returns the time (GMT) of sunrise or sunset on the local date to which
	    /// this calendar is currently set.
	    /// NOTE: This method only works well if this object is set to a time near
	    /// local noon. Because of variations between the local official time zone
	    /// and the geographic longitude, the computation can flop over into an
	    /// adjacent day if this object is set to a time near local midnight.
	    /// </summary>
	    ///
	    public long GetSunRiseSet(bool rise) {
	        long t0 = time;
	
	        // Make a rough guess: 6am or 6pm local time on the current day
	        long noon = ((time + fGmtOffset) / DAY_MS) * DAY_MS - fGmtOffset + 12
	                * HOUR_MS;
	
	        SetTime(noon + (long) (((rise) ? -6 : 6) * HOUR_MS));
	
	        long t = RiseOrSet(new CalendarAstronomer.Anonymous_C2 (this), rise, .533d * DEG_RAD, // Angular Diameter
	                34 / 60.0d * DEG_RAD, // Refraction correction
	                MINUTE_MS / 12); // Desired accuracy
	
	        SetTime(t0);
	        return t;
	    }
	
	    // Commented out - currently unused. ICU 2.6, Alan
	    // //-------------------------------------------------------------------------
	    // // Alternate Sun Rise/Set
	    // // See Duffett-Smith p.93
	    // //-------------------------------------------------------------------------
	    //
	    // // This yields worse results (as compared to USNO data) than
	    // getSunRiseSet().
	    // /**
	    // * TODO Make this public when the entire class is package-private.
	    // */
	    // /*public*/ long getSunRiseSet2(boolean rise) {
	    // // 1. Calculate coordinates of the sun's center for midnight
	    // double jd = Math.floor(getJulianDay() - 0.5) + 0.5;
	    // double[] sl = getSunLongitude(jd);
	    // double lambda1 = sl[0];
	    // Equatorial pos1 = eclipticToEquatorial(lambda1, 0);
	    //
	    // // 2. Add ... to lambda to get position 24 hours later
	    // double lambda2 = lambda1 + 0.985647*DEG_RAD;
	    // Equatorial pos2 = eclipticToEquatorial(lambda2, 0);
	    //
	    // // 3. Calculate LSTs of rising and setting for these two positions
	    // double tanL = Math.tan(fLatitude);
	    // double H = Math.acos(-tanL * Math.tan(pos1.declination));
	    // double lst1r = (PI2 + pos1.ascension - H) * 24 / PI2;
	    // double lst1s = (pos1.ascension + H) * 24 / PI2;
	    // H = Math.acos(-tanL * Math.tan(pos2.declination));
	    // double lst2r = (PI2-H + pos2.ascension ) * 24 / PI2;
	    // double lst2s = (H + pos2.ascension ) * 24 / PI2;
	    // if (lst1r > 24) lst1r -= 24;
	    // if (lst1s > 24) lst1s -= 24;
	    // if (lst2r > 24) lst2r -= 24;
	    // if (lst2s > 24) lst2s -= 24;
	    //
	    // // 4. Convert LSTs to GSTs. If GST1 > GST2, add 24 to GST2.
	    // double gst1r = lstToGst(lst1r);
	    // double gst1s = lstToGst(lst1s);
	    // double gst2r = lstToGst(lst2r);
	    // double gst2s = lstToGst(lst2s);
	    // if (gst1r > gst2r) gst2r += 24;
	    // if (gst1s > gst2s) gst2s += 24;
	    //
	    // // 5. Calculate GST at 0h UT of this date
	    // double t00 = utToGst(0);
	    //
	    // // 6. Calculate GST at 0h on the observer's longitude
	    // double offset = Math.round(fLongitude*12/PI); // p.95 step 6; he _rounds_
	    // to nearest 15 deg.
	    // double t00p = t00 - offset*1.002737909;
	    // if (t00p < 0) t00p += 24; // do NOT normalize
	    //
	    // // 7. Adjust
	    // if (gst1r < t00p) {
	    // gst1r += 24;
	    // gst2r += 24;
	    // }
	    // if (gst1s < t00p) {
	    // gst1s += 24;
	    // gst2s += 24;
	    // }
	    //
	    // // 8.
	    // double gstr = (24.07*gst1r-t00*(gst2r-gst1r))/(24.07+gst1r-gst2r);
	    // double gsts = (24.07*gst1s-t00*(gst2s-gst1s))/(24.07+gst1s-gst2s);
	    //
	    // // 9. Correct for parallax, refraction, and sun's diameter
	    // double dec = (pos1.declination + pos2.declination) / 2;
	    // double psi = Math.acos(Math.sin(fLatitude) / Math.cos(dec));
	    // double x = 0.830725 * DEG_RAD; // parallax+refraction+diameter
	    // double y = Math.asin(Math.sin(x) / Math.sin(psi)) * RAD_DEG;
	    // double delta_t = 240 * y / Math.cos(dec) / 3600; // hours
	    //
	    // // 10. Add correction to GSTs, subtract from GSTr
	    // gstr -= delta_t;
	    // gsts += delta_t;
	    //
	    // // 11. Convert GST to UT and then to local civil time
	    // double ut = gstToUt(rise ? gstr : gsts);
	    // //System.out.println((rise?"rise=":"set=") + ut + ", delta_t=" +
	    // delta_t);
	    // long midnight = DAY_MS * (time / DAY_MS); // Find UT midnight on this day
	    // return midnight + (long) (ut * 3600000);
	    // }
	
	    // Commented out - currently unused. ICU 2.6, Alan
	    // /**
	    // * Convert local sidereal time to Greenwich sidereal time.
	    // * Section 15. Duffett-Smith p.21
	    // * @param lst in hours (0..24)
	    // * @return GST in hours (0..24)
	    // */
	    // double lstToGst(double lst) {
	    // double delta = fLongitude * 24 / PI2;
	    // return normalize(lst - delta, 24);
	    // }
	
	    // Commented out - currently unused. ICU 2.6, Alan
	    // /**
	    // * Convert UT to GST on this date.
	    // * Section 12. Duffett-Smith p.17
	    // * @param ut in hours
	    // * @return GST in hours
	    // */
	    // double utToGst(double ut) {
	    // return normalize(getT0() + ut*1.002737909, 24);
	    // }
	
	    // Commented out - currently unused. ICU 2.6, Alan
	    // /**
	    // * Convert GST to UT on this date.
	    // * Section 13. Duffett-Smith p.18
	    // * @param gst in hours
	    // * @return UT in hours
	    // */
	    // double gstToUt(double gst) {
	    // return normalize(gst - getT0(), 24) * 0.9972695663;
	    // }
	
	    // Commented out - currently unused. ICU 2.6, Alan
	    // double getT0() {
	    // // Common computation for UT <=> GST
	    //
	    // // Find JD for 0h UT
	    // double jd = Math.floor(getJulianDay() - 0.5) + 0.5;
	    //
	    // double s = jd - 2451545.0;
	    // double t = s / 36525.0;
	    // double t0 = 6.697374558 + (2400.051336 + 0.000025862*t)*t;
	    // return t0;
	    // }
	
	    // Commented out - currently unused. ICU 2.6, Alan
	    // //-------------------------------------------------------------------------
	    // // Alternate Sun Rise/Set
	    // // See sci.astro FAQ
	    // // http://www.faqs.org/faqs/astronomy/faq/part3/section-5.html
	    // //-------------------------------------------------------------------------
	    //
	    // // Note: This method appears to produce inferior accuracy as
	    // // compared to getSunRiseSet().
	    //
	    // /**
	    // * TODO Make this public when the entire class is package-private.
	    // */
	    // /*public*/ long getSunRiseSet3(boolean rise) {
	    //
	    // // Compute day number for 0.0 Jan 2000 epoch
	    // double d = (double)(time - EPOCH_2000_MS) / DAY_MS;
	    //
	    // // Now compute the Local Sidereal Time, LST:
	    // //
	    // double LST = 98.9818 + 0.985647352 * d + /*UT*15 + long*/
	    // fLongitude*RAD_DEG;
	    // //
	    // // (east long. positive). Note that LST is here expressed in degrees,
	    // // where 15 degrees corresponds to one hour. Since LST really is an
	    // angle,
	    // // it's convenient to use one unit---degrees---throughout.
	    //
	    // // COMPUTING THE SUN'S POSITION
	    // // ----------------------------
	    // //
	    // // To be able to compute the Sun's rise/set times, you need to be able to
	    // // compute the Sun's position at any time. First compute the "day
	    // // number" d as outlined above, for the desired moment. Next compute:
	    // //
	    // double oblecl = 23.4393 - 3.563E-7 * d;
	    // //
	    // double w = 282.9404 + 4.70935E-5 * d;
	    // double M = 356.0470 + 0.9856002585 * d;
	    // double e = 0.016709 - 1.151E-9 * d;
	    // //
	    // // This is the obliquity of the ecliptic, plus some of the elements of
	    // // the Sun's apparent orbit (i.e., really the Earth's orbit): w =
	    // // argument of perihelion, M = mean anomaly, e = eccentricity.
	    // // Semi-major axis is here assumed to be exactly 1.0 (while not strictly
	    // // true, this is still an accurate approximation). Next compute E, the
	    // // eccentric anomaly:
	    // //
	    // double E = M + e*(180/PI) * Math.sin(M*DEG_RAD) * ( 1.0 +
	    // e*Math.cos(M*DEG_RAD) );
	    // //
	    // // where E and M are in degrees. This is it---no further iterations are
	    // // needed because we know e has a sufficiently small value. Next compute
	    // // the true anomaly, v, and the distance, r:
	    // //
	    // /* r * cos(v) = */ double A = Math.cos(E*DEG_RAD) - e;
	    // /* r * sin(v) = */ double B = Math.sqrt(1 - e*e) * Math.sin(E*DEG_RAD);
	    // //
	    // // and
	    // //
	    // // r = sqrt( A*A + B*B )
	    // double v = Math.atan2( B, A )*RAD_DEG;
	    // //
	    // // The Sun's true longitude, slon, can now be computed:
	    // //
	    // double slon = v + w;
	    // //
	    // // Since the Sun is always at the ecliptic (or at least very very close
	    // to
	    // // it), we can use simplified formulae to convert slon (the Sun's
	    // ecliptic
	    // // longitude) to sRA and sDec (the Sun's RA and Dec):
	    // //
	    // // sin(slon) * cos(oblecl)
	    // // tan(sRA) = -------------------------
	    // // cos(slon)
	    // //
	    // // sin(sDec) = sin(oblecl) * sin(slon)
	    // //
	    // // As was the case when computing az, the Azimuth, if possible use an
	    // // atan2() function to compute sRA.
	    //
	    // double sRA = Math.atan2(Math.sin(slon*DEG_RAD) *
	    // Math.cos(oblecl*DEG_RAD), Math.cos(slon*DEG_RAD))*RAD_DEG;
	    //
	    // double sin_sDec = Math.sin(oblecl*DEG_RAD) * Math.sin(slon*DEG_RAD);
	    // double sDec = Math.asin(sin_sDec)*RAD_DEG;
	    //
	    // // COMPUTING RISE AND SET TIMES
	    // // ----------------------------
	    // //
	    // // To compute when an object rises or sets, you must compute when it
	    // // passes the meridian and the HA of rise/set. Then the rise time is
	    // // the meridian time minus HA for rise/set, and the set time is the
	    // // meridian time plus the HA for rise/set.
	    // //
	    // // To find the meridian time, compute the Local Sidereal Time at 0h local
	    // // time (or 0h UT if you prefer to work in UT) as outlined above---name
	    // // that quantity LST0. The Meridian Time, MT, will now be:
	    // //
	    // // MT = RA - LST0
	    // double MT = normalize(sRA - LST, 360);
	    // //
	    // // where "RA" is the object's Right Ascension (in degrees!). If negative,
	    // // add 360 deg to MT. If the object is the Sun, leave the time as it is,
	    // // but if it's stellar, multiply MT by 365.2422/366.2422, to convert from
	    // // sidereal to solar time. Now, compute HA for rise/set, name that
	    // // quantity HA0:
	    // //
	    // // sin(h0) - sin(lat) * sin(Dec)
	    // // cos(HA0) = ---------------------------------
	    // // cos(lat) * cos(Dec)
	    // //
	    // // where h0 is the altitude selected to represent rise/set. For a purely
	    // // mathematical horizon, set h0 = 0 and simplify to:
	    // //
	    // // cos(HA0) = - tan(lat) * tan(Dec)
	    // //
	    // // If you want to account for refraction on the atmosphere, set h0 =
	    // -35/60
	    // // degrees (-35 arc minutes), and if you want to compute the rise/set
	    // times
	    // // for the Sun's upper limb, set h0 = -50/60 (-50 arc minutes).
	    // //
	    // double h0 = -50/60 * DEG_RAD;
	    //
	    // double HA0 = Math.acos(
	    // (Math.sin(h0) - Math.sin(fLatitude) * sin_sDec) /
	    // (Math.cos(fLatitude) * Math.cos(sDec*DEG_RAD)))*RAD_DEG;
	    //
	    // // When HA0 has been computed, leave it as it is for the Sun but multiply
	    // // by 365.2422/366.2422 for stellar objects, to convert from sidereal to
	    // // solar time. Finally compute:
	    // //
	    // // Rise time = MT - HA0
	    // // Set time = MT + HA0
	    // //
	    // // convert the times from degrees to hours by dividing by 15.
	    // //
	    // // If you'd like to check that your calculations are accurate or just
	    // // need a quick result, check the USNO's Sun or Moon Rise/Set Table,
	    // // <URL:http://aa.usno.navy.mil/AA/data/docs/RS_OneYear.html>.
	    //
	    // double result = MT + (rise ? -HA0 : HA0); // in degrees
	    //
	    // // Find UT midnight on this day
	    // long midnight = DAY_MS * (time / DAY_MS);
	    //
	    // return midnight + (long) (result * 3600000 / 15);
	    // }
	
	    // -------------------------------------------------------------------------
	    // The Moon
	    // -------------------------------------------------------------------------
	
	    internal const double moonL0 = 318.351648d * PI / 180; // Mean long. at epoch
	
	    internal const double moonP0 = 36.340410d * PI / 180; // Mean long. of perigee
	
	    internal const double moonN0 = 318.510107d * PI / 180; // Mean long. of node
	
	    internal const double moonI = 5.145366d * PI / 180; // Inclination of orbit
	
	    internal const double moonE = 0.054900d; // Eccentricity of orbit
	
	    // These aren't used right now
	    internal const double moonA = 3.84401e5d; // semi-major axis (km)
	
	    internal const double moonT0 = 0.5181d * PI / 180; // Angular size at distance
	                                                    // A
	
	    internal const double moonPi = 0.9507d * PI / 180; // Parallax at distance A
	
	    /// <exclude/>
	    /// <summary>
	    /// The position of the moon at the time set on this object, in equatorial
	    /// coordinates.
	    /// </summary>
	    ///
	    public CalendarAstronomer.Equatorial  GetMoonPosition() {
	        //
	        // See page 142 of "Practial Astronomy with your Calculator",
	        // by Peter Duffet-Smith, for details on the algorithm.
	        //
	        if (moonPosition == null) {
	            // Calculate the solar longitude. Has the side effect of
	            // filling in "meanAnomalySun" as well.
	            double sunLongitude = GetSunLongitude();
	
	            //
	            // Find the # of days since the epoch of our orbital parameters.
	            // TODO: Convert the time of day portion into ephemeris time
	            //
	            double day = GetJulianDay() - JD_EPOCH; // Days since epoch
	
	            // Calculate the mean longitude and anomaly of the moon, based on
	            // a circular orbit. Similar to the corresponding solar calculation.
	            double meanLongitude = Norm2PI(13.1763966d * PI / 180 * day + moonL0);
	            double meanAnomalyMoon = Norm2PI(meanLongitude - 0.1114041d * PI
	                    / 180 * day - moonP0);
	
	            //
	            // Calculate the following corrections:
	            // Evection: the sun's gravity affects the moon's eccentricity
	            // Annual Eqn: variation in the effect due to earth-sun distance
	            // A3: correction factor (for ???)
	            //
	            double evection = 1.2739d
	                    * PI
	                    / 180
	                    * System.Math.Sin(2 * (meanLongitude - sunLongitude)
	                            - meanAnomalyMoon);
	            double annual = 0.1858d * PI / 180 * System.Math.Sin(meanAnomalySun);
	            double a3 = 0.3700d * PI / 180 * System.Math.Sin(meanAnomalySun);
	
	            meanAnomalyMoon += evection - annual - a3;
	
	            //
	            // More correction factors:
	            // center equation of the center correction
	            // a4 yet another error correction (???)
	            //
	            // TODO: Skip the equation of the center correction and solve
	            // Kepler's eqn?
	            //
	            double center = 6.2886d * PI / 180 * System.Math.Sin(meanAnomalyMoon);
	            double a4 = 0.2140d * PI / 180 * System.Math.Sin(2 * meanAnomalyMoon);
	
	            // Now find the moon's corrected longitude
	            moonLongitude = meanLongitude + evection + center - annual + a4;
	
	            //
	            // And finally, find the variation, caused by the fact that the
	            // sun's
	            // gravitational pull on the moon varies depending on which side of
	            // the earth the moon is on
	            //
	            double variation = 0.6583d * PI / 180
	                    * System.Math.Sin(2 * (moonLongitude - sunLongitude));
	
	            moonLongitude += variation;
	
	            //
	            // What we've calculated so far is the moon's longitude in the plane
	            // of its own orbit. Now map to the ecliptic to get the latitude
	            // and longitude. First we need to find the longitude of the
	            // ascending
	            // node, the position on the ecliptic where it is crossed by the
	            // moon's
	            // orbit as it crosses from the southern to the northern hemisphere.
	            //
	            double nodeLongitude = Norm2PI(moonN0 - 0.0529539d * PI / 180 * day);
	
	            nodeLongitude -= 0.16d * PI / 180 * System.Math.Sin(meanAnomalySun);
	
	            double y = System.Math.Sin(moonLongitude - nodeLongitude);
	            double x = System.Math.Cos(moonLongitude - nodeLongitude);
	
	            moonEclipLong = System.Math.Atan2(y * System.Math.Cos(moonI), x) + nodeLongitude;
	            double moonEclipLat = System.Math.Asin(y * System.Math.Sin(moonI));
	
	            moonPosition = EclipticToEquatorial(moonEclipLong, moonEclipLat);
	        }
	        return moonPosition;
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// The "age" of the moon at the time specified in this object. This is
	    /// really the angle between the current ecliptic longitudes of the sun and
	    /// the moon, measured in radians.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Impl.CalendarAstronomer.GetMoonPhase"/>
	    public double GetMoonAge() {
	        // See page 147 of "Practial Astronomy with your Calculator",
	        // by Peter Duffet-Smith, for details on the algorithm.
	        //
	        // Force the moon's position to be calculated. We're going to use
	        // some the intermediate results cached during that calculation.
	        //
	        GetMoonPosition();
	
	        return Norm2PI(moonEclipLong - sunLongitude);
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Calculate the phase of the moon at the time set in this object. The
	    /// returned phase is a <c>double</c> in the range
	    /// <code>0 <= phase < 1</code>, interpreted as follows:
	    /// <ul>
	    /// <li>0.00: New moon
	    /// <li>0.25: First quarter
	    /// <li>0.50: Full moon
	    /// <li>0.75: Last quarter
	    /// </ul>
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Impl.CalendarAstronomer.GetMoonAge"/>
	    public double GetMoonPhase() {
	        // See page 147 of "Practial Astronomy with your Calculator",
	        // by Peter Duffet-Smith, for details on the algorithm.
	        return 0.5d * (1 - System.Math.Cos(GetMoonAge()));
	    }
	
	    public class MoonAge {
	        internal double value_ren;
	
	        internal MoonAge(double val) {
	            value_ren = val;
	        }
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Constant representing a new moon. For use with<see cref="M:IBM.ICU.Impl.CalendarAstronomer.GetMoonTime(null, null)"/>
	    /// </summary>
	    ///
	    public static readonly CalendarAstronomer.MoonAge  NEW_MOON = new CalendarAstronomer.MoonAge (0);
	
	    /// <exclude/>
	    /// <summary>
	    /// Constant representing the moon's first quarter. For use with<see cref="M:IBM.ICU.Impl.CalendarAstronomer.GetMoonTime(null, null)"/>
	    /// </summary>
	    ///
	    public static readonly CalendarAstronomer.MoonAge  FIRST_QUARTER = new CalendarAstronomer.MoonAge (PI / 2);
	
	    /// <exclude/>
	    /// <summary>
	    /// Constant representing a full moon. For use with<see cref="M:IBM.ICU.Impl.CalendarAstronomer.GetMoonTime(null, null)"/>
	    /// </summary>
	    ///
	    public static readonly CalendarAstronomer.MoonAge  FULL_MOON = new CalendarAstronomer.MoonAge (PI);
	
	    /// <exclude/>
	    /// <summary>
	    /// Constant representing the moon's last quarter. For use with<see cref="M:IBM.ICU.Impl.CalendarAstronomer.GetMoonTime(null, null)"/>
	    /// </summary>
	    ///
	    public static readonly CalendarAstronomer.MoonAge  LAST_QUARTER = new CalendarAstronomer.MoonAge ((PI * 3) / 2);
	
	    /// <exclude/>
	    /// <summary>
	    /// Find the next or previous time at which the Moon's ecliptic longitude
	    /// will have the desired value.
	    /// <p>
	    /// </summary>
	    ///
	    /// <param name="desired">The desired longitude.</param>
	    /// <param name="next"><tt>true</tt> if the next occurrance of the phase is desired,<tt>false</tt> for the previous occurrance.</param>
	    public long GetMoonTime(double desired, bool next) {
	        return TimeOfAngle(new CalendarAstronomer.Anonymous_C1 (this), desired, SYNODIC_MONTH, MINUTE_MS, next);
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Find the next or previous time at which the moon will be in the desired
	    /// phase.
	    /// <p>
	    /// </summary>
	    ///
	    /// <param name="desired">The desired phase of the moon.</param>
	    /// <param name="next"><tt>true</tt> if the next occurrance of the phase is desired,<tt>false</tt> for the previous occurrance.</param>
	    public long GetMoonTime(CalendarAstronomer.MoonAge  desired, bool next) {
	        return GetMoonTime(desired.value_ren, next);
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Returns the time (GMT) of sunrise or sunset on the local date to which
	    /// this calendar is currently set.
	    /// </summary>
	    ///
	    public long GetMoonRiseSet(bool rise) {
	        return RiseOrSet(new CalendarAstronomer.Anonymous_C0 (this), rise, .533d * DEG_RAD, // Angular Diameter
	                34 / 60.0d * DEG_RAD, // Refraction correction
	                MINUTE_MS); // Desired accuracy
	    }
	
	    // -------------------------------------------------------------------------
	    // Interpolation methods for finding the time at which a given event occurs
	    // -------------------------------------------------------------------------
	
	    interface AngleFunc {
	        double Eval();
	    }
	
	    private long TimeOfAngle(CalendarAstronomer.AngleFunc  func, double desired, double periodDays,
	            long epsilon, bool next) {
	        // Find the value of the function at the current time
	        double lastAngle = func.Eval();
	
	        // Find out how far we are from the desired angle
	        double deltaAngle = Norm2PI(desired - lastAngle);
	
	        // Using the average period, estimate the next (or previous) time at
	        // which the desired angle occurs.
	        double deltaT = (deltaAngle + ((next) ? (double) (0) : (double) (-PI2)))
	                * (periodDays * DAY_MS) / PI2;
	
	        double lastDeltaT = deltaT; // Liu
	        long startTime = time; // Liu
	
	        SetTime(time + (long) deltaT);
	
	        // Now iterate until we get the error below epsilon. Throughout
	        // this loop we use normPI to get values in the range -Pi to Pi,
	        // since we're using them as correction factors rather than absolute
	        // angles.
	        do {
	            // Evaluate the function at the time we've estimated
	            double angle = func.Eval();
	
	            // Find the # of milliseconds per radian at this point on the curve
	            double factor = Math.Abs(deltaT / NormPI(angle - lastAngle));
	
	            // Correct the time estimate based on how far off the angle is
	            deltaT = NormPI(desired - angle) * factor;
	
	            // HACK:
	            //
	            // If abs(deltaT) begins to diverge we need to quit this loop.
	            // This only appears to happen when attempting to locate, for
	            // example, a new moon on the day of the new moon. E.g.:
	            //
	            // This result is correct:
	            // newMoon(7508(Mon Jul 23 00:00:00 CST 1990,false))=
	            // Sun Jul 22 10:57:41 CST 1990
	            //
	            // But attempting to make the same call a day earlier causes deltaT
	            // to diverge:
	            // CalendarAstronomer.timeOfAngle() diverging: 1.348508727575625E9
	            // ->
	            // 1.3649828540224032E9
	            // newMoon(7507(Sun Jul 22 00:00:00 CST 1990,false))=
	            // Sun Jul 08 13:56:15 CST 1990
	            //
	            // As a temporary solution, we catch this specific condition and
	            // adjust our start time by one eighth period days (either forward
	            // or backward) and try again.
	            // Liu 11/9/00
	            if (Math.Abs(deltaT) > Math.Abs(lastDeltaT)) {
	                long delta = (long) (periodDays * DAY_MS / 8);
	                SetTime(startTime + ((next) ? delta : -delta));
	                return TimeOfAngle(func, desired, periodDays, epsilon, next);
	            }
	
	            lastDeltaT = deltaT;
	            lastAngle = angle;
	
	            SetTime(time + (long) deltaT);
	        } while (Math.Abs(deltaT) > epsilon);
	
	        return time;
	    }
	
	    interface CoordFunc {
	        CalendarAstronomer.Equatorial  Eval();
	    }
	
	    private long RiseOrSet(CalendarAstronomer.CoordFunc  func, bool rise, double diameter,
	            double refraction, long epsilon) {
	        CalendarAstronomer.Equatorial  pos = null;
	        double tanL = System.Math.Tan(fLatitude);
	        long deltaT = Int64.MaxValue;
	        int count = 0;
	
	        //
	        // Calculate the object's position at the current time, then use that
	        // position to calculate the time of rising or setting. The position
	        // will be different at that time, so iterate until the error is
	        // allowable.
	        //
	        do {
	            // See "Practical Astronomy With Your Calculator, section 33.
	            pos = func.Eval();
	            double angle = System.Math.Acos(-tanL * System.Math.Tan(pos.declination));
	            double lst = (((rise) ? PI2 - angle : angle) + pos.ascension) * 24
	                    / PI2;
	
	            // Convert from LST to Universal Time.
	            long newTime = LstToUT(lst);
	
	            deltaT = newTime - time;
	            SetTime(newTime);
	        } while (++count < 5 && Math.Abs(deltaT) > epsilon);
	
	        // Calculate the correction due to refraction and the object's angular
	        // diameter
	        double cosD = System.Math.Cos(pos.declination);
	        double psi = System.Math.Acos(System.Math.Sin(fLatitude) / cosD);
	        double x = diameter / 2 + refraction;
	        double y = System.Math.Asin(System.Math.Sin(x) / System.Math.Sin(psi));
	        long delta = (long) ((240 * y * RAD_DEG / cosD) * SECOND_MS);
	
	        return time + ((rise) ? -delta : delta);
	    }
	
	    // -------------------------------------------------------------------------
	    // Other utility methods
	    // -------------------------------------------------------------------------
	
	    /// <summary>
	    /// Given 'value', add or subtract 'range' until 0 <= 'value' < range. The
	    /// modulus operator.
	    /// </summary>
	    ///
	    private static double Normalize(double value_ren, double range) {
	        return value_ren - range * Math.Floor(value_ren / range);
	    }
	
	    /// <summary>
	    /// Normalize an angle so that it's in the range 0 - 2pi. For positive angles
	    /// this is just (angle % 2pi), but the Java mod operator doesn't work that
	    /// way for negative numbers....
	    /// </summary>
	    ///
	    private static double Norm2PI(double angle) {
	        return Normalize(angle, PI2);
	    }
	
	    /// <summary>
	    /// Normalize an angle into the range -PI - PI
	    /// </summary>
	    ///
	    private static double NormPI(double angle) {
	        return Normalize(angle + PI, PI2) - PI;
	    }
	
	    /// <summary>
	    /// Find the "true anomaly" (longitude) of an object from its mean anomaly
	    /// and the eccentricity of its orbit. This uses an iterative solution to
	    /// Kepler's equation.
	    /// </summary>
	    ///
	    /// <param name="meanAnomaly">The object's longitude calculated as if it were in a regular,circular orbit, measured in radians from the point of perigee.</param>
	    /// <param name="eccentricity">The eccentricity of the orbit</param>
	    /// <returns>The true anomaly (longitude) measured in radians</returns>
	    private double TrueAnomaly(double meanAnomaly, double eccentricity) {
	        // First, solve Kepler's equation iteratively
	        // Duffett-Smith, p.90
	        double delta;
	        double E = meanAnomaly;
	        do {
	            delta = E - eccentricity * System.Math.Sin(E) - meanAnomaly;
	            E = E - delta / (1 - eccentricity * System.Math.Cos(E));
	        } while (Math.Abs(delta) > 1e-5d); // epsilon = 1e-5 rad
	
	        return 2.0d * System.Math.Atan(System.Math.Tan(E / 2)
	                * Math.Sqrt((1 + eccentricity) / (1 - eccentricity)));
	    }
	
	    /// <summary>
	    /// Return the obliquity of the ecliptic (the angle between the ecliptic and
	    /// the earth's equator) at the current time. This varies due to the
	    /// precession of the earth's axis.
	    /// </summary>
	    ///
	    /// <returns>the obliquity of the ecliptic relative to the equator, measured
	    /// in radians.</returns>
	    private double EclipticObliquity() {
	        if (eclipObliquity == INVALID) {
	            double epoch = 2451545.0d; // 2000 AD, January 1.5
	
	            double T = (GetJulianDay() - epoch) / 36525;
	
	            eclipObliquity = 23.439292d - 46.815d / 3600 * T - 0.0006d / 3600 * T
	                    * T + 0.00181d / 3600 * T * T * T;
	
	            eclipObliquity *= DEG_RAD;
	        }
	        return eclipObliquity;
	    }
	
	    // -------------------------------------------------------------------------
	    // Private data
	    // -------------------------------------------------------------------------
	
	    /// <summary>
	    /// Current time in milliseconds since 1/1/1970 AD
	    /// </summary>
	    ///
	    /// <seealso cref="null"/>
	    private long time;
	
	    /*
	     * These aren't used yet, but they'll be needed for sunset calculations and
	     * equatorial to horizon coordinate conversions
	     */
	    private double fLongitude;
	
	    private double fLatitude;
	
	    private long fGmtOffset;
	
	    //
	    // The following fields are used to cache calculated results for improved
	    // performance. These values all depend on the current time setting
	    // of this object, so the clearCache method is provided.
	    //
	    private const double INVALID = System.Double.MinValue;
	
	    private double julianDay;
	
	    private double julianCentury;
	
	    private double sunLongitude;
	
	    private double meanAnomalySun;
	
	    private double moonLongitude;
	
	    private double moonEclipLong;
	
	    // private transient double meanAnomalyMoon = INVALID;
	    private double eclipObliquity;
	
	    private double siderealT0;
	
	    private double siderealTime;
	
	    private CalendarAstronomer.Equatorial  moonPosition;
	
	    private void ClearCache() {
	        julianDay = INVALID;
	        julianCentury = INVALID;
	        sunLongitude = INVALID;
	        meanAnomalySun = INVALID;
	        moonLongitude = INVALID;
	        moonEclipLong = INVALID;
	        // meanAnomalyMoon = INVALID;
	        eclipObliquity = INVALID;
	        siderealTime = INVALID;
	        siderealT0 = INVALID;
	        moonPosition = null;
	    }
	
	    // private static void out(String s) {
	    // System.out.println(s);
	    // }
	
	    // private static String deg(double rad) {
	    // return Double.toString(rad * RAD_DEG);
	    // }
	
	    // private static String hours(long ms) {
	    // return Double.toString((double)ms / HOUR_MS) + " hours";
	    // }
	
	    /// <exclude/>
	    public String Local(long localMillis) {
	        return ILOG.J2CsMapping.Util.DateUtil.DateFromJavaMillis(localMillis - IBM.ICU.Util.TimeZone.GetDefault().GetRawOffset()).ToString();
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Represents the position of an object in the sky relative to the ecliptic,
	    /// the plane of the earth's orbit around the Sun. This is a spherical
	    /// coordinate system in which the latitude specifies the position north or
	    /// south of the plane of the ecliptic. The longitude specifies the position
	    /// along the ecliptic plane relative to the "First Point of Aries", which is
	    /// the Sun's position in the sky at the Vernal Equinox.
	    /// <p>
	    /// Note that Ecliptic objects are immutable and cannot be modified once they
	    /// are constructed. This allows them to be passed and returned by value
	    /// without worrying about whether other code will modify them.
	    /// </summary>
	    ///
	    /// <seealso cref="T:IBM.ICU.Impl.Equatorial"/>
	    /// <seealso cref="T:IBM.ICU.Impl.Horizon"/>
	    public sealed class Ecliptic {
	        /// <exclude/>
	        /// <summary>
	        /// Constructs an Ecliptic coordinate object.
	        /// <p>
	        /// </summary>
	        ///
	        /// <param name="lat">The ecliptic latitude, measured in radians.</param>
	        /// <param name="lon">The ecliptic longitude, measured in radians.</param>
	        public Ecliptic(double lat, double lon) {
	            latitude = lat;
	            longitude = lon;
	        }
	
	        /// <exclude/>
	        /// <summary>
	        /// Return a string representation of this object
	        /// </summary>
	        ///
	        public override String ToString() {
	            return String.Concat(longitude * IBM.ICU.Impl.CalendarAstronomer.RAD_DEG) + ","
	                    + (latitude * IBM.ICU.Impl.CalendarAstronomer.RAD_DEG);
	        }
	
	        /// <exclude/>
	        /// <summary>
	        /// The ecliptic latitude, in radians. This specifies an object's
	        /// position north or south of the plane of the ecliptic, with positive
	        /// angles representing north.
	        /// </summary>
	        ///
	        public readonly double latitude;
	
	        /// <exclude/>
	        /// <summary>
	        /// The ecliptic longitude, in radians. This specifies an object's
	        /// position along the ecliptic plane relative to the
	        /// "First Point of Aries", which is the Sun's position in the sky at the
	        /// Vernal Equinox, with positive angles representing east.
	        /// <p>
	        /// A bit of trivia: the first point of Aries is currently in the
	        /// constellation Pisces, due to the precession of the earth's axis.
	        /// </summary>
	        ///
	        public readonly double longitude;
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Represents the position of an object in the sky relative to the plane of
	    /// the earth's equator. The <i>Right Ascension</i> specifies the position
	    /// east or west along the equator, relative to the sun's position at the
	    /// vernal equinox. The <i>Declination</i> is the position north or south of
	    /// the equatorial plane.
	    /// <p>
	    /// Note that Equatorial objects are immutable and cannot be modified once
	    /// they are constructed. This allows them to be passed and returned by value
	    /// without worrying about whether other code will modify them.
	    /// </summary>
	    ///
	    /// <seealso cref="T:IBM.ICU.Impl.Ecliptic"/>
	    /// <seealso cref="T:IBM.ICU.Impl.Horizon"/>
	    public sealed class Equatorial {
	        /// <exclude/>
	        /// <summary>
	        /// Constructs an Equatorial coordinate object.
	        /// <p>
	        /// </summary>
	        ///
	        /// <param name="asc">The right ascension, measured in radians.</param>
	        /// <param name="dec">The declination, measured in radians.</param>
	        public Equatorial(double asc, double dec) {
	            ascension = asc;
	            declination = dec;
	        }
	
	        /// <exclude/>
	        /// <summary>
	        /// Return a string representation of this object, with the angles
	        /// measured in degrees.
	        /// </summary>
	        ///
	        public override String ToString() {
	            return String.Concat(ascension * IBM.ICU.Impl.CalendarAstronomer.RAD_DEG) + ","
	                    + (declination * IBM.ICU.Impl.CalendarAstronomer.RAD_DEG);
	        }
	
	        /// <exclude/>
	        /// <summary>
	        /// Return a string representation of this object with the right
	        /// ascension measured in hours, minutes, and seconds.
	        /// </summary>
	        ///
	        public String ToHmsString() {
	            return IBM.ICU.Impl.CalendarAstronomer.RadToHms(ascension) + "," + IBM.ICU.Impl.CalendarAstronomer.RadToDms(declination);
	        }
	
	        /// <exclude/>
	        /// <summary>
	        /// The right ascension, in radians. This is the position east or west
	        /// along the equator relative to the sun's position at the vernal
	        /// equinox, with positive angles representing East.
	        /// </summary>
	        ///
	        public readonly double ascension;
	
	        /// <exclude/>
	        /// <summary>
	        /// The declination, in radians. This is the position north or south of
	        /// the equatorial plane, with positive angles representing north.
	        /// </summary>
	        ///
	        public readonly double declination;
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Represents the position of an object in the sky relative to the local
	    /// horizon. The <i>Altitude</i> represents the object's elevation above the
	    /// horizon, with objects below the horizon having a negative altitude. The
	    /// <i>Azimuth</i> is the geographic direction of the object from the
	    /// observer's position, with 0 representing north. The azimuth increases
	    /// clockwise from north.
	    /// <p>
	    /// Note that Horizon objects are immutable and cannot be modified once they
	    /// are constructed. This allows them to be passed and returned by value
	    /// without worrying about whether other code will modify them.
	    /// </summary>
	    ///
	    /// <seealso cref="T:IBM.ICU.Impl.Ecliptic"/>
	    /// <seealso cref="T:IBM.ICU.Impl.Equatorial"/>
	    public sealed class Horizon {
	        /// <exclude/>
	        /// <summary>
	        /// Constructs a Horizon coordinate object.
	        /// <p>
	        /// </summary>
	        ///
	        /// <param name="alt">The altitude, measured in radians above the horizon.</param>
	        /// <param name="azim">The azimuth, measured in radians clockwise from north.</param>
	        public Horizon(double alt, double azim) {
	            altitude = alt;
	            azimuth = azim;
	        }
	
	        /// <exclude/>
	        /// <summary>
	        /// Return a string representation of this object, with the angles
	        /// measured in degrees.
	        /// </summary>
	        ///
	        public override String ToString() {
	            return String.Concat(altitude * IBM.ICU.Impl.CalendarAstronomer.RAD_DEG) + ","
	                    + (azimuth * IBM.ICU.Impl.CalendarAstronomer.RAD_DEG);
	        }
	
	        /// <exclude/>
	        /// <summary>
	        /// The object's altitude above the horizon, in radians.
	        /// </summary>
	        ///
	        public readonly double altitude;
	
	        /// <exclude/>
	        /// <summary>
	        /// The object's direction, in radians clockwise from north.
	        /// </summary>
	        ///
	        public readonly double azimuth;
	    }
	
	    static private String RadToHms(double angle) {
	        int hrs = (int) (angle * RAD_HOUR);
	        int min = (int) ((angle * RAD_HOUR - hrs) * 60);
	        int sec = (int) ((angle * RAD_HOUR - hrs - min / 60.0d) * 3600);
	
	        return ILOG.J2CsMapping.Util.IlNumber.ToString(hrs) + "h" + min + "m" + sec + "s";
	    }
	
	    static private String RadToDms(double angle) {
	        int deg = (int) (angle * RAD_DEG);
	        int min = (int) ((angle * RAD_DEG - deg) * 60);
	        int sec = (int) ((angle * RAD_DEG - deg - min / 60.0d) * 3600);
	
	        return ILOG.J2CsMapping.Util.IlNumber.ToString(deg) + "\u00b0" + min + "'" + sec + "\"";
	    }
	}
}
