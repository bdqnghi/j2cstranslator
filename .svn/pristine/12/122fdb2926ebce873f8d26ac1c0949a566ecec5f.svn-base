//##header J2SE15
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 2:05 PM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 1996-2007, International Business Machines Corporation and    
/// others. All Rights Reserved.                                                
/// </summary>
///
namespace IBM.ICU.Lang {
	
	using IBM.ICU.Impl;
	using IBM.ICU.Lang;
	using IBM.ICU.Text;
	using IBM.ICU.Util;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.Globalization;
	using System.IO;
	using System.Resources;
	using System.Runtime.CompilerServices;
	using System.Text;
    using ILOG.J2CsMapping.Util;
	
	/// <summary>
	/// <p>
	/// The UCharacter class provides extensions to the <a
	/// href="http://java.sun.com/j2se/1.5/docs/api/java/lang/Character.html">
	/// java.lang.Character</a> class. These extensions provide support for more
	/// Unicode properties and together with the <a href=../text/UTF16.html>UTF16</a>
	/// class, provide support for supplementary characters (those with code points
	/// above U+FFFF). Each ICU release supports the latest version of Unicode
	/// available at that time.
	/// </p>
	/// <p>
	/// Code points are represented in these API using ints. While it would be more
	/// convenient in Java to have a separate primitive datatype for them, ints
	/// suffice in the meantime.
	/// </p>
	/// <p>
	/// To use this class please add the jar file name icu4j.jar to the class path,
	/// since it contains data files which supply the information used by this file.<br>
	/// E.g. In Windows <br>
	/// <code>set CLASSPATH=%CLASSPATH%;$JAR_FILE_PATH/ucharacter.jar</code>.<br>
	/// Otherwise, another method would be to copy the files uprops.dat and
	/// unames.icu from the icu4j source subdirectory
	/// <i>$ICU4J_SRC/src/com.ibm.icu.impl.data</i> to your class directory
	/// <i>$ICU4J_CLASS/com.ibm.icu.impl.data</i>.
	/// </p>
	/// <p>
	/// Aside from the additions for UTF-16 support, and the updated Unicode
	/// properties, the main differences between UCharacter and Character are:
	/// <ul>
	/// <li>UCharacter is not designed to be a char wrapper and does not have APIs to
	/// which involves management of that single char.<br>
	/// These include:
	/// <ul>
	/// <li>char charValue(),
	/// <li>int compareTo(java.lang.Character, java.lang.Character), etc.
	/// </ul>
	/// <li>UCharacter does not include Character APIs that are deprecated, nor does
	/// it include the Java-specific character information, such as boolean
	/// isJavaIdentifierPart(char ch).
	/// <li>Character maps characters 'A' - 'Z' and 'a' - 'z' to the numeric values
	/// '10' - '35'. UCharacter also does this in digit and getNumericValue, to
	/// adhere to the java semantics of these methods. New methods unicodeDigit, and
	/// getUnicodeNumericValue do not treat the above code points as having numeric
	/// values. This is a semantic change from ICU4J 1.3.1.
	/// </ul>
	/// <p>
	/// Further detail differences can be determined from the program <a href=
	/// "http://source.icu-project.org/repos/icu/icu4j/trunk/src/com/ibm/icu/dev/test/lang/UCharacterCompare.java"
	/// > com.ibm.icu.dev.test.lang.UCharacterCompare</a>
	/// </p>
	/// <p>
	/// In addition to Java compatibility functions, which calculate derived
	/// properties, this API provides low-level access to the Unicode Character
	/// Database.
	/// </p>
	/// <p>
	/// Unicode assigns each code point (not just assigned character) values for many
	/// properties. Most of them are simple boolean flags, or constants from a small
	/// enumerated list. For some properties, values are strings or other relatively
	/// more complex types.
	/// </p>
	/// <p>
	/// For more information see "About the Unicode Character Database"
	/// (http://www.unicode.org/ucd/) and the ICU User Guide chapter on Properties
	/// (http://www.icu-project.org/userguide/properties.html).
	/// </p>
	/// <p>
	/// There are also functions that provide easy migration from C/POSIX functions
	/// like isblank(). Their use is generally discouraged because the C/POSIX
	/// standards do not define their semantics beyond the ASCII range, which means
	/// that different implementations exhibit very different behavior. Instead,
	/// Unicode properties should be used directly.
	/// </p>
	/// <p>
	/// There are also only a few, broad C/POSIX character classes, and they tend to
	/// be used for conflicting purposes. For example, the "isalpha()" class is
	/// sometimes used to determine word boundaries, while a more sophisticated
	/// approach would at least distinguish initial letters from continuation
	/// characters (the latter including combining marks). (In ICU, BreakIterator is
	/// the most sophisticated API for word boundaries.) Another example: There is no
	/// "istitle()" class for titlecase characters.
	/// </p>
	/// <p>
	/// ICU 3.4 and later provides API access for all twelve C/POSIX character
	/// classes. ICU implements them according to the Standard Recommendations in
	/// Annex C: Compatibility Properties of UTS #18 Unicode Regular Expressions
	/// (http://www.unicode.org/reports/tr18/#Compatibility_Properties).
	/// </p>
	/// <p>
	/// API access for C/POSIX character classes is as follows: - alpha:
	/// isUAlphabetic(c) or hasBinaryProperty(c, UProperty.ALPHABETIC) - lower:
	/// isULowercase(c) or hasBinaryProperty(c, UProperty.LOWERCASE) - upper:
	/// isUUppercase(c) or hasBinaryProperty(c, UProperty.UPPERCASE) - punct:
	/// ((1<<getType(c)) &
	/// ((1<<DASH_PUNCTUATION)|(1<<START_PUNCTUATION)|(1<<END_PUNCTUATION
	/// )|(1<<CONNECTOR_PUNCTUATION
	/// )|(1<<OTHER_PUNCTUATION)|(1<<INITIAL_PUNCTUATION)|(1<<FINAL_PUNCTUATION)))!=0
	/// - digit: isDigit(c) or getType(c)==DECIMAL_DIGIT_NUMBER - xdigit:
	/// hasBinaryProperty(c, UProperty.POSIX_XDIGIT) - alnum: hasBinaryProperty(c,
	/// UProperty.POSIX_ALNUM) - space: isUWhiteSpace(c) or hasBinaryProperty(c,
	/// UProperty.WHITE_SPACE) - blank: hasBinaryProperty(c, UProperty.POSIX_BLANK) -
	/// cntrl: getType(c)==CONTROL - graph: hasBinaryProperty(c,
	/// UProperty.POSIX_GRAPH) - print: hasBinaryProperty(c, UProperty.POSIX_PRINT)
	/// </p>
	/// <p>
	/// The C/POSIX character classes are also available in UnicodeSet patterns,
	/// using patterns like [:graph:] or \p{graph}.
	/// </p>
	/// <p>
	/// Note: There are several ICU (and Java) whitespace functions. Comparison: -
	/// isUWhiteSpace=UCHAR_WHITE_SPACE: Unicode White_Space property; most of
	/// general categories "Z" (separators) + most whitespace ISO controls (including
	/// no-break spaces, but excluding IS1..IS4 and ZWSP) - isWhitespace: Java
	/// isWhitespace; Z + whitespace ISO controls but excluding no-break spaces -
	/// isSpaceChar: just Z (including no-break spaces)
	/// </p>
	/// <p>
	/// This class is not subclassable
	/// </p>
	/// </summary>
	///
	/// @stable ICU 2.1
	/// <seealso cref="T:IBM.ICU.Lang.UCharacterEnums"/>
	
	public sealed class UCharacter : IBM.ICU.Lang.UCharacterEnums.ECharacterCategory /*,
	        IBM.ICU.Lang.UCharacterEnums.ECharacterDirection  */{
	    // public inner classes ----------------------------------------------
	
	    /// <summary>
	    /// A family of character subsets representing the character blocks in the
	    /// Unicode specification, generated from Unicode Data file Blocks.txt.
	    /// Character blocks generally define characters used for a specific script
	    /// or purpose. A character is contained by at most one Unicode block.
	    /// </summary>
	    ///
	    /// @stable ICU 2.4
	    public sealed class UnicodeBlock : Character.Subset {
	        // block id corresponding to icu4c -----------------------------------
	
	        
	        /// @stable ICU 2.4
	        public const int INVALID_CODE_ID = -1;
	
	        
	        /// @stable ICU 2.4
	        public const int BASIC_LATIN_ID = 1;
	
	        
	        /// @stable ICU 2.4
	        public const int LATIN_1_SUPPLEMENT_ID = 2;
	
	        
	        /// @stable ICU 2.4
	        public const int LATIN_EXTENDED_A_ID = 3;
	
	        
	        /// @stable ICU 2.4
	        public const int LATIN_EXTENDED_B_ID = 4;
	
	        
	        /// @stable ICU 2.4
	        public const int IPA_EXTENSIONS_ID = 5;
	
	        
	        /// @stable ICU 2.4
	        public const int SPACING_MODIFIER_LETTERS_ID = 6;
	
	        
	        /// @stable ICU 2.4
	        public const int COMBINING_DIACRITICAL_MARKS_ID = 7;
	
	        /// <summary>
	        /// Unicode 3.2 renames this block to "Greek and Coptic".
	        /// </summary>
	        ///
	        /// @stable ICU 2.4
	        public const int GREEK_ID = 8;
	
	        
	        /// @stable ICU 2.4
	        public const int CYRILLIC_ID = 9;
	
	        
	        /// @stable ICU 2.4
	        public const int ARMENIAN_ID = 10;
	
	        
	        /// @stable ICU 2.4
	        public const int HEBREW_ID = 11;
	
	        
	        /// @stable ICU 2.4
	        public const int ARABIC_ID = 12;
	
	        
	        /// @stable ICU 2.4
	        public const int SYRIAC_ID = 13;
	
	        
	        /// @stable ICU 2.4
	        public const int THAANA_ID = 14;
	
	        
	        /// @stable ICU 2.4
	        public const int DEVANAGARI_ID = 15;
	
	        
	        /// @stable ICU 2.4
	        public const int BENGALI_ID = 16;
	
	        
	        /// @stable ICU 2.4
	        public const int GURMUKHI_ID = 17;
	
	        
	        /// @stable ICU 2.4
	        public const int GUJARATI_ID = 18;
	
	        
	        /// @stable ICU 2.4
	        public const int ORIYA_ID = 19;
	
	        
	        /// @stable ICU 2.4
	        public const int TAMIL_ID = 20;
	
	        
	        /// @stable ICU 2.4
	        public const int TELUGU_ID = 21;
	
	        
	        /// @stable ICU 2.4
	        public const int KANNADA_ID = 22;
	
	        
	        /// @stable ICU 2.4
	        public const int MALAYALAM_ID = 23;
	
	        
	        /// @stable ICU 2.4
	        public const int SINHALA_ID = 24;
	
	        
	        /// @stable ICU 2.4
	        public const int THAI_ID = 25;
	
	        
	        /// @stable ICU 2.4
	        public const int LAO_ID = 26;
	
	        
	        /// @stable ICU 2.4
	        public const int TIBETAN_ID = 27;
	
	        
	        /// @stable ICU 2.4
	        public const int MYANMAR_ID = 28;
	
	        
	        /// @stable ICU 2.4
	        public const int GEORGIAN_ID = 29;
	
	        
	        /// @stable ICU 2.4
	        public const int HANGUL_JAMO_ID = 30;
	
	        
	        /// @stable ICU 2.4
	        public const int ETHIOPIC_ID = 31;
	
	        
	        /// @stable ICU 2.4
	        public const int CHEROKEE_ID = 32;
	
	        
	        /// @stable ICU 2.4
	        public const int UNIFIED_CANADIAN_ABORIGINAL_SYLLABICS_ID = 33;
	
	        
	        /// @stable ICU 2.4
	        public const int OGHAM_ID = 34;
	
	        
	        /// @stable ICU 2.4
	        public const int RUNIC_ID = 35;
	
	        
	        /// @stable ICU 2.4
	        public const int KHMER_ID = 36;
	
	        
	        /// @stable ICU 2.4
	        public const int MONGOLIAN_ID = 37;
	
	        
	        /// @stable ICU 2.4
	        public const int LATIN_EXTENDED_ADDITIONAL_ID = 38;
	
	        
	        /// @stable ICU 2.4
	        public const int GREEK_EXTENDED_ID = 39;
	
	        
	        /// @stable ICU 2.4
	        public const int GENERAL_PUNCTUATION_ID = 40;
	
	        
	        /// @stable ICU 2.4
	        public const int SUPERSCRIPTS_AND_SUBSCRIPTS_ID = 41;
	
	        
	        /// @stable ICU 2.4
	        public const int CURRENCY_SYMBOLS_ID = 42;
	
	        /// <summary>
	        /// Unicode 3.2 renames this block to "Combining Diacritical Marks for
	        /// Symbols".
	        /// </summary>
	        ///
	        /// @stable ICU 2.4
	        public const int COMBINING_MARKS_FOR_SYMBOLS_ID = 43;
	
	        
	        /// @stable ICU 2.4
	        public const int LETTERLIKE_SYMBOLS_ID = 44;
	
	        
	        /// @stable ICU 2.4
	        public const int NUMBER_FORMS_ID = 45;
	
	        
	        /// @stable ICU 2.4
	        public const int ARROWS_ID = 46;
	
	        
	        /// @stable ICU 2.4
	        public const int MATHEMATICAL_OPERATORS_ID = 47;
	
	        
	        /// @stable ICU 2.4
	        public const int MISCELLANEOUS_TECHNICAL_ID = 48;
	
	        
	        /// @stable ICU 2.4
	        public const int CONTROL_PICTURES_ID = 49;
	
	        
	        /// @stable ICU 2.4
	        public const int OPTICAL_CHARACTER_RECOGNITION_ID = 50;
	
	        
	        /// @stable ICU 2.4
	        public const int ENCLOSED_ALPHANUMERICS_ID = 51;
	
	        
	        /// @stable ICU 2.4
	        public const int BOX_DRAWING_ID = 52;
	
	        
	        /// @stable ICU 2.4
	        public const int BLOCK_ELEMENTS_ID = 53;
	
	        
	        /// @stable ICU 2.4
	        public const int GEOMETRIC_SHAPES_ID = 54;
	
	        
	        /// @stable ICU 2.4
	        public const int MISCELLANEOUS_SYMBOLS_ID = 55;
	
	        
	        /// @stable ICU 2.4
	        public const int DINGBATS_ID = 56;
	
	        
	        /// @stable ICU 2.4
	        public const int BRAILLE_PATTERNS_ID = 57;
	
	        
	        /// @stable ICU 2.4
	        public const int CJK_RADICALS_SUPPLEMENT_ID = 58;
	
	        
	        /// @stable ICU 2.4
	        public const int KANGXI_RADICALS_ID = 59;
	
	        
	        /// @stable ICU 2.4
	        public const int IDEOGRAPHIC_DESCRIPTION_CHARACTERS_ID = 60;
	
	        
	        /// @stable ICU 2.4
	        public const int CJK_SYMBOLS_AND_PUNCTUATION_ID = 61;
	
	        
	        /// @stable ICU 2.4
	        public const int HIRAGANA_ID = 62;
	
	        
	        /// @stable ICU 2.4
	        public const int KATAKANA_ID = 63;
	
	        
	        /// @stable ICU 2.4
	        public const int BOPOMOFO_ID = 64;
	
	        
	        /// @stable ICU 2.4
	        public const int HANGUL_COMPATIBILITY_JAMO_ID = 65;
	
	        
	        /// @stable ICU 2.4
	        public const int KANBUN_ID = 66;
	
	        
	        /// @stable ICU 2.4
	        public const int BOPOMOFO_EXTENDED_ID = 67;
	
	        
	        /// @stable ICU 2.4
	        public const int ENCLOSED_CJK_LETTERS_AND_MONTHS_ID = 68;
	
	        
	        /// @stable ICU 2.4
	        public const int CJK_COMPATIBILITY_ID = 69;
	
	        
	        /// @stable ICU 2.4
	        public const int CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A_ID = 70;
	
	        
	        /// @stable ICU 2.4
	        public const int CJK_UNIFIED_IDEOGRAPHS_ID = 71;
	
	        
	        /// @stable ICU 2.4
	        public const int YI_SYLLABLES_ID = 72;
	
	        
	        /// @stable ICU 2.4
	        public const int YI_RADICALS_ID = 73;
	
	        
	        /// @stable ICU 2.4
	        public const int HANGUL_SYLLABLES_ID = 74;
	
	        
	        /// @stable ICU 2.4
	        public const int HIGH_SURROGATES_ID = 75;
	
	        
	        /// @stable ICU 2.4
	        public const int HIGH_PRIVATE_USE_SURROGATES_ID = 76;
	
	        
	        /// @stable ICU 2.4
	        public const int LOW_SURROGATES_ID = 77;
	
	        /// <summary>
	        /// Same as public static final int PRIVATE_USE. Until Unicode 3.1.1; the
	        /// corresponding block name was "Private Use"; and multiple code point
	        /// ranges had this block. Unicode 3.2 renames the block for the BMP PUA
	        /// to "Private Use Area" and adds separate blocks for the supplementary
	        /// PUAs.
	        /// </summary>
	        ///
	        /// @stable ICU 2.4
	        public const int PRIVATE_USE_AREA_ID = 78;
	
	        /// <summary>
	        /// Same as public static final int PRIVATE_USE_AREA. Until Unicode
	        /// 3.1.1; the corresponding block name was "Private Use"; and multiple
	        /// code point ranges had this block. Unicode 3.2 renames the block for
	        /// the BMP PUA to "Private Use Area" and adds separate blocks for the
	        /// supplementary PUAs.
	        /// </summary>
	        ///
	        /// @stable ICU 2.4
	        public const int PRIVATE_USE_ID = PRIVATE_USE_AREA_ID;
	
	        
	        /// @stable ICU 2.4
	        public const int CJK_COMPATIBILITY_IDEOGRAPHS_ID = 79;
	
	        
	        /// @stable ICU 2.4
	        public const int ALPHABETIC_PRESENTATION_FORMS_ID = 80;
	
	        
	        /// @stable ICU 2.4
	        public const int ARABIC_PRESENTATION_FORMS_A_ID = 81;
	
	        
	        /// @stable ICU 2.4
	        public const int COMBINING_HALF_MARKS_ID = 82;
	
	        
	        /// @stable ICU 2.4
	        public const int CJK_COMPATIBILITY_FORMS_ID = 83;
	
	        
	        /// @stable ICU 2.4
	        public const int SMALL_FORM_VARIANTS_ID = 84;
	
	        
	        /// @stable ICU 2.4
	        public const int ARABIC_PRESENTATION_FORMS_B_ID = 85;
	
	        
	        /// @stable ICU 2.4
	        public const int SPECIALS_ID = 86;
	
	        
	        /// @stable ICU 2.4
	        public const int HALFWIDTH_AND_FULLWIDTH_FORMS_ID = 87;
	
	        
	        /// @stable ICU 2.4
	        public const int OLD_ITALIC_ID = 88;
	
	        
	        /// @stable ICU 2.4
	        public const int GOTHIC_ID = 89;
	
	        
	        /// @stable ICU 2.4
	        public const int DESERET_ID = 90;
	
	        
	        /// @stable ICU 2.4
	        public const int BYZANTINE_MUSICAL_SYMBOLS_ID = 91;
	
	        
	        /// @stable ICU 2.4
	        public const int MUSICAL_SYMBOLS_ID = 92;
	
	        
	        /// @stable ICU 2.4
	        public const int MATHEMATICAL_ALPHANUMERIC_SYMBOLS_ID = 93;
	
	        
	        /// @stable ICU 2.4
	        public const int CJK_UNIFIED_IDEOGRAPHS_EXTENSION_B_ID = 94;
	
	        
	        /// @stable ICU 2.4
	        public const int CJK_COMPATIBILITY_IDEOGRAPHS_SUPPLEMENT_ID = 95;
	
	        
	        /// @stable ICU 2.4
	        public const int TAGS_ID = 96;
	
	        // New blocks in Unicode 3.2
	
	        /// <summary>
	        /// Unicode 4.0.1 renames the "Cyrillic Supplementary" block to
	        /// "Cyrillic Supplement".
	        /// </summary>
	        ///
	        /// @stable ICU 2.4
	        public const int CYRILLIC_SUPPLEMENTARY_ID = 97;
	
	        /// <summary>
	        /// Unicode 4.0.1 renames the "Cyrillic Supplementary" block to
	        /// "Cyrillic Supplement".
	        /// </summary>
	        ///
	        /// @stable ICU 3.0
	
	        public const int CYRILLIC_SUPPLEMENT_ID = 97;
	
	        
	        /// @stable ICU 2.4
	        public const int TAGALOG_ID = 98;
	
	        
	        /// @stable ICU 2.4
	        public const int HANUNOO_ID = 99;
	
	        
	        /// @stable ICU 2.4
	        public const int BUHID_ID = 100;
	
	        
	        /// @stable ICU 2.4
	        public const int TAGBANWA_ID = 101;
	
	        
	        /// @stable ICU 2.4
	        public const int MISCELLANEOUS_MATHEMATICAL_SYMBOLS_A_ID = 102;
	
	        
	        /// @stable ICU 2.4
	        public const int SUPPLEMENTAL_ARROWS_A_ID = 103;
	
	        
	        /// @stable ICU 2.4
	        public const int SUPPLEMENTAL_ARROWS_B_ID = 104;
	
	        
	        /// @stable ICU 2.4
	        public const int MISCELLANEOUS_MATHEMATICAL_SYMBOLS_B_ID = 105;
	
	        
	        /// @stable ICU 2.4
	        public const int SUPPLEMENTAL_MATHEMATICAL_OPERATORS_ID = 106;
	
	        
	        /// @stable ICU 2.4
	        public const int KATAKANA_PHONETIC_EXTENSIONS_ID = 107;
	
	        
	        /// @stable ICU 2.4
	        public const int VARIATION_SELECTORS_ID = 108;
	
	        
	        /// @stable ICU 2.4
	        public const int SUPPLEMENTARY_PRIVATE_USE_AREA_A_ID = 109;
	
	        
	        /// @stable ICU 2.4
	        public const int SUPPLEMENTARY_PRIVATE_USE_AREA_B_ID = 110;
	
	        
	        /// @stable ICU 2.6
	        public const int LIMBU_ID = 111; /* [1900] */
	
	        
	        /// @stable ICU 2.6
	        public const int TAI_LE_ID = 112; /* [1950] */
	
	        
	        /// @stable ICU 2.6
	        public const int KHMER_SYMBOLS_ID = 113; /* [19E0] */
	
	        
	        /// @stable ICU 2.6
	        public const int PHONETIC_EXTENSIONS_ID = 114; /* [1D00] */
	
	        
	        /// @stable ICU 2.6
	        public const int MISCELLANEOUS_SYMBOLS_AND_ARROWS_ID = 115; /*
	                                                                            * [2B00
	                                                                            * ]
	                                                                            */
	
	        
	        /// @stable ICU 2.6
	        public const int YIJING_HEXAGRAM_SYMBOLS_ID = 116; /* [4DC0] */
	
	        
	        /// @stable ICU 2.6
	        public const int LINEAR_B_SYLLABARY_ID = 117; /* [10000] */
	
	        
	        /// @stable ICU 2.6
	        public const int LINEAR_B_IDEOGRAMS_ID = 118; /* [10080] */
	
	        
	        /// @stable ICU 2.6
	        public const int AEGEAN_NUMBERS_ID = 119; /* [10100] */
	
	        
	        /// @stable ICU 2.6
	        public const int UGARITIC_ID = 120; /* [10380] */
	
	        
	        /// @stable ICU 2.6
	        public const int SHAVIAN_ID = 121; /* [10450] */
	
	        
	        /// @stable ICU 2.6
	        public const int OSMANYA_ID = 122; /* [10480] */
	
	        
	        /// @stable ICU 2.6
	        public const int CYPRIOT_SYLLABARY_ID = 123; /* [10800] */
	
	        
	        /// @stable ICU 2.6
	        public const int TAI_XUAN_JING_SYMBOLS_ID = 124; /* [1D300] */
	
	        
	        /// @stable ICU 2.6
	        public const int VARIATION_SELECTORS_SUPPLEMENT_ID = 125; /*
	                                                                          * [E0100
	                                                                          * ]
	                                                                          */
	
	        /* New blocks in Unicode 4.1 */
	
	        
	        /// @stable ICU 3.4
	        public const int ANCIENT_GREEK_MUSICAL_NOTATION_ID = 126; /*
	                                                                          * [1D200
	                                                                          * ]
	                                                                          */
	
	        
	        /// @stable ICU 3.4
	        public const int ANCIENT_GREEK_NUMBERS_ID = 127; /* [10140] */
	
	        
	        /// @stable ICU 3.4
	        public const int ARABIC_SUPPLEMENT_ID = 128; /* [0750] */
	
	        
	        /// @stable ICU 3.4
	        public const int BUGINESE_ID = 129; /* [1A00] */
	
	        
	        /// @stable ICU 3.4
	        public const int CJK_STROKES_ID = 130; /* [31C0] */
	
	        
	        /// @stable ICU 3.4
	        public const int COMBINING_DIACRITICAL_MARKS_SUPPLEMENT_ID = 131; /*
	                                                                                  * [
	                                                                                  * 1D
	                                                                                  * C0
	                                                                                  * ]
	                                                                                  */
	
	        
	        /// @stable ICU 3.4
	        public const int COPTIC_ID = 132; /* [2C80] */
	
	        
	        /// @stable ICU 3.4
	        public const int ETHIOPIC_EXTENDED_ID = 133; /* [2D80] */
	
	        
	        /// @stable ICU 3.4
	        public const int ETHIOPIC_SUPPLEMENT_ID = 134; /* [1380] */
	
	        
	        /// @stable ICU 3.4
	        public const int GEORGIAN_SUPPLEMENT_ID = 135; /* [2D00] */
	
	        
	        /// @stable ICU 3.4
	        public const int GLAGOLITIC_ID = 136; /* [2C00] */
	
	        
	        /// @stable ICU 3.4
	        public const int KHAROSHTHI_ID = 137; /* [10A00] */
	
	        
	        /// @stable ICU 3.4
	        public const int MODIFIER_TONE_LETTERS_ID = 138; /* [A700] */
	
	        
	        /// @stable ICU 3.4
	        public const int NEW_TAI_LUE_ID = 139; /* [1980] */
	
	        
	        /// @stable ICU 3.4
	        public const int OLD_PERSIAN_ID = 140; /* [103A0] */
	
	        
	        /// @stable ICU 3.4
	        public const int PHONETIC_EXTENSIONS_SUPPLEMENT_ID = 141; /*
	                                                                          * [1D80
	                                                                          * ]
	                                                                          */
	
	        
	        /// @stable ICU 3.4
	        public const int SUPPLEMENTAL_PUNCTUATION_ID = 142; /* [2E00] */
	
	        
	        /// @stable ICU 3.4
	        public const int SYLOTI_NAGRI_ID = 143; /* [A800] */
	
	        
	        /// @stable ICU 3.4
	        public const int TIFINAGH_ID = 144; /* [2D30] */
	
	        
	        /// @stable ICU 3.4
	        public const int VERTICAL_FORMS_ID = 145; /* [FE10] */
	
	        /* New blocks in Unicode 5.0 */
	
	        
	        /// @draft ICU 3.6
	        /// @provisional This API might change or be removed in a future release.
	        public const int NKO_ID = 146; /* [07C0] */
	
	        
	        /// @draft ICU 3.6
	        /// @provisional This API might change or be removed in a future release.
	        public const int BALINESE_ID = 147; /* [1B00] */
	
	        
	        /// @draft ICU 3.6
	        /// @provisional This API might change or be removed in a future release.
	        public const int LATIN_EXTENDED_C_ID = 148; /* [2C60] */
	
	        
	        /// @draft ICU 3.6
	        /// @provisional This API might change or be removed in a future release.
	        public const int LATIN_EXTENDED_D_ID = 149; /* [A720] */
	
	        
	        /// @draft ICU 3.6
	        /// @provisional This API might change or be removed in a future release.
	        public const int PHAGS_PA_ID = 150; /* [A840] */
	
	        
	        /// @draft ICU 3.6
	        /// @provisional This API might change or be removed in a future release.
	        public const int PHOENICIAN_ID = 151; /* [10900] */
	
	        
	        /// @draft ICU 3.6
	        /// @provisional This API might change or be removed in a future release.
	        public const int CUNEIFORM_ID = 152; /* [12000] */
	
	        
	        /// @draft ICU 3.6
	        /// @provisional This API might change or be removed in a future release.
	        public const int CUNEIFORM_NUMBERS_AND_PUNCTUATION_ID = 153; /*
	                                                                             * [
	                                                                             * 12400
	                                                                             * ]
	                                                                             */
	
	        
	        /// @draft ICU 3.6
	        /// @provisional This API might change or be removed in a future release.
	        public const int COUNTING_ROD_NUMERALS_ID = 154; /* [1D360] */
	
	        
	        /// @stable ICU 2.4
	        public const int COUNT = 155;
	
	        // blocks objects ---------------------------------------------------
	
	        
	        /// @stable ICU 2.6
	        public static readonly UCharacter.UnicodeBlock  NO_BLOCK = new UCharacter.UnicodeBlock (
	                "NO_BLOCK", 0);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  BASIC_LATIN = new UCharacter.UnicodeBlock (
	                "BASIC_LATIN", BASIC_LATIN_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  LATIN_1_SUPPLEMENT = new UCharacter.UnicodeBlock (
	                "LATIN_1_SUPPLEMENT", LATIN_1_SUPPLEMENT_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  LATIN_EXTENDED_A = new UCharacter.UnicodeBlock (
	                "LATIN_EXTENDED_A", LATIN_EXTENDED_A_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  LATIN_EXTENDED_B = new UCharacter.UnicodeBlock (
	                "LATIN_EXTENDED_B", LATIN_EXTENDED_B_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  IPA_EXTENSIONS = new UCharacter.UnicodeBlock (
	                "IPA_EXTENSIONS", IPA_EXTENSIONS_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  SPACING_MODIFIER_LETTERS = new UCharacter.UnicodeBlock (
	                "SPACING_MODIFIER_LETTERS", SPACING_MODIFIER_LETTERS_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  COMBINING_DIACRITICAL_MARKS = new UCharacter.UnicodeBlock (
	                "COMBINING_DIACRITICAL_MARKS", COMBINING_DIACRITICAL_MARKS_ID);
	
	        /// <summary>
	        /// Unicode 3.2 renames this block to "Greek and Coptic".
	        /// </summary>
	        ///
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  GREEK = new UCharacter.UnicodeBlock ("GREEK",
	                GREEK_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  CYRILLIC = new UCharacter.UnicodeBlock (
	                "CYRILLIC", CYRILLIC_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  ARMENIAN = new UCharacter.UnicodeBlock (
	                "ARMENIAN", ARMENIAN_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  HEBREW = new UCharacter.UnicodeBlock ("HEBREW",
	                HEBREW_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  ARABIC = new UCharacter.UnicodeBlock ("ARABIC",
	                ARABIC_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  SYRIAC = new UCharacter.UnicodeBlock ("SYRIAC",
	                SYRIAC_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  THAANA = new UCharacter.UnicodeBlock ("THAANA",
	                THAANA_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  DEVANAGARI = new UCharacter.UnicodeBlock (
	                "DEVANAGARI", DEVANAGARI_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  BENGALI = new UCharacter.UnicodeBlock ("BENGALI",
	                BENGALI_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  GURMUKHI = new UCharacter.UnicodeBlock (
	                "GURMUKHI", GURMUKHI_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  GUJARATI = new UCharacter.UnicodeBlock (
	                "GUJARATI", GUJARATI_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  ORIYA = new UCharacter.UnicodeBlock ("ORIYA",
	                ORIYA_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  TAMIL = new UCharacter.UnicodeBlock ("TAMIL",
	                TAMIL_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  TELUGU = new UCharacter.UnicodeBlock ("TELUGU",
	                TELUGU_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  KANNADA = new UCharacter.UnicodeBlock ("KANNADA",
	                KANNADA_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  MALAYALAM = new UCharacter.UnicodeBlock (
	                "MALAYALAM", MALAYALAM_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  SINHALA = new UCharacter.UnicodeBlock ("SINHALA",
	                SINHALA_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  THAI = new UCharacter.UnicodeBlock ("THAI",
	                THAI_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  LAO = new UCharacter.UnicodeBlock ("LAO", LAO_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  TIBETAN = new UCharacter.UnicodeBlock ("TIBETAN",
	                TIBETAN_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  MYANMAR = new UCharacter.UnicodeBlock ("MYANMAR",
	                MYANMAR_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  GEORGIAN = new UCharacter.UnicodeBlock (
	                "GEORGIAN", GEORGIAN_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  HANGUL_JAMO = new UCharacter.UnicodeBlock (
	                "HANGUL_JAMO", HANGUL_JAMO_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  ETHIOPIC = new UCharacter.UnicodeBlock (
	                "ETHIOPIC", ETHIOPIC_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  CHEROKEE = new UCharacter.UnicodeBlock (
	                "CHEROKEE", CHEROKEE_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  UNIFIED_CANADIAN_ABORIGINAL_SYLLABICS = new UCharacter.UnicodeBlock (
	                "UNIFIED_CANADIAN_ABORIGINAL_SYLLABICS",
	                UNIFIED_CANADIAN_ABORIGINAL_SYLLABICS_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  OGHAM = new UCharacter.UnicodeBlock ("OGHAM",
	                OGHAM_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  RUNIC = new UCharacter.UnicodeBlock ("RUNIC",
	                RUNIC_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  KHMER = new UCharacter.UnicodeBlock ("KHMER",
	                KHMER_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  MONGOLIAN = new UCharacter.UnicodeBlock (
	                "MONGOLIAN", MONGOLIAN_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  LATIN_EXTENDED_ADDITIONAL = new UCharacter.UnicodeBlock (
	                "LATIN_EXTENDED_ADDITIONAL", LATIN_EXTENDED_ADDITIONAL_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  GREEK_EXTENDED = new UCharacter.UnicodeBlock (
	                "GREEK_EXTENDED", GREEK_EXTENDED_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  GENERAL_PUNCTUATION = new UCharacter.UnicodeBlock (
	                "GENERAL_PUNCTUATION", GENERAL_PUNCTUATION_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  SUPERSCRIPTS_AND_SUBSCRIPTS = new UCharacter.UnicodeBlock (
	                "SUPERSCRIPTS_AND_SUBSCRIPTS", SUPERSCRIPTS_AND_SUBSCRIPTS_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  CURRENCY_SYMBOLS = new UCharacter.UnicodeBlock (
	                "CURRENCY_SYMBOLS", CURRENCY_SYMBOLS_ID);
	
	        /// <summary>
	        /// Unicode 3.2 renames this block to "Combining Diacritical Marks for
	        /// Symbols".
	        /// </summary>
	        ///
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  COMBINING_MARKS_FOR_SYMBOLS = new UCharacter.UnicodeBlock (
	                "COMBINING_MARKS_FOR_SYMBOLS", COMBINING_MARKS_FOR_SYMBOLS_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  LETTERLIKE_SYMBOLS = new UCharacter.UnicodeBlock (
	                "LETTERLIKE_SYMBOLS", LETTERLIKE_SYMBOLS_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  NUMBER_FORMS = new UCharacter.UnicodeBlock (
	                "NUMBER_FORMS", NUMBER_FORMS_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  ARROWS = new UCharacter.UnicodeBlock ("ARROWS",
	                ARROWS_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  MATHEMATICAL_OPERATORS = new UCharacter.UnicodeBlock (
	                "MATHEMATICAL_OPERATORS", MATHEMATICAL_OPERATORS_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  MISCELLANEOUS_TECHNICAL = new UCharacter.UnicodeBlock (
	                "MISCELLANEOUS_TECHNICAL", MISCELLANEOUS_TECHNICAL_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  CONTROL_PICTURES = new UCharacter.UnicodeBlock (
	                "CONTROL_PICTURES", CONTROL_PICTURES_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  OPTICAL_CHARACTER_RECOGNITION = new UCharacter.UnicodeBlock (
	                "OPTICAL_CHARACTER_RECOGNITION",
	                OPTICAL_CHARACTER_RECOGNITION_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  ENCLOSED_ALPHANUMERICS = new UCharacter.UnicodeBlock (
	                "ENCLOSED_ALPHANUMERICS", ENCLOSED_ALPHANUMERICS_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  BOX_DRAWING = new UCharacter.UnicodeBlock (
	                "BOX_DRAWING", BOX_DRAWING_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  BLOCK_ELEMENTS = new UCharacter.UnicodeBlock (
	                "BLOCK_ELEMENTS", BLOCK_ELEMENTS_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  GEOMETRIC_SHAPES = new UCharacter.UnicodeBlock (
	                "GEOMETRIC_SHAPES", GEOMETRIC_SHAPES_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  MISCELLANEOUS_SYMBOLS = new UCharacter.UnicodeBlock (
	                "MISCELLANEOUS_SYMBOLS", MISCELLANEOUS_SYMBOLS_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  DINGBATS = new UCharacter.UnicodeBlock (
	                "DINGBATS", DINGBATS_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  BRAILLE_PATTERNS = new UCharacter.UnicodeBlock (
	                "BRAILLE_PATTERNS", BRAILLE_PATTERNS_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  CJK_RADICALS_SUPPLEMENT = new UCharacter.UnicodeBlock (
	                "CJK_RADICALS_SUPPLEMENT", CJK_RADICALS_SUPPLEMENT_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  KANGXI_RADICALS = new UCharacter.UnicodeBlock (
	                "KANGXI_RADICALS", KANGXI_RADICALS_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  IDEOGRAPHIC_DESCRIPTION_CHARACTERS = new UCharacter.UnicodeBlock (
	                "IDEOGRAPHIC_DESCRIPTION_CHARACTERS",
	                IDEOGRAPHIC_DESCRIPTION_CHARACTERS_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  CJK_SYMBOLS_AND_PUNCTUATION = new UCharacter.UnicodeBlock (
	                "CJK_SYMBOLS_AND_PUNCTUATION", CJK_SYMBOLS_AND_PUNCTUATION_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  HIRAGANA = new UCharacter.UnicodeBlock (
	                "HIRAGANA", HIRAGANA_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  KATAKANA = new UCharacter.UnicodeBlock (
	                "KATAKANA", KATAKANA_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  BOPOMOFO = new UCharacter.UnicodeBlock (
	                "BOPOMOFO", BOPOMOFO_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  HANGUL_COMPATIBILITY_JAMO = new UCharacter.UnicodeBlock (
	                "HANGUL_COMPATIBILITY_JAMO", HANGUL_COMPATIBILITY_JAMO_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  KANBUN = new UCharacter.UnicodeBlock ("KANBUN",
	                KANBUN_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  BOPOMOFO_EXTENDED = new UCharacter.UnicodeBlock (
	                "BOPOMOFO_EXTENDED", BOPOMOFO_EXTENDED_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  ENCLOSED_CJK_LETTERS_AND_MONTHS = new UCharacter.UnicodeBlock (
	                "ENCLOSED_CJK_LETTERS_AND_MONTHS",
	                ENCLOSED_CJK_LETTERS_AND_MONTHS_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  CJK_COMPATIBILITY = new UCharacter.UnicodeBlock (
	                "CJK_COMPATIBILITY", CJK_COMPATIBILITY_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A = new UCharacter.UnicodeBlock (
	                "CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A",
	                CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  CJK_UNIFIED_IDEOGRAPHS = new UCharacter.UnicodeBlock (
	                "CJK_UNIFIED_IDEOGRAPHS", CJK_UNIFIED_IDEOGRAPHS_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  YI_SYLLABLES = new UCharacter.UnicodeBlock (
	                "YI_SYLLABLES", YI_SYLLABLES_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  YI_RADICALS = new UCharacter.UnicodeBlock (
	                "YI_RADICALS", YI_RADICALS_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  HANGUL_SYLLABLES = new UCharacter.UnicodeBlock (
	                "HANGUL_SYLLABLES", HANGUL_SYLLABLES_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  HIGH_SURROGATES = new UCharacter.UnicodeBlock (
	                "HIGH_SURROGATES", HIGH_SURROGATES_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  HIGH_PRIVATE_USE_SURROGATES = new UCharacter.UnicodeBlock (
	                "HIGH_PRIVATE_USE_SURROGATES", HIGH_PRIVATE_USE_SURROGATES_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  LOW_SURROGATES = new UCharacter.UnicodeBlock (
	                "LOW_SURROGATES", LOW_SURROGATES_ID);
	
	        /// <summary>
	        /// Same as public static final int PRIVATE_USE. Until Unicode 3.1.1; the
	        /// corresponding block name was "Private Use"; and multiple code point
	        /// ranges had this block. Unicode 3.2 renames the block for the BMP PUA
	        /// to "Private Use Area" and adds separate blocks for the supplementary
	        /// PUAs.
	        /// </summary>
	        ///
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  PRIVATE_USE_AREA = new UCharacter.UnicodeBlock (
	                "PRIVATE_USE_AREA", 78);
	
	        /// <summary>
	        /// Same as public static final int PRIVATE_USE_AREA. Until Unicode
	        /// 3.1.1; the corresponding block name was "Private Use"; and multiple
	        /// code point ranges had this block. Unicode 3.2 renames the block for
	        /// the BMP PUA to "Private Use Area" and adds separate blocks for the
	        /// supplementary PUAs.
	        /// </summary>
	        ///
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  PRIVATE_USE = PRIVATE_USE_AREA;
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  CJK_COMPATIBILITY_IDEOGRAPHS = new UCharacter.UnicodeBlock (
	                "CJK_COMPATIBILITY_IDEOGRAPHS", CJK_COMPATIBILITY_IDEOGRAPHS_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  ALPHABETIC_PRESENTATION_FORMS = new UCharacter.UnicodeBlock (
	                "ALPHABETIC_PRESENTATION_FORMS",
	                ALPHABETIC_PRESENTATION_FORMS_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  ARABIC_PRESENTATION_FORMS_A = new UCharacter.UnicodeBlock (
	                "ARABIC_PRESENTATION_FORMS_A", ARABIC_PRESENTATION_FORMS_A_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  COMBINING_HALF_MARKS = new UCharacter.UnicodeBlock (
	                "COMBINING_HALF_MARKS", COMBINING_HALF_MARKS_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  CJK_COMPATIBILITY_FORMS = new UCharacter.UnicodeBlock (
	                "CJK_COMPATIBILITY_FORMS", CJK_COMPATIBILITY_FORMS_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  SMALL_FORM_VARIANTS = new UCharacter.UnicodeBlock (
	                "SMALL_FORM_VARIANTS", SMALL_FORM_VARIANTS_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  ARABIC_PRESENTATION_FORMS_B = new UCharacter.UnicodeBlock (
	                "ARABIC_PRESENTATION_FORMS_B", ARABIC_PRESENTATION_FORMS_B_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  SPECIALS = new UCharacter.UnicodeBlock (
	                "SPECIALS", SPECIALS_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  HALFWIDTH_AND_FULLWIDTH_FORMS = new UCharacter.UnicodeBlock (
	                "HALFWIDTH_AND_FULLWIDTH_FORMS",
	                HALFWIDTH_AND_FULLWIDTH_FORMS_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  OLD_ITALIC = new UCharacter.UnicodeBlock (
	                "OLD_ITALIC", OLD_ITALIC_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  GOTHIC = new UCharacter.UnicodeBlock ("GOTHIC",
	                GOTHIC_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  DESERET = new UCharacter.UnicodeBlock ("DESERET",
	                DESERET_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  BYZANTINE_MUSICAL_SYMBOLS = new UCharacter.UnicodeBlock (
	                "BYZANTINE_MUSICAL_SYMBOLS", BYZANTINE_MUSICAL_SYMBOLS_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  MUSICAL_SYMBOLS = new UCharacter.UnicodeBlock (
	                "MUSICAL_SYMBOLS", MUSICAL_SYMBOLS_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  MATHEMATICAL_ALPHANUMERIC_SYMBOLS = new UCharacter.UnicodeBlock (
	                "MATHEMATICAL_ALPHANUMERIC_SYMBOLS",
	                MATHEMATICAL_ALPHANUMERIC_SYMBOLS_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  CJK_UNIFIED_IDEOGRAPHS_EXTENSION_B = new UCharacter.UnicodeBlock (
	                "CJK_UNIFIED_IDEOGRAPHS_EXTENSION_B",
	                CJK_UNIFIED_IDEOGRAPHS_EXTENSION_B_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  CJK_COMPATIBILITY_IDEOGRAPHS_SUPPLEMENT = new UCharacter.UnicodeBlock (
	                "CJK_COMPATIBILITY_IDEOGRAPHS_SUPPLEMENT",
	                CJK_COMPATIBILITY_IDEOGRAPHS_SUPPLEMENT_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  TAGS = new UCharacter.UnicodeBlock ("TAGS",
	                TAGS_ID);
	
	        // New blocks in Unicode 3.2
	
	        /// <summary>
	        /// Unicode 4.0.1 renames the "Cyrillic Supplementary" block to
	        /// "Cyrillic Supplement".
	        /// </summary>
	        ///
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  CYRILLIC_SUPPLEMENTARY = new UCharacter.UnicodeBlock (
	                "CYRILLIC_SUPPLEMENTARY", CYRILLIC_SUPPLEMENTARY_ID);
	
	        /// <summary>
	        /// Unicode 4.0.1 renames the "Cyrillic Supplementary" block to
	        /// "Cyrillic Supplement".
	        /// </summary>
	        ///
	        /// @stable ICU 3.0
	        public static readonly UCharacter.UnicodeBlock  CYRILLIC_SUPPLEMENT = new UCharacter.UnicodeBlock (
	                "CYRILLIC_SUPPLEMENT", CYRILLIC_SUPPLEMENT_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  TAGALOG = new UCharacter.UnicodeBlock ("TAGALOG",
	                TAGALOG_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  HANUNOO = new UCharacter.UnicodeBlock ("HANUNOO",
	                HANUNOO_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  BUHID = new UCharacter.UnicodeBlock ("BUHID",
	                BUHID_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  TAGBANWA = new UCharacter.UnicodeBlock (
	                "TAGBANWA", TAGBANWA_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  MISCELLANEOUS_MATHEMATICAL_SYMBOLS_A = new UCharacter.UnicodeBlock (
	                "MISCELLANEOUS_MATHEMATICAL_SYMBOLS_A",
	                MISCELLANEOUS_MATHEMATICAL_SYMBOLS_A_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  SUPPLEMENTAL_ARROWS_A = new UCharacter.UnicodeBlock (
	                "SUPPLEMENTAL_ARROWS_A", SUPPLEMENTAL_ARROWS_A_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  SUPPLEMENTAL_ARROWS_B = new UCharacter.UnicodeBlock (
	                "SUPPLEMENTAL_ARROWS_B", SUPPLEMENTAL_ARROWS_B_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  MISCELLANEOUS_MATHEMATICAL_SYMBOLS_B = new UCharacter.UnicodeBlock (
	                "MISCELLANEOUS_MATHEMATICAL_SYMBOLS_B",
	                MISCELLANEOUS_MATHEMATICAL_SYMBOLS_B_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  SUPPLEMENTAL_MATHEMATICAL_OPERATORS = new UCharacter.UnicodeBlock (
	                "SUPPLEMENTAL_MATHEMATICAL_OPERATORS",
	                SUPPLEMENTAL_MATHEMATICAL_OPERATORS_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  KATAKANA_PHONETIC_EXTENSIONS = new UCharacter.UnicodeBlock (
	                "KATAKANA_PHONETIC_EXTENSIONS", KATAKANA_PHONETIC_EXTENSIONS_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  VARIATION_SELECTORS = new UCharacter.UnicodeBlock (
	                "VARIATION_SELECTORS", VARIATION_SELECTORS_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  SUPPLEMENTARY_PRIVATE_USE_AREA_A = new UCharacter.UnicodeBlock (
	                "SUPPLEMENTARY_PRIVATE_USE_AREA_A",
	                SUPPLEMENTARY_PRIVATE_USE_AREA_A_ID);
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  SUPPLEMENTARY_PRIVATE_USE_AREA_B = new UCharacter.UnicodeBlock (
	                "SUPPLEMENTARY_PRIVATE_USE_AREA_B",
	                SUPPLEMENTARY_PRIVATE_USE_AREA_B_ID);
	
	        
	        /// @stable ICU 2.6
	        public static readonly UCharacter.UnicodeBlock  LIMBU = new UCharacter.UnicodeBlock ("LIMBU",
	                LIMBU_ID);
	
	        
	        /// @stable ICU 2.6
	        public static readonly UCharacter.UnicodeBlock  TAI_LE = new UCharacter.UnicodeBlock ("TAI_LE",
	                TAI_LE_ID);
	
	        
	        /// @stable ICU 2.6
	        public static readonly UCharacter.UnicodeBlock  KHMER_SYMBOLS = new UCharacter.UnicodeBlock (
	                "KHMER_SYMBOLS", KHMER_SYMBOLS_ID);
	
	        
	        /// @stable ICU 2.6
	        public static readonly UCharacter.UnicodeBlock  PHONETIC_EXTENSIONS = new UCharacter.UnicodeBlock (
	                "PHONETIC_EXTENSIONS", PHONETIC_EXTENSIONS_ID);
	
	        
	        /// @stable ICU 2.6
	        public static readonly UCharacter.UnicodeBlock  MISCELLANEOUS_SYMBOLS_AND_ARROWS = new UCharacter.UnicodeBlock (
	                "MISCELLANEOUS_SYMBOLS_AND_ARROWS",
	                MISCELLANEOUS_SYMBOLS_AND_ARROWS_ID);
	
	        
	        /// @stable ICU 2.6
	        public static readonly UCharacter.UnicodeBlock  YIJING_HEXAGRAM_SYMBOLS = new UCharacter.UnicodeBlock (
	                "YIJING_HEXAGRAM_SYMBOLS", YIJING_HEXAGRAM_SYMBOLS_ID);
	
	        
	        /// @stable ICU 2.6
	        public static readonly UCharacter.UnicodeBlock  LINEAR_B_SYLLABARY = new UCharacter.UnicodeBlock (
	                "LINEAR_B_SYLLABARY", LINEAR_B_SYLLABARY_ID);
	
	        
	        /// @stable ICU 2.6
	        public static readonly UCharacter.UnicodeBlock  LINEAR_B_IDEOGRAMS = new UCharacter.UnicodeBlock (
	                "LINEAR_B_IDEOGRAMS", LINEAR_B_IDEOGRAMS_ID);
	
	        
	        /// @stable ICU 2.6
	        public static readonly UCharacter.UnicodeBlock  AEGEAN_NUMBERS = new UCharacter.UnicodeBlock (
	                "AEGEAN_NUMBERS", AEGEAN_NUMBERS_ID);
	
	        
	        /// @stable ICU 2.6
	        public static readonly UCharacter.UnicodeBlock  UGARITIC = new UCharacter.UnicodeBlock (
	                "UGARITIC", UGARITIC_ID);
	
	        
	        /// @stable ICU 2.6
	        public static readonly UCharacter.UnicodeBlock  SHAVIAN = new UCharacter.UnicodeBlock ("SHAVIAN",
	                SHAVIAN_ID);
	
	        
	        /// @stable ICU 2.6
	        public static readonly UCharacter.UnicodeBlock  OSMANYA = new UCharacter.UnicodeBlock ("OSMANYA",
	                OSMANYA_ID);
	
	        
	        /// @stable ICU 2.6
	        public static readonly UCharacter.UnicodeBlock  CYPRIOT_SYLLABARY = new UCharacter.UnicodeBlock (
	                "CYPRIOT_SYLLABARY", CYPRIOT_SYLLABARY_ID);
	
	        
	        /// @stable ICU 2.6
	        public static readonly UCharacter.UnicodeBlock  TAI_XUAN_JING_SYMBOLS = new UCharacter.UnicodeBlock (
	                "TAI_XUAN_JING_SYMBOLS", TAI_XUAN_JING_SYMBOLS_ID);
	
	        
	        /// @stable ICU 2.6
	        public static readonly UCharacter.UnicodeBlock  VARIATION_SELECTORS_SUPPLEMENT = new UCharacter.UnicodeBlock (
	                "VARIATION_SELECTORS_SUPPLEMENT",
	                VARIATION_SELECTORS_SUPPLEMENT_ID);
	
	        /* New blocks in Unicode 4.1 */
	
	        
	        /// @stable ICU 3.4
	        public static readonly UCharacter.UnicodeBlock  ANCIENT_GREEK_MUSICAL_NOTATION = new UCharacter.UnicodeBlock (
	                "ANCIENT_GREEK_MUSICAL_NOTATION",
	                ANCIENT_GREEK_MUSICAL_NOTATION_ID); /* [1D200] */
	
	        
	        /// @stable ICU 3.4
	        public static readonly UCharacter.UnicodeBlock  ANCIENT_GREEK_NUMBERS = new UCharacter.UnicodeBlock (
	                "ANCIENT_GREEK_NUMBERS", ANCIENT_GREEK_NUMBERS_ID); /* [10140] */
	
	        
	        /// @stable ICU 3.4
	        public static readonly UCharacter.UnicodeBlock  ARABIC_SUPPLEMENT = new UCharacter.UnicodeBlock (
	                "ARABIC_SUPPLEMENT", ARABIC_SUPPLEMENT_ID); /* [0750] */
	
	        
	        /// @stable ICU 3.4
	        public static readonly UCharacter.UnicodeBlock  BUGINESE = new UCharacter.UnicodeBlock (
	                "BUGINESE", BUGINESE_ID); /* [1A00] */
	
	        
	        /// @stable ICU 3.4
	        public static readonly UCharacter.UnicodeBlock  CJK_STROKES = new UCharacter.UnicodeBlock (
	                "CJK_STROKES", CJK_STROKES_ID); /* [31C0] */
	
	        
	        /// @stable ICU 3.4
	        public static readonly UCharacter.UnicodeBlock  COMBINING_DIACRITICAL_MARKS_SUPPLEMENT = new UCharacter.UnicodeBlock (
	                "COMBINING_DIACRITICAL_MARKS_SUPPLEMENT",
	                COMBINING_DIACRITICAL_MARKS_SUPPLEMENT_ID); /* [1DC0] */
	
	        
	        /// @stable ICU 3.4
	        public static readonly UCharacter.UnicodeBlock  COPTIC = new UCharacter.UnicodeBlock ("COPTIC",
	                COPTIC_ID); /* [2C80] */
	
	        
	        /// @stable ICU 3.4
	        public static readonly UCharacter.UnicodeBlock  ETHIOPIC_EXTENDED = new UCharacter.UnicodeBlock (
	                "ETHIOPIC_EXTENDED", ETHIOPIC_EXTENDED_ID); /* [2D80] */
	
	        
	        /// @stable ICU 3.4
	        public static readonly UCharacter.UnicodeBlock  ETHIOPIC_SUPPLEMENT = new UCharacter.UnicodeBlock (
	                "ETHIOPIC_SUPPLEMENT", ETHIOPIC_SUPPLEMENT_ID); /* [1380] */
	
	        
	        /// @stable ICU 3.4
	        public static readonly UCharacter.UnicodeBlock  GEORGIAN_SUPPLEMENT = new UCharacter.UnicodeBlock (
	                "GEORGIAN_SUPPLEMENT", GEORGIAN_SUPPLEMENT_ID); /* [2D00] */
	
	        
	        /// @stable ICU 3.4
	        public static readonly UCharacter.UnicodeBlock  GLAGOLITIC = new UCharacter.UnicodeBlock (
	                "GLAGOLITIC", GLAGOLITIC_ID); /* [2C00] */
	
	        
	        /// @stable ICU 3.4
	        public static readonly UCharacter.UnicodeBlock  KHAROSHTHI = new UCharacter.UnicodeBlock (
	                "KHAROSHTHI", KHAROSHTHI_ID); /* [10A00] */
	
	        
	        /// @stable ICU 3.4
	        public static readonly UCharacter.UnicodeBlock  MODIFIER_TONE_LETTERS = new UCharacter.UnicodeBlock (
	                "MODIFIER_TONE_LETTERS", MODIFIER_TONE_LETTERS_ID); /* [A700] */
	
	        
	        /// @stable ICU 3.4
	        public static readonly UCharacter.UnicodeBlock  NEW_TAI_LUE = new UCharacter.UnicodeBlock (
	                "NEW_TAI_LUE", NEW_TAI_LUE_ID); /* [1980] */
	
	        
	        /// @stable ICU 3.4
	        public static readonly UCharacter.UnicodeBlock  OLD_PERSIAN = new UCharacter.UnicodeBlock (
	                "OLD_PERSIAN", OLD_PERSIAN_ID); /* [103A0] */
	
	        
	        /// @stable ICU 3.4
	        public static readonly UCharacter.UnicodeBlock  PHONETIC_EXTENSIONS_SUPPLEMENT = new UCharacter.UnicodeBlock (
	                "PHONETIC_EXTENSIONS_SUPPLEMENT",
	                PHONETIC_EXTENSIONS_SUPPLEMENT_ID); /* [1D80] */
	
	        
	        /// @stable ICU 3.4
	        public static readonly UCharacter.UnicodeBlock  SUPPLEMENTAL_PUNCTUATION = new UCharacter.UnicodeBlock (
	                "SUPPLEMENTAL_PUNCTUATION", SUPPLEMENTAL_PUNCTUATION_ID); /*
	                                                                           * [2E00
	                                                                           * ]
	                                                                           */
	
	        
	        /// @stable ICU 3.4
	        public static readonly UCharacter.UnicodeBlock  SYLOTI_NAGRI = new UCharacter.UnicodeBlock (
	                "SYLOTI_NAGRI", SYLOTI_NAGRI_ID); /* [A800] */
	
	        
	        /// @stable ICU 3.4
	        public static readonly UCharacter.UnicodeBlock  TIFINAGH = new UCharacter.UnicodeBlock (
	                "TIFINAGH", TIFINAGH_ID); /* [2D30] */
	
	        
	        /// @stable ICU 3.4
	        public static readonly UCharacter.UnicodeBlock  VERTICAL_FORMS = new UCharacter.UnicodeBlock (
	                "VERTICAL_FORMS", VERTICAL_FORMS_ID); /* [FE10] */
	
	        
	        /// @draft ICU 3.6
	        /// @provisional This API might change or be removed in a future release.
	        public static readonly UCharacter.UnicodeBlock  NKO = new UCharacter.UnicodeBlock ("NKO", NKO_ID); /*
	                                                                                 * [
	                                                                                 * 07
	                                                                                 * C0
	                                                                                 * ]
	                                                                                 */
	
	        
	        /// @draft ICU 3.6
	        /// @provisional This API might change or be removed in a future release.
	        public static readonly UCharacter.UnicodeBlock  BALINESE = new UCharacter.UnicodeBlock (
	                "BALINESE", BALINESE_ID); /* [1B00] */
	
	        
	        /// @draft ICU 3.6
	        /// @provisional This API might change or be removed in a future release.
	        public static readonly UCharacter.UnicodeBlock  LATIN_EXTENDED_C = new UCharacter.UnicodeBlock (
	                "LATIN_EXTENDED_C", LATIN_EXTENDED_C_ID); /* [2C60] */
	
	        
	        /// @draft ICU 3.6
	        /// @provisional This API might change or be removed in a future release.
	        public static readonly UCharacter.UnicodeBlock  LATIN_EXTENDED_D = new UCharacter.UnicodeBlock (
	                "LATIN_EXTENDED_D", LATIN_EXTENDED_D_ID); /* [A720] */
	
	        
	        /// @draft ICU 3.6
	        /// @provisional This API might change or be removed in a future release.
	        public static readonly UCharacter.UnicodeBlock  PHAGS_PA = new UCharacter.UnicodeBlock (
	                "PHAGS_PA", PHAGS_PA_ID); /* [A840] */
	
	        
	        /// @draft ICU 3.6
	        /// @provisional This API might change or be removed in a future release.
	        public static readonly UCharacter.UnicodeBlock  PHOENICIAN = new UCharacter.UnicodeBlock (
	                "PHOENICIAN", PHOENICIAN_ID); /* [10900] */
	
	        
	        /// @draft ICU 3.6
	        /// @provisional This API might change or be removed in a future release.
	        public static readonly UCharacter.UnicodeBlock  CUNEIFORM = new UCharacter.UnicodeBlock (
	                "CUNEIFORM", CUNEIFORM_ID); /* [12000] */
	
	        
	        /// @draft ICU 3.6
	        /// @provisional This API might change or be removed in a future release.
	        public static readonly UCharacter.UnicodeBlock  CUNEIFORM_NUMBERS_AND_PUNCTUATION = new UCharacter.UnicodeBlock (
	                "CUNEIFORM_NUMBERS_AND_PUNCTUATION",
	                CUNEIFORM_NUMBERS_AND_PUNCTUATION_ID); /* [12400] */
	
	        
	        /// @draft ICU 3.6
	        /// @provisional This API might change or be removed in a future release.
	        public static readonly UCharacter.UnicodeBlock  COUNTING_ROD_NUMERALS = new UCharacter.UnicodeBlock (
	                "COUNTING_ROD_NUMERALS", COUNTING_ROD_NUMERALS_ID); /* [1D360] */
	
	        
	        /// @stable ICU 2.4
	        public static readonly UCharacter.UnicodeBlock  INVALID_CODE = new UCharacter.UnicodeBlock (
	                "INVALID_CODE", INVALID_CODE_ID);
	
	        // public methods --------------------------------------------------
	
	        /// <summary>
	        /// Gets the only instance of the UnicodeBlock with the argument ID. If
	        /// no such ID exists, a INVALID_CODE UnicodeBlock will be returned.
	        /// </summary>
	        ///
	        /// <param name="id">UnicodeBlock ID</param>
	        /// <returns>the only instance of the UnicodeBlock with the argument ID if
	        /// it exists, otherwise a INVALID_CODE UnicodeBlock will be
	        /// returned.</returns>
	        /// @stable ICU 2.4
	        public static UCharacter.UnicodeBlock  GetInstance(int id) {
	            if (id >= 0 && id < BLOCKS_.Length) {
	                return BLOCKS_[id];
	            }
	            return INVALID_CODE;
	        }
	
	        /// <summary>
	        /// Returns the Unicode allocation block that contains the code point, or
	        /// null if the code point is not a member of a defined block.
	        /// </summary>
	        ///
	        /// <param name="ch">code point to be tested</param>
	        /// <returns>the Unicode allocation block that contains the code point</returns>
	        /// @stable ICU 2.4
	        public static UCharacter.UnicodeBlock  Of(int ch) {
	            if (ch > IBM.ICU.Lang.UCharacter.MAX_VALUE) {
	                return INVALID_CODE;
	            }
	
	            return UnicodeBlock
	                    .GetInstance((IBM.ICU.Lang.UCharacter.PROPERTY_.GetAdditional(ch, 0) & IBM.ICU.Lang.UCharacter.BLOCK_MASK_) >> IBM.ICU.Lang.UCharacter.BLOCK_SHIFT_);
	        }
	
	        /// <exclude/>
	        /// <summary>
	        /// Internal function returning of(ch).getID().
	        /// </summary>
	        ///
	        /// <param name="ch"></param>
	        /// <returns>numeric block value</returns>
	        static internal int IdOf(int ch) {
	            if (ch < 0 || ch > IBM.ICU.Lang.UCharacter.MAX_VALUE) {
	                return -1;
	            }
	
	            return (IBM.ICU.Lang.UCharacter.PROPERTY_.GetAdditional(ch, 0) & IBM.ICU.Lang.UCharacter.BLOCK_MASK_) >> IBM.ICU.Lang.UCharacter.BLOCK_SHIFT_;
	        }
	
	        /// <summary>
	        /// Cover the JDK 1.5 API. Return the Unicode block with the given name. <br/>
	        /// <b>Note</b>: Unlike JDK 1.5, this only matches against the official
	        /// UCD name and the Java block name (ignoring case).
	        /// </summary>
	        ///
	        /// <param name="blockName">the name of the block to match</param>
	        /// <returns>the UnicodeBlock with that name</returns>
	        /// <exception cref="IllegalArgumentException">if the blockName could not be matched</exception>
	        /// @stable ICU 3.0
	        public static UCharacter.UnicodeBlock  ForName(String blockName) {
	            IDictionary m = null;
	            if (mref != null) {
	                m = (IDictionary) mref.Target;
	            }
	            if (m == null) {
	                m = new Hashtable(BLOCKS_.Length);
	                for (int i = 0; i < BLOCKS_.Length; ++i) {
	                    UCharacter.UnicodeBlock  b = BLOCKS_[i];
	                    String name = IBM.ICU.Lang.UCharacter.GetPropertyValueName(IBM.ICU.Lang.UProperty_Constants.BLOCK,
	                            b.GetID(), IBM.ICU.Lang.UProperty_Constants.NameChoice.LONG);
	                    ILOG.J2CsMapping.Collections.Collections.Put(m,name.ToUpper(),b);
	                    ILOG.J2CsMapping.Collections.Collections.Put(m,name.Replace('_', ' ').ToUpper(),b);
	                    ILOG.J2CsMapping.Collections.Collections.Put(m,b.ToString().ToUpper(),b);
	                }
	                mref = new WeakReference(m);
	            }
	            UCharacter.UnicodeBlock  b_0 = (UCharacter.UnicodeBlock ) ILOG.J2CsMapping.Collections.Collections.Get(m,blockName.ToUpper());
	            if (b_0 == null) {
	                throw new ArgumentException();
	            }
	            return b_0;
	        }
	
	        private static WeakReference mref;
	
	        /// <summary>
	        /// Returns the type ID of this Unicode block
	        /// </summary>
	        ///
	        /// <returns>integer type ID of this Unicode block</returns>
	        /// @stable ICU 2.4
	        public int GetID() {
	            return m_id_;
	        }
	
	        // private data members ---------------------------------------------
	
	        /// <summary>
	        /// Array of UnicodeBlocks, for easy access in getInstance(int)
	        /// </summary>
	        ///
	        private static readonly UCharacter.UnicodeBlock [] BLOCKS_ = { NO_BLOCK, BASIC_LATIN,
	                LATIN_1_SUPPLEMENT, LATIN_EXTENDED_A, LATIN_EXTENDED_B,
	                IPA_EXTENSIONS, SPACING_MODIFIER_LETTERS,
	                COMBINING_DIACRITICAL_MARKS, GREEK, CYRILLIC, ARMENIAN, HEBREW,
	                ARABIC, SYRIAC, THAANA, DEVANAGARI, BENGALI, GURMUKHI,
	                GUJARATI, ORIYA, TAMIL, TELUGU, KANNADA, MALAYALAM, SINHALA,
	                THAI, LAO, TIBETAN, MYANMAR, GEORGIAN, HANGUL_JAMO, ETHIOPIC,
	                CHEROKEE, UNIFIED_CANADIAN_ABORIGINAL_SYLLABICS, OGHAM, RUNIC,
	                KHMER, MONGOLIAN, LATIN_EXTENDED_ADDITIONAL, GREEK_EXTENDED,
	                GENERAL_PUNCTUATION, SUPERSCRIPTS_AND_SUBSCRIPTS,
	                CURRENCY_SYMBOLS, COMBINING_MARKS_FOR_SYMBOLS,
	                LETTERLIKE_SYMBOLS, NUMBER_FORMS, ARROWS,
	                MATHEMATICAL_OPERATORS, MISCELLANEOUS_TECHNICAL,
	                CONTROL_PICTURES, OPTICAL_CHARACTER_RECOGNITION,
	                ENCLOSED_ALPHANUMERICS, BOX_DRAWING, BLOCK_ELEMENTS,
	                GEOMETRIC_SHAPES, MISCELLANEOUS_SYMBOLS, DINGBATS,
	                BRAILLE_PATTERNS, CJK_RADICALS_SUPPLEMENT, KANGXI_RADICALS,
	                IDEOGRAPHIC_DESCRIPTION_CHARACTERS,
	                CJK_SYMBOLS_AND_PUNCTUATION, HIRAGANA, KATAKANA, BOPOMOFO,
	                HANGUL_COMPATIBILITY_JAMO, KANBUN, BOPOMOFO_EXTENDED,
	                ENCLOSED_CJK_LETTERS_AND_MONTHS, CJK_COMPATIBILITY,
	                CJK_UNIFIED_IDEOGRAPHS_EXTENSION_A, CJK_UNIFIED_IDEOGRAPHS,
	                YI_SYLLABLES, YI_RADICALS, HANGUL_SYLLABLES, HIGH_SURROGATES,
	                HIGH_PRIVATE_USE_SURROGATES, LOW_SURROGATES, PRIVATE_USE_AREA,
	                CJK_COMPATIBILITY_IDEOGRAPHS, ALPHABETIC_PRESENTATION_FORMS,
	                ARABIC_PRESENTATION_FORMS_A, COMBINING_HALF_MARKS,
	                CJK_COMPATIBILITY_FORMS, SMALL_FORM_VARIANTS,
	                ARABIC_PRESENTATION_FORMS_B, SPECIALS,
	                HALFWIDTH_AND_FULLWIDTH_FORMS, OLD_ITALIC, GOTHIC, DESERET,
	                BYZANTINE_MUSICAL_SYMBOLS, MUSICAL_SYMBOLS,
	                MATHEMATICAL_ALPHANUMERIC_SYMBOLS,
	                CJK_UNIFIED_IDEOGRAPHS_EXTENSION_B,
	                CJK_COMPATIBILITY_IDEOGRAPHS_SUPPLEMENT, TAGS,
	                CYRILLIC_SUPPLEMENT, TAGALOG, HANUNOO, BUHID, TAGBANWA,
	                MISCELLANEOUS_MATHEMATICAL_SYMBOLS_A, SUPPLEMENTAL_ARROWS_A,
	                SUPPLEMENTAL_ARROWS_B, MISCELLANEOUS_MATHEMATICAL_SYMBOLS_B,
	                SUPPLEMENTAL_MATHEMATICAL_OPERATORS,
	                KATAKANA_PHONETIC_EXTENSIONS, VARIATION_SELECTORS,
	                SUPPLEMENTARY_PRIVATE_USE_AREA_A,
	                SUPPLEMENTARY_PRIVATE_USE_AREA_B, LIMBU, TAI_LE, KHMER_SYMBOLS,
	                PHONETIC_EXTENSIONS, MISCELLANEOUS_SYMBOLS_AND_ARROWS,
	                YIJING_HEXAGRAM_SYMBOLS, LINEAR_B_SYLLABARY,
	                LINEAR_B_IDEOGRAMS, AEGEAN_NUMBERS, UGARITIC, SHAVIAN, OSMANYA,
	                CYPRIOT_SYLLABARY, TAI_XUAN_JING_SYMBOLS,
	                VARIATION_SELECTORS_SUPPLEMENT, ANCIENT_GREEK_MUSICAL_NOTATION,
	                ANCIENT_GREEK_NUMBERS, ARABIC_SUPPLEMENT, BUGINESE,
	                CJK_STROKES, COMBINING_DIACRITICAL_MARKS_SUPPLEMENT, COPTIC,
	                ETHIOPIC_EXTENDED, ETHIOPIC_SUPPLEMENT, GEORGIAN_SUPPLEMENT,
	                GLAGOLITIC, KHAROSHTHI, MODIFIER_TONE_LETTERS, NEW_TAI_LUE,
	                OLD_PERSIAN, PHONETIC_EXTENSIONS_SUPPLEMENT,
	                SUPPLEMENTAL_PUNCTUATION, SYLOTI_NAGRI, TIFINAGH,
	                VERTICAL_FORMS, NKO, BALINESE, LATIN_EXTENDED_C,
	                LATIN_EXTENDED_D, PHAGS_PA, PHOENICIAN, CUNEIFORM,
	                CUNEIFORM_NUMBERS_AND_PUNCTUATION, COUNTING_ROD_NUMERALS };
	
	        /// <summary>
	        /// Identification code for this UnicodeBlock
	        /// </summary>
	        ///
	        private int m_id_;
	
	        // private constructor ----------------------------------------------
	
	        /// <summary>
	        /// UnicodeBlock constructor
	        /// </summary>
	        ///
	        /// <param name="name">name of this UnicodeBlock</param>
	        /// <param name="id">unique id of this UnicodeBlock</param>
	        /// <exception cref="NullPointerException">if name is <c>null</c></exception>
	        public UnicodeBlock(String name, int id) : base(name) {
	            m_id_ = id;
	        }
	
	        static UnicodeBlock() {
	                    if (COUNT != BLOCKS_.Length) {
	                        throw new InvalidOperationException(
	                                "UnicodeBlock fields are inconsistent!");
	                    }
	                }
	    }
	
	    /// <summary>
	    /// East Asian Width constants.
	    /// </summary>
	    ///
	    /// <seealso cref="null"/>
	    /// <seealso cref="M:IBM.ICU.Lang.UCharacter.GetIntPropertyValue(System.Int32, System.Int32)"/>
	    /// @stable ICU 2.4
	    public class EastAsianWidth {
	        
	        /// @stable ICU 2.4
            const int NEUTRAL = 0;
	
	        
	        /// @stable ICU 2.4
	        const int AMBIGUOUS = 1;
	
	        
	        /// @stable ICU 2.4
	        const int HALFWIDTH = 2;
	
	        
	        /// @stable ICU 2.4
	        const int FULLWIDTH = 3;
	
	        
	        /// @stable ICU 2.4
	        const int NARROW = 4;
	
	        
	        /// @stable ICU 2.4
	        const int WIDE = 5;
	
	        
	        /// @stable ICU 2.4
	        const int COUNT = 6;
	    }
	
	    /// <summary>
	    /// Decomposition Type constants.
	    /// </summary>
	    ///
	    /// <seealso cref="null"/>
	    /// @stable ICU 2.4
	    public class DecompositionType {
	        
	        /// @stable ICU 2.4
	        const int NONE = 0;
	
	        
	        /// @stable ICU 2.4
	        const int CANONICAL = 1;
	
	        
	        /// @stable ICU 2.4
	        const int COMPAT = 2;
	
	        
	        /// @stable ICU 2.4
	        const int CIRCLE = 3;
	
	        
	        /// @stable ICU 2.4
	        const int FINAL = 4;
	
	        
	        /// @stable ICU 2.4
	        const int FONT = 5;
	
	        
	        /// @stable ICU 2.4
	        const int FRACTION = 6;
	
	        
	        /// @stable ICU 2.4
	        const int INITIAL = 7;
	
	        
	        /// @stable ICU 2.4
	        const int ISOLATED = 8;
	
	        
	        /// @stable ICU 2.4
	        const int MEDIAL = 9;
	
	        
	        /// @stable ICU 2.4
	        const int NARROW = 10;
	
	        
	        /// @stable ICU 2.4
	        const int NOBREAK = 11;
	
	        
	        /// @stable ICU 2.4
	        const int SMALL = 12;
	
	        
	        /// @stable ICU 2.4
	        const int SQUARE = 13;
	
	        
	        /// @stable ICU 2.4
	        const int SUB = 14;
	
	        
	        /// @stable ICU 2.4
	        const int SUPER = 15;
	
	        
	        /// @stable ICU 2.4
	        const int VERTICAL = 16;
	
	        
	        /// @stable ICU 2.4
	        const int WIDE = 17;
	
	        
	        /// @stable ICU 2.4
	        const int COUNT = 18;
	    }
	
	    /// <summary>
	    /// Joining Type constants.
	    /// </summary>
	    ///
	    /// <seealso cref="null"/>
	    /// @stable ICU 2.4
	    public class JoiningType {
	        
	        /// @stable ICU 2.4
	        const int NON_JOINING = 0;
	
	        
	        /// @stable ICU 2.4
	        const int JOIN_CAUSING = 1;
	
	        
	        /// @stable ICU 2.4
	        const int DUAL_JOINING = 2;
	
	        
	        /// @stable ICU 2.4
	        const int LEFT_JOINING = 3;
	
	        
	        /// @stable ICU 2.4
	        const int RIGHT_JOINING = 4;
	
	        
	        /// @stable ICU 2.4
	        const int TRANSPARENT = 5;
	
	        
	        /// @stable ICU 2.4
	        const int COUNT = 6;
	    }
	
	    /// <summary>
	    /// Joining Group constants.
	    /// </summary>
	    ///
	    /// <seealso cref="null"/>
	    /// @stable ICU 2.4
	    public class JoiningGroup {
	        
	        /// @stable ICU 2.4
	        public const int NO_JOINING_GROUP = 0;
	
	        
	        /// @stable ICU 2.4
            public const int AIN = 1;
	
	        
	        /// @stable ICU 2.4
            public const int ALAPH = 2;
	
	        
	        /// @stable ICU 2.4
            public const int ALEF = 3;
	
	        
	        /// @stable ICU 2.4
            public const int BEH = 4;
	
	        
	        /// @stable ICU 2.4
            public const int BETH = 5;
	
	        
	        /// @stable ICU 2.4
            public const int DAL = 6;
	
	        
	        /// @stable ICU 2.4
            public const int DALATH_RISH = 7;
	
	        
	        /// @stable ICU 2.4
            public const int E = 8;
	
	        
	        /// @stable ICU 2.4
            public const int FEH = 9;
	
	        
	        /// @stable ICU 2.4
            public const int FINAL_SEMKATH = 10;
	
	        
	        /// @stable ICU 2.4
            public const int GAF = 11;
	
	        
	        /// @stable ICU 2.4
            public const int GAMAL = 12;
	
	        
	        /// @stable ICU 2.4
            public const int HAH = 13;
	
	        
	        /// @stable ICU 2.4
            public const int HAMZA_ON_HEH_GOAL = 14;
	
	        
	        /// @stable ICU 2.4
            public const int HE = 15;
	
	        
	        /// @stable ICU 2.4
            public const int HEH = 16;
	
	        
	        /// @stable ICU 2.4
            public const int HEH_GOAL = 17;
	
	        
	        /// @stable ICU 2.4
            public const int HETH = 18;
	
	        
	        /// @stable ICU 2.4
            public const int KAF = 19;
	
	        
	        /// @stable ICU 2.4
            public const int KAPH = 20;
	
	        
	        /// @stable ICU 2.4
            public const int KNOTTED_HEH = 21;
	
	        
	        /// @stable ICU 2.4
            public const int LAM = 22;
	
	        
	        /// @stable ICU 2.4
            public const int LAMADH = 23;
	
	        
	        /// @stable ICU 2.4
            public const int MEEM = 24;
	
	        
	        /// @stable ICU 2.4
            public const int MIM = 25;
	
	        
	        /// @stable ICU 2.4
            public const int NOON = 26;
	
	        
	        /// @stable ICU 2.4
            public const int NUN = 27;
	
	        
	        /// @stable ICU 2.4
            public const int PE = 28;
	
	        
	        /// @stable ICU 2.4
            public const int QAF = 29;
	
	        
	        /// @stable ICU 2.4
            public const int QAPH = 30;
	
	        
	        /// @stable ICU 2.4
            public const int REH = 31;
	
	        
	        /// @stable ICU 2.4
            public const int REVERSED_PE = 32;
	
	        
	        /// @stable ICU 2.4
            public const int SAD = 33;
	
	        
	        /// @stable ICU 2.4
	        const int SADHE = 34;
	
	        
	        /// @stable ICU 2.4
            public const int SEEN = 35;
	
	        
	        /// @stable ICU 2.4
            public const int SEMKATH = 36;
	
	        
	        /// @stable ICU 2.4
            public const int SHIN = 37;
	
	        
	        /// @stable ICU 2.4
            public const int SWASH_KAF = 38;
	
	        
	        /// @stable ICU 2.4
            public const int SYRIAC_WAW = 39;
	
	        
	        /// @stable ICU 2.4
            public const int TAH = 40;
	
	        
	        /// @stable ICU 2.4
            public const int TAW = 41;
	
	        
	        /// @stable ICU 2.4
            public const int TEH_MARBUTA = 42;
	
	        
	        /// @stable ICU 2.4
            public const int TETH = 43;
	
	        
	        /// @stable ICU 2.4
            public const int WAW = 44;
	
	        
	        /// @stable ICU 2.4
            public const int YEH = 45;
	
	        
	        /// @stable ICU 2.4
            public const int YEH_BARREE = 46;
	
	        
	        /// @stable ICU 2.4
            public const int YEH_WITH_TAIL = 47;
	
	        
	        /// @stable ICU 2.4
            public const int YUDH = 48;
	
	        
	        /// @stable ICU 2.4
            public const int YUDH_HE = 49;
	
	        
	        /// @stable ICU 2.4
            public const int ZAIN = 50;
	
	        
	        /// @stable ICU 2.6
            public const int FE = 51;
	
	        
	        /// @stable ICU 2.6
            public const int KHAPH = 52;
	
	        
	        /// @stable ICU 2.6
            public const int ZHAIN = 53;
	
	        
	        /// @stable ICU 2.4
            public const int COUNT = 54;
	    }
	
	    /// <summary>
	    /// Grapheme Cluster Break constants.
	    /// </summary>
	    ///
	    /// <seealso cref="null"/>
	    /// @stable ICU 3.4
	    public class GraphemeClusterBreak {
	        
	        /// @stable ICU 3.4
	        const int OTHER = 0;
	
	        
	        /// @stable ICU 3.4
	        const int CONTROL = 1;
	
	        
	        /// @stable ICU 3.4
	        const int CR = 2;
	
	        
	        /// @stable ICU 3.4
	        const int EXTEND = 3;
	
	        
	        /// @stable ICU 3.4
	        const int L = 4;
	
	        
	        /// @stable ICU 3.4
	        const int LF = 5;
	
	        
	        /// @stable ICU 3.4
	        const int LV = 6;
	
	        
	        /// @stable ICU 3.4
	        const int LVT = 7;
	
	        
	        /// @stable ICU 3.4
	        const int T = 8;
	
	        
	        /// @stable ICU 3.4
	        const int V = 9;
	
	        
	        /// @stable ICU 3.4
	        const int COUNT = 10;
	    }
	
	    /// <summary>
	    /// Word Break constants.
	    /// </summary>
	    ///
	    /// <seealso cref="null"/>
	    /// @stable ICU 3.4
	    public class WordBreak {
	        
	        /// @stable ICU 3.8
	        const int OTHER = 0;
	
	        
	        /// @stable ICU 3.8
	        const int ALETTER = 1;
	
	        
	        /// @stable ICU 3.8
	        const int FORMAT = 2;
	
	        
	        /// @stable ICU 3.8
	        const int KATAKANA = 3;
	
	        
	        /// @stable ICU 3.8
	        const int MIDLETTER = 4;
	
	        
	        /// @stable ICU 3.8
	        const int MIDNUM = 5;
	
	        
	        /// @stable ICU 3.8
	        const int NUMERIC = 6;
	
	        
	        /// @stable ICU 3.8
	        const int EXTENDNUMLET = 7;
	
	        
	        /// @stable ICU 3.8
	        const int COUNT = 8;
	    }
	
	    /// <summary>
	    /// Sentence Break constants.
	    /// </summary>
	    ///
	    /// <seealso cref="null"/>
	    /// @stable ICU 3.4
	    public class SentenceBreak {
	        
	        /// @stable ICU 3.8
	        const int OTHER = 0;
	
	        
	        /// @stable ICU 3.8
	        const int ATERM = 1;
	
	        
	        /// @stable ICU 3.8
	        const int CLOSE = 2;
	
	        
	        /// @stable ICU 3.8
	        const int FORMAT = 3;
	
	        
	        /// @stable ICU 3.8
	        const int LOWER = 4;
	
	        
	        /// @stable ICU 3.8
	        const int NUMERIC = 5;
	
	        
	        /// @stable ICU 3.8
	        const int OLETTER = 6;
	
	        
	        /// @stable ICU 3.8
	        const int SEP = 7;
	
	        
	        /// @stable ICU 3.8
	        const int SP = 8;
	
	        
	        /// @stable ICU 3.8
	        const int STERM = 9;
	
	        
	        /// @stable ICU 3.8
	        const int UPPER = 10;
	
	        
	        /// @stable ICU 3.8
	        const int COUNT = 11;
	    }
	
	    /// <summary>
	    /// Line Break constants.
	    /// </summary>
	    ///
	    /// <seealso cref="null"/>
	    /// @stable ICU 2.4
        public class LineBreak
        {
	        
	        /// @stable ICU 2.4
	        const int UNKNOWN = 0;
	
	        
	        /// @stable ICU 2.4
	        const int AMBIGUOUS = 1;
	
	        
	        /// @stable ICU 2.4
	        const int ALPHABETIC = 2;
	
	        
	        /// @stable ICU 2.4
	        const int BREAK_BOTH = 3;
	
	        
	        /// @stable ICU 2.4
	        const int BREAK_AFTER = 4;
	
	        
	        /// @stable ICU 2.4
	        const int BREAK_BEFORE = 5;
	
	        
	        /// @stable ICU 2.4
	        const int MANDATORY_BREAK = 6;
	
	        
	        /// @stable ICU 2.4
	        const int CONTINGENT_BREAK = 7;
	
	        
	        /// @stable ICU 2.4
	        const int CLOSE_PUNCTUATION = 8;
	
	        
	        /// @stable ICU 2.4
	        public const int COMBINING_MARK = 9;
	
	        
	        /// @stable ICU 2.4
	        const int CARRIAGE_RETURN = 10;
	
	        
	        /// @stable ICU 2.4
	        const int EXCLAMATION = 11;
	
	        
	        /// @stable ICU 2.4
	        const int GLUE = 12;
	
	        
	        /// @stable ICU 2.4
	        const int HYPHEN = 13;
	
	        
	        /// @stable ICU 2.4
	        const int IDEOGRAPHIC = 14;
	
	        
	        /// <seealso cref="null"/>
	        /// @stable ICU 2.4
	        const int INSEPERABLE = 15;
	
	        /// <summary>
	        /// Renamed from the misspelled "inseperable" in Unicode 4.0.1.
	        /// </summary>
	        ///
	        /// @stable ICU 3.0
	        const int INSEPARABLE = 15;
	
	        
	        /// @stable ICU 2.4
	        const int INFIX_NUMERIC = 16;
	
	        
	        /// @stable ICU 2.4
	        const int LINE_FEED = 17;
	
	        
	        /// @stable ICU 2.4
	        const int NONSTARTER = 18;
	
	        
	        /// @stable ICU 2.4
	        const int NUMERIC = 19;
	
	        
	        /// @stable ICU 2.4
	        const int OPEN_PUNCTUATION = 20;
	
	        
	        /// @stable ICU 2.4
	        const int POSTFIX_NUMERIC = 21;
	
	        
	        /// @stable ICU 2.4
	        const int PREFIX_NUMERIC = 22;
	
	        
	        /// @stable ICU 2.4
	        const int QUOTATION = 23;
	
	        
	        /// @stable ICU 2.4
	        const int COMPLEX_CONTEXT = 24;
	
	        
	        /// @stable ICU 2.4
	        const int SURROGATE = 25;
	
	        
	        /// @stable ICU 2.4
	        const int SPACE = 26;
	
	        
	        /// @stable ICU 2.4
	        const int BREAK_SYMBOLS = 27;
	
	        
	        /// @stable ICU 2.4
	        const int ZWSPACE = 28;
	
	        
	        /// @stable ICU 2.6
	        const int NEXT_LINE = 29; /* [NL] *//*
	                                                           * from here on: new
	                                                           * in Unicode 4/ICU
	                                                           * 2.6
	                                                           */
	
	        
	        /// @stable ICU 2.6
	        const int WORD_JOINER = 30; /* [WJ] */
	
	        /* from here on: new in Unicode 4.1/ICU 3.4 */
	
	        
	        /// @stable ICU 3.4
	        const int H2 = 31;
	
	        
	        /// @stable ICU 3.4
	        const int H3 = 32;
	
	        
	        /// @stable ICU 3.4
	        const int JL = 33;
	
	        
	        /// @stable ICU 3.4
	        const int JT = 34;
	
	        
	        /// @stable ICU 3.4
	        const int JV = 35;
	
	        
	        /// @stable ICU 2.4
	        const int COUNT = 36;
	    }
	
	    /// <summary>
	    /// Numeric Type constants.
	    /// </summary>
	    ///
	    /// <seealso cref="null"/>
	    /// @stable ICU 2.4
        public class NumericType
        {
	        
	        /// @stable ICU 2.4
            public const int NONE = 0;
	
	        
	        /// @stable ICU 2.4
            public const int DECIMAL = 1;
	
	        
	        /// @stable ICU 2.4
            public const int DIGIT = 2;
	
	        
	        /// @stable ICU 2.4
            public const int NUMERIC = 3;
	
	        
	        /// @stable ICU 2.4
            public const int COUNT = 4;
	    }
	
	    /// <summary>
	    /// Hangul Syllable Type constants.
	    /// </summary>
	    ///
	    /// <seealso cref="null"/>
	    /// @stable ICU 2.6
        public class HangulSyllableType
        {
	        
	        /// @stable ICU 2.6
	        public const int NOT_APPLICABLE = 0; /* [NA] *//* See note !! */
	
	        
	        /// @stable ICU 2.6
            public const int LEADING_JAMO = 1; /* [L] */
	
	        
	        /// @stable ICU 2.6
            public const int VOWEL_JAMO = 2; /* [V] */
	
	        
	        /// @stable ICU 2.6
            public const int TRAILING_JAMO = 3; /* [T] */
	
	        
	        /// @stable ICU 2.6
            public const int LV_SYLLABLE = 4; /* [LV] */
	
	        
	        /// @stable ICU 2.6
            public const int LVT_SYLLABLE = 5; /* [LVT] */
	
	        
	        /// @stable ICU 2.6
            public const int COUNT = 6;
	    }
	
	    // public data members -----------------------------------------------
	
	    /// <summary>
	    /// The lowest Unicode code point value.
	    /// </summary>
	    ///
	    /// @stable ICU 2.1
	    public const int MIN_VALUE = IBM.ICU.Text.UTF16.CODEPOINT_MIN_VALUE;
	
	    /// <summary>
	    /// The highest Unicode code point value (scalar value) according to the
	    /// Unicode Standard. This is a 21-bit value (21 bits, rounded up).<br>
	    /// Up-to-date Unicode implementation of java.lang.Character.MIN_VALUE
	    /// </summary>
	    ///
	    /// @stable ICU 2.1
	    public const int MAX_VALUE = IBM.ICU.Text.UTF16.CODEPOINT_MAX_VALUE;
	
	    /// <summary>
	    /// The minimum value for Supplementary code points
	    /// </summary>
	    ///
	    /// @stable ICU 2.1
	    public const int SUPPLEMENTARY_MIN_VALUE = IBM.ICU.Text.UTF16.SUPPLEMENTARY_MIN_VALUE;
	
	    /// <summary>
	    /// Unicode value used when translating into Unicode encoding form and there
	    /// is no existing character.
	    /// </summary>
	    ///
	    /// @stable ICU 2.1
	    public const int REPLACEMENT_CHAR = '\uFFFD';
	
	    /// <summary>
	    /// Special value that is returned by getUnicodeNumericValue(int) when no
	    /// numeric value is defined for a code point.
	    /// </summary>
	    ///
	    /// @stable ICU 2.4
	    /// <seealso cref="M:IBM.ICU.Lang.UCharacter.GetUnicodeNumericValue(System.Int32)"/>
	    public const double NO_NUMERIC_VALUE = -123456789;
	
	    /// <summary>
	    /// Compatibility constant for Java Character's MIN_RADIX.
	    /// </summary>
	    ///
	    /// @stable ICU 3.4
        public static int MIN_RADIX = Character.MIN_RADIX;
	
	    /// <summary>
	    /// Compatibility constant for Java Character's MAX_RADIX.
	    /// </summary>
	    ///
	    /// @stable ICU 3.4
	    public static int MAX_RADIX = ILOG.J2CsMapping.Util.Character.MAX_RADIX;
	
	    /// <summary>
	    /// Do not lowercase non-initial parts of words when titlecasing. Option bit
	    /// for titlecasing APIs that take an options bit set.
	    /// By default, titlecasing will titlecase the first cased character of a
	    /// word and lowercase all other characters. With this option, the other
	    /// characters will not be modified.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Lang.UCharacter.ToTitleCase(System.Int32)"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const int TITLECASE_NO_LOWERCASE = 0x100;
	
	    /// <summary>
	    /// Do not adjust the titlecasing indexes from BreakIterator::next() indexes;
	    /// titlecase exactly the characters at breaks from the iterator. Option bit
	    /// for titlecasing APIs that take an options bit set.
	    /// By default, titlecasing will take each break iterator index, adjust it by
	    /// looking for the next cased character, and titlecase that one. Other
	    /// characters are lowercased.
	    /// This follows Unicode 4 & 5 section 3.13 Default Case Operations:
	    /// R3 toTitlecase(X): Find the word boundaries based on Unicode Standard
	    /// Annex #29, "Text Boundaries." Between each pair of word boundaries, find
	    /// the first cased character F. If F exists, map F to default_title(F); then
	    /// map each subsequent character C to default_lower(C).
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Lang.UCharacter.ToTitleCase(System.Int32)"/>
	    /// <seealso cref="F:IBM.ICU.Lang.UCharacter.TITLECASE_NO_LOWERCASE"/>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const int TITLECASE_NO_BREAK_ADJUSTMENT = 0x200;
	
	    // public methods ----------------------------------------------------
	
	    /// <summary>
	    /// Retrieves the numeric value of a decimal digit code point. <br>
	    /// This method observes the semantics of
	    /// <c>java.lang.Character.digit()</c>. Note that this will return
	    /// positive values for code points for which isDigit returns false, just
	    /// like java.lang.Character. <br>
	    /// <em>Semantic Change:</em> In release 1.3.1 and prior, this did not treat
	    /// the European letters as having a digit value, and also treated numeric
	    /// letters and other numbers as digits. This has been changed to conform to
	    /// the java semantics. <br>
	    /// A code point is a valid digit if and only if:
	    /// <ul>
	    /// <li>ch is a decimal digit or one of the european letters, and
	    /// <li>the value of ch is less than the specified radix.
	    /// </ul>
	    /// </summary>
	    ///
	    /// <param name="ch">the code point to query</param>
	    /// <param name="radix">the radix</param>
	    /// <returns>the numeric value represented by the code point in the specified
	    /// radix, or -1 if the code point is not a decimal digit or if its
	    /// value is too large for the radix</returns>
	    /// @stable ICU 2.1
	    public static int Digit(int ch, int radix) {
	        // when ch is out of bounds getProperty == 0
	        int props = GetProperty(ch);
	        int value_ren;
	        if (GetNumericType(props) == IBM.ICU.Lang.UCharacter.NumericType.DECIMAL) {
	            value_ren = IBM.ICU.Impl.UCharacterProperty.GetUnsignedValue(props);
	        } else {
	            value_ren = GetEuropeanDigit(ch);
	        }
	        return (0 <= value_ren && value_ren < radix) ? value_ren : -1;
	    }
	
	    /// <summary>
	    /// Retrieves the numeric value of a decimal digit code point. <br>
	    /// This is a convenience overload of <c>digit(int, int)</c> that
	    /// provides a decimal radix. <br>
	    /// <em>Semantic Change:</em> In release 1.3.1 and prior, this treated
	    /// numeric letters and other numbers as digits. This has been changed to
	    /// conform to the java semantics.
	    /// </summary>
	    ///
	    /// <param name="ch">the code point to query</param>
	    /// <returns>the numeric value represented by the code point, or -1 if the
	    /// code point is not a decimal digit or if its value is too large
	    /// for a decimal radix</returns>
	    /// @stable ICU 2.1
	    public static int Digit(int ch) {
	        int props = GetProperty(ch);
	        if (GetNumericType(props) == IBM.ICU.Lang.UCharacter.NumericType.DECIMAL) {
	            return IBM.ICU.Impl.UCharacterProperty.GetUnsignedValue(props);
	        } else {
	            return -1;
	        }
	    }
	
	    /// <summary>
	    /// Returns the numeric value of the code point as a nonnegative integer. <br>
	    /// If the code point does not have a numeric value, then -1 is returned. <br>
	    /// If the code point has a numeric value that cannot be represented as a
	    /// nonnegative integer (for example, a fractional value), then -2 is
	    /// returned.
	    /// </summary>
	    ///
	    /// <param name="ch">the code point to query</param>
	    /// <returns>the numeric value of the code point, or -1 if it has no numeric
	    /// value, or -2 if it has a numeric value that cannot be represented
	    /// as a nonnegative integer</returns>
	    /// @stable ICU 2.1
	    public static int GetNumericValue(int ch) {
	        // slightly pruned version of getUnicodeNumericValue(), plus
	        // getEuropeanDigit()
	        int props = PROPERTY_.GetProperty(ch);
	        int numericType = GetNumericType(props);
	
	        if (numericType == 0) {
	            return GetEuropeanDigit(ch);
	        }
	        if (numericType == IBM.ICU.Impl.UCharacterProperty.NT_FRACTION
	                || numericType >= IBM.ICU.Impl.UCharacterProperty.NT_COUNT) {
	            return -2;
	        }
	
	        int numericValue = IBM.ICU.Impl.UCharacterProperty.GetUnsignedValue(props);
	
	        if (numericType < IBM.ICU.Lang.UCharacter.NumericType.COUNT) {
	            /* normal type, the value is stored directly */
	            return numericValue;
	        } else /* numericType==NT_LARGE */{
	            /* large value with exponent */
	            long numValue;
	            int mant, exp;
	
	            mant = numericValue >> LARGE_MANT_SHIFT;
	            exp = numericValue & LARGE_EXP_MASK;
	            if (mant == 0) {
	                mant = 1;
	                exp += LARGE_EXP_OFFSET_EXTRA;
	            } else if (mant > 9) {
	                return -2; /* reserved mantissa value */
	            } else {
	                exp += LARGE_EXP_OFFSET;
	            }
	            if (exp > 9) {
	                return -2;
	            }
	
	            numValue = mant;
	
	            /* multiply by 10^exp without math.h */
	            while (exp >= 4) {
	                numValue *= (long) 10000.0;
	                exp -= 4;
	            }
	            switch (exp) {
	            case 3:
                        numValue *= (long)1000.0;
	                break;
	            case 2:
                    numValue *= (long)100.0;
	                break;
	            case 1:
                    numValue *= (long)10.0;
	                break;
	            case 0:
	            default:
	                break;
	            }
	            if (numValue <= Int32.MaxValue) {
	                return (int) numValue;
	            } else {
	                return -2;
	            }
	        }
	    }
	
	    /// <summary>
	    /// <p>
	    /// Get the numeric value for a Unicode code point as defined in the Unicode
	    /// Character Database.
	    /// </p>
	    /// <p>
	    /// A "double" return type is necessary because some numeric values are
	    /// fractions, negative, or too large for int.
	    /// </p>
	    /// <p>
	    /// For characters without any numeric values in the Unicode Character
	    /// Database, this function will return NO_NUMERIC_VALUE.
	    /// </p>
	    /// <p>
	    /// <em>API Change:</em> In release 2.2 and prior, this API has a return type
	    /// int and returns -1 when the argument ch does not have a corresponding
	    /// numeric value. This has been changed to synch with ICU4C
	    /// </p>
	    /// This corresponds to the ICU4C function u_getNumericValue.
	    /// </summary>
	    ///
	    /// <param name="ch">Code point to get the numeric value for.</param>
	    /// <returns>numeric value of ch, or NO_NUMERIC_VALUE if none is defined.</returns>
	    /// @stable ICU 2.4
	    public static double GetUnicodeNumericValue(int ch) {
	        // equivalent to c version double u_getNumericValue(UChar32 c)
	        int props = PROPERTY_.GetProperty(ch);
	        int numericType = GetNumericType(props);
	
	        if (numericType == 0 || numericType >= IBM.ICU.Impl.UCharacterProperty.NT_COUNT) {
	            return NO_NUMERIC_VALUE;
	        }
	
	        int numericValue = IBM.ICU.Impl.UCharacterProperty.GetUnsignedValue(props);
	
	        if (numericType < IBM.ICU.Lang.UCharacter.NumericType.COUNT) {
	            /* normal type, the value is stored directly */
	            return numericValue;
	        } else if (numericType == IBM.ICU.Impl.UCharacterProperty.NT_FRACTION) {
	            /* fraction value */
	            int numerator, denominator;
	
	            numerator = numericValue >> FRACTION_NUM_SHIFT;
	            denominator = (numericValue & FRACTION_DEN_MASK)
	                    + FRACTION_DEN_OFFSET;
	
	            if (numerator == 0) {
	                numerator = -1;
	            }
	            return (double) numerator / (double) denominator;
	        } else /* numericType==NT_LARGE */{
	            /* large value with exponent */
	            double numValue;
	            int mant, exp;
	
	            mant = numericValue >> LARGE_MANT_SHIFT;
	            exp = numericValue & LARGE_EXP_MASK;
	            if (mant == 0) {
	                mant = 1;
	                exp += LARGE_EXP_OFFSET_EXTRA;
	            } else if (mant > 9) {
	                return NO_NUMERIC_VALUE; /* reserved mantissa value */
	            } else {
	                exp += LARGE_EXP_OFFSET;
	            }
	
	            numValue = mant;
	
	            /* multiply by 10^exp without math.h */
	            while (exp >= 4) {
	                numValue *= 10000.0;
	                exp -= 4;
	            }
	            switch (exp) {
	            case 3:
	                numValue *= 1000.0;
	                break;
	            case 2:
	                numValue *= 100.0;
	                break;
	            case 1:
	                numValue *= 10.0;
	                break;
	            case 0:
	            default:
	                break;
	            }
	
	            return numValue;
	        }
	    }
	
	    /// <summary>
	    /// Compatibility override of Java deprecated method. This method will always
	    /// remain deprecated. Delegates to java.lang.Character.isSpace.
	    /// </summary>
	    ///
	    /// <param name="ch">the code point</param>
	    /// <returns>true if the code point is a space character as defined by
	    /// java.lang.Character.isSpace.</returns>
	    public static bool IsSpace(int ch) {
	        return ch <= 0x20
	                && (ch == 0x20 || ch == 0x09 || ch == 0x0a || ch == 0x0c || ch == 0x0d);
	    }
	
	    /// <summary>
	    /// Returns a value indicating a code point's Unicode category. Up-to-date
	    /// Unicode implementation of java.lang.Character.getType() except for the
	    /// above mentioned code points that had their category changed.<br>
	    /// Return results are constants from the interface <a
	    /// href=UCharacterCategory.html>UCharacterCategory</a><br>
	    /// <em>NOTE:</em> the UCharacterCategory values are <em>not</em> compatible
	    /// with those returned by java.lang.Character.getType. UCharacterCategory
	    /// values match the ones used in ICU4C, while java.lang.Character type
	    /// values, though similar, skip the value 17.</p>
	    /// </summary>
	    ///
	    /// <param name="ch">code point whose type is to be determined</param>
	    /// <returns>category which is a value of UCharacterCategory</returns>
	    /// @stable ICU 2.1
	    public static int GetType(int ch) {
	        return GetProperty(ch) & IBM.ICU.Impl.UCharacterProperty.TYPE_MASK;
	    }
	
	    /// <summary>
	    /// Determines if a code point has a defined meaning in the up-to-date
	    /// Unicode standard. E.g. supplementary code points though allocated space
	    /// are not defined in Unicode yet.<br>
	    /// Up-to-date Unicode implementation of java.lang.Character.isDefined()
	    /// </summary>
	    ///
	    /// <param name="ch">code point to be determined if it is defined in the mostcurrent version of Unicode</param>
	    /// <returns>true if this code point is defined in unicode</returns>
	    /// @stable ICU 2.1
	    public static bool IsDefined(int ch) {
	        return GetType(ch) != 0;
	    }
	
	    /// <summary>
	    /// Determines if a code point is a Java digit. <br>
	    /// This method observes the semantics of
	    /// <c>java.lang.Character.isDigit()</c>. It returns true for decimal
	    /// digits only. <br>
	    /// <em>Semantic Change:</em> In release 1.3.1 and prior, this treated
	    /// numeric letters and other numbers as digits. This has been changed to
	    /// conform to the java semantics.
	    /// </summary>
	    ///
	    /// <param name="ch">code point to query</param>
	    /// <returns>true if this code point is a digit</returns>
	    /// @stable ICU 2.1
	    public static bool IsDigit(int ch) {
	        return GetType(ch) == IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.DECIMAL_DIGIT_NUMBER;
	    }
	
	    /// <summary>
	    /// Determines if the specified code point is an ISO control character. A
	    /// code point is considered to be an ISO control character if it is in the
	    /// range &#92u0000 through &#92u001F or in the range &#92u007F through
	    /// &#92u009F.<br>
	    /// Up-to-date Unicode implementation of java.lang.Character.isISOControl()
	    /// </summary>
	    ///
	    /// <param name="ch">code point to determine if it is an ISO control character</param>
	    /// <returns>true if code point is a ISO control character</returns>
	    /// @stable ICU 2.1
	    public static bool IsISOControl(int ch) {
	        return ch >= 0 && ch <= APPLICATION_PROGRAM_COMMAND_
	                && ((ch <= UNIT_SEPARATOR_) || (ch >= DELETE_));
	    }
	
	    /// <summary>
	    /// Determines if the specified code point is a letter. Up-to-date Unicode
	    /// implementation of java.lang.Character.isLetter()
	    /// </summary>
	    ///
	    /// <param name="ch">code point to determine if it is a letter</param>
	    /// <returns>true if code point is a letter</returns>
	    /// @stable ICU 2.1
	    public static bool IsLetter(int ch) {
	        // if props == 0, it will just fall through and return false
	        return ((1 << GetType(ch)) & ((1 << IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.UPPERCASE_LETTER)
	                | (1 << IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.LOWERCASE_LETTER)
	                | (1 << IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.TITLECASE_LETTER)
	                | (1 << IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.MODIFIER_LETTER) | (1 << IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.OTHER_LETTER))) != 0;
	    }
	
	    /// <summary>
	    /// Determines if the specified code point is a letter or digit. Note this
	    /// method, unlike java.lang.Character does not regard the ascii characters
	    /// 'A' - 'Z' and 'a' - 'z' as digits.
	    /// </summary>
	    ///
	    /// <param name="ch">code point to determine if it is a letter or a digit</param>
	    /// <returns>true if code point is a letter or a digit</returns>
	    /// @stable ICU 2.1
	    public static bool IsLetterOrDigit(int ch) {
	        return ((1 << GetType(ch)) & ((1 << IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.UPPERCASE_LETTER)
	                | (1 << IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.LOWERCASE_LETTER)
	                | (1 << IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.TITLECASE_LETTER)
	                | (1 << IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.MODIFIER_LETTER)
	                | (1 << IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.OTHER_LETTER) | (1 << IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.DECIMAL_DIGIT_NUMBER))) != 0;
	    }
	
	    /// <summary>
	    /// Compatibility override of Java deprecated method. This method will always
	    /// remain deprecated. Delegates to
	    /// java.lang.Character.isJavaIdentifierStart.
	    /// </summary>
	    ///
	    /// <param name="cp">the code point</param>
	    /// <returns>true if the code point can start a java identifier.</returns>
	    public static bool IsJavaLetter(int cp) {
	        return IsJavaIdentifierStart(cp);
	    }
	
	    /// <summary>
	    /// Compatibility override of Java deprecated method. This method will always
	    /// remain deprecated. Delegates to java.lang.Character.isJavaIdentifierPart.
	    /// </summary>
	    ///
	    /// <param name="cp">the code point</param>
	    /// <returns>true if the code point can continue a java identifier.</returns>
	    public static bool IsJavaLetterOrDigit(int cp) {
	        return IsJavaIdentifierPart(cp);
	    }
	
	    /// <summary>
	    /// Compatibility override of Java method, delegates to
	    /// java.lang.Character.isJavaIdentifierStart.
	    /// </summary>
	    ///
	    /// <param name="cp">the code point</param>
	    /// <returns>true if the code point can start a java identifier.</returns>
	    /// @stable ICU 3.4
	    public static bool IsJavaIdentifierStart(int cp) {
	        // note, downcast to char for jdk 1.4 compatibility
	        return ILOG.J2CsMapping.Util.Character.IsCSharpIdentifierStart((char) cp);
	    }
	
	    /// <summary>
	    /// Compatibility override of Java method, delegates to
	    /// java.lang.Character.isJavaIdentifierPart.
	    /// </summary>
	    ///
	    /// <param name="cp">the code point</param>
	    /// <returns>true if the code point can continue a java identifier.</returns>
	    /// @stable ICU 3.4
	    public static bool IsJavaIdentifierPart(int cp) {
	        // note, downcast to char for jdk 1.4 compatibility
	        return ILOG.J2CsMapping.Util.Character.IsCSharpIdentifierPart((char) cp);
	    }
	
	    /// <summary>
	    /// Determines if the specified code point is a lowercase character.
	    /// UnicodeData only contains case mappings for code points where they are
	    /// one-to-one mappings; it also omits information about context-sensitive
	    /// case mappings.<br>
	    /// For more information about Unicode case mapping please refer to the <a
	    /// href=http://www.unicode.org/unicode/reports/tr21/>Technical report
	    /// #21</a>.<br>
	    /// Up-to-date Unicode implementation of java.lang.Character.isLowerCase()
	    /// </summary>
	    ///
	    /// <param name="ch">code point to determine if it is in lowercase</param>
	    /// <returns>true if code point is a lowercase character</returns>
	    /// @stable ICU 2.1
	    public static bool IsLowerCase(int ch) {
	        // if props == 0, it will just fall through and return false
	        return GetType(ch) == IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.LOWERCASE_LETTER;
	    }
	
	    /// <summary>
	    /// Determines if the specified code point is a white space character. A code
	    /// point is considered to be an whitespace character if and only if it
	    /// satisfies one of the following criteria:
	    /// <ul>
	    /// <li>It is a Unicode space separator (category "Zs"), but is not a
	    /// no-break space (&#92u00A0 or &#92u202F or &#92uFEFF).
	    /// <li>It is a Unicode line separator (category "Zl").
	    /// <li>It is a Unicode paragraph separator (category "Zp").
	    /// <li>It is &#92u0009, HORIZONTAL TABULATION.
	    /// <li>It is &#92u000A, LINE FEED.
	    /// <li>It is &#92u000B, VERTICAL TABULATION.
	    /// <li>It is &#92u000C, FORM FEED.
	    /// <li>It is &#92u000D, CARRIAGE RETURN.
	    /// <li>It is &#92u001C, FILE SEPARATOR.
	    /// <li>It is &#92u001D, GROUP SEPARATOR.
	    /// <li>It is &#92u001E, RECORD SEPARATOR.
	    /// <li>It is &#92u001F, UNIT SEPARATOR.
	    /// </ul>
	    /// This API tries to synch to the semantics of the Java API,
	    /// java.lang.Character.isWhitespace().
	    /// </summary>
	    ///
	    /// <param name="ch">code point to determine if it is a white space</param>
	    /// <returns>true if the specified code point is a white space character</returns>
	    /// @stable ICU 2.1
	    public static bool IsWhitespace(int ch) {
	        // exclude no-break spaces
	        // if props == 0, it will just fall through and return false
	        return ((1 << GetType(ch)) & ((1 << IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.SPACE_SEPARATOR)
	                | (1 << IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.LINE_SEPARATOR) | (1 << IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.PARAGRAPH_SEPARATOR))) != 0
	                && (ch != NO_BREAK_SPACE_)
	                && (ch != NARROW_NO_BREAK_SPACE_)
	                && (ch != ZERO_WIDTH_NO_BREAK_SPACE_)
	                // TAB VT LF FF CR FS GS RS US NL are all control characters
	                // that are white spaces.
	                || (ch >= 0x9 && ch <= 0xd) || (ch >= 0x1c && ch <= 0x1f);
	    }
	
	    /// <summary>
	    /// Determines if the specified code point is a Unicode specified space
	    /// character, i.e. if code point is in the category Zs, Zl and Zp.
	    /// Up-to-date Unicode implementation of java.lang.Character.isSpaceChar().
	    /// </summary>
	    ///
	    /// <param name="ch">code point to determine if it is a space</param>
	    /// <returns>true if the specified code point is a space character</returns>
	    /// @stable ICU 2.1
	    public static bool IsSpaceChar(int ch) {
	        // if props == 0, it will just fall through and return false
	        return ((1 << GetType(ch)) & ((1 << IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.SPACE_SEPARATOR)
	                | (1 << IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.LINE_SEPARATOR) | (1 << IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.PARAGRAPH_SEPARATOR))) != 0;
	    }
	
	    /// <summary>
	    /// Determines if the specified code point is a titlecase character.
	    /// UnicodeData only contains case mappings for code points where they are
	    /// one-to-one mappings; it also omits information about context-sensitive
	    /// case mappings.<br>
	    /// For more information about Unicode case mapping please refer to the <a
	    /// href=http://www.unicode.org/unicode/reports/tr21/> Technical report
	    /// #21</a>.<br>
	    /// Up-to-date Unicode implementation of java.lang.Character.isTitleCase().
	    /// </summary>
	    ///
	    /// <param name="ch">code point to determine if it is in title case</param>
	    /// <returns>true if the specified code point is a titlecase character</returns>
	    /// @stable ICU 2.1
	    public static bool IsTitleCase(int ch) {
	        // if props == 0, it will just fall through and return false
	        return GetType(ch) == IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.TITLECASE_LETTER;
	    }
	
	    /// <summary>
	    /// Determines if the specified code point may be any part of a Unicode
	    /// identifier other than the starting character. A code point may be part of
	    /// a Unicode identifier if and only if it is one of the following:
	    /// <ul>
	    /// <li>Lu Uppercase letter
	    /// <li>Ll Lowercase letter
	    /// <li>Lt Titlecase letter
	    /// <li>Lm Modifier letter
	    /// <li>Lo Other letter
	    /// <li>Nl Letter number
	    /// <li>Pc Connecting punctuation character
	    /// <li>Nd decimal number
	    /// <li>Mc Spacing combining mark
	    /// <li>Mn Non-spacing mark
	    /// <li>Cf formatting code
	    /// </ul>
	    /// Up-to-date Unicode implementation of
	    /// java.lang.Character.isUnicodeIdentifierPart().<br>
	    /// See <a href=http://www.unicode.org/unicode/reports/tr8/>UTR #8</a>.
	    /// </summary>
	    ///
	    /// <param name="ch">code point to determine if is can be part of a Unicodeidentifier</param>
	    /// <returns>true if code point is any character belonging a unicode
	    /// identifier suffix after the first character</returns>
	    /// @stable ICU 2.1
	    public static bool IsUnicodeIdentifierPart(int ch) {
	        // if props == 0, it will just fall through and return false
	        // cat == format
	        return ((1 << GetType(ch)) & ((1 << IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.UPPERCASE_LETTER)
	                | (1 << IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.LOWERCASE_LETTER)
	                | (1 << IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.TITLECASE_LETTER)
	                | (1 << IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.MODIFIER_LETTER)
	                | (1 << IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.OTHER_LETTER)
	                | (1 << IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.LETTER_NUMBER)
	                | (1 << IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.CONNECTOR_PUNCTUATION)
	                | (1 << IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.DECIMAL_DIGIT_NUMBER)
	                | (1 << IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.COMBINING_SPACING_MARK) | (1 << IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.NON_SPACING_MARK))) != 0
	                || IsIdentifierIgnorable(ch);
	    }
	
	    /// <summary>
	    /// Determines if the specified code point is permissible as the first
	    /// character in a Unicode identifier. A code point may start a Unicode
	    /// identifier if it is of type either
	    /// <ul>
	    /// <li>Lu Uppercase letter
	    /// <li>Ll Lowercase letter
	    /// <li>Lt Titlecase letter
	    /// <li>Lm Modifier letter
	    /// <li>Lo Other letter
	    /// <li>Nl Letter number
	    /// </ul>
	    /// Up-to-date Unicode implementation of
	    /// java.lang.Character.isUnicodeIdentifierStart().<br>
	    /// See <a href=http://www.unicode.org/unicode/reports/tr8/>UTR #8</a>.
	    /// </summary>
	    ///
	    /// <param name="ch">code point to determine if it can start a Unicode identifier</param>
	    /// <returns>true if code point is the first character belonging a unicode
	    /// identifier</returns>
	    /// @stable ICU 2.1
	    public static bool IsUnicodeIdentifierStart(int ch) {
	        /* int cat = getType(ch); */
	        // if props == 0, it will just fall through and return false
	        return ((1 << GetType(ch)) & ((1 << IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.UPPERCASE_LETTER)
	                | (1 << IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.LOWERCASE_LETTER)
	                | (1 << IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.TITLECASE_LETTER)
	                | (1 << IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.MODIFIER_LETTER)
	                | (1 << IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.OTHER_LETTER) | (1 << IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.LETTER_NUMBER))) != 0;
	    }
	
	    /// <summary>
	    /// Determines if the specified code point should be regarded as an ignorable
	    /// character in a Unicode identifier. A character is ignorable in the
	    /// Unicode standard if it is of the type Cf, Formatting code.<br>
	    /// Up-to-date Unicode implementation of
	    /// java.lang.Character.isIdentifierIgnorable().<br>
	    /// See <a href=http://www.unicode.org/unicode/reports/tr8/>UTR #8</a>.
	    /// </summary>
	    ///
	    /// <param name="ch">code point to be determined if it can be ignored in a Unicodeidentifier.</param>
	    /// <returns>true if the code point is ignorable</returns>
	    /// @stable ICU 2.1
	    public static bool IsIdentifierIgnorable(int ch) {
	        // see java.lang.Character.isIdentifierIgnorable() on range of
	        // ignorable characters.
	        if (ch <= 0x9f) {
	            return IsISOControl(ch)
	                    && !((ch >= 0x9 && ch <= 0xd) || (ch >= 0x1c && ch <= 0x1f));
	        }
	        return GetType(ch) == IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.FORMAT;
	    }
	
	    /// <summary>
	    /// Determines if the specified code point is an uppercase character.
	    /// UnicodeData only contains case mappings for code point where they are
	    /// one-to-one mappings; it also omits information about context-sensitive
	    /// case mappings.<br>
	    /// For language specific case conversion behavior, use toUpperCase(locale,
	    /// str). <br>
	    /// For example, the case conversion for dot-less i and dotted I in Turkish,
	    /// or for final sigma in Greek. For more information about Unicode case
	    /// mapping please refer to the <a
	    /// href=http://www.unicode.org/unicode/reports/tr21/> Technical report
	    /// #21</a>.<br>
	    /// Up-to-date Unicode implementation of java.lang.Character.isUpperCase().
	    /// </summary>
	    ///
	    /// <param name="ch">code point to determine if it is in uppercase</param>
	    /// <returns>true if the code point is an uppercase character</returns>
	    /// @stable ICU 2.1
	    public static bool IsUpperCase(int ch) {
	        // if props == 0, it will just fall through and return false
	        return GetType(ch) == IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.UPPERCASE_LETTER;
	    }
	
	    /// <summary>
	    /// The given code point is mapped to its lowercase equivalent; if the code
	    /// point has no lowercase equivalent, the code point itself is returned.
	    /// Up-to-date Unicode implementation of java.lang.Character.toLowerCase()
	    /// <p>
	    /// This function only returns the simple, single-code point case mapping.
	    /// Full case mappings should be used whenever possible because they produce
	    /// better results by working on whole strings. They take into account the
	    /// string context and the language and can map to a result string with a
	    /// different length as appropriate. Full case mappings are applied by the
	    /// case mapping functions that take String parameters rather than code
	    /// points (int). See also the User Guide chapter on C/POSIX migration:
	    /// http://www.icu-project.org/userguide/posix.html#case_mappings
	    /// </summary>
	    ///
	    /// <param name="ch">code point whose lowercase equivalent is to be retrieved</param>
	    /// <returns>the lowercase equivalent code point</returns>
	    /// @stable ICU 2.1
	    public static int ToLowerCase(int ch) {
	        return gCsp.Tolower(ch);
	    }
	
	    /// <summary>
	    /// Converts argument code point and returns a String object representing the
	    /// code point's value in UTF16 format. The result is a string whose length
	    /// is 1 for non-supplementary code points, 2 otherwise.<br>
	    /// com.ibm.ibm.icu.UTF16 can be used to parse Strings generated by this
	    /// function.<br>
	    /// Up-to-date Unicode implementation of java.lang.Character.toString()
	    /// </summary>
	    ///
	    /// <param name="ch">code point</param>
	    /// <returns>string representation of the code point, null if code point is
	    /// not defined in unicode</returns>
	    /// @stable ICU 2.1
	    public static String ToString(int ch) {
	        if (ch < MIN_VALUE || ch > MAX_VALUE) {
	            return null;
	        }
	
	        if (ch < SUPPLEMENTARY_MIN_VALUE) {
	            return ch.ToString();
	        }
	
	        StringBuilder result = new StringBuilder();
	        result.Append(IBM.ICU.Text.UTF16.GetLeadSurrogate(ch));
	        result.Append(IBM.ICU.Text.UTF16.GetTrailSurrogate(ch));
	        return result.ToString();
	    }
	
	    /// <summary>
	    /// Converts the code point argument to titlecase. If no titlecase is
	    /// available, the uppercase is returned. If no uppercase is available, the
	    /// code point itself is returned. Up-to-date Unicode implementation of
	    /// java.lang.Character.toTitleCase()
	    /// <p>
	    /// This function only returns the simple, single-code point case mapping.
	    /// Full case mappings should be used whenever possible because they produce
	    /// better results by working on whole strings. They take into account the
	    /// string context and the language and can map to a result string with a
	    /// different length as appropriate. Full case mappings are applied by the
	    /// case mapping functions that take String parameters rather than code
	    /// points (int). See also the User Guide chapter on C/POSIX migration:
	    /// http://www.icu-project.org/userguide/posix.html#case_mappings
	    /// </summary>
	    ///
	    /// <param name="ch">code point whose title case is to be retrieved</param>
	    /// <returns>titlecase code point</returns>
	    /// @stable ICU 2.1
	    public static int ToTitleCase(int ch) {
	        return gCsp.Totitle(ch);
	    }
	
	    /// <summary>
	    /// Converts the character argument to uppercase. If no uppercase is
	    /// available, the character itself is returned. Up-to-date Unicode
	    /// implementation of java.lang.Character.toUpperCase()
	    /// <p>
	    /// This function only returns the simple, single-code point case mapping.
	    /// Full case mappings should be used whenever possible because they produce
	    /// better results by working on whole strings. They take into account the
	    /// string context and the language and can map to a result string with a
	    /// different length as appropriate. Full case mappings are applied by the
	    /// case mapping functions that take String parameters rather than code
	    /// points (int). See also the User Guide chapter on C/POSIX migration:
	    /// http://www.icu-project.org/userguide/posix.html#case_mappings
	    /// </summary>
	    ///
	    /// <param name="ch">code point whose uppercase is to be retrieved</param>
	    /// <returns>uppercase code point</returns>
	    /// @stable ICU 2.1
	    public static int ToUpperCase(int ch) {
	        return gCsp.Toupper(ch);
	    }
	
	    // extra methods not in java.lang.Character --------------------------
	
	    /// <summary>
	    /// Determines if the code point is a supplementary character. A code point
	    /// is a supplementary character if and only if it is greater than <a
	    /// href=#SUPPLEMENTARY_MIN_VALUE>SUPPLEMENTARY_MIN_VALUE</a>
	    /// </summary>
	    ///
	    /// <param name="ch">code point to be determined if it is in the supplementaryplane</param>
	    /// <returns>true if code point is a supplementary character</returns>
	    /// @stable ICU 2.1
	    public static bool IsSupplementary(int ch) {
	        return ch >= UCharacter.SUPPLEMENTARY_MIN_VALUE
	                && ch <= UCharacter.MAX_VALUE;
	    }
	
	    /// <summary>
	    /// Determines if the code point is in the BMP plane.
	    /// </summary>
	    ///
	    /// <param name="ch">code point to be determined if it is not a supplementarycharacter</param>
	    /// <returns>true if code point is not a supplementary character</returns>
	    /// @stable ICU 2.1
	    public static bool IsBMP(int ch) {
	        return (ch >= 0 && ch <= LAST_CHAR_MASK_);
	    }
	
	    /// <summary>
	    /// Determines whether the specified code point is a printable character
	    /// according to the Unicode standard.
	    /// </summary>
	    ///
	    /// <param name="ch">code point to be determined if it is printable</param>
	    /// <returns>true if the code point is a printable character</returns>
	    /// @stable ICU 2.1
	    public static bool IsPrintable(int ch) {
	        int cat = GetType(ch);
	        // if props == 0, it will just fall through and return false
	        return (cat != IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.UNASSIGNED
	                && cat != IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.CONTROL
	                && cat != IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.FORMAT
	                && cat != IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.PRIVATE_USE
	                && cat != IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.SURROGATE && cat != IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.GENERAL_OTHER_TYPES);
	    }
	
	    /// <summary>
	    /// Determines whether the specified code point is of base form. A code point
	    /// of base form does not graphically combine with preceding characters, and
	    /// is neither a control nor a format character.
	    /// </summary>
	    ///
	    /// <param name="ch">code point to be determined if it is of base form</param>
	    /// <returns>true if the code point is of base form</returns>
	    /// @stable ICU 2.1
	    public static bool IsBaseForm(int ch) {
	        int cat = GetType(ch);
	        // if props == 0, it will just fall through and return false
	        return cat == IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.DECIMAL_DIGIT_NUMBER
	                || cat == IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.OTHER_NUMBER
	                || cat == IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.LETTER_NUMBER
	                || cat == IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.UPPERCASE_LETTER
	                || cat == IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.LOWERCASE_LETTER
	                || cat == IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.TITLECASE_LETTER
	                || cat == IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.MODIFIER_LETTER
	                || cat == IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.OTHER_LETTER
	                || cat == IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.NON_SPACING_MARK
	                || cat == IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.ENCLOSING_MARK
	                || cat == IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.COMBINING_SPACING_MARK;
	    }
	
	    /// <summary>
	    /// Returns the Bidirection property of a code point. For example, 0x0041
	    /// (letter A) has the LEFT_TO_RIGHT directional property.<br>
	    /// Result returned belongs to the interface <a
	    /// href=UCharacterDirection.html>UCharacterDirection</a>
	    /// </summary>
	    ///
	    /// <param name="ch">the code point to be determined its direction</param>
	    /// <returns>direction constant from UCharacterDirection.</returns>
	    /// @stable ICU 2.1
	    public static int GetDirection(int ch) {
	        return gBdp.GetClass(ch);
	    }
	
	    /// <summary>
	    /// Determines whether the code point has the "mirrored" property. This
	    /// property is set for characters that are commonly used in Right-To-Left
	    /// contexts and need to be displayed with a "mirrored" glyph.
	    /// </summary>
	    ///
	    /// <param name="ch">code point whose mirror is to be determined</param>
	    /// <returns>true if the code point has the "mirrored" property</returns>
	    /// @stable ICU 2.1
	    public static bool IsMirrored(int ch) {
	        return gBdp.IsMirrored(ch);
	    }
	
	    /// <summary>
	    /// Maps the specified code point to a "mirror-image" code point. For code
	    /// points with the "mirrored" property, implementations sometimes need a
	    /// "poor man's" mapping to another code point such that the default glyph
	    /// may serve as the mirror-image of the default glyph of the specified code
	    /// point.<br>
	    /// This is useful for text conversion to and from codepages with visual
	    /// order, and for displays without glyph selection capabilities.
	    /// </summary>
	    ///
	    /// <param name="ch">code point whose mirror is to be retrieved</param>
	    /// <returns>another code point that may serve as a mirror-image substitute,
	    /// or ch itself if there is no such mapping or ch does not have the
	    /// "mirrored" property</returns>
	    /// @stable ICU 2.1
	    public static int GetMirror(int ch) {
	        return gBdp.GetMirror(ch);
	    }
	
	    /// <summary>
	    /// Gets the combining class of the argument codepoint
	    /// </summary>
	    ///
	    /// <param name="ch">code point whose combining is to be retrieved</param>
	    /// <returns>the combining class of the codepoint</returns>
	    /// @stable ICU 2.1
	    public static int GetCombiningClass(int ch) {
	        if (ch < MIN_VALUE || ch > MAX_VALUE) {
	            throw new ArgumentException("Codepoint out of bounds");
	        }
	        return IBM.ICU.Impl.NormalizerImpl.GetCombiningClass(ch);
	    }
	
	    /// <summary>
	    /// A code point is illegal if and only if
	    /// <ul>
	    /// <li>Out of bounds, less than 0 or greater than UCharacter.MAX_VALUE
	    /// <li>A surrogate value, 0xD800 to 0xDFFF
	    /// <li>Not-a-character, having the form 0x xxFFFF or 0x xxFFFE
	    /// </ul>
	    /// Note: legal does not mean that it is assigned in this version of Unicode.
	    /// </summary>
	    ///
	    /// <param name="ch">code point to determine if it is a legal code point by itself</param>
	    /// <returns>true if and only if legal.</returns>
	    /// @stable ICU 2.1
	    public static bool IsLegal(int ch) {
	        if (ch < MIN_VALUE) {
	            return false;
	        }
	        if (ch < IBM.ICU.Text.UTF16.SURROGATE_MIN_VALUE) {
	            return true;
	        }
	        if (ch <= IBM.ICU.Text.UTF16.SURROGATE_MAX_VALUE) {
	            return false;
	        }
	        if (IBM.ICU.Impl.UCharacterUtility.IsNonCharacter(ch)) {
	            return false;
	        }
	        return (ch <= MAX_VALUE);
	    }
	
	    /// <summary>
	    /// A string is legal iff all its code points are legal. A code point is
	    /// illegal if and only if
	    /// <ul>
	    /// <li>Out of bounds, less than 0 or greater than UCharacter.MAX_VALUE
	    /// <li>A surrogate value, 0xD800 to 0xDFFF
	    /// <li>Not-a-character, having the form 0x xxFFFF or 0x xxFFFE
	    /// </ul>
	    /// Note: legal does not mean that it is assigned in this version of Unicode.
	    /// </summary>
	    ///
	    /// <param name="str">containing code points to examin</param>
	    /// <returns>true if and only if legal.</returns>
	    /// @stable ICU 2.1
	    public static bool IsLegal(String str) {
	        int size = str.Length;
	        int codepoint;
	        for (int i = 0; i < size; i++) {
	            codepoint = IBM.ICU.Text.UTF16.CharAt(str, i);
	            if (!IsLegal(codepoint)) {
	                return false;
	            }
	            if (IsSupplementary(codepoint)) {
	                i++;
	            }
	        }
	        return true;
	    }
	
	    /// <summary>
	    /// Gets the version of Unicode data used.
	    /// </summary>
	    ///
	    /// <returns>the unicode version number used</returns>
	    /// @stable ICU 2.1
	    public static VersionInfo GetUnicodeVersion() {
	        return PROPERTY_.m_unicodeVersion_;
	    }
	
	    /// <summary>
	    /// Retrieve the most current Unicode name of the argument code point, or
	    /// null if the character is unassigned or outside the range
	    /// UCharacter.MIN_VALUE and UCharacter.MAX_VALUE or does not have a name. <br>
	    /// Note calling any methods related to code point names, e.g. get///Name///()
	    /// incurs a one-time initialisation cost to construct the name tables.
	    /// </summary>
	    ///
	    /// <param name="ch">the code point for which to get the name</param>
	    /// <returns>most current Unicode name</returns>
	    /// @stable ICU 2.1
	    public static String GetName(int ch) {
	        if (NAME_ == null) {
	            throw new MissingManifestResourceException("Could not load unames.icu");
	        }
	        return NAME_.GetName(ch, IBM.ICU.Impl.UCharacterNameChoice_Constants.UNICODE_CHAR_NAME);
	    }
	
	    /// <summary>
	    /// Gets the names for each of the characters in a string
	    /// </summary>
	    ///
	    /// <param name="s">string to format</param>
	    /// <param name="separator">string to go between names</param>
	    /// <returns>string of names</returns>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public static String GetName(String s, String separator) {
	        if (s.Length == 1) { // handle common case
	            return GetName(s[0]);
	        }
	        int cp;
	        StringBuilder sb = new StringBuilder();
	        for (int i = 0; i < s.Length; i += IBM.ICU.Text.UTF16.GetCharCount(cp)) {
	            cp = IBM.ICU.Text.UTF16.CharAt(s, i);
	            if (i != 0)
	                sb.Append(separator);
	            sb.Append(UCharacter.GetName(cp));
	        }
	        return sb.ToString();
	    }
	
	    /// <summary>
	    /// Retrieve the earlier version 1.0 Unicode name of the argument code point,
	    /// or null if the character is unassigned or outside the range
	    /// UCharacter.MIN_VALUE and UCharacter.MAX_VALUE or does not have a name. <br>
	    /// Note calling any methods related to code point names, e.g. get///Name///()
	    /// incurs a one-time initialisation cost to construct the name tables.
	    /// </summary>
	    ///
	    /// <param name="ch">the code point for which to get the name</param>
	    /// <returns>version 1.0 Unicode name</returns>
	    /// @stable ICU 2.1
	    public static String GetName1_0(int ch) {
	        if (NAME_ == null) {
	            throw new MissingManifestResourceException("Could not load unames.icu");
	        }
            return NAME_.GetName(ch, IBM.ICU.Impl.UCharacterNameChoice_Constants.UNICODE_10_CHAR_NAME);
	    }
	
	    /// <summary>
	    /// <p>
	    /// Retrieves a name for a valid codepoint. Unlike, getName(int) and
	    /// getName1_0(int), this method will return a name even for codepoints that
	    /// are not assigned a name in UnicodeData.txt.
	    /// </p>
	    /// The names are returned in the following order.
	    /// <ul>
	    /// <li>Most current Unicode name if there is any
	    /// <li>Unicode 1.0 name if there is any
	    /// <li>Extended name in the form of "<codepoint_type-codepoint_hex_digits>".
	    /// E.g. <noncharacter-fffe>
	    /// </ul>
	    /// Note calling any methods related to code point names, e.g. get///Name///()
	    /// incurs a one-time initialisation cost to construct the name tables.
	    /// </summary>
	    ///
	    /// <param name="ch">the code point for which to get the name</param>
	    /// <returns>a name for the argument codepoint</returns>
	    /// @stable ICU 2.6
	    public static String GetExtendedName(int ch) {
	        if (NAME_ == null) {
	            throw new MissingManifestResourceException("Could not load unames.icu");
	        }
            return NAME_.GetName(ch, IBM.ICU.Impl.UCharacterNameChoice_Constants.EXTENDED_CHAR_NAME);
	    }
	
	    /// <summary>
	    /// Get the ISO 10646 comment for a character. The ISO 10646 comment is an
	    /// informative field in the Unicode Character Database (UnicodeData.txt
	    /// field 11) and is from the ISO 10646 names list.
	    /// </summary>
	    ///
	    /// <param name="ch">The code point for which to get the ISO comment. It must be<code>0<=c<=0x10ffff</code>.</param>
	    /// <returns>The ISO comment, or null if there is no comment for this
	    /// character.</returns>
	    /// @stable ICU 2.4
	    public static String GetISOComment(int ch) {
	        if (ch < UCharacter.MIN_VALUE || ch > UCharacter.MAX_VALUE) {
	            return null;
	        }
	        if (NAME_ == null) {
	            throw new MissingManifestResourceException("Could not load unames.icu");
	        }
	        String result = NAME_.GetGroupName(ch,
                    IBM.ICU.Impl.UCharacterNameChoice_Constants.ISO_COMMENT_);
	        return result;
	    }
	
	    /// <summary>
	    /// <p>
	    /// Find a Unicode code point by its most current Unicode name and return its
	    /// code point value. All Unicode names are in uppercase.
	    /// </p>
	    /// Note calling any methods related to code point names, e.g. get///Name///()
	    /// incurs a one-time initialisation cost to construct the name tables.
	    /// </summary>
	    ///
	    /// <param name="name">most current Unicode character name whose code point is to bereturned</param>
	    /// <returns>code point or -1 if name is not found</returns>
	    /// @stable ICU 2.1
	    public static int GetCharFromName(String name) {
	        if (NAME_ == null) {
	            throw new MissingManifestResourceException("Could not load unames.icu");
	        }
            return NAME_.GetCharFromName(IBM.ICU.Impl.UCharacterNameChoice_Constants.UNICODE_CHAR_NAME,
	                name);
	    }
	
	    /// <summary>
	    /// <p>
	    /// Find a Unicode character by its version 1.0 Unicode name and return its
	    /// code point value. All Unicode names are in uppercase.
	    /// </p>
	    /// Note calling any methods related to code point names, e.g. get///Name///()
	    /// incurs a one-time initialisation cost to construct the name tables.
	    /// </summary>
	    ///
	    /// <param name="name">Unicode 1.0 code point name whose code point is to returned</param>
	    /// <returns>code point or -1 if name is not found</returns>
	    /// @stable ICU 2.1
	    public static int GetCharFromName1_0(String name) {
	        if (NAME_ == null) {
	            throw new MissingManifestResourceException("Could not load unames.icu");
	        }
            return NAME_.GetCharFromName(IBM.ICU.Impl.UCharacterNameChoice_Constants.UNICODE_10_CHAR_NAME,
	                name);
	    }
	
	    /// <summary>
	    /// <p>
	    /// Find a Unicode character by either its name and return its code point
	    /// value. All Unicode names are in uppercase. Extended names are all
	    /// lowercase except for numbers and are contained within angle brackets.
	    /// </p>
	    /// The names are searched in the following order
	    /// <ul>
	    /// <li>Most current Unicode name if there is any
	    /// <li>Unicode 1.0 name if there is any
	    /// <li>Extended name in the form of "<codepoint_type-codepoint_hex_digits>".
	    /// E.g. <noncharacter-FFFE>
	    /// </ul>
	    /// Note calling any methods related to code point names, e.g. get///Name///()
	    /// incurs a one-time initialisation cost to construct the name tables.
	    /// </summary>
	    ///
	    /// <param name="name">codepoint name</param>
	    /// <returns>code point associated with the name or -1 if the name is not
	    /// found.</returns>
	    /// @stable ICU 2.6
	    public static int GetCharFromExtendedName(String name) {
	        if (NAME_ == null) {
	            throw new MissingManifestResourceException("Could not load unames.icu");
	        }
            return NAME_.GetCharFromName(IBM.ICU.Impl.UCharacterNameChoice_Constants.EXTENDED_CHAR_NAME,
	                name);
	    }
	
	    /// <summary>
	    /// Return the Unicode name for a given property, as given in the Unicode
	    /// database file PropertyAliases.txt. Most properties have more than one
	    /// name. The nameChoice determines which one is returned.
	    /// In addition, this function maps the property
	    /// UProperty.GENERAL_CATEGORY_MASK to the synthetic names "gcm" /
	    /// "General_Category_Mask". These names are not in PropertyAliases.txt.
	    /// </summary>
	    ///
	    /// <param name="property">UProperty selector.</param>
	    /// <param name="nameChoice">UProperty.NameChoice selector for which name to get. Allproperties have a long name. Most have a short name, but somedo not. Unicode allows for additional names; if present thesewill be returned by UProperty.NameChoice.LONG + i, where i=1,2,...</param>
	    /// <returns>a name, or null if Unicode explicitly defines no name ("n/a") for
	    /// a given property/nameChoice. If a given nameChoice throws an
	    /// exception, then all larger values of nameChoice will throw an
	    /// exception. If null is returned for a given nameChoice, then other
	    /// nameChoice values may return non-null results.</returns>
	    /// <exception cref="IllegalArgumentException">thrown if property or nameChoice are invalid.</exception>
	    /// <seealso cref="T:IBM.ICU.Lang.UProperty"/>
	    /// <seealso cref="null"/>
	    /// @stable ICU 2.4
	    public static String GetPropertyName(int property, int nameChoice) {
	        return PNAMES_.GetPropertyName(property, nameChoice);
	    }
	
	    /// <summary>
	    /// Return the UProperty selector for a given property name, as specified in
	    /// the Unicode database file PropertyAliases.txt. Short, long, and any other
	    /// variants are recognized.
	    /// In addition, this function maps the synthetic names "gcm" /
	    /// "General_Category_Mask" to the property UProperty.GENERAL_CATEGORY_MASK.
	    /// These names are not in PropertyAliases.txt.
	    /// </summary>
	    ///
	    /// <param name="propertyAlias">the property name to be matched. The name is compared using"loose matching" as described in PropertyAliases.txt.</param>
	    /// <returns>a UProperty enum.</returns>
	    /// <exception cref="IllegalArgumentException">thrown if propertyAlias is not recognized.</exception>
	    /// <seealso cref="T:IBM.ICU.Lang.UProperty"/>
	    /// @stable ICU 2.4
	    public static int GetPropertyEnum(String propertyAlias) {
	        return PNAMES_.GetPropertyEnum(propertyAlias);
	    }
	
	    /// <summary>
	    /// Return the Unicode name for a given property value, as given in the
	    /// Unicode database file PropertyValueAliases.txt. Most values have more
	    /// than one name. The nameChoice determines which one is returned.
	    /// Note: Some of the names in PropertyValueAliases.txt can only be retrieved
	    /// using UProperty.GENERAL_CATEGORY_MASK, not UProperty.GENERAL_CATEGORY.
	    /// These include: "C" / "Other", "L" / "Letter", "LC" / "Cased_Letter", "M"
	    /// / "Mark", "N" / "Number", "P" / "Punctuation", "S" / "Symbol", and "Z" /
	    /// "Separator".
	    /// </summary>
	    ///
	    /// <param name="property">UProperty selector constant. UProperty.INT_START &lt;=property &lt; UProperty.INT_LIMIT or UProperty.BINARY_START&lt;= property &lt; UProperty.BINARY_LIMIT orUProperty.MASK_START &lt; = property &lt;UProperty.MASK_LIMIT. If out of range, null is returned.</param>
	    /// <param name="value">selector for a value for the given property. In general, validvalues range from 0 up to some maximum. There are a fewexceptions: (1.) UProperty.BLOCK values begin at the non-zerovalue BASIC_LATIN.getID(). (2.)UProperty.CANONICAL_COMBINING_CLASS values are not contiguousand range from 0..240. (3.) UProperty.GENERAL_CATEGORY_MASKvalues are mask values produced by left-shifting 1 byUCharacter.getType(). This allows grouped categories such as[:L:] to be represented. Mask values are non-contiguous.</param>
	    /// <param name="nameChoice">UProperty.NameChoice selector for which name to get. Allvalues have a long name. Most have a short name, but some donot. Unicode allows for additional names; if present thesewill be returned by UProperty.NameChoice.LONG + i, where i=1,2,...</param>
	    /// <returns>a name, or null if Unicode explicitly defines no name ("n/a") for
	    /// a given property/value/nameChoice. If a given nameChoice throws
	    /// an exception, then all larger values of nameChoice will throw an
	    /// exception. If null is returned for a given nameChoice, then other
	    /// nameChoice values may return non-null results.</returns>
	    /// <exception cref="IllegalArgumentException">thrown if property, value, or nameChoice are invalid.</exception>
	    /// <seealso cref="T:IBM.ICU.Lang.UProperty"/>
	    /// <seealso cref="null"/>
	    /// @stable ICU 2.4
	    public static String GetPropertyValueName(int property, int value_ren,
	            int nameChoice) {
	        if ((property == IBM.ICU.Lang.UProperty_Constants.CANONICAL_COMBINING_CLASS
	                || property == IBM.ICU.Lang.UProperty_Constants.LEAD_CANONICAL_COMBINING_CLASS || property == IBM.ICU.Lang.UProperty_Constants.TRAIL_CANONICAL_COMBINING_CLASS)
	                && value_ren >= UCharacter
	                        .GetIntPropertyMinValue(IBM.ICU.Lang.UProperty_Constants.CANONICAL_COMBINING_CLASS)
	                && value_ren <= UCharacter
	                        .GetIntPropertyMaxValue(IBM.ICU.Lang.UProperty_Constants.CANONICAL_COMBINING_CLASS)
	                && nameChoice >= 0 && nameChoice < IBM.ICU.Lang.UProperty_Constants.NameChoice.COUNT) {
	            // this is hard coded for the valid cc
	            // because PropertyValueAliases.txt does not contain all of them
	            try {
	                return PNAMES_
	                        .GetPropertyValueName(property, value_ren, nameChoice);
	            } catch (ArgumentException e) {
	                return null;
	            }
	        }
	        return PNAMES_.GetPropertyValueName(property, value_ren, nameChoice);
	    }
	
	    /// <summary>
	    /// Return the property value integer for a given value name, as specified in
	    /// the Unicode database file PropertyValueAliases.txt. Short, long, and any
	    /// other variants are recognized.
	    /// Note: Some of the names in PropertyValueAliases.txt will only be
	    /// recognized with UProperty.GENERAL_CATEGORY_MASK, not
	    /// UProperty.GENERAL_CATEGORY. These include: "C" / "Other", "L" / "Letter",
	    /// "LC" / "Cased_Letter", "M" / "Mark", "N" / "Number", "P" / "Punctuation",
	    /// "S" / "Symbol", and "Z" / "Separator".
	    /// </summary>
	    ///
	    /// <param name="property">UProperty selector constant. UProperty.INT_START &lt;=property &lt; UProperty.INT_LIMIT or UProperty.BINARY_START&lt;= property &lt; UProperty.BINARY_LIMIT orUProperty.MASK_START &lt; = property &lt;UProperty.MASK_LIMIT. Only these properties can be enumerated.</param>
	    /// <param name="valueAlias">the value name to be matched. The name is compared using"loose matching" as described in PropertyValueAliases.txt.</param>
	    /// <returns>a value integer. Note: UProperty.GENERAL_CATEGORY values are mask
	    /// values produced by left-shifting 1 by UCharacter.getType(). This
	    /// allows grouped categories such as [:L:] to be represented.</returns>
	    /// <seealso cref="T:IBM.ICU.Lang.UProperty"/>
	    /// <exception cref="IllegalArgumentException">if property is not a valid UProperty selector</exception>
	    /// @stable ICU 2.4
	    public static int GetPropertyValueEnum(int property, String valueAlias) {
	        return PNAMES_.GetPropertyValueEnum(property, valueAlias);
	    }
	
	    /// <summary>
	    /// Returns a code point corresponding to the two UTF16 characters.
	    /// </summary>
	    ///
	    /// <param name="lead">the lead char</param>
	    /// <param name="trail">the trail char</param>
	    /// <returns>code point if surrogate characters are valid.</returns>
	    /// <exception cref="IllegalArgumentException">thrown when argument characters do not form a validcodepoint</exception>
	    /// @stable ICU 2.1
	    public static int GetCodePoint(char lead, char trail) {
	        if (IBM.ICU.Text.UTF16.IsLeadSurrogate(lead) && IBM.ICU.Text.UTF16.IsTrailSurrogate(trail)) {
	            return IBM.ICU.Impl.UCharacterProperty.GetRawSupplementary(lead, trail);
	        }
	        throw new ArgumentException("Illegal surrogate characters");
	    }
	
	    /// <summary>
	    /// Returns the code point corresponding to the UTF16 character.
	    /// </summary>
	    ///
	    /// <param name="char16">the UTF16 character</param>
	    /// <returns>code point if argument is a valid character.</returns>
	    /// <exception cref="IllegalArgumentException">thrown when char16 is not a valid codepoint</exception>
	    /// @stable ICU 2.1
	    public static int GetCodePoint(char char16) {
	        if (UCharacter.IsLegal(char16)) {
	            return char16;
	        }
	        throw new ArgumentException("Illegal codepoint");
	    }
	
	    /// <summary>
	    /// Implementation of UCaseProps.ContextIterator, iterates over a String. See
	    /// ustrcase.c/utf16_caseContextIterator().
	    /// </summary>
	    ///
	    private class StringContextIterator : 
	            UCaseProps.ContextIterator {
	        /// <summary>
	        /// Constructor.
	        /// </summary>
	        ///
	        /// <param name="s">String to iterate over.</param>
	        internal StringContextIterator(String s) {
	            this.s = s;
	            limit = s.Length;
	            cpStart = cpLimit = index = 0;
	            dir = 0;
	        }
	
	        /// <summary>
	        /// Set the iteration limit for nextCaseMapCP() to an index within the
	        /// string. If the limit parameter is negative or past the string, then
	        /// the string length is restored as the iteration limit.
	        /// This limit does not affect the next() function which always iterates
	        /// to the very end of the string.
	        /// </summary>
	        ///
	        /// <param name="lim">The iteration limit.</param>
	        public void SetLimit(int lim) {
	            if (0 <= lim && lim <= s.Length) {
	                limit = lim;
	            } else {
	                limit = s.Length;
	            }
	        }
	
	        /// <summary>
	        /// Move to the iteration limit without fetching code points up to there.
	        /// </summary>
	        ///
	        public void MoveToLimit() {
	            cpStart = cpLimit = limit;
	        }
	
	        /// <summary>
	        /// Iterate forward through the string to fetch the next code point to be
	        /// case-mapped, and set the context indexes for it. Performance
	        /// optimization, to save on function calls and redundant tests. Combines
	        /// UTF16.charAt(), UTF16.getCharCount(), and setIndex().
	        /// When the iteration limit is reached (and -1 is returned),
	        /// getCPStart() will be at the iteration limit.
	        /// Iteration with next() does not affect the position for
	        /// nextCaseMapCP().
	        /// </summary>
	        ///
	        /// <returns>The next code point to be case-mapped, or <0 when the
	        /// iteration is done.</returns>
	        public int NextCaseMapCP() {
	            cpStart = cpLimit;
	            if (cpLimit < limit) {
	                int c = s[cpLimit++];
	                if (IBM.ICU.Text.UTF16.LEAD_SURROGATE_MIN_VALUE <= c
	                        || c <= IBM.ICU.Text.UTF16.TRAIL_SURROGATE_MAX_VALUE) {
	                    char c2;
	                    if (c <= IBM.ICU.Text.UTF16.LEAD_SURROGATE_MAX_VALUE
	                            && cpLimit < limit
	                            && IBM.ICU.Text.UTF16.TRAIL_SURROGATE_MIN_VALUE <= (c2 = s[cpLimit])
	                            && c2 <= IBM.ICU.Text.UTF16.TRAIL_SURROGATE_MAX_VALUE) {
	                        // supplementary code point
	                        ++cpLimit;
	                        c = IBM.ICU.Impl.UCharacterProperty
	                                .GetRawSupplementary((char) c, c2);
	                        // else unpaired surrogate code point
	                    }
	                    // else BMP code point
	                }
	                return c;
	            } else {
	                return -1;
	            }
	        }
	
	        /// <summary>
	        /// Get the start of the code point that was last returned by
	        /// nextCaseMapCP().
	        /// </summary>
	        ///
	        public int GetCPStart() {
	            return cpStart;
	        }
	
	        /// <summary>
	        /// Get the limit of the code point that was last returned by
	        /// nextCaseMapCP().
	        /// </summary>
	        ///
	        public int GetCPLimit() {
	            return cpLimit;
	        }
	
	        // implement UCaseProps.ContextIterator
	        public virtual void Reset(int dir) {
	            if (dir > 0) {
	                /* reset for forward iteration */
	                this.dir = 1;
	                index = cpLimit;
	            } else if (dir < 0) {
	                /* reset for backward iteration */
	                this.dir = -1;
	                index = cpStart;
	            } else {
	                // not a valid direction
	                this.dir = 0;
	                index = 0;
	            }
	        }
	
	        public virtual int Next() {
	            int c;
	
	            if (dir > 0 && index < s.Length) {
	                c = IBM.ICU.Text.UTF16.CharAt(s, index);
	                index += IBM.ICU.Text.UTF16.GetCharCount(c);
	                return c;
	            } else if (dir < 0 && index > 0) {
	                c = IBM.ICU.Text.UTF16.CharAt(s, index - 1);
	                index -= IBM.ICU.Text.UTF16.GetCharCount(c);
	                return c;
	            }
	            return -1;
	        }
	
	        // variables
	        protected internal String s;
	
	        protected internal int index, limit, cpStart, cpLimit;
	
	        protected internal int dir; // 0=initial state >0=forward <0=backward
	    }
	
	    /// <summary>
	    /// Gets uppercase version of the argument string. Casing is dependent on the
	    /// default locale and context-sensitive.
	    /// </summary>
	    ///
	    /// <param name="str">source string to be performed on</param>
	    /// <returns>uppercase version of the argument string</returns>
	    /// @stable ICU 2.1
	    public static String ToUpperCase(String str) {
	        return ToUpperCase(IBM.ICU.Util.ULocale.GetDefault(), str);
	    }
	
	    /// <summary>
	    /// Gets lowercase version of the argument string. Casing is dependent on the
	    /// default locale and context-sensitive
	    /// </summary>
	    ///
	    /// <param name="str">source string to be performed on</param>
	    /// <returns>lowercase version of the argument string</returns>
	    /// @stable ICU 2.1
	    public static String ToLowerCase(String str) {
	        return ToLowerCase(IBM.ICU.Util.ULocale.GetDefault(), str);
	    }
	
	    /// <summary>
	    /// <p>
	    /// Gets the titlecase version of the argument string.
	    /// </p>
	    /// <p>
	    /// Position for titlecasing is determined by the argument break iterator,
	    /// hence the user can customize his break iterator for a specialized
	    /// titlecasing. In this case only the forward iteration needs to be
	    /// implemented. If the break iterator passed in is null, the default Unicode
	    /// algorithm will be used to determine the titlecase positions.
	    /// </p>
	    /// <p>
	    /// Only positions returned by the break iterator will be title cased,
	    /// character in between the positions will all be in lower case.
	    /// </p>
	    /// <p>
	    /// Casing is dependent on the default locale and context-sensitive
	    /// </p>
	    /// </summary>
	    ///
	    /// <param name="str">source string to be performed on</param>
	    /// <param name="breakiter">break iterator to determine the positions in which thecharacter should be title cased.</param>
	    /// <returns>lowercase version of the argument string</returns>
	    /// @stable ICU 2.6
	    public static String ToTitleCase(String str, BreakIterator breakiter) {
	        return ToTitleCase(IBM.ICU.Util.ULocale.GetDefault(), str, breakiter);
	    }
	
	    /// <summary>
	    /// Gets uppercase version of the argument string. Casing is dependent on the
	    /// argument locale and context-sensitive.
	    /// </summary>
	    ///
	    /// <param name="locale">which string is to be converted in</param>
	    /// <param name="str">source string to be performed on</param>
	    /// <returns>uppercase version of the argument string</returns>
	    /// @stable ICU 2.1
        public static String ToUpperCase(ILOG.J2CsMapping.Util.Locale locale, String str)
        {
	        return ToUpperCase(IBM.ICU.Util.ULocale.ForLocale(locale), str);
	    }
	
	    /// <summary>
	    /// Gets uppercase version of the argument string. Casing is dependent on the
	    /// argument locale and context-sensitive.
	    /// </summary>
	    ///
	    /// <param name="locale">which string is to be converted in</param>
	    /// <param name="str">source string to be performed on</param>
	    /// <returns>uppercase version of the argument string</returns>
	    /// @stable ICU 3.2
	    public static String ToUpperCase(ULocale locale, String str) {
	        UCharacter.StringContextIterator  iter = new UCharacter.StringContextIterator (str);
	        StringBuilder result = new StringBuilder(str.Length);
	        int[] locCache = new int[1];
	        int c;
	
	        if (locale == null) {
	            locale = IBM.ICU.Util.ULocale.GetDefault();
	        }
	        locCache[0] = 0;
	
	        while ((c = iter.NextCaseMapCP()) >= 0) {
	            c = gCsp.ToFullUpper(c, iter, result, locale, locCache);
	
	            /* decode the result */
	            if (c < 0) {
	                /* (not) original code point */
	                c = ~c;
	            } else if (c <= IBM.ICU.Impl.UCaseProps.MAX_STRING_LENGTH) {
	                /* mapping already appended to result */
	                continue;
	                /* } else { append single-code point mapping */
	            }
	            if (c <= 0xffff) {
	                result.Append((char) c);
	            } else {
	                IBM.ICU.Text.UTF16.Append(result, c);
	            }
	        }
	        return result.ToString();
	    }
	
	    /// <summary>
	    /// Gets lowercase version of the argument string. Casing is dependent on the
	    /// argument locale and context-sensitive
	    /// </summary>
	    ///
	    /// <param name="locale">which string is to be converted in</param>
	    /// <param name="str">source string to be performed on</param>
	    /// <returns>lowercase version of the argument string</returns>
	    /// @stable ICU 2.1
        public static String ToLowerCase(ILOG.J2CsMapping.Util.Locale locale, String str)
        {
	        return ToLowerCase(IBM.ICU.Util.ULocale.ForLocale(locale), str);
	    }
	
	    /// <summary>
	    /// Gets lowercase version of the argument string. Casing is dependent on the
	    /// argument locale and context-sensitive
	    /// </summary>
	    ///
	    /// <param name="locale">which string is to be converted in</param>
	    /// <param name="str">source string to be performed on</param>
	    /// <returns>lowercase version of the argument string</returns>
	    /// @stable ICU 3.2
	    public static String ToLowerCase(ULocale locale, String str) {
	        UCharacter.StringContextIterator  iter = new UCharacter.StringContextIterator (str);
	        StringBuilder result = new StringBuilder(str.Length);
	        int[] locCache = new int[1];
	        int c;
	
	        if (locale == null) {
	            locale = IBM.ICU.Util.ULocale.GetDefault();
	        }
	        locCache[0] = 0;
	
	        while ((c = iter.NextCaseMapCP()) >= 0) {
	            c = gCsp.ToFullLower(c, iter, result, locale, locCache);
	
	            /* decode the result */
	            if (c < 0) {
	                /* (not) original code point */
	                c = ~c;
	            } else if (c <= IBM.ICU.Impl.UCaseProps.MAX_STRING_LENGTH) {
	                /* mapping already appended to result */
	                continue;
	                /* } else { append single-code point mapping */
	            }
	            if (c <= 0xffff) {
	                result.Append((char) c);
	            } else {
	                IBM.ICU.Text.UTF16.Append(result, c);
	            }
	        }
	        return result.ToString();
	    }
	
	    /// <summary>
	    /// <p>
	    /// Gets the titlecase version of the argument string.
	    /// </p>
	    /// <p>
	    /// Position for titlecasing is determined by the argument break iterator,
	    /// hence the user can customize his break iterator for a specialized
	    /// titlecasing. In this case only the forward iteration needs to be
	    /// implemented. If the break iterator passed in is null, the default Unicode
	    /// algorithm will be used to determine the titlecase positions.
	    /// </p>
	    /// <p>
	    /// Only positions returned by the break iterator will be title cased,
	    /// character in between the positions will all be in lower case.
	    /// </p>
	    /// <p>
	    /// Casing is dependent on the argument locale and context-sensitive
	    /// </p>
	    /// </summary>
	    ///
	    /// <param name="locale">which string is to be converted in</param>
	    /// <param name="str">source string to be performed on</param>
	    /// <param name="breakiter">break iterator to determine the positions in which thecharacter should be title cased.</param>
	    /// <returns>lowercase version of the argument string</returns>
	    /// @stable ICU 2.6
        public static String ToTitleCase(ILOG.J2CsMapping.Util.Locale locale, String str,
	            BreakIterator breakiter) {
	        return ToTitleCase(IBM.ICU.Util.ULocale.ForLocale(locale), str, breakiter);
	    }
	
	    /// <summary>
	    /// <p>
	    /// Gets the titlecase version of the argument string.
	    /// </p>
	    /// <p>
	    /// Position for titlecasing is determined by the argument break iterator,
	    /// hence the user can customize his break iterator for a specialized
	    /// titlecasing. In this case only the forward iteration needs to be
	    /// implemented. If the break iterator passed in is null, the default Unicode
	    /// algorithm will be used to determine the titlecase positions.
	    /// </p>
	    /// <p>
	    /// Only positions returned by the break iterator will be title cased,
	    /// character in between the positions will all be in lower case.
	    /// </p>
	    /// <p>
	    /// Casing is dependent on the argument locale and context-sensitive
	    /// </p>
	    /// </summary>
	    ///
	    /// <param name="locale">which string is to be converted in</param>
	    /// <param name="str">source string to be performed on</param>
	    /// <param name="titleIter">break iterator to determine the positions in which thecharacter should be title cased.</param>
	    /// <returns>lowercase version of the argument string</returns>
	    /// @stable ICU 3.2
	    public static String ToTitleCase(ULocale locale, String str,
	            BreakIterator titleIter) {
	        return ToTitleCase(locale, str, titleIter, 0);
	    }
	
	    /// <summary>
	    /// <p>
	    /// Gets the titlecase version of the argument string.
	    /// </p>
	    /// <p>
	    /// Position for titlecasing is determined by the argument break iterator,
	    /// hence the user can customize his break iterator for a specialized
	    /// titlecasing. In this case only the forward iteration needs to be
	    /// implemented. If the break iterator passed in is null, the default Unicode
	    /// algorithm will be used to determine the titlecase positions.
	    /// </p>
	    /// <p>
	    /// Only positions returned by the break iterator will be title cased,
	    /// character in between the positions will all be in lower case.
	    /// </p>
	    /// <p>
	    /// Casing is dependent on the argument locale and context-sensitive
	    /// </p>
	    /// </summary>
	    ///
	    /// <param name="locale">which string is to be converted in</param>
	    /// <param name="str">source string to be performed on</param>
	    /// <param name="titleIter">break iterator to determine the positions in which thecharacter should be title cased.</param>
	    /// <param name="options">bit set to modify the titlecasing operation</param>
	    /// <returns>lowercase version of the argument string</returns>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    /// <seealso cref="F:IBM.ICU.Lang.UCharacter.TITLECASE_NO_LOWERCASE"/>
	    /// <seealso cref="F:IBM.ICU.Lang.UCharacter.TITLECASE_NO_BREAK_ADJUSTMENT"/>
	    public static String ToTitleCase(ULocale locale, String str,
	            BreakIterator titleIter, int options) {
	        UCharacter.StringContextIterator  iter = new UCharacter.StringContextIterator (str);
	        StringBuilder result = new StringBuilder(str.Length);
	        int[] locCache = new int[1];
	        int c, srcLength = str.Length;
	
	        if (locale == null) {
	            locale = IBM.ICU.Util.ULocale.GetDefault();
	        }
	        locCache[0] = 0;
	
	        if (titleIter == null) {
	            titleIter = IBM.ICU.Text.BreakIterator.GetWordInstance(locale);
	        }
	        titleIter.SetText(str);
	
	        int prev, titleStart, index_0;
	        bool isFirstIndex;
	
	        /* set up local variables */
	        prev = 0;
	        isFirstIndex = true;
	
	        /* titlecasing loop */
	        while (prev < srcLength) {
	            /* find next index where to titlecase */
	            if (isFirstIndex) {
	                isFirstIndex = false;
	                index_0 = titleIter.First();
	            } else {
	                index_0 = titleIter.Next();
	            }
	            if (index_0 == IBM.ICU.Text.BreakIterator.DONE || index_0 > srcLength) {
	                index_0 = srcLength;
	            }
	
	            /*
	             * Unicode 4 & 5 section 3.13 Default Case Operations:
	             * 
	             * R3 toTitlecase(X): Find the word boundaries based on Unicode
	             * Standard Annex #29, "Text Boundaries." Between each pair of word
	             * boundaries, find the first cased character F. If F exists, map F
	             * to default_title(F); then map each subsequent character C to
	             * default_lower(C).
	             * 
	             * In this implementation, segment [prev..index[ into 3 parts: a)
	             * uncased characters (copy as-is) [prev..titleStart[ b) first case
	             * letter (titlecase) [titleStart..titleLimit[ c) subsequent
	             * characters (lowercase) [titleLimit..index[
	             */
	            if (prev < index_0) {
	                /* find and copy uncased characters [prev..titleStart[ */
	                iter.SetLimit(index_0);
	                c = iter.NextCaseMapCP();
	                if ((options & TITLECASE_NO_BREAK_ADJUSTMENT) == 0
	                        && IBM.ICU.Impl.UCaseProps.NONE == gCsp.GetType(c)) {
	                    while ((c = iter.NextCaseMapCP()) >= 0
	                            && IBM.ICU.Impl.UCaseProps.NONE == gCsp.GetType(c)) {
	                    }
	                    titleStart = iter.GetCPStart();
	                    if (prev < titleStart) {
	                        // TODO: With Java 5, this would want to be
	                        // result.append(str, prev, titleStart);
	                        result.Append(str.Substring(prev,(titleStart)-(prev)));
	                    }
	                } else {
	                    titleStart = prev;
	                }
	
	                if (titleStart < index_0) {
	                    /* titlecase c which is from titleStart */
	                    c = gCsp.ToFullTitle(c, iter, result, locale, locCache);
	
	                    /* decode the result and lowercase up to index */
	                    for (;;) {
	                        if (c < 0) {
	                            /* (not) original code point */
	                            c = ~c;
	                            if (c <= 0xffff) {
	                                result.Append((char) c);
	                            } else {
	                                IBM.ICU.Text.UTF16.Append(result, c);
	                            }
	                        } else if (c <= IBM.ICU.Impl.UCaseProps.MAX_STRING_LENGTH) {
	                            /* mapping already appended to result */
	                        } else {
	                            /* append single-code point mapping */
	                            if (c <= 0xffff) {
	                                result.Append((char) c);
	                            } else {
	                                IBM.ICU.Text.UTF16.Append(result, c);
	                            }
	                        }
	
	                        if ((options & TITLECASE_NO_LOWERCASE) != 0) {
	                            /*
	                             * Optionally just copy the rest of the word
	                             * unchanged.
	                             */
	                            int titleLimit = iter.GetCPLimit();
	                            if (titleLimit < index_0) {
	                                // TODO: With Java 5, this would want to be
	                                // result.append(str, titleLimit, index);
	                                result.Append(str.Substring(titleLimit,(index_0)-(titleLimit)));
	                                iter.MoveToLimit();
	                                break;
	                            }
	                        } else if ((c = iter.NextCaseMapCP()) >= 0) {
	                            /* Normal operation: Lowercase the rest of the word. */
	                            c = gCsp.ToFullLower(c, iter, result, locale,
	                                    locCache);
	                        } else {
	                            break;
	                        }
	                    }
	                }
	            }
	
	            prev = index_0;
	        }
	        return result.ToString();
	    }
	
	    /// <summary>
	    /// The given character is mapped to its case folding equivalent according to
	    /// UnicodeData.txt and CaseFolding.txt; if the character has no case folding
	    /// equivalent, the character itself is returned.
	    /// <p>
	    /// This function only returns the simple, single-code point case mapping.
	    /// Full case mappings should be used whenever possible because they produce
	    /// better results by working on whole strings. They can map to a result
	    /// string with a different length as appropriate. Full case mappings are
	    /// applied by the case mapping functions that take String parameters rather
	    /// than code points (int). See also the User Guide chapter on C/POSIX
	    /// migration: http://www.icu-project.org/userguide/posix.html#case_mappings
	    /// </summary>
	    ///
	    /// <param name="ch">the character to be converted</param>
	    /// <param name="defaultmapping">Indicates if all mappings defined in CaseFolding.txt is to beused, otherwise the mappings for dotted I and dotless i markedwith 'I' in CaseFolding.txt will be skipped.</param>
	    /// <returns>the case folding equivalent of the character, if any; otherwise
	    /// the character itself.</returns>
	    /// <seealso cref="M:IBM.ICU.Lang.UCharacter.FoldCase(System.String, System.Boolean)"/>
	    /// @stable ICU 2.1
	    public static int FoldCase(int ch, bool defaultmapping) {
	        return FoldCase(ch, (defaultmapping) ? FOLD_CASE_DEFAULT
	                : FOLD_CASE_EXCLUDE_SPECIAL_I);
	    }
	
	    /// <summary>
	    /// The given string is mapped to its case folding equivalent according to
	    /// UnicodeData.txt and CaseFolding.txt; if any character has no case folding
	    /// equivalent, the character itself is returned. "Full", multiple-code point
	    /// case folding mappings are returned here. For "simple" single-code point
	    /// mappings use the API foldCase(int ch, boolean defaultmapping).
	    /// </summary>
	    ///
	    /// <param name="str">the String to be converted</param>
	    /// <param name="defaultmapping">Indicates if all mappings defined in CaseFolding.txt is to beused, otherwise the mappings for dotted I and dotless i markedwith 'I' in CaseFolding.txt will be skipped.</param>
	    /// <returns>the case folding equivalent of the character, if any; otherwise
	    /// the character itself.</returns>
	    /// <seealso cref="M:IBM.ICU.Lang.UCharacter.FoldCase(System.Int32, System.Boolean)"/>
	    /// @stable ICU 2.1
	    public static String FoldCase(String str, bool defaultmapping) {
	        return FoldCase(str, (defaultmapping) ? FOLD_CASE_DEFAULT
	                : FOLD_CASE_EXCLUDE_SPECIAL_I);
	    }
	
	    /// <summary>
	    /// Option value for case folding: use default mappings defined in
	    /// CaseFolding.txt.
	    /// </summary>
	    ///
	    /// @stable ICU 2.6
	    public const int FOLD_CASE_DEFAULT = 0x0000;
	
	    /// <summary>
	    /// Option value for case folding: exclude the mappings for dotted I and
	    /// dotless i marked with 'I' in CaseFolding.txt.
	    /// </summary>
	    ///
	    /// @stable ICU 2.6
	    public const int FOLD_CASE_EXCLUDE_SPECIAL_I = 0x0001;
	
	    /// <summary>
	    /// The given character is mapped to its case folding equivalent according to
	    /// UnicodeData.txt and CaseFolding.txt; if the character has no case folding
	    /// equivalent, the character itself is returned.
	    /// <p>
	    /// This function only returns the simple, single-code point case mapping.
	    /// Full case mappings should be used whenever possible because they produce
	    /// better results by working on whole strings. They can map to a result
	    /// string with a different length as appropriate. Full case mappings are
	    /// applied by the case mapping functions that take String parameters rather
	    /// than code points (int). See also the User Guide chapter on C/POSIX
	    /// migration: http://www.icu-project.org/userguide/posix.html#case_mappings
	    /// </summary>
	    ///
	    /// <param name="ch">the character to be converted</param>
	    /// <param name="options">A bit set for special processing. Currently the recognisedoptions are FOLD_CASE_EXCLUDE_SPECIAL_I and FOLD_CASE_DEFAULT</param>
	    /// <returns>the case folding equivalent of the character, if any; otherwise
	    /// the character itself.</returns>
	    /// <seealso cref="M:IBM.ICU.Lang.UCharacter.FoldCase(System.String, System.Boolean)"/>
	    /// @stable ICU 2.6
	    public static int FoldCase(int ch, int options) {
	        return gCsp.Fold(ch, options);
	    }
	
	    /// <summary>
	    /// The given string is mapped to its case folding equivalent according to
	    /// UnicodeData.txt and CaseFolding.txt; if any character has no case folding
	    /// equivalent, the character itself is returned. "Full", multiple-code point
	    /// case folding mappings are returned here. For "simple" single-code point
	    /// mappings use the API foldCase(int ch, boolean defaultmapping).
	    /// </summary>
	    ///
	    /// <param name="str">the String to be converted</param>
	    /// <param name="options">A bit set for special processing. Currently the recognisedoptions are FOLD_CASE_EXCLUDE_SPECIAL_I and FOLD_CASE_DEFAULT</param>
	    /// <returns>the case folding equivalent of the character, if any; otherwise
	    /// the character itself.</returns>
	    /// <seealso cref="M:IBM.ICU.Lang.UCharacter.FoldCase(System.Int32, System.Boolean)"/>
	    /// @stable ICU 2.6
	    public static String FoldCase(String str, int options) {
	        StringBuilder result = new StringBuilder(str.Length);
	        int c, i, length;
	
	        length = str.Length;
	        for (i = 0; i < length;) {
	            c = IBM.ICU.Text.UTF16.CharAt(str, i);
	            i += IBM.ICU.Text.UTF16.GetCharCount(c);
	            c = gCsp.ToFullFolding(c, result, options);
	
	            /* decode the result */
	            if (c < 0) {
	                /* (not) original code point */
	                c = ~c;
	            } else if (c <= IBM.ICU.Impl.UCaseProps.MAX_STRING_LENGTH) {
	                /* mapping already appended to result */
	                continue;
	                /* } else { append single-code point mapping */
	            }
	            if (c <= 0xffff) {
	                result.Append((char) c);
	            } else {
	                IBM.ICU.Text.UTF16.Append(result, c);
	            }
	        }
	        return result.ToString();
	    }
	
	    /// <summary>
	    /// Return numeric value of Han code points. <br>
	    /// This returns the value of Han 'numeric' code points, including those for
	    /// zero, ten, hundred, thousand, ten thousand, and hundred million. This
	    /// includes both the standard and 'checkwriting' characters, the 'big
	    /// circle' zero character, and the standard zero character.
	    /// </summary>
	    ///
	    /// <param name="ch">code point to query</param>
	    /// <returns>value if it is a Han 'numeric character,' otherwise return -1.</returns>
	    /// @stable ICU 2.4
	    public static int GetHanNumericValue(int ch) {
	        // TODO: Are these all covered by Unicode numeric value data?
	        switch (ch) {
	        case IDEOGRAPHIC_NUMBER_ZERO_:
	        case CJK_IDEOGRAPH_COMPLEX_ZERO_:
	            return 0; // Han Zero
	        case CJK_IDEOGRAPH_FIRST_:
	        case CJK_IDEOGRAPH_COMPLEX_ONE_:
	            return 1; // Han One
	        case CJK_IDEOGRAPH_SECOND_:
	        case CJK_IDEOGRAPH_COMPLEX_TWO_:
	            return 2; // Han Two
	        case CJK_IDEOGRAPH_THIRD_:
	        case CJK_IDEOGRAPH_COMPLEX_THREE_:
	            return 3; // Han Three
	        case CJK_IDEOGRAPH_FOURTH_:
	        case CJK_IDEOGRAPH_COMPLEX_FOUR_:
	            return 4; // Han Four
	        case CJK_IDEOGRAPH_FIFTH_:
	        case CJK_IDEOGRAPH_COMPLEX_FIVE_:
	            return 5; // Han Five
	        case CJK_IDEOGRAPH_SIXTH_:
	        case CJK_IDEOGRAPH_COMPLEX_SIX_:
	            return 6; // Han Six
	        case CJK_IDEOGRAPH_SEVENTH_:
	        case CJK_IDEOGRAPH_COMPLEX_SEVEN_:
	            return 7; // Han Seven
	        case CJK_IDEOGRAPH_EIGHTH_:
	        case CJK_IDEOGRAPH_COMPLEX_EIGHT_:
	            return 8; // Han Eight
	        case CJK_IDEOGRAPH_NINETH_:
	        case CJK_IDEOGRAPH_COMPLEX_NINE_:
	            return 9; // Han Nine
	        case CJK_IDEOGRAPH_TEN_:
	        case CJK_IDEOGRAPH_COMPLEX_TEN_:
	            return 10;
	        case CJK_IDEOGRAPH_HUNDRED_:
	        case CJK_IDEOGRAPH_COMPLEX_HUNDRED_:
	            return 100;
	        case CJK_IDEOGRAPH_THOUSAND_:
	        case CJK_IDEOGRAPH_COMPLEX_THOUSAND_:
	            return 1000;
	        case CJK_IDEOGRAPH_TEN_THOUSAND_:
	            return 10000;
	        case CJK_IDEOGRAPH_HUNDRED_MILLION_:
	            return 100000000;
	        }
	        return -1; // no value
	    }
	
	    /// <summary>
	    /// <p>
	    /// Gets an iterator for character types, iterating over codepoints.
	    /// </p>
	    /// Example of use:<br>
	    /// <pre>
	    /// RangeValueIterator iterator = UCharacter.getTypeIterator();
	    /// RangeValueIterator.Element element = new RangeValueIterator.Element();
	    /// while (iterator.next(element)) {
	    /// System.out.println(&quot;Codepoint \\u&quot; + Integer.toHexString(element.start)
	    /// + &quot; to codepoint \\u&quot; + Integer.toHexString(element.limit - 1)
	    /// + &quot; has the character type &quot; + element.value);
	    /// }
	    /// </pre>
	    /// </summary>
	    ///
	    /// <returns>an iterator</returns>
	    /// @stable ICU 2.6
	    public static RangeValueIterator GetTypeIterator() {
	        return new UCharacterTypeIterator(PROPERTY_);
	    }
	
	    /// <summary>
	    /// <p>
	    /// Gets an iterator for character names, iterating over codepoints.
	    /// </p>
	    /// <p>
	    /// This API only gets the iterator for the modern, most up-to-date Unicode
	    /// names. For older 1.0 Unicode names use get1_0NameIterator() or for
	    /// extended names use getExtendedNameIterator().
	    /// </p>
	    /// Example of use:<br>
	    /// <pre>
	    /// ValueIterator iterator = UCharacter.getNameIterator();
	    /// ValueIterator.Element element = new ValueIterator.Element();
	    /// while (iterator.next(element)) {
	    /// System.out.println(&quot;Codepoint \\u&quot; + Integer.toHexString(element.codepoint)
	    /// + &quot; has the name &quot; + (String) element.value);
	    /// }
	    /// </pre>
	    /// <p>
	    /// The maximal range which the name iterator iterates is from
	    /// UCharacter.MIN_VALUE to UCharacter.MAX_VALUE.
	    /// </p>
	    /// </summary>
	    ///
	    /// <returns>an iterator</returns>
	    /// @stable ICU 2.6
	    public static ValueIterator GetNameIterator() {
	        if (NAME_ == null) {
	            throw new Exception("Could not load unames.icu");
	        }
	        return new UCharacterNameIterator(NAME_,
	                IBM.ICU.Impl.UCharacterNameChoice_Constants.UNICODE_CHAR_NAME);
	    }
	
	    /// <summary>
	    /// <p>
	    /// Gets an iterator for character names, iterating over codepoints.
	    /// </p>
	    /// <p>
	    /// This API only gets the iterator for the older 1.0 Unicode names. For
	    /// modern, most up-to-date Unicode names use getNameIterator() or for
	    /// extended names use getExtendedNameIterator().
	    /// </p>
	    /// Example of use:<br>
	    /// <pre>
	    /// ValueIterator iterator = UCharacter.get1_0NameIterator();
	    /// ValueIterator.Element element = new ValueIterator.Element();
	    /// while (iterator.next(element)) {
	    /// System.out.println(&quot;Codepoint \\u&quot; + Integer.toHexString(element.codepoint)
	    /// + &quot; has the name &quot; + (String) element.value);
	    /// }
	    /// </pre>
	    /// <p>
	    /// The maximal range which the name iterator iterates is from
	    /// </summary>
	    ///
	    /// <returns>an iterator</returns>
	    /// @stable ICU 2.6
	    public static ValueIterator GetName1_0Iterator() {
	        if (NAME_ == null) {
	            throw new Exception("Could not load unames.icu");
	        }
	        return new UCharacterNameIterator(NAME_,
                    IBM.ICU.Impl.UCharacterNameChoice_Constants.UNICODE_10_CHAR_NAME);
	    }
	
	    /// <summary>
	    /// <p>
	    /// Gets an iterator for character names, iterating over codepoints.
	    /// </p>
	    /// <p>
	    /// This API only gets the iterator for the extended names. For modern, most
	    /// up-to-date Unicode names use getNameIterator() or for older 1.0 Unicode
	    /// names use get1_0NameIterator().
	    /// </p>
	    /// Example of use:<br>
	    /// <pre>
	    /// ValueIterator iterator = UCharacter.getExtendedNameIterator();
	    /// ValueIterator.Element element = new ValueIterator.Element();
	    /// while (iterator.next(element)) {
	    /// System.out.println(&quot;Codepoint \\u&quot; + Integer.toHexString(element.codepoint)
	    /// + &quot; has the name &quot; + (String) element.value);
	    /// }
	    /// </pre>
	    /// <p>
	    /// The maximal range which the name iterator iterates is from
	    /// </summary>
	    ///
	    /// <returns>an iterator</returns>
	    /// @stable ICU 2.6
	    public static ValueIterator GetExtendedNameIterator() {
	        if (NAME_ == null) {
	            throw new MissingManifestResourceException("Could not load unames.icu");
	        }
	        return new UCharacterNameIterator(NAME_,
                    IBM.ICU.Impl.UCharacterNameChoice_Constants.EXTENDED_CHAR_NAME);
	    }
	
	    /// <summary>
	    /// <p>
	    /// Get the "age" of the code point.
	    /// </p>
	    /// <p>
	    /// The "age" is the Unicode version when the code point was first designated
	    /// (as a non-character or for Private Use) or assigned a character.
	    /// <p>
	    /// This can be useful to avoid emitting code points to receiving processes
	    /// that do not accept newer characters.
	    /// </p>
	    /// <p>
	    /// The data is from the UCD file DerivedAge.txt.
	    /// </p>
	    /// </summary>
	    ///
	    /// <param name="ch">The code point.</param>
	    /// <returns>the Unicode version number</returns>
	    /// @stable ICU 2.6
	    public static VersionInfo GetAge(int ch) {
	        if (ch < MIN_VALUE || ch > MAX_VALUE) {
	            throw new ArgumentException("Codepoint out of bounds");
	        }
	        return PROPERTY_.GetAge(ch);
	    }
	
	    /// <summary>
	    /// <p>
	    /// Check a binary Unicode property for a code point.
	    /// </p>
	    /// <p>
	    /// Unicode, especially in version 3.2, defines many more properties than the
	    /// original set in UnicodeData.txt.
	    /// </p>
	    /// <p>
	    /// This API is intended to reflect Unicode properties as defined in the
	    /// Unicode Character Database (UCD) and Unicode Technical Reports (UTR).
	    /// </p>
	    /// <p>
	    /// For details about the properties see <a
	    /// href=http://www.unicode.org/>http://www.unicode.org/</a>.
	    /// </p>
	    /// <p>
	    /// For names of Unicode properties see the UCD file PropertyAliases.txt.
	    /// </p>
	    /// <p>
	    /// This API does not check the validity of the codepoint.
	    /// </p>
	    /// <p>
	    /// Important: If ICU is built with UCD files from Unicode versions below
	    /// 3.2, then properties marked with "new" are not or not fully available.
	    /// </p>
	    /// </summary>
	    ///
	    /// <param name="ch">code point to test.</param>
	    /// <param name="property">selector constant from com.ibm.icu.lang.UProperty, identifieswhich binary property to check.</param>
	    /// <returns>true or false according to the binary Unicode property value for
	    /// ch. Also false if property is out of bounds or if the Unicode
	    /// version does not have data for the property at all, or not for
	    /// this code point.</returns>
	    /// <seealso cref="T:IBM.ICU.Lang.UProperty"/>
	    /// @stable ICU 2.6
	    public static bool HasBinaryProperty(int ch, int property) {
	        if (ch < MIN_VALUE || ch > MAX_VALUE) {
	            throw new ArgumentException("Codepoint out of bounds");
	        }
	        return PROPERTY_.HasBinaryProperty(ch, property);
	    }
	
	    /// <summary>
	    /// <p>
	    /// Check if a code point has the Alphabetic Unicode property.
	    /// </p>
	    /// <p>
	    /// Same as UCharacter.hasBinaryProperty(ch, UProperty.ALPHABETIC).
	    /// </p>
	    /// <p>
	    /// Different from UCharacter.isLetter(ch)!
	    /// </p>
	    /// </summary>
	    ///
	    /// @stable ICU 2.6
	    /// <param name="ch">codepoint to be tested</param>
	    public static bool IsUAlphabetic(int ch) {
	        return HasBinaryProperty(ch, IBM.ICU.Lang.UProperty_Constants.ALPHABETIC);
	    }
	
	    /// <summary>
	    /// <p>
	    /// Check if a code point has the Lowercase Unicode property.
	    /// </p>
	    /// <p>
	    /// Same as UCharacter.hasBinaryProperty(ch, UProperty.LOWERCASE).
	    /// </p>
	    /// <p>
	    /// This is different from UCharacter.isLowerCase(ch)!
	    /// </p>
	    /// </summary>
	    ///
	    /// <param name="ch">codepoint to be tested</param>
	    /// @stable ICU 2.6
	    public static bool IsULowercase(int ch) {
	        return HasBinaryProperty(ch, IBM.ICU.Lang.UProperty_Constants.LOWERCASE);
	    }
	
	    /// <summary>
	    /// <p>
	    /// Check if a code point has the Uppercase Unicode property.
	    /// </p>
	    /// <p>
	    /// Same as UCharacter.hasBinaryProperty(ch, UProperty.UPPERCASE).
	    /// </p>
	    /// <p>
	    /// This is different from UCharacter.isUpperCase(ch)!
	    /// </p>
	    /// </summary>
	    ///
	    /// <param name="ch">codepoint to be tested</param>
	    /// @stable ICU 2.6
	    public static bool IsUUppercase(int ch) {
	        return HasBinaryProperty(ch, IBM.ICU.Lang.UProperty_Constants.UPPERCASE);
	    }
	
	    /// <summary>
	    /// <p>
	    /// Check if a code point has the White_Space Unicode property.
	    /// </p>
	    /// <p>
	    /// Same as UCharacter.hasBinaryProperty(ch, UProperty.WHITE_SPACE).
	    /// </p>
	    /// <p>
	    /// This is different from both UCharacter.isSpace(ch) and
	    /// UCharacter.isWhitespace(ch)!
	    /// </p>
	    /// </summary>
	    ///
	    /// <param name="ch">codepoint to be tested</param>
	    /// @stable ICU 2.6
	    public static bool IsUWhiteSpace(int ch) {
	        return HasBinaryProperty(ch, IBM.ICU.Lang.UProperty_Constants.WHITE_SPACE);
	    }
	
	    /// <summary>
	    /// <p>
	    /// Gets the property value for an Unicode property type of a code point.
	    /// Also returns binary and mask property values.
	    /// </p>
	    /// <p>
	    /// Unicode, especially in version 3.2, defines many more properties than the
	    /// original set in UnicodeData.txt.
	    /// </p>
	    /// <p>
	    /// The properties APIs are intended to reflect Unicode properties as defined
	    /// in the Unicode Character Database (UCD) and Unicode Technical Reports
	    /// (UTR). For details about the properties see http://www.unicode.org/.
	    /// </p>
	    /// <p>
	    /// For names of Unicode properties see the UCD file PropertyAliases.txt.
	    /// </p>
	    /// <pre>
	    /// Sample usage:
	    /// int ea = UCharacter.getIntPropertyValue(c, UProperty.EAST_ASIAN_WIDTH);
	    /// int ideo = UCharacter.getIntPropertyValue(c, UProperty.IDEOGRAPHIC);
	    /// boolean b = (ideo == 1) ? true : false;
	    /// </pre>
	    /// </summary>
	    ///
	    /// <param name="ch">code point to test.</param>
	    /// <param name="type">UProperty selector constant, identifies which binary propertyto check. Must be UProperty.BINARY_START &lt;= type &lt;UProperty.BINARY_LIMIT or UProperty.INT_START &lt;= type &lt;UProperty.INT_LIMIT or UProperty.MASK_START &lt;= type &lt;UProperty.MASK_LIMIT.</param>
	    /// <returns>numeric value that is directly the property value or, for
	    /// enumerated properties, corresponds to the numeric value of the
	    /// enumerated constant of the respective property value enumeration
	    /// type (cast to enum type if necessary). Returns 0 or 1 (for false
	    /// / true) for binary Unicode properties. Returns a bit-mask for
	    /// mask properties. Returns 0 if 'type' is out of bounds or if the
	    /// Unicode version does not have data for the property at all, or
	    /// not for this code point.</returns>
	    /// <seealso cref="T:IBM.ICU.Lang.UProperty"/>
	    /// <seealso cref="M:IBM.ICU.Lang.UCharacter.HasBinaryProperty(System.Int32, System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Lang.UCharacter.GetIntPropertyMinValue(System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Lang.UCharacter.GetIntPropertyMaxValue(System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Lang.UCharacter.GetUnicodeVersion"/>
	    /// @stable ICU 2.4
	    public static int GetIntPropertyValue(int ch, int type) {
	        if (type < IBM.ICU.Lang.UProperty_Constants.BINARY_START) {
	            return 0; // undefined
	        } else if (type < IBM.ICU.Lang.UProperty_Constants.BINARY_LIMIT) {
	            return (HasBinaryProperty(ch, type)) ? 1 : 0;
	        } else if (type < IBM.ICU.Lang.UProperty_Constants.INT_START) {
	            return 0; // undefined
	        } else if (type < IBM.ICU.Lang.UProperty_Constants.INT_LIMIT) {
	            // int result = 0;
	            switch (type) {
	            case IBM.ICU.Lang.UProperty_Constants.BIDI_CLASS:
	                return GetDirection(ch);
	            case IBM.ICU.Lang.UProperty_Constants.BLOCK:
	                return IBM.ICU.Lang.UCharacter.UnicodeBlock.IdOf(ch);
	            case IBM.ICU.Lang.UProperty_Constants.CANONICAL_COMBINING_CLASS:
	                return GetCombiningClass(ch);
	            case IBM.ICU.Lang.UProperty_Constants.DECOMPOSITION_TYPE:
	                return PROPERTY_.GetAdditional(ch, 2)
	                        & DECOMPOSITION_TYPE_MASK_;
	            case IBM.ICU.Lang.UProperty_Constants.EAST_ASIAN_WIDTH:
	                return (PROPERTY_.GetAdditional(ch, 0) & EAST_ASIAN_MASK_) >> EAST_ASIAN_SHIFT_;
	            case IBM.ICU.Lang.UProperty_Constants.GENERAL_CATEGORY:
	                return GetType(ch);
	            case IBM.ICU.Lang.UProperty_Constants.JOINING_GROUP:
	                return gBdp.GetJoiningGroup(ch);
	            case IBM.ICU.Lang.UProperty_Constants.JOINING_TYPE:
	                return gBdp.GetJoiningType(ch);
	            case IBM.ICU.Lang.UProperty_Constants.LINE_BREAK:
	                return (int) (PROPERTY_.GetAdditional(ch, 0) & LINE_BREAK_MASK_) >> LINE_BREAK_SHIFT_;
	            case IBM.ICU.Lang.UProperty_Constants.NUMERIC_TYPE:
	                type = GetNumericType(PROPERTY_.GetProperty(ch));
	                if (type > IBM.ICU.Lang.UCharacter.NumericType.NUMERIC) {
	                    /*
	                     * keep internal variants of NumericType.NUMERIC from
	                     * becoming visible
	                     */
	                    type = IBM.ICU.Lang.UCharacter.NumericType.NUMERIC;
	                }
	                return type;
	            case IBM.ICU.Lang.UProperty_Constants.SCRIPT:
	                return IBM.ICU.Lang.UScript.GetScript(ch);
	            case IBM.ICU.Lang.UProperty_Constants.HANGUL_SYLLABLE_TYPE:
	                /*
	                 * purely algorithmic; hardcode known characters, check for
	                 * assigned new ones
	                 */
	                if (ch < IBM.ICU.Impl.NormalizerImpl.JAMO_L_BASE) {
	                    /* NA */
	                } else if (ch <= 0x11ff) {
	                    /* Jamo range */
	                    if (ch <= 0x115f) {
	                        /* Jamo L range, HANGUL CHOSEONG ... */
	                        if (ch == 0x115f
	                                || ch <= 0x1159
	                                || GetType(ch) == IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.OTHER_LETTER) {
	                            return IBM.ICU.Lang.UCharacter.HangulSyllableType.LEADING_JAMO;
	                        }
	                    } else if (ch <= 0x11a7) {
	                        /* Jamo V range, HANGUL JUNGSEONG ... */
	                        if (ch <= 0x11a2
	                                || GetType(ch) == IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.OTHER_LETTER) {
	                            return IBM.ICU.Lang.UCharacter.HangulSyllableType.VOWEL_JAMO;
	                        }
	                    } else {
	                        /* Jamo T range */
	                        if (ch <= 0x11f9
	                                || GetType(ch) == IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.OTHER_LETTER) {
	                            return IBM.ICU.Lang.UCharacter.HangulSyllableType.TRAILING_JAMO;
	                        }
	                    }
	                } else if ((ch -= IBM.ICU.Impl.NormalizerImpl.HANGUL_BASE) < 0) {
	                    /* NA */
	                } else if (ch < IBM.ICU.Impl.NormalizerImpl.HANGUL_COUNT) {
	                    /* Hangul syllable */
	                    return (ch % IBM.ICU.Impl.NormalizerImpl.JAMO_T_COUNT == 0) ? IBM.ICU.Lang.UCharacter.HangulSyllableType.LV_SYLLABLE
	                            : IBM.ICU.Lang.UCharacter.HangulSyllableType.LVT_SYLLABLE;
	                }
	                return 0; /* NA */
	
	            case IBM.ICU.Lang.UProperty_Constants.NFD_QUICK_CHECK:
	            case IBM.ICU.Lang.UProperty_Constants.NFKD_QUICK_CHECK:
	            case IBM.ICU.Lang.UProperty_Constants.NFC_QUICK_CHECK:
	            case IBM.ICU.Lang.UProperty_Constants.NFKC_QUICK_CHECK:
	                return IBM.ICU.Impl.NormalizerImpl.QuickCheck(ch,
	                        (type - IBM.ICU.Lang.UProperty_Constants.NFD_QUICK_CHECK) + 2); // 2=UNORM_NFD
	            case IBM.ICU.Lang.UProperty_Constants.LEAD_CANONICAL_COMBINING_CLASS:
	                return IBM.ICU.Impl.NormalizerImpl.GetFCD16(ch) >> 8;
	            case IBM.ICU.Lang.UProperty_Constants.TRAIL_CANONICAL_COMBINING_CLASS:
	                return IBM.ICU.Impl.NormalizerImpl.GetFCD16(ch) & 0xff;
	            case IBM.ICU.Lang.UProperty_Constants.GRAPHEME_CLUSTER_BREAK:
	                return (int) (PROPERTY_.GetAdditional(ch, 2) & GCB_MASK) >> GCB_SHIFT;
	            case IBM.ICU.Lang.UProperty_Constants.SENTENCE_BREAK:
	                return (int) (PROPERTY_.GetAdditional(ch, 2) & SB_MASK) >> SB_SHIFT;
	            case IBM.ICU.Lang.UProperty_Constants.WORD_BREAK:
	                return (int) (PROPERTY_.GetAdditional(ch, 2) & WB_MASK) >> WB_SHIFT;
	            default:
	
	                return 0; /* undefined */
	            }
	        } else if (type == IBM.ICU.Lang.UProperty_Constants.GENERAL_CATEGORY_MASK) {
	            return IBM.ICU.Impl.UCharacterProperty.GetMask(GetType(ch));
	        }
	        return 0; // undefined
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Returns a string version of the property value.
	    /// </summary>
	    ///
	    /// <param name="propertyEnum"></param>
	    /// <param name="codepoint"></param>
	    /// <param name="nameChoice"></param>
	    /// <returns>value as string</returns>
	    public static String GetStringPropertyValue(int propertyEnum,
	            int codepoint, int nameChoice) {
	        // TODO some of these are less efficient, since a string is forced!
	        if ((propertyEnum >= IBM.ICU.Lang.UProperty_Constants.BINARY_START && propertyEnum < IBM.ICU.Lang.UProperty_Constants.BINARY_LIMIT)
	                || (propertyEnum >= IBM.ICU.Lang.UProperty_Constants.INT_START && propertyEnum < IBM.ICU.Lang.UProperty_Constants.INT_LIMIT)) {
	            return GetPropertyValueName(propertyEnum,
	                    GetIntPropertyValue(codepoint, propertyEnum), nameChoice);
	        }
	        if (propertyEnum == IBM.ICU.Lang.UProperty_Constants.NUMERIC_VALUE) {
	            return GetUnicodeNumericValue(codepoint).ToString();
	        }
	        // otherwise must be string property
	        switch (propertyEnum) {
	        case IBM.ICU.Lang.UProperty_Constants.AGE:
	            return GetAge(codepoint).ToString();
	        case IBM.ICU.Lang.UProperty_Constants.ISO_COMMENT:
	            return GetISOComment(codepoint);
	        case IBM.ICU.Lang.UProperty_Constants.BIDI_MIRRORING_GLYPH:
	            return IBM.ICU.Text.UTF16.ValueOf(GetMirror(codepoint));
	        case IBM.ICU.Lang.UProperty_Constants.CASE_FOLDING:
	            return FoldCase(IBM.ICU.Text.UTF16.ValueOf(codepoint), true);
	        case IBM.ICU.Lang.UProperty_Constants.LOWERCASE_MAPPING:
	            return ToLowerCase(IBM.ICU.Text.UTF16.ValueOf(codepoint));
	        case IBM.ICU.Lang.UProperty_Constants.NAME:
	            return GetName(codepoint);
	        case IBM.ICU.Lang.UProperty_Constants.SIMPLE_CASE_FOLDING:
	            return IBM.ICU.Text.UTF16.ValueOf(FoldCase(codepoint, true));
	        case IBM.ICU.Lang.UProperty_Constants.SIMPLE_LOWERCASE_MAPPING:
	            return IBM.ICU.Text.UTF16.ValueOf(ToLowerCase(codepoint));
	        case IBM.ICU.Lang.UProperty_Constants.SIMPLE_TITLECASE_MAPPING:
	            return IBM.ICU.Text.UTF16.ValueOf(ToTitleCase(codepoint));
	        case IBM.ICU.Lang.UProperty_Constants.SIMPLE_UPPERCASE_MAPPING:
	            return IBM.ICU.Text.UTF16.ValueOf(ToUpperCase(codepoint));
	        case IBM.ICU.Lang.UProperty_Constants.TITLECASE_MAPPING:
	            return ToTitleCase(IBM.ICU.Text.UTF16.ValueOf(codepoint), null);
	        case IBM.ICU.Lang.UProperty_Constants.UNICODE_1_NAME:
	            return GetName1_0(codepoint);
	        case IBM.ICU.Lang.UProperty_Constants.UPPERCASE_MAPPING:
	            return ToUpperCase(IBM.ICU.Text.UTF16.ValueOf(codepoint));
	        }
	        throw new ArgumentException("Illegal Property Enum");
	    }
	
	    /// <summary>
	    /// Get the minimum value for an integer/binary Unicode property type. Can be
	    /// used together with UCharacter.getIntPropertyMaxValue(int) to allocate
	    /// arrays of com.ibm.icu.text.UnicodeSet or similar.
	    /// </summary>
	    ///
	    /// <param name="type">UProperty selector constant, identifies which binary propertyto check. Must be UProperty.BINARY_START &lt;= type &lt;UProperty.BINARY_LIMIT or UProperty.INT_START &lt;= type &lt;UProperty.INT_LIMIT.</param>
	    /// <returns>Minimum value returned by UCharacter.getIntPropertyValue(int) for
	    /// a Unicode property. 0 if the property selector 'type' is out of
	    /// range.</returns>
	    /// <seealso cref="T:IBM.ICU.Lang.UProperty"/>
	    /// <seealso cref="M:IBM.ICU.Lang.UCharacter.HasBinaryProperty(System.Int32, System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Lang.UCharacter.GetUnicodeVersion"/>
	    /// <seealso cref="M:IBM.ICU.Lang.UCharacter.GetIntPropertyMaxValue(System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Lang.UCharacter.GetIntPropertyValue(System.Int32, System.Int32)"/>
	    /// @stable ICU 2.4
	    public static int GetIntPropertyMinValue(int type) {
	
	        return 0; // undefined; and: all other properties have a minimum value
	        // of 0
	    }
	
	    /// <summary>
	    /// Get the maximum value for an integer/binary Unicode property. Can be used
	    /// together with UCharacter.getIntPropertyMinValue(int) to allocate arrays
	    /// of com.ibm.icu.text.UnicodeSet or similar. Examples for min/max values
	    /// (for Unicode 3.2):
	    /// <ul>
	    /// <li>UProperty.BIDI_CLASS: 0/18
	    /// (UCharacterDirection.LEFT_TO_RIGHT/UCharacterDirection.BOUNDARY_NEUTRAL)
	    /// <li>UProperty.SCRIPT: 0/45 (UScript.COMMON/UScript.TAGBANWA)
	    /// <li>UProperty.IDEOGRAPHIC: 0/1 (false/true)
	    /// </ul>
	    /// For undefined UProperty constant values, min/max values will be 0/-1.
	    /// </summary>
	    ///
	    /// <param name="type">UProperty selector constant, identifies which binary propertyto check. Must be UProperty.BINARY_START &lt;= type &lt;UProperty.BINARY_LIMIT or UProperty.INT_START &lt;= type &lt;UProperty.INT_LIMIT.</param>
	    /// <returns>Maximum value returned by u_getIntPropertyValue for a Unicode
	    /// property. &lt;= 0 if the property selector 'type' is out of
	    /// range.</returns>
	    /// <seealso cref="T:IBM.ICU.Lang.UProperty"/>
	    /// <seealso cref="M:IBM.ICU.Lang.UCharacter.HasBinaryProperty(System.Int32, System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Lang.UCharacter.GetUnicodeVersion"/>
	    /// <seealso cref="M:IBM.ICU.Lang.UCharacter.GetIntPropertyMaxValue(System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Lang.UCharacter.GetIntPropertyValue(System.Int32, System.Int32)"/>
	    /// @stable ICU 2.4
	    public static int GetIntPropertyMaxValue(int type) {
	        if (type < IBM.ICU.Lang.UProperty_Constants.BINARY_START) {
	            return -1; // undefined
	        } else if (type < IBM.ICU.Lang.UProperty_Constants.BINARY_LIMIT) {
	            return 1; // maximum TRUE for all binary properties
	        } else if (type < IBM.ICU.Lang.UProperty_Constants.INT_START) {
	            return -1; // undefined
	        } else if (type < IBM.ICU.Lang.UProperty_Constants.INT_LIMIT) {
	            switch (type) {
	            case IBM.ICU.Lang.UProperty_Constants.BIDI_CLASS:
	            case IBM.ICU.Lang.UProperty_Constants.JOINING_GROUP:
	            case IBM.ICU.Lang.UProperty_Constants.JOINING_TYPE:
	                return gBdp.GetMaxValue(type);
	            case IBM.ICU.Lang.UProperty_Constants.BLOCK:
	                return (PROPERTY_.GetMaxValues(0) & BLOCK_MASK_) >> BLOCK_SHIFT_;
	            case IBM.ICU.Lang.UProperty_Constants.CANONICAL_COMBINING_CLASS:
	            case IBM.ICU.Lang.UProperty_Constants.LEAD_CANONICAL_COMBINING_CLASS:
	            case IBM.ICU.Lang.UProperty_Constants.TRAIL_CANONICAL_COMBINING_CLASS:
	                return 0xff; // TODO do we need to be more precise,
	                             // getting the actual maximum?
	            case IBM.ICU.Lang.UProperty_Constants.DECOMPOSITION_TYPE:
	                return PROPERTY_.GetMaxValues(2) & DECOMPOSITION_TYPE_MASK_;
	            case IBM.ICU.Lang.UProperty_Constants.EAST_ASIAN_WIDTH:
	                return (PROPERTY_.GetMaxValues(0) & EAST_ASIAN_MASK_) >> EAST_ASIAN_SHIFT_;
	            case IBM.ICU.Lang.UProperty_Constants.GENERAL_CATEGORY:
	                return IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.CHAR_CATEGORY_COUNT - 1;
	            case IBM.ICU.Lang.UProperty_Constants.LINE_BREAK:
	                return (PROPERTY_.GetMaxValues(0) & LINE_BREAK_MASK_) >> LINE_BREAK_SHIFT_;
	            case IBM.ICU.Lang.UProperty_Constants.NUMERIC_TYPE:
	                return IBM.ICU.Lang.UCharacter.NumericType.COUNT - 1;
	            case IBM.ICU.Lang.UProperty_Constants.SCRIPT:
	                return PROPERTY_.GetMaxValues(0) & SCRIPT_MASK_;
	            case IBM.ICU.Lang.UProperty_Constants.HANGUL_SYLLABLE_TYPE:
	                return IBM.ICU.Lang.UCharacter.HangulSyllableType.COUNT - 1;
	            case IBM.ICU.Lang.UProperty_Constants.NFD_QUICK_CHECK:
	            case IBM.ICU.Lang.UProperty_Constants.NFKD_QUICK_CHECK:
	                return 1; // YES -- these are never "maybe", only "no" or "yes"
	            case IBM.ICU.Lang.UProperty_Constants.NFC_QUICK_CHECK:
	            case IBM.ICU.Lang.UProperty_Constants.NFKC_QUICK_CHECK:
	                return 2; // MAYBE
	            case IBM.ICU.Lang.UProperty_Constants.GRAPHEME_CLUSTER_BREAK:
	                return (PROPERTY_.GetMaxValues(2) & GCB_MASK) >> GCB_SHIFT;
	            case IBM.ICU.Lang.UProperty_Constants.SENTENCE_BREAK:
	                return (PROPERTY_.GetMaxValues(2) & SB_MASK) >> SB_SHIFT;
	            case IBM.ICU.Lang.UProperty_Constants.WORD_BREAK:
	                return (PROPERTY_.GetMaxValues(2) & WB_MASK) >> WB_SHIFT;
	            default:
	                return -1; // undefined
	            }
	
	        }
	        return -1; // undefined
	    }
	
	    /// <summary>
	    /// Provide the java.lang.Character forDigit API, for convenience.
	    /// </summary>
	    ///
	    /// @stable ICU 3.0
	    public static char ForDigit(int digit, int radix) {
            return ILOG.J2CsMapping.Util.Character.ForDigit(digit, radix);
	    }
	
	    // JDK 1.5 API coverage
	
	    /// <summary>
	    /// Cover the JDK 1.5 API, for convenience.
	    /// </summary>
	    ///
	    /// <seealso cref="null"/>
	    /// @stable ICU 3.0
	    public const char MIN_HIGH_SURROGATE = (char) (IBM.ICU.Text.UTF16.LEAD_SURROGATE_MIN_VALUE);
	
	    /// <summary>
	    /// Cover the JDK 1.5 API, for convenience.
	    /// </summary>
	    ///
	    /// <seealso cref="null"/>
	    /// @stable ICU 3.0
	    public const char MAX_HIGH_SURROGATE = (char) (IBM.ICU.Text.UTF16.LEAD_SURROGATE_MAX_VALUE);
	
	    /// <summary>
	    /// Cover the JDK 1.5 API, for convenience.
	    /// </summary>
	    ///
	    /// <seealso cref="null"/>
	    /// @stable ICU 3.0
	    public const char MIN_LOW_SURROGATE = (char) (IBM.ICU.Text.UTF16.TRAIL_SURROGATE_MIN_VALUE);
	
	    /// <summary>
	    /// Cover the JDK 1.5 API, for convenience.
	    /// </summary>
	    ///
	    /// <seealso cref="null"/>
	    /// @stable ICU 3.0
	    public const char MAX_LOW_SURROGATE = (char) (IBM.ICU.Text.UTF16.TRAIL_SURROGATE_MAX_VALUE);
	
	    /// <summary>
	    /// Cover the JDK 1.5 API, for convenience.
	    /// </summary>
	    ///
	    /// <seealso cref="null"/>
	    /// @stable ICU 3.0
	    public const char MIN_SURROGATE = (char) (IBM.ICU.Text.UTF16.SURROGATE_MIN_VALUE);
	
	    /// <summary>
	    /// Cover the JDK 1.5 API, for convenience.
	    /// </summary>
	    ///
	    /// <seealso cref="null"/>
	    /// @stable ICU 3.0
	    public const char MAX_SURROGATE = (char) (IBM.ICU.Text.UTF16.SURROGATE_MAX_VALUE);
	
	    /// <summary>
	    /// Cover the JDK 1.5 API, for convenience.
	    /// </summary>
	    ///
	    /// <seealso cref="null"/>
	    /// @stable ICU 3.0
	    public const int MIN_SUPPLEMENTARY_CODE_POINT = IBM.ICU.Text.UTF16.SUPPLEMENTARY_MIN_VALUE;
	
	    /// <summary>
	    /// Cover the JDK 1.5 API, for convenience.
	    /// </summary>
	    ///
	    /// <seealso cref="null"/>
	    /// @stable ICU 3.0
	    public const int MAX_CODE_POINT = IBM.ICU.Text.UTF16.CODEPOINT_MAX_VALUE;
	
	    /// <summary>
	    /// Cover the JDK 1.5 API, for convenience.
	    /// </summary>
	    ///
	    /// <seealso cref="null"/>
	    /// @stable ICU 3.0
	    public const int MIN_CODE_POINT = IBM.ICU.Text.UTF16.CODEPOINT_MIN_VALUE;
	
	    /// <summary>
	    /// Cover the JDK 1.5 API, for convenience.
	    /// </summary>
	    ///
	    /// <param name="cp">the code point to check</param>
	    /// <returns>true if cp is a valid code point</returns>
	    /// @stable ICU 3.0
	    public static bool IsValidCodePoint(int cp) {
	        return cp >= 0 && cp <= MAX_CODE_POINT;
	    }
	
	    /// <summary>
	    /// Cover the JDK 1.5 API, for convenience.
	    /// </summary>
	    ///
	    /// <param name="cp">the code point to check</param>
	    /// <returns>true if cp is a supplementary code point</returns>
	    /// @stable ICU 3.0
	    public static bool IsSupplementaryCodePoint(int cp) {
	        return cp >= IBM.ICU.Text.UTF16.SUPPLEMENTARY_MIN_VALUE
	                && cp <= IBM.ICU.Text.UTF16.CODEPOINT_MAX_VALUE;
	    }
	
	    /// <summary>
	    /// Cover the JDK 1.5 API, for convenience.
	    /// </summary>
	    ///
	    /// <param name="ch">the char to check</param>
	    /// <returns>true if ch is a high (lead) surrogate</returns>
	    /// @stable ICU 3.0
	    public static bool IsHighSurrogate(char ch) {
	        return ch >= MIN_HIGH_SURROGATE && ch <= MAX_HIGH_SURROGATE;
	    }
	
	    /// <summary>
	    /// Cover the JDK 1.5 API, for convenience.
	    /// </summary>
	    ///
	    /// <param name="ch">the char to check</param>
	    /// <returns>true if ch is a low (trail) surrogate</returns>
	    /// @stable ICU 3.0
	    public static bool IsLowSurrogate(char ch) {
	        return ch >= MIN_LOW_SURROGATE && ch <= MAX_LOW_SURROGATE;
	    }
	
	    /// <summary>
	    /// Cover the JDK 1.5 API, for convenience. Return true if the chars form a
	    /// valid surrogate pair.
	    /// </summary>
	    ///
	    /// <param name="high">the high (lead) char</param>
	    /// <param name="low">the low (trail) char</param>
	    /// <returns>true if high, low form a surrogate pair</returns>
	    /// @stable ICU 3.0
	    public static bool IsSurrogatePair(char high, char low) {
	        return IsHighSurrogate(high) && IsLowSurrogate(low);
	    }
	
	    /// <summary>
	    /// Cover the JDK 1.5 API, for convenience. Return the number of chars needed
	    /// to represent the code point. This does not check the code point for
	    /// validity.
	    /// </summary>
	    ///
	    /// <param name="cp">the code point to check</param>
	    /// <returns>the number of chars needed to represent the code point</returns>
	    /// <seealso cref="null"/>
	    /// @stable ICU 3.0
	    public static int CharCount(int cp) {
	        return IBM.ICU.Text.UTF16.GetCharCount(cp);
	    }
	
	    /// <summary>
	    /// Cover the JDK 1.5 API, for convenience. Return the code point represented
	    /// by the characters. This does not check the surrogate pair for validity.
	    /// </summary>
	    ///
	    /// <param name="high">the high (lead) surrogate</param>
	    /// <param name="low">the low (trail) surrogate</param>
	    /// <returns>the code point formed by the surrogate pair</returns>
	    /// @stable ICU 3.0
	    public static int ToCodePoint(char high, char low) {
	        return IBM.ICU.Impl.UCharacterProperty.GetRawSupplementary(high, low);
	    }
	
	    /// <summary>
	    /// Cover the JDK 1.5 API, for convenience. Return the code point at index. <br/>
	    /// <b>Note</b>: the semantics of this API is different from the related
	    /// UTF16 API. This examines only the characters at index and index+1.
	    /// </summary>
	    ///
	    /// <param name="seq">the characters to check</param>
	    /// <param name="index_0">the index of the first or only char forming the code point</param>
	    /// <returns>the code point at the index</returns>
	    /// @stable ICU 3.0
	    // #if defined(FOUNDATION10) || defined(J2SE13)
	    // ## public static final int codePointAt(String seq, int index) {
	    // ## char c1 = seq.charAt(index++);
	    // ## if (isHighSurrogate(c1)) {
	    // ## if (index < seq.length()) {
	    // ## char c2 = seq.charAt(index);
	    // ## if (isLowSurrogate(c2)) {
	    // ## return toCodePoint(c1, c2);
	    // ## }
	    // ## }
	    // ## }
	    // ## return c1;
	    // ## }
	    // ## public static final int codePointAt(StringBuffer seq, int index) {
	    // ## return codePointAt(seq.toString(), index);
	    // ## }
	    // #else
	    // #if defined(ECLIPSE_FRAGMENT)
	    // ## public static final int codePointAt(String seq, int index) {
	    // ## return codePointAt((CharSequence)seq, index);
	    // ## }
	    // ## public static final int codePointAt(StringBuffer seq, int index) {
	    // ## return codePointAt((CharSequence)seq, index);
	    // ## }
	    // #endif
	    public static int CodePointAt(String seq, int index_0) {
	        char c1 = seq[index_0++];
	        if (IsHighSurrogate(c1)) {
	            if (index_0 < seq.Length) {
	                char c2 = seq[index_0];
	                if (IsLowSurrogate(c2)) {
	                    return ToCodePoint(c1, c2);
	                }
	            }
	        }
	        return c1;
	    }
	
	    // #endif
	
	    /// <summary>
	    /// Cover the JDK 1.5 API, for convenience. Return the code point at index. <br/>
	    /// <b>Note</b>: the semantics of this API is different from the related
	    /// UTF16 API. This examines only the characters at index and index+1.
	    /// </summary>
	    ///
	    /// <param name="text">the characters to check</param>
	    /// <param name="index_0">the index of the first or only char forming the code point</param>
	    /// <returns>the code point at the index</returns>
	    /// @stable ICU 3.0
	    public static int CodePointAt(char[] text, int index_0) {
	        char c1 = text[index_0++];
	        if (IsHighSurrogate(c1)) {
	            if (index_0 < text.Length) {
	                char c2 = text[index_0];
	                if (IsLowSurrogate(c2)) {
	                    return ToCodePoint(c1, c2);
	                }
	            }
	        }
	        return c1;
	    }
	
	    /// <summary>
	    /// Cover the JDK 1.5 API, for convenience. Return the code point at index. <br/>
	    /// <b>Note</b>: the semantics of this API is different from the related
	    /// UTF16 API. This examines only the characters at index and index+1.
	    /// </summary>
	    ///
	    /// <param name="text">the characters to check</param>
	    /// <param name="index_0">the index of the first or only char forming the code point</param>
	    /// <param name="limit_1">the limit of the valid text</param>
	    /// <returns>the code point at the index</returns>
	    /// @stable ICU 3.0
	    public static int CodePointAt(char[] text, int index_0, int limit_1) {
	        if (index_0 >= limit_1 || limit_1 > text.Length) {
	            throw new IndexOutOfRangeException();
	        }
	        char c1 = text[index_0++];
	        if (IsHighSurrogate(c1)) {
	            if (index_0 < limit_1) {
	                char c2 = text[index_0];
	                if (IsLowSurrogate(c2)) {
	                    return ToCodePoint(c1, c2);
	                }
	            }
	        }
	        return c1;
	    }
	
	    /// <summary>
	    /// Cover the JDK 1.5 API, for convenience. Return the code point before
	    /// index. <br/>
	    /// <b>Note</b>: the semantics of this API is different from the related
	    /// UTF16 API. This examines only the characters at index-1 and index-2.
	    /// </summary>
	    ///
	    /// <param name="seq">the characters to check</param>
	    /// <param name="index_0">the index after the last or only char forming the code point</param>
	    /// <returns>the code point before the index</returns>
	    /// @stable ICU 3.0
	    // #if defined(FOUNDATION10) || defined(J2SE13)
	    // ## public static final int codePointBefore(String seq, int index) {
	    // ## char c2 = seq.charAt(--index);
	    // ## if (isLowSurrogate(c2)) {
	    // ## if (index > 0) {
	    // ## char c1 = seq.charAt(--index);
	    // ## if (isHighSurrogate(c1)) {
	    // ## return toCodePoint(c1, c2);
	    // ## }
	    // ## }
	    // ## }
	    // ## return c2;
	    // ## }
	    // ## public static final int codePointBefore(StringBuffer seq, int index) {
	    // ## return codePointBefore(seq.toString(), index);
	    // ## }
	    // #else
	    // #if defined(ECLIPSE_FRAGMENT)
	    // ## public static final int codePointBefore(String seq, int index) {
	    // ## return codePointBefore((CharSequence)seq, index);
	    // ## }
	    // ## public static final int codePointBefore(StringBuffer seq, int index) {
	    // ## return codePointBefore((CharSequence)seq, index);
	    // ## }
	    // #endif
	    public static int CodePointBefore(String seq, int index_0) {
	        char c2 = seq[--index_0];
	        if (IsLowSurrogate(c2)) {
	            if (index_0 > 0) {
	                char c1 = seq[--index_0];
	                if (IsHighSurrogate(c1)) {
	                    return ToCodePoint(c1, c2);
	                }
	            }
	        }
	        return c2;
	    }
	
	    // #endif
	
	    /// <summary>
	    /// Cover the JDK 1.5 API, for convenience. Return the code point before
	    /// index. <br/>
	    /// <b>Note</b>: the semantics of this API is different from the related
	    /// UTF16 API. This examines only the characters at index-1 and index-2.
	    /// </summary>
	    ///
	    /// <param name="text">the characters to check</param>
	    /// <param name="index_0">the index after the last or only char forming the code point</param>
	    /// <returns>the code point before the index</returns>
	    /// @stable ICU 3.0
	    public static int CodePointBefore(char[] text, int index_0) {
	        char c2 = text[--index_0];
	        if (IsLowSurrogate(c2)) {
	            if (index_0 > 0) {
	                char c1 = text[--index_0];
	                if (IsHighSurrogate(c1)) {
	                    return ToCodePoint(c1, c2);
	                }
	            }
	        }
	        return c2;
	    }
	
	    /// <summary>
	    /// Cover the JDK 1.5 API, for convenience. Return the code point before
	    /// index. <br/>
	    /// <b>Note</b>: the semantics of this API is different from the related
	    /// UTF16 API. This examines only the characters at index-1 and index-2.
	    /// </summary>
	    ///
	    /// <param name="text">the characters to check</param>
	    /// <param name="index_0">the index after the last or only char forming the code point</param>
	    /// <param name="limit_1">the start of the valid text</param>
	    /// <returns>the code point before the index</returns>
	    /// @stable ICU 3.0
	    public static int CodePointBefore(char[] text, int index_0, int limit_1) {
	        if (index_0 <= limit_1 || limit_1 < 0) {
	            throw new IndexOutOfRangeException();
	        }
	        char c2 = text[--index_0];
	        if (IsLowSurrogate(c2)) {
	            if (index_0 > limit_1) {
	                char c1 = text[--index_0];
	                if (IsHighSurrogate(c1)) {
	                    return ToCodePoint(c1, c2);
	                }
	            }
	        }
	        return c2;
	    }
	
	    /// <summary>
	    /// Cover the JDK 1.5 API, for convenience. Writes the chars representing the
	    /// code point into the destination at the given index.
	    /// </summary>
	    ///
	    /// <param name="cp">the code point to convert</param>
	    /// <param name="dst">the destination array into which to put the char(s)representing the code point</param>
	    /// <param name="dstIndex">the index at which to put the first (or only) char</param>
	    /// <returns>the count of the number of chars written (1 or 2)</returns>
	    /// <exception cref="IllegalArgumentException">if cp is not a valid code point</exception>
	    /// @stable ICU 3.0
	    public static int ToChars(int cp, char[] dst, int dstIndex) {
	        if (cp >= 0) {
	            if (cp < MIN_SUPPLEMENTARY_CODE_POINT) {
	                dst[dstIndex] = (char) cp;
	                return 1;
	            }
	            if (cp <= MAX_CODE_POINT) {
	                dst[dstIndex] = IBM.ICU.Text.UTF16.GetLeadSurrogate(cp);
	                dst[dstIndex + 1] = IBM.ICU.Text.UTF16.GetTrailSurrogate(cp);
	                return 2;
	            }
	        }
	        throw new ArgumentException();
	    }
	
	    /// <summary>
	    /// Cover the JDK 1.5 API, for convenience. Returns a char array representing
	    /// the code point.
	    /// </summary>
	    ///
	    /// <param name="cp">the code point to convert</param>
	    /// <returns>an array containing the char(s) representing the code point</returns>
	    /// <exception cref="IllegalArgumentException">if cp is not a valid code point</exception>
	    /// @stable ICU 3.0
	    public static char[] ToChars(int cp) {
	        if (cp >= 0) {
	            if (cp < MIN_SUPPLEMENTARY_CODE_POINT) {
	                return new char[] { (char) cp };
	            }
	            if (cp <= MAX_CODE_POINT) {
	                return new char[] { IBM.ICU.Text.UTF16.GetLeadSurrogate(cp),
	                        IBM.ICU.Text.UTF16.GetTrailSurrogate(cp) };
	            }
	        }
	        throw new ArgumentException();
	    }
	
	    /// <summary>
	    /// Cover the JDK API, for convenience. Return a byte representing the
	    /// directionality of the character. <br/>
	    /// <b>Note</b>: Unlike the JDK, this returns DIRECTIONALITY_LEFT_TO_RIGHT
	    /// for undefined or out-of-bounds characters. <br/>
	    /// <b>Note</b>: The return value must be tested using the constants defined
	    /// in <see cref="T:IBM.ICU.Lang.ECharacterDirection"/> since the values are
	    /// different from the ones defined by <c>java.lang.Character</c>.
	    /// </summary>
	    ///
	    /// <param name="cp">the code point to check</param>
	    /// <returns>the directionality of the code point</returns>
	    /// <seealso cref="M:IBM.ICU.Lang.UCharacter.GetDirection(System.Int32)"/>
	    /// @stable ICU 3.0
	    public static byte GetDirectionality(int cp) {
	        return (byte) GetDirection(cp);
	    }
	
	    /// <summary>
	    /// Cover the JDK API, for convenience. Count the number of code points in
	    /// the range of text.
	    /// </summary>
	    ///
	    /// <param name="text">the characters to check</param>
	    /// <param name="start">the start of the range</param>
	    /// <param name="limit_0">the limit of the range</param>
	    /// <returns>the number of code points in the range</returns>
	    /// @stable ICU 3.0
	    // #if defined(FOUNDATION10) || defined(J2SE13)
	    // ## public static int codePointCount(String text, int start, int limit) {
	    // ## if (start < 0 || limit < start || limit > text.length()) {
	    // ## throw new IndexOutOfBoundsException("start (" + start +
	    // ## ") or limit (" + limit +
	    // ## ") invalid or out of range 0, " + text.length());
	    // ## }
	    // ##
	    // ## int len = limit - start;
	    // ## while (limit > start) {
	    // ## char ch = text.charAt(--limit);
	    // ## while (ch >= MIN_LOW_SURROGATE && ch <= MAX_LOW_SURROGATE && limit >
	    // start) {
	    // ## ch = text.charAt(--limit);
	    // ## if (ch >= MIN_HIGH_SURROGATE && ch <= MAX_HIGH_SURROGATE) {
	    // ## --len;
	    // ## break;
	    // ## }
	    // ## }
	    // ## }
	    // ## return len;
	    // ## }
	    // ## public static int codePointCount(StringBuffer text, int start, int
	    // limit) {
	    // ## return codePointCount(text.toString(), start, limit);
	    // ## }
	    // #else
	    // #if defined(ECLIPSE_FRAGMENT)
	    // ## public static int codePointCount(String text, int start, int limit) {
	    // ## return codePointCount((CharSequence)text, start, limit);
	    // ## }
	    // ## public static int codePointCount(StringBuffer text, int start, int
	    // limit) {
	    // ## return codePointCount((CharSequence)text, start, limit);
	    // ## }
	    // #endif
	    public static int CodePointCount(String text, int start, int limit_0) {
	        if (start < 0 || limit_0 < start || limit_0 > text.Length) {
	            throw new IndexOutOfRangeException("start (" + start
	                                + ") or limit (" + limit_0 + ") invalid or out of range 0, "
	                                + text.Length.ToString());
	        }
	
	        int len = limit_0 - start;
	        while (limit_0 > start) {
	            char ch = text[--limit_0];
	            while (ch >= MIN_LOW_SURROGATE && ch <= MAX_LOW_SURROGATE
	                    && limit_0 > start) {
	                ch = text[--limit_0];
	                if (ch >= MIN_HIGH_SURROGATE && ch <= MAX_HIGH_SURROGATE) {
	                    --len;
	                    break;
	                }
	            }
	        }
	        return len;
	    }
	
	    // #endif
	
	    /// <summary>
	    /// Cover the JDK API, for convenience. Count the number of code points in
	    /// the range of text.
	    /// </summary>
	    ///
	    /// <param name="text">the characters to check</param>
	    /// <param name="start">the start of the range</param>
	    /// <param name="limit_0">the limit of the range</param>
	    /// <returns>the number of code points in the range</returns>
	    /// @stable ICU 3.0
	    public static int CodePointCount(char[] text, int start, int limit_0) {
	        if (start < 0 || limit_0 < start || limit_0 > text.Length) {
	            throw new IndexOutOfRangeException("start (" + start
	                                + ") or limit (" + limit_0 + ") invalid or out of range 0, "
	                                + text.Length.ToString());
	        }
	
	        int len = limit_0 - start;
	        while (limit_0 > start) {
	            char ch = text[--limit_0];
	            while (ch >= MIN_LOW_SURROGATE && ch <= MAX_LOW_SURROGATE
	                    && limit_0 > start) {
	                ch = text[--limit_0];
	                if (ch >= MIN_HIGH_SURROGATE && ch <= MAX_HIGH_SURROGATE) {
	                    --len;
	                    break;
	                }
	            }
	        }
	        return len;
	    }
	
	    /// <summary>
	    /// Cover the JDK API, for convenience. Adjust the char index by a code point
	    /// offset.
	    /// </summary>
	    ///
	    /// <param name="text">the characters to check</param>
	    /// <param name="index_0">the index to adjust</param>
	    /// <param name="codePointOffset">the number of code points by which to offset the index</param>
	    /// <returns>the adjusted index</returns>
	    /// @stable ICU 3.0
	    // #if defined(FOUNDATION10) || defined(J2SE13)
	    // ## public static int offsetByCodePoints(String text, int index, int
	    // codePointOffset) {
	    // ## if (index < 0 || index > text.length()) {
	    // ## throw new IndexOutOfBoundsException("index ( " + index +
	    // ## ") out of range 0, " + text.length());
	    // ## }
	    // ##
	    // ## if (codePointOffset < 0) {
	    // ## while (++codePointOffset <= 0) {
	    // ## char ch = text.charAt(--index);
	    // ## while (ch >= MIN_LOW_SURROGATE && ch <= MAX_LOW_SURROGATE && index >
	    // 0) {
	    // ## ch = text.charAt(--index);
	    // ## if (ch < MIN_HIGH_SURROGATE || ch > MAX_HIGH_SURROGATE) {
	    // ## if (++codePointOffset > 0) {
	    // ## return index+1;
	    // ## }
	    // ## }
	    // ## }
	    // ## }
	    // ## } else {
	    // ## int limit = text.length();
	    // ## while (--codePointOffset >= 0) {
	    // ## char ch = text.charAt(index++);
	    // ## while (ch >= MIN_HIGH_SURROGATE && ch <= MAX_HIGH_SURROGATE && index <
	    // limit) {
	    // ## ch = text.charAt(index++);
	    // ## if (ch < MIN_LOW_SURROGATE || ch > MAX_LOW_SURROGATE) {
	    // ## if (--codePointOffset < 0) {
	    // ## return index-1;
	    // ## }
	    // ## }
	    // ## }
	    // ## }
	    // ## }
	    // ##
	    // ## return index;
	    // ## }
	    // ## public static int offsetByCodePoints(StringBuffer text, int index, int
	    // codePointOffset) {
	    // ## return offsetByCodePoints(text.toString(), index, codePointOffset);
	    // ## }
	    // #else
	    // #if defined(ECLIPSE_FRAGMENT)
	    // ## public static int offsetByCodePoints(String text, int index, int
	    // codePointOffset) {
	    // ## return offsetByCodePoints((CharSequence)text, index, codePointOffset);
	    // ## }
	    // ## public static int offsetByCodePoints(StringBuffer text, int index, int
	    // codePointOffset) {
	    // ## return offsetByCodePoints((CharSequence)text, index, codePointOffset);
	    // ## }
	    // #endif
	    public static int OffsetByCodePoints(String text, int index_0,
	            int codePointOffset) {
	        if (index_0 < 0 || index_0 > text.Length) {
	            throw new IndexOutOfRangeException("index ( " + index_0
	                                + ") out of range 0, " + text.Length.ToString());
	        }
	
	        if (codePointOffset < 0) {
	            while (++codePointOffset <= 0) {
	                char ch = text[--index_0];
	                while (ch >= MIN_LOW_SURROGATE && ch <= MAX_LOW_SURROGATE
	                        && index_0 > 0) {
	                    ch = text[--index_0];
	                    if (ch < MIN_HIGH_SURROGATE || ch > MAX_HIGH_SURROGATE) {
	                        if (++codePointOffset > 0) {
	                            return index_0 + 1;
	                        }
	                    }
	                }
	            }
	        } else {
	            int limit_1 = text.Length;
	            while (--codePointOffset >= 0) {
	                char ch_2 = text[index_0++];
	                while (ch_2 >= MIN_HIGH_SURROGATE && ch_2 <= MAX_HIGH_SURROGATE
	                        && index_0 < limit_1) {
	                    ch_2 = text[index_0++];
	                    if (ch_2 < MIN_LOW_SURROGATE || ch_2 > MAX_LOW_SURROGATE) {
	                        if (--codePointOffset < 0) {
	                            return index_0 - 1;
	                        }
	                    }
	                }
	            }
	        }
	
	        return index_0;
	    }
	
	    // #endif
	
	    /// <summary>
	    /// Cover the JDK API, for convenience. Adjust the char index by a code point
	    /// offset.
	    /// </summary>
	    ///
	    /// <param name="text">the characters to check</param>
	    /// <param name="start">the start of the range to check</param>
	    /// <param name="count">the length of the range to check</param>
	    /// <param name="index_0">the index to adjust</param>
	    /// <param name="codePointOffset">the number of code points by which to offset the index</param>
	    /// <returns>the adjusted index</returns>
	    /// @stable ICU 3.0
	    public static int OffsetByCodePoints(char[] text, int start, int count,
	            int index_0, int codePointOffset) {
	        int limit_1 = start + count;
	        if (start < 0 || limit_1 < start || limit_1 > text.Length || index_0 < start
	                || index_0 > limit_1) {
	            throw new IndexOutOfRangeException("index ( " + index_0
	                                + ") out of range " + start + ", " + limit_1
	                                + " in array 0, " + text.Length.ToString());
	        }
	
	        if (codePointOffset < 0) {
	            while (++codePointOffset <= 0) {
	                char ch = text[--index_0];
	                if (index_0 < start) {
	                    throw new IndexOutOfRangeException("index ( " + index_0
	                                                + ") < start (" + start + ")".ToString());
	                }
	                while (ch >= MIN_LOW_SURROGATE && ch <= MAX_LOW_SURROGATE
	                        && index_0 > start) {
	                    ch = text[--index_0];
	                    if (ch < MIN_HIGH_SURROGATE || ch > MAX_HIGH_SURROGATE) {
	                        if (++codePointOffset > 0) {
	                            return index_0 + 1;
	                        }
	                    }
	                }
	            }
	        } else {
	            while (--codePointOffset >= 0) {
	                char ch_2 = text[index_0++];
	                if (index_0 > limit_1) {
	                    throw new IndexOutOfRangeException("index ( " + index_0
	                                                + ") > limit (" + limit_1 + ")".ToString());
	                }
	                while (ch_2 >= MIN_HIGH_SURROGATE && ch_2 <= MAX_HIGH_SURROGATE
	                        && index_0 < limit_1) {
	                    ch_2 = text[index_0++];
	                    if (ch_2 < MIN_LOW_SURROGATE || ch_2 > MAX_LOW_SURROGATE) {
	                        if (--codePointOffset < 0) {
	                            return index_0 - 1;
	                        }
	                    }
	                }
	            }
	        }
	
	        return index_0;
	    }
	
	    // protected data members --------------------------------------------
	
	    /// <summary>
	    /// Database storing the sets of character name
	    /// </summary>
	    ///
	    static internal UCharacterName NAME_ = null;
	
	    /// <summary>
	    /// Singleton object encapsulating the imported pnames.icu property aliases
	    /// </summary>
	    ///
	    static internal UPropertyAliases PNAMES_ = null;
	
	    /// <summary>
	    /// Database storing the sets of character property
	    /// </summary>
	    ///
	    private static readonly UCharacterProperty PROPERTY_;
	
	    /// <summary>
	    /// For optimization
	    /// </summary>
	    ///
	    private static readonly char[] PROPERTY_TRIE_INDEX_;
	
	    private static readonly char[] PROPERTY_TRIE_DATA_;
	
	    private static readonly int PROPERTY_INITIAL_VALUE_;
	
	    private static readonly UCaseProps gCsp;
	
	    private static readonly UBiDiProps gBdp;
	
	    /// <summary>
	    /// To get the last character out from a data type
	    /// </summary>
	    ///
	    private const int LAST_CHAR_MASK_ = 0xFFFF;
	
	    // /**
	    // * To get the last byte out from a data type
	    // */
	    // private static final int LAST_BYTE_MASK_ = 0xFF;
	    //
	    // /**
	    // * Shift 16 bits
	    // */
	    // private static final int SHIFT_16_ = 16;
	    //
	    // /**
	    // * Shift 24 bits
	    // */
	    // private static final int SHIFT_24_ = 24;
	    //
	    // /**
	    // * Decimal radix
	    // */
	    // private static final int DECIMAL_RADIX_ = 10;
	
	    /// <summary>
	    /// No break space code point
	    /// </summary>
	    ///
	    private const int NO_BREAK_SPACE_ = 0xA0;
	
	    /// <summary>
	    /// Narrow no break space code point
	    /// </summary>
	    ///
	    private const int NARROW_NO_BREAK_SPACE_ = 0x202F;
	
	    /// <summary>
	    /// Zero width no break space code point
	    /// </summary>
	    ///
	    private const int ZERO_WIDTH_NO_BREAK_SPACE_ = 0xFEFF;
	
	    /// <summary>
	    /// Ideographic number zero code point
	    /// </summary>
	    ///
	    private const int IDEOGRAPHIC_NUMBER_ZERO_ = 0x3007;
	
	    /// <summary>
	    /// CJK Ideograph, First code point
	    /// </summary>
	    ///
	    private const int CJK_IDEOGRAPH_FIRST_ = 0x4e00;
	
	    /// <summary>
	    /// CJK Ideograph, Second code point
	    /// </summary>
	    ///
	    private const int CJK_IDEOGRAPH_SECOND_ = 0x4e8c;
	
	    /// <summary>
	    /// CJK Ideograph, Third code point
	    /// </summary>
	    ///
	    private const int CJK_IDEOGRAPH_THIRD_ = 0x4e09;
	
	    /// <summary>
	    /// CJK Ideograph, Fourth code point
	    /// </summary>
	    ///
	    private const int CJK_IDEOGRAPH_FOURTH_ = 0x56d8;
	
	    /// <summary>
	    /// CJK Ideograph, FIFTH code point
	    /// </summary>
	    ///
	    private const int CJK_IDEOGRAPH_FIFTH_ = 0x4e94;
	
	    /// <summary>
	    /// CJK Ideograph, Sixth code point
	    /// </summary>
	    ///
	    private const int CJK_IDEOGRAPH_SIXTH_ = 0x516d;
	
	    /// <summary>
	    /// CJK Ideograph, Seventh code point
	    /// </summary>
	    ///
	    private const int CJK_IDEOGRAPH_SEVENTH_ = 0x4e03;
	
	    /// <summary>
	    /// CJK Ideograph, Eighth code point
	    /// </summary>
	    ///
	    private const int CJK_IDEOGRAPH_EIGHTH_ = 0x516b;
	
	    /// <summary>
	    /// CJK Ideograph, Nineth code point
	    /// </summary>
	    ///
	    private const int CJK_IDEOGRAPH_NINETH_ = 0x4e5d;
	
	    /// <summary>
	    /// Application Program command code point
	    /// </summary>
	    ///
	    private const int APPLICATION_PROGRAM_COMMAND_ = 0x009F;
	
	    /// <summary>
	    /// Unit separator code point
	    /// </summary>
	    ///
	    private const int UNIT_SEPARATOR_ = 0x001F;
	
	    /// <summary>
	    /// Delete code point
	    /// </summary>
	    ///
	    private const int DELETE_ = 0x007F;
	
	    /*
	     * ISO control character first range upper limit 0x0 - 0x1F
	     */
	    // private static final int ISO_CONTROL_FIRST_RANGE_MAX_ = 0x1F;
	    /// <summary>
	    /// Shift to get numeric type
	    /// </summary>
	    ///
	    private const int NUMERIC_TYPE_SHIFT_ = 5;
	
	    /// <summary>
	    /// Mask to get numeric type
	    /// </summary>
	    ///
	    private const int NUMERIC_TYPE_MASK_ = 0x7 << NUMERIC_TYPE_SHIFT_;
	
	    /* encoding of fractional and large numbers */
	    // private static final int MAX_SMALL_NUMBER=0xff;
	
	    private const int FRACTION_NUM_SHIFT = 3; /* numerator: bits 7..3 */
	
	    private const int FRACTION_DEN_MASK = 7; /* denominator: bits 2..0 */
	
	    // private static final int FRACTION_MAX_NUM=31;
	    private const int FRACTION_DEN_OFFSET = 2; /*
	                                                       * denominator values are
	                                                       * 2..9
	                                                       */
	
	    // private static final int FRACTION_MIN_DEN=FRACTION_DEN_OFFSET;
	    // private static final int
	    // FRACTION_MAX_DEN=FRACTION_MIN_DEN+FRACTION_DEN_MASK;
	
	    private const int LARGE_MANT_SHIFT = 4; /* mantissa: bits 7..4 */
	
	    private const int LARGE_EXP_MASK = 0xf; /* exponent: bits 3..0 */
	
	    private const int LARGE_EXP_OFFSET = 2; /* regular exponents 2..17 */
	
	    private const int LARGE_EXP_OFFSET_EXTRA = 18; /*
	                                                           * extra large
	                                                           * exponents 18..33
	                                                           */
	
	    // private static final int LARGE_MIN_EXP=LARGE_EXP_OFFSET;
	    // private static final int LARGE_MAX_EXP=LARGE_MIN_EXP+LARGE_EXP_MASK;
	    // private static final int
	    // LARGE_MAX_EXP_EXTRA=LARGE_EXP_OFFSET_EXTRA+LARGE_EXP_MASK;
	
	    /// <summary>
	    /// Han digit characters
	    /// </summary>
	    ///
	    private const int CJK_IDEOGRAPH_COMPLEX_ZERO_ = 0x96f6;
	
	    private const int CJK_IDEOGRAPH_COMPLEX_ONE_ = 0x58f9;
	
	    private const int CJK_IDEOGRAPH_COMPLEX_TWO_ = 0x8cb3;
	
	    private const int CJK_IDEOGRAPH_COMPLEX_THREE_ = 0x53c3;
	
	    private const int CJK_IDEOGRAPH_COMPLEX_FOUR_ = 0x8086;
	
	    private const int CJK_IDEOGRAPH_COMPLEX_FIVE_ = 0x4f0d;
	
	    private const int CJK_IDEOGRAPH_COMPLEX_SIX_ = 0x9678;
	
	    private const int CJK_IDEOGRAPH_COMPLEX_SEVEN_ = 0x67d2;
	
	    private const int CJK_IDEOGRAPH_COMPLEX_EIGHT_ = 0x634c;
	
	    private const int CJK_IDEOGRAPH_COMPLEX_NINE_ = 0x7396;
	
	    private const int CJK_IDEOGRAPH_TEN_ = 0x5341;
	
	    private const int CJK_IDEOGRAPH_COMPLEX_TEN_ = 0x62fe;
	
	    private const int CJK_IDEOGRAPH_HUNDRED_ = 0x767e;
	
	    private const int CJK_IDEOGRAPH_COMPLEX_HUNDRED_ = 0x4f70;
	
	    private const int CJK_IDEOGRAPH_THOUSAND_ = 0x5343;
	
	    private const int CJK_IDEOGRAPH_COMPLEX_THOUSAND_ = 0x4edf;
	
	    private const int CJK_IDEOGRAPH_TEN_THOUSAND_ = 0x824c;
	
	    private const int CJK_IDEOGRAPH_HUNDRED_MILLION_ = 0x5104;
	
	    // /**
	    // * Zero Width Non Joiner.
	    // * Equivalent to icu4c ZWNJ.
	    // */
	    // private static final int ZERO_WIDTH_NON_JOINER_ = 0x200c;
	    // /**
	    // * Zero Width Joiner
	    // * Equivalent to icu4c ZWJ.
	    // */
	    // private static final int ZERO_WIDTH_JOINER_ = 0x200d;
	
	    /*
	     * Properties in vector word 2 Bits 31..24 More binary properties (see
	     * UCharacterProperty) 23..19 reserved 18..14 Sentence Break 13..10 Word
	     * Break 9.. 5 Grapheme Cluster Break 4.. 0 Decomposition Type
	     */
	    private const int SB_MASK = 0x0007c000;
	
	    private const int SB_SHIFT = 14;
	
	    private const int WB_MASK = 0x00003c00;
	
	    private const int WB_SHIFT = 10;
	
	    private const int GCB_MASK = 0x000003e0;
	
	    private const int GCB_SHIFT = 5;
	
	    /// <summary>
	    /// Integer properties mask for decomposition type. Equivalent to icu4c
	    /// UPROPS_DT_MASK.
	    /// </summary>
	    ///
	    private const int DECOMPOSITION_TYPE_MASK_ = 0x0000001f;
	
	    /*
	     * Properties in vector word 0 Bits 31..24 DerivedAge version major/minor
	     * one nibble each (see UCharacterProperty) 23..18 Line Break 17..15 East
	     * Asian Width 14.. 7 UBlockCode 6.. 0 UScriptCode
	     */
	
	    /// <summary>
	    /// Integer properties mask and shift values for East Asian cell width.
	    /// Equivalent to icu4c UPROPS_EA_MASK
	    /// </summary>
	    ///
	    private const int EAST_ASIAN_MASK_ = 0x00038000;
	
	    /// <summary>
	    /// Integer properties mask and shift values for East Asian cell width.
	    /// Equivalent to icu4c UPROPS_EA_SHIFT
	    /// </summary>
	    ///
	    private const int EAST_ASIAN_SHIFT_ = 15;
	
	    /// <summary>
	    /// Integer properties mask and shift values for line breaks. Equivalent to
	    /// icu4c UPROPS_LB_MASK
	    /// </summary>
	    ///
	    private const int LINE_BREAK_MASK_ = 0x00FC0000;
	
	    /// <summary>
	    /// Integer properties mask and shift values for line breaks. Equivalent to
	    /// icu4c UPROPS_LB_SHIFT
	    /// </summary>
	    ///
	    private const int LINE_BREAK_SHIFT_ = 18;
	
	    /// <summary>
	    /// Integer properties mask and shift values for blocks. Equivalent to icu4c
	    /// UPROPS_BLOCK_MASK
	    /// </summary>
	    ///
	    private const int BLOCK_MASK_ = 0x00007f80;
	
	    /// <summary>
	    /// Integer properties mask and shift values for blocks. Equivalent to icu4c
	    /// UPROPS_BLOCK_SHIFT
	    /// </summary>
	    ///
	    private const int BLOCK_SHIFT_ = 7;
	
	    /// <summary>
	    /// Integer properties mask and shift values for scripts. Equivalent to icu4c
	    /// UPROPS_SHIFT_MASK
	    /// </summary>
	    ///
	    private const int SCRIPT_MASK_ = 0x0000007f;
	
	    // private constructor -----------------------------------------------
	    // /CLOVER:OFF
	    /// <summary>
	    /// Private constructor to prevent instantiation
	    /// </summary>
	    ///
	    private UCharacter() {
	    }
	
	    // /CLOVER:ON
	    // private methods ---------------------------------------------------
	
	    /// <summary>
	    /// Getting the digit values of characters like 'A' - 'Z', normal, half-width
	    /// and full-width. This method assumes that the other digit characters are
	    /// checked by the calling method.
	    /// </summary>
	    ///
	    /// <param name="ch">character to test</param>
	    /// <returns>-1 if ch is not a character of the form 'A' - 'Z', otherwise its
	    /// corresponding digit will be returned.</returns>
	    private static int GetEuropeanDigit(int ch) {
	        if ((ch > 0x7a && ch < 0xff21) || ch < 0x41 || (ch > 0x5a && ch < 0x61)
	                || ch > 0xff5a || (ch > 0xff31 && ch < 0xff41)) {
	            return -1;
	        }
	        if (ch <= 0x7a) {
	            // ch >= 0x41 or ch < 0x61
	            return ch + 10 - ((ch <= 0x5a) ? 0x41 : 0x61);
	        }
	        // ch >= 0xff21
	        if (ch <= 0xff3a) {
	            return ch + 10 - 0xff21;
	        }
	        // ch >= 0xff41 && ch <= 0xff5a
	        return ch + 10 - 0xff41;
	    }
	
	    /// <summary>
	    /// Gets the numeric type of the property argument
	    /// </summary>
	    ///
	    /// <param name="props">32 bit property</param>
	    /// <returns>the numeric type</returns>
	    private static int GetNumericType(int props) {
	        return (props & NUMERIC_TYPE_MASK_) >> NUMERIC_TYPE_SHIFT_;
	    }
	
	    /// <summary>
	    /// Gets the property value at the index. This is optimized. Note this is
	    /// alittle different from CharTrie the index m_trieData_ is never negative.
	    /// This is a duplicate of UCharacterProperty.getProperty. For optimization
	    /// purposes, this method calls the trie data directly instead of through
	    /// UCharacterProperty.getProperty.
	    /// </summary>
	    ///
	    /// <param name="ch">code point whose property value is to be retrieved</param>
	    /// <returns>property value of code point</returns>
	    /// @stable ICU 2.6
	    private static int GetProperty(int ch) {
	        if (ch < IBM.ICU.Text.UTF16.LEAD_SURROGATE_MIN_VALUE
	                || (ch > IBM.ICU.Text.UTF16.LEAD_SURROGATE_MAX_VALUE && ch < IBM.ICU.Text.UTF16.SUPPLEMENTARY_MIN_VALUE)) {
	            // BMP codepoint 0000..D7FF or DC00..FFFF
	            try { // using try for ch < 0 is faster than using an if statement
	                return PROPERTY_TRIE_DATA_[(PROPERTY_TRIE_INDEX_[ch >> 5] << 2)
	                        + (ch & 0x1f)];
	            } catch (IndexOutOfRangeException e) {
	                return PROPERTY_INITIAL_VALUE_;
	            }
	        }
	        if (ch <= IBM.ICU.Text.UTF16.LEAD_SURROGATE_MAX_VALUE) {
	            // lead surrogate D800..DBFF
	            return PROPERTY_TRIE_DATA_[(PROPERTY_TRIE_INDEX_[(0x2800 >> 5)
	                    + (ch >> 5)] << 2)
	                    + (ch & 0x1f)];
	        }
	        // for optimization
	        if (ch <= IBM.ICU.Text.UTF16.CODEPOINT_MAX_VALUE) {
	            // supplementary code point 10000..10FFFF
	            // look at the construction of supplementary characters
	            // trail forms the ends of it.
	            return PROPERTY_.m_trie_.GetSurrogateValue(
	                    IBM.ICU.Text.UTF16.GetLeadSurrogate(ch), (char) (ch & 0x3ff));
	        }
	        // return m_dataOffset_ if there is an error, in this case we return
	        // the default value: m_initialValue_
	        // we cannot assume that m_initialValue_ is at offset 0
	        // this is for optimization.
	        return PROPERTY_INITIAL_VALUE_;
	    }
	
	    static UCharacter() {
	            try {
	                PNAMES_ = new UPropertyAliases();
	                NAME_ = IBM.ICU.Impl.UCharacterName.GetInstance();
	            } catch (IOException e) {
	                throw new MissingManifestResourceException(e.Message);
	            }
	            try {
	                PROPERTY_ = IBM.ICU.Impl.UCharacterProperty.GetInstance();
	                PROPERTY_TRIE_INDEX_ = PROPERTY_.m_trieIndex_;
	                PROPERTY_TRIE_DATA_ = PROPERTY_.m_trieData_;
	                PROPERTY_INITIAL_VALUE_ = PROPERTY_.m_trieInitialValue_;
	            } catch (Exception e) {
	                throw new MissingManifestResourceException(e.Message);
	            }
	            UCaseProps csp;
	            try {
	                csp = IBM.ICU.Impl.UCaseProps.GetSingleton();
	            } catch (IOException e) {
	                csp = IBM.ICU.Impl.UCaseProps.GetDummy();
	            }
	            gCsp = csp;
	            UBiDiProps bdp;
	            try {
	                bdp = IBM.ICU.Impl.UBiDiProps.GetSingleton();
	            } catch (IOException e) {
	                bdp = IBM.ICU.Impl.UBiDiProps.GetDummy();
	            }
	            gBdp = bdp;
	        }
	}
}
