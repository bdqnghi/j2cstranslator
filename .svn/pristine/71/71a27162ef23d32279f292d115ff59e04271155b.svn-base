/*
 *******************************************************************************
 * Copyright (C) 1996-2007, International Business Machines Corporation and    *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 */
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:30 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Text {
	
	using IBM.ICU.Impl;
	using IBM.ICU.Util;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Text;
	
	/// <summary>
	/// A transliterator that performs locale-sensitive toLower() case mapping.
	/// </summary>
	///
	internal class LowercaseTransliterator : Transliterator {
	
	    public sealed class Anonymous_C0 : Transliterator.Factory {
	        public Transliterator GetInstance(String ID) {
	            return new LowercaseTransliterator(IBM.ICU.Util.ULocale.US);
	        }
	    }
	
	    /// <summary>
	    /// Package accessible ID.
	    /// </summary>
	    ///
	    internal const String _ID = "Any-Lower";
	
	    // TODO: Add variants for tr, az, lt, default = default locale
	
	    /// <summary>
	    /// System registration hook.
	    /// </summary>
	    ///
	    static internal void Register() {
	        IBM.ICU.Text.Transliterator.RegisterFactory(_ID, new LowercaseTransliterator.Anonymous_C0 ());
	
	        IBM.ICU.Text.Transliterator.RegisterSpecialInverse("Lower", "Upper", true);
	    }
	
	    private ULocale locale;
	
	    private UCaseProps csp;
	
	    private ReplaceableContextIterator iter;
	
	    private StringBuilder result;
	
	    private int[] locCache;
	
	    /// <summary>
	    /// Constructs a transliterator.
	    /// </summary>
	    ///
	
	    public LowercaseTransliterator(ULocale loc) : base(_ID, null) {
	        locale = loc;
	        try {
	            csp = IBM.ICU.Impl.UCaseProps.GetSingleton();
	        } catch (IOException e) {
	            csp = null;
	        }
	        iter = new ReplaceableContextIterator();
	        result = new StringBuilder();
	        locCache = new int[1];
	        locCache[0] = 0;
	    }
	
	    /// <summary>
	    /// Implements <see cref="M:IBM.ICU.Text.Transliterator.HandleTransliterate(IBM.ICU.Text.Replaceable, null, System.Boolean)"/>.
	    /// </summary>
	    ///
	    protected internal override void HandleTransliterate(Replaceable text, Transliterator.Position  offsets,
	            bool isIncremental) {
	        if (csp == null) {
	            return;
	        }
	
	        if (offsets.start >= offsets.limit) {
	            return;
	        }
	
	        iter.SetText(text);
	        result.Length=0;
	        int c, delta;
	
	        // Walk through original string
	        // If there is a case change, modify corresponding position in
	        // replaceable
	
	        iter.SetIndex(offsets.start);
	        iter.SetLimit(offsets.limit);
	        iter.SetContextLimits(offsets.contextStart, offsets.contextLimit);
	        while ((c = iter.NextCaseMapCP()) >= 0) {
	            c = csp.ToFullLower(c, iter, result, locale, locCache);
	
	            if (iter.DidReachLimit() && isIncremental) {
	                // the case mapping function tried to look beyond the context
	                // limit
	                // wait for more input
	                offsets.start = iter.GetCaseMapCPStart();
	                return;
	            }
	
	            /* decode the result */
	            if (c < 0) {
	                /* c mapped to itself, no change */
	                continue;
	            } else if (c <= IBM.ICU.Impl.UCaseProps.MAX_STRING_LENGTH) {
	                /* replace by the mapping string */
	                delta = iter.Replace(result.ToString());
	                result.Length=0;
	            } else {
	                /* replace by single-code point mapping */
	                delta = iter.Replace(IBM.ICU.Text.UTF16.ValueOf(c));
	            }
	
	            if (delta != 0) {
	                offsets.limit += delta;
	                offsets.contextLimit += delta;
	            }
	        }
	        offsets.start = offsets.limit;
	    }
	}
}
