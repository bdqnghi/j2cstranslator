//##header J2SE15
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/13/10 10:46 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /*
 *******************************************************************************
 * Copyright (C) 1996-2007, International Business Machines Corporation and    *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 */
namespace IBM.ICU.Charset
{

    using IBM.ICU.Text;
    using IBM.ICU.Util;
    using ILOG.J2CsMapping.Threading;
    using ILOG.J2CsMapping.Util;
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.Globalization;
    using System.IO;
    using System.Reflection;
    using System.Resources;
    using System.Runtime.CompilerServices;
    using System.Security;
    using System.Text;
    using ILOG.J2CsMapping.Text;

    /// <summary>
    /// TestFmwk is a base class for tests that can be run conveniently from the
    /// command line as well as under the Java test harness.
    /// <p>
    /// Sub-classes implement a set of methods named Test <something>. Each of these
    /// methods performs some test. Test methods should indicate errors by calling
    /// either err or errln. This will increment the errorCount field and may
    /// optionally print a message to the log. Debugging information may also be
    /// added to the log via the log and logln methods. These methods will add their
    /// arguments to the log only if the test is being run in verbose mode.
    /// </summary>
    ///
    public class TestFmwk : AbstractTestLog
    {
        /// <summary>
        /// The default time zone for all of our tests. Used in Target.run();
        /// </summary>
        ///
        static internal readonly IBM.ICU.Util.TimeZone defaultTimeZone = IBM.ICU.Util.TimeZone.GetTimeZone("PST");

        /// <summary>
        /// The default locale used for all of our tests. Used in Target.run();
        /// </summary>
        ///
        static internal readonly Locale defaultLocale = Locale.US;

        [Serializable]
        public sealed class TestFmwkException : Exception
        {
            /// <summary>
            /// For serialization
            /// </summary>
            ///
            private const long serialVersionUID = -3051148210247229194L;

            internal TestFmwkException(String msg)
                : base(msg)
            {
            }
        }

        protected internal void HandleException(Exception e)
        {
            // #if defined(FOUNDATION10) || defined(J2SE13)
            // ## Throwable ex = null;
            // #else
            Exception ex = e.InnerException;
            // #endif
            if (ex == null)
            {
                ex = e;
            }
            if (ex is ReflectionTypeLoadException)
            {
                ex = ((ReflectionTypeLoadException)ex).InnerException;
            }
            String msg = ex.Message;
            if (msg == null)
            {
                msg = "";
            }
            // System.err.println("TF handleException msg: " + msg);
            if (ex is MissingManifestResourceException
                    || ex is ReflectionTypeLoadException
                    || msg.IndexOf("java.util.MissingResourceException") >= 0)
            {
                if (paras.warnings || paras.nodata)
                {
                    Warnln(msg);
                }
                else if (paras.nothrow)
                {
                    Errln(msg);
                    Console.Error.WriteLine(ex.StackTrace);
                }
                else
                {
                    Console.Error.WriteLine(ex.StackTrace);
                    throw new Exception(msg);
                }
            }
            else
            {
                if (paras.nothrow)
                {
                    Errln(msg);
                    Console.Error.WriteLine(ex.StackTrace);
                }
                else
                {
                    Errln(msg);
                    Console.Error.WriteLine(ex.StackTrace);
                    throw new Exception(msg);
                }
            }
        }

        // use this instead of new random so we get a consistent seed
        // for our tests
        protected internal Random CreateRandom()
        {
            return new Random(paras.seed);
        }

        /// <summary>
        /// A test that has no test methods itself, but instead runs other tests.
        /// This overrides methods are getTargets and getSubtest from TestFmwk.
        /// If you want the default behavior, pass an array of class names and an
        /// optional description to the constructor. The named classes must extend
        /// TestFmwk. If a provided name doesn't include a ".", package name is
        /// prefixed to it (the package of the current test is used if none was
        /// provided in the constructor). The resulting full name is used to
        /// instantiate an instance of the class using the default constructor.
        /// Class names are resolved to classes when getTargets or getSubtest is
        /// called. This allows instances of TestGroup to be compiled and run without
        /// all the targets they would normally invoke being available.
        /// </summary>
        ///
        public abstract class TestGroup : TestFmwk
        {
            private TestFmwk outer_TestFmwk;

            private String defaultPackage;

            private String[] names;

            private String description;

            private Type[] tests; // deferred init

            /// <summary>
            /// Constructor that takes a default package name and a list of class
            /// names. Adopts and modifies the classname list
            /// </summary>
            ///
            protected internal TestGroup(TestFmwk fmwk, String defaultPackage_0, String[] classnames,
                    String description_1)
            {
                outer_TestFmwk = fmwk;
                if (classnames == null)
                {
                    throw new InvalidOperationException("classnames must not be null");
                }

                if (defaultPackage_0 == null)
                {
                    defaultPackage_0 = GetType().FullName;
                }
                defaultPackage_0 = defaultPackage_0 + ".";

                this.defaultPackage = defaultPackage_0;
                this.names = classnames;
                this.description = description_1;
            }

            /// <summary>
            /// Constructor that takes a list of class names and a description, and
            /// uses the package for this class as the default package.
            /// </summary>
            ///
            protected internal TestGroup(TestFmwk fmwk, String[] classnames, String description_0)
                : this(fmwk, null, classnames, description_0)
            {
            }

            /// <summary>
            /// Constructor that takes a list of class names, and uses the package
            /// for this class as the default package.
            /// </summary>
            ///
            protected internal TestGroup(TestFmwk fmwk, String[] classnames)
                : this(fmwk, null, classnames, null)
            {
            }

            protected internal override String GetDescription()
            {
                return description;
            }

            protected internal override TestFmwk.Target GetTargets(String targetName)
            {
                TestFmwk.Target target = null;
                if (targetName != null)
                {
                    FinishInit(); // hmmm, want to get subtest without initializing
                    // all tests

                    try
                    {
                        TestFmwk test = GetSubtest(targetName);
                        if (test != null)
                        {
                            target = new IBM.ICU.Charset.TestFmwk.ClassTarget(outer_TestFmwk);
                        }
                        else
                        {
                            target = new IBM.ICU.Charset.TestFmwk.Target(outer_TestFmwk, targetName);
                        }
                    }
                    catch (TestFmwk.TestFmwkException e)
                    {
                        target = new IBM.ICU.Charset.TestFmwk.Target(outer_TestFmwk, targetName);
                    }
                }
                else if (paras.DoRecurse())
                {
                    FinishInit();
                    bool groupOnly = paras.DoRecurseGroupsOnly();
                    for (int i = names.Length; --i >= 0; )
                    {
                        TestFmwk.Target newTarget = null;
                        Type cls = tests[i];
                        if (cls == null)
                        { // hack no warning for missing tests
                            if (paras.warnings)
                            {
                                continue;
                            }
                            newTarget = new IBM.ICU.Charset.TestFmwk.Target(outer_TestFmwk, names[i]);
                        }
                        else
                        {
                            TestFmwk test_0 = GetSubtest(i, groupOnly);
                            if (test_0 != null)
                            {
                                newTarget = new IBM.ICU.Charset.TestFmwk.ClassTarget(outer_TestFmwk);
                            }
                            else
                            {
                                if (groupOnly)
                                {
                                    newTarget = new IBM.ICU.Charset.TestFmwk.EmptyTarget(outer_TestFmwk, names[i]);
                                }
                                else
                                {
                                    newTarget = new IBM.ICU.Charset.TestFmwk.Target(outer_TestFmwk, names[i]);
                                }
                            }
                        }
                        if (newTarget != null)
                        {
                            newTarget.SetNext(target);
                            target = newTarget;
                        }
                    }
                }

                return target;
            }

            protected internal override TestFmwk GetSubtest(String testName)
            {
                FinishInit();

                for (int i = 0; i < names.Length; ++i)
                {
                    if (names[i].Equals(testName, StringComparison.InvariantCultureIgnoreCase))
                    { // allow
                        // case-insensitive
                        // matching
                        return GetSubtest(i, false);
                    }
                }
                throw new TestFmwk.TestFmwkException(testName);
            }

            public TestFmwk GetSubtest(int i, bool groupOnly)
            {
                Type cls = tests[i];
                if (cls != null)
                {
                    if (groupOnly && !typeof(TestGroup).IsAssignableFrom(cls))
                    {
                        return null;
                    }

                    try
                    {
                        TestFmwk subtest = (TestFmwk)Activator.CreateInstance(cls);
                        subtest.paras = paras;
                        return subtest;
                    }
                    catch (TargetException e)
                    {
                        throw new InvalidOperationException(e.Message);
                    }
                    catch (MemberAccessException e_0)
                    {
                        throw new InvalidOperationException(e_0.Message);
                    }
                }
                return null;
            }

            public void FinishInit()
            {
                if (tests == null)
                {
                    tests = new Type[names.Length];

                    for (int i = 0; i < names.Length; ++i)
                    {
                        String name = names[i];
                        if (name.IndexOf('.') == -1)
                        {
                            name = defaultPackage + name;
                        }
                        try
                        {
                            Type cls = ILOG.J2CsMapping.Reflect.Helper.GetNativeType(name);
                            if (!typeof(TestFmwk).IsAssignableFrom(cls))
                            {
                                throw new InvalidOperationException("class " + name
                                        + " does not extend TestFmwk");
                            }

                            tests[i] = cls;
                            names[i] = IBM.ICU.Charset.TestFmwk.GetClassTargetName(cls);
                        }
                        catch (TypeLoadException e)
                        {
                            // leave tests[i] null and name as classname
                        }
                    }
                }
            }
        }

        /// <summary>
        /// The default target is invalid.
        /// </summary>
        ///
        public class Target
        {
            private TestFmwk outer_TestFmwk;

            internal TestFmwk.Target next;

            public readonly String name;

            public Target(TestFmwk fmwk, String name_0)
            {
                outer_TestFmwk = fmwk;
                this.name = name_0;
            }

            public TestFmwk.Target SetNext(TestFmwk.Target next_0)
            {
                this.next = next_0;
                return this;
            }

            public TestFmwk.Target GetNext()
            {
                return next;
            }

            public TestFmwk.Target Append(TestFmwk.Target targets)
            {
                TestFmwk.Target t = this;
                while (t.next != null)
                {
                    t = t.next;
                }
                t.next = targets;
                return this;
            }

            public void Run()
            {
                int f = Filter();
                if (f == -1)
                {
                    ++outer_TestFmwk.paras.invalidCount;
                }
                else
                {
                    Locale.SetDefault(IBM.ICU.Charset.TestFmwk.defaultLocale);
                    IBM.ICU.Util.TimeZone.SetDefault(IBM.ICU.Charset.TestFmwk.defaultTimeZone);

                    if (!Validate())
                    {
                        outer_TestFmwk.paras.WriteTestInvalid(name, outer_TestFmwk.paras.nodata);
                    }
                    else
                    {
                        outer_TestFmwk.paras.Push(name, GetDescription(), f == 1);
                        Execute();
                        outer_TestFmwk.paras.Pop();
                    }
                }
            }

            protected internal int Filter()
            {
                return outer_TestFmwk.paras.Filter(name);
            }

            protected internal virtual bool Validate()
            {
                return false;
            }

            protected internal virtual String GetDescription()
            {
                return null;
            }

            protected internal virtual void Execute()
            {
            }
        }

        public class EmptyTarget : TestFmwk.Target
        {
            private TestFmwk outer_TestFmwk;

            public EmptyTarget(TestFmwk fmwk, String name_0)
                : base(fmwk, name_0)
            {
                outer_TestFmwk = fmwk;
            }

            protected internal override bool Validate()
            {
                return true;
            }
        }

        public class MethodTarget : TestFmwk.Target
        {
            private TestFmwk outer_TestFmwk;
            private MethodInfo testMethod;

            public MethodTarget(TestFmwk fmwk, String name_0, MethodInfo method)
                : base(fmwk, name_0)
            {
                outer_TestFmwk = fmwk;
                testMethod = method;
            }

            protected internal override bool Validate()
            {
                return testMethod != null && outer_TestFmwk.ValidateMethod(name);
            }

            protected internal override String GetDescription()
            {
                return outer_TestFmwk.GetMethodDescription(name);
            }

            protected internal override void Execute()
            {
                if (outer_TestFmwk.paras.InDocMode())
                {
                    // nothing to execute
                }
                else if (!outer_TestFmwk.paras.stack.included)
                {
                    ++outer_TestFmwk.paras.invalidCount;
                }
                else
                {
                    Object[] NO_ARGS = new Object[0];
                    try
                    {
                        ++outer_TestFmwk.paras.testCount;
                        outer_TestFmwk.Init();
                        ILOG.J2CsMapping.Reflect.Helper.Invoke(testMethod, outer_TestFmwk, NO_ARGS);
                    }
                    catch (MemberAccessException e)
                    {
                        outer_TestFmwk.Errln("Can't access test method " + testMethod.Name);
                    }
                    catch (ReflectionTypeLoadException e_0)
                    {
                        outer_TestFmwk.HandleException(e_0);
                    }
                    catch (TargetInvocationException e_1)
                    {
                        // e.printStackTrace();
                        outer_TestFmwk.HandleException(e_1);
                    }
                    catch (MissingManifestResourceException e_2)
                    {
                        outer_TestFmwk.HandleException(e_2);
                        /* } catch (ReflectionTypeLoadException e_3) {
                             outer_TestFmwk.HandleException(e_3);*/
                    }
                    catch (Exception e_4)
                    {
                        /*
                         * errln("Encountered: "+ e.toString());
                         * e.printStackTrace(System.err);
                         */
                        outer_TestFmwk.HandleException(e_4);
                    }
                }
            }

            protected internal String GetStackTrace(TargetInvocationException e)
            {
                MemoryStream bs = new MemoryStream();
                TextWriter ps = new StreamWriter(bs);
                ps.WriteLine(e.InnerException.StackTrace);
                return bs.ToString();
            }
        }

        public class ClassTarget : TestFmwk.Target
        {
            private TestFmwk outer_TestFmwk;

            public sealed class Anonymous_C0 : IComparer
            {
                private readonly TestFmwk.ClassTarget outer_ClassTarget;


                /// <param name="paramouter_ClassTarget"></param>
                public Anonymous_C0(TestFmwk.ClassTarget paramouter_ClassTarget)
                {
                    this.outer_ClassTarget = paramouter_ClassTarget;
                }

                public int Compare(Object lhs, Object rhs)
                {
                    // sort in reverse order, later we link up in
                    // forward order
                    return String.CompareOrdinal(((TestFmwk.Target)rhs).name, ((TestFmwk.Target)lhs).name);
                }
            }

            internal String targetName;

            public ClassTarget(TestFmwk fmwk)
                : this(fmwk, null)
            {
                // this(fmwk, null);
            }

            public ClassTarget(TestFmwk fmwk, String targetName_0)
                : base(fmwk, IBM.ICU.Charset.TestFmwk.GetClassTargetName(fmwk.GetType()))
            {
                outer_TestFmwk = fmwk;
                this.targetName = targetName_0;
            }

            protected internal override bool Validate()
            {
                return outer_TestFmwk.Validate();
            }

            protected internal override String GetDescription()
            {
                return outer_TestFmwk.GetDescription();
            }

            protected internal override void Execute()
            {
                outer_TestFmwk.paras.indentLevel++;
                TestFmwk.Target target = Randomize(outer_TestFmwk.GetTargets(targetName));
                while (target != null)
                {
                    target.Run();
                    target = target.next;
                }
                outer_TestFmwk.paras.indentLevel--;
            }

            public TestFmwk.Target Randomize(TestFmwk.Target t)
            {
                if (t != null && t.GetNext() != null)
                {
                    ArrayList list = new ArrayList();
                    while (t != null)
                    {
                        ILOG.J2CsMapping.Collections.Generics.Collections.Add(list, t);
                        t = t.GetNext();
                    }

                    TestFmwk.Target[] arr = (TestFmwk.Target[])ILOG.J2CsMapping.Collections.Generics.Collections.ToArray(list, new TestFmwk.Target[list.Count]);

                    if (true)
                    { // todo - add to params?
                        // different jvms return class methods in different orders,
                        // so we sort them (always, and then randomize them, so that
                        // forcing a seed will also work across jvms).
                        Array.Sort(arr, new IBM.ICU.Charset.TestFmwk.ClassTarget.Anonymous_C0(this));

                        // t is null to start, ends up as first element
                        // (arr[arr.length-1])
                        for (int i = 0; i < arr.Length; ++i)
                        {
                            t = arr[i].SetNext(t); // relink in forward order
                        }
                    }

                    if (outer_TestFmwk.paras.random != null)
                    {
                        t = null; // reset t to null
                        Random r = outer_TestFmwk.paras.random;
                        for (int i_0 = arr.Length; --i_0 >= 1; )
                        {
                            int x = r.Next(i_0 + 1);
                            t = arr[x].SetNext(t);
                            arr[x] = arr[i_0];
                        }

                        t = arr[0].SetNext(t); // new first element
                    }
                }

                return t;
            }
        }

        // ------------------------------------------------------------------------
        // Everything below here is boilerplate code that makes it possible
        // to add a new test by simply adding a function to an existing class
        // ------------------------------------------------------------------------

        protected internal TestFmwk()
        {
            this.paras = TestFmwk.TestParams.Create("", null);
        }

        protected internal virtual void Init()
        {
        }

        /// <summary>
        /// Parse arguments into a TestParams object and a collection of target
        /// paths. If there was an error parsing the TestParams, print usage and exit
        /// with -1. Otherwise, call resolveTarget(TestParams, String) for each path,
        /// and run the returned target. After the last test returns, if prompt is
        /// set, prompt and wait for input from stdin. Finally, exit with number of
        /// errors.
        /// This method never returns, since it always exits with System.exit();
        /// </summary>
        ///
        public void Run(String[] args)
        {
            Environment.Exit(Run(args, System.Console.Out));
        }

        /// <summary>
        /// Like run(String[]) except this allows you to specify the error log.
        /// Unlike run(String[]) this returns the error code as a result instead of
        /// calling System.exit().
        /// </summary>
        ///
        public int Run(String[] args, TextWriter log)
        {
            bool prompt = false;
            int wx = 0;
            for (int i = 0; i < args.Length; ++i)
            {
                String arg = args[i];
                if (arg.Equals("-p") || arg.Equals("-prompt"))
                {
                    prompt = true;
                }
                else
                {
                    if (wx < i)
                    {
                        args[wx] = arg;
                    }
                    wx++;
                }
            }
            while (wx < args.Length)
            {
                args[wx++] = null;
            }

            TestFmwk.TestParams localParams = IBM.ICU.Charset.TestFmwk.TestParams.Create(args, log);
            if (localParams == null)
            {
                return -1;
            }

            int errorCount = RunTests(localParams, args);

            if (localParams.seed != 0)
            {
                localParams.log.WriteLine("-random:" + localParams.seed);
                localParams.log.Flush();
            }

            if (localParams.errorSummary != null
                    && localParams.errorSummary.Length > 0)
            {
                localParams.log.WriteLine("\nError summary:");
                localParams.log.WriteLine(localParams.errorSummary.ToString());
            }

            if (prompt)
            {
                System.Console.Out.WriteLine("Hit RETURN to exit...");
                System.Console.Out.Flush();
                try
                {
                    System.Console.In.Read();
                }
                catch (IOException e)
                {
                    localParams.log.WriteLine("Exception: " + e.ToString()
                            + e.Message);
                }
            }

            return errorCount;
        }

        public int RunTests(TestFmwk.TestParams _params, String[] tests_0)
        {
            int ec = 0;

            StringBuilder summary = null;
            try
            {
                if (tests_0.Length == 0 || tests_0[0] == null)
                { // no args
                    _params.Init();
                    ResolveTarget(_params).Run();
                    ec = _params.errorCount;
                }
                else
                {
                    for (int i = 0; i < tests_0.Length; ++i)
                    {
                        if (tests_0[i] == null)
                            continue;

                        if (i > 0)
                        {
                            _params.log.WriteLine();
                        }

                        _params.Init();
                        ResolveTarget(_params, tests_0[i]).Run();
                        ec += _params.errorCount;

                        if (_params.errorSummary != null
                                && _params.errorSummary.Length > 0)
                        {
                            if (summary == null)
                            {
                                summary = new StringBuilder();
                            }
                            summary.Append("\nTest Root: " + tests_0[i] + "\n");
                            summary.Append(_params.ErrorSummary());
                        }
                    }
                    _params.errorSummary = summary;
                }
            }
            catch (Exception e)
            {
                _params.log.WriteLine(e.StackTrace);
                _params.log.WriteLine(e.Message);
                _params.log.WriteLine("encountered exception, exiting");
            }

            return ec;
        }

        /// <summary>
        /// Return a ClassTarget for this test. Params is set on this test.
        /// </summary>
        ///
        public TestFmwk.Target ResolveTarget(TestFmwk.TestParams paramsArg)
        {
            this.paras = paramsArg;
            return new TestFmwk.ClassTarget(this);
        }

        /// <summary>
        /// Resolve a path from this test to a target. If this test has subtests, and
        /// the path contains '/', the portion before the '/' is resolved to a
        /// subtest, until the path is consumed or the test has no subtests. Returns
        /// a ClassTarget created using the resolved test and remaining path (which
        /// ought to be null or a method name). Params is set on the target's test.
        /// </summary>
        ///
        public TestFmwk.Target ResolveTarget(TestFmwk.TestParams paramsArg, String targetPath)
        {
            TestFmwk test = this;
            test.paras = paramsArg;

            if (targetPath != null)
            {
                if (targetPath.Length == 0)
                {
                    targetPath = null;
                }
                else
                {
                    int p = 0;
                    int e = targetPath.Length;

                    // trim all leading and trailing '/'
                    while (targetPath[p] == '/')
                    {
                        ++p;
                    }
                    while (e > p && targetPath[e - 1] == '/')
                    {
                        --e;
                    }
                    if (p > 0 || e < targetPath.Length)
                    {
                        targetPath = targetPath.Substring(p, (e - p) - (p));
                        p = 0;
                        e = targetPath.Length;
                    }

                    try
                    {
                        for (; ; )
                        {
                            int n = targetPath.IndexOf('/');
                            String prefix = (n == -1) ? targetPath : targetPath.Substring(0, (n) - (0));
                            TestFmwk subtest = test.GetSubtest(prefix);

                            if (subtest == null)
                            {
                                break;
                            }

                            test = subtest;

                            if (n == -1)
                            {
                                targetPath = null;
                                break;
                            }

                            targetPath = targetPath.Substring(n + 1);
                        }
                    }
                    catch (TestFmwk.TestFmwkException ex)
                    {
                        return new IBM.ICU.Charset.TestFmwk.Target(test, targetPath);
                    }
                }
            }

            return new IBM.ICU.Charset.TestFmwk.ClassTarget(test, targetPath);
        }

        /// <summary>
        /// Return true if we can run this test (allows test to inspect jvm,
        /// environment, params before running)
        /// </summary>
        ///
        protected internal virtual bool Validate()
        {
            return true;
        }

        /// <summary>
        /// Return the targets for this test. If targetName is null, return all
        /// targets, otherwise return a target for just that name. The returned
        /// target can be null.
        /// The default implementation returns a MethodTarget for each public method
        /// of the object's class whose name starts with "Test" or "test".
        /// </summary>
        ///
        protected internal virtual TestFmwk.Target GetTargets(String targetName_0)
        {
            return GetClassTargets(GetType(), targetName_0);
        }

        protected internal TestFmwk.Target GetClassTargets(Type cls, String targetName_0)
        {
            if (cls == null)
            {
                return null;
            }

            TestFmwk.Target target = null;
            if (targetName_0 != null)
            {
                try
                {
                    MethodInfo method = ILOG.J2CsMapping.Reflect.Helper.GetMethod(cls, targetName_0, (Type[])null);
                    target = new TestFmwk.MethodTarget(this, targetName_0, method);
                }
                catch (AmbiguousMatchException e)
                {
                    if (!InheritTargets())
                    {
                        return new TestFmwk.Target(this, targetName_0); // invalid target
                    }
                }
                catch (SecurityException e_1)
                {
                    return null;
                }
            }
            else
            {
                if (paras.DoMethods())
                {
                    MethodInfo[] methods = cls.GetMethods(BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.Static);
                    for (int i = methods.Length; --i >= 0; )
                    {
                        String name_2 = methods[i].Name;
                        if (name_2.StartsWith("Test") || name_2.StartsWith("test"))
                        {
                            target = new TestFmwk.MethodTarget(this, name_2, methods[i])
                                    .SetNext(target);
                        }
                    }
                }
            }

            if (InheritTargets())
            {
                TestFmwk.Target parentTarget = GetClassTargets(cls.BaseType,
                        targetName_0);
                if (parentTarget == null)
                {
                    return target;
                }
                if (target == null)
                {
                    return parentTarget;
                }
                return parentTarget.Append(target);
            }

            return target;
        }

        protected internal bool InheritTargets()
        {
            return false;
        }

        protected internal virtual String GetDescription()
        {
            return null;
        }

        protected internal virtual bool ValidateMethod(String name_0)
        {
            return true;
        }

        protected internal virtual String GetMethodDescription(String name_0)
        {
            return null;
        }

        // method tests have no subtests, group tests override
        protected internal virtual TestFmwk GetSubtest(String prefix)
        {
            return null;
        }

        public bool IsVerbose()
        {
            return paras.verbose;
        }

        public bool NoData()
        {
            return paras.nodata;
        }

        public bool IsTiming()
        {
            return paras.timing < Int64.MaxValue;
        }

        public bool IsMemTracking()
        {
            return paras.memusage;
        }

        /// <summary>
        /// 0 = fewest tests, 5 is normal build, 10 is most tests
        /// </summary>
        ///
        public int GetInclusion()
        {
            return paras.inclusion;
        }

        public bool IsModularBuild()
        {
            return paras.warnings;
        }

        public bool IsQuick()
        {
            return paras.inclusion == 0;
        }

        public override void Msg(String message, int level, bool incCount, bool newln)
        {
            if (paras == null)
                Console.WriteLine(message);
            else
                paras.Msg(message, level, incCount, newln);

        }

        protected internal int GetErrorCount()
        {
            return paras.errorCount;
        }

        protected internal IBM.ICU.Util.TimeZone SafeGetTimeZone(String id)
        {
            IBM.ICU.Util.TimeZone tz = IBM.ICU.Util.TimeZone.GetTimeZone(id);
            if (tz == null)
            {
                // should never happen
                Errln("FAIL: TimeZone.getTimeZone(" + id + ") => null");
            }
            if (!tz.GetID().Equals(id))
            {
                Warnln("FAIL: TimeZone.getTimeZone(" + id + ") => " + tz.GetID());
            }
            return tz;
        }

        /// <summary>
        /// Print a usage message for this test class.
        /// </summary>
        ///
        public void Usage()
        {
            Usage(System.Console.Out, GetType().FullName);
        }

        public static void Usage(TextWriter pw, String className)
        {
            pw.WriteLine("Usage: " + className + " option* target*");
            pw.WriteLine();
            pw.WriteLine("Options:");
            pw.WriteLine(" -describe Print a short descriptive string for this test and all");
            pw.WriteLine("       listed targets.");
            pw.WriteLine(" -e<n> Set exhaustiveness from 0..10.  Default is 0, fewest tests.\n"
                    + "       To run all tests, specify -e10.  Giving -e with no <n> is\n"
                    + "       the same as -e5.");
            pw.WriteLine(" -filter:<str> Only tests matching filter will be run or listed.\n"
                    + "       <str> is of the form ['^']text[','['^']text].\n"
                    + "       Each string delimited by ',' is a separate filter argument.\n"
                    + "       If '^' is prepended to an argument, its matches are excluded.\n"
                    + "       Filtering operates on test groups as well as tests, if a test\n"
                    + "       group is included, all its subtests that are not excluded will\n"
                    + "       be run.  Examples:\n"
                    + "    -filter:A -- only tests matching A are run.  If A matches a group,\n"
                    + "       all subtests of this group are run.\n"
                    + "    -filter:^A -- all tests except those matching A are run.  If A matches\n"
                    + "        a group, no subtest of that group will be run.\n"
                    + "    -filter:A,B,^C,^D -- tests matching A or B and not C and not D are run\n"
                    + "       Note: Filters are case insensitive.");
            pw.WriteLine(" -h[elp] Print this help text and exit.");
            pw.WriteLine(" -l[ist] List immediate targets of this test");
            pw.WriteLine("   -la, -listAll List immediate targets of this test, and all subtests");
            pw.WriteLine("   -le, -listExaustive List all subtests and targets");
            // don't know how to get useful numbers for memory usage using java API
            // calls
            // pw.println(" -m[emory] print memory usage and force gc for
            // each test");
            pw.WriteLine(" -n[othrow] Message on test failure rather than exception");
            pw.WriteLine(" -prompt Prompt before exiting");
            pw.WriteLine(" -q[uiet] Do not show warnings");
            pw.WriteLine(" -r[andom][:<n>] If present, randomize targets.  If n is present,\n"
                    + "       use it as the seed.  If random is not set, targets will\n"
                    + "       be in alphabetical order to ensure cross-platform consistency.");
            pw.WriteLine(" -s[ilent] No output except error summary or exceptions.");
            pw.WriteLine(" -tfilter:<str> Transliterator Test filter of ids.");
            pw.WriteLine(" -t[ime][:<n>] Print elapsed time for each test.  if n is present\n"
                    + "       only print times >= n milliseconds.");
            pw.WriteLine(" -v[erbose] Show log messages");
            pw.WriteLine(" -w[arning] Continue in presence of warnings, and disable missing test warnings.");
            pw.WriteLine(" -nodata | -nd Do not warn if resource data is not present.");
            pw.WriteLine();
            pw.WriteLine(" If a list or describe option is provided, no tests are run.");
            pw.WriteLine();
            pw.WriteLine("Targets:");
            pw.WriteLine(" If no target is specified, all targets for this test are run.");
            pw.WriteLine(" If a target contains no '/' characters, and matches a target");
            pw.WriteLine(" of this test, the target is run.  Otherwise, the part before the");
            pw.WriteLine(" '/' is used to match a subtest, which then evaluates the");
            pw.WriteLine(" remainder of the target as above.  Target matching is case-insensitive.");
            pw.WriteLine();
            pw.WriteLine(" If multiple targets are provided, each is executed in order.");
            pw.Flush();
        }

        public static String Hex(char[] s)
        {
            StringBuilder result = new StringBuilder();
            for (int i = 0; i < s.Length; ++i)
            {
                if (i != 0)
                    result.Append(',');
                result.Append(Hex(s[i]));
            }
            return result.ToString();
        }

        public static String Hex(byte[] s)
        {
            StringBuilder result = new StringBuilder();
            for (int i = 0; i < s.Length; ++i)
            {
                if (i != 0)
                    result.Append(',');
                result.Append(Hex(s[i]));
            }
            return result.ToString();
        }

        public static String Hex(char ch)
        {
            StringBuilder result = new StringBuilder();
            String foo = ILOG.J2CsMapping.Util.IlNumber.ToString(ch, 16).ToUpper();
            for (int i = foo.Length; i < 4; ++i)
            {
                result.Append('0');
            }
            return result + foo;
        }

        public static String Hex(int ch)
        {
            StringBuilder result = new StringBuilder();
            String foo = ILOG.J2CsMapping.Util.IlNumber.ToString(ch, 16).ToUpper();
            for (int i = foo.Length; i < 4; ++i)
            {
                result.Append('0');
            }
            return result + foo;
        }

        public static String Hex(String s)
        {
            StringBuilder result = new StringBuilder();
            for (int i = 0; i < s.Length; ++i)
            {
                if (i != 0)
                    result.Append(',');
                result.Append(Hex(s[i]));
            }
            return result.ToString();
        }

        public static String Hex(StringBuilder s)
        {
            return Hex(s.ToString());
        }

        public static String Prettify(String s)
        {
            StringBuilder result = new StringBuilder();
            int ch;
            for (int i = 0; i < s.Length; i += IBM.ICU.Text.UTF16.GetCharCount(ch))
            {
                ch = IBM.ICU.Text.UTF16.CharAt(s, i);
                if (ch > 0xfffff)
                {
                    result.Append("\\U00");
                    result.Append(Hex(ch));
                }
                else if (ch > 0xffff)
                {
                    result.Append("\\U000");
                    result.Append(Hex(ch));
                }
                else if (ch > 0x7f)
                {
                    result.Append("\\u");
                    result.Append(Hex(ch));
                }
                else
                {
                    result.Append((char)ch);
                }

            }
            return result.ToString();
        }

        public static String Prettify(StringBuilder s)
        {
            return Prettify(s.ToString());
        }

        private static IBM.ICU.Util.GregorianCalendar cal;

        /// <summary>
        /// Return a Date given a year, month, and day of month. This is similar to
        /// new Date(y-1900, m, d). It uses the default time zone at the time this
        /// method is first called.
        /// </summary>
        ///
        /// <param name="year">use 2000 for 2000, unlike new Date()</param>
        /// <param name="month">use Calendar.JANUARY etc.</param>
        /// <param name="dom">day of month, 1-based</param>
        /// <returns>a Date object for the given y/m/d</returns>
        [MethodImpl(MethodImplOptions.Synchronized)]
        protected static internal DateTime GetDate(int year, int month,
                int dom)
        {
            if (cal == null)
            {
                cal = new IBM.ICU.Util.GregorianCalendar();
            }
            cal.Clear();
            cal.Set(year, month, dom);
            return cal.GetTime();
        }

        public class NullWriter : StreamWriter
        {
            public NullWriter()
                : base(FileStream.Null) /*, false)*/ {
                }

            public override void Write(int c)
            {
            }

            public override void Write(char[] buf, int off, int len)
            {
            }

            public void Write(String s, int off, int len)
            {
            }

            public override void WriteLine()
            {
            }
        }

        public class ASCIIWriter : StreamWriter
        {
            private StringBuilder buffer;

            // Characters that we think are printable but that escapeUnprintable
            // doesn't
            private const String PRINTABLES = "\t\n\r";

            public ASCIIWriter(TextWriter w, bool autoFlush)
                : base((Stream) null /*, autoFlush*/)
            {
                
                this.buffer = new StringBuilder();
            }

            public ASCIIWriter(Stream os, bool autoFlush)
                : base(os /*, autoFlush*/)
            {
                this.buffer = new StringBuilder();
            }

            public override void Write(int c)
            {
                lock (this)
                {
                    buffer.Length = 0;
                    if (PRINTABLES.IndexOf((char)c) < 0
                            && IBM.ICU.Charset.TestUtil.EscapeUnprintable(buffer, c))
                    {
                        base.Write(buffer.ToString());
                    }
                    else
                    {
                        base.Write(c);
                    }
                }
            }

            public override void Write(char[] buf, int off, int len)
            {
                lock (this)
                {
                    buffer.Length = 0;
                    int limit = off + len;
                    while (off < limit)
                    {
                        int c = IBM.ICU.Charset.UTF16Util.CharAt(buf, 0, buf.Length, off);
                        off += IBM.ICU.Charset.UTF16Util.GetCharCount(c);
                        if (PRINTABLES.IndexOf((char)c) < 0
                                && IBM.ICU.Charset.TestUtil.EscapeUnprintable(buffer, c))
                        {
                            base.Write(buffer.ToString());
                            buffer.Length = 0;
                        }
                        else
                        {
                            base.Write(c);
                        }
                    }
                }
            }

            public void Write(String s, int off, int len)
            {
                Write(s.Substring(off, (off + len) - (off)).ToCharArray(), 0, len);
            }
        }

        // filters
        // match against the entire hierarchy
        // A;B;!C;!D --> (A ||B) && (!C && !D)
        // positive, negative, unknown matches
        // positive -- known to be included, negative- known to be excluded
        // positive only if no excludes, and matches at least one include, if any
        // negative only if matches at least one exclude
        // otherwise, we wait

        public class TestParams
        {
            public bool prompt;

            public bool nothrow = false;

            public bool verbose;

            public bool quiet;

            public int listlevel;

            public bool describe;

            public bool warnings;

            public bool nodata;

            public long timing;

            public bool memusage;

            public int inclusion;

            public String filter;

            public int seed;

            public String tfilter; // for transliterator tests

            public IBM.ICU.Charset.TestFmwk.TestParams.State stack;

            public StringBuilder errorSummary;

            public TextWriter log;

            public int indentLevel;

            internal bool needLineFeed;

            private bool suppressIndent;

            public int errorCount;

            public int warnCount;

            public int invalidCount;

            public int testCount;

            private IBM.ICU.Text.NumberFormat tformat;

            public Random random;

            public TestParams()
            {
                this.timing = Int64.MaxValue;
            }

            public static TestFmwk.TestParams Create(String arglist, TextWriter log_0)
            {
                String[] args = null;
                if (arglist != null && arglist.Length > 0)
                {
                    // #if defined(FOUNDATION10) || defined(J2SE13)
                    // ## args = Utility.split(arglist, '\u0020');
                    // #else
                    args = ILOG.J2CsMapping.Text.RegExUtil.Split(arglist, "\\s");
                    // #endif
                }
                return Create(args, log_0);
            }

            /// <summary>
            /// Create a TestParams from a list of arguments. If successful, return
            /// the params object, else return null. Error messages will be reported
            /// on errlog if it is not null. Arguments and values understood by this
            /// method will be removed from the args array and existing args will be
            /// shifted down, to be filled by nulls at the end.
            /// </summary>
            ///
            /// <param name="args">the list of arguments</param>
            /// <param name="log_0">the error log, or null if no error log is desired</param>
            /// <returns>the new TestParams object, or null if error</returns>
            public static TestFmwk.TestParams Create(String[] args, TextWriter log_0)
            {
                TestFmwk.TestParams paras = new TestFmwk.TestParams();

                if (log_0 == null)
                {
                    paras.log = new TestFmwk.NullWriter();
                }
                else
                {
                    paras.log = new TestFmwk.ASCIIWriter(log_0, true);
                }

                bool usageError = false;
                String filter_1 = null;
                int wx = 0; // write argets.
                if (args != null)
                {
                    for (int i = 0; i < args.Length; i++)
                    {
                        String arg = args[i];
                        if (arg == null || arg.Length == 0)
                        {
                            continue;
                        }
                        if (arg[0] == '-')
                        {
                            arg = arg.ToLower();
                            if (arg.Equals("-verbose") || arg.Equals("-v"))
                            {
                                paras.verbose = true;
                                paras.quiet = false;
                            }
                            else if (arg.Equals("-quiet") || arg.Equals("-q"))
                            {
                                paras.quiet = true;
                                paras.verbose = false;
                            }
                            else if (arg.Equals("-help") || arg.Equals("-h"))
                            {
                                usageError = true;
                            }
                            else if (arg.Equals("-warning") || arg.Equals("-w"))
                            {
                                paras.warnings = true;
                            }
                            else if (arg.Equals("-nodata") || arg.Equals("-nd"))
                            {
                                paras.nodata = true;
                            }
                            else if (arg.Equals("-list") || arg.Equals("-l"))
                            {
                                paras.listlevel = 1;
                            }
                            else if (arg.Equals("-listall") || arg.Equals("-la"))
                            {
                                paras.listlevel = 2;
                            }
                            else if (arg.Equals("-listexaustive")
                                  || arg.Equals("-le"))
                            {
                                paras.listlevel = 3;
                            }
                            else if (arg.Equals("-memory") || arg.Equals("-m"))
                            {
                                paras.memusage = true;
                            }
                            else if (arg.Equals("-nothrow") || arg.Equals("-n"))
                            {
                                paras.nothrow = true;
                                paras.errorSummary = new StringBuilder();
                            }
                            else if (arg.Equals("-describe") || arg.Equals("-d"))
                            {
                                paras.describe = true;
                            }
                            else if (arg.StartsWith("-r"))
                            {
                                String s = null;
                                int n = arg.IndexOf(':');
                                if (n != -1)
                                {
                                    s = arg.Substring(n + 1);
                                    arg = arg.Substring(0, (n) - (0));
                                }

                                if (arg.Equals("-r") || arg.Equals("-random"))
                                {
                                    if (s == null)
                                    {
                                        paras.seed = DateTime.Now.Millisecond;
                                    }
                                    else
                                    {
                                        paras.seed = ((Int32)Int32.Parse(s, System.Globalization.NumberStyles.Integer));
                                    }
                                }
                                else
                                {
                                    log_0.WriteLine("*** Error: unrecognized argument: "
                                            + arg);
                                    usageError = true;
                                    break;
                                }
                            }
                            else if (arg.StartsWith("-e"))
                            {
                                // see above
                                paras.inclusion = (arg.Length == 2) ? 5
                                        : Int32.Parse(arg.Substring(2));
                                if (paras.inclusion < 0 || paras.inclusion > 10)
                                {
                                    usageError = true;
                                    break;
                                }
                            }
                            else if (arg.StartsWith("-tfilter:"))
                            {
                                paras.tfilter = arg.Substring(8);
                            }
                            else if (arg.StartsWith("-time")
                                  || arg.StartsWith("-t"))
                            {
                                long val = 0;
                                int inx = arg.IndexOf(':');
                                if (inx > 0)
                                {
                                    String num = arg.Substring(inx + 1);
                                    try
                                    {
                                        val = ((Int64)Int64.Parse(num, System.Globalization.NumberStyles.Integer));
                                    }
                                    catch (Exception e)
                                    {
                                        log_0.WriteLine("*** Error: could not parse time threshold '"
                                                + num + "'");
                                        usageError = true;
                                        break;
                                    }
                                }
                                paras.timing = val;
                                String fmt = "#,00s";
                                if (val <= 10)
                                {
                                    fmt = "#,##0.000s";
                                }
                                else if (val <= 100)
                                {
                                    fmt = "#,##0.00s";
                                }
                                else if (val <= 1000)
                                {
                                    fmt = "#,##0.0s";
                                }
                                paras.tformat = new IBM.ICU.Text.DecimalFormat(fmt);
                            }
                            else if (arg.StartsWith("-filter:"))
                            {
                                String temp = arg.Substring(8).ToLower();
                                filter_1 = (filter_1 == null) ? temp : filter_1 + ","
                                        + temp;
                            }
                            else if (arg.StartsWith("-f:"))
                            {
                                String temp_2 = arg.Substring(3).ToLower();
                                filter_1 = (filter_1 == null) ? temp_2 : filter_1 + ","
                                        + temp_2;
                            }
                            else if (arg.StartsWith("-s"))
                            {
                                paras.log = new TestFmwk.NullWriter();
                            }
                            else
                            {
                                log_0.WriteLine("*** Error: unrecognized argument: "
                                        + args[i]);
                                usageError = true;
                                break;
                            }
                        }
                        else
                        {
                            args[wx++] = arg; // shift down
                        }
                    }

                    while (wx < args.Length)
                    {
                        args[wx++] = null;
                    }
                }

                if (usageError)
                {
                    IBM.ICU.Charset.TestFmwk.Usage(log_0, "TestAll");
                    return null;
                }

                if (filter_1 != null)
                {
                    paras.filter = filter_1.ToLower();
                }

                paras.Init();

                return paras;
            }

            public String ErrorSummary()
            {
                return (errorSummary == null) ? "" : errorSummary.ToString();
            }

            public void Init()
            {
                indentLevel = 0;
                needLineFeed = false;
                suppressIndent = false;
                errorCount = 0;
                warnCount = 0;
                invalidCount = 0;
                testCount = 0;
                random = (seed == 0) ? null : new Random(seed);
            }

            public class State
            {
                private TestFmwk.TestParams outer_TestParams;

                internal IBM.ICU.Charset.TestFmwk.TestParams.State link;

                internal String name;

                internal StringBuilder buffer;

                internal int level;

                internal int ec;

                internal int wc;

                internal int ic;

                internal int tc;

                internal bool flushed;

                public bool included;

                internal long mem;

                internal long millis;

                public State(TestFmwk.TestParams paras, IBM.ICU.Charset.TestFmwk.TestParams.State link_0, String name_1, bool included_2)
                {
                    outer_TestParams = paras;
                    this.link = link_0;
                    this.name = name_1;
                    if (link_0 == null)
                    {
                        this.level = 0;
                        this.included = included_2;
                    }
                    else
                    {
                        this.level = link_0.level + 1;
                        this.included = included_2 || link_0.included;
                    }
                    this.ec = outer_TestParams.errorCount;
                    this.wc = outer_TestParams.warnCount;
                    this.ic = outer_TestParams.invalidCount;
                    this.tc = outer_TestParams.testCount;

                    if (link_0 == null || this.included)
                    {
                        Flush();
                    }

                    mem = outer_TestParams.Getmem();
                    millis = DateTime.Now.Millisecond;
                }

                internal void Flush()
                {
                    if (!flushed)
                    {
                        if (link != null)
                        {
                            link.Flush();
                        }

                        outer_TestParams.Indent(level);
                        outer_TestParams.log.Write(name);
                        outer_TestParams.log.Flush();

                        flushed = true;

                        outer_TestParams.needLineFeed = true;
                    }
                }

                internal void AppendPath(StringBuilder buf)
                {
                    if (this.link != null)
                    {
                        this.link.AppendPath(buf);
                        buf.Append('/');
                    }
                    buf.Append(name);
                }
            }

            public void Push(String name_0, String description_1, bool included_2)
            {
                if (InDocMode() && describe && description_1 != null)
                {
                    name_0 += ": " + description_1;
                }
                stack = new IBM.ICU.Charset.TestFmwk.TestParams.State(this, stack, name_0, included_2);
            }

            public void Pop()
            {
                if (stack != null)
                {
                    WriteTestResult();
                    stack = stack.link;
                }
            }

            public bool InDocMode()
            {
                return describe || listlevel != 0;
            }

            public bool DoMethods()
            {
                return !InDocMode() || listlevel == 3
                        || (indentLevel == 1 && listlevel > 0);
            }

            public bool DoRecurse()
            {
                return !InDocMode() || listlevel > 1
                        || (indentLevel == 1 && listlevel > 0);
            }

            public bool DoRecurseGroupsOnly()
            {
                return InDocMode()
                        && (listlevel == 2 || (indentLevel == 1 && listlevel > 0));
            }

            // return 0, -1, or 1
            // 1: run this test
            // 0: might run this test, no positive include or exclude on this group
            // -1: exclude this test
            public int Filter(String testName)
            {
                int result = 0;
                if (filter == null)
                {
                    result = 1;
                }
                else
                {
                    bool noIncludes = true;
                    bool noExcludes = filter.IndexOf('^') == -1;
                    testName = testName.ToLower();
                    int ix = 0;
                    while (ix < filter.Length)
                    {
                        int nix = filter.IndexOf(',', ix);
                        if (nix == -1)
                        {
                            nix = filter.Length;
                        }
                        if (filter[ix] == '^')
                        {
                            if (testName.IndexOf(filter.Substring(ix + 1, (nix) - (ix + 1))) != -1)
                            {
                                result = -1;
                                break;
                            }
                        }
                        else
                        {
                            noIncludes = false;
                            if (testName.IndexOf(filter.Substring(ix, (nix) - (ix))) != -1)
                            {
                                result = 1;
                                if (noExcludes)
                                {
                                    break;
                                }
                            }
                        }

                        ix = nix + 1;
                    }
                    if (result == 0 && noIncludes)
                    {
                        result = 1;
                    }
                }
                // System.out.println("filter: " + testName + " returns: " +
                // result);
                return result;
            }

            /// <summary>
            /// Log access.
            /// </summary>
            ///
            /// <param name="msg">The string message to write</param>
            public void Write(String msg)
            {
                Write(msg, false);
            }

            public void Writeln(String msg)
            {
                Write(msg, true);
            }

            public void Write(String msg, bool newln)
            {
                if (!suppressIndent)
                {
                    if (needLineFeed)
                    {
                        log.WriteLine();
                        needLineFeed = false;
                    }
                    log.Write(IBM.ICU.Charset.TestFmwk.spaces.Substring(0, (indentLevel * 2) - (0)));
                }
                log.Write(msg);
                if (newln)
                {
                    log.WriteLine();
                }
                log.Flush();
                suppressIndent = !newln;
            }

            public void Msg(String message, int level_0, bool incCount,
                    bool newln)
            {
                if (level_0 == IBM.ICU.Charset.TestLog_Constants.WARN && (!warnings && !nodata))
                {
                    level_0 = IBM.ICU.Charset.TestLog_Constants.ERR;
                }

                if (incCount)
                {
                    if (level_0 == IBM.ICU.Charset.TestLog_Constants.WARN)
                    {
                        warnCount++;
                        invalidCount++;
                    }
                    else if (level_0 == IBM.ICU.Charset.TestLog_Constants.ERR)
                    {
                        errorCount++;
                    }
                }

                // should roll indentation stuff into log ???
                if (verbose || level_0 > ((quiet) ? IBM.ICU.Charset.TestLog_Constants.WARN : IBM.ICU.Charset.TestLog_Constants.LOG))
                {
                    if (!suppressIndent)
                    {
                        Indent(indentLevel + 1);
                        String[] MSGNAMES = { "", "Warning: ", "Error: " };
                        log.Write(MSGNAMES[level_0]);
                    }

                    log.Write(message);
                    if (newln)
                    {
                        log.WriteLine();
                    }
                    log.Flush();
                }

                if (level_0 == IBM.ICU.Charset.TestLog_Constants.ERR)
                {
                    if (!nothrow)
                    {
                        throw new Exception(message);
                    }
                    if (!suppressIndent && errorSummary != null && stack != null
                            && (errorCount == stack.ec + 1))
                    {
                        stack.AppendPath(errorSummary);
                        errorSummary.Append("\n");
                    }
                }

                suppressIndent = !newln;
            }

            internal void WriteTestInvalid(String name_0, bool nodataArg)
            {
                // msg("***" + name + "*** not found or not valid.", WARN, true,
                // true);
                if (InDocMode())
                {
                    if (!warnings)
                    {
                        if (stack != null)
                        {
                            stack.Flush();
                        }
                        log.WriteLine(" *** Target not found or not valid.");
                        log.Flush();
                        needLineFeed = false;
                    }
                }
                else
                {
                    if (!nodataArg)
                    {
                        Msg("Test " + name_0 + " not found or not valid.", IBM.ICU.Charset.TestLog_Constants.WARN,
                                true, true);
                    }
                }
            }

            internal long Getmem()
            {
                long newmem = 0;
                if (memusage)
                {
                    //Runtime rt = System.Runtime.GetRuntime();
                    long lastmem = Int64.MaxValue;
                    do
                    {
                        //rt.Gc();
                        //rt.Gc();
                        try
                        {
                            ILOG.J2CsMapping.Threading.ThreadWrapper.Sleep(50);
                        }
                        catch (Exception e)
                        {
                            break;
                        }
                        lastmem = newmem;
                        // newmem = rt.TotalMemory() - rt.FreeMemory();
                    } while (newmem < lastmem);
                }
                return newmem;
            }

            public void WriteTestResult()
            {
                if (InDocMode())
                {
                    if (needLineFeed)
                    {
                        log.WriteLine();
                        log.Flush();
                    }
                    needLineFeed = false;
                    return;
                }

                long dmem = Getmem() - stack.mem;
                long dtime = DateTime.Now.Millisecond - stack.millis;

                int testDelta = testCount - stack.tc;
                if (testDelta == 0)
                {
                    return;
                }

                int errorDelta = errorCount - stack.ec;
                int invalidDelta = invalidCount - stack.ic;

                stack.Flush();

                if (!needLineFeed)
                {
                    Indent(indentLevel);
                    log.Write("}");
                }
                needLineFeed = false;

                if (memusage || dtime >= timing)
                {
                    log.Write(" (");
                    if (memusage)
                    {
                        log.Write("dmem: " + dmem);
                    }
                    if (dtime >= timing)
                    {
                        if (memusage)
                        {
                            log.Write(", ");
                        }
                        log.Write(tformat.Format(dtime / 1000f));
                    }
                    log.Write(")");
                }
                if (errorDelta != 0)
                {
                    log.WriteLine(" FAILED ("
                            + errorDelta
                            + " failures"
                            + ((invalidDelta != 0) ? ", " + invalidDelta
                                    + " tests skipped)" : ")"));
                }
                else if (invalidDelta != 0)
                {
                    log.WriteLine(" Qualified (" + invalidDelta + " tests skipped)");
                }
                else
                {
                    log.WriteLine(" Passed");
                }
            }

            internal void Indent(int distance)
            {
                bool idm = InDocMode();
                if (needLineFeed)
                {
                    if (idm)
                    {
                        log.WriteLine();
                    }
                    else
                    {
                        log.WriteLine(" {");
                    }
                    needLineFeed = false;
                }

                log.Write(IBM.ICU.Charset.TestFmwk.spaces.Substring(0, (distance * ((idm) ? 3 : 2)) - (0)));

                if (idm)
                {
                    log.Write("-- ");
                }
            }
        }

        public String GetTranslitTestFilter()
        {
            return paras.tfilter;
        }

        /// <summary>
        /// Return the target name for a test class. This is either the end of the
        /// class name, or if the class declares a public static field
        /// CLASS_TARGET_NAME, the value of that field.
        /// </summary>
        ///
        static internal String GetClassTargetName(Type testClass)
        {
            String name_0 = testClass.FullName;
            try
            {
                FieldInfo f = testClass.GetField("CLASS_TARGET_NAME");
                name_0 = (String)f.GetValue(null);
            }
            catch (MemberAccessException e)
            {
                throw new InvalidOperationException(
                        "static field CLASS_TARGET_NAME must be accessible");
            }
            catch (Exception e_1)
            {
                int n = Math.Max(name_0.LastIndexOf('.'), name_0.LastIndexOf('$'));
                if (n != -1)
                {
                    name_0 = name_0.Substring(n + 1);
                }
            }
            return name_0;
        }

        /// <summary>
        /// Check the given array to see that all the strings in the expected array
        /// are present.
        /// </summary>
        ///
        /// <param name="msg">string message, for log output</param>
        /// <param name="array">array of strings to check</param>
        /// <param name="expected">array of strings we expect to see, or null</param>
        /// <returns>the length of 'array', or -1 on error</returns>
        protected internal int CheckArray(String msg, String[] array, String[] expected)
        {
            int explen = (expected != null) ? expected.Length : 0;
            if (!(explen >= 0 && explen < 31))
            { // [sic] 31 not 32
                Errln("Internal error");
                return -1;
            }
            int i = 0;
            StringBuilder buf = new StringBuilder();
            int seenMask = 0;
            for (; i < array.Length; ++i)
            {
                String s = array[i];
                if (i != 0)
                    buf.Append(", ");
                buf.Append(s);
                // check expected list
                for (int j = 0, bit = 1; j < explen; ++j, bit <<= 1)
                {
                    if ((seenMask & bit) == 0)
                    {
                        if (s.Equals(expected[j]))
                        {
                            seenMask |= bit;
                            Logln("Ok: \"" + s + "\" seen");
                        }
                    }
                }
            }
            Logln(msg + " = [" + buf + "] (" + i + ")");
            // did we see all expected strings?
            if (((1 << explen) - 1) != seenMask)
            {
                for (int j_0 = 0, bit_1 = 1; j_0 < expected.Length; ++j_0, bit_1 <<= 1)
                {
                    if ((seenMask & bit_1) == 0)
                    {
                        Errln("\"" + expected[j_0] + "\" not seen");
                    }
                }
            }
            return array.Length;
        }

        /// <summary>
        /// Check the given array to see that all the locales in the expected array
        /// are present.
        /// </summary>
        ///
        /// <param name="msg">string message, for log output</param>
        /// <param name="array">array of locales to check</param>
        /// <param name="expected">array of locales names we expect to see, or null</param>
        /// <returns>the length of 'array'</returns>
        protected internal int CheckArray(String msg, CultureInfo[] array, String[] expected)
        {
            String[] strs = new String[array.Length];
            for (int i = 0; i < array.Length; ++i)
                strs[i] = array[i].ToString();
            return CheckArray(msg, strs, expected);
        }

        /// <summary>
        /// Check the given array to see that all the locales in the expected array
        /// are present.
        /// </summary>
        ///
        /// <param name="msg">string message, for log output</param>
        /// <param name="array">array of locales to check</param>
        /// <param name="expected">array of locales names we expect to see, or null</param>
        /// <returns>the length of 'array'</returns>
        protected internal int CheckArray(String msg, ULocale[] array, String[] expected)
        {
            String[] strs = new String[array.Length];
            for (int i = 0; i < array.Length; ++i)
                strs[i] = array[i].ToString();
            return CheckArray(msg, strs, expected);
        }

        // JUnit-like assertions.

        protected internal bool AssertTrue(String message, bool condition)
        {
            return HandleAssert(condition, message, "true", null);
        }

        protected internal bool AssertFalse(String message, bool condition)
        {
            return HandleAssert(!condition, message, "false", null);
        }

        protected internal bool AssertEquals(String message, bool expected,
                bool actual)
        {
            return HandleAssert(expected == actual, message,
                    expected.ToString(), actual.ToString());
        }

        protected internal bool AssertEquals(String message, long expected, long actual)
        {
            return HandleAssert(expected == actual, message,
                    expected.ToString(), actual.ToString());
        }

        // do NaN and range calculations to precision of float, don't rely on
        // promotion to double
        protected internal bool AssertEquals(String message, float expected,
                float actual, double error)
        {
            bool result = (Single.IsInfinity((float)expected)) ? expected == actual
                    : !(Math.Abs(expected - actual) > error); // handles NaN
            return HandleAssert(result, message, expected.ToString()
                    + ((error == 0) ? "" : " (within " + error + ")"),
                    actual.ToString());
        }

        protected internal bool AssertEquals(String message, double expected,
                double actual, double error)
        {
            bool result = (Double.IsInfinity(expected)) ? expected == actual
                    : !(Math.Abs(expected - actual) > error); // handles NaN
            return HandleAssert(result, message, expected.ToString()
                    + ((error == 0) ? "" : " (within " + error + ")"),
                    actual.ToString());
        }

        protected internal bool AssertEquals(String message, Object expected,
                Object actual)
        {
            bool result = (expected == null) ? actual == null : expected
                    .Equals(actual);
            return HandleAssert(result, message, StringFor(expected),
                    StringFor(actual));
        }

        protected internal bool AssertNotEquals(String message, Object expected,
                Object actual)
        {
            bool result = !((expected == null) ? actual == null : expected
                    .Equals(actual));
            return HandleAssert(result, message, StringFor(expected),
                    StringFor(actual), "not equal to", true);
        }

        protected internal bool AssertSame(String message, Object expected, Object actual)
        {
            return HandleAssert(expected == actual, message, StringFor(expected),
                    StringFor(actual), "==", false);
        }

        protected internal bool AssertNotSame(String message, Object expected,
                Object actual)
        {
            return HandleAssert(expected != actual, message, StringFor(expected),
                    StringFor(actual), "!=", true);
        }

        protected internal bool AssertNull(String message, Object actual)
        {
            return HandleAssert(actual == null, message, null, StringFor(actual));
        }

        protected internal bool AssertNotNull(String message, Object actual)
        {
            return HandleAssert(actual != null, message, null, StringFor(actual),
                    "!=", true);
        }

        protected internal void Fail(String message)
        {
            Errln(message);
        }

        private bool HandleAssert(bool result, String message,
                String expected, String actual)
        {
            return HandleAssert(result, message, expected, actual, null, false);
        }

        private bool HandleAssert(bool result, String message,
                String expected, String actual, String relation, bool flip)
        {
            if (!result || IsVerbose())
            {
                message = (message == null) ? "" : " " + message;
                relation = (relation == null) ? ", got " : " " + relation + " ";
                if (result)
                {
                    Logln("OK" + message + ": "
                            + ((flip) ? expected + relation + actual : expected));
                }
                else
                {
                    // assert must assume errors are true errors and not just
                    // warnings
                    // so cannot warnln here
                    Errln(message
                            + ": expected"
                            + ((flip) ? relation + expected : " " + expected
                                    + ((actual != null) ? relation + actual : "")));
                }
            }
            return result;
        }

        private String StringFor(Object obj)
        {
            if (obj == null)
                return "null";
            if (obj is String)
                return "\"" + obj + '"';
            return obj.GetType().FullName + "<" + obj + ">";
        }

        // End JUnit-like assertions

        // PrintWriter support

        public StreamWriter GetErrorLogPrintWriter()
        {
            return ILOG.J2CsMapping.IO.IOUtility.NewStreamWriter(new TestLogWriter(this, IBM.ICU.Charset.TestLog_Constants.ERR)) /* Warning: if writer (arg) is a StringWriter exception raised */;
        }

        public StreamWriter GetLogPrintWriter()
        {
            return ILOG.J2CsMapping.IO.IOUtility.NewStreamWriter(new TestLogWriter(this, IBM.ICU.Charset.TestLog_Constants.LOG)) /* Warning: if writer (arg) is a StringWriter exception raised */;
        }

        // end PrintWriter support

        protected internal TestFmwk.TestParams paras = null;

        private const String spaces = "                                          ";

    }
}
