/*
 *******************************************************************************
 * Copyright (C) 1996-2007, International Business Machines Corporation and    *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 */

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:47 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Impl {
	
	using IBM.ICU.Text;
	using IBM.ICU.Util;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Resources;
	using System.Runtime.CompilerServices;
     using ILOG.J2CsMapping.IO;
	
	public sealed class NormalizerImpl {
	    // Static block for the class to initialize its own self
	    static internal readonly NormalizerImpl IMPL;
	
	    internal const int UNSIGNED_BYTE_MASK = 0xFF;
	
	    internal const long UNSIGNED_INT_MASK = 0xffffffffL;
	
	    /*
	     * This new implementation of the normalization code loads its data from
	     * unorm.icu, which is generated with the gennorm tool. The format of that
	     * file is described at the end of this file.
	     */
	    private const String DATA_FILE_NAME = IBM.ICU.Impl.ICUResourceBundle.ICU_BASE_NAME
	            + "/unorm.icu";
	
	    // norm32 value constants
	
	    // quick check flags 0..3 set mean "no" for their forms
	    public const int QC_NFC = 0x11; /* no|maybe */
	
	    public const int QC_NFKC = 0x22; /* no|maybe */
	
	    public const int QC_NFD = 4; /* no */
	
	    public const int QC_NFKD = 8; /* no */
	
	    public const int QC_ANY_NO = 0xf;
	
	    /*
	     * quick check flags 4..5 mean "maybe" for their forms; test flags>=QC_MAYBE
	     */
	    public const int QC_MAYBE = 0x10;
	
	    public const int QC_ANY_MAYBE = 0x30;
	
	    public const int QC_MASK = 0x3f;
	
	    private const int COMBINES_FWD = 0x40;
	
	    private const int COMBINES_BACK = 0x80;
	
	    public const int COMBINES_ANY = 0xc0;
	
	    // UnicodeData.txt combining class in bits 15.
	    private const int CC_SHIFT = 8;
	
	    public const int CC_MASK = 0xff00;
	
	    // 16 bits for the index to UChars and other extra data
	    private const int EXTRA_SHIFT = 16;
	
	    // start of surrogate specials after shift
	    // private static final int EXTRA_INDEX_TOP=0xfc00;
	
	    // private static final int EXTRA_SURROGATE_MASK=0x3ff;
	    // private static final int EXTRA_SURROGATE_TOP=0x3f0; /* hangul etc. */
	
	    // private static final int EXTRA_HANGUL=EXTRA_SURROGATE_TOP;
	    // private static final int EXTRA_JAMO_L=EXTRA_SURROGATE_TOP+1;/* ### not
	    // used */
	    // private static final int EXTRA_JAMO_V=EXTRA_SURROGATE_TOP+2;
	    // private static final int EXTRA_JAMO_T=EXTRA_SURROGATE_TOP+3;
	
	    /* norm32 value constants using >16 bits */
	    private const long MIN_SPECIAL = (long) (-67108864 & UNSIGNED_INT_MASK);
	
	    private const long SURROGATES_TOP = (long) (-1048576 & UNSIGNED_INT_MASK);
	
	    private const long MIN_HANGUL = (long) (-1048576 & UNSIGNED_INT_MASK);
	
	    // private static final long MIN_JAMO_V = (long)(0xfff20000 &
	    // UNSIGNED_INT_MASK);
	    private const long JAMO_V_TOP = (long) (-851968 & UNSIGNED_INT_MASK);
	
	    /* indexes[] value names */
	    /* number of bytes in normalization trie */
	    internal const int INDEX_TRIE_SIZE = 0;
	
	    /* number of chars in extra data */
	    internal const int INDEX_CHAR_COUNT = 1;
	
	    /* number of uint16_t words for combining data */
	    internal const int INDEX_COMBINE_DATA_COUNT = 2;
	
	    /* number of code points that combine forward */
	    internal const int INDEX_COMBINE_FWD_COUNT = 3;
	
	    /* number of code points that combine forward and backward */
	    internal const int INDEX_COMBINE_BOTH_COUNT = 4;
	
	    /* number of code points that combine backward */
	    internal const int INDEX_COMBINE_BACK_COUNT = 5;
	
	    /* first code point with quick check NFC NO/MAYBE */
	    public const int INDEX_MIN_NFC_NO_MAYBE = 6;
	
	    /* first code point with quick check NFKC NO/MAYBE */
	    public const int INDEX_MIN_NFKC_NO_MAYBE = 7;
	
	    /* first code point with quick check NFD NO/MAYBE */
	    public const int INDEX_MIN_NFD_NO_MAYBE = 8;
	
	    /* first code point with quick check NFKD NO/MAYBE */
	    public const int INDEX_MIN_NFKD_NO_MAYBE = 9;
	
	    /* number of bytes in FCD trie */
	    internal const int INDEX_FCD_TRIE_SIZE = 10;
	
	    /* number of bytes in the auxiliary trie */
	    internal const int INDEX_AUX_TRIE_SIZE = 11;
	
	    /* number of uint16_t in the array of serialized USet */
	    internal const int INDEX_CANON_SET_COUNT = 12;
	
	    /* changing this requires a new formatVersion */
	    internal const int INDEX_TOP = 32;
	
	    /* AUX constants */
	    /* value constants for auxTrie */
	    private const int AUX_UNSAFE_SHIFT = 11;
	
	    private const int AUX_COMP_EX_SHIFT = 10;
	
	    private const int AUX_NFC_SKIPPABLE_F_SHIFT = 12;
	
	    private const int AUX_MAX_FNC = ((int) 1 << AUX_COMP_EX_SHIFT);
	
	    private const int AUX_UNSAFE_MASK = (int) ((1 << AUX_UNSAFE_SHIFT) & UNSIGNED_INT_MASK);
	
	    private const int AUX_FNC_MASK = (int) ((AUX_MAX_FNC - 1) & UNSIGNED_INT_MASK);
	
	    private const int AUX_COMP_EX_MASK = (int) ((1 << AUX_COMP_EX_SHIFT) & UNSIGNED_INT_MASK);
	
	    private const long AUX_NFC_SKIP_F_MASK = ((UNSIGNED_INT_MASK & 1) << AUX_NFC_SKIPPABLE_F_SHIFT);
	
	    /* canonStartSets[0..31] contains indexes for what is in the array */
	    /* number of uint16_t in canonical starter sets */
	    internal const int SET_INDEX_CANON_SETS_LENGTH = 0;
	
	    /* number of uint16_t in the BMP search table (contains pairs) */
	    internal const int SET_INDEX_CANON_BMP_TABLE_LENGTH = 1;
	
	    /* number of uint16_t in the supplementary search table(contains triplets) */
	    internal const int SET_INDEX_CANON_SUPP_TABLE_LENGTH = 2;
	
	    /* changing this requires a new formatVersion */
	    internal const int SET_INDEX_TOP = 32;
	
	    internal const int CANON_SET_INDICIES_INDEX = 0;
	
	    internal const int CANON_SET_START_SETS_INDEX = 1;
	
	    internal const int CANON_SET_BMP_TABLE_INDEX = 2;
	
	    internal const int CANON_SET_SUPP_TABLE_INDEX = 3;
	
	    /* 14 bit indexes to canonical USerializedSets */
	    internal const int CANON_SET_MAX_CANON_SETS = 0x4000;
	
	    /*
	     * single-code point BMP sets are encoded directly in the search table
	     * except if result=0x4000..0x7fff
	     */
	    internal const int CANON_SET_BMP_MASK = 0xc000;
	
	    internal const int CANON_SET_BMP_IS_INDEX = 0x4000;
	
	    private const int MAX_BUFFER_SIZE = 20;
	
	    /// <exclude/>
	    /// <summary>
	    /// Internal option for cmpEquivFold() for decomposing. If not set, just do
	    /// strcasecmp().
	    /// </summary>
	    ///
	    public const int COMPARE_EQUIV = 0x80000;
	
	    /* Wrappers for Trie implementations */
	    internal sealed class NormTrieImpl : Trie.DataManipulate {
	        static internal IntTrie normTrie = null;
	
	        /// <summary>
	        /// Called by com.ibm.icu.util.Trie to extract from a lead surrogate's
	        /// data the index array offset of the indexes for that lead surrogate.
	        /// </summary>
	        ///
	        /// <param name="property">data value for a surrogate from the trie, including thefolding offset</param>
	        /// <returns>data offset or 0 if there is no data for the lead surrogate</returns>
	        /*
	         * normTrie: 32-bit trie result may contain a special extraData index
	         * with the folding offset
	         */
	        public int GetFoldingOffset(int value_ren) {
	            return IBM.ICU.Impl.NormalizerImpl.BMP_INDEX_LENGTH
	                    + ((value_ren >> (IBM.ICU.Impl.NormalizerImpl.EXTRA_SHIFT - IBM.ICU.Impl.NormalizerImpl.SURROGATE_BLOCK_BITS)) & (0x3ff << IBM.ICU.Impl.NormalizerImpl.SURROGATE_BLOCK_BITS));
	        }
	
	    }
	
	    internal sealed class FCDTrieImpl : Trie.DataManipulate {
	        static internal CharTrie fcdTrie = null;
	
	        /// <summary>
	        /// Called by com.ibm.icu.util.Trie to extract from a lead surrogate's
	        /// data the index array offset of the indexes for that lead surrogate.
	        /// </summary>
	        ///
	        /// <param name="property">data value for a surrogate from the trie, including thefolding offset</param>
	        /// <returns>data offset or 0 if there is no data for the lead surrogate</returns>
	        /* fcdTrie: the folding offset is the lead FCD value itself */
	        public int GetFoldingOffset(int value_ren) {
	            return value_ren;
	        }
	    }
	
	    internal sealed class AuxTrieImpl : Trie.DataManipulate {
	        static internal CharTrie auxTrie = null;
	
	        /// <summary>
	        /// Called by com.ibm.icu.util.Trie to extract from a lead surrogate's
	        /// data the index array offset of the indexes for that lead surrogate.
	        /// </summary>
	        ///
	        /// <param name="property">data value for a surrogate from the trie, including thefolding offset</param>
	        /// <returns>data offset or 0 if there is no data for the lead surrogate</returns>
	        /* auxTrie: the folding offset is in bits 9..0 of the 16-bit trie result */
	        public int GetFoldingOffset(int value_ren) {
	            return (int) (value_ren & IBM.ICU.Impl.NormalizerImpl.AUX_FNC_MASK) << IBM.ICU.Impl.NormalizerImpl.SURROGATE_BLOCK_BITS;
	        }
	    }
	
	    private static NormalizerImpl.FCDTrieImpl  fcdTrieImpl;
	
	    private static NormalizerImpl.NormTrieImpl  normTrieImpl;
	
	    private static NormalizerImpl.AuxTrieImpl  auxTrieImpl;
	
	    private static int[] indexes;
	
	    private static char[] combiningTable;
	
	    private static char[] extraData;
	
	    private static Object[] canonStartSets;
	
	    private static bool isDataLoaded;
	
	    private static bool isFormatVersion_2_1;
	
	    private static bool isFormatVersion_2_2;
	
	    private static byte[] unicodeVersion;
	
	    /// <summary>
	    /// Default buffer size of datafile
	    /// </summary>
	    ///
	    private const int DATA_BUFFER_SIZE = 25000;
	
	    /// <summary>
	    /// FCD check: everything below this code point is known to have a 0 lead
	    /// combining class
	    /// </summary>
	    ///
	    public const int MIN_WITH_LEAD_CC = 0x300;
	
	    /// <summary>
	    /// Bit 7 of the length byte for a decomposition string in extra data is a
	    /// flag indicating whether the decomposition string is preceded by a 16-bit
	    /// word with the leading and trailing cc of the decomposition (like for
	    /// A-umlaut); if not, then both cc's are zero (like for compatibility
	    /// ideographs).
	    /// </summary>
	    ///
	    private const int DECOMP_FLAG_LENGTH_HAS_CC = 0x80;
	
	    /// <summary>
	    /// Bits 6..0 of the length byte contain the actual length.
	    /// </summary>
	    ///
	    private const int DECOMP_LENGTH_MASK = 0x7f;
	
	    /// <summary>
	    /// Length of the BMP portion of the index (stage 1) array. 
	    /// </summary>
	    ///
	    private const int BMP_INDEX_LENGTH = 0x10000 >> IBM.ICU.Impl.Trie.INDEX_STAGE_1_SHIFT_;
	
	    /// <summary>
	    /// Number of bits of a trail surrogate that are used in index table lookups.
	    /// </summary>
	    ///
	    private const int SURROGATE_BLOCK_BITS = 10 - IBM.ICU.Impl.Trie.INDEX_STAGE_1_SHIFT_;
	
	    // public utility
	    public static int GetFromIndexesArr(int index) {
	        return indexes[index];
	    }
	
	    // protected constructor ---------------------------------------------
	
	    /// <summary>
	    /// Constructor
	    /// </summary>
	    ///
	    /// <exception cref="thrown">when data reading fails or data corrupted</exception>
	    private NormalizerImpl() {
	        // data should be loaded only once
	        if (!isDataLoaded) {
	
	            // jar access
	            Stream i = IBM.ICU.Impl.ICUData.GetRequiredStream(DATA_FILE_NAME);
	            BufferedStream b = new BufferedStream(i,DATA_BUFFER_SIZE);
	            NormalizerDataReader reader = new NormalizerDataReader(b);
	
	            // read the indexes
	            indexes = reader.ReadIndexes(NormalizerImpl.INDEX_TOP);
	
	            byte[] normBytes = new byte[indexes[NormalizerImpl.INDEX_TRIE_SIZE]];
	
	            int combiningTableTop = indexes[NormalizerImpl.INDEX_COMBINE_DATA_COUNT];
	            combiningTable = new char[combiningTableTop];
	
	            int extraDataTop = indexes[NormalizerImpl.INDEX_CHAR_COUNT];
	            extraData = new char[extraDataTop];
	
	            byte[] fcdBytes = new byte[indexes[NormalizerImpl.INDEX_FCD_TRIE_SIZE]];
	            byte[] auxBytes = new byte[indexes[NormalizerImpl.INDEX_AUX_TRIE_SIZE]];
	            canonStartSets = new Object[NormalizerImpl.CANON_SET_MAX_CANON_SETS];
	
	            fcdTrieImpl = new NormalizerImpl.FCDTrieImpl ();
	            normTrieImpl = new NormalizerImpl.NormTrieImpl ();
	            auxTrieImpl = new NormalizerImpl.AuxTrieImpl ();
	
	            // load the rest of the data data and initialize the data members
	            reader.Read(normBytes, fcdBytes, auxBytes, extraData,
	                    combiningTable, canonStartSets);
	
	            IBM.ICU.Impl.NormalizerImpl.NormTrieImpl.normTrie = new IntTrie(new DataInputStream(new MemoryStream(
	                    normBytes)), normTrieImpl);
	            IBM.ICU.Impl.NormalizerImpl.FCDTrieImpl.fcdTrie = new CharTrie(new DataInputStream(new MemoryStream(
	                    fcdBytes)), fcdTrieImpl);
	            IBM.ICU.Impl.NormalizerImpl.AuxTrieImpl.auxTrie = new CharTrie(new DataInputStream(new MemoryStream(
	                    auxBytes)), auxTrieImpl);
	
	            // we reached here without any exceptions so the data is fully
	            // loaded set the variable to true
	            isDataLoaded = true;
	
	            // get the data format version
	            byte[] formatVersion = reader.GetDataFormatVersion();
	
	            isFormatVersion_2_1 = (formatVersion[0] > 2 || (formatVersion[0] == 2 && formatVersion[1] >= 1));
	            isFormatVersion_2_2 = (formatVersion[0] > 2 || (formatVersion[0] == 2 && formatVersion[1] >= 2));
	            unicodeVersion = reader.GetUnicodeVersion();
	            b.Close();
	        }
	    }
	
	    /* ---------------------------------------------------------------------- */
	
	    /* Korean Hangul and Jamo constants */
	
	    public const int JAMO_L_BASE = 0x1100; /* "lead" jamo */
	
	    public const int JAMO_V_BASE = 0x1161; /* "vowel" jamo */
	
	    public const int JAMO_T_BASE = 0x11a7; /* "trail" jamo */
	
	    public const int HANGUL_BASE = 0xac00;
	
	    public const int JAMO_L_COUNT = 19;
	
	    public const int JAMO_V_COUNT = 21;
	
	    public const int JAMO_T_COUNT = 28;
	
	    public const int HANGUL_COUNT = JAMO_L_COUNT * JAMO_V_COUNT
	            * JAMO_T_COUNT;
	
	    private static bool IsHangulWithoutJamoT(char c) {
	        c -= ((Char)HANGUL_BASE);
	        return c < HANGUL_COUNT && c % JAMO_T_COUNT == 0;
	    }
	
	    /* norm32 helpers */
	
	    /* is this a norm32 with a regular index? */
	    private static bool IsNorm32Regular(long norm32) {
	        return norm32 < MIN_SPECIAL;
	    }
	
	    /* is this a norm32 with a special index for a lead surrogate? */
	    private static bool IsNorm32LeadSurrogate(long norm32) {
	        return MIN_SPECIAL <= norm32 && norm32 < SURROGATES_TOP;
	    }
	
	    /* is this a norm32 with a special index for a Hangul syllable or a Jamo? */
	    private static bool IsNorm32HangulOrJamo(long norm32) {
	        return norm32 >= MIN_HANGUL;
	    }
	
	    /*
	     * Given isNorm32HangulOrJamo(), is this a Hangul syllable or a Jamo?
	     */
	    // private static boolean isHangulJamoNorm32HangulOrJamoL(long norm32) {
	    // return norm32<MIN_JAMO_V;
	    // }
	
	    /*
	     * Given norm32 for Jamo V or T, is this a Jamo V?
	     */
	    private static bool IsJamoVTNorm32JamoV(long norm32) {
	        return norm32 < JAMO_V_TOP;
	    }
	
	    /* data access primitives ----------------------------------------------- */
	
	    public static long/* unsigned */GetNorm32(char c) {
	        return ((UNSIGNED_INT_MASK) & (IBM.ICU.Impl.NormalizerImpl.NormTrieImpl.normTrie.GetLeadValue(c)));
	    }
	
	    public static long/* unsigned */GetNorm32FromSurrogatePair(long norm32,
	            char c2) {
	        /*
	         * the surrogate index in norm32 stores only the number of the surrogate
	         * index block see gennorm/store.c/getFoldedNormValue()
	         */
	        return ((UNSIGNED_INT_MASK) & IBM.ICU.Impl.NormalizerImpl.NormTrieImpl.normTrie.GetTrailValue(
	                (int) norm32, c2));
	    }
	
	    private static long GetNorm32(int c) {
	        return (UNSIGNED_INT_MASK & (IBM.ICU.Impl.NormalizerImpl.NormTrieImpl.normTrie.GetCodePointValue(c)));
	    }
	
	    // private static long getNorm32(int c,int mask){
	    // long/*unsigned*/ norm32= getNorm32(UTF16.getLeadSurrogate(c));
	    // if(((norm32&mask)>0) && isNorm32LeadSurrogate(norm32)) {
	    // /* c is a lead surrogate, get the real norm32 */
	    // norm32=getNorm32FromSurrogatePair(norm32,UTF16.getTrailSurrogate(c));
	    // }
	    // return norm32;
	    // }
	
	    /*
	     * get a norm32 from text with complete code points (like from
	     * decompositions)
	     */
	    private static long/* unsigned */GetNorm32(char[] p, int start,
	            int/* unsigned */mask) {
	        long/* unsigned */norm32 = GetNorm32(p[start]);
	        if (((norm32 & mask) > 0) && IsNorm32LeadSurrogate(norm32)) {
	            /* *p is a lead surrogate, get the real norm32 */
	            norm32 = GetNorm32FromSurrogatePair(norm32, p[start + 1]);
	        }
	        return norm32;
	    }
	
	    public static VersionInfo GetUnicodeVersion() {
	        return IBM.ICU.Util.VersionInfo.GetInstance(unicodeVersion[0], unicodeVersion[1],
	                unicodeVersion[2], unicodeVersion[3]);
	    }
	
	    public static char GetFCD16(char c) {
	        return IBM.ICU.Impl.NormalizerImpl.FCDTrieImpl.fcdTrie.GetLeadValue(c);
	    }
	
	    public static char GetFCD16FromSurrogatePair(char fcd16, char c2) {
	        /*
	         * the surrogate index in fcd16 is an absolute offset over the start of
	         * stage 1
	         */
	        return IBM.ICU.Impl.NormalizerImpl.FCDTrieImpl.fcdTrie.GetTrailValue(fcd16, c2);
	    }
	
	    public static int GetFCD16(int c) {
	        return IBM.ICU.Impl.NormalizerImpl.FCDTrieImpl.fcdTrie.GetCodePointValue(c);
	    }
	
	    private static int GetExtraDataIndex(long norm32) {
	        return (int) (norm32 >> EXTRA_SHIFT);
	    }
	
	    private sealed class DecomposeArgs {
	        internal int /* unsigned byte */cc;
	
	        internal int /* unsigned byte */trailCC;
	
	        internal int length;
	    }
	
	    /// <summary>
	    /// get the canonical or compatibility decomposition for one character
	    /// </summary>
	    ///
	    /// <returns>index into the extraData array</returns>
	    private static int/* index */Decompose(long/* unsigned */norm32,
	            int/* unsigned */qcMask, NormalizerImpl.DecomposeArgs  args) {
	        int p = GetExtraDataIndex(norm32);
	        args.length = extraData[p++];
	
	        if ((norm32 & qcMask & QC_NFKD) != 0 && args.length >= 0x100) {
	            /* use compatibility decomposition, skip canonical data */
	            p += ((args.length >> 7) & 1) + (args.length & DECOMP_LENGTH_MASK);
	            args.length >>= 8;
	        }
	
	        if ((args.length & DECOMP_FLAG_LENGTH_HAS_CC) > 0) {
	            /* get the lead and trail cc's */
	            char bothCCs = extraData[p++];
	            args.cc = (UNSIGNED_BYTE_MASK) & (bothCCs >> 8);
	            args.trailCC = (UNSIGNED_BYTE_MASK) & bothCCs;
	        } else {
	            /* lead and trail cc's are both 0 */
	            args.cc = args.trailCC = 0;
	        }
	
	        args.length &= DECOMP_LENGTH_MASK;
	        return p;
	    }
	
	    /// <summary>
	    /// get the canonical decomposition for one character
	    /// </summary>
	    ///
	    /// <returns>index into the extraData array</returns>
	    private static int Decompose(long/* unsigned */norm32, NormalizerImpl.DecomposeArgs  args) {
	
	        int p = GetExtraDataIndex(norm32);
	        args.length = extraData[p++];
	
	        if ((args.length & DECOMP_FLAG_LENGTH_HAS_CC) > 0) {
	            /* get the lead and trail cc's */
	            char bothCCs = extraData[p++];
	            args.cc = (UNSIGNED_BYTE_MASK) & (bothCCs >> 8);
	            args.trailCC = (UNSIGNED_BYTE_MASK) & bothCCs;
	        } else {
	            /* lead and trail cc's are both 0 */
	            args.cc = args.trailCC = 0;
	        }
	
	        args.length &= DECOMP_LENGTH_MASK;
	        return p;
	    }
	
	    private sealed class NextCCArgs {
	        internal char[] source;
	
	        internal int next;
	
	        internal int limit;
	
	        internal char c;
	
	        internal char c2;
	    }
	
	    /*
	     * get the combining class of (c, c2)= args.source[args.next++] before:
	     * args.next<args.limit after: args.next<=args.limit if only one code unit
	     * is used, then c2==0
	     */
	    private static int /* unsigned byte */GetNextCC(NormalizerImpl.NextCCArgs  args) {
	        long /* unsigned */norm32;
	
	        args.c = args.source[args.next++];
	
	        norm32 = GetNorm32(args.c);
	        if ((norm32 & CC_MASK) == 0) {
	            args.c2 = ((Char)0);
	            return 0;
	        } else {
	            if (!IsNorm32LeadSurrogate(norm32)) {
	                args.c2 = ((Char)0);
	            } else {
	                /* c is a lead surrogate, get the real norm32 */
	                if (args.next != args.limit
	                        && IBM.ICU.Text.UTF16.IsTrailSurrogate(args.c2 = args.source[args.next])) {
	                    ++args.next;
	                    norm32 = GetNorm32FromSurrogatePair(norm32, args.c2);
	                } else {
	                    args.c2 = ((Char)0);
	                    return 0;
	                }
	            }
	
	            return (int) ((UNSIGNED_BYTE_MASK) & (norm32 >> CC_SHIFT));
	        }
	    }
	
	    private sealed class PrevArgs {
	        internal char[] src;
	
	        internal int start;
	
	        internal int current;
	
	        internal char c;
	
	        internal char c2;
	    }
	
	    /*
	     * read backwards and get norm32 return 0 if the character is <minC if c2!=0
	     * then (c2, c) is a surrogate pair (reversed - c2 is first surrogate but
	     * read second!)
	     */
	    private static long /* unsigned */GetPrevNorm32(NormalizerImpl.PrevArgs  args,
	            int/* unsigned */minC, int/* unsigned */mask) {
	        long/* unsigned */norm32;
	
	        args.c = args.src[--args.current];
	        args.c2 = ((Char)0);
	
	        /*
	         * check for a surrogate before getting norm32 to see if we need to
	         * predecrement further
	         */
	        if (args.c < minC) {
	            return 0;
	        } else if (!IBM.ICU.Text.UTF16.IsSurrogate(args.c)) {
	            return GetNorm32(args.c);
	        } else if (IBM.ICU.Text.UTF16.IsLeadSurrogate(args.c)) {
	            /* unpaired first surrogate */
	            return 0;
	        } else if (args.current != args.start
	                && IBM.ICU.Text.UTF16.IsLeadSurrogate(args.c2 = args.src[args.current - 1])) {
	            --args.current;
	            norm32 = GetNorm32(args.c2);
	
	            if ((norm32 & mask) == 0) {
	                /*
	                 * all surrogate pairs with this lead surrogate have only
	                 * irrelevant data
	                 */
	                return 0;
	            } else {
	                /* norm32 must be a surrogate special */
	                return GetNorm32FromSurrogatePair(norm32, args.c);
	            }
	        } else {
	            /* unpaired second surrogate */
	            args.c2 = ((Char)0);
	            return 0;
	        }
	    }
	
	    /*
	     * get the combining class of (c, c2)=*--p before: start<p after: start<=p
	     */
	    private static int /* unsigned byte */GetPrevCC(NormalizerImpl.PrevArgs  args) {
	
	        return (int) ((UNSIGNED_BYTE_MASK) & (GetPrevNorm32(args,
	                MIN_WITH_LEAD_CC, CC_MASK) >> CC_SHIFT));
	    }
	
	    /*
	     * is this a safe boundary character for NF*D? (lead cc==0)
	     */
	    public static bool IsNFDSafe(long/* unsigned */norm32,
	            int/* unsigned */ccOrQCMask, int/* unsigned */decompQCMask) {
	        if ((norm32 & ccOrQCMask) == 0) {
	            return true; /* cc==0 and no decomposition: this is NF*D safe */
	        }
	
	        /* inspect its decomposition - maybe a Hangul but not a surrogate here */
	        if (IsNorm32Regular(norm32) && (norm32 & decompQCMask) != 0) {
	            NormalizerImpl.DecomposeArgs  args = new NormalizerImpl.DecomposeArgs ();
	            /* decomposes, get everything from the variable-length extra data */
	            Decompose(norm32, decompQCMask, args);
	            return args.cc == 0;
	        } else {
	            /* no decomposition (or Hangul), test the cc directly */
	            return (norm32 & CC_MASK) == 0;
	        }
	    }
	
	    /*
	     * is this (or does its decomposition begin with) a "true starter"? (cc==0
	     * and NF*C_YES)
	     */
	    public static bool IsTrueStarter(long/* unsigned */norm32,
	            int/* unsigned */ccOrQCMask, int/* unsigned */decompQCMask) {
	        if ((norm32 & ccOrQCMask) == 0) {
	            return true; /* this is a true starter (could be Hangul or Jamo L) */
	        }
	
	        /* inspect its decomposition - not a Hangul or a surrogate here */
	        if ((norm32 & decompQCMask) != 0) {
	            int p; /* index into extra data array */
	            NormalizerImpl.DecomposeArgs  args = new NormalizerImpl.DecomposeArgs ();
	            /* decomposes, get everything from the variable-length extra data */
	            p = Decompose(norm32, decompQCMask, args);
	
	            if (args.cc == 0) {
	                int/* unsigned */qcMask = ccOrQCMask & QC_MASK;
	
	                /* does it begin with NFC_YES? */
	                if ((GetNorm32(extraData, p, qcMask) & qcMask) == 0) {
	                    /* yes, the decomposition begins with a true starter */
	                    return true;
	                }
	            }
	        }
	        return false;
	    }
	
	    /* reorder UTF-16 in-place ---------------------------------------------- */
	
	    /// <summary>
	    /// simpler, single-character version of mergeOrdered() - bubble-insert one
	    /// single code point into the preceding string which is already canonically
	    /// ordered (c, c2) may or may not yet have been inserted at
	    /// src[current]..src[p]
	    /// it must be p=current+lengthof(c, c2) i.e. p=current+(c2==0 ? 1 : 2)
	    /// before: src[start]..src[current] is already ordered, and
	    /// src[current]..src[p] may or may not hold (c, c2) but must be exactly the
	    /// same length as (c, c2) after: src[start]..src[p] is ordered
	    /// </summary>
	    ///
	    /// <returns>the trailing combining class</returns>
	    private static int/* unsigned byte */InsertOrdered(char[] source_0,
	            int start_1, int current_2, int p, char c_3, char c2_4,
	            int/* unsigned byte */cc_5) {
	        int back, preBack;
	        int r;
	        int prevCC, trailCC_6 = cc_5;
	
	        if (start_1 < current_2 && cc_5 != 0) {
	            // search for the insertion point where cc>=prevCC
	            preBack = back = current_2;
	            NormalizerImpl.PrevArgs  prevArgs = new NormalizerImpl.PrevArgs ();
	            prevArgs.current = current_2;
	            prevArgs.start = start_1;
	            prevArgs.src = source_0;
	            // get the prevCC
	            prevCC = GetPrevCC(prevArgs);
	            preBack = prevArgs.current;
	
	            if (cc_5 < prevCC) {
	                // this will be the last code point, so keep its cc
	                trailCC_6 = prevCC;
	                back = preBack;
	                while (start_1 < preBack) {
	                    prevCC = GetPrevCC(prevArgs);
	                    preBack = prevArgs.current;
	                    if (cc_5 >= prevCC) {
	                        break;
	                    }
	                    back = preBack;
	                }
	
	                // this is where we are right now with all these indicies:
	                // [start]..[pPreBack] 0..? code points that we can ignore
	                // [pPreBack]..[pBack] 0..1 code points with prevCC<=cc
	                // [pBack]..[current] 0..n code points with >cc, move up to
	                // insert (c, c2)
	                // [current]..[p] 1 code point (c, c2) with cc
	
	                // move the code units in between up
	                r = p;
	                do {
	                    source_0[--r] = source_0[--current_2];
	                } while (back != current_2);
	            }
	        }
	
	        // insert (c, c2)
	        source_0[current_2] = c_3;
	        if (c2_4 != 0) {
	            source_0[(current_2 + 1)] = c2_4;
	        }
	
	        // we know the cc of the last code point
	        return trailCC_6;
	    }
	
	    /// <summary>
	    /// merge two UTF-16 string parts together to canonically order (order by
	    /// combining classes) their concatenation
	    /// the two strings may already be adjacent, so that the merging is done
	    /// in-place if the two strings are not adjacent, then the buffer holding the
	    /// first one must be large enough the second string may or may not be
	    /// ordered in itself
	    /// before: [start]..[current] is already ordered, and [next]..[limit] may be
	    /// ordered in itself, but is not in relation to [start..current[ after:
	    /// [start..current+(limit-next)[ is ordered
	    /// the algorithm is a simple bubble-sort that takes the characters from
	    /// src[next++] and inserts them in correct combining class order into the
	    /// preceding part of the string
	    /// since this function is called much less often than the single-code point
	    /// insertOrdered(), it just uses that for easier maintenance
	    /// </summary>
	    ///
	    /// <returns>the trailing combining class</returns>
	    private static int /* unsigned byte */MergeOrdered(char[] source_0,
	            int start_1, int current_2, char[] data, int next_3, int limit_4,
	            bool isOrdered) {
	        int r;
	        int /* unsigned byte */cc_5, trailCC_6 = 0;
	        bool adjacent;
	
	        adjacent = current_2 == next_3;
	        NormalizerImpl.NextCCArgs  ncArgs = new NormalizerImpl.NextCCArgs ();
	        ncArgs.source = data;
	        ncArgs.next = next_3;
	        ncArgs.limit = limit_4;
	
	        if (start_1 != current_2 || !isOrdered) {
	
	            while (ncArgs.next < ncArgs.limit) {
	                cc_5 = GetNextCC(ncArgs);
	                if (cc_5 == 0) {
	                    // does not bubble back
	                    trailCC_6 = 0;
	                    if (adjacent) {
	                        current_2 = ncArgs.next;
	                    } else {
	                        data[current_2++] = ncArgs.c;
	                        if (ncArgs.c2 != 0) {
	                            data[current_2++] = ncArgs.c2;
	                        }
	                    }
	                    if (isOrdered) {
	                        break;
	                    } else {
	                        start_1 = current_2;
	                    }
	                } else {
	                    r = current_2 + ((ncArgs.c2 == 0) ? 1 : 2);
	                    trailCC_6 = InsertOrdered(source_0, start_1, current_2, r,
	                            ncArgs.c, ncArgs.c2, cc_5);
	                    current_2 = r;
	                }
	            }
	        }
	
	        if (ncArgs.next == ncArgs.limit) {
	            // we know the cc of the last code point
	            return trailCC_6;
	        } else {
	            if (!adjacent) {
	                // copy the second string part
	                do {
	                    source_0[current_2++] = data[ncArgs.next++];
	                } while (ncArgs.next != ncArgs.limit);
	                ncArgs.limit = current_2;
	            }
	            NormalizerImpl.PrevArgs  prevArgs = new NormalizerImpl.PrevArgs ();
	            prevArgs.src = data;
	            prevArgs.start = start_1;
	            prevArgs.current = ncArgs.limit;
	            return GetPrevCC(prevArgs);
	        }
	
	    }
	
	    private static int /* unsigned byte */MergeOrdered(char[] source_0,
	            int start_1, int current_2, char[] data, int next_3, int limit_4) {
	        return MergeOrdered(source_0, start_1, current_2, data, next_3, limit_4, true);
	    }
	
	    public static bool CheckFCD(char[] src_0, int srcStart, int srcLimit,
	            UnicodeSet nx) {
	
	        char fcd16, c_1, c2_2;
	        int prevCC = 0, cc_3;
	        int i = srcStart, length_4 = srcLimit;
	
	        for (;;) {
	            for (;;) {
	                if (i == length_4) {
	                    return true;
	                } else if ((c_1 = src_0[i++]) < MIN_WITH_LEAD_CC) {
	                    prevCC = (int) -c_1;
	                } else if ((fcd16 = GetFCD16(c_1)) == 0) {
	                    prevCC = 0;
	                } else {
	                    break;
	                }
	            }
	
	            // check one above-minimum, relevant code unit
	            if (IBM.ICU.Text.UTF16.IsLeadSurrogate(c_1)) {
	                // c is a lead surrogate, get the real fcd16
	                if (i != length_4 && IBM.ICU.Text.UTF16.IsTrailSurrogate(c2_2 = src_0[i])) {
	                    ++i;
	                    fcd16 = GetFCD16FromSurrogatePair(fcd16, c2_2);
	                } else {
	                    c2_2 = ((Char)0);
	                    fcd16 = ((Char)0);
	                }
	            } else {
	                c2_2 = ((Char)0);
	            }
	
	            if (Nx_contains(nx, c_1, c2_2)) {
	                prevCC = 0; /* excluded: fcd16==0 */
	                continue;
	            }
	
	            // prevCC has values from the following ranges:
	            // 0..0xff -the previous trail combining class
	            // <0 -the negative value of the previous code unit;
	            // that code unit was <MIN_WITH_LEAD_CC and its getFCD16()
	            // was deferred so that average text is checked faster
	            //
	
	            // check the combining order
	            cc_3 = (int) (fcd16 >> 8);
	            if (cc_3 != 0) {
	                if (prevCC < 0) {
	                    // the previous character was <_NORM_MIN_WITH_LEAD_CC,
	                    // we need to get its trail cc
	                    //
	                    if (!Nx_contains(nx, (int) -prevCC)) {
	                        prevCC = (int) (IBM.ICU.Impl.NormalizerImpl.FCDTrieImpl.fcdTrie
	                                .GetBMPValue((char) -prevCC) & 0xff);
	                    } else {
	                        prevCC = 0; /* excluded: fcd16==0 */
	                    }
	
	                }
	
	                if (cc_3 < prevCC) {
	                    return false;
	                }
	            }
	            prevCC = (int) (fcd16 & 0xff);
	        }
	    }
	
	    public static Normalizer.QuickCheckResult QuickCheck(char[] src_0,
	            int srcStart, int srcLimit, int minNoMaybe, int qcMask,
	            int options, bool allowMaybe, UnicodeSet nx) {
	
	        int ccOrQCMask;
	        long norm32;
	        char c_1, c2_2;
	        char cc_3, prevCC;
	        long qcNorm32;
	        Normalizer.QuickCheckResult result;
	        NormalizerImpl.ComposePartArgs  args = new NormalizerImpl.ComposePartArgs ();
	        char[] buffer;
	        int start_4 = srcStart;
	
	        if (!isDataLoaded) {
	            return IBM.ICU.Text.Normalizer.MAYBE;
	        }
	        // initialize
	        ccOrQCMask = CC_MASK | qcMask;
	        result = IBM.ICU.Text.Normalizer.YES;
	        prevCC = ((Char)0);
	
	        for (;;) {
	            for (;;) {
	                if (srcStart == srcLimit) {
	                    return result;
	                } else if ((c_1 = src_0[srcStart++]) >= minNoMaybe
	                        && ((norm32 = GetNorm32(c_1)) & ccOrQCMask) != 0) {
	                    break;
	                }
	                prevCC = ((Char)0);
	            }
	
	            // check one above-minimum, relevant code unit
	            if (IsNorm32LeadSurrogate(norm32)) {
	                // c is a lead surrogate, get the real norm32
	                if (srcStart != srcLimit
	                        && IBM.ICU.Text.UTF16.IsTrailSurrogate(c2_2 = src_0[srcStart])) {
	                    ++srcStart;
	                    norm32 = GetNorm32FromSurrogatePair(norm32, c2_2);
	                } else {
	                    norm32 = 0;
	                    c2_2 = ((Char)0);
	                }
	            } else {
	                c2_2 = ((Char)0);
	            }
	            if (Nx_contains(nx, c_1, c2_2)) {
	                /* excluded: norm32==0 */
	                norm32 = 0;
	            }
	
	            // check the combining order
	            cc_3 = (char) ((norm32 >> CC_SHIFT) & 0xFF);
	            if (cc_3 != 0 && cc_3 < prevCC) {
	                return IBM.ICU.Text.Normalizer.NO;
	            }
	            prevCC = cc_3;
	
	            // check for "no" or "maybe" quick check flags
	            qcNorm32 = norm32 & qcMask;
	            if ((qcNorm32 & QC_ANY_NO) >= 1) {
	                result = IBM.ICU.Text.Normalizer.NO;
	                break;
	            } else if (qcNorm32 != 0) {
	                // "maybe" can only occur for NFC and NFKC
	                if (allowMaybe) {
	                    result = IBM.ICU.Text.Normalizer.MAYBE;
	                } else {
	                    // normalize a section around here to see if it is really
	                    // normalized or not
	                    int prevStarter;
	                    int/* unsigned */decompQCMask;
	
	                    decompQCMask = (qcMask << 2) & 0xf; // decomposition quick
	                                                        // check mask
	
	                    // find the previous starter
	
	                    // set prevStarter to the beginning of the current character
	                    prevStarter = srcStart - 1;
	                    if (IBM.ICU.Text.UTF16.IsTrailSurrogate(src_0[prevStarter])) {
	                        // safe because unpaired surrogates do not result
	                        // in "maybe"
	                        --prevStarter;
	                    }
	
	                    prevStarter = FindPreviousStarter(src_0, start_4, prevStarter,
	                            ccOrQCMask, decompQCMask, (char) minNoMaybe);
	
	                    // find the next true starter in [src..limit[ - modifies
	                    // src to point to the next starter
	                    srcStart = FindNextStarter(src_0, srcStart, srcLimit, qcMask,
	                            decompQCMask, (char) minNoMaybe);
	
	                    // set the args for compose part
	                    args.prevCC = prevCC;
	
	                    // decompose and recompose [prevStarter..src[
	                    buffer = ComposePart(args, prevStarter, src_0, srcStart,
	                            srcLimit, options, nx);
	
	                    // compare the normalized version with the original
	                    if (0 != StrCompare(buffer, 0, args.length, src_0,
	                            prevStarter, srcStart, false)) {
	                        result = IBM.ICU.Text.Normalizer.NO; // normalization differs
	                        break;
	                    }
	
	                    // continue after the next starter
	                }
	            }
	        }
	        return result;
	    }
	
	    // ------------------------------------------------------
	    // make NFD & NFKD
	    // ------------------------------------------------------
	    public static int GetDecomposition(int c_0 /* UTF-32 */, bool compat,
	            char[] dest, int destStart, int destCapacity) {
	
	        if ((UNSIGNED_INT_MASK & c_0) <= 0x10ffff) {
	            long /* unsigned */norm32;
	            int qcMask;
	            int minNoMaybe;
	            int length_1;
	
	            // initialize
	            if (!compat) {
	                minNoMaybe = (int) indexes[INDEX_MIN_NFD_NO_MAYBE];
	                qcMask = QC_NFD;
	            } else {
	                minNoMaybe = (int) indexes[INDEX_MIN_NFKD_NO_MAYBE];
	                qcMask = QC_NFKD;
	            }
	
	            if (c_0 < minNoMaybe) {
	                // trivial case
	                if (destCapacity > 0) {
	                    dest[0] = (char) c_0;
	                }
	                return -1;
	            }
	
	            /* data lookup */
	            norm32 = GetNorm32(c_0);
	            if ((norm32 & qcMask) == 0) {
	                /* simple case: no decomposition */
	                if (c_0 <= 0xffff) {
	                    if (destCapacity > 0) {
	                        dest[0] = (char) c_0;
	                    }
	                    return -1;
	                } else {
	                    if (destCapacity >= 2) {
	                        dest[0] = IBM.ICU.Text.UTF16.GetLeadSurrogate(c_0);
	                        dest[1] = IBM.ICU.Text.UTF16.GetTrailSurrogate(c_0);
	                    }
	                    return -2;
	                }
	            } else if (IsNorm32HangulOrJamo(norm32)) {
	                /* Hangul syllable: decompose algorithmically */
	                char c2_2;
	
	                c_0 -= HANGUL_BASE;
	
	                c2_2 = (char) (c_0 % JAMO_T_COUNT);
	                c_0 /= JAMO_T_COUNT;
	                if (c2_2 > 0) {
	                    if (destCapacity >= 3) {
	                        dest[2] = (char) (JAMO_T_BASE + c2_2);
	                    }
	                    length_1 = 3;
	                } else {
	                    length_1 = 2;
	                }
	
	                if (destCapacity >= 2) {
	                    dest[1] = (char) (JAMO_V_BASE + c_0 % JAMO_V_COUNT);
	                    dest[0] = (char) (JAMO_L_BASE + c_0 / JAMO_V_COUNT);
	                }
	                return length_1;
	            } else {
	                /*
	                 * c decomposes, get everything from the variable-length extra
	                 * data
	                 */
	                int p, limit_3;
	                NormalizerImpl.DecomposeArgs  args = new NormalizerImpl.DecomposeArgs ();
	                /* the index into extra data array */
	                p = Decompose(norm32, qcMask, args);
	                if (args.length <= destCapacity) {
	                    limit_3 = p + args.length;
	                    do {
	                        dest[destStart++] = extraData[p++];
	                    } while (p < limit_3);
	                }
	                return args.length;
	            }
	        } else {
	            return 0;
	        }
	    }
	
	    public static int Decompose(char[] src_0, int srcStart, int srcLimit,
	            char[] dest, int destStart, int destLimit, bool compat,
	            int[] outTrailCC, UnicodeSet nx) {
	
	        char[] buffer = new char[3];
	        int prevSrc;
	        long norm32;
	        int ccOrQCMask, qcMask;
	        int reorderStartIndex, length_1;
	        char c_2, c2_3, minNoMaybe;
	        int/* unsigned byte */cc_4, prevCC, trailCC_5;
	        char[] p;
	        int pStart;
	        int destIndex = destStart;
	        int srcIndex = srcStart;
	        if (!compat) {
	            minNoMaybe = (char) indexes[INDEX_MIN_NFD_NO_MAYBE];
	            qcMask = QC_NFD;
	        } else {
	            minNoMaybe = (char) indexes[INDEX_MIN_NFKD_NO_MAYBE];
	            qcMask = QC_NFKD;
	        }
	
	        /* initialize */
	        ccOrQCMask = CC_MASK | qcMask;
	        reorderStartIndex = 0;
	        prevCC = 0;
	        norm32 = 0;
	        c_2 = ((Char)0);
	        pStart = 0;
	
	        cc_4 = trailCC_5 = -1;// initialize to bogus value
	
	        for (;;) {
	            /*
	             * count code units below the minimum or with irrelevant data for
	             * the quick check
	             */
	            prevSrc = srcIndex;
	
	            while (srcIndex != srcLimit
	                    && ((c_2 = src_0[srcIndex]) < minNoMaybe || ((norm32 = GetNorm32(c_2)) & ccOrQCMask) == 0)) {
	                prevCC = 0;
	                ++srcIndex;
	            }
	
	            /* copy these code units all at once */
	            if (srcIndex != prevSrc) {
	                length_1 = (int) (srcIndex - prevSrc);
	                if ((destIndex + length_1) <= destLimit) {
	                    System.Array.Copy((Array)(src_0),prevSrc,(Array)(dest),destIndex,length_1);
	                }
	
	                destIndex += length_1;
	                reorderStartIndex = destIndex;
	            }
	
	            /* end of source reached? */
	            if (srcIndex == srcLimit) {
	                break;
	            }
	
	            /* c already contains *src and norm32 is set for it, increment src */
	            ++srcIndex;
	
	            /* check one above-minimum, relevant code unit */
	            /*
	             * generally, set p and length to the decomposition string in simple
	             * cases, p==NULL and (c, c2) will hold the length code units to
	             * append in all cases, set cc to the lead and trailCC to the trail
	             * combining class
	             * 
	             * the following merge-sort of the current character into the
	             * preceding, canonically ordered result text will use the optimized
	             * insertOrdered() if there is only one single code point to
	             * process; this is indicated with p==NULL, and (c, c2) is the
	             * character to insert ((c, 0) for a BMP character and (lead
	             * surrogate, trail surrogate) for a supplementary character)
	             * otherwise, p[length] is merged in with _mergeOrdered()
	             */
	            if (IsNorm32HangulOrJamo(norm32)) {
	                if (Nx_contains(nx, c_2)) {
	                    c2_3 = ((Char)0);
	                    p = null;
	                    length_1 = 1;
	                } else {
	                    // Hangul syllable: decompose algorithmically
	                    p = buffer;
	                    pStart = 0;
	                    cc_4 = trailCC_5 = 0;
	
	                    c_2 -= ((Char)HANGUL_BASE);
	
	                    c2_3 = (char) (c_2 % JAMO_T_COUNT);
	                    c_2 /= ((Char)JAMO_T_COUNT);
	                    if (c2_3 > 0) {
	                        buffer[2] = (char) (JAMO_T_BASE + c2_3);
	                        length_1 = 3;
	                    } else {
	                        length_1 = 2;
	                    }
	
	                    buffer[1] = (char) (JAMO_V_BASE + c_2 % JAMO_V_COUNT);
	                    buffer[0] = (char) (JAMO_L_BASE + c_2 / JAMO_V_COUNT);
	                }
	            } else {
	                if (IsNorm32Regular(norm32)) {
	                    c2_3 = ((Char)0);
	                    length_1 = 1;
	                } else {
	                    // c is a lead surrogate, get the real norm32
	                    if (srcIndex != srcLimit
	                            && IBM.ICU.Text.UTF16.IsTrailSurrogate(c2_3 = src_0[srcIndex])) {
	                        ++srcIndex;
	                        length_1 = 2;
	                        norm32 = GetNorm32FromSurrogatePair(norm32, c2_3);
	                    } else {
	                        c2_3 = ((Char)0);
	                        length_1 = 1;
	                        norm32 = 0;
	                    }
	                }
	
	                /* get the decomposition and the lead and trail cc's */
	                if (Nx_contains(nx, c_2, c2_3)) {
	                    /* excluded: norm32==0 */
	                    cc_4 = trailCC_5 = 0;
	                    p = null;
	                } else if ((norm32 & qcMask) == 0) {
	                    /* c does not decompose */
	                    cc_4 = trailCC_5 = (int) ((UNSIGNED_BYTE_MASK) & (norm32 >> CC_SHIFT));
	                    p = null;
	                    pStart = -1;
	                } else {
	                    NormalizerImpl.DecomposeArgs  arg = new NormalizerImpl.DecomposeArgs ();
	                    /*
	                     * c decomposes, get everything from the variable-length
	                     * extra data
	                     */
	                    pStart = Decompose(norm32, qcMask, arg);
	                    p = extraData;
	                    length_1 = arg.length;
	                    cc_4 = arg.cc;
	                    trailCC_5 = arg.trailCC;
	                    if (length_1 == 1) {
	                        /* fastpath a single code unit from decomposition */
	                        c_2 = p[pStart];
	                        c2_3 = ((Char)0);
	                        p = null;
	                        pStart = -1;
	                    }
	                }
	            }
	
	            /*
	             * append the decomposition to the destination buffer, assume
	             * length>0
	             */
	            if ((destIndex + length_1) <= destLimit) {
	                int reorderSplit = destIndex;
	                if (p == null) {
	                    /* fastpath: single code point */
	                    if (cc_4 != 0 && cc_4 < prevCC) {
	                        /*
	                         * (c, c2) is out of order with respect to the preceding
	                         * text
	                         */
	                        destIndex += length_1;
	                        trailCC_5 = InsertOrdered(dest, reorderStartIndex,
	                                reorderSplit, destIndex, c_2, c2_3, cc_4);
	                    } else {
	                        /* just append (c, c2) */
	                        dest[destIndex++] = c_2;
	                        if (c2_3 != 0) {
	                            dest[destIndex++] = c2_3;
	                        }
	                    }
	                } else {
	                    /*
	                     * general: multiple code points (ordered by themselves)
	                     * from decomposition
	                     */
	                    if (cc_4 != 0 && cc_4 < prevCC) {
	                        /*
	                         * the decomposition is out of order with respect to the
	                         * preceding text
	                         */
	                        destIndex += length_1;
	                        trailCC_5 = MergeOrdered(dest, reorderStartIndex,
	                                reorderSplit, p, pStart, pStart + length_1);
	                    } else {
	                        /* just append the decomposition */
	                        do {
	                            dest[destIndex++] = p[pStart++];
	                        } while (--length_1 > 0);
	                    }
	                }
	            } else {
	                /* buffer overflow */
	                /* keep incrementing the destIndex for preflighting */
	                destIndex += length_1;
	            }
	
	            prevCC = trailCC_5;
	            if (prevCC == 0) {
	                reorderStartIndex = destIndex;
	            }
	        }
	
	        outTrailCC[0] = prevCC;
	
	        return destIndex - destStart;
	    }
	
	    /* make NFC & NFKC ------------------------------------------------------ */
	    private sealed class NextCombiningArgs {
	        internal char[] source;
	
	        internal int start;
	
	        // int limit;
	        internal char c;
	
	        internal char c2;
	
	        internal int/* unsigned */combiningIndex;
	
	        internal char /* unsigned byte */cc;
	    }
	
	    /* get the composition properties of the next character */
	    private static int /* unsigned */GetNextCombining(NormalizerImpl.NextCombiningArgs  args,
	            int limit_0, UnicodeSet nx) {
	        long/* unsigned */norm32;
	        int combineFlags;
	        /* get properties */
	        args.c = args.source[args.start++];
	        norm32 = GetNorm32(args.c);
	
	        /* preset output values for most characters */
	        args.c2 = ((Char)0);
	        args.combiningIndex = 0;
	        args.cc = ((Char)0);
	
	        if ((norm32 & (CC_MASK | COMBINES_ANY)) == 0) {
	            return 0;
	        } else {
	            if (IsNorm32Regular(norm32)) {
	                /* set cc etc. below */
	            } else if (IsNorm32HangulOrJamo(norm32)) {
	                /* a compatibility decomposition contained Jamos */
	                args.combiningIndex = (int) ((UNSIGNED_INT_MASK) & (0xfff0 | (norm32 >> EXTRA_SHIFT)));
	                return (int) (norm32 & COMBINES_ANY);
	            } else {
	                /* c is a lead surrogate, get the real norm32 */
	                if (args.start != limit_0
	                        && IBM.ICU.Text.UTF16.IsTrailSurrogate(args.c2 = args.source[args.start])) {
	                    ++args.start;
	                    norm32 = GetNorm32FromSurrogatePair(norm32, args.c2);
	                } else {
	                    args.c2 = ((Char)0);
	                    return 0;
	                }
	            }
	
	            if (Nx_contains(nx, args.c, args.c2)) {
	                return 0; /* excluded: norm32==0 */
	            }
	
	            args.cc = (char) ((norm32 >> CC_SHIFT) & 0xff);
	
	            combineFlags = (int) (norm32 & COMBINES_ANY);
	            if (combineFlags != 0) {
	                int index = GetExtraDataIndex(norm32);
	                args.combiningIndex = (index > 0) ? (char) (extraData[(index - 1)]) : (char) (0);
	            }
	
	            return combineFlags;
	        }
	    }
	
	    /*
	     * given a composition-result starter (c, c2) - which means its cc==0, it
	     * combines forward, it has extra data, its norm32!=0, it is not a Hangul or
	     * Jamo, get just its combineFwdIndex
	     * 
	     * norm32(c) is special if and only if c2!=0
	     */
	    private static int/* unsigned */GetCombiningIndexFromStarter(char c_0, char c2_1) {
	        long/* unsigned */norm32;
	
	        norm32 = GetNorm32(c_0);
	        if (c2_1 != 0) {
	            norm32 = GetNorm32FromSurrogatePair(norm32, c2_1);
	        }
	        return extraData[(GetExtraDataIndex(norm32) - 1)];
	    }
	
	    /*
	     * Find the recomposition result for a forward-combining character
	     * (specified with a pointer to its part of the combiningTable[]) and a
	     * backward-combining character (specified with its combineBackIndex).
	     * 
	     * If these two characters combine, then set (value, value2) with the code
	     * unit(s) of the composition character.
	     * 
	     * Return value: 0 do not combine 1 combine >1 combine, and the composition
	     * is a forward-combining starter
	     * 
	     * See unormimp.h for a description of the composition table format.
	     */
	    private static int/* unsigned */Combine(char[] table, int tableStart,
	            int/* unsinged */combineBackIndex, int[] outValues) {
	        int/* unsigned */key;
	        int value_ren, value2;
	
	        if (outValues.Length < 2) {
	            throw new ArgumentException();
	        }
	
	        /* search in the starter's composition table */
	        for (;;) {
	            key = table[tableStart++];
	            if (key >= combineBackIndex) {
	                break;
	            }
	            tableStart += ((table[tableStart] & 0x8000) != 0) ? 2 : 1;
	        }
	
	        /* mask off bit 15, the last-entry-in-the-list flag */
	        if ((key & 0x7fff) == combineBackIndex) {
	            /* found! combine! */
	            value_ren = table[tableStart];
	
	            /* is the composition a starter that combines forward? */
	            key = (int) ((UNSIGNED_INT_MASK) & ((value_ren & 0x2000) + 1));
	
	            /*
	             * get the composition result code point from the variable-length
	             * result value
	             */
	            if ((value_ren & 0x8000) != 0) {
	                if ((value_ren & 0x4000) != 0) {
	                    /* surrogate pair composition result */
	                    value_ren = (int) ((UNSIGNED_INT_MASK) & ((value_ren & 0x3ff) | 0xd800));
	                    value2 = table[tableStart + 1];
	                } else {
	                    /* BMP composition result U+2000..U+ffff */
	                    value_ren = table[tableStart + 1];
	                    value2 = 0;
	                }
	            } else {
	                /* BMP composition result U+0000..U+1fff */
	                value_ren &= 0x1fff;
	                value2 = 0;
	            }
	            outValues[0] = value_ren;
	            outValues[1] = value2;
	            return key;
	        } else {
	            /* not found */
	            return 0;
	        }
	    }
	
	    private sealed class RecomposeArgs {
	        internal char[] source;
	
	        internal int start;
	
	        internal int limit;
	    }
	
	    /*
	     * recompose the characters in [p..limit[ (which is in NFD - decomposed and
	     * canonically ordered), adjust limit, and return the trailing cc
	     * 
	     * since for NFKC we may get Jamos in decompositions, we need to recompose
	     * those too
	     * 
	     * note that recomposition never lengthens the text: any character consists
	     * of either one or two code units; a composition may contain at most one
	     * more code unit than the original starter, while the combining mark that
	     * is removed has at least one code unit
	     */
	    private static char/* unsigned byte */Recompose(NormalizerImpl.RecomposeArgs  args,
	            int options, UnicodeSet nx) {
	        int remove, q, r;
	        int /* unsigned */combineFlags;
	        int /* unsigned */combineFwdIndex, combineBackIndex;
	        int /* unsigned */result, value_ren = 0, value2 = 0;
	        int /* unsigned byte */prevCC;
	        bool starterIsSupplementary;
	        int starter;
	        int[] outValues = new int[2];
	        starter = -1; /* no starter */
	        combineFwdIndex = 0; /* will not be used until starter!=NULL */
	        starterIsSupplementary = false; /* will not be used until starter!=NULL */
	        prevCC = 0;
	
	        NormalizerImpl.NextCombiningArgs  ncArg = new NormalizerImpl.NextCombiningArgs ();
	        ncArg.source = args.source;
	
	        ncArg.cc = ((Char)0);
	        ncArg.c2 = ((Char)0);
	
	        for (;;) {
	            ncArg.start = args.start;
	            combineFlags = GetNextCombining(ncArg, args.limit, nx);
	            combineBackIndex = ncArg.combiningIndex;
	            args.start = ncArg.start;
	
	            if (((combineFlags & COMBINES_BACK) != 0) && starter != -1) {
	                if ((combineBackIndex & 0x8000) != 0) {
	                    /*
	                     * c is a Jamo V/T, see if we can compose it with the
	                     * previous character
	                     */
	                    /*
	                     * for the PRI #29 fix, check that there is no intervening
	                     * combining mark
	                     */
	                    if ((options & BEFORE_PRI_29) != 0 || prevCC == 0) {
	                        remove = -1; /* NULL while no Hangul composition */
	                        combineFlags = 0;
	                        ncArg.c2 = args.source[starter];
	                        if (combineBackIndex == 0xfff2) {
	                            /*
	                             * Jamo V, compose with previous Jamo L and
	                             * following Jamo T
	                             */
	                            ncArg.c2 = (char) (ncArg.c2 - JAMO_L_BASE);
	                            if (ncArg.c2 < JAMO_L_COUNT) {
	                                remove = args.start - 1;
	                                ncArg.c = (char) (HANGUL_BASE + (ncArg.c2
	                                        * JAMO_V_COUNT + (ncArg.c - JAMO_V_BASE))
	                                        * JAMO_T_COUNT);
	                                if (args.start != args.limit
	                                        && (ncArg.c2 = (char) (args.source[args.start] - JAMO_T_BASE)) < JAMO_T_COUNT) {
	                                    ++args.start;
	                                    ncArg.c += ncArg.c2;
	                                } else {
	                                    /*
	                                     * the result is an LV syllable, which is a
	                                     * starter (unlike LVT)
	                                     */
	                                    combineFlags = COMBINES_FWD;
	                                }
	                                if (!Nx_contains(nx, ncArg.c)) {
	                                    args.source[starter] = ncArg.c;
	                                } else {
	                                    /* excluded */
	                                    if (!IsHangulWithoutJamoT(ncArg.c)) {
	                                        --args.start; /*
	                                                       * undo the ++args.start
	                                                       * from reading the Jamo T
	                                                       */
	                                    }
	                                    /*
	                                     * c is modified but not used any more --
	                                     * c=*(p-1); -- re-read the Jamo V/T
	                                     */
	                                    remove = args.start;
	                                }
	                            }
	
	                            /*
	                             * Normally, the following can not occur: Since the
	                             * input is in NFD, there are no Hangul LV syllables
	                             * that a Jamo T could combine with. All Jamo Ts are
	                             * combined above when handling Jamo Vs.
	                             * 
	                             * However, before the PRI #29 fix, this can occur
	                             * due to an intervening combining mark between the
	                             * Hangul LV and the Jamo T.
	                             */
	                        } else {
	                            /*
	                             * Jamo T, compose with previous Hangul that does
	                             * not have a Jamo T
	                             */
	                            if (IsHangulWithoutJamoT(ncArg.c2)) {
	                                ncArg.c2 += (Char) (ncArg.c - JAMO_T_BASE);
	                                if (!Nx_contains(nx, ncArg.c2)) {
	                                    remove = args.start - 1;
	                                    args.source[starter] = ncArg.c2;
	                                }
	                            }
	                        }
	
	                        if (remove != -1) {
	                            /* remove the Jamo(s) */
	                            q = remove;
	                            r = args.start;
	                            while (r < args.limit) {
	                                args.source[q++] = args.source[r++];
	                            }
	                            args.start = remove;
	                            args.limit = q;
	                        }
	
	                        ncArg.c2 = ((Char)0); /* c2 held *starter temporarily */
	
	                        if (combineFlags != 0) {
	                            /*
	                             * not starter=NULL because the composition is a
	                             * Hangul LV syllable and might combine once more
	                             * (but only before the PRI #29 fix)
	                             */
	
	                            /* done? */
	                            if (args.start == args.limit) {
	                                return (char) prevCC;
	                            }
	
	                            /*
	                             * the composition is a Hangul LV syllable which is
	                             * a starter that combines forward
	                             */
	                            combineFwdIndex = 0xfff0;
	
	                            /*
	                             * we combined; continue with looking for
	                             * compositions
	                             */
	                            continue;
	                        }
	                    }
	
	                    /*
	                     * now: cc==0 and the combining index does not include
	                     * "forward" -> the rest of the loop body will reset starter
	                     * to NULL; technically, a composed Hangul syllable is a
	                     * starter, but it does not combine forward now that we have
	                     * consumed all eligible Jamos; for Jamo V/T, combineFlags
	                     * does not contain _NORM_COMBINES_FWD
	                     */
	
	                } else if (
	                /* the starter is not a Hangul LV or Jamo V/T and */
	                !((combineFwdIndex & 0x8000) != 0)
	                        &&
	                        /* the combining mark is not blocked and */
	                        (((options & BEFORE_PRI_29) != 0) ? (prevCC != ncArg.cc || prevCC == 0)
	                                : (prevCC < ncArg.cc || prevCC == 0))
	                        &&
	                        /* the starter and the combining mark (c, c2) do combine */
	                        0 != (result = Combine(combiningTable, combineFwdIndex,
	                                combineBackIndex, outValues)) &&
	                        /* the composition result is not excluded */
	                        !Nx_contains(nx, (char) value_ren, (char) value2)) {
	                    value_ren = outValues[0];
	                    value2 = outValues[1];
	                    /*
	                     * replace the starter with the composition, remove the
	                     * combining mark
	                     */
	                    remove = (ncArg.c2 == 0) ? args.start - 1 : args.start - 2; /*
	                                                                               * index
	                                                                               * to
	                                                                               * the
	                                                                               * combining
	                                                                               * mark
	                                                                               */
	
	                    /* replace the starter with the composition */
	                    args.source[starter] = (char) value_ren;
	                    if (starterIsSupplementary) {
	                        if (value2 != 0) {
	                            /* both are supplementary */
	                            args.source[starter + 1] = (char) value2;
	                        } else {
	                            /*
	                             * the composition is shorter than the starter, move
	                             * the intermediate characters forward one
	                             */
	                            starterIsSupplementary = false;
	                            q = starter + 1;
	                            r = q + 1;
	                            while (r < remove) {
	                                args.source[q++] = args.source[r++];
	                            }
	                            --remove;
	                        }
	                    } else if (value2 != 0) {
	                        /*
	                         * the composition is longer than the starter, move the
	                         * intermediate characters back one
	                         */
	                        starterIsSupplementary = true;
	                        /* temporarily increment for the loop boundary */
	                        ++starter;
	                        q = remove;
	                        r = ++remove;
	                        while (starter < q) {
	                            args.source[--r] = args.source[--q];
	                        }
	                        args.source[starter] = (char) value2;
	                        --starter; /* undo the temporary increment */
	                        /* } else { both are on the BMP, nothing more to do */
	                    }
	
	                    /*
	                     * remove the combining mark by moving the following text
	                     * over it
	                     */
	                    if (remove < args.start) {
	                        q = remove;
	                        r = args.start;
	                        while (r < args.limit) {
	                            args.source[q++] = args.source[r++];
	                        }
	                        args.start = remove;
	                        args.limit = q;
	                    }
	
	                    /* keep prevCC because we removed the combining mark */
	
	                    /* done? */
	                    if (args.start == args.limit) {
	                        return (char) prevCC;
	                    }
	
	                    /* is the composition a starter that combines forward? */
	                    if (result > 1) {
	                        combineFwdIndex = GetCombiningIndexFromStarter(
	                                (char) value_ren, (char) value2);
	                    } else {
	                        starter = -1;
	                    }
	
	                    /* we combined; continue with looking for compositions */
	                    continue;
	                }
	            }
	
	            /* no combination this time */
	            prevCC = ncArg.cc;
	            if (args.start == args.limit) {
	                return (char) prevCC;
	            }
	
	            /* if (c, c2) did not combine, then check if it is a starter */
	            if (ncArg.cc == 0) {
	                /* found a new starter; combineFlags==0 if (c, c2) is excluded */
	                if ((combineFlags & COMBINES_FWD) != 0) {
	                    /* it may combine with something, prepare for it */
	                    if (ncArg.c2 == 0) {
	                        starterIsSupplementary = false;
	                        starter = args.start - 1;
	                    } else {
	                        starterIsSupplementary = false;
	                        starter = args.start - 2;
	                    }
	                    combineFwdIndex = combineBackIndex;
	                } else {
	                    /* it will not combine with anything */
	                    starter = -1;
	                }
	            } else if ((options & OPTIONS_COMPOSE_CONTIGUOUS) != 0) {
	                /*
	                 * FCC: no discontiguous compositions; any intervening character
	                 * blocks
	                 */
	                starter = -1;
	            }
	        }
	    }
	
	    // find the last true starter between src[start]....src[current] going
	    // backwards and return its index
	    private static int FindPreviousStarter(char[] src_0, int srcStart,
	            int current_1, int/* unsigned */ccOrQCMask,
	            int/* unsigned */decompQCMask, char minNoMaybe) {
	        long norm32;
	        NormalizerImpl.PrevArgs  args = new NormalizerImpl.PrevArgs ();
	        args.src = src_0;
	        args.start = srcStart;
	        args.current = current_1;
	
	        while (args.start < args.current) {
	            norm32 = GetPrevNorm32(args, minNoMaybe, ccOrQCMask | decompQCMask);
	            if (IsTrueStarter(norm32, ccOrQCMask, decompQCMask)) {
	                break;
	            }
	        }
	        return args.current;
	    }
	
	    /*
	     * find the first true starter in [src..limit[ and return the pointer to it
	     */
	    private static int/* index */FindNextStarter(char[] src_0, int start_1,
	            int limit_2, int/* unsigned */qcMask, int/* unsigned */decompQCMask,
	            char minNoMaybe) {
	        int p;
	        long/* unsigned */norm32;
	        int ccOrQCMask;
	        char c_3, c2_4;
	
	        ccOrQCMask = CC_MASK | qcMask;
	
	        NormalizerImpl.DecomposeArgs  decompArgs = new NormalizerImpl.DecomposeArgs ();
	
	        for (;;) {
	            if (start_1 == limit_2) {
	                break; /* end of string */
	            }
	            c_3 = src_0[start_1];
	            if (c_3 < minNoMaybe) {
	                break; /* catches NUL terminater, too */
	            }
	
	            norm32 = GetNorm32(c_3);
	            if ((norm32 & ccOrQCMask) == 0) {
	                break; /* true starter */
	            }
	
	            if (IsNorm32LeadSurrogate(norm32)) {
	                /* c is a lead surrogate, get the real norm32 */
	                if ((start_1 + 1) == limit_2
	                        || !IBM.ICU.Text.UTF16.IsTrailSurrogate(c2_4 = (src_0[start_1 + 1]))) {
	                    /* unmatched first surrogate: counts as a true starter */
	                    break;
	                }
	                norm32 = GetNorm32FromSurrogatePair(norm32, c2_4);
	
	                if ((norm32 & ccOrQCMask) == 0) {
	                    break; /* true starter */
	                }
	            } else {
	                c2_4 = ((Char)0);
	            }
	
	            /* (c, c2) is not a true starter but its decomposition may be */
	            if ((norm32 & decompQCMask) != 0) {
	                /*
	                 * (c, c2) decomposes, get everything from the variable-length
	                 * extra data
	                 */
	                p = Decompose(norm32, decompQCMask, decompArgs);
	
	                /*
	                 * get the first character's norm32 to check if it is a true
	                 * starter
	                 */
	                if (decompArgs.cc == 0
	                        && (GetNorm32(extraData, p, qcMask) & qcMask) == 0) {
	                    break; /* true starter */
	                }
	            }
	
	            start_1 += (c2_4 == 0) ? 1 : 2; /* not a true starter, continue */
	        }
	
	        return start_1;
	    }
	
	    private sealed class ComposePartArgs {
	        internal int prevCC;
	
	        internal int length; /* length of decomposed part */
	    }
	
	    /* decompose and recompose [prevStarter..src[ */
	    private static char[] ComposePart(NormalizerImpl.ComposePartArgs  args, int prevStarter,
	            char[] src_0, int start_1, int limit_2, int options, UnicodeSet nx) {
	        int recomposeLimit;
	        bool compat = ((options & OPTIONS_COMPAT) != 0);
	
	        /* decompose [prevStarter..src[ */
	        int[] outTrailCC = new int[1];
	        char[] buffer = new char[(limit_2 - prevStarter) * MAX_BUFFER_SIZE];
	
	        for (;;) {
	            args.length = Decompose(src_0, prevStarter, (start_1), buffer, 0,
	                    buffer.Length, compat, outTrailCC, nx);
	            if (args.length <= buffer.Length) {
	                break;
	            } else {
	                buffer = new char[args.length];
	            }
	        }
	
	        /* recompose the decomposition */
	        recomposeLimit = args.length;
	
	        if (args.length >= 2) {
	            NormalizerImpl.RecomposeArgs  rcArgs = new NormalizerImpl.RecomposeArgs ();
	            rcArgs.source = buffer;
	            rcArgs.start = 0;
	            rcArgs.limit = recomposeLimit;
	            args.prevCC = Recompose(rcArgs, options, nx);
	            recomposeLimit = rcArgs.limit;
	        }
	
	        /* return with a pointer to the recomposition and its length */
	        args.length = recomposeLimit;
	        return buffer;
	    }
	
	    private static bool ComposeHangul(char prev, char c_0,
	            long/* unsigned */norm32, char[] src_1, int[] srcIndex, int limit_2,
	            bool compat, char[] dest, int destIndex, UnicodeSet nx) {
	        int start_3 = srcIndex[0];
	        if (IsJamoVTNorm32JamoV(norm32)) {
	            /*
	             * c is a Jamo V, compose with previous Jamo L and following Jamo T
	             */
	            prev = (char) (prev - JAMO_L_BASE);
	            if (prev < JAMO_L_COUNT) {
	                c_0 = (char) (HANGUL_BASE + (prev * JAMO_V_COUNT + (c_0 - JAMO_V_BASE))
	                        * JAMO_T_COUNT);
	
	                /*
	                 * check if the next character is a Jamo T (normal or
	                 * compatibility)
	                 */
	                if (start_3 != limit_2) {
	                    char next_4, t;
	
	                    next_4 = src_1[start_3];
	                    if ((t = (char) (next_4 - JAMO_T_BASE)) < JAMO_T_COUNT) {
	                        /* normal Jamo T */
	                        ++start_3;
	                        c_0 += t;
	                    } else if (compat) {
	                        /*
	                         * if NFKC, then check for compatibility Jamo T (BMP
	                         * only)
	                         */
	                        norm32 = GetNorm32(next_4);
	                        if (IsNorm32Regular(norm32)
	                                && ((norm32 & QC_NFKD) != 0)) {
	                            int p /* index into extra data array */;
	                            NormalizerImpl.DecomposeArgs  dcArgs = new NormalizerImpl.DecomposeArgs ();
	                            p = Decompose(norm32, QC_NFKD, dcArgs);
	                            if (dcArgs.length == 1
	                                    && (t = (char) (extraData[p] - JAMO_T_BASE)) < JAMO_T_COUNT) {
	                                /* compatibility Jamo T */
	                                ++start_3;
	                                c_0 += t;
	                            }
	                        }
	                    }
	                }
	                if (Nx_contains(nx, c_0)) {
	                    if (!IsHangulWithoutJamoT(c_0)) {
	                        --start_3; /* undo ++start from reading the Jamo T */
	                    }
	                    return false;
	                }
	                dest[destIndex] = c_0;
	                srcIndex[0] = start_3;
	                return true;
	            }
	        } else if (IsHangulWithoutJamoT(prev)) {
	            /*
	             * c is a Jamo T, compose with previous Hangul LV that does not
	             * contain a Jamo T
	             */
	            c_0 = (char) (prev + (c_0 - JAMO_T_BASE));
	            if (Nx_contains(nx, c_0)) {
	                return false;
	            }
	            dest[destIndex] = c_0;
	            srcIndex[0] = start_3;
	            return true;
	        }
	        return false;
	    }
	
	    /*
	     * public static int compose(char[] src, char[] dest,boolean compat,
	     * UnicodeSet nx){ return
	     * compose(src,0,src.length,dest,0,dest.length,compat, nx); }
	     */
	
	    public static int Compose(char[] src_0, int srcStart, int srcLimit,
	            char[] dest, int destStart, int destLimit, int options,
	            UnicodeSet nx) {
	
	        int prevSrc, prevStarter;
	        long/* unsigned */norm32;
	        int ccOrQCMask, qcMask;
	        int reorderStartIndex, length_1;
	        char c_2, c2_3, minNoMaybe;
	        int/* unsigned byte */cc_4, prevCC_5;
	        int[] ioIndex = new int[1];
	        int destIndex = destStart;
	        int srcIndex = srcStart;
	
	        if ((options & OPTIONS_COMPAT) != 0) {
	            minNoMaybe = (char) indexes[INDEX_MIN_NFKC_NO_MAYBE];
	            qcMask = QC_NFKC;
	        } else {
	            minNoMaybe = (char) indexes[INDEX_MIN_NFC_NO_MAYBE];
	            qcMask = QC_NFC;
	        }
	
	        /*
	         * prevStarter points to the last character before the current one that
	         * is a "true" starter with cc==0 and quick check "yes".
	         * 
	         * prevStarter will be used instead of looking for a true starter while
	         * incrementally decomposing [prevStarter..prevSrc[ in _composePart().
	         * Having a good prevStarter allows to just decompose the entire
	         * [prevStarter..prevSrc[.
	         * 
	         * When _composePart() backs out from prevSrc back to prevStarter, then
	         * it also backs out destIndex by the same amount. Therefore, at all
	         * times, the (prevSrc-prevStarter) source units must correspond 1:1 to
	         * destination units counted with destIndex, except for reordering. This
	         * is true for the qc "yes" characters copied in the fast loop, and for
	         * pure reordering. prevStarter must be set forward to src when this is
	         * not true: In _composePart() and after composing a Hangul syllable.
	         * 
	         * This mechanism relies on the assumption that the decomposition of a
	         * true starter also begins with a true starter. gennorm/store.c checks
	         * for this.
	         */
	        prevStarter = srcIndex;
	
	        ccOrQCMask = CC_MASK | qcMask;
	        /* destIndex= */reorderStartIndex = 0;/* ####TODO#### check this * */
	        prevCC_5 = 0;
	
	        /* avoid compiler warnings */
	        norm32 = 0;
	        c_2 = ((Char)0);
	
	        for (;;) {
	            /*
	             * count code units below the minimum or with irrelevant data for
	             * the quick check
	             */
	            prevSrc = srcIndex;
	
	            while (srcIndex != srcLimit
	                    && ((c_2 = src_0[srcIndex]) < minNoMaybe || ((norm32 = GetNorm32(c_2)) & ccOrQCMask) == 0)) {
	                prevCC_5 = 0;
	                ++srcIndex;
	            }
	
	            /* copy these code units all at once */
	            if (srcIndex != prevSrc) {
	                length_1 = (int) (srcIndex - prevSrc);
	                if ((destIndex + length_1) <= destLimit) {
	                    System.Array.Copy((Array)(src_0),prevSrc,(Array)(dest),destIndex,length_1);
	                }
	                destIndex += length_1;
	                reorderStartIndex = destIndex;
	
	                /*
	                 * set prevStarter to the last character in the quick check loop
	                 */
	                prevStarter = srcIndex - 1;
	                if (IBM.ICU.Text.UTF16.IsTrailSurrogate(src_0[prevStarter])
	                        && prevSrc < prevStarter
	                        && IBM.ICU.Text.UTF16.IsLeadSurrogate(src_0[(prevStarter - 1)])) {
	                    --prevStarter;
	                }
	
	                prevSrc = srcIndex;
	            }
	
	            /* end of source reached? */
	            if (srcIndex == srcLimit) {
	                break;
	            }
	
	            /* c already contains *src and norm32 is set for it, increment src */
	            ++srcIndex;
	
	            /*
	             * source buffer pointers:
	             * 
	             * all done quick check current char not yet "yes" but (c, c2)
	             * processed may combine forward
	             * [-------------[-------------[-------------[-------------[ | | | |
	             * | start prevStarter prevSrc src limit
	             * 
	             * 
	             * destination buffer pointers and indexes:
	             * 
	             * all done might take not filled yet characters for reordering
	             * [-------------[-------------[-------------[ | | | | dest
	             * reorderStartIndex destIndex destCapacity
	             */
	
	            /* check one above-minimum, relevant code unit */
	            /*
	             * norm32 is for c=*(src-1), and the quick check flag is "no" or
	             * "maybe", and/or cc!=0 check for Jamo V/T, then for surrogates and
	             * regular characters c is not a Hangul syllable or Jamo L because
	             * they are not marked with no/maybe for NFC & NFKC(and their cc==0)
	             */
	            if (IsNorm32HangulOrJamo(norm32)) {
	                /*
	                 * c is a Jamo V/T: try to compose with the previous character,
	                 * Jamo V also with a following Jamo T, and set values here
	                 * right now in case we just continue with the main loop
	                 */
	                prevCC_5 = cc_4 = 0;
	                reorderStartIndex = destIndex;
	                ioIndex[0] = srcIndex;
	                if (destIndex > 0
	                        && ComposeHangul(src_0[(prevSrc - 1)], c_2, norm32, src_0,
	                                ioIndex, srcLimit,
	                                (options & OPTIONS_COMPAT) != 0, dest,
	                                (destIndex <= destLimit) ? destIndex - 1 : 0, nx)) {
	                    srcIndex = ioIndex[0];
	                    prevStarter = srcIndex;
	                    continue;
	                }
	
	                srcIndex = ioIndex[0];
	
	                /*
	                 * the Jamo V/T did not compose into a Hangul syllable, just
	                 * append to dest
	                 */
	                c2_3 = ((Char)0);
	                length_1 = 1;
	                prevStarter = prevSrc;
	            } else {
	                if (IsNorm32Regular(norm32)) {
	                    c2_3 = ((Char)0);
	                    length_1 = 1;
	                } else {
	                    /* c is a lead surrogate, get the real norm32 */
	                    if (srcIndex != srcLimit
	                            && IBM.ICU.Text.UTF16.IsTrailSurrogate(c2_3 = src_0[srcIndex])) {
	                        ++srcIndex;
	                        length_1 = 2;
	                        norm32 = GetNorm32FromSurrogatePair(norm32, c2_3);
	                    } else {
	                        /* c is an unpaired lead surrogate, nothing to do */
	                        c2_3 = ((Char)0);
	                        length_1 = 1;
	                        norm32 = 0;
	                    }
	                }
	                NormalizerImpl.ComposePartArgs  args = new NormalizerImpl.ComposePartArgs ();
	
	                /* we are looking at the character (c, c2) at [prevSrc..src[ */
	                if (Nx_contains(nx, c_2, c2_3)) {
	                    /* excluded: norm32==0 */
	                    cc_4 = 0;
	                } else if ((norm32 & qcMask) == 0) {
	                    cc_4 = (int) ((UNSIGNED_BYTE_MASK) & (norm32 >> CC_SHIFT));
	                } else {
	                    char[] p;
	
	                    /*
	                     * find appropriate boundaries around this character,
	                     * decompose the source text from between the boundaries,
	                     * and recompose it
	                     * 
	                     * this puts the intermediate text into the side buffer
	                     * because it might be longer than the recomposition end
	                     * result, or the destination buffer may be too short or
	                     * missing
	                     * 
	                     * note that destIndex may be adjusted backwards to account
	                     * for source text that passed the quick check but needed to
	                     * take part in the recomposition
	                     */
	                    int decompQCMask = (qcMask << 2) & 0xf; /*
	                                                             * decomposition
	                                                             * quick check mask
	                                                             */
	                    /*
	                     * find the last true starter in [prevStarter..src[ it is
	                     * either the decomposition of the current character (at
	                     * prevSrc), or prevStarter
	                     */
	                    if (IsTrueStarter(norm32, CC_MASK | qcMask, decompQCMask)) {
	                        prevStarter = prevSrc;
	                    } else {
	                        /*
	                         * adjust destIndex: back out what had been copied with
	                         * qc "yes"
	                         */
	                        destIndex -= prevSrc - prevStarter;
	                    }
	
	                    /* find the next true starter in [src..limit[ */
	                    srcIndex = FindNextStarter(src_0, srcIndex, srcLimit, qcMask,
	                            decompQCMask, minNoMaybe);
	                    // args.prevStarter = prevStarter;
	                    args.prevCC = prevCC_5;
	                    // args.destIndex = destIndex;
	                    args.length = length_1;
	                    p = ComposePart(args, prevStarter, src_0, srcIndex, srcLimit,
	                            options, nx);
	
	                    if (p == null) {
	                        /* an error occurred (out of memory) */
	                        break;
	                    }
	
	                    prevCC_5 = args.prevCC;
	                    length_1 = args.length;
	
	                    /*
	                     * append the recomposed buffer contents to the destination
	                     * buffer
	                     */
	                    if ((destIndex + args.length) <= destLimit) {
	                        int i = 0;
	                        while (i < args.length) {
	                            dest[destIndex++] = p[i++];
	                            --length_1;
	                        }
	                    } else {
	                        /* buffer overflow */
	                        /* keep incrementing the destIndex for preflighting */
	                        destIndex += length_1;
	                    }
	
	                    prevStarter = srcIndex;
	                    continue;
	                }
	            }
	
	            /* append the single code point (c, c2) to the destination buffer */
	            if ((destIndex + length_1) <= destLimit) {
	                if (cc_4 != 0 && cc_4 < prevCC_5) {
	                    /*
	                     * (c, c2) is out of order with respect to the preceding
	                     * text
	                     */
	                    int reorderSplit = destIndex;
	                    destIndex += length_1;
	                    prevCC_5 = InsertOrdered(dest, reorderStartIndex,
	                            reorderSplit, destIndex, c_2, c2_3, cc_4);
	                } else {
	                    /* just append (c, c2) */
	                    dest[destIndex++] = c_2;
	                    if (c2_3 != 0) {
	                        dest[destIndex++] = c2_3;
	                    }
	                    prevCC_5 = cc_4;
	                }
	            } else {
	                /* buffer overflow */
	                /* keep incrementing the destIndex for preflighting */
	                destIndex += length_1;
	                prevCC_5 = cc_4;
	            }
	        }
	
	        return destIndex - destStart;
	    }
	
	    /* make FCD -------------------------------------------------------------- */
	
	    private static int/* index */FindSafeFCD(char[] src_0, int start_1, int limit_2,
	            char fcd16) {
	        char c_3, c2_4;
	
	        /*
	         * find the first position in [src..limit[ after some cc==0 according to
	         * FCD data
	         * 
	         * at the beginning of the loop, we have fcd16 from before src
	         * 
	         * stop at positions: - after trail cc==0 - at the end of the source -
	         * before lead cc==0
	         */
	        for (;;) {
	            /* stop if trail cc==0 for the previous character */
	            if ((fcd16 & 0xff) == 0) {
	                break;
	            }
	
	            /* get c=*src - stop at end of string */
	            if (start_1 == limit_2) {
	                break;
	            }
	            c_3 = src_0[start_1];
	
	            /* stop if lead cc==0 for this character */
	            if (c_3 < MIN_WITH_LEAD_CC || (fcd16 = GetFCD16(c_3)) == 0) {
	                break; /* catches terminating NUL, too */
	            }
	
	            if (!IBM.ICU.Text.UTF16.IsLeadSurrogate(c_3)) {
	                if (fcd16 <= 0xff) {
	                    break;
	                }
	                ++start_1;
	            } else if (start_1 + 1 != limit_2
	                    && (IBM.ICU.Text.UTF16.IsTrailSurrogate(c2_4 = src_0[start_1 + 1]))) {
	                /* c is a lead surrogate, get the real fcd16 */
	                fcd16 = GetFCD16FromSurrogatePair(fcd16, c2_4);
	                if (fcd16 <= 0xff) {
	                    break;
	                }
	                start_1 += 2;
	            } else {
	                /* c is an unpaired first surrogate, lead cc==0 */
	                break;
	            }
	        }
	
	        return start_1;
	    }
	
	    private static int/* unsigned byte */DecomposeFCD(char[] src_0, int start_1,
	            int decompLimit, char[] dest, int[] destIndexArr, UnicodeSet nx) {
	        char[] p = null;
	        int pStart = -1;
	
	        long /* unsigned int */norm32;
	        int reorderStartIndex;
	        char c_2, c2_3;
	        int/* unsigned byte */prevCC_4;
	        NormalizerImpl.DecomposeArgs  args = new NormalizerImpl.DecomposeArgs ();
	        int destIndex = destIndexArr[0];
	        /*
	         * canonically decompose [src..decompLimit[
	         * 
	         * all characters in this range have some non-zero cc, directly or in
	         * decomposition, so that we do not need to check in the following for
	         * quick-check limits etc.
	         * 
	         * there _are_ _no_ Hangul syllables or Jamos in here because they are
	         * FCD-safe (cc==0)!
	         * 
	         * we also do not need to check for c==0 because we have an established
	         * decompLimit
	         */
	        reorderStartIndex = destIndex;
	        prevCC_4 = 0;
	
	        while (start_1 < decompLimit) {
	            c_2 = src_0[start_1++];
	            norm32 = GetNorm32(c_2);
	            if (IsNorm32Regular(norm32)) {
	                c2_3 = ((Char)0);
	                args.length = 1;
	            } else {
	                /*
	                 * reminder: this function is called with [src..decompLimit[ not
	                 * containing any Hangul/Jamo characters, therefore the only
	                 * specials are lead surrogates
	                 */
	                /* c is a lead surrogate, get the real norm32 */
	                if (start_1 != decompLimit
	                        && IBM.ICU.Text.UTF16.IsTrailSurrogate(c2_3 = src_0[start_1])) {
	                    ++start_1;
	                    args.length = 2;
	                    norm32 = GetNorm32FromSurrogatePair(norm32, c2_3);
	                } else {
	                    c2_3 = ((Char)0);
	                    args.length = 1;
	                    norm32 = 0;
	                }
	            }
	
	            /* get the decomposition and the lead and trail cc's */
	            if (Nx_contains(nx, c_2, c2_3)) {
	                /* excluded: norm32==0 */
	                args.cc = args.trailCC = 0;
	                p = null;
	            } else if ((norm32 & QC_NFD) == 0) {
	                /* c does not decompose */
	                args.cc = args.trailCC = (int) ((UNSIGNED_BYTE_MASK) & (norm32 >> CC_SHIFT));
	                p = null;
	            } else {
	                /*
	                 * c decomposes, get everything from the variable-length extra
	                 * data
	                 */
	                pStart = Decompose(norm32, args);
	                p = extraData;
	                if (args.length == 1) {
	                    /* fastpath a single code unit from decomposition */
	                    c_2 = p[pStart];
	                    c2_3 = ((Char)0);
	                    p = null;
	                }
	            }
	
	            /*
	             * append the decomposition to the destination buffer, assume
	             * length>0
	             */
	            if ((destIndex + args.length) <= dest.Length) {
	                int reorderSplit = destIndex;
	                if (p == null) {
	                    /* fastpath: single code point */
	                    if (args.cc != 0 && args.cc < prevCC_4) {
	                        /*
	                         * (c, c2) is out of order with respect to the preceding
	                         * text
	                         */
	                        destIndex += args.length;
	                        args.trailCC = InsertOrdered(dest, reorderStartIndex,
	                                reorderSplit, destIndex, c_2, c2_3, args.cc);
	                    } else {
	                        /* just append (c, c2) */
	                        dest[destIndex++] = c_2;
	                        if (c2_3 != 0) {
	                            dest[destIndex++] = c2_3;
	                        }
	                    }
	                } else {
	                    /*
	                     * general: multiple code points (ordered by themselves)
	                     * from decomposition
	                     */
	                    if (args.cc != 0 && args.cc < prevCC_4) {
	                        /*
	                         * the decomposition is out of order with respect to the
	                         * preceding text
	                         */
	                        destIndex += args.length;
	                        args.trailCC = MergeOrdered(dest, reorderStartIndex,
	                                reorderSplit, p, pStart, pStart + args.length);
	                    } else {
	                        /* just append the decomposition */
	                        do {
	                            dest[destIndex++] = p[pStart++];
	                        } while (--args.length > 0);
	                    }
	                }
	            } else {
	                /* buffer overflow */
	                /* keep incrementing the destIndex for preflighting */
	                destIndex += args.length;
	            }
	
	            prevCC_4 = args.trailCC;
	            if (prevCC_4 == 0) {
	                reorderStartIndex = destIndex;
	            }
	        }
	        destIndexArr[0] = destIndex;
	        return prevCC_4;
	    }
	
	    public static int MakeFCD(char[] src_0, int srcStart, int srcLimit,
	            char[] dest, int destStart, int destLimit, UnicodeSet nx) {
	
	        int prevSrc, decompStart;
	        int destIndex, length_1;
	        char c_2, c2_3;
	        int /* unsigned int */fcd16;
	        int prevCC_4, cc_5;
	
	        /* initialize */
	        decompStart = srcStart;
	        destIndex = destStart;
	        prevCC_4 = 0;
	        c_2 = ((Char)0);
	        fcd16 = 0;
	        int[] destIndexArr = new int[1];
	        destIndexArr[0] = destIndex;
	
	        for (;;) {
	            /*
	             * skip a run of code units below the minimum or with irrelevant
	             * data for the FCD check
	             */
	            prevSrc = srcStart;
	
	            for (;;) {
	                if (srcStart == srcLimit) {
	                    break;
	                } else if ((c_2 = src_0[srcStart]) < MIN_WITH_LEAD_CC) {
	                    prevCC_4 = (int) -c_2;
	                } else if ((fcd16 = GetFCD16(c_2)) == 0) {
	                    prevCC_4 = 0;
	                } else {
	                    break;
	                }
	                ++srcStart;
	            }
	
	            /*
	             * prevCC has values from the following ranges: 0..0xff - the
	             * previous trail combining class <0 - the negative value of the
	             * previous code unit; that code unit was <_NORM_MIN_WITH_LEAD_CC
	             * and its getFCD16() was deferred so that average text is checked
	             * faster
	             */
	
	            /* copy these code units all at once */
	            if (srcStart != prevSrc) {
	                length_1 = (int) (srcStart - prevSrc);
	                if ((destIndex + length_1) <= destLimit) {
	                    System.Array.Copy((Array)(src_0),prevSrc,(Array)(dest),destIndex,length_1);
	                }
	                destIndex += length_1;
	                prevSrc = srcStart;
	
	                /*
	                 * prevCC<0 is only possible from the above loop, i.e., only if
	                 * prevSrc<src
	                 */
	                if (prevCC_4 < 0) {
	                    /*
	                     * the previous character was <_NORM_MIN_WITH_LEAD_CC, we
	                     * need to get its trail cc
	                     */
	                    if (!Nx_contains(nx, (int) -prevCC_4)) {
	                        prevCC_4 = (int) (GetFCD16((int) -prevCC_4) & 0xff);
	                    } else {
	                        prevCC_4 = 0; /* excluded: fcd16==0 */
	                    }
	                    /*
	                     * set a pointer to this below-U+0300 character; if
	                     * prevCC==0 then it will moved to after this character
	                     * below
	                     */
	                    decompStart = prevSrc - 1;
	                }
	            }
	            /*
	             * now: prevSrc==src - used later to adjust destIndex before
	             * decomposition prevCC>=0
	             */
	
	            /* end of source reached? */
	            if (srcStart == srcLimit) {
	                break;
	            }
	
	            /* set a pointer to after the last source position where prevCC==0 */
	            if (prevCC_4 == 0) {
	                decompStart = prevSrc;
	            }
	
	            /* c already contains *src and fcd16 is set for it, increment src */
	            ++srcStart;
	
	            /* check one above-minimum, relevant code unit */
	            if (IBM.ICU.Text.UTF16.IsLeadSurrogate(c_2)) {
	                /* c is a lead surrogate, get the real fcd16 */
	                if (srcStart != srcLimit
	                        && IBM.ICU.Text.UTF16.IsTrailSurrogate(c2_3 = src_0[srcStart])) {
	                    ++srcStart;
	                    fcd16 = GetFCD16FromSurrogatePair((char) fcd16, c2_3);
	                } else {
	                    c2_3 = ((Char)0);
	                    fcd16 = 0;
	                }
	            } else {
	                c2_3 = ((Char)0);
	            }
	
	            /* we are looking at the character (c, c2) at [prevSrc..src[ */
	            if (Nx_contains(nx, c_2, c2_3)) {
	                fcd16 = 0; /* excluded: fcd16==0 */
	            }
	            /* check the combining order, get the lead cc */
	            cc_5 = (int) (fcd16 >> 8);
	            if (cc_5 == 0 || cc_5 >= prevCC_4) {
	                /* the order is ok */
	                if (cc_5 == 0) {
	                    decompStart = prevSrc;
	                }
	                prevCC_4 = (int) (fcd16 & 0xff);
	
	                /* just append (c, c2) */
	                length_1 = (c2_3 == 0) ? 1 : 2;
	                if ((destIndex + length_1) <= destLimit) {
	                    dest[destIndex++] = c_2;
	                    if (c2_3 != 0) {
	                        dest[destIndex++] = c2_3;
	                    }
	                } else {
	                    destIndex += length_1;
	                }
	            } else {
	                /*
	                 * back out the part of the source that we copied already but is
	                 * now going to be decomposed; prevSrc is set to after what was
	                 * copied
	                 */
	                destIndex -= (int) (prevSrc - decompStart);
	
	                /*
	                 * find the part of the source that needs to be decomposed; to
	                 * be safe and simple, decompose to before the next character
	                 * with lead cc==0
	                 */
	                srcStart = FindSafeFCD(src_0, srcStart, srcLimit, (char) fcd16);
	
	                /*
	                 * the source text does not fulfill the conditions for FCD;
	                 * decompose and reorder a limited piece of the text
	                 */
	                destIndexArr[0] = destIndex;
	                prevCC_4 = DecomposeFCD(src_0, decompStart, srcStart, dest,
	                        destIndexArr, nx);
	                decompStart = srcStart;
	                destIndex = destIndexArr[0];
	            }
	        }
	
	        return destIndex - destStart;
	
	    }
	
	    public static int GetCombiningClass(int c_0) {
	        long norm32;
	        norm32 = GetNorm32(c_0);
	        return (char) ((norm32 >> CC_SHIFT) & 0xFF);
	    }
	
	    public static bool IsFullCompositionExclusion(int c_0) {
	        if (isFormatVersion_2_1) {
	            int aux = IBM.ICU.Impl.NormalizerImpl.AuxTrieImpl.auxTrie.GetCodePointValue(c_0);
	            return (bool) ((aux & AUX_COMP_EX_MASK) != 0);
	        } else {
	            return false;
	        }
	    }
	
	    public static bool IsCanonSafeStart(int c_0) {
	        if (isFormatVersion_2_1) {
	            int aux = IBM.ICU.Impl.NormalizerImpl.AuxTrieImpl.auxTrie.GetCodePointValue(c_0);
	            return (bool) ((aux & AUX_UNSAFE_MASK) == 0);
	        } else {
	            return false;
	        }
	    }
	
	    public static bool GetCanonStartSet(int c_0, USerializedSet fillSet) {
	
	        if (fillSet != null && canonStartSets != null) {
	            /*
	             * binary search for c
	             * 
	             * There are two search tables, one for BMP code points and one for
	             * supplementary ones. See unormimp.h for details.
	             */
	            char[] table;
	            int i = 0, start_1, limit_2;
	
	            int[] indexes_3 = (int[]) canonStartSets[CANON_SET_INDICIES_INDEX];
	            char[] startSets = (char[]) canonStartSets[CANON_SET_START_SETS_INDEX];
	
	            if (c_0 <= 0xffff) {
	                table = (char[]) canonStartSets[CANON_SET_BMP_TABLE_INDEX];
	                start_1 = 0;
	                limit_2 = table.Length;
	
	                /* each entry is a pair { c, result } */
	                while (start_1 < limit_2 - 2) {
	                    i = (char) (((start_1 + limit_2) / 4) * 2);
	                    if (c_0 < table[i]) {
	                        limit_2 = i;
	                    } else {
	                        start_1 = i;
	                    }
	                }
	                // System.out.println(i);
	                /* found? */
	                if (c_0 == table[start_1]) {
	                    i = table[start_1 + 1];
	                    if ((i & CANON_SET_BMP_MASK) == CANON_SET_BMP_IS_INDEX) {
	                        /*
	                         * result 01xxxxxx xxxxxx contains index x to a
	                         * USerializedSet
	                         */
	                        i &= (CANON_SET_MAX_CANON_SETS - 1);
	                        return fillSet.GetSet(startSets, (i - indexes_3.Length));
	                    } else {
	                        /*
	                         * other result values are BMP code points for
	                         * single-code point sets
	                         */
	                        fillSet.SetToOne(i);
	                        return true;
	                    }
	                }
	            } else {
	                char high, low, h, j = (char) (0);
	
	                table = (char[]) canonStartSets[CANON_SET_SUPP_TABLE_INDEX];
	                start_1 = 0;
	                limit_2 = table.Length;
	
	                high = (char) (c_0 >> 16);
	                low = (char) c_0;
	
	                /* each entry is a triplet { high(c), low(c), result } */
	                while (start_1 < limit_2 - 3) {
	                    /* (start+limit)/2 and address triplets */
	                    i = (char) (((start_1 + limit_2) / 6) * 3);
	                    j = (char) (table[i] & 0x1f); /* high word */
	                    int tableVal = table[i + 1];
	                    int lowInt = low;
	                    if (high < j || ((tableVal > lowInt) && (high == j))) {
	                        limit_2 = i;
	                    } else {
	                        start_1 = i;
	                    }
	
	                    // System.err.println("\t((high==j) && (table[i+1]>low)) == "
	                    // + ((high==j) && (tableVal>lowInt)) );
	
	                    // KLUDGE: IBM JIT in 1.4.0 is sooo broken
	                    // The below lines make TestExhaustive pass
	                    if (IBM.ICU.Impl.ICUDebug.Enabled()) {
	                        System.Console.Error.WriteLine("\t\t j = " + IBM.ICU.Impl.Utility.Hex(j, 4)
	                                + "\t i = " + IBM.ICU.Impl.Utility.Hex(i, 4) + "\t high = "
	                                + IBM.ICU.Impl.Utility.Hex(high) + "\t low = "
	                                + IBM.ICU.Impl.Utility.Hex(lowInt, 4) + "\t table[i+1]: "
	                                + IBM.ICU.Impl.Utility.Hex(tableVal, 4));
	                    }
	
	                }
	
	                /* found? */
	                h = table[start_1];
	
	                // System.err.println("c: \\U"+
	                // Integer.toHexString(c)+" i : "+Integer.toHexString(i)
	                // +" h : " + Integer.toHexString(h));
	                int tableVal1 = table[start_1 + 1];
	                int lowInt_4 = low;
	
	                if (high == (h & 0x1f) && lowInt_4 == tableVal1) {
	                    int tableVal2 = table[start_1 + 2];
	                    i = tableVal2;
	                    if ((h & 0x8000) == 0) {
	                        /* the result is an index to a USerializedSet */
	                        return fillSet.GetSet(startSets, (i - indexes_3.Length));
	                    } else {
	                        /*
	                         * single-code point set {x} in triplet { 100xxxxx
	                         * 000hhhhh llllllll llllllll xxxxxxxx xxxxxxxx }
	                         */
	                        // i|=((int)h & 0x1f00)<<8; /* add high bits from
	                        // high(c) */
	                        int temp = ((int) h & 0x1f00) << 8;
	                        i |= temp; /* add high bits from high(c) */
	                        fillSet.SetToOne((int) i);
	                        return true;
	                    }
	                }
	            }
	        }
	
	        return false; /* not found */
	    }
	
	    public static int GetFC_NFKC_Closure(int c_0, char[] dest) {
	
	        int destCapacity;
	
	        if (dest == null) {
	            destCapacity = 0;
	        } else {
	            destCapacity = dest.Length;
	        }
	
	        int aux = IBM.ICU.Impl.NormalizerImpl.AuxTrieImpl.auxTrie.GetCodePointValue(c_0);
	
	        aux &= AUX_FNC_MASK;
	        if (aux != 0) {
	            int s;
	            int index = aux;
	            int length_1;
	
	            s = extraData[index];
	            if (s < 0xff00) {
	                /* s points to the single-unit string */
	                length_1 = 1;
	            } else {
	                length_1 = s & 0xff;
	                ++index;
	            }
	            if (0 < length_1 && length_1 <= destCapacity) {
	                System.Array.Copy((Array)(extraData),index,(Array)(dest),0,length_1);
	            }
	            return length_1;
	        } else {
	            return 0;
	        }
	    }
	
	    /* Is c an NF<mode>-skippable code point? See unormimp.h. */
	    public static bool IsNFSkippable(int c_0, Normalizer.Mode mode, long mask) {
	        long /* unsigned int */norm32;
	        mask = mask & UNSIGNED_INT_MASK;
	        char aux;
	
	        /* check conditions (a)..(e), see unormimp.h */
	        norm32 = GetNorm32(c_0);
	
	        if ((norm32 & mask) != 0) {
	            return false; /* fails (a)..(e), not skippable */
	        }
	
	        if (mode == IBM.ICU.Text.Normalizer.NFD || mode == IBM.ICU.Text.Normalizer.NFKD
	                || mode == IBM.ICU.Text.Normalizer.NONE) {
	            return true; /* NF*D, passed (a)..(c), is skippable */
	        }
	        /* check conditions (a)..(e), see unormimp.h */
	
	        /* NF*C/FCC, passed (a)..(e) */
	        if ((norm32 & QC_NFD) == 0) {
	            return true; /* no canonical decomposition, is skippable */
	        }
	
	        /* check Hangul syllables algorithmically */
	        if (IsNorm32HangulOrJamo(norm32)) {
	            /* Jamo passed (a)..(e) above, must be Hangul */
	            return !IsHangulWithoutJamoT((char) c_0); /*
	                                                     * LVT are skippable, LV are
	                                                     * not
	                                                     */
	        }
	
	        /* if(mode<=UNORM_NFKC) { -- enable when implementing FCC */
	        /* NF*C, test (f) flag */
	        if (!isFormatVersion_2_2) {
	            return false; /* no (f) data, say not skippable to be safe */
	        }
	
	        aux = IBM.ICU.Impl.NormalizerImpl.AuxTrieImpl.auxTrie.GetCodePointValue(c_0);
	        return (aux & AUX_NFC_SKIP_F_MASK) == 0; /*
	                                                  * TRUE=skippable if the (f)
	                                                  * flag is not set
	                                                  */
	
	        /* } else { FCC, test fcd<=1 instead of the above } */
	    }
	
	    /*
	     * private static final boolean _enumPropertyStartsRange(const void
	     * *context, UChar32 start, UChar32 limit, uint32_t value) { // add the
	     * start code point to the USet uset_add((USet *)context, start); return
	     * TRUE; }
	     */
	
	    public static UnicodeSet AddPropertyStarts(UnicodeSet set) {
	        int c_0;
	
	        /* add the start code point of each same-value range of each trie */
	        // utrie_enum(&normTrie, NULL, _enumPropertyStartsRange, set);
	        TrieIterator normIter = new TrieIterator(IBM.ICU.Impl.NormalizerImpl.NormTrieImpl.normTrie);
	        RangeValueIterator_Constants.Element normResult = new RangeValueIterator_Constants.Element();
	
	        while (normIter.Next(normResult)) {
	            set.Add(normResult.start);
	        }
	
	        // utrie_enum(&fcdTrie, NULL, _enumPropertyStartsRange, set);
	        TrieIterator fcdIter = new TrieIterator(IBM.ICU.Impl.NormalizerImpl.FCDTrieImpl.fcdTrie);
	        RangeValueIterator_Constants.Element fcdResult = new RangeValueIterator_Constants.Element();
	
	        while (fcdIter.Next(fcdResult)) {
	            set.Add(fcdResult.start);
	        }
	
	        if (isFormatVersion_2_1) {
	            // utrie_enum(&auxTrie, NULL, _enumPropertyStartsRange, set);
	            TrieIterator auxIter = new TrieIterator(IBM.ICU.Impl.NormalizerImpl.AuxTrieImpl.auxTrie);
	            RangeValueIterator_Constants.Element auxResult = new RangeValueIterator_Constants.Element();
	            while (auxIter.Next(auxResult)) {
	                set.Add(auxResult.start);
	            }
	        }
	        /* add Hangul LV syllables and LV+1 because of skippables */
	        for (c_0 = HANGUL_BASE; c_0 < HANGUL_BASE + HANGUL_COUNT; c_0 += JAMO_T_COUNT) {
	            set.Add(c_0);
	            set.Add(c_0 + 1);
	        }
	        set.Add(HANGUL_BASE + HANGUL_COUNT); /*
	                                              * add Hangul+1 to continue with
	                                              * other properties
	                                              */
	        return set; // for chaining
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Internal API, used in UCharacter.getIntPropertyValue().
	    /// </summary>
	    ///
	    /// <param name="c_0">code point</param>
	    /// <param name="modeValue">numeric value compatible with Mode</param>
	    /// <returns>numeric value compatible with QuickCheck</returns>
	    public static int QuickCheck(int c_0, int modeValue) {
	        int[] qcMask = { 0, 0, QC_NFD, QC_NFKD, QC_NFC, QC_NFKC };
	
	        int norm32 = (int) GetNorm32(c_0) & qcMask[modeValue];
	
	        if (norm32 == 0) {
	            return 1; // YES
	        } else if ((norm32 & QC_ANY_NO) != 0) {
	            return 0; // NO
	        } else /* _NORM_QC_ANY_MAYBE */{
	            return 2; // MAYBE;
	        }
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Internal API, used by collation code. Get access to the internal FCD trie
	    /// table to be able to perform incremental, per-code unit, FCD checks in
	    /// collation. One pointer is sufficient because the trie index values are
	    /// offset by the index size, so that the same pointer is used to access the
	    /// trie data.
	    /// </summary>
	    ///
	    // /CLOVER:OFF
	    public CharTrie GetFCDTrie() {
	        return IBM.ICU.Impl.NormalizerImpl.FCDTrieImpl.fcdTrie;
	    }
	
	    // /CLOVER:ON
	
	    /* compare canonically equivalent ---------------------------------------- */
	
	    /*
	     * Compare two strings for canonical equivalence. Further options include
	     * case-insensitive comparison and code point order (as opposed to code unit
	     * order).
	     * 
	     * In this function, canonical equivalence is optional as well. If canonical
	     * equivalence is tested, then both strings must fulfill the FCD check.
	     * 
	     * Semantically, this is equivalent to
	     * strcmp[CodePointOrder](foldCase(NFD(s1)), foldCase(NFD(s2))) where code
	     * point order, NFD and foldCase are all optional.
	     * 
	     * String comparisons almost always yield results before processing both
	     * strings completely. They are generally more efficient working
	     * incrementally instead of performing the sub-processing (strlen,
	     * normalization, case-folding) on the entire strings first.
	     * 
	     * It is also unnecessary to not normalize identical characters.
	     * 
	     * This function works in principle as follows:
	     * 
	     * loop { get one code unit c1 from s1 (-1 if end of source) get one code
	     * unit c2 from s2 (-1 if end of source)
	     * 
	     * if(either string finished) { return result; } if(c1==c2) { continue; }
	     * 
	     * // c1!=c2 try to decompose/case-fold c1/c2, and continue if one does;
	     * 
	     * // still c1!=c2 and neither decomposes/case-folds, return result return
	     * c1-c2; }
	     * 
	     * When a character decomposes, then the pointer for that source changes to
	     * the decomposition, pushing the previous pointer onto a stack. When the
	     * end of the decomposition is reached, then the code unit reader pops the
	     * previous source from the stack. (Same for case-folding.)
	     * 
	     * This is complicated further by operating on variable-width UTF-16. The
	     * top part of the loop works on code units, while lookups for decomposition
	     * and case-folding need code points. Code points are assembled after the
	     * equality/end-of-source part. The source pointer is only advanced beyond
	     * all code units when the code point actually decomposes/case-folds.
	     * 
	     * If we were on a trail surrogate unit when assembling a code point, and
	     * the code point decomposes/case-folds, then the decomposition/folding
	     * result must be compared with the part of the other string that
	     * corresponds to this string's lead surrogate. Since we only assemble a
	     * code point when hitting a trail unit when the preceding lead units were
	     * identical, we back up the other string by one unit in such a case.
	     * 
	     * The optional code point order comparison at the end works with the same
	     * fix-up as the other code point order comparison functions. See ustring.c
	     * and the comment near the end of this function.
	     * 
	     * Assumption: A decomposition or case-folding result string never contains
	     * a single surrogate. This is a safe assumption in the Unicode Standard.
	     * Therefore, we do not need to check for surrogate pairs across
	     * decomposition/case-folding boundaries. Further assumptions (see
	     * verifications tstnorm.cpp): The API function checks for FCD first, while
	     * the core function first case-folds and then decomposes. This requires
	     * that case-folding does not un-FCD any strings.
	     * 
	     * The API function may also NFD the input and turn off decomposition. This
	     * requires that case-folding does not un-NFD strings either.
	     * 
	     * TODO If any of the above two assumptions is violated, then this entire
	     * code must be re-thought. If this happens, then a simple solution is to
	     * case-fold both strings up front and to turn off UNORM_INPUT_IS_FCD. We
	     * already do this when not both strings are in FCD because makeFCD would be
	     * a partial NFD before the case folding, which does not work. Note that all
	     * of this is only a problem when case-folding _and_ canonical equivalence
	     * come together.
	     * 
	     * This function could be moved to a different source file, at increased
	     * cost for calling the decomposition access function.
	     */
	
	    // stack element for previous-level source/decomposition pointers
	    private class CmpEquivLevel {
	        internal char[] source;
	
	        internal int start;
	
	        internal int s;
	
	        internal int limit;
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Get the canonical decomposition for one code point.
	    /// </summary>
	    ///
	    /// <param name="c_0">code point</param>
	    /// <param name="buffer">out-only buffer for algorithmic decompositions of Hangul</param>
	    /// <param name="length">out-only, takes the length of the decomposition, if any</param>
	    /// <returns>index into the extraData array, or 0 if none</returns>
	    private static int Decompose(int c_0, char[] buffer) {
	
	        long norm32;
	        int length_1 = 0;
	        norm32 = (long) ((UNSIGNED_INT_MASK) & IBM.ICU.Impl.NormalizerImpl.NormTrieImpl.normTrie
	                .GetCodePointValue(c_0));
	        if ((norm32 & QC_NFD) != 0) {
	            if (IsNorm32HangulOrJamo(norm32)) {
	                /* Hangul syllable: decompose algorithmically */
	                char c2_2;
	
	                c_0 -= HANGUL_BASE;
	
	                c2_2 = (char) (c_0 % JAMO_T_COUNT);
	                c_0 /= JAMO_T_COUNT;
	                if (c2_2 > 0) {
	                    buffer[2] = (char) (JAMO_T_BASE + c2_2);
	                    length_1 = 3;
	                } else {
	                    length_1 = 2;
	                }
	                buffer[1] = (char) (JAMO_V_BASE + c_0 % JAMO_V_COUNT);
	                buffer[0] = (char) (JAMO_L_BASE + c_0 / JAMO_V_COUNT);
	                return length_1;
	            } else {
	                /* normal decomposition */
	                NormalizerImpl.DecomposeArgs  args = new NormalizerImpl.DecomposeArgs ();
	                int index = Decompose(norm32, args);
	                System.Array.Copy((Array)(extraData),index,(Array)(buffer),0,args.length);
	                return args.length;
	            }
	        } else {
	            return 0;
	        }
	    }
	
	    private static int FoldCase(int c_0, char[] dest, int destStart,
	            int destLimit, int options) {
	        String src_1 = IBM.ICU.Text.UTF16.ValueOf(c_0);
	        String foldedStr = IBM.ICU.Lang.UCharacter.FoldCase(src_1, options);
	        char[] foldedC = foldedStr.ToCharArray();
	        for (int i = 0; i < foldedC.Length; i++) {
	            if (destStart < destLimit) {
	                dest[destStart] = foldedC[i];
	            }
	            // always increment destStart so that we can return
	            // the required length
	            destStart++;
	        }
	        return (c_0 == IBM.ICU.Text.UTF16.CharAt(foldedStr, 0)) ? -destStart : destStart;
	    }
	
	    /*
	     * private static int foldCase(char[] src,int srcStart,int srcLimit, char[]
	     * dest, int destStart, int destLimit, int options){ String source =new
	     * String(src,srcStart,(srcLimit-srcStart)); String foldedStr =
	     * UCharacter.foldCase(source,options); char[] foldedC =
	     * foldedStr.toCharArray(); for(int i=0;i<foldedC.length;i++){
	     * if(destStart<destLimit){ dest[destStart]=foldedC[i]; } // always
	     * increment destStart so that we can return // the required length
	     * destStart++;
	     * 
	     * } return destStart; }
	     */
	    public static int CmpEquivFold(String s1, String s2, int options) {
	        return CmpEquivFold(s1.ToCharArray(), 0, s1.Length, s2.ToCharArray(),
	                0, s2.Length, options);
	    }
	
	    // internal function
	    public static int CmpEquivFold(char[] s1, int s1Start, int s1Limit,
	            char[] s2, int s2Start, int s2Limit, int options) {
	        // current-level start/limit - s1/s2 as current
	        int start1, start2, limit1, limit2;
	        char[] cSource1, cSource2;
	
	        cSource1 = s1;
	        cSource2 = s2;
	        // decomposition variables
	        int length_0;
	
	        // stacks of previous-level start/current/limit
	        NormalizerImpl.CmpEquivLevel [] stack1 = new NormalizerImpl.CmpEquivLevel [] { new NormalizerImpl.CmpEquivLevel (),
	                new NormalizerImpl.CmpEquivLevel () };
	        NormalizerImpl.CmpEquivLevel [] stack2 = new NormalizerImpl.CmpEquivLevel [] { new NormalizerImpl.CmpEquivLevel (),
	                new NormalizerImpl.CmpEquivLevel () };
	
	        // decomposition buffers for Hangul
	        char[] decomp1 = new char[8];
	        char[] decomp2 = new char[8];
	
	        // case folding buffers, only use current-level start/limit
	        char[] fold1 = new char[32];
	        char[] fold2 = new char[32];
	
	        // track which is the current level per string
	        int level1, level2;
	
	        // current code units, and code points for lookups
	        int c1, c2_1;
	        int cp1, cp2;
	
	        // no argument error checking because this itself is not an API
	
	        // assume that at least one of the options COMPARE_EQUIV and
	        // COMPARE_IGNORE_CASE is set
	        // otherwise this function must behave exactly as uprv_strCompare()
	        // not checking for that here makes testing this function easier
	
	        // initialize
	        start1 = s1Start;
	        limit1 = s1Limit;
	
	        start2 = s2Start;
	        limit2 = s2Limit;
	
	        level1 = level2 = 0;
	        c1 = c2_1 = -1;
	        cp1 = cp2 = -1;
	        // comparison loop
	        for (;;) {
	            // here a code unit value of -1 means "get another code unit"
	            // below it will mean "this source is finished"
	
	            if (c1 < 0) {
	                // get next code unit from string 1, post-increment
	                for (;;) {
	                    if (s1Start >= limit1) {
	                        if (level1 == 0) {
	                            c1 = -1;
	                            break;
	                        }
	                    } else {
	                        c1 = cSource1[s1Start];
	                        ++s1Start;
	                        break;
	                    }
	
	                    // reached end of level buffer, pop one level
	                    do {
	                        --level1;
	                        start1 = stack1[level1].start;
	                    } while (start1 == -1); // ###### check this
	                    s1Start = stack1[level1].s;
	                    limit1 = stack1[level1].limit;
	                    cSource1 = stack1[level1].source;
	                }
	            }
	
	            if (c2_1 < 0) {
	                // get next code unit from string 2, post-increment
	                for (;;) {
	                    if (s2Start >= limit2) {
	                        if (level2 == 0) {
	                            c2_1 = -1;
	                            break;
	                        }
	                    } else {
	                        c2_1 = cSource2[s2Start];
	                        ++s2Start;
	                        break;
	                    }
	
	                    // reached end of level buffer, pop one level
	                    do {
	                        --level2;
	                        start2 = stack2[level2].start;
	                    } while (start2 == -1);
	                    s2Start = stack2[level2].s;
	                    limit2 = stack2[level2].limit;
	                    cSource2 = stack2[level2].source;
	                }
	            }
	
	            // compare c1 and c2
	            // either variable c1, c2 is -1 only if the corresponding string
	            // is finished
	            if (c1 == c2_1) {
	                if (c1 < 0) {
	                    return 0; // c1==c2==-1 indicating end of strings
	                }
	                c1 = c2_1 = -1; // make us fetch new code units
	                continue;
	            } else if (c1 < 0) {
	                return -1; // string 1 ends before string 2
	            } else if (c2_1 < 0) {
	                return 1; // string 2 ends before string 1
	            }
	            // c1!=c2 && c1>=0 && c2>=0
	
	            // get complete code points for c1, c2 for lookups if either is a
	            // surrogate
	            cp1 = c1;
	            if (IBM.ICU.Text.UTF16.IsSurrogate((char) c1)) {
	                char c_2;
	
	                if (IBM.ICU.Text.UTF16.IsLeadSurrogate((char) c1)) {
	                    if (s1Start != limit1
	                            && IBM.ICU.Text.UTF16.IsTrailSurrogate(c_2 = cSource1[s1Start])) {
	                        // advance ++s1; only below if cp1 decomposes/case-folds
	                        cp1 = IBM.ICU.Impl.UCharacterProperty.GetRawSupplementary((char) c1,
	                                c_2);
	                    }
	                } else /* isTrail(c1) */{
	                    if (start1 <= (s1Start - 2)
	                            && IBM.ICU.Text.UTF16.IsLeadSurrogate(c_2 = cSource1[(s1Start - 2)])) {
	                        cp1 = IBM.ICU.Impl.UCharacterProperty.GetRawSupplementary(c_2,
	                                (char) c1);
	                    }
	                }
	            }
	            cp2 = c2_1;
	            if (IBM.ICU.Text.UTF16.IsSurrogate((char) c2_1)) {
	                char c_3;
	
	                if (IBM.ICU.Text.UTF16.IsLeadSurrogate((char) c2_1)) {
	                    if (s2Start != limit2
	                            && IBM.ICU.Text.UTF16.IsTrailSurrogate(c_3 = cSource2[s2Start])) {
	                        // advance ++s2; only below if cp2 decomposes/case-folds
	                        cp2 = IBM.ICU.Impl.UCharacterProperty.GetRawSupplementary((char) c2_1,
	                                c_3);
	                    }
	                } else /* isTrail(c2) */{
	                    if (start2 <= (s2Start - 2)
	                            && IBM.ICU.Text.UTF16.IsLeadSurrogate(c_3 = cSource2[s2Start - 2])) {
	                        cp2 = IBM.ICU.Impl.UCharacterProperty.GetRawSupplementary(c_3,
	                                (char) c2_1);
	                    }
	                }
	            }
	
	            // go down one level for each string
	            // continue with the main loop as soon as there is a real change
	            if (level1 < 2 && ((options & IBM.ICU.Text.Normalizer.COMPARE_IGNORE_CASE) != 0)
	                    && (length_0 = FoldCase(cp1, fold1, 0, 32, options)) >= 0) {
	                // cp1 case-folds to fold1[length]
	                if (IBM.ICU.Text.UTF16.IsSurrogate((char) c1)) {
	                    if (IBM.ICU.Text.UTF16.IsLeadSurrogate((char) c1)) {
	                        // advance beyond source surrogate pair if it
	                        // case-folds
	                        ++s1Start;
	                    } else /* isTrail(c1) */{
	                        // we got a supplementary code point when hitting its
	                        // trail surrogate, therefore the lead surrogate must
	                        // have been the same as in the other string;
	                        // compare this decomposition with the lead surrogate
	                        // in the other string
	                        --s2Start;
	                        c2_1 = cSource2[(s2Start - 1)];
	                    }
	                }
	
	                // push current level pointers
	                stack1[0].start = start1;
	                stack1[0].s = s1Start;
	                stack1[0].limit = limit1;
	                stack1[0].source = cSource1;
	                ++level1;
	
	                cSource1 = fold1;
	                start1 = s1Start = 0;
	                limit1 = length_0;
	
	                // get ready to read from decomposition, continue with loop
	                c1 = -1;
	                continue;
	            }
	
	            if (level2 < 2 && ((options & IBM.ICU.Text.Normalizer.COMPARE_IGNORE_CASE) != 0)
	                    && (length_0 = FoldCase(cp2, fold2, 0, 32, options)) >= 0) {
	                // cp2 case-folds to fold2[length]
	                if (IBM.ICU.Text.UTF16.IsSurrogate((char) c2_1)) {
	                    if (IBM.ICU.Text.UTF16.IsLeadSurrogate((char) c2_1)) {
	                        // advance beyond source surrogate pair if it
	                        // case-folds
	                        ++s2Start;
	                    } else /* isTrail(c2) */{
	                        // we got a supplementary code point when hitting its
	                        // trail surrogate, therefore the lead surrogate must
	                        // have been the same as in the other string;
	                        // compare this decomposition with the lead surrogate
	                        // in the other string
	                        --s1Start;
	                        c1 = cSource1[(s1Start - 1)];
	                    }
	                }
	
	                // push current level pointers
	                stack2[0].start = start2;
	                stack2[0].s = s2Start;
	                stack2[0].limit = limit2;
	                stack2[0].source = cSource2;
	                ++level2;
	
	                cSource2 = fold2;
	                start2 = s2Start = 0;
	                limit2 = length_0;
	
	                // get ready to read from decomposition, continue with loop
	                c2_1 = -1;
	                continue;
	            }
	
	            if (level1 < 2 && ((options & COMPARE_EQUIV) != 0)
	                    && 0 != (length_0 = Decompose(cp1, decomp1))) {
	                // cp1 decomposes into p[length]
	                if (IBM.ICU.Text.UTF16.IsSurrogate((char) c1)) {
	                    if (IBM.ICU.Text.UTF16.IsLeadSurrogate((char) c1)) {
	                        // advance beyond source surrogate pair if it
	                        // decomposes
	                        ++s1Start;
	                    } else /* isTrail(c1) */{
	                        // we got a supplementary code point when hitting
	                        // its trail surrogate, therefore the lead surrogate
	                        // must have been the same as in the other string;
	                        // compare this decomposition with the lead surrogate
	                        // in the other string
	                        --s2Start;
	                        c2_1 = cSource2[(s2Start - 1)];
	                    }
	                }
	
	                // push current level pointers
	                stack1[level1].start = start1;
	                stack1[level1].s = s1Start;
	                stack1[level1].limit = limit1;
	                stack1[level1].source = cSource1;
	                ++level1;
	
	                // set next level pointers to decomposition
	                cSource1 = decomp1;
	                start1 = s1Start = 0;
	                limit1 = length_0;
	
	                // set empty intermediate level if skipped
	                if (level1 < 2) {
	                    stack1[level1++].start = -1;
	                }
	                // get ready to read from decomposition, continue with loop
	                c1 = -1;
	                continue;
	            }
	
	            if (level2 < 2 && ((options & COMPARE_EQUIV) != 0)
	                    && 0 != (length_0 = Decompose(cp2, decomp2))) {
	                // cp2 decomposes into p[length]
	                if (IBM.ICU.Text.UTF16.IsSurrogate((char) c2_1)) {
	                    if (IBM.ICU.Text.UTF16.IsLeadSurrogate((char) c2_1)) {
	                        // advance beyond source surrogate pair if it
	                        // decomposes
	                        ++s2Start;
	                    } else /* isTrail(c2) */{
	                        // we got a supplementary code point when hitting its
	                        // trail surrogate, therefore the lead surrogate must
	                        // have been the same as in the other string;
	                        // compare this decomposition with the lead surrogate
	                        // in the other string
	                        --s1Start;
	                        c1 = cSource1[(s1Start - 1)];
	                    }
	                }
	
	                // push current level pointers
	                stack2[level2].start = start2;
	                stack2[level2].s = s2Start;
	                stack2[level2].limit = limit2;
	                stack2[level2].source = cSource2;
	                ++level2;
	
	                // set next level pointers to decomposition
	                cSource2 = decomp2;
	                start2 = s2Start = 0;
	                limit2 = length_0;
	
	                // set empty intermediate level if skipped
	                if (level2 < 2) {
	                    stack2[level2++].start = -1;
	                }
	
	                // get ready to read from decomposition, continue with loop
	                c2_1 = -1;
	                continue;
	            }
	
	            // no decomposition/case folding, max level for both sides:
	            // return difference result
	
	            // code point order comparison must not just return cp1-cp2
	            // because when single surrogates are present then the surrogate
	            // pairs that formed cp1 and cp2 may be from different string
	            // indexes
	
	            // example: { d800 d800 dc01 } vs. { d800 dc00 }, compare at
	            // second code units
	            // c1=d800 cp1=10001 c2=dc00 cp2=10000
	            // cp1-cp2>0 but c1-c2<0 and in fact in UTF-32
	            // it is { d800 10001 } < { 10000 }
	            // therefore fix-up
	
	            if (c1 >= 0xd800 && c2_1 >= 0xd800
	                    && ((options & IBM.ICU.Text.Normalizer.COMPARE_CODE_POINT_ORDER) != 0)) {
	                /*
	                 * subtract 0x2800 from BMP code points to make them smaller
	                 * than supplementary ones
	                 */
	                if ((c1 <= 0xdbff && s1Start != limit1 && IBM.ICU.Text.UTF16
	                        .IsTrailSurrogate(cSource1[s1Start]))
	                        || (IBM.ICU.Text.UTF16.IsTrailSurrogate((char) c1)
	                                && start1 != (s1Start - 1) && IBM.ICU.Text.UTF16
	                                .IsLeadSurrogate(cSource1[(s1Start - 2)]))) {
	                    /* part of a surrogate pair, leave >=d800 */
	                } else {
	                    /*
	                     * BMP code point - may be surrogate code point - make <d800
	                     */
	                    c1 -= 0x2800;
	                }
	
	                if ((c2_1 <= 0xdbff && s2Start != limit2 && IBM.ICU.Text.UTF16
	                        .IsTrailSurrogate(cSource2[s2Start]))
	                        || (IBM.ICU.Text.UTF16.IsTrailSurrogate((char) c2_1)
	                                && start2 != (s2Start - 1) && IBM.ICU.Text.UTF16
	                                .IsLeadSurrogate(cSource2[(s2Start - 2)]))) {
	                    /* part of a surrogate pair, leave >=d800 */
	                } else {
	                    /*
	                     * BMP code point - may be surrogate code point - make <d800
	                     */
	                    c2_1 -= 0x2800;
	                }
	            }
	
	            return c1 - c2_1;
	        }
	    }
	
	    private static int StrCompare(char[] s1, int s1Start, int s1Limit,
	            char[] s2, int s2Start, int s2Limit, bool codePointOrder) {
	
	        int start1, start2, limit1, limit2;
	
	        char c1, c2_0;
	
	        /* setup for fix-up */
	        start1 = s1Start;
	        start2 = s2Start;
	
	        int length1, length2;
	
	        length1 = s1Limit - s1Start;
	        length2 = s2Limit - s2Start;
	
	        int lengthResult;
	
	        if (length1 < length2) {
	            lengthResult = -1;
	            limit1 = start1 + length1;
	        } else if (length1 == length2) {
	            lengthResult = 0;
	            limit1 = start1 + length1;
	        } else /* length1>length2 */{
	            lengthResult = 1;
	            limit1 = start1 + length2;
	        }
	
	        if (s1 == s2) {
	            return lengthResult;
	        }
	
	        for (;;) {
	            /* check pseudo-limit */
	            if (s1Start == limit1) {
	                return lengthResult;
	            }
	
	            c1 = s1[s1Start];
	            c2_0 = s2[s2Start];
	            if (c1 != c2_0) {
	                break;
	            }
	            ++s1Start;
	            ++s2Start;
	        }
	
	        /* setup for fix-up */
	        limit1 = start1 + length1;
	        limit2 = start2 + length2;
	
	        /* if both values are in or above the surrogate range, fix them up */
	        if (c1 >= 0xd800 && c2_0 >= 0xd800 && codePointOrder) {
	            /*
	             * subtract 0x2800 from BMP code points to make them smaller than
	             * supplementary ones
	             */
	            if ((c1 <= 0xdbff && (s1Start + 1) != limit1 && IBM.ICU.Text.UTF16
	                    .IsTrailSurrogate(s1[(s1Start + 1)]))
	                    || (IBM.ICU.Text.UTF16.IsTrailSurrogate(c1) && start1 != s1Start && IBM.ICU.Text.UTF16
	                            .IsLeadSurrogate(s1[(s1Start - 1)]))) {
	                /* part of a surrogate pair, leave >=d800 */
	            } else {
	                /* BMP code point - may be surrogate code point - make <d800 */
	                c1 -= ((Char)0x2800);
	            }
	
	            if ((c2_0 <= 0xdbff && (s2Start + 1) != limit2 && IBM.ICU.Text.UTF16
	                    .IsTrailSurrogate(s2[(s2Start + 1)]))
	                    || (IBM.ICU.Text.UTF16.IsTrailSurrogate(c2_0) && start2 != s2Start && IBM.ICU.Text.UTF16
	                            .IsLeadSurrogate(s2[(s2Start - 1)]))) {
	                /* part of a surrogate pair, leave >=d800 */
	            } else {
	                /* BMP code point - may be surrogate code point - make <d800 */
	                c2_0 -= ((Char)0x2800);
	            }
	        }
	
	        /* now c1 and c2 are in UTF-32-compatible order */
	        return (int) c1 - (int) c2_0;
	    }
	
	    /*
	     * Status of tailored normalization
	     * 
	     * This was done initially for investigation on Unicode public review issue
	     * 7 (http://www.unicode.org/review/). See Jitterbug 2481. While the UTC at
	     * meeting #94 (2003mar) did not take up the issue, this is a permanent
	     * feature in ICU 2.6 in support of IDNA which requires true Unicode 3.2
	     * normalization. (NormalizationCorrections are rolled into IDNA mapping
	     * tables.)
	     * 
	     * Tailored normalization as implemented here allows to "normalize less"
	     * than full Unicode normalization would. Based internally on a UnicodeSet
	     * of code points that are "excluded from normalization", the normalization
	     * functions leave those code points alone ("inert"). This means that
	     * tailored normalization still transforms text into a canonically
	     * equivalent form. It does not add decompositions to code points that do
	     * not have any or change decomposition results.
	     * 
	     * Any function that searches for a safe boundary has not been touched,
	     * which means that these functions will be over-pessimistic when exclusions
	     * are applied. This should not matter because subsequent checks and
	     * normalizations do apply the exclusions; only a little more of the text
	     * may be processed than necessary under exclusions.
	     * 
	     * Normalization exclusions have the following effect on excluded code
	     * points c: - c is not decomposed - c is not a composition target - c does
	     * not combine forward or backward for composition except that this is not
	     * implemented for Jamo - c is treated as having a combining class of 0
	     */
	
	    /*
	     * Constants for the bit fields in the options bit set parameter. These need
	     * not be public. A user only needs to know the currently assigned values.
	     * The number and positions of reserved bits per field can remain private.
	     */
	    private const int OPTIONS_NX_MASK = 0x1f;
	
	    private const int OPTIONS_UNICODE_MASK = 0xe0;
	
	    public const int OPTIONS_SETS_MASK = 0xff;
	
	    // private static final int OPTIONS_UNICODE_SHIFT=5;
	    private static readonly UnicodeSet[] nxCache = new UnicodeSet[OPTIONS_SETS_MASK + 1];
	
	    /* Constants for options flags for normalization. */
	
	    /// <summary>
	    /// Options bit 0, do not decompose Hangul syllables.
	    /// </summary>
	    ///
	    /// @draft ICU 2.6
	    private const int NX_HANGUL = 1;
	
	    /// <summary>
	    /// Options bit 1, do not decompose CJK compatibility characters.
	    /// </summary>
	    ///
	    /// @draft ICU 2.6
	    private const int NX_CJK_COMPAT = 2;
	
	    /// <summary>
	    /// Options bit 8, use buggy recomposition described in Unicode Public Review
	    /// Issue #29 at http://www.unicode.org/review/resolved-pri.html#pri29
	    /// Used in IDNA implementation according to strict interpretation of IDNA
	    /// definition based on Unicode 3.2 which predates PRI #29.
	    /// See ICU4C unormimp.h
	    /// </summary>
	    ///
	    /// @draft ICU 3.2
	    public const int BEFORE_PRI_29 = 0x100;
	
	    /*
	     * The following options are used only in some composition functions. They
	     * use bits 12 and up to preserve lower bits for the available options space
	     * in unorm_compare() - see documentation for
	     * UNORM_COMPARE_NORM_OPTIONS_SHIFT.
	     */
	
	    /// <summary>
	    /// Options bit 12, for compatibility vs. canonical decomposition. 
	    /// </summary>
	    ///
	    public const int OPTIONS_COMPAT = 0x1000;
	
	    /// <summary>
	    /// Options bit 13, no discontiguous composition (FCC vs. NFC). 
	    /// </summary>
	    ///
	    public const int OPTIONS_COMPOSE_CONTIGUOUS = 0x2000;
	
	    /*
	     * normalization exclusion sets
	     * ---------------------------------------------
	     */
	
	    /*
	     * Normalization exclusion UnicodeSets are used for tailored normalization;
	     * see the comment near the beginning of this file.
	     * 
	     * By specifying one or several sets of code points, those code points
	     * become inert for normalization.
	     */
	    [MethodImpl(MethodImplOptions.Synchronized)]
	    private static UnicodeSet InternalGetNXHangul() {
	        /* internal function, does not check for incoming U_FAILURE */
	
	        if (nxCache[NX_HANGUL] == null) {
	            nxCache[NX_HANGUL] = new UnicodeSet(0xac00, 0xd7a3);
	        }
	        return nxCache[NX_HANGUL];
	    }
	
	    [MethodImpl(MethodImplOptions.Synchronized)]
	    private static UnicodeSet InternalGetNXCJKCompat() {
	        /* internal function, does not check for incoming U_FAILURE */
	
	        if (nxCache[NX_CJK_COMPAT] == null) {
	
	            /* build a set from [CJK Ideographs]&[has canonical decomposition] */
	            UnicodeSet set, hasDecomp;
	
	            set = new UnicodeSet("[:Ideographic:]");
	
	            /* start with an empty set for [has canonical decomposition] */
	            hasDecomp = new UnicodeSet();
	
	            /*
	             * iterate over all ideographs and remember which canonically
	             * decompose
	             */
	            UnicodeSetIterator it = new UnicodeSetIterator(set);
	            int start_0, end;
	            long norm32;
	
	            while (it.NextRange()
	                    && (it.codepoint != IBM.ICU.Text.UnicodeSetIterator.IS_STRING)) {
	                start_0 = it.codepoint;
	                end = it.codepointEnd;
	                while (start_0 <= end) {
	                    norm32 = GetNorm32(start_0);
	                    if ((norm32 & QC_NFD) > 0) {
	                        hasDecomp.Add(start_0);
	                    }
	                    ++start_0;
	                }
	            }
	
	            /* hasDecomp now contains all ideographs that decompose canonically */
	            nxCache[NX_CJK_COMPAT] = hasDecomp;
	
	        }
	
	        return nxCache[NX_CJK_COMPAT];
	    }
	
	    [MethodImpl(MethodImplOptions.Synchronized)]
	    private static UnicodeSet InternalGetNXUnicode(
	            int options) {
	        options &= OPTIONS_UNICODE_MASK;
	        if (options == 0) {
	            return null;
	        }
	
	        if (nxCache[options] == null) {
	            /*
	             * build a set with all code points that were not designated by the
	             * specified Unicode version
	             */
	            UnicodeSet set = new UnicodeSet();
	
	            switch (options) {
	            case IBM.ICU.Text.Normalizer.UNICODE_3_2:
	                set.ApplyPattern("[:^Age=3.2:]");
	                break;
	            default:
	                return null;
	            }
	
	            nxCache[options] = set;
	        }
	
	        return nxCache[options];
	    }
	
	    /* Get a decomposition exclusion set. The data must be loaded. */
	    [MethodImpl(MethodImplOptions.Synchronized)]
	    private static UnicodeSet InternalGetNX(int options) {
	        options &= OPTIONS_SETS_MASK;
	
	        if (nxCache[options] == null) {
	            /* return basic sets */
	            if (options == NX_HANGUL) {
	                return InternalGetNXHangul();
	            }
	            if (options == NX_CJK_COMPAT) {
	                return InternalGetNXCJKCompat();
	            }
	            if ((options & OPTIONS_UNICODE_MASK) != 0
	                    && (options & OPTIONS_NX_MASK) == 0) {
	                return InternalGetNXUnicode(options);
	            }
	
	            /* build a set from multiple subsets */
	            UnicodeSet set;
	            UnicodeSet other;
	
	            set = new UnicodeSet();
	
	            if ((options & NX_HANGUL) != 0
	                    && null != (other = InternalGetNXHangul())) {
	                set.AddAll(other);
	            }
	            if ((options & NX_CJK_COMPAT) != 0
	                    && null != (other = InternalGetNXCJKCompat())) {
	                set.AddAll(other);
	            }
	            if ((options & OPTIONS_UNICODE_MASK) != 0
	                    && null != (other = InternalGetNXUnicode(options))) {
	                set.AddAll(other);
	            }
	
	            nxCache[options] = set;
	        }
	        return nxCache[options];
	    }
	
	    public static UnicodeSet GetNX(int options) {
	        if ((options &= OPTIONS_SETS_MASK) == 0) {
	            /* incoming failure, or no decomposition exclusions requested */
	            return null;
	        } else {
	            return InternalGetNX(options);
	        }
	    }
	
	    private static bool Nx_contains(UnicodeSet nx, int c_0) {
	        return nx != null && nx.Contains(c_0);
	    }
	
	    private static bool Nx_contains(UnicodeSet nx, char c_0, char c2_1) {
	        return nx != null
	                && nx.Contains((c2_1 == 0) ? (int) (c_0) : (int) (IBM.ICU.Impl.UCharacterProperty.GetRawSupplementary(
	                        c_0, c2_1)));
	    }
	
	    static NormalizerImpl() {
	            try {
	                IMPL = new NormalizerImpl();
	            } catch (Exception e) {
	                throw new MissingManifestResourceException(e.Message);
	            }
	        }
	
	}
}
