//##header J2SE15
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:30 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 1996-2007, International Business Machines Corporation and    
/// others. All Rights Reserved.                                                
/// </summary>
///
namespace IBM.ICU.Text {
	
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Text;
	
	
	/// <summary>
	/// <p>
	/// Standalone utility class providing UTF16 character conversions and indexing
	/// conversions.
	/// </p>
	/// <p>
	/// Code that uses strings alone rarely need modification. By design, UTF-16 does
	/// not allow overlap, so searching for strings is a safe operation. Similarly,
	/// concatenation is always safe. Substringing is safe if the start and end are
	/// both on UTF-32 boundaries. In normal code, the values for start and end are
	/// on those boundaries, since they arose from operations like searching. If not,
	/// the nearest UTF-32 boundaries can be determined using <c>bounds()</c>.
	/// </p>
	/// <strong>Examples:</strong>
	/// <p>
	/// The following examples illustrate use of some of these methods.
	/// <pre>
	/// // iteration forwards: Original
	/// for (int i = 0; i &lt; s.length(); ++i) {
	/// char ch = s.charAt(i);
	/// doSomethingWith(ch);
	/// }
	/// // iteration forwards: Changes for UTF-32
	/// int ch;
	/// for (int i = 0; i &lt; s.length(); i += UTF16.getCharCount(ch)) {
	/// ch = UTF16.charAt(s, i);
	/// doSomethingWith(ch);
	/// }
	/// // iteration backwards: Original
	/// for (int i = s.length() - 1; i &gt;= 0; --i) {
	/// char ch = s.charAt(i);
	/// doSomethingWith(ch);
	/// }
	/// // iteration backwards: Changes for UTF-32
	/// int ch;
	/// for (int i = s.length() - 1; i &gt; 0; i -= UTF16.getCharCount(ch)) {
	/// ch = UTF16.charAt(s, i);
	/// doSomethingWith(ch);
	/// }
	/// </pre>
	/// <strong>Notes:</strong>
	/// <ul>
	/// <li><strong>Naming:</strong> For clarity, High and Low surrogates are called
	/// <c>Lead</c> and <c>Trail</c> in the API, which gives a better
	/// sense of their ordering in a string. <c>offset16</c> and
	/// <c>offset32</c> are used to distinguish offsets to UTF-16 boundaries vs
	/// offsets to UTF-32 boundaries. <c>int char32</c> is used to contain
	/// UTF-32 characters, as opposed to <c>char16</c>, which is a UTF-16 code
	/// unit.</li>
	/// <li><strong>Roundtripping Offsets:</strong> You can always roundtrip from a
	/// UTF-32 offset to a UTF-16 offset and back. Because of the difference in
	/// structure, you can roundtrip from a UTF-16 offset to a UTF-32 offset and back
	/// if and only if <c>bounds(string, offset16) != TRAIL</c>.</li>
	/// <li><strong>Exceptions:</strong> The error checking will throw an exception
	/// if indices are out of bounds. Other than than that, all methods will behave
	/// reasonably, even if unmatched surrogates or out-of-bounds UTF-32 values are
	/// present. <c>UCharacter.isLegal()</c> can be used to check for validity
	/// if desired.</li>
	/// <li><strong>Unmatched Surrogates:</strong> If the string contains unmatched
	/// surrogates, then these are counted as one UTF-32 value. This matches their
	/// iteration behavior, which is vital. It also matches common display practice
	/// as missing glyphs (see the Unicode Standard Section 5.4, 5.5).</li>
	/// <li><strong>Optimization:</strong> The method implementations may need
	/// optimization if the compiler doesn't fold static final methods. Since
	/// surrogate pairs will form an exceeding small percentage of all the text in
	/// the world, the singleton case should always be optimized for.</li>
	/// </ul>
	/// </summary>
	///
	/// @stable ICU 2.1
	
	public sealed class UTF16 {
	    // public variables ---------------------------------------------------
	
	    /// <summary>
	    /// Value returned in <code><a href="#bounds(java.lang.String, int)">
	    /// bounds()</a></code>. These values are chosen specifically so that it
	    /// actually represents the position of the character [offset16 - (value >>
	    /// 2), offset16 + (value & 3)]
	    /// </summary>
	    ///
	    /// @stable ICU 2.1
	    public const int SINGLE_CHAR_BOUNDARY = 1,
	            LEAD_SURROGATE_BOUNDARY = 2, TRAIL_SURROGATE_BOUNDARY = 5;
	
	    /// <summary>
	    /// The lowest Unicode code point value.
	    /// </summary>
	    ///
	    /// @stable ICU 2.1
	    public const int CODEPOINT_MIN_VALUE = 0;
	
	    /// <summary>
	    /// The highest Unicode code point value (scalar value) according to the
	    /// Unicode Standard.
	    /// </summary>
	    ///
	    /// @stable ICU 2.1
	    public const int CODEPOINT_MAX_VALUE = 0x10ffff;
	
	    /// <summary>
	    /// The minimum value for Supplementary code points
	    /// </summary>
	    ///
	    /// @stable ICU 2.1
	    public const int SUPPLEMENTARY_MIN_VALUE = 0x10000;
	
	    /// <summary>
	    /// Lead surrogate minimum value
	    /// </summary>
	    ///
	    /// @stable ICU 2.1
	    public const int LEAD_SURROGATE_MIN_VALUE = 0xD800;
	
	    /// <summary>
	    /// Trail surrogate minimum value
	    /// </summary>
	    ///
	    /// @stable ICU 2.1
	    public const int TRAIL_SURROGATE_MIN_VALUE = 0xDC00;
	
	    /// <summary>
	    /// Lead surrogate maximum value
	    /// </summary>
	    ///
	    /// @stable ICU 2.1
	    public const int LEAD_SURROGATE_MAX_VALUE = 0xDBFF;
	
	    /// <summary>
	    /// Trail surrogate maximum value
	    /// </summary>
	    ///
	    /// @stable ICU 2.1
	    public const int TRAIL_SURROGATE_MAX_VALUE = 0xDFFF;
	
	    /// <summary>
	    /// Surrogate minimum value
	    /// </summary>
	    ///
	    /// @stable ICU 2.1
	    public const int SURROGATE_MIN_VALUE = LEAD_SURROGATE_MIN_VALUE;
	
	    /// <summary>
	    /// Maximum surrogate value
	    /// </summary>
	    ///
	    /// @stable ICU 2.1
	    public const int SURROGATE_MAX_VALUE = TRAIL_SURROGATE_MAX_VALUE;
	
	    /// <summary>
	    /// Lead surrogate bitmask
	    /// </summary>
	    ///
	    private const int LEAD_SURROGATE_BITMASK = -1024;
	
	    /// <summary>
	    /// Trail surrogate bitmask
	    /// </summary>
	    ///
	    private const int TRAIL_SURROGATE_BITMASK = -1024;
	
	    /// <summary>
	    /// Surrogate bitmask
	    /// </summary>
	    ///
	    private const int SURROGATE_BITMASK = -2048;
	
	    /// <summary>
	    /// Lead surrogate bits
	    /// </summary>
	    ///
	    private const int LEAD_SURROGATE_BITS = 0xD800;
	
	    /// <summary>
	    /// Trail surrogate bits
	    /// </summary>
	    ///
	    private const int TRAIL_SURROGATE_BITS = 0xDC00;
	
	    /// <summary>
	    /// Surrogate bits
	    /// </summary>
	    ///
	    private const int SURROGATE_BITS = 0xD800;
	
	    // constructor --------------------------------------------------------
	
	    // /CLOVER:OFF
	    /// <summary>
	    /// Prevent instance from being created.
	    /// </summary>
	    ///
	    private UTF16() {
	    }
	
	    // /CLOVER:ON
	    // public method ------------------------------------------------------
	
	    /// <summary>
	    /// Extract a single UTF-32 value from a string. Used when iterating forwards
	    /// or backwards (with <c>UTF16.getCharCount()</c>, as well as random
	    /// access. If a validity check is required, use
	    /// <code><a href="../lang/UCharacter.html#isLegal(char)">
	    /// UCharacter.isLegal()</a></code> on the return value. If the char
	    /// retrieved is part of a surrogate pair, its supplementary character will
	    /// be returned. If a complete supplementary character is not found the
	    /// incomplete character will be returned
	    /// </summary>
	    ///
	    /// <param name="source">array of UTF-16 chars</param>
	    /// <param name="offset16">UTF-16 offset to the start of the character.</param>
	    /// <returns>UTF-32 value for the UTF-32 value that contains the char at
	    /// offset16. The boundaries of that codepoint are the same as in
	    /// <c>bounds32()</c>.</returns>
	    /// <exception cref="IndexOutOfBoundsException">thrown if offset16 is out of bounds.</exception>
	    /// @stable ICU 2.1
	    public static int CharAt(String source, int offset16) {
	        char single = source[offset16];
	        if (single < LEAD_SURROGATE_MIN_VALUE) {
	            return single;
	        }
	        return _charAt(source, offset16, single);
	    }
	
	    private static int _charAt(String source, int offset16, char single) {
	        if (single > TRAIL_SURROGATE_MAX_VALUE) {
	            return single;
	        }
	
	        // Convert the UTF-16 surrogate pair if necessary.
	        // For simplicity in usage, and because the frequency of pairs is
	        // low, look both directions.
	
	        if (single <= LEAD_SURROGATE_MAX_VALUE) {
	            ++offset16;
	            if (source.Length != offset16) {
	                char trail = source[offset16];
	                if (trail >= TRAIL_SURROGATE_MIN_VALUE
	                        && trail <= TRAIL_SURROGATE_MAX_VALUE) {
	                    return IBM.ICU.Impl.UCharacterProperty
	                            .GetRawSupplementary(single, trail);
	                }
	            }
	        } else {
	            --offset16;
	            if (offset16 >= 0) {
	                // single is a trail surrogate so
	                char lead = source[offset16];
	                if (lead >= LEAD_SURROGATE_MIN_VALUE
	                        && lead <= LEAD_SURROGATE_MAX_VALUE) {
	                    return IBM.ICU.Impl.UCharacterProperty.GetRawSupplementary(lead, single);
	                }
	            }
	        }
	        return single; // return unmatched surrogate
	    }
	
	    // #if defined(FOUNDATION10) || defined(J2SE13)
	    // #else
	    /// <summary>
	    /// Extract a single UTF-32 value from a string. Used when iterating forwards
	    /// or backwards (with <c>UTF16.getCharCount()</c>, as well as random
	    /// access. If a validity check is required, use
	    /// <code><a href="../lang/UCharacter.html#isLegal(char)">
	    /// UCharacter.isLegal()</a></code> on the return value. If the char
	    /// retrieved is part of a surrogate pair, its supplementary character will
	    /// be returned. If a complete supplementary character is not found the
	    /// incomplete character will be returned
	    /// </summary>
	    ///
	    /// <param name="source">array of UTF-16 chars</param>
	    /// <param name="offset16">UTF-16 offset to the start of the character.</param>
	    /// <returns>UTF-32 value for the UTF-32 value that contains the char at
	    /// offset16. The boundaries of that codepoint are the same as in
	    /// <c>bounds32()</c>.</returns>
	    /// <exception cref="IndexOutOfBoundsException">thrown if offset16 is out of bounds.</exception>
	    /// @stable ICU 2.1
	   /* public static int CharAt(String source, int offset16) {
	        char single = source[offset16];
	        if (single < UTF16.LEAD_SURROGATE_MIN_VALUE) {
	            return single;
	        }
	        return _charAt(source, offset16, single);
	    }*/
	
	    /*private static int _charAt(String source, int offset16, char single) {
	        if (single > UTF16.TRAIL_SURROGATE_MAX_VALUE) {
	            return single;
	        }
	
	        // Convert the UTF-16 surrogate pair if necessary.
	        // For simplicity in usage, and because the frequency of pairs is
	        // low, look both directions.
	
	        if (single <= UTF16.LEAD_SURROGATE_MAX_VALUE) {
	            ++offset16;
	            if (source.Length != offset16) {
	                char trail = source[offset16];
	                if (trail >= UTF16.TRAIL_SURROGATE_MIN_VALUE
	                        && trail <= UTF16.TRAIL_SURROGATE_MAX_VALUE) {
	                    return IBM.ICU.Impl.UCharacterProperty
	                            .GetRawSupplementary(single, trail);
	                }
	            }
	        } else {
	            --offset16;
	            if (offset16 >= 0) {
	                // single is a trail surrogate so
	                char lead = source[offset16];
	                if (lead >= UTF16.LEAD_SURROGATE_MIN_VALUE
	                        && lead <= UTF16.LEAD_SURROGATE_MAX_VALUE) {
	                    return IBM.ICU.Impl.UCharacterProperty.GetRawSupplementary(lead, single);
	                }
	            }
	        }
	        return single; // return unmatched surrogate
	    }*/
	
	    // #endif
	
	    /// <summary>
	    /// Extract a single UTF-32 value from a string. Used when iterating forwards
	    /// or backwards (with <c>UTF16.getCharCount()</c>, as well as random
	    /// access. If a validity check is required, use
	    /// <code><a href="../lang/UCharacter.html#isLegal(char)">UCharacter.isLegal()
	    /// </a></code> on the return value. If the char retrieved is part of a
	    /// surrogate pair, its supplementary character will be returned. If a
	    /// complete supplementary character is not found the incomplete character
	    /// will be returned
	    /// </summary>
	    ///
	    /// <param name="source">UTF-16 chars string buffer</param>
	    /// <param name="offset16">UTF-16 offset to the start of the character.</param>
	    /// <returns>UTF-32 value for the UTF-32 value that contains the char at
	    /// offset16. The boundaries of that codepoint are the same as in
	    /// <c>bounds32()</c>.</returns>
	    /// <exception cref="IndexOutOfBoundsException">thrown if offset16 is out of bounds.</exception>
	    /// @stable ICU 2.1
	    public static int CharAt(StringBuilder source, int offset16) {
	        if (offset16 < 0 || offset16 >= source.Length) {
                throw new ArgumentOutOfRangeException(offset16.ToString());
	        }
	
	        char single = source[offset16];
	        if (!IsSurrogate(single)) {
	            return single;
	        }
	
	        // Convert the UTF-16 surrogate pair if necessary.
	        // For simplicity in usage, and because the frequency of pairs is
	        // low, look both directions.
	
	        if (single <= LEAD_SURROGATE_MAX_VALUE) {
	            ++offset16;
	            if (source.Length != offset16) {
	                char trail = source[offset16];
	                if (IsTrailSurrogate(trail))
	                    return IBM.ICU.Impl.UCharacterProperty
	                            .GetRawSupplementary(single, trail);
	            }
	        } else {
	            --offset16;
	            if (offset16 >= 0) {
	                // single is a trail surrogate so
	                char lead = source[offset16];
	                if (IsLeadSurrogate(lead)) {
	                    return IBM.ICU.Impl.UCharacterProperty.GetRawSupplementary(lead, single);
	                }
	            }
	        }
	        return single; // return unmatched surrogate
	    }
	
	    /// <summary>
	    /// Extract a single UTF-32 value from a substring. Used when iterating
	    /// forwards or backwards (with <c>UTF16.getCharCount()</c>, as well as
	    /// random access. If a validity check is required, use
	    /// <code><a href="../lang/UCharacter.html#isLegal(char)">UCharacter.isLegal()
	    /// </a></code> on the return value. If the char retrieved is part of a
	    /// surrogate pair, its supplementary character will be returned. If a
	    /// complete supplementary character is not found the incomplete character
	    /// will be returned
	    /// </summary>
	    ///
	    /// <param name="source">array of UTF-16 chars</param>
	    /// <param name="start">offset to substring in the source array for analyzing</param>
	    /// <param name="limit">offset to substring in the source array for analyzing</param>
	    /// <param name="offset16">UTF-16 offset relative to start</param>
	    /// <returns>UTF-32 value for the UTF-32 value that contains the char at
	    /// offset16. The boundaries of that codepoint are the same as in
	    /// <c>bounds32()</c>.</returns>
	    /// <exception cref="IndexOutOfBoundsException">thrown if offset16 is not within the range of start andlimit.</exception>
	    /// @stable ICU 2.1
	    public static int CharAt(char[] source, int start, int limit, int offset16) {
	        offset16 += start;
	        if (offset16 < start || offset16 >= limit) {
	            throw new IndexOutOfRangeException(offset16.ToString());
	        }
	
	        char single = source[offset16];
	        if (!IsSurrogate(single)) {
	            return single;
	        }
	
	        // Convert the UTF-16 surrogate pair if necessary.
	        // For simplicity in usage, and because the frequency of pairs is
	        // low, look both directions.
	        if (single <= LEAD_SURROGATE_MAX_VALUE) {
	            offset16++;
	            if (offset16 >= limit) {
	                return single;
	            }
	            char trail = source[offset16];
	            if (IsTrailSurrogate(trail)) {
	                return IBM.ICU.Impl.UCharacterProperty.GetRawSupplementary(single, trail);
	            }
	        } else { // isTrailSurrogate(single), so
	            if (offset16 == start) {
	                return single;
	            }
	            offset16--;
	            char lead = source[offset16];
	            if (IsLeadSurrogate(lead))
	                return IBM.ICU.Impl.UCharacterProperty.GetRawSupplementary(lead, single);
	        }
	        return single; // return unmatched surrogate
	    }
	
	    /// <summary>
	    /// Extract a single UTF-32 value from a string. Used when iterating forwards
	    /// or backwards (with <c>UTF16.getCharCount()</c>, as well as random
	    /// access. If a validity check is required, use
	    /// <code><a href="../lang/UCharacter.html#isLegal(char)">UCharacter.isLegal()
	    /// </a></code> on the return value. If the char retrieved is part of a
	    /// surrogate pair, its supplementary character will be returned. If a
	    /// complete supplementary character is not found the incomplete character
	    /// will be returned
	    /// </summary>
	    ///
	    /// <param name="source">UTF-16 chars string buffer</param>
	    /// <param name="offset16">UTF-16 offset to the start of the character.</param>
	    /// <returns>UTF-32 value for the UTF-32 value that contains the char at
	    /// offset16. The boundaries of that codepoint are the same as in
	    /// <c>bounds32()</c>.</returns>
	    /// <exception cref="IndexOutOfBoundsException">thrown if offset16 is out of bounds.</exception>
	    /// @stable ICU 2.1
	    public static int CharAt(Replaceable source, int offset16) {
	        if (offset16 < 0 || offset16 >= source.Length()) {
                throw new ArgumentOutOfRangeException(offset16.ToString());
	        }
	
	        char single = source.CharAt(offset16);
	        if (!IsSurrogate(single)) {
	            return single;
	        }
	
	        // Convert the UTF-16 surrogate pair if necessary.
	        // For simplicity in usage, and because the frequency of pairs is
	        // low, look both directions.
	
	        if (single <= LEAD_SURROGATE_MAX_VALUE) {
	            ++offset16;
	            if (source.Length() != offset16) {
	                char trail = source.CharAt(offset16);
	                if (IsTrailSurrogate(trail))
	                    return IBM.ICU.Impl.UCharacterProperty
	                            .GetRawSupplementary(single, trail);
	            }
	        } else {
	            --offset16;
	            if (offset16 >= 0) {
	                // single is a trail surrogate so
	                char lead = source.CharAt(offset16);
	                if (IsLeadSurrogate(lead)) {
	                    return IBM.ICU.Impl.UCharacterProperty.GetRawSupplementary(lead, single);
	                }
	            }
	        }
	        return single; // return unmatched surrogate
	    }
	
	    /// <summary>
	    /// Determines how many chars this char32 requires. If a validity check is
	    /// required, use <code>
	    /// <a href="../lang/UCharacter.html#isLegal(char)">isLegal()</a></code> on
	    /// char32 before calling.
	    /// </summary>
	    ///
	    /// <param name="char32">the input codepoint.</param>
	    /// <returns>2 if is in supplementary space, otherwise 1.</returns>
	    /// @stable ICU 2.1
	    public static int GetCharCount(int char32) {
	        if (char32 < SUPPLEMENTARY_MIN_VALUE) {
	            return 1;
	        }
	        return 2;
	    }
	
	    /// <summary>
	    /// Returns the type of the boundaries around the char at offset16. Used for
	    /// random access.
	    /// </summary>
	    ///
	    /// <param name="source">text to analyse</param>
	    /// <param name="offset16">UTF-16 offset</param>
	    /// <returns><ul>
	    /// <li>SINGLE_CHAR_BOUNDARY : a single char; the bounds are
	    /// [offset16, offset16+1]
	    /// <li>LEAD_SURROGATE_BOUNDARY : a surrogate pair starting at
	    /// offset16; the bounds are [offset16, offset16 + 2]
	    /// <li>TRAIL_SURROGATE_BOUNDARY : a surrogate pair starting at
	    /// offset16 - 1; the bounds are [offset16 - 1, offset16 + 1]
	    /// </ul>
	    /// For bit-twiddlers, the return values for these are chosen so that
	    /// the boundaries can be gotten by: [offset16 - (value >> 2),
	    /// offset16 + (value & 3)].</returns>
	    /// <exception cref="IndexOutOfBoundsException">if offset16 is out of bounds.</exception>
	    /// @stable ICU 2.1
	    public static int Bounds(String source, int offset16) {
	        char ch = source[offset16];
	        if (IsSurrogate(ch)) {
	            if (IsLeadSurrogate(ch)) {
	                if (++offset16 < source.Length
	                        && IsTrailSurrogate(source[offset16])) {
	                    return LEAD_SURROGATE_BOUNDARY;
	                }
	            } else {
	                // isTrailSurrogate(ch), so
	                --offset16;
	                if (offset16 >= 0 && IsLeadSurrogate(source[offset16])) {
	                    return TRAIL_SURROGATE_BOUNDARY;
	                }
	            }
	        }
	        return SINGLE_CHAR_BOUNDARY;
	    }
	
	    /// <summary>
	    /// Returns the type of the boundaries around the char at offset16. Used for
	    /// random access.
	    /// </summary>
	    ///
	    /// <param name="source">string buffer to analyse</param>
	    /// <param name="offset16">UTF16 offset</param>
	    /// <returns><ul>
	    /// <li>SINGLE_CHAR_BOUNDARY : a single char; the bounds are
	    /// [offset16, offset16 + 1]
	    /// <li>LEAD_SURROGATE_BOUNDARY : a surrogate pair starting at
	    /// offset16; the bounds are [offset16, offset16 + 2]
	    /// <li>TRAIL_SURROGATE_BOUNDARY : a surrogate pair starting at
	    /// offset16 - 1; the bounds are [offset16 - 1, offset16 + 1]
	    /// </ul>
	    /// For bit-twiddlers, the return values for these are chosen so that
	    /// the boundaries can be gotten by: [offset16 - (value >> 2),
	    /// offset16 + (value & 3)].</returns>
	    /// <exception cref="IndexOutOfBoundsException">if offset16 is out of bounds.</exception>
	    /// @stable ICU 2.1
	    public static int Bounds(StringBuilder source, int offset16) {
	        char ch = source[offset16];
	        if (IsSurrogate(ch)) {
	            if (IsLeadSurrogate(ch)) {
	                if (++offset16 < source.Length
	                        && IsTrailSurrogate(source[offset16])) {
	                    return LEAD_SURROGATE_BOUNDARY;
	                }
	            } else {
	                // isTrailSurrogate(ch), so
	                --offset16;
	                if (offset16 >= 0 && IsLeadSurrogate(source[offset16])) {
	                    return TRAIL_SURROGATE_BOUNDARY;
	                }
	            }
	        }
	        return SINGLE_CHAR_BOUNDARY;
	    }
	
	    /// <summary>
	    /// Returns the type of the boundaries around the char at offset16. Used for
	    /// random access. Note that the boundaries are determined with respect to
	    /// the subarray, hence the char array {0xD800, 0xDC00} has the result
	    /// SINGLE_CHAR_BOUNDARY for start = offset16 = 0 and limit = 1.
	    /// </summary>
	    ///
	    /// <param name="source">char array to analyse</param>
	    /// <param name="start">offset to substring in the source array for analyzing</param>
	    /// <param name="limit">offset to substring in the source array for analyzing</param>
	    /// <param name="offset16">UTF16 offset relative to start</param>
	    /// <returns><ul>
	    /// <li>SINGLE_CHAR_BOUNDARY : a single char; the bounds are
	    /// <li>LEAD_SURROGATE_BOUNDARY : a surrogate pair starting at
	    /// offset16; the bounds are [offset16, offset16 + 2]
	    /// <li>TRAIL_SURROGATE_BOUNDARY : a surrogate pair starting at
	    /// offset16 - 1; the bounds are [offset16 - 1, offset16 + 1]
	    /// </ul>
	    /// For bit-twiddlers, the boundary values for these are chosen so
	    /// that the boundaries can be gotten by: [offset16 - (boundvalue >>
	    /// 2), offset16 + (boundvalue & 3)].</returns>
	    /// <exception cref="IndexOutOfBoundsException">if offset16 is not within the range of start and limit.</exception>
	    /// @stable ICU 2.1
	    public static int Bounds(char[] source, int start, int limit, int offset16) {
	        offset16 += start;
	        if (offset16 < start || offset16 >= limit) {
	            throw new IndexOutOfRangeException(offset16.ToString());
	        }
	        char ch = source[offset16];
	        if (IsSurrogate(ch)) {
	            if (IsLeadSurrogate(ch)) {
	                ++offset16;
	                if (offset16 < limit && IsTrailSurrogate(source[offset16])) {
	                    return LEAD_SURROGATE_BOUNDARY;
	                }
	            } else { // isTrailSurrogate(ch), so
	                --offset16;
	                if (offset16 >= start && IsLeadSurrogate(source[offset16])) {
	                    return TRAIL_SURROGATE_BOUNDARY;
	                }
	            }
	        }
	        return SINGLE_CHAR_BOUNDARY;
	    }
	
	    /// <summary>
	    /// Determines whether the code value is a surrogate.
	    /// </summary>
	    ///
	    /// <param name="char16">the input character.</param>
	    /// <returns>true iff the input character is a surrogate.</returns>
	    /// @stable ICU 2.1
	    public static bool IsSurrogate(char char16) {
	        return (char16 & SURROGATE_BITMASK) == SURROGATE_BITS;
	    }
	
	    /// <summary>
	    /// Determines whether the character is a trail surrogate.
	    /// </summary>
	    ///
	    /// <param name="char16">the input character.</param>
	    /// <returns>true iff the input character is a trail surrogate.</returns>
	    /// @stable ICU 2.1
	    public static bool IsTrailSurrogate(char char16) {
	        return (char16 & TRAIL_SURROGATE_BITMASK) == TRAIL_SURROGATE_BITS;
	    }
	
	    /// <summary>
	    /// Determines whether the character is a lead surrogate.
	    /// </summary>
	    ///
	    /// <param name="char16">the input character.</param>
	    /// <returns>true iff the input character is a lead surrogate</returns>
	    /// @stable ICU 2.1
	    public static bool IsLeadSurrogate(char char16) {
	        return (char16 & LEAD_SURROGATE_BITMASK) == LEAD_SURROGATE_BITS;
	    }
	
	    /// <summary>
	    /// Returns the lead surrogate. If a validity check is required, use
	    /// <code><a href="../lang/UCharacter.html#isLegal(char)">isLegal()</a></code>
	    /// on char32 before calling.
	    /// </summary>
	    ///
	    /// <param name="char32">the input character.</param>
	    /// <returns>lead surrogate if the getCharCount(ch) is 2; <br>
	    /// and 0 otherwise (note: 0 is not a valid lead surrogate).</returns>
	    /// @stable ICU 2.1
	    public static char GetLeadSurrogate(int char32) {
	        if (char32 >= SUPPLEMENTARY_MIN_VALUE) {
	            return (char) (LEAD_SURROGATE_OFFSET_ + (char32 >> LEAD_SURROGATE_SHIFT_));
	        }
	        return (char) 0;
	    }
	
	    /// <summary>
	    /// Returns the trail surrogate. If a validity check is required, use
	    /// <code><a href="../lang/UCharacter.html#isLegal(char)">isLegal()</a></code>
	    /// on char32 before calling.
	    /// </summary>
	    ///
	    /// <param name="char32">the input character.</param>
	    /// <returns>the trail surrogate if the getCharCount(ch) is 2; <br>
	    /// otherwise the character itself</returns>
	    /// @stable ICU 2.1
	    public static char GetTrailSurrogate(int char32) {
	        if (char32 >= SUPPLEMENTARY_MIN_VALUE) {
	            return (char) (TRAIL_SURROGATE_MIN_VALUE + (char32 & TRAIL_SURROGATE_MASK_));
	        }
	        return (char) char32;
	    }
	
	    /// <summary>
	    /// Convenience method corresponding to String.valueOf(char). Returns a one
	    /// or two char string containing the UTF-32 value in UTF16 format. If a
	    /// validity check is required, use <a
	    /// href="../lang/UCharacter.html#isLegal(char)">isLegal()</a></code> on
	    /// char32 before calling.
	    /// </summary>
	    ///
	    /// <param name="char32">the input character.</param>
	    /// <returns>string value of char32 in UTF16 format</returns>
	    /// <exception cref="IllegalArgumentException">thrown if char32 is a invalid codepoint.</exception>
	    /// @stable ICU 2.1
	    public static String ValueOf(int char32) {
	        if (char32 < CODEPOINT_MIN_VALUE || char32 > CODEPOINT_MAX_VALUE) {
	            throw new ArgumentException("Illegal codepoint");
	        }
	        return ToString(char32);
	    }
	
	    /// <summary>
	    /// Convenience method corresponding to String.valueOf(codepoint at
	    /// offset16). Returns a one or two char string containing the UTF-32 value
	    /// in UTF16 format. If offset16 indexes a surrogate character, the whole
	    /// supplementary codepoint will be returned. If a validity check is
	    /// required, use <a
	    /// href="../lang/UCharacter.html#isLegal(char)">isLegal()</a></code> on the
	    /// codepoint at offset16 before calling. The result returned will be a newly
	    /// created String obtained by calling source.substring(..) with the
	    /// appropriate indexes.
	    /// </summary>
	    ///
	    /// <param name="source">the input string.</param>
	    /// <param name="offset16">the UTF16 index to the codepoint in source</param>
	    /// <returns>string value of char32 in UTF16 format</returns>
	    /// @stable ICU 2.1
	    public static String ValueOf(String source, int offset16) {
	        switch (Bounds(source, offset16)) {
	        case LEAD_SURROGATE_BOUNDARY:
	            return source.Substring(offset16,(offset16 + 2)-(offset16));
	        case TRAIL_SURROGATE_BOUNDARY:
	            return source.Substring(offset16 - 1,(offset16 + 1)-(offset16 - 1));
	        default:
	            return source.Substring(offset16,(offset16 + 1)-(offset16));
	        }
	    }
	
	    /// <summary>
	    /// Convenience method corresponding to StringBuffer.valueOf(codepoint at
	    /// offset16). Returns a one or two char string containing the UTF-32 value
	    /// in UTF16 format. If offset16 indexes a surrogate character, the whole
	    /// supplementary codepoint will be returned. If a validity check is
	    /// required, use <a
	    /// href="../lang/UCharacter.html#isLegal(char)">isLegal()</a></code> on the
	    /// codepoint at offset16 before calling. The result returned will be a newly
	    /// created String obtained by calling source.substring(..) with the
	    /// appropriate indexes.
	    /// </summary>
	    ///
	    /// <param name="source">the input string buffer.</param>
	    /// <param name="offset16">the UTF16 index to the codepoint in source</param>
	    /// <returns>string value of char32 in UTF16 format</returns>
	    /// @stable ICU 2.1
	    public static String ValueOf(StringBuilder source, int offset16) {
	        switch (Bounds(source, offset16)) {
	        case LEAD_SURROGATE_BOUNDARY:
	            return source.ToString(offset16,offset16 + 2-offset16);
	        case TRAIL_SURROGATE_BOUNDARY:
	            return source.ToString(offset16 - 1,offset16 + 1-offset16 - 1);
	        default:
	            return source.ToString(offset16,offset16 + 1-offset16);
	        }
	    }
	
	    /// <summary>
	    /// Convenience method. Returns a one or two char string containing the
	    /// UTF-32 value in UTF16 format. If offset16 indexes a surrogate character,
	    /// the whole supplementary codepoint will be returned, except when either
	    /// the leading or trailing surrogate character lies out of the specified
	    /// subarray. In the latter case, only the surrogate character within bounds
	    /// will be returned. If a validity check is required, use <a
	    /// href="../lang/UCharacter.html#isLegal(char)">isLegal()</a></code> on the
	    /// codepoint at offset16 before calling. The result returned will be a newly
	    /// created String containing the relevant characters.
	    /// </summary>
	    ///
	    /// <param name="source">the input char array.</param>
	    /// <param name="start">start index of the subarray</param>
	    /// <param name="limit">end index of the subarray</param>
	    /// <param name="offset16">the UTF16 index to the codepoint in source relative to start</param>
	    /// <returns>string value of char32 in UTF16 format</returns>
	    /// @stable ICU 2.1
	    public static String ValueOf(char[] source, int start, int limit,
	            int offset16) {
	        switch (Bounds(source, start, limit, offset16)) {
	        case LEAD_SURROGATE_BOUNDARY:
	            return new String(source, start + offset16, 2);
	        case TRAIL_SURROGATE_BOUNDARY:
	            return new String(source, start + offset16 - 1, 2);
	        }
	        return new String(source, start + offset16, 1);
	    }
	
	    /// <summary>
	    /// Returns the UTF-16 offset that corresponds to a UTF-32 offset. Used for
	    /// random access. See the <a name="_top_">class description</a> for notes on
	    /// roundtripping.
	    /// </summary>
	    ///
	    /// <param name="source">the UTF-16 string</param>
	    /// <param name="offset32">UTF-32 offset</param>
	    /// <returns>UTF-16 offset</returns>
	    /// <exception cref="IndexOutOfBoundsException">if offset32 is out of bounds.</exception>
	    /// @stable ICU 2.1
	    public static int FindOffsetFromCodePoint(String source, int offset32) {
	        char ch;
	        int size = source.Length, result = 0, count = offset32;
	        if (offset32 < 0 || offset32 > size) {
                throw new ArgumentOutOfRangeException(offset32.ToString());
	        }
	        while (result < size && count > 0) {
	            ch = source[result];
	            if (IsLeadSurrogate(ch) && ((result + 1) < size)
	                    && IsTrailSurrogate(source[result + 1])) {
	                result++;
	            }
	
	            count--;
	            result++;
	        }
	        if (count != 0) {
                throw new ArgumentOutOfRangeException(offset32.ToString());
	        }
	        return result;
	    }
	
	    /// <summary>
	    /// Returns the UTF-16 offset that corresponds to a UTF-32 offset. Used for
	    /// random access. See the <a name="_top_">class description</a> for notes on
	    /// roundtripping.
	    /// </summary>
	    ///
	    /// <param name="source">the UTF-16 string buffer</param>
	    /// <param name="offset32">UTF-32 offset</param>
	    /// <returns>UTF-16 offset</returns>
	    /// <exception cref="IndexOutOfBoundsException">if offset32 is out of bounds.</exception>
	    /// @stable ICU 2.1
	    public static int FindOffsetFromCodePoint(StringBuilder source, int offset32) {
	        char ch;
	        int size = source.Length, result = 0, count = offset32;
	        if (offset32 < 0 || offset32 > size) {
                throw new ArgumentOutOfRangeException(offset32.ToString());
	        }
	        while (result < size && count > 0) {
	            ch = source[result];
	            if (IsLeadSurrogate(ch) && ((result + 1) < size)
	                    && IsTrailSurrogate(source[result + 1])) {
	                result++;
	            }
	
	            count--;
	            result++;
	        }
	        if (count != 0) {
                throw new ArgumentOutOfRangeException(offset32.ToString());
	        }
	        return result;
	    }
	
	    /// <summary>
	    /// Returns the UTF-16 offset that corresponds to a UTF-32 offset. Used for
	    /// random access. See the <a name="_top_">class description</a> for notes on
	    /// roundtripping.
	    /// </summary>
	    ///
	    /// <param name="source">the UTF-16 char array whose substring is to be analysed</param>
	    /// <param name="start">offset of the substring to be analysed</param>
	    /// <param name="limit">offset of the substring to be analysed</param>
	    /// <param name="offset32">UTF-32 offset relative to start</param>
	    /// <returns>UTF-16 offset relative to start</returns>
	    /// <exception cref="IndexOutOfBoundsException">if offset32 is out of bounds.</exception>
	    /// @stable ICU 2.1
	    public static int FindOffsetFromCodePoint(char[] source, int start,
	            int limit, int offset32) {
	        char ch;
	        int result = start, count = offset32;
	        if (offset32 > limit - start) {
	            throw new IndexOutOfRangeException(offset32.ToString());
	        }
	        while (result < limit && count > 0) {
	            ch = source[result];
	            if (IsLeadSurrogate(ch) && ((result + 1) < limit)
	                    && IsTrailSurrogate(source[result + 1])) {
	                result++;
	            }
	
	            count--;
	            result++;
	        }
	        if (count != 0) {
	            throw new IndexOutOfRangeException(offset32.ToString());
	        }
	        return result - start;
	    }
	
	    /// <summary>
	    /// Returns the UTF-32 offset corresponding to the first UTF-32 boundary at
	    /// or after the given UTF-16 offset. Used for random access. See the <a
	    /// name="_top_">class description</a> for notes on roundtripping.<br>
	    /// <i>Note: If the UTF-16 offset is into the middle of a surrogate pair,
	    /// then the UTF-32 offset of the <strong>lead</strong> of the pair is
	    /// returned. </i>
	    /// <p>
	    /// To find the UTF-32 length of a string, use:
	    /// <pre>
	    /// len32 = countCodePoint(source, source.length());
	    /// </pre>
	    /// </p>
	    /// <p>
	    /// </summary>
	    ///
	    /// <param name="source">text to analyse</param>
	    /// <param name="offset16">UTF-16 offset < source text length.</param>
	    /// <returns>UTF-32 offset</returns>
	    /// <exception cref="IndexOutOfBoundsException">if offset16 is out of bounds.</exception>
	    /// @stable ICU 2.1
	    public static int FindCodePointOffset(String source, int offset16) {
	        if (offset16 < 0 || offset16 > source.Length) {
                throw new ArgumentOutOfRangeException(offset16.ToString());
	        }
	
	        int result = 0;
	        char ch;
	        bool hadLeadSurrogate = false;
	
	        for (int i = 0; i < offset16; ++i) {
	            ch = source[i];
	            if (hadLeadSurrogate && IsTrailSurrogate(ch)) {
	                hadLeadSurrogate = false; // count valid trail as zero
	            } else {
	                hadLeadSurrogate = IsLeadSurrogate(ch);
	                ++result; // count others as 1
	            }
	        }
	
	        if (offset16 == source.Length) {
	            return result;
	        }
	
	        // end of source being the less significant surrogate character
	        // shift result back to the start of the supplementary character
	        if (hadLeadSurrogate && (IsTrailSurrogate(source[offset16]))) {
	            result--;
	        }
	
	        return result;
	    }
	
	    /// <summary>
	    /// Returns the UTF-32 offset corresponding to the first UTF-32 boundary at
	    /// the given UTF-16 offset. Used for random access. See the <a
	    /// name="_top_">class description</a> for notes on roundtripping.<br>
	    /// <i>Note: If the UTF-16 offset is into the middle of a surrogate pair,
	    /// then the UTF-32 offset of the <strong>lead</strong> of the pair is
	    /// returned. </i>
	    /// <p>
	    /// To find the UTF-32 length of a string, use:
	    /// <pre>
	    /// len32 = countCodePoint(source);
	    /// </pre>
	    /// </p>
	    /// <p>
	    /// </summary>
	    ///
	    /// <param name="source">text to analyse</param>
	    /// <param name="offset16">UTF-16 offset < source text length.</param>
	    /// <returns>UTF-32 offset</returns>
	    /// <exception cref="IndexOutOfBoundsException">if offset16 is out of bounds.</exception>
	    /// @stable ICU 2.1
	    public static int FindCodePointOffset(StringBuilder source, int offset16) {
	        if (offset16 < 0 || offset16 > source.Length) {
                throw new ArgumentOutOfRangeException(offset16.ToString());
	        }
	
	        int result = 0;
	        char ch;
	        bool hadLeadSurrogate = false;
	
	        for (int i = 0; i < offset16; ++i) {
	            ch = source[i];
	            if (hadLeadSurrogate && IsTrailSurrogate(ch)) {
	                hadLeadSurrogate = false; // count valid trail as zero
	            } else {
	                hadLeadSurrogate = IsLeadSurrogate(ch);
	                ++result; // count others as 1
	            }
	        }
	
	        if (offset16 == source.Length) {
	            return result;
	        }
	
	        // end of source being the less significant surrogate character
	        // shift result back to the start of the supplementary character
	        if (hadLeadSurrogate && (IsTrailSurrogate(source[offset16]))) {
	            result--;
	        }
	
	        return result;
	    }
	
	    /// <summary>
	    /// Returns the UTF-32 offset corresponding to the first UTF-32 boundary at
	    /// the given UTF-16 offset. Used for random access. See the <a
	    /// name="_top_">class description</a> for notes on roundtripping.<br>
	    /// <i>Note: If the UTF-16 offset is into the middle of a surrogate pair,
	    /// then the UTF-32 offset of the <strong>lead</strong> of the pair is
	    /// returned. </i>
	    /// <p>
	    /// To find the UTF-32 length of a substring, use:
	    /// <pre>
	    /// len32 = countCodePoint(source, start, limit);
	    /// </pre>
	    /// </p>
	    /// <p>
	    /// </summary>
	    ///
	    /// <param name="source">text to analyse</param>
	    /// <param name="start">offset of the substring</param>
	    /// <param name="limit">offset of the substring</param>
	    /// <param name="offset16">UTF-16 relative to start</param>
	    /// <returns>UTF-32 offset relative to start</returns>
	    /// <exception cref="IndexOutOfBoundsException">if offset16 is not within the range of start and limit.</exception>
	    /// @stable ICU 2.1
	    public static int FindCodePointOffset(char[] source, int start, int limit,
	            int offset16) {
	        offset16 += start;
	        if (offset16 > limit) {
                throw new ArgumentOutOfRangeException(offset16.ToString());
	        }
	
	        int result = 0;
	        char ch;
	        bool hadLeadSurrogate = false;
	
	        for (int i = start; i < offset16; ++i) {
	            ch = source[i];
	            if (hadLeadSurrogate && IsTrailSurrogate(ch)) {
	                hadLeadSurrogate = false; // count valid trail as zero
	            } else {
	                hadLeadSurrogate = IsLeadSurrogate(ch);
	                ++result; // count others as 1
	            }
	        }
	
	        if (offset16 == limit) {
	            return result;
	        }
	
	        // end of source being the less significant surrogate character
	        // shift result back to the start of the supplementary character
	        if (hadLeadSurrogate && (IsTrailSurrogate(source[offset16]))) {
	            result--;
	        }
	
	        return result;
	    }
	
	    /// <summary>
	    /// Append a single UTF-32 value to the end of a StringBuffer. If a validity
	    /// check is required, use <a
	    /// href="../lang/UCharacter.html#isLegal(char)">isLegal()</a></code> on
	    /// char32 before calling.
	    /// </summary>
	    ///
	    /// <param name="target">the buffer to append to</param>
	    /// <param name="char32">value to append.</param>
	    /// <returns>the updated StringBuffer</returns>
	    /// <exception cref="IllegalArgumentException">thrown when char32 does not lie within the range of theUnicode codepoints</exception>
	    /// @stable ICU 2.1
	    public static StringBuilder Append(StringBuilder target, int char32) {
	        // Check for irregular values
	        if (char32 < CODEPOINT_MIN_VALUE || char32 > CODEPOINT_MAX_VALUE) {
	            throw new ArgumentException("Illegal codepoint: "
	                    + ILOG.J2CsMapping.Util.IlNumber.ToString(char32,16));
	        }
	
	        // Write the UTF-16 values
	        if (char32 >= SUPPLEMENTARY_MIN_VALUE) {
	            target.Append(GetLeadSurrogate(char32));
	            target.Append(GetTrailSurrogate(char32));
	        } else {
	            target.Append((char) char32);
	        }
	        return target;
	    }
	
	    /// <summary>
	    /// Cover JDK 1.5 APIs. Append the code point to the buffer and return the
	    /// buffer as a convenience.
	    /// </summary>
	    ///
	    /// <param name="target">the buffer to append to</param>
	    /// <param name="cp">the code point to append</param>
	    /// <returns>the updated StringBuffer</returns>
	    /// <exception cref="IllegalArgumentException">if cp is not a valid code point</exception>
	    /// @stable ICU 3.0
	    public static StringBuilder AppendCodePoint(StringBuilder target, int cp) {
	        return Append(target, cp);
	    }
	
	    /// <summary>
	    /// Adds a codepoint to offset16 position of the argument char array.
	    /// </summary>
	    ///
	    /// <param name="target">char array to be append with the new code point</param>
	    /// <param name="limit">UTF16 offset which the codepoint will be appended.</param>
	    /// <param name="char32">code point to be appended</param>
	    /// <returns>offset after char32 in the array.</returns>
	    /// <exception cref="IllegalArgumentException">thrown if there is not enough space for the append, orwhen char32 does not lie within the range of the Unicodecodepoints.</exception>
	    /// @stable ICU 2.1
	    public static int Append(char[] target, int limit, int char32) {
	        // Check for irregular values
	        if (char32 < CODEPOINT_MIN_VALUE || char32 > CODEPOINT_MAX_VALUE) {
	            throw new ArgumentException("Illegal codepoint");
	        }
	        // Write the UTF-16 values
	        if (char32 >= SUPPLEMENTARY_MIN_VALUE) {
	            target[limit++] = GetLeadSurrogate(char32);
	            target[limit++] = GetTrailSurrogate(char32);
	        } else {
	            target[limit++] = (char) char32;
	        }
	        return limit;
	    }
	
	    /// <summary>
	    /// Number of codepoints in a UTF16 String
	    /// </summary>
	    ///
	    /// <param name="source">UTF16 string</param>
	    /// <returns>number of codepoint in string</returns>
	    /// @stable ICU 2.1
	    public static int CountCodePoint(String source) {
	        if (source == null || source.Length == 0) {
	            return 0;
	        }
	        return FindCodePointOffset(source, source.Length);
	    }
	
	    /// <summary>
	    /// Number of codepoints in a UTF16 String buffer
	    /// </summary>
	    ///
	    /// <param name="source">UTF16 string buffer</param>
	    /// <returns>number of codepoint in string</returns>
	    /// @stable ICU 2.1
	    public static int CountCodePoint(StringBuilder source) {
	        if (source == null || source.Length == 0) {
	            return 0;
	        }
	        return FindCodePointOffset(source, source.Length);
	    }
	
	    /// <summary>
	    /// Number of codepoints in a UTF16 char array substring
	    /// </summary>
	    ///
	    /// <param name="source">UTF16 char array</param>
	    /// <param name="start">offset of the substring</param>
	    /// <param name="limit">offset of the substring</param>
	    /// <returns>number of codepoint in the substring</returns>
	    /// <exception cref="IndexOutOfBoundsException">if start and limit are not valid.</exception>
	    /// @stable ICU 2.1
	    public static int CountCodePoint(char[] source, int start, int limit) {
	        if (source == null || source.Length == 0) {
	            return 0;
	        }
	        return FindCodePointOffset(source, start, limit, limit - start);
	    }
	
	    /// <summary>
	    /// Set a code point into a UTF16 position. Adjusts target according if we
	    /// are replacing a non-supplementary codepoint with a supplementary and vice
	    /// versa.
	    /// </summary>
	    ///
	    /// <param name="target">stringbuffer</param>
	    /// <param name="offset16">UTF16 position to insert into</param>
	    /// <param name="char32">code point</param>
	    /// @stable ICU 2.1
	    public static void SetCharAt(StringBuilder target, int offset16, int char32) {
	        int count = 1;
	        char single = target[offset16];
	
	        if (IsSurrogate(single)) {
	            // pairs of the surrogate with offset16 at the lead char found
	            if (IsLeadSurrogate(single) && (target.Length > offset16 + 1)
	                    && IsTrailSurrogate(target[offset16 + 1])) {
	                count++;
	            } else {
	                // pairs of the surrogate with offset16 at the trail char
	                // found
	                if (IsTrailSurrogate(single) && (offset16 > 0)
	                        && IsLeadSurrogate(target[offset16 - 1])) {
	                    offset16--;
	                    count++;
	                }
	            }
	        }
	        target.Insert(offset16, ValueOf(char32), count);
	    }
	
	    /// <summary>
	    /// Set a code point into a UTF16 position in a char array. Adjusts target
	    /// according if we are replacing a non-supplementary codepoint with a
	    /// supplementary and vice versa.
	    /// </summary>
	    ///
	    /// <param name="target">char array</param>
	    /// <param name="limit">numbers of valid chars in target, different fromtarget.length. limit counts the number of chars in target thatrepresents a string, not the size of array target.</param>
	    /// <param name="offset16">UTF16 position to insert into</param>
	    /// <param name="char32">code point</param>
	    /// <returns>new number of chars in target that represents a string</returns>
	    /// <exception cref="IndexOutOfBoundsException">if offset16 is out of range</exception>
	    /// @stable ICU 2.1
	    public static int SetCharAt(char[] target, int limit, int offset16,
	            int char32) {
	        if (offset16 >= limit) {
	            throw new IndexOutOfRangeException(offset16.ToString());
	        }
	        int count = 1;
	        char single = target[offset16];
	
	        if (IsSurrogate(single)) {
	            // pairs of the surrogate with offset16 at the lead char found
	            if (IsLeadSurrogate(single) && (target.Length > offset16 + 1)
	                    && IsTrailSurrogate(target[offset16 + 1])) {
	                count++;
	            } else {
	                // pairs of the surrogate with offset16 at the trail char
	                // found
	                if (IsTrailSurrogate(single) && (offset16 > 0)
	                        && IsLeadSurrogate(target[offset16 - 1])) {
	                    offset16--;
	                    count++;
	                }
	            }
	        }
	
	        String str = ValueOf(char32);
	        int result = limit;
	        int strlength = str.Length;
	        target[offset16] = str[0];
	        if (count == strlength) {
	            if (count == 2) {
	                target[offset16 + 1] = str[1];
	            }
	        } else {
	            // this is not exact match in space, we'll have to do some
	            // shifting
	            System.Array.Copy((Array)(target),offset16 + count,(Array)(target),offset16
	                                + strlength,limit - (offset16 + count));
	            if (count < strlength) {
	                // char32 is a supplementary character trying to squeeze into
	                // a non-supplementary space
	                target[offset16 + 1] = str[1];
	                result++;
	                if (result < target.Length) {
	                    target[result] = ((Char)0);
	                }
	            } else {
	                // char32 is a non-supplementary character trying to fill
	                // into a supplementary space
	                result--;
	                target[result] = ((Char)0);
	            }
	        }
	        return result;
	    }
	
	    /// <summary>
	    /// Shifts offset16 by the argument number of codepoints
	    /// </summary>
	    ///
	    /// <param name="source">string</param>
	    /// <param name="offset16">UTF16 position to shift</param>
	    /// <param name="shift32">number of codepoints to shift</param>
	    /// <returns>new shifted offset16</returns>
	    /// <exception cref="IndexOutOfBoundsException">if the new offset16 is out of bounds.</exception>
	    /// @stable ICU 2.1
	    public static int MoveCodePointOffset(String source, int offset16,
	            int shift32) {
	        int result = offset16;
	        int size = source.Length;
	        int count;
	        char ch;
	        if (offset16 < 0 || offset16 > size) {
                throw new ArgumentOutOfRangeException(offset16.ToString());
	        }
	        if (shift32 > 0) {
	            if (shift32 + offset16 > size) {
                    throw new ArgumentOutOfRangeException(offset16.ToString());
	            }
	            count = shift32;
	            while (result < size && count > 0) {
	                ch = source[result];
	                if (IsLeadSurrogate(ch) && ((result + 1) < size)
	                        && IsTrailSurrogate(source[result + 1])) {
	                    result++;
	                }
	                count--;
	                result++;
	            }
	        } else {
	            if (offset16 + shift32 < 0) {
                    throw new ArgumentOutOfRangeException(offset16.ToString());
	            }
	            for (count = -shift32; count > 0; count--) {
	                result--;
	                if (result < 0) {
	                    break;
	                }
	                ch = source[result];
	                if (IsTrailSurrogate(ch) && result > 0
	                        && IsLeadSurrogate(source[result - 1])) {
	                    result--;
	                }
	            }
	        }
	        if (count != 0) {
                throw new ArgumentOutOfRangeException(shift32.ToString());
	        }
	        return result;
	    }
	
	    /// <summary>
	    /// Shifts offset16 by the argument number of codepoints
	    /// </summary>
	    ///
	    /// <param name="source">string buffer</param>
	    /// <param name="offset16">UTF16 position to shift</param>
	    /// <param name="shift32">number of codepoints to shift</param>
	    /// <returns>new shifted offset16</returns>
	    /// <exception cref="IndexOutOfBoundsException">if the new offset16 is out of bounds.</exception>
	    /// @stable ICU 2.1
	    public static int MoveCodePointOffset(StringBuilder source, int offset16,
	            int shift32) {
	        int result = offset16;
	        int size = source.Length;
	        int count;
	        char ch;
	        if (offset16 < 0 || offset16 > size) {
                throw new ArgumentOutOfRangeException(offset16.ToString());
	        }
	        if (shift32 > 0) {
	            if (shift32 + offset16 > size) {
                    throw new ArgumentOutOfRangeException(offset16.ToString());
	            }
	            count = shift32;
	            while (result < size && count > 0) {
	                ch = source[result];
	                if (IsLeadSurrogate(ch) && ((result + 1) < size)
	                        && IsTrailSurrogate(source[result + 1])) {
	                    result++;
	                }
	                count--;
	                result++;
	            }
	        } else {
	            if (offset16 + shift32 < 0) {
                    throw new ArgumentOutOfRangeException(offset16.ToString());
	            }
	            for (count = -shift32; count > 0; count--) {
	                result--;
	                if (result < 0) {
	                    break;
	                }
	                ch = source[result];
	                if (IsTrailSurrogate(ch) && result > 0
	                        && IsLeadSurrogate(source[result - 1])) {
	                    result--;
	                }
	            }
	        }
	        if (count != 0) {
                throw new ArgumentOutOfRangeException(shift32.ToString());
	        }
	        return result;
	    }
	
	    /// <summary>
	    /// Shifts offset16 by the argument number of codepoints within a subarray.
	    /// </summary>
	    ///
	    /// <param name="source">char array</param>
	    /// <param name="start">position of the subarray to be performed on</param>
	    /// <param name="limit">position of the subarray to be performed on</param>
	    /// <param name="offset16">UTF16 position to shift relative to start</param>
	    /// <param name="shift32">number of codepoints to shift</param>
	    /// <returns>new shifted offset16 relative to start</returns>
	    /// <exception cref="IndexOutOfBoundsException">if the new offset16 is out of bounds with respect to thesubarray or the subarray bounds are out of range.</exception>
	    /// @stable ICU 2.1
	    public static int MoveCodePointOffset(char[] source, int start, int limit,
	            int offset16, int shift32) {
	        int size = source.Length;
	        int count;
	        char ch;
	        int result = offset16 + start;
	        if (start < 0 || limit < start) {
	            throw new ArgumentOutOfRangeException(start.ToString());
	        }
	        if (limit > size) {
                throw new ArgumentOutOfRangeException(limit.ToString());
	        }
	        if (offset16 < 0 || result > limit) {
                throw new ArgumentOutOfRangeException(offset16.ToString());
	        }
	        if (shift32 > 0) {
	            if (shift32 + result > size) {
                    throw new ArgumentOutOfRangeException(result.ToString());
	            }
	            count = shift32;
	            while (result < limit && count > 0) {
	                ch = source[result];
	                if (IsLeadSurrogate(ch) && (result + 1 < limit)
	                        && IsTrailSurrogate(source[result + 1])) {
	                    result++;
	                }
	                count--;
	                result++;
	            }
	        } else {
	            if (result + shift32 < start) {
                    throw new ArgumentOutOfRangeException(result.ToString());
	            }
	            for (count = -shift32; count > 0; count--) {
	                result--;
	                if (result < start) {
	                    break;
	                }
	                ch = source[result];
	                if (IsTrailSurrogate(ch) && result > start
	                        && IsLeadSurrogate(source[result - 1])) {
	                    result--;
	                }
	            }
	        }
	        if (count != 0) {
                throw new ArgumentOutOfRangeException(shift32.ToString());
	        }
	        result -= start;
	        return result;
	    }
	
	    /// <summary>
	    /// Inserts char32 codepoint into target at the argument offset16. If the
	    /// offset16 is in the middle of a supplementary codepoint, char32 will be
	    /// inserted after the supplementary codepoint. The length of target
	    /// increases by one if codepoint is non-supplementary, 2 otherwise.
	    /// <p>
	    /// The overall effect is exactly as if the argument were converted to a
	    /// string by the method valueOf(char) and the characters in that string were
	    /// then inserted into target at the position indicated by offset16.
	    /// </p>
	    /// <p>
	    /// The offset argument must be greater than or equal to 0, and less than or
	    /// equal to the length of source.
	    /// </summary>
	    ///
	    /// <param name="target">string buffer to insert to</param>
	    /// <param name="offset16">offset which char32 will be inserted in</param>
	    /// <param name="char32">codepoint to be inserted</param>
	    /// <returns>a reference to target</returns>
	    /// <exception cref="IndexOutOfBoundsException">thrown if offset16 is invalid.</exception>
	    /// @stable ICU 2.1
	    public static StringBuilder Insert(StringBuilder target, int offset16,
	            int char32) {
	        String str = ValueOf(char32);
	        if (offset16 != target.Length
	                && Bounds(target, offset16) == TRAIL_SURROGATE_BOUNDARY) {
	            offset16++;
	        }
	        target.Insert(offset16, str);
	        return target;
	    }
	
	    /// <summary>
	    /// Inserts char32 codepoint into target at the argument offset16. If the
	    /// offset16 is in the middle of a supplementary codepoint, char32 will be
	    /// inserted after the supplementary codepoint. Limit increases by one if
	    /// codepoint is non-supplementary, 2 otherwise.
	    /// <p>
	    /// The overall effect is exactly as if the argument were converted to a
	    /// string by the method valueOf(char) and the characters in that string were
	    /// then inserted into target at the position indicated by offset16.
	    /// </p>
	    /// <p>
	    /// The offset argument must be greater than or equal to 0, and less than or
	    /// equal to the limit.
	    /// </summary>
	    ///
	    /// <param name="target">char array to insert to</param>
	    /// <param name="limit">end index of the char array, limit <= target.length</param>
	    /// <param name="offset16">offset which char32 will be inserted in</param>
	    /// <param name="char32">codepoint to be inserted</param>
	    /// <returns>new limit size</returns>
	    /// <exception cref="IndexOutOfBoundsException">thrown if offset16 is invalid.</exception>
	    /// @stable ICU 2.1
	    public static int Insert(char[] target, int limit, int offset16, int char32) {
	        String str = ValueOf(char32);
	        if (offset16 != limit
	                && Bounds(target, 0, limit, offset16) == TRAIL_SURROGATE_BOUNDARY) {
	            offset16++;
	        }
	        int size = str.Length;
	        if (limit + size > target.Length) {
	            throw new IndexOutOfRangeException(offset16 + size.ToString());
	        }
	        System.Array.Copy((Array)(target),offset16,(Array)(target),offset16 + size,limit
	                        - offset16);
	        target[offset16] = str[0];
	        if (size == 2) {
	            target[offset16 + 1] = str[1];
	        }
	        return limit + size;
	    }
	
	    /// <summary>
	    /// Removes the codepoint at the specified position in this target
	    /// (shortening target by 1 character if the codepoint is a
	    /// non-supplementary, 2 otherwise).
	    /// </summary>
	    ///
	    /// <param name="target">string buffer to remove codepoint from</param>
	    /// <param name="offset16">offset which the codepoint will be removed</param>
	    /// <returns>a reference to target</returns>
	    /// <exception cref="IndexOutOfBoundsException">thrown if offset16 is invalid.</exception>
	    /// @stable ICU 2.1
	    public static StringBuilder Delete(StringBuilder target, int offset16) {
	        int count = 1;
	        switch (Bounds(target, offset16)) {
	        case LEAD_SURROGATE_BOUNDARY:
	            count++;
	            break;
	        case TRAIL_SURROGATE_BOUNDARY:
	            count++;
	            offset16--;
	            break;
	        }
	        target.Remove(offset16,offset16 + count-(offset16));
	        return target;
	    }
	
	    /// <summary>
	    /// Removes the codepoint at the specified position in this target
	    /// (shortening target by 1 character if the codepoint is a
	    /// non-supplementary, 2 otherwise).
	    /// </summary>
	    ///
	    /// <param name="target">string buffer to remove codepoint from</param>
	    /// <param name="limit">end index of the char array, limit <= target.length</param>
	    /// <param name="offset16">offset which the codepoint will be removed</param>
	    /// <returns>a new limit size</returns>
	    /// <exception cref="IndexOutOfBoundsException">thrown if offset16 is invalid.</exception>
	    /// @stable ICU 2.1
	    public static int Delete(char[] target, int limit, int offset16) {
	        int count = 1;
	        switch (Bounds(target, 0, limit, offset16)) {
	        case LEAD_SURROGATE_BOUNDARY:
	            count++;
	            break;
	        case TRAIL_SURROGATE_BOUNDARY:
	            count++;
	            offset16--;
	            break;
	        }
	        System.Array.Copy((Array)(target),offset16 + count,(Array)(target),offset16,limit
	                        - (offset16 + count));
	        target[limit - count] = ((Char)0);
	        return limit - count;
	    }
	
	    /// <summary>
	    /// Returns the index within the argument UTF16 format Unicode string of the
	    /// first occurrence of the argument codepoint. I.e., the smallest index
	    /// <c>i</c> such that <code>UTF16.charAt(source, i) ==
	    /// char32</code> is true.
	    /// <p>
	    /// If no such character occurs in this string, then -1 is returned.
	    /// </p>
	    /// <p>
	    /// Examples:<br>
	    /// UTF16.indexOf("abc", 'a') returns 0<br>
	    /// UTF16.indexOf("abc\ud800\udc00", 0x10000) returns 3<br>
	    /// UTF16.indexOf("abc\ud800\udc00", 0xd800) returns -1<br>
	    /// </p>
	    /// Note this method is provided as support to jdk 1.3, which does not
	    /// support supplementary characters to its fullest.
	    /// </summary>
	    ///
	    /// <param name="source">UTF16 format Unicode string that will be searched</param>
	    /// <param name="char32">codepoint to search for</param>
	    /// <returns>the index of the first occurrence of the codepoint in the
	    /// argument Unicode string, or -1 if the codepoint does not occur.</returns>
	    /// @stable ICU 2.6
	    public static int IndexOf(String source, int char32) {
	        if (char32 < CODEPOINT_MIN_VALUE || char32 > CODEPOINT_MAX_VALUE) {
	            throw new ArgumentException(
	                    "Argument char32 is not a valid codepoint");
	        }
	        // non-surrogate bmp
	        if (char32 < LEAD_SURROGATE_MIN_VALUE
	                || (char32 > TRAIL_SURROGATE_MAX_VALUE && char32 < SUPPLEMENTARY_MIN_VALUE)) {
	            return source.IndexOf((char) char32);
	        }
	        // surrogate
	        if (char32 < SUPPLEMENTARY_MIN_VALUE) {
	            int result = source.IndexOf((char) char32);
	            if (result >= 0) {
	                if (IsLeadSurrogate((char) char32)
	                        && (result < source.Length - 1)
	                        && IsTrailSurrogate(source[result + 1])) {
	                    return IndexOf(source, char32, result + 1);
	                }
	                // trail surrogate
	                if (result > 0 && IsLeadSurrogate(source[result - 1])) {
	                    return IndexOf(source, char32, result + 1);
	                }
	            }
	            return result;
	        }
	        // supplementary
	        String char32str = ToString(char32);
	        return source.IndexOf(char32str);
	    }
	
	    /// <summary>
	    /// Returns the index within the argument UTF16 format Unicode string of the
	    /// first occurrence of the argument string str. This method is implemented
	    /// based on codepoints, hence a "lead surrogate character + trail surrogate
	    /// character" is treated as one entity.e Hence if the str starts with trail
	    /// surrogate character at index 0, a source with a leading a surrogate
	    /// character before str found at in source will not have a valid match. Vice
	    /// versa for lead surrogates that ends str. See example below.
	    /// <p>
	    /// If no such string str occurs in this source, then -1 is returned.
	    /// </p>
	    /// <p>
	    /// Examples:<br>
	    /// UTF16.indexOf("abc", "ab") returns 0<br>
	    /// UTF16.indexOf("abc\ud800\udc00", "\ud800\udc00") returns 3<br>
	    /// UTF16.indexOf("abc\ud800\udc00", "\ud800") returns -1<br>
	    /// </p>
	    /// Note this method is provided as support to jdk 1.3, which does not
	    /// support supplementary characters to its fullest.
	    /// </summary>
	    ///
	    /// <param name="source">UTF16 format Unicode string that will be searched</param>
	    /// <param name="str">UTF16 format Unicode string to search for</param>
	    /// <returns>the index of the first occurrence of the codepoint in the
	    /// argument Unicode string, or -1 if the codepoint does not occur.</returns>
	    /// @stable ICU 2.6
	    public static int IndexOf(String source, String str) {
	        int strLength = str.Length;
	        // non-surrogate ends
	        if (!IsTrailSurrogate(str[0])
	                && !IsLeadSurrogate(str[strLength - 1])) {
	            return source.IndexOf(str);
	        }
	
	        int result = source.IndexOf(str);
	        int resultEnd = result + strLength;
	        if (result >= 0) {
	            // check last character
	            if (IsLeadSurrogate(str[strLength - 1])
	                    && (result < source.Length - 1)
	                    && IsTrailSurrogate(source[resultEnd + 1])) {
	                return IndexOf(source, str, resultEnd + 1);
	            }
	            // check first character which is a trail surrogate
	            if (IsTrailSurrogate(str[0]) && result > 0
	                    && IsLeadSurrogate(source[result - 1])) {
	                return IndexOf(source, str, resultEnd + 1);
	            }
	        }
	        return result;
	    }
	
	    /// <summary>
	    /// Returns the index within the argument UTF16 format Unicode string of the
	    /// first occurrence of the argument codepoint. I.e., the smallest index i
	    /// such that: <br>
	    /// (UTF16.charAt(source, i) == char32 && i >= fromIndex) is true.
	    /// <p>
	    /// If no such character occurs in this string, then -1 is returned.
	    /// </p>
	    /// <p>
	    /// Examples:<br>
	    /// UTF16.indexOf("abc", 'a', 1) returns -1<br>
	    /// UTF16.indexOf("abc\ud800\udc00", 0x10000, 1) returns 3<br>
	    /// UTF16.indexOf("abc\ud800\udc00", 0xd800, 1) returns -1<br>
	    /// </p>
	    /// Note this method is provided as support to jdk 1.3, which does not
	    /// support supplementary characters to its fullest.
	    /// </summary>
	    ///
	    /// <param name="source">UTF16 format Unicode string that will be searched</param>
	    /// <param name="char32">codepoint to search for</param>
	    /// <param name="fromIndex">the index to start the search from.</param>
	    /// <returns>the index of the first occurrence of the codepoint in the
	    /// argument Unicode string at or after fromIndex, or -1 if the
	    /// codepoint does not occur.</returns>
	    /// @stable ICU 2.6
	    public static int IndexOf(String source, int char32, int fromIndex) {
	        if (char32 < CODEPOINT_MIN_VALUE || char32 > CODEPOINT_MAX_VALUE) {
	            throw new ArgumentException(
	                    "Argument char32 is not a valid codepoint");
	        }
	        // non-surrogate bmp
	        if (char32 < LEAD_SURROGATE_MIN_VALUE
	                || (char32 > TRAIL_SURROGATE_MAX_VALUE && char32 < SUPPLEMENTARY_MIN_VALUE)) {
	            return source.IndexOf((char) char32, fromIndex);
	        }
	        // surrogate
	        if (char32 < SUPPLEMENTARY_MIN_VALUE) {
	            int result = source.IndexOf((char) char32, fromIndex);
	            if (result >= 0) {
	                if (IsLeadSurrogate((char) char32)
	                        && (result < source.Length - 1)
	                        && IsTrailSurrogate(source[result + 1])) {
	                    return IndexOf(source, char32, result + 1);
	                }
	                // trail surrogate
	                if (result > 0 && IsLeadSurrogate(source[result - 1])) {
	                    return IndexOf(source, char32, result + 1);
	                }
	            }
	            return result;
	        }
	        // supplementary
	        String char32str = ToString(char32);
	        return ILOG.J2CsMapping.Util.StringUtil.IndexOf(source,char32str,fromIndex);
	    }
	
	    /// <summary>
	    /// Returns the index within the argument UTF16 format Unicode string of the
	    /// first occurrence of the argument string str. This method is implemented
	    /// based on codepoints, hence a "lead surrogate character + trail surrogate
	    /// character" is treated as one entity.e Hence if the str starts with trail
	    /// surrogate character at index 0, a source with a leading a surrogate
	    /// character before str found at in source will not have a valid match. Vice
	    /// versa for lead surrogates that ends str. See example below.
	    /// <p>
	    /// If no such string str occurs in this source, then -1 is returned.
	    /// </p>
	    /// <p>
	    /// Examples:<br>
	    /// UTF16.indexOf("abc", "ab", 0) returns 0<br>
	    /// UTF16.indexOf("abc\ud800\udc00", "\ud800\udc00", 0) returns 3<br>
	    /// UTF16.indexOf("abc\ud800\udc00", "\ud800\udc00", 2) returns 3<br>
	    /// UTF16.indexOf("abc\ud800\udc00", "\ud800", 0) returns -1<br>
	    /// </p>
	    /// Note this method is provided as support to jdk 1.3, which does not
	    /// support supplementary characters to its fullest.
	    /// </summary>
	    ///
	    /// <param name="source">UTF16 format Unicode string that will be searched</param>
	    /// <param name="str">UTF16 format Unicode string to search for</param>
	    /// <param name="fromIndex">the index to start the search from.</param>
	    /// <returns>the index of the first occurrence of the codepoint in the
	    /// argument Unicode string, or -1 if the codepoint does not occur.</returns>
	    /// @stable ICU 2.6
	    public static int IndexOf(String source, String str, int fromIndex) {
	        int strLength = str.Length;
	        // non-surrogate ends
	        if (!IsTrailSurrogate(str[0])
	                && !IsLeadSurrogate(str[strLength - 1])) {
	            return ILOG.J2CsMapping.Util.StringUtil.IndexOf(source,str,fromIndex);
	        }
	
	        int result = ILOG.J2CsMapping.Util.StringUtil.IndexOf(source,str,fromIndex);
	        int resultEnd = result + strLength;
	        if (result >= 0) {
	            // check last character
	            if (IsLeadSurrogate(str[strLength - 1])
	                    && (result < source.Length - 1)
	                    && IsTrailSurrogate(source[resultEnd])) {
	                return IndexOf(source, str, resultEnd + 1);
	            }
	            // check first character which is a trail surrogate
	            if (IsTrailSurrogate(str[0]) && result > 0
	                    && IsLeadSurrogate(source[result - 1])) {
	                return IndexOf(source, str, resultEnd + 1);
	            }
	        }
	        return result;
	    }
	
	    /// <summary>
	    /// Returns the index within the argument UTF16 format Unicode string of the
	    /// last occurrence of the argument codepoint. I.e., the index returned is
	    /// the largest value i such that: UTF16.charAt(source, i) == char32 is true.
	    /// <p>
	    /// Examples:<br>
	    /// UTF16.lastIndexOf("abc", 'a') returns 0<br>
	    /// UTF16.lastIndexOf("abc\ud800\udc00", 0x10000) returns 3<br>
	    /// UTF16.lastIndexOf("abc\ud800\udc00", 0xd800) returns -1<br>
	    /// </p>
	    /// <p>
	    /// source is searched backwards starting at the last character.
	    /// </p>
	    /// Note this method is provided as support to jdk 1.3, which does not
	    /// support supplementary characters to its fullest.
	    /// </summary>
	    ///
	    /// <param name="source">UTF16 format Unicode string that will be searched</param>
	    /// <param name="char32">codepoint to search for</param>
	    /// <returns>the index of the last occurrence of the codepoint in source, or
	    /// -1 if the codepoint does not occur.</returns>
	    /// @stable ICU 2.6
	    public static int LastIndexOf(String source, int char32) {
	        if (char32 < CODEPOINT_MIN_VALUE || char32 > CODEPOINT_MAX_VALUE) {
	            throw new ArgumentException(
	                    "Argument char32 is not a valid codepoint");
	        }
	        // non-surrogate bmp
	        if (char32 < LEAD_SURROGATE_MIN_VALUE
	                || (char32 > TRAIL_SURROGATE_MAX_VALUE && char32 < SUPPLEMENTARY_MIN_VALUE)) {
	            return source.LastIndexOf((char) char32);
	        }
	        // surrogate
	        if (char32 < SUPPLEMENTARY_MIN_VALUE) {
	            int result = source.LastIndexOf((char) char32);
	            if (result >= 0) {
	                if (IsLeadSurrogate((char) char32)
	                        && (result < source.Length - 1)
	                        && IsTrailSurrogate(source[result + 1])) {
	                    return LastIndexOf(source, char32, result - 1);
	                }
	                // trail surrogate
	                if (result > 0 && IsLeadSurrogate(source[result - 1])) {
	                    return LastIndexOf(source, char32, result - 1);
	                }
	            }
	            return result;
	        }
	        // supplementary
	        String char32str = ToString(char32);
	        return source.LastIndexOf(char32str);
	    }
	
	    /// <summary>
	    /// Returns the index within the argument UTF16 format Unicode string of the
	    /// last occurrence of the argument string str. This method is implemented
	    /// based on codepoints, hence a "lead surrogate character + trail surrogate
	    /// character" is treated as one entity.e Hence if the str starts with trail
	    /// surrogate character at index 0, a source with a leading a surrogate
	    /// character before str found at in source will not have a valid match. Vice
	    /// versa for lead surrogates that ends str. See example below.
	    /// <p>
	    /// Examples:<br>
	    /// UTF16.lastIndexOf("abc", "a") returns 0<br>
	    /// UTF16.lastIndexOf("abc\ud800\udc00", "\ud800\udc00") returns 3<br>
	    /// UTF16.lastIndexOf("abc\ud800\udc00", "\ud800") returns -1<br>
	    /// </p>
	    /// <p>
	    /// source is searched backwards starting at the last character.
	    /// </p>
	    /// Note this method is provided as support to jdk 1.3, which does not
	    /// support supplementary characters to its fullest.
	    /// </summary>
	    ///
	    /// <param name="source">UTF16 format Unicode string that will be searched</param>
	    /// <param name="str">UTF16 format Unicode string to search for</param>
	    /// <returns>the index of the last occurrence of the codepoint in source, or
	    /// -1 if the codepoint does not occur.</returns>
	    /// @stable ICU 2.6
	    public static int LastIndexOf(String source, String str) {
	        int strLength = str.Length;
	        // non-surrogate ends
	        if (!IsTrailSurrogate(str[0])
	                && !IsLeadSurrogate(str[strLength - 1])) {
	            return source.LastIndexOf(str);
	        }
	
	        int result = source.LastIndexOf(str);
	        if (result >= 0) {
	            // check last character
	            if (IsLeadSurrogate(str[strLength - 1])
	                    && (result < source.Length - 1)
	                    && IsTrailSurrogate(source[result + strLength + 1])) {
	                return LastIndexOf(source, str, result - 1);
	            }
	            // check first character which is a trail surrogate
	            if (IsTrailSurrogate(str[0]) && result > 0
	                    && IsLeadSurrogate(source[result - 1])) {
	                return LastIndexOf(source, str, result - 1);
	            }
	        }
	        return result;
	    }
	
	    /// <summary>
	    /// <p>
	    /// Returns the index within the argument UTF16 format Unicode string of the
	    /// last occurrence of the argument codepoint, where the result is less than
	    /// or equals to fromIndex.
	    /// </p>
	    /// <p>
	    /// This method is implemented based on codepoints, hence a single surrogate
	    /// character will not match a supplementary character.
	    /// </p>
	    /// <p>
	    /// source is searched backwards starting at the last character starting at
	    /// the specified index.
	    /// </p>
	    /// <p>
	    /// Examples:<br>
	    /// UTF16.lastIndexOf("abc", 'c', 2) returns 2<br>
	    /// UTF16.lastIndexOf("abc", 'c', 1) returns -1<br>
	    /// UTF16.lastIndexOf("abc\ud800\udc00", 0x10000, 5) returns 3<br>
	    /// UTF16.lastIndexOf("abc\ud800\udc00", 0x10000, 3) returns 3<br>
	    /// UTF16.lastIndexOf("abc\ud800\udc00", 0xd800) returns -1<br>
	    /// </p>
	    /// Note this method is provided as support to jdk 1.3, which does not
	    /// support supplementary characters to its fullest.
	    /// </summary>
	    ///
	    /// <param name="source">UTF16 format Unicode string that will be searched</param>
	    /// <param name="char32">codepoint to search for</param>
	    /// <param name="fromIndex">the index to start the search from. There is no restriction onthe value of fromIndex. If it is greater than or equal to thelength of this string, it has the same effect as if it wereequal to one less than the length of this string: this entirestring may be searched. If it is negative, it has the sameeffect as if it were -1: -1 is returned.</param>
	    /// <returns>the index of the last occurrence of the codepoint in source, or
	    /// -1 if the codepoint does not occur.</returns>
	    /// @stable ICU 2.6
	    public static int LastIndexOf(String source, int char32, int fromIndex) {
	        if (char32 < CODEPOINT_MIN_VALUE || char32 > CODEPOINT_MAX_VALUE) {
	            throw new ArgumentException(
	                    "Argument char32 is not a valid codepoint");
	        }
	        // non-surrogate bmp
	        if (char32 < LEAD_SURROGATE_MIN_VALUE
	                || (char32 > TRAIL_SURROGATE_MAX_VALUE && char32 < SUPPLEMENTARY_MIN_VALUE)) {
	            return source.LastIndexOf((char) char32, fromIndex);
	        }
	        // surrogate
	        if (char32 < SUPPLEMENTARY_MIN_VALUE) {
	            int result = source.LastIndexOf((char) char32, fromIndex);
	            if (result >= 0) {
	                if (IsLeadSurrogate((char) char32)
	                        && (result < source.Length - 1)
	                        && IsTrailSurrogate(source[result + 1])) {
	                    return LastIndexOf(source, char32, result - 1);
	                }
	                // trail surrogate
	                if (result > 0 && IsLeadSurrogate(source[result - 1])) {
	                    return LastIndexOf(source, char32, result - 1);
	                }
	            }
	            return result;
	        }
	        // supplementary
	        String char32str = ToString(char32);
	        return source.LastIndexOf(char32str, fromIndex);
	    }
	
	    /// <summary>
	    /// <p>
	    /// Returns the index within the argument UTF16 format Unicode string of the
	    /// last occurrence of the argument string str, where the result is less than
	    /// or equals to fromIndex.
	    /// </p>
	    /// <p>
	    /// This method is implemented based on codepoints, hence a "lead surrogate
	    /// character + trail surrogate character" is treated as one entity. Hence if
	    /// the str starts with trail surrogate character at index 0, a source with a
	    /// leading a surrogate character before str found at in source will not have
	    /// a valid match. Vice versa for lead surrogates that ends str.
	    /// </p>
	    /// See example below.
	    /// <p>
	    /// Examples:<br>
	    /// UTF16.lastIndexOf("abc", "c", 2) returns 2<br>
	    /// UTF16.lastIndexOf("abc", "c", 1) returns -1<br>
	    /// UTF16.lastIndexOf("abc\ud800\udc00", "\ud800\udc00", 5) returns 3<br>
	    /// UTF16.lastIndexOf("abc\ud800\udc00", "\ud800\udc00", 3) returns 3<br>
	    /// UTF16.lastIndexOf("abc\ud800\udc00", "\ud800", 4) returns -1<br>
	    /// </p>
	    /// <p>
	    /// source is searched backwards starting at the last character.
	    /// </p>
	    /// Note this method is provided as support to jdk 1.3, which does not
	    /// support supplementary characters to its fullest.
	    /// </summary>
	    ///
	    /// <param name="source">UTF16 format Unicode string that will be searched</param>
	    /// <param name="str">UTF16 format Unicode string to search for</param>
	    /// <param name="fromIndex">the index to start the search from. There is no restriction onthe value of fromIndex. If it is greater than or equal to thelength of this string, it has the same effect as if it wereequal to one less than the length of this string: this entirestring may be searched. If it is negative, it has the sameeffect as if it were -1: -1 is returned.</param>
	    /// <returns>the index of the last occurrence of the codepoint in source, or
	    /// -1 if the codepoint does not occur.</returns>
	    /// @stable ICU 2.6
	    public static int LastIndexOf(String source, String str, int fromIndex) {
	        int strLength = str.Length;
	        // non-surrogate ends
	        if (!IsTrailSurrogate(str[0])
	                && !IsLeadSurrogate(str[strLength - 1])) {
	            return source.LastIndexOf(str, fromIndex);
	        }
	
	        int result = source.LastIndexOf(str, fromIndex);
	        if (result >= 0) {
	            // check last character
	            if (IsLeadSurrogate(str[strLength - 1])
	                    && (result < source.Length - 1)
	                    && IsTrailSurrogate(source[result + strLength])) {
	                return LastIndexOf(source, str, result - 1);
	            }
	            // check first character which is a trail surrogate
	            if (IsTrailSurrogate(str[0]) && result > 0
	                    && IsLeadSurrogate(source[result - 1])) {
	                return LastIndexOf(source, str, result - 1);
	            }
	        }
	        return result;
	    }
	
	    /// <summary>
	    /// Returns a new UTF16 format Unicode string resulting from replacing all
	    /// occurrences of oldChar32 in source with newChar32. If the character
	    /// oldChar32 does not occur in the UTF16 format Unicode string source, then
	    /// source will be returned. Otherwise, a new String object is created that
	    /// represents a codepoint sequence identical to the codepoint sequence
	    /// represented by source, except that every occurrence of oldChar32 is
	    /// replaced by an occurrence of newChar32.
	    /// <p>
	    /// Examples: <br>
	    /// UTF16.replace("mesquite in your cellar", 'e', 'o');<br>
	    /// returns "mosquito in your collar"<br>
	    /// UTF16.replace("JonL", 'q', 'x');<br>
	    /// returns "JonL" (no change)<br>
	    /// UTF16.replace("Supplementary character \ud800\udc00", 0x10000, '!'); <br>
	    /// returns "Supplementary character !"<br>
	    /// UTF16.replace("Supplementary character \ud800\udc00", 0xd800, '!'); <br>
	    /// returns "Supplementary character \ud800\udc00"<br>
	    /// </p>
	    /// Note this method is provided as support to jdk 1.3, which does not
	    /// support supplementary characters to its fullest.
	    /// </summary>
	    ///
	    /// <param name="source">UTF16 format Unicode string which the codepoint replacementswill be based on.</param>
	    /// <param name="oldChar32">non-zero old codepoint to be replaced.</param>
	    /// <param name="newChar32">the new codepoint to replace oldChar32</param>
	    /// <returns>new String derived from source by replacing every occurrence of
	    /// oldChar32 with newChar32, unless when no oldChar32 is found in
	    /// source then source will be returned.</returns>
	    /// @stable ICU 2.6
	    public static String Replace(String source, int oldChar32, int newChar32) {
	        if (oldChar32 <= 0 || oldChar32 > CODEPOINT_MAX_VALUE) {
	            throw new ArgumentException(
	                    "Argument oldChar32 is not a valid codepoint");
	        }
	        if (newChar32 <= 0 || newChar32 > CODEPOINT_MAX_VALUE) {
	            throw new ArgumentException(
	                    "Argument newChar32 is not a valid codepoint");
	        }
	
	        int index = IndexOf(source, oldChar32);
	        if (index == -1) {
	            return source;
	        }
	        String newChar32Str = ToString(newChar32);
	        int oldChar32Size = 1;
	        int newChar32Size = newChar32Str.Length;
	        StringBuilder result = new StringBuilder(source);
	        int resultIndex = index;
	
	        if (oldChar32 >= SUPPLEMENTARY_MIN_VALUE) {
	            oldChar32Size = 2;
	        }
	
	        while (index != -1) {
	            int endResultIndex = resultIndex + oldChar32Size;
                result.Insert(resultIndex, newChar32Str, endResultIndex - resultIndex);
	            int lastEndIndex = index + oldChar32Size;
	            index = IndexOf(source, oldChar32, lastEndIndex);
	            resultIndex += newChar32Size + index - lastEndIndex;
	        }
	        return result.ToString();
	    }
	
	    /// <summary>
	    /// Returns a new UTF16 format Unicode string resulting from replacing all
	    /// occurrences of oldStr in source with newStr. If the string oldStr does
	    /// not occur in the UTF16 format Unicode string source, then source will be
	    /// returned. Otherwise, a new String object is created that represents a
	    /// codepoint sequence identical to the codepoint sequence represented by
	    /// source, except that every occurrence of oldStr is replaced by an
	    /// occurrence of newStr.
	    /// <p>
	    /// Examples: <br>
	    /// UTF16.replace("mesquite in your cellar", "e", "o");<br>
	    /// returns "mosquito in your collar"<br>
	    /// UTF16.replace("mesquite in your cellar", "mesquite", "cat");<br>
	    /// returns "cat in your cellar"<br>
	    /// UTF16.replace("JonL", "q", "x");<br>
	    /// returns "JonL" (no change)<br>
	    /// UTF16.replace("Supplementary character \ud800\udc00", "\ud800\udc00",
	    /// '!'); <br>
	    /// returns "Supplementary character !"<br>
	    /// UTF16.replace("Supplementary character \ud800\udc00", "\ud800", '!'); <br>
	    /// returns "Supplementary character \ud800\udc00"<br>
	    /// </p>
	    /// Note this method is provided as support to jdk 1.3, which does not
	    /// support supplementary characters to its fullest.
	    /// </summary>
	    ///
	    /// <param name="source">UTF16 format Unicode string which the replacements will bebased on.</param>
	    /// <param name="oldStr">non-zero-length string to be replaced.</param>
	    /// <param name="newStr">the new string to replace oldStr</param>
	    /// <returns>new String derived from source by replacing every occurrence of
	    /// oldStr with newStr. When no oldStr is found in source, then
	    /// source will be returned.</returns>
	    /// @stable ICU 2.6
	    public static String Replace(String source, String oldStr, String newStr) {
	        int index = IndexOf(source, oldStr);
	        if (index == -1) {
	            return source;
	        }
	        int oldStrSize = oldStr.Length;
	        int newStrSize = newStr.Length;
	        StringBuilder result = new StringBuilder(source);
	        int resultIndex = index;
	
	        while (index != -1) {
	            int endResultIndex = resultIndex + oldStrSize;
                result.Insert(resultIndex, newStr, endResultIndex - resultIndex);
	            int lastEndIndex = index + oldStrSize;
	            index = IndexOf(source, oldStr, lastEndIndex);
	            resultIndex += newStrSize + index - lastEndIndex;
	        }
	        return result.ToString();
	    }
	
	    /// <summary>
	    /// Reverses a UTF16 format Unicode string and replaces source's content with
	    /// it. This method will reverse surrogate characters correctly, instead of
	    /// blindly reversing every character.
	    /// <p>
	    /// Examples:<br>
	    /// UTF16.reverse(new StringBuffer(
	    /// "Supplementary characters \ud800\udc00\ud801\udc01"))<br>
	    /// returns "\ud801\udc01\ud800\udc00 sretcarahc yratnemelppuS".
	    /// </summary>
	    ///
	    /// <param name="source">the source StringBuffer that contains UTF16 format Unicodestring to be reversed</param>
	    /// <returns>a modified source with reversed UTF16 format Unicode string.</returns>
	    /// @stable ICU 2.6
	    public static StringBuilder Reverse(StringBuilder source) {
	        int length = source.Length;
	        StringBuilder result = new StringBuilder(length);
	        for (int i = length; i-- > 0;) {
	            char ch = source[i];
	            if (IsTrailSurrogate(ch) && i > 0) {
	                char ch2 = source[i - 1];
	                if (IsLeadSurrogate(ch2)) {
	                    result.Append(ch2);
	                    result.Append(ch);
	                    --i;
	                    continue;
	                }
	            }
	            result.Append(ch);
	        }
	        return result;
	    }
	
	    /// <summary>
	    /// Check if the string contains more Unicode code points than a certain
	    /// number. This is more efficient than counting all code points in the
	    /// entire string and comparing that number with a threshold. This function
	    /// may not need to scan the string at all if the length is within a certain
	    /// range, and never needs to count more than 'number + 1' code points.
	    /// Logically equivalent to (countCodePoint(s) > number). A Unicode code
	    /// point may occupy either one or two code units.
	    /// </summary>
	    ///
	    /// <param name="source">The input string.</param>
	    /// <param name="number">The number of code points in the string is compared againstthe 'number' parameter.</param>
	    /// <returns>boolean value for whether the string contains more Unicode code
	    /// points than 'number'.</returns>
	    /// @stable ICU 2.4
	    public static bool HasMoreCodePointsThan(String source, int number) {
	        if (number < 0) {
	            return true;
	        }
	        if (source == null) {
	            return false;
	        }
	        int length = source.Length;
	
	        // length >= 0 known
	        // source contains at least (length + 1) / 2 code points: <= 2
	        // chars per cp
	        if (((length + 1) >> 1) > number) {
	            return true;
	        }
	
	        // check if source does not even contain enough chars
	        int maxsupplementary = length - number;
	        if (maxsupplementary <= 0) {
	            return false;
	        }
	
	        // there are maxsupplementary = length - number more chars than
	        // asked-for code points
	
	        // count code points until they exceed and also check that there are
	        // no more than maxsupplementary supplementary code points (char pairs)
	        int start = 0;
	        while (true) {
	            if (length == 0) {
	                return false;
	            }
	            if (number == 0) {
	                return true;
	            }
	            if (IsLeadSurrogate(source[start++]) && start != length
	                    && IsTrailSurrogate(source[start])) {
	                start++;
	                if (--maxsupplementary <= 0) {
	                    // too many pairs - too few code points
	                    return false;
	                }
	            }
	            --number;
	        }
	    }
	
	    /// <summary>
	    /// Check if the sub-range of char array, from argument start to limit,
	    /// contains more Unicode code points than a certain number. This is more
	    /// efficient than counting all code points in the entire char array range
	    /// and comparing that number with a threshold. This function may not need to
	    /// scan the char array at all if start and limit is within a certain range,
	    /// and never needs to count more than 'number + 1' code points. Logically
	    /// equivalent to (countCodePoint(source, start, limit) > number). A Unicode
	    /// code point may occupy either one or two code units.
	    /// </summary>
	    ///
	    /// <param name="source">array of UTF-16 chars</param>
	    /// <param name="start">offset to substring in the source array for analyzing</param>
	    /// <param name="limit">offset to substring in the source array for analyzing</param>
	    /// <param name="number">The number of code points in the string is compared againstthe 'number' parameter.</param>
	    /// <returns>boolean value for whether the string contains more Unicode code
	    /// points than 'number'.</returns>
	    /// <exception cref="IndexOutOfBoundsException">thrown when limit &lt; start</exception>
	    /// @stable ICU 2.4
	    public static bool HasMoreCodePointsThan(char[] source, int start,
	            int limit, int number) {
	        int length = limit - start;
	        if (length < 0 || start < 0 || limit < 0) {
	            throw new IndexOutOfRangeException("Start and limit indexes should be non-negative and start <= limit".ToString());
	        }
	        if (number < 0) {
	            return true;
	        }
	        if (source == null) {
	            return false;
	        }
	
	        // length >= 0 known
	        // source contains at least (length + 1) / 2 code points: <= 2
	        // chars per cp
	        if (((length + 1) >> 1) > number) {
	            return true;
	        }
	
	        // check if source does not even contain enough chars
	        int maxsupplementary = length - number;
	        if (maxsupplementary <= 0) {
	            return false;
	        }
	
	        // there are maxsupplementary = length - number more chars than
	        // asked-for code points
	
	        // count code points until they exceed and also check that there are
	        // no more than maxsupplementary supplementary code points (char pairs)
	        while (true) {
	            if (length == 0) {
	                return false;
	            }
	            if (number == 0) {
	                return true;
	            }
	            if (IsLeadSurrogate(source[start++]) && start != limit
	                    && IsTrailSurrogate(source[start])) {
	                start++;
	                if (--maxsupplementary <= 0) {
	                    // too many pairs - too few code points
	                    return false;
	                }
	            }
	            --number;
	        }
	    }
	
	    /// <summary>
	    /// Check if the string buffer contains more Unicode code points than a
	    /// certain number. This is more efficient than counting all code points in
	    /// the entire string buffer and comparing that number with a threshold. This
	    /// function may not need to scan the string buffer at all if the length is
	    /// within a certain range, and never needs to count more than 'number + 1'
	    /// code points. Logically equivalent to (countCodePoint(s) > number). A
	    /// Unicode code point may occupy either one or two code units.
	    /// </summary>
	    ///
	    /// <param name="source">The input string buffer.</param>
	    /// <param name="number">The number of code points in the string buffer is comparedagainst the 'number' parameter.</param>
	    /// <returns>boolean value for whether the string buffer contains more Unicode
	    /// code points than 'number'.</returns>
	    /// @stable ICU 2.4
	    public static bool HasMoreCodePointsThan(StringBuilder source, int number) {
	        if (number < 0) {
	            return true;
	        }
	        if (source == null) {
	            return false;
	        }
	        int length = source.Length;
	
	        // length >= 0 known
	        // source contains at least (length + 1) / 2 code points: <= 2
	        // chars per cp
	        if (((length + 1) >> 1) > number) {
	            return true;
	        }
	
	        // check if source does not even contain enough chars
	        int maxsupplementary = length - number;
	        if (maxsupplementary <= 0) {
	            return false;
	        }
	
	        // there are maxsupplementary = length - number more chars than
	        // asked-for code points
	
	        // count code points until they exceed and also check that there are
	        // no more than maxsupplementary supplementary code points (char pairs)
	        int start = 0;
	        while (true) {
	            if (length == 0) {
	                return false;
	            }
	            if (number == 0) {
	                return true;
	            }
	            if (IsLeadSurrogate(source[start++]) && start != length
	                    && IsTrailSurrogate(source[start])) {
	                start++;
	                if (--maxsupplementary <= 0) {
	                    // too many pairs - too few code points
	                    return false;
	                }
	            }
	            --number;
	        }
	    }
	
	    /// <summary>
	    /// Cover JDK 1.5 API. Create a String from an array of codePoints.
	    /// </summary>
	    ///
	    /// <param name="codePoints">the code array</param>
	    /// <param name="offset">the start of the text in the code point array</param>
	    /// <param name="count">the number of code points</param>
	    /// <returns>a String representing the code points between offset and count</returns>
	    /// <exception cref="IllegalArgumentException">if an invalid code point is encountered</exception>
	    /// <exception cref="IndexOutOfBoundsException">if the offset or count are out of bounds.</exception>
	    /// @stable ICU 3.0
	    public static String NewString(int[] codePoints, int offset, int count) {
	        if (count < 0) {
	            throw new ArgumentException();
	        }
	        char[] chars = new char[count];
	        int w = 0;
	        for (int r = offset, e = offset + count; r < e; ++r) {
	            int cp = codePoints[r];
	            if (cp < 0 || cp > 0x10ffff) {
	                throw new ArgumentException();
	            }
	            while (true) {
	                try {
	                    if (cp < 0x010000) {
	                        chars[w] = (char) cp;
	                        w++;
	                    } else {
	                        chars[w] = (char) (LEAD_SURROGATE_OFFSET_ + (cp >> LEAD_SURROGATE_SHIFT_));
	                        chars[w + 1] = (char) (TRAIL_SURROGATE_MIN_VALUE + (cp & TRAIL_SURROGATE_MASK_));
	                        w += 2;
	                    }
	                    break;
	                } catch (IndexOutOfRangeException ex) {
	                    int newlen = (int) (Math.Ceiling((double) codePoints.Length
	                                                * (w + 2) / (r - offset + 1)));
	                    char[] temp = new char[newlen];
	                    System.Array.Copy((Array)(chars),0,(Array)(temp),0,w);
	                    chars = temp;
	                }
	            }
	        }
	        return new String(chars, 0, w);
	    }
	
	    /// <summary>
	    /// <p>
	    /// UTF16 string comparator class. Allows UTF16 string comparison to be done
	    /// with the various modes
	    /// </p>
	    /// <ul>
	    /// <li>Code point comparison or code unit comparison
	    /// <li>Case sensitive comparison, case insensitive comparison or case
	    /// insensitive comparison with special handling for character 'i'.
	    /// </ul>
	    /// <p>
	    /// The code unit or code point comparison differ only when comparing
	    /// supplementary code points (&#92;u10000..&#92;u10ffff) to BMP code points
	    /// near the end of the BMP (i.e., &#92;ue000..&#92;uffff). In code unit
	    /// comparison, high BMP code points sort after supplementary code points
	    /// because they are stored as pairs of surrogates which are at
	    /// &#92;ud800..&#92;udfff.
	    /// </p>
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.UTF16.FOLD_CASE_DEFAULT"/>
	    /// <seealso cref="M:IBM.ICU.Text.UTF16.FOLD_CASE_EXCLUDE_SPECIAL_I"/>
	    /// @stable ICU 2.1
	    public sealed class StringComparator : IComparer {
	        // public constructor ------------------------------------------------
	
	        /// <summary>
	        /// Default constructor that does code unit comparison and case sensitive
	        /// comparison.
	        /// </summary>
	        ///
	        /// @stable ICU 2.1
	        public StringComparator() : this(false, false, FOLD_CASE_DEFAULT) {
	        }
	
	        /// <summary>
	        /// Constructor that does comparison based on the argument options.
	        /// </summary>
	        ///
	        /// <param name="codepointcompare">flag to indicate true for code point comparison or falsefor code unit comparison.</param>
	        /// <param name="ignorecase">false for case sensitive comparison, true forcase-insensitive comparison</param>
	        /// <param name="foldcaseoption">FOLD_CASE_DEFAULT or FOLD_CASE_EXCLUDE_SPECIAL_I. Thisoption is used only when ignorecase is set to true. Ifignorecase is false, this option is ignored.</param>
	        /// <seealso cref="null"/>
	        /// <seealso cref="null"/>
	        /// <exception cref="IllegalArgumentException">if foldcaseoption is out of range</exception>
	        /// @stable ICU 2.4
	        public StringComparator(bool codepointcompare, bool ignorecase,
	                int foldcaseoption) {
	            SetCodePointCompare(codepointcompare);
	            m_ignoreCase_ = ignorecase;
	            if (foldcaseoption < FOLD_CASE_DEFAULT
	                    || foldcaseoption > FOLD_CASE_EXCLUDE_SPECIAL_I) {
	                throw new ArgumentException("Invalid fold case option");
	            }
	            m_foldCase_ = foldcaseoption;
	        }
	
	        // public data member ------------------------------------------------
	
	        /// <summary>
	        /// <p>
	        /// Option value for case folding comparison:
	        /// </p>
	        /// <p>
	        /// Comparison is case insensitive, strings are folded using default
	        /// mappings defined in Unicode data file CaseFolding.txt, before
	        /// comparison.
	        /// </p>
	        /// </summary>
	        ///
	        /// @stable ICU 2.4
	        public const int FOLD_CASE_DEFAULT = 0;
	
	        /// <summary>
	        /// <p>
	        /// Option value for case folding comparison:
	        /// </p>
	        /// <p>
	        /// Comparison is case insensitive, strings are folded using modified
	        /// mappings defined in Unicode data file CaseFolding.txt, before
	        /// comparison.
	        /// </p>
	        /// <p>
	        /// The modified set of mappings is provided in a Unicode data file
	        /// CaseFolding.txt to handle dotted I and dotless i appropriately for
	        /// Turkic languages (tr, az).
	        /// </p>
	        /// <p>
	        /// Before Unicode 3.2, CaseFolding.txt contains mappings marked with 'I'
	        /// that are to be included for default mappings and excluded for the
	        /// Turkic-specific mappings.
	        /// </p>
	        /// <p>
	        /// Unicode 3.2 CaseFolding.txt instead contains mappings marked with 'T'
	        /// that are to be excluded for default mappings and included for the
	        /// Turkic-specific mappings.
	        /// </p>
	        /// </summary>
	        ///
	        /// @stable ICU 2.4
	        public const int FOLD_CASE_EXCLUDE_SPECIAL_I = 1;
	
	        // public methods ----------------------------------------------------
	
	        // public setters ----------------------------------------------------
	
	        /// <summary>
	        /// Sets the comparison mode to code point compare if flag is true.
	        /// Otherwise comparison mode is set to code unit compare
	        /// </summary>
	        ///
	        /// <param name="flag">true for code point compare, false for code unit compare</param>
	        /// @stable ICU 2.4
	        public void SetCodePointCompare(bool flag) {
	            if (flag) {
	                m_codePointCompare_ = IBM.ICU.Text.Normalizer.COMPARE_CODE_POINT_ORDER;
	            } else {
	                m_codePointCompare_ = 0;
	            }
	        }
	
	        /// <summary>
	        /// Sets the Comparator to case-insensitive comparison mode if argument
	        /// is true, otherwise case sensitive comparison mode if set to false.
	        /// </summary>
	        ///
	        /// <param name="ignorecase">true for case-insitive comparison, false for casesensitive comparison</param>
	        /// <param name="foldcaseoption">FOLD_CASE_DEFAULT or FOLD_CASE_EXCLUDE_SPECIAL_I. Thisoption is used only when ignorecase is set to true. Ifignorecase is false, this option is ignored.</param>
	        /// <seealso cref="null"/>
	        /// <seealso cref="null"/>
	        /// @stable ICU 2.4
	        public void SetIgnoreCase(bool ignorecase, int foldcaseoption) {
	            m_ignoreCase_ = ignorecase;
	            if (foldcaseoption < FOLD_CASE_DEFAULT
	                    || foldcaseoption > FOLD_CASE_EXCLUDE_SPECIAL_I) {
	                throw new ArgumentException("Invalid fold case option");
	            }
	            m_foldCase_ = foldcaseoption;
	        }
	
	        // public getters ----------------------------------------------------
	
	        /// <summary>
	        /// Checks if the comparison mode is code point compare.
	        /// </summary>
	        ///
	        /// <returns>true for code point compare, false for code unit compare</returns>
	        /// @stable ICU 2.4
	        public bool GetCodePointCompare() {
	            return m_codePointCompare_ == IBM.ICU.Text.Normalizer.COMPARE_CODE_POINT_ORDER;
	        }
	
	        /// <summary>
	        /// Checks if Comparator is in the case insensitive mode.
	        /// </summary>
	        ///
	        /// <returns>true if Comparator performs case insensitive comparison,
	        /// false otherwise</returns>
	        /// @stable ICU 2.4
	        public bool GetIgnoreCase() {
	            return m_ignoreCase_;
	        }
	
	        /// <summary>
	        /// Gets the fold case options set in Comparator to be used with case
	        /// insensitive comparison.
	        /// </summary>
	        ///
	        /// <returns>either FOLD_CASE_DEFAULT or FOLD_CASE_EXCLUDE_SPECIAL_I</returns>
	        /// <seealso cref="null"/>
	        /// <seealso cref="null"/>
	        /// @stable ICU 2.4
	        public int GetIgnoreCaseOption() {
	            return m_foldCase_;
	        }
	
	        // public other methods ----------------------------------------------
	
	        /// <summary>
	        /// Compare two strings depending on the options selected during
	        /// construction.
	        /// </summary>
	        ///
	        /// <param name="a">first source string.</param>
	        /// <param name="b">second source string.</param>
	        /// <returns>0 returned if a == b. If a < b, a negative value is returned.
	        /// Otherwise if a > b, a positive value is returned.</returns>
	        /// <exception cref="ClassCastException">thrown when either a or b is not a String object</exception>
	        /// @stable ICU 2.4
	        public int Compare(Object a, Object b) {
	            String str1 = (String) a;
	            String str2 = (String) b;
	
	            if (str1 == str2) {
	                return 0;
	            }
	            if (str1 == null) {
	                return -1;
	            }
	            if (str2 == null) {
	                return 1;
	            }
	
	            if (m_ignoreCase_) {
	                return CompareCaseInsensitive(str1, str2);
	            }
	            return CompareCaseSensitive(str1, str2);
	        }
	
	        // private data member ----------------------------------------------
	
	        /// <summary>
	        /// Code unit comparison flag. True if code unit comparison is required.
	        /// False if code point comparison is required.
	        /// </summary>
	        ///
	        private int m_codePointCompare_;
	
	        /// <summary>
	        /// Fold case comparison option.
	        /// </summary>
	        ///
	        private int m_foldCase_;
	
	        /// <summary>
	        /// Flag indicator if ignore case is to be used during comparison
	        /// </summary>
	        ///
	        private bool m_ignoreCase_;
	
	        /// <summary>
	        /// Code point order offset for surrogate characters
	        /// </summary>
	        ///
	        private const int CODE_POINT_COMPARE_SURROGATE_OFFSET_ = 0x2800;
	
	        // private method ---------------------------------------------------
	
	        /// <summary>
	        /// Compares case insensitive. This is a direct port of ICU4C, to make
	        /// maintainence life easier.
	        /// </summary>
	        ///
	        /// <param name="s1">first string to compare</param>
	        /// <param name="s2">second string to compare</param>
	        /// <returns>-1 is s1 &lt; s2, 0 if equals,</returns>
	        public int CompareCaseInsensitive(String s1, String s2) {
	            return IBM.ICU.Impl.NormalizerImpl.CmpEquivFold(s1, s2, m_foldCase_
	                    | m_codePointCompare_ | IBM.ICU.Text.Normalizer.COMPARE_IGNORE_CASE);
	        }
	
	        /// <summary>
	        /// Compares case sensitive. This is a direct port of ICU4C, to make
	        /// maintainence life easier.
	        /// </summary>
	        ///
	        /// <param name="s1">first string to compare</param>
	        /// <param name="s2">second string to compare</param>
	        /// <returns>-1 is s1 &lt; s2, 0 if equals,</returns>
	        public int CompareCaseSensitive(String s1, String s2) {
	            // compare identical prefixes - they do not need to be fixed up
	            // limit1 = start1 + min(lenght1, length2)
	            int length1 = s1.Length;
	            int length2 = s2.Length;
	            int minlength = length1;
	            int result = 0;
	            if (length1 < length2) {
	                result = -1;
	            } else if (length1 > length2) {
	                result = 1;
	                minlength = length2;
	            }
	
	            char c1 = (char) (0);
	            char c2 = (char) (0);
	            int index = 0;
	            for (; index < minlength; index++) {
	                c1 = s1[index];
	                c2 = s2[index];
	                // check pseudo-limit
	                if (c1 != c2) {
	                    break;
	                }
	            }
	
	            if (index == minlength) {
	                return result;
	            }
	
	            bool codepointcompare = m_codePointCompare_ == IBM.ICU.Text.Normalizer.COMPARE_CODE_POINT_ORDER;
	            // if both values are in or above the surrogate range, fix them up
	            if (c1 >= IBM.ICU.Text.UTF16.LEAD_SURROGATE_MIN_VALUE
	                    && c2 >= IBM.ICU.Text.UTF16.LEAD_SURROGATE_MIN_VALUE && codepointcompare) {
	                // subtract 0x2800 from BMP code points to make them smaller
	                // than supplementary ones
	                if ((c1 <= IBM.ICU.Text.UTF16.LEAD_SURROGATE_MAX_VALUE && (index + 1) != length1 && IBM.ICU.Text.UTF16.IsTrailSurrogate(s1[index + 1]))
	                        || (IBM.ICU.Text.UTF16.IsTrailSurrogate(c1) && index != 0 && IBM.ICU.Text.UTF16.IsLeadSurrogate(s1[index - 1]))) {
	                    // part of a surrogate pair, leave >=d800
	                } else {
	                    // BMP code point - may be surrogate code point - make
	                    // < d800
	                    c1 -= ((Char)CODE_POINT_COMPARE_SURROGATE_OFFSET_);
	                }
	
	                if ((c2 <= IBM.ICU.Text.UTF16.LEAD_SURROGATE_MAX_VALUE && (index + 1) != length2 && IBM.ICU.Text.UTF16.IsTrailSurrogate(s2[index + 1]))
	                        || (IBM.ICU.Text.UTF16.IsTrailSurrogate(c2) && index != 0 && IBM.ICU.Text.UTF16.IsLeadSurrogate(s2[index - 1]))) {
	                    // part of a surrogate pair, leave >=d800
	                } else {
	                    // BMP code point - may be surrogate code point - make <d800
	                    c2 -= ((Char)CODE_POINT_COMPARE_SURROGATE_OFFSET_);
	                }
	            }
	
	            // now c1 and c2 are in UTF-32-compatible order
	            return c1 - c2;
	        }
	    }
	
	    // private data members -------------------------------------------------
	
	    /// <summary>
	    /// Shift value for lead surrogate to form a supplementary character.
	    /// </summary>
	    ///
	    private const int LEAD_SURROGATE_SHIFT_ = 10;
	
	    /// <summary>
	    /// Mask to retrieve the significant value from a trail surrogate.
	    /// </summary>
	    ///
	    private const int TRAIL_SURROGATE_MASK_ = 0x3FF;
	
	    /// <summary>
	    /// Value that all lead surrogate starts with
	    /// </summary>
	    ///
	    private const int LEAD_SURROGATE_OFFSET_ = LEAD_SURROGATE_MIN_VALUE
	            - (SUPPLEMENTARY_MIN_VALUE >> LEAD_SURROGATE_SHIFT_);
	
	    // private methods ------------------------------------------------------
	
	    /// <summary>
	    /// <p>
	    /// Converts argument code point and returns a String object representing the
	    /// code point's value in UTF16 format.
	    /// </p>
	    /// <p>
	    /// This method does not check for the validity of the codepoint, the results
	    /// are not guaranteed if a invalid codepoint is passed as argument.
	    /// </p>
	    /// <p>
	    /// The result is a string whose length is 1 for non-supplementary code
	    /// points, 2 otherwise.
	    /// </p>
	    /// </summary>
	    ///
	    /// <param name="ch">code point</param>
	    /// <returns>string representation of the code point</returns>
	    private static String ToString(int ch) {
	        if (ch < SUPPLEMENTARY_MIN_VALUE) {
	            return ch.ToString();
	        }
	
	        StringBuilder result = new StringBuilder();
	        result.Append(GetLeadSurrogate(ch));
	        result.Append(GetTrailSurrogate(ch));
	        return result.ToString();
	    }
	}
	// eof
}
