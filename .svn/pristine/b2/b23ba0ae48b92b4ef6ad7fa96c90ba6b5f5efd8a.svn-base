/* 
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110104_01     
// 1/4/11 3:58 PM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace ILOG.J2CsMapping.Text {
	
	using IBM.ICU.Text;
	using ILOG.J2CsMapping.Text;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
     using System;
     using ILOG.J2CsMapping.Util;
	
	/// <summary>
	/// Collator is an abstract class which is the root of classes which provide
	/// Locale specific String comparison to determine their ordering with respect to
	/// each other.
	/// </summary>
	///
	public abstract class Collator : IComparer<object>, ICloneable {
	
	    internal const int EQUAL = 0;
	
	    internal const int GREATER = 1;
	
	    internal const int LESS = -1;
	
	    /// <summary>
	    /// Constant used to specify the decomposition rule.
	    /// </summary>
	    ///
	    public const int NO_DECOMPOSITION = 0;
	
	    /// <summary>
	    /// Constant used to specify the decomposition rule.
	    /// </summary>
	    ///
	    public const int CANONICAL_DECOMPOSITION = 1;
	
	    /// <summary>
	    /// Constant used to specify the decomposition rule.
	    /// </summary>
	    ///
	    public const int FULL_DECOMPOSITION = 2;
	
	    /// <summary>
	    /// Constant used to specify the collation strength.
	    /// </summary>
	    ///
	    public const int PRIMARY = 0;
	
	    /// <summary>
	    /// Constant used to specify the collation strength.
	    /// </summary>
	    ///
	    public const int SECONDARY = 1;
	
	    /// <summary>
	    /// Constant used to specify the collation strength.
	    /// </summary>
	    ///
	    public const int TERTIARY = 2;
	
	    /// <summary>
	    /// Constant used to specify the collation strength.
	    /// </summary>
	    ///
	    public const int IDENTICAL = 3;
	
	    private static int CACHE_SIZE;
	
	    private static List<Collator> cache = new List<Collator>(CACHE_SIZE);
	
	    // Wrapper class of ICU4J Collator
	    internal IBM.ICU.Text.Collator icuColl;
	
	    internal Collator(IBM.ICU.Text.Collator wrapper) {
	        this.icuColl = wrapper;
	    }
	
	    /// <summary>
	    /// Constructs a new instance of this Collator.
	    /// </summary>
	    ///
	    protected internal Collator() : base() {
	    }
	
	    /// <summary>
	    /// Answers a new Collator with the same decomposition rule and strength
	    /// value as this Collator.
	    /// </summary>
	    ///
	    /// <returns>a shallow copy of this Collator</returns>
	    /// <seealso cref="T:System.ICloneable"/>
	    public virtual Object Clone() {
	        try {
	            Collator clone = (Collator) base.MemberwiseClone();
	            clone.icuColl = (IBM.ICU.Text.Collator) this.icuColl.Clone();
	            return clone;
	        } catch (Exception e) {
	            return null;
	        }
	    }
	
	    /// <summary>
	    /// Compares the two objects to determine their relative ordering. The
	    /// objects must be Strings.
	    /// </summary>
	    ///
	    /// <param name="object1">the first String to compare</param>
	    /// <param name="object2">the second String to compare</param>
	    /// <returns>an int < 0 if object1 is less than object2, 0 if they are equal,
	    /// and > 0 if object1 is greater than object2</returns>
	    /// <exception cref="ClassCastException">when the objects are not Strings</exception>
	    public virtual int Compare(Object object1, Object object2) {
	        return Compare((String) object1, (String) object2);
	    }
	
	    /// <summary>
	    /// Compares the two Strings to determine their relative ordering.
	    /// </summary>
	    ///
	    /// <param name="string1">the first String to compare</param>
	    /// <param name="string2">the second String to compare</param>
	    /// <returns>an int < 0 if string1 is less than string2, 0 if they are equal,
	    /// and > 0 if string1 is greater than string2</returns>
	    public abstract int Compare(String string1, String string2);
	
	    /// <summary>
	    /// Compares the specified object to this Collator and answer if they are
	    /// equal. The object must be an instance of Collator and have the same
	    /// strength and decomposition values.
	    /// </summary>
	    ///
	    /// <param name="object">the object to compare with this object</param>
	    /// <returns>true if the specified object is equal to this Collator, false
	    /// otherwise</returns>
	    /// <seealso cref="M:ILOG.J2CsMapping.Text.Collator.HashCode"/>
	    public override bool Equals(Object obj0) {
	        if (!(obj0   is  Collator)) {
	            return false;
	        }
	        Collator collator = (Collator) obj0;
	        return (this.icuColl == null) ? collator.icuColl == null : this.icuColl
	                .Equals(collator.icuColl);
	    }
	
	    /// <summary>
	    /// Compares the two Strings using the collation rules to determine if they
	    /// are equal.
	    /// </summary>
	    ///
	    /// <param name="string1">the first String to compare</param>
	    /// <param name="string2">the second String to compare</param>
	    /// <returns>true if the strings are equal using the collation rules, false
	    /// otherwise</returns>
	    public bool Equals(String string1, String string2) {
	        return Compare(string1, string2) == 0;
	    }
	
	    /// <summary>
	    /// Gets the list of installed Locales which support Collator.
	    /// </summary>
	    ///
	    /// <returns>an array of Locale</returns>
	    public static Locale[] GetAvailableLocales() {
	        return IBM.ICU.Text.Collator.GetAvailableLocales();
	    }
	
	    /// <summary>
	    /// Answers a CollationKey for the specified String for this Collator with
	    /// the current decomposition rule and strength value.
	    /// </summary>
	    ///
	    /// <param name="string">the collation key.</param>
	    /// <returns>a CollationKey</returns>
	    public abstract CollationKey GetCollationKey(String str0);
	
	    /// <summary>
	    /// Answers the decomposition rule for this Collator.
	    /// </summary>
	    ///
	    /// <returns>the decomposition rule, either NO_DECOMPOSITION,
	    /// CANONICAL_DECOMPOSITION or FULL_DECOMPOSITION</returns>
	    public int GetDecomposition() {
	        return DecompositionMode_ICU_Java(this.icuColl.GetDecomposition());
	    }
	
	    /// <summary>
	    /// Answers a Collator instance which is appropriate for the default Locale.
	    /// </summary>
	    ///
	    /// <returns>a Collator</returns>
	    public static Collator GetInstance() {
	        return GetInstance(Locale.GetDefault());
	    }
	
	    /// <summary>
	    /// Answers a Collator instance which is appropriate for the specified
	    /// Locale.
	    /// </summary>
	    ///
	    /// <param name="locale">the Locale</param>
	    /// <returns>a Collator</returns>
	    public static Collator GetInstance(Locale locale) {
	        String key = locale.ToString();
	        for (int i = cache.Count - 1; i >= 0; i -= 2) {
	            if (cache[i].Equals(key)) {
	                return (Collator) (cache[i - 1]).Clone();
	            }
	        }
	
	        return new RuleBasedCollator(
	                IBM.ICU.Text.Collator.GetInstance(locale));
	    }
	
	    /// <summary>
	    /// Answers the strength value for this Collator.
	    /// </summary>
	    ///
	    /// <returns>the strength value, either PRIMARY, SECONDARY, TERTIARY, or
	    /// IDENTICAL</returns>
	    public int GetStrength() {
	        return Strength_ICU_Java(this.icuColl.GetStrength());
	    }
	
	    /// <summary>
	    /// Answers an integer hash code for the receiver. Objects which are equal
	    /// answer the same value for this method.
	    /// </summary>
	    ///
	    /// <returns>the receiver's hash</returns>
	    /// <seealso cref="M:ILOG.J2CsMapping.Text.Collator.Equals(System.Object)"/>
	    /// <seealso cref="M:ILOG.J2CsMapping.Text.Collator.Equals(System.String, System.String)"/>
	    public abstract override int GetHashCode();
	
	    /// <summary>
	    /// Sets the decomposition rule for this Collator.
	    /// </summary>
	    ///
	    /// <param name="value">the decomposition rule, either NO_DECOMPOSITION,CANONICAL_DECOMPOSITION or FULL_DECOMPOSITION</param>
	    /// <exception cref="IllegalArgumentException">when the decomposition rule is not valid</exception>
	    public void SetDecomposition(int value_ren) {
	        this.icuColl.SetDecomposition(DecompositionMode_Java_ICU(value_ren));
	    }
	
	    /// <summary>
	    /// Sets the strength value for this Collator.
	    /// </summary>
	    ///
	    /// <param name="value">the strength value, either PRIMARY, SECONDARY, TERTIARY, orIDENTICAL</param>
	    /// <exception cref="IllegalArgumentException">when the strength value is not valid</exception>
	    public void SetStrength(int value_ren) {
	        this.icuColl.SetStrength(Strength_Java_ICU(value_ren));
	    }
	
	    private int DecompositionMode_Java_ICU(int mode) {
	        int icuDecomp = mode;
	        switch (mode) {
	        case Collator.CANONICAL_DECOMPOSITION:
	            icuDecomp = IBM.ICU.Text.Collator.CANONICAL_DECOMPOSITION;
	            break;
	        case Collator.NO_DECOMPOSITION:
	            icuDecomp = IBM.ICU.Text.Collator.NO_DECOMPOSITION;
	            break;
	        }
	        return icuDecomp;
	    }
	
	    private int DecompositionMode_ICU_Java(int mode) {
	        int javaMode = mode;
	        switch (mode) {
	        case IBM.ICU.Text.Collator.NO_DECOMPOSITION:
	            javaMode = Collator.NO_DECOMPOSITION;
	            break;
	        case IBM.ICU.Text.Collator.CANONICAL_DECOMPOSITION:
	            javaMode = Collator.CANONICAL_DECOMPOSITION;
	            break;
	        }
	        return javaMode;
	    }
	
	    private int Strength_Java_ICU(int value_ren) {
	        int icuValue = value_ren;
	        switch (value_ren) {
	        case Collator.PRIMARY:
	            icuValue = IBM.ICU.Text.Collator.PRIMARY;
	            break;
	        case Collator.SECONDARY:
	            icuValue = IBM.ICU.Text.Collator.SECONDARY;
	            break;
	        case Collator.TERTIARY:
	            icuValue = IBM.ICU.Text.Collator.TERTIARY;
	            break;
	        case Collator.IDENTICAL:
	            icuValue = IBM.ICU.Text.Collator.IDENTICAL;
	            break;
	        }
	        return icuValue;
	
	    }
	
	    private int Strength_ICU_Java(int value_ren) {
	        int javaValue = value_ren;
	        switch (value_ren) {
	        case IBM.ICU.Text.Collator.PRIMARY:
	            javaValue = Collator.PRIMARY;
	            break;
	        case IBM.ICU.Text.Collator.SECONDARY:
	            javaValue = Collator.SECONDARY;
	            break;
	        case IBM.ICU.Text.Collator.TERTIARY:
	            javaValue = Collator.TERTIARY;
	            break;
	        case IBM.ICU.Text.Collator.IDENTICAL:
	            javaValue = Collator.IDENTICAL;
	            break;
	        }
	        return javaValue;
	    }
	
	    static Collator() {
	            String cacheSize = null;
	            if (cacheSize != null) {
	                try {
	                    CACHE_SIZE = Int32.Parse(cacheSize);
	                } catch (FormatException e) {
	                    CACHE_SIZE = 6;
	                }
	            } else {
	                CACHE_SIZE = 6;
	            }
	        }
	}
}
