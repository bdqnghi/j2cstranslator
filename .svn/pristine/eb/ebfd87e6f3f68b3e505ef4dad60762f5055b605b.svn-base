/* 
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/1/10 3:36 PM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
namespace ILOG.J2CsMapping.Formatting
{

    using ILOG.J2CsMapping.IO;
    using ILOG.J2CsMapping.Text;
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.Globalization;
    using System.IO;
    using System.Reflection;
    using System.Runtime.CompilerServices;
    using System.Text;
    using IBM.ICU.Util;

    /// <summary>
    /// DecimalFormat is used to format and parse numbers, both integers and
    /// fractions, based on a pattern. The pattern characters used can be either
    /// localized or non-localized.
    /// </summary>
    ///
    public class DecimalFormat : NumberFormat
    {

        public sealed class Anonymous_C0 :
                Object
        {
            private readonly Object target;
            private readonly Object value_ren;
            private readonly String fieldName;

            public Anonymous_C0(Object target_0, Object value_ren, String fieldName_1)
            {
                this.target = target_0;
                this.value_ren = value_ren;
                this.fieldName = fieldName_1;
            }

            public FieldInfo Run()
            {
                FieldInfo field = null;
                try
                {
                    field = target.GetType().GetField(
                            fieldName);
                    ILOG.J2CsMapping.Reflect.AccessibleObject.SetAccessible(field, true);
                    field.SetValue(target, value_ren);
                }
                catch (Exception e)
                {
                    return null;
                }
                return field;
            }
        }

        private const long serialVersionUID = 864413376551465018L;

        private bool parseBigDecimal;

        private DecimalFormatSymbols symbols;

        private IBM.ICU.Text.DecimalFormat dform;

        private IBM.ICU.Text.DecimalFormatSymbols icuSymbols;

        private const int CURRENT_SERIAL_VERTION = 3;

        private int serialVersionOnStream;

        /// <summary>
        /// Constructs a new DecimalFormat for formatting and parsing numbers for the
        /// default Locale.
        /// </summary>
        ///
        public DecimalFormat()
        {
            this.parseBigDecimal = false;
            this.serialVersionOnStream = 3;
            ILOG.J2CsMapping.Util.Locale locale = ILOG.J2CsMapping.Util.Locale.GetDefault();
            icuSymbols = new IBM.ICU.Text.DecimalFormatSymbols(locale);
            symbols = new DecimalFormatSymbols(locale);
            dform = new IBM.ICU.Text.DecimalFormat();

            base.SetMaximumFractionDigits(dform.GetMaximumFractionDigits());
            base.SetMaximumIntegerDigits(dform.GetMaximumIntegerDigits());
            base.SetMinimumFractionDigits(dform.GetMinimumFractionDigits());
            base.SetMinimumIntegerDigits(dform.GetMinimumIntegerDigits());
        }

        /// <summary>
        /// Constructs a new DecimalFormat using the specified non-localized pattern
        /// and the DecimalFormatSymbols for the default Locale.
        /// </summary>
        ///
        /// <param name="pattern">the non-localized pattern</param>
        /// <exception cref="IllegalArgumentException">when the pattern cannot be parsed</exception>
        public DecimalFormat(String pattern)
        {
            this.parseBigDecimal = false;
            this.serialVersionOnStream = 3;
            ILOG.J2CsMapping.Util.Locale locale = ILOG.J2CsMapping.Util.Locale.GetDefault();
            icuSymbols = new IBM.ICU.Text.DecimalFormatSymbols(locale);
            symbols = new DecimalFormatSymbols(locale);
            dform = new IBM.ICU.Text.DecimalFormat(pattern, icuSymbols);

            base.SetMaximumFractionDigits(dform.GetMaximumFractionDigits());
            base.SetMaximumIntegerDigits(dform.GetMaximumIntegerDigits());
            base.SetMinimumFractionDigits(dform.GetMinimumFractionDigits());
            base.SetMinimumIntegerDigits(dform.GetMinimumIntegerDigits());
        }

        /// <summary>
        /// Constructs a new DecimalFormat using the specified non-localized pattern
        /// and DecimalFormatSymbols.
        /// </summary>
        ///
        /// <param name="pattern">the non-localized pattern</param>
        /// <param name="value">the DecimalFormatSymbols</param>
        /// <exception cref="IllegalArgumentException">when the pattern cannot be parsed</exception>
        public DecimalFormat(String pattern, DecimalFormatSymbols value_ren)
        {
            this.parseBigDecimal = false;
            this.serialVersionOnStream = 3;
            symbols = (DecimalFormatSymbols)value_ren.Clone();
            ILOG.J2CsMapping.Util.Locale locale = symbols.GetLocale(); //$NON-NLS-1$
            icuSymbols = new IBM.ICU.Text.DecimalFormatSymbols(locale);
            CopySymbols(icuSymbols, symbols);

            dform = new IBM.ICU.Text.DecimalFormat(pattern, icuSymbols);

            base.SetMaximumFractionDigits(dform.GetMaximumFractionDigits());
            base.SetMaximumIntegerDigits(dform.GetMaximumIntegerDigits());
            base.SetMinimumFractionDigits(dform.GetMinimumFractionDigits());
            base.SetMinimumIntegerDigits(dform.GetMinimumIntegerDigits());
        }

        /// <summary>
        /// Changes the pattern of this DecimalFormat to the specified pattern which
        /// uses localized pattern characters.
        /// </summary>
        ///
        /// <param name="pattern">the localized pattern</param>
        /// <exception cref="IllegalArgumentException">when the pattern cannot be parsed</exception>
        public void ApplyLocalizedPattern(String pattern)
        {
            dform.ApplyLocalizedPattern(pattern);
        }

        /// <summary>
        /// Changes the pattern of this SimpleDateFormat to the specified pattern
        /// which uses non-localized pattern characters.
        /// </summary>
        ///
        /// <param name="pattern">the non-localized pattern</param>
        /// <exception cref="IllegalArgumentException">when the pattern cannot be parsed</exception>
        public void ApplyPattern(String pattern)
        {

            dform.ApplyPattern(pattern);
        }

        /// <summary>
        /// Answers a new instance of DecimalFormat with the same pattern and
        /// properties as this DecimalFormat.
        /// </summary>
        ///
        /// <returns>a shallow copy of this DecimalFormat</returns>
        /// <seealso cref="T:System.ICloneable"/>
        public Object Clone()
        {
            DecimalFormat clone = (DecimalFormat)base.Clone();
            clone.dform = (IBM.ICU.Text.DecimalFormat)dform.Clone();
            clone.symbols = (DecimalFormatSymbols)symbols.Clone();
            return clone;
        }

        /// <summary>
        /// Compares the specified object to this DecimalFormat and answer if they
        /// are equal. The object must be an instance of DecimalFormat with the same
        /// pattern and properties.
        /// </summary>
        ///
        /// <param name="object">the object to compare with this object</param>
        /// <returns>true if the specified object is equal to this DecimalFormat,
        /// false otherwise</returns>
        /// <seealso cref="M:ILOG.J2CsMapping.Text.DummyFormat.HashCode"/>
        public override bool Equals(Object obj0)
        {
            if ((Object)this == obj0)
            {
                return true;
            }
            if (!(obj0 is DecimalFormat))
            {
                return false;
            }
            DecimalFormat format = (DecimalFormat)obj0;
            return ((this.dform == null) ? format.dform == null : this.dform
                    .Equals(format.dform));
        }

        /// <summary>
        /// Formats the specified object using the rules of this DecimalNumberFormat
        /// and returns an AttributedCharacterIterator with the formatted number and
        /// attributes.
        /// </summary>
        ///
        /// <param name="object">the object to format</param>
        /// <returns>an AttributedCharacterIterator with the formatted number and
        /// attributes</returns>
        /// <exception cref="NullPointerException">when the object is null</exception>
        /// <exception cref="IllegalArgumentException">when the object cannot be formatted by this Format</exception>
        public override AttributedCharacterIterator FormatToCharacterIterator(Object obj0)
        {
            if (obj0 == null)
            {
                throw new NullReferenceException();
            }
            return dform.FormatToCharacterIterator(obj0);
        }

        /// <summary>
        /// Formats the double value into the specified StringBuffer using the
        /// pattern of this DecimalFormat. If the field specified by the
        /// FieldPosition is formatted, set the begin and end index of the formatted
        /// field in the FieldPosition.
        /// </summary>
        ///
        /// <param name="value">the double to format</param>
        /// <param name="buffer">the StringBuffer</param>
        /// <param name="position">the FieldPosition</param>
        /// <returns>the StringBuffer parameter <c>buffer</c></returns>
        public override StringBuilder Format(double value_ren, StringBuilder buffer,
                FieldPosition position)
        {
            return dform.Format(value_ren, buffer, position);
        }

        /// <summary>
        /// Formats the long value into the specified StringBuffer using the pattern
        /// of this DecimalFormat. If the field specified by the FieldPosition is
        /// formatted, set the begin and end index of the formatted field in the
        /// FieldPosition.
        /// </summary>
        ///
        /// <param name="value">the long to format</param>
        /// <param name="buffer">the StringBuffer</param>
        /// <param name="position">the FieldPosition</param>
        /// <returns>the StringBuffer parameter <c>buffer</c></returns>
        public override StringBuilder Format(long value_ren, StringBuilder buffer,
                FieldPosition position)
        {
            return dform.Format(value_ren, buffer, position);
        }

        /// <summary>
        /// Formats the number into the specified StringBuffer using the pattern of
        /// this DecimalFormat. If the field specified by the FieldPosition is
        /// formatted, set the begin and end index of the formatted field in the
        /// FieldPosition.
        /// </summary>
        ///
        /// <param name="number">the object to format</param>
        /// <param name="toAppendTo">the StringBuffer</param>
        /// <param name="pos">the FieldPosition</param>
        /// <returns>the StringBuffer parameter <c>buffer</c></returns>
        /// <exception cref="IllegalArgumentException">if the given number is not instance of <c>Number</c></exception>
        public sealed override StringBuilder FormatObject(Object number, StringBuilder toAppendTo,
                FieldPosition pos)
        {
            if (!(number is ValueType))
            {
                throw new ArgumentException();
            }
            if (toAppendTo == null || pos == null)
            {
                throw new NullReferenceException();
            }
            if (number is Int64 || number is Decimal)
            {
                return dform.FormatObject(number, toAppendTo, pos);
            }
            return base.FormatObject(number, toAppendTo, pos);
        }

        /// <summary>
        /// Answers the DecimalFormatSymbols used by this DecimalFormat.
        /// </summary>
        ///
        /// <returns>a DecimalFormatSymbols</returns>
        public DecimalFormatSymbols GetDecimalFormatSymbols()
        {
            return (DecimalFormatSymbols)symbols.Clone();
        }

        /// <summary>
        /// Answers the currency used by this decimal format.
        /// </summary>
        ///
        /// <returns>currency of DecimalFormatSymbols used by this decimal format</returns>
        /// <seealso cref="M:System.Globalization.NumberFormatInfo.GetCurrency"/>
        public override Currency GetCurrency()
        {
            IBM.ICU.Util.Currency cur = dform.GetCurrency();
            String code = (cur == null) ? "XXX" : cur.GetCurrencyCode(); //$NON-NLS-1$

            return IBM.ICU.Util.Currency.GetInstance(code);
        }

        /// <summary>
        /// Answers the number of digits grouped together by the grouping separator.
        /// </summary>
        ///
        /// <returns>the number of digits grouped together</returns>
        public int GetGroupingSize()
        {
            return dform.GetGroupingSize();
        }

        /// <summary>
        /// Answers the multiplier which is applied to the number before formatting
        /// or after parsing.
        /// </summary>
        ///
        /// <returns>the multiplier</returns>
        public int GetMultiplier()
        {
            return dform.GetMultiplier();
        }

        /// <summary>
        /// Answers the prefix which is formatted or parsed before a negative number.
        /// </summary>
        ///
        /// <returns>the negative prefix</returns>
        public String GetNegativePrefix()
        {
            return dform.GetNegativePrefix();
        }

        /// <summary>
        /// Answers the suffix which is formatted or parsed after a negative number.
        /// </summary>
        ///
        /// <returns>the negative suffix</returns>
        public String GetNegativeSuffix()
        {
            return dform.GetNegativeSuffix();
        }

        /// <summary>
        /// Answers the prefix which is formatted or parsed before a positive number.
        /// </summary>
        ///
        /// <returns>the positive prefix</returns>
        public String GetPositivePrefix()
        {
            return dform.GetPositivePrefix();
        }

        /// <summary>
        /// Answers the suffix which is formatted or parsed after a positive number.
        /// </summary>
        ///
        /// <returns>the positive suffix</returns>
        public String GetPositiveSuffix()
        {
            return dform.GetPositiveSuffix();
        }

        /// <summary>
        /// Answers an integer hash code for the receiver. Objects which are equal
        /// answer the same value for this method.
        /// </summary>
        ///
        /// <returns>the receiver's hash</returns>
        /// <seealso cref="M:ILOG.J2CsMapping.Text.DummyFormat.Equals(System.Object)"/>
        public override int GetHashCode()
        {
            return dform.GetHashCode();
        }

        /// <summary>
        /// Answers whether the decimal separator is shown when there are no
        /// fractional digits.
        /// </summary>
        ///
        /// <returns>true if the decimal separator should always be formatted, false
        /// otherwise</returns>
        public bool IsDecimalSeparatorAlwaysShown()
        {
            return dform.IsDecimalSeparatorAlwaysShown();
        }

        /// <summary>
        /// This value indicates whether the return object of the parse operation
        /// will be of type BigDecimal. This value will default to false.
        /// </summary>
        ///
        /// <returns>true and parse will always return BigDecimals, false and the type
        /// of the result will be Long or Double.</returns>
        public bool IsParseBigDecimal()
        {
            return this.parseBigDecimal;
        }

        /// <summary>
        /// When DecimalFormat is used to parsing, and this value is set to true,
        /// then all the resulting number will be of type
        /// <c>java.lang.Integer</c>. Except that, NaN, positive and
        /// negative infinity are still returned as <c>java.lang.Double</c>
        /// In this implementation, com.ibm.icu.text.DecimalFormat is wrapped to
        /// fulfill most of the format and parse feature. And this method is
        /// delegated to the wrapped instance of com.ibm.icu.text.DecimalFormat.
        /// </summary>
        ///
        /// <param name="value">If set to true, all the resulting number will be of typejava.lang.Integer except some special cases.</param>
        public override void SetParseIntegerOnly(bool value_ren)
        {
            dform.SetParseIntegerOnly(value_ren);
        }

        /// <summary>
        /// Returns true if this <c>DecimalFormat</c>'s all resulting number
        /// will be of type <c>java.lang.Integer</c>
        /// </summary>
        ///
        /// <returns>true if this <c>DecimalFormat</c>'s all resulting number
        /// will be of type <c>java.lang.Integer</c></returns>
        public override bool IsParseIntegerOnly()
        {
            return dform.IsParseIntegerOnly();
        }

        private static readonly Double NEGATIVE_ZERO_DOUBLE = (double)(-0.0d);

        /// <summary>
        /// Parse a Long or Double from the specified String starting at the index
        /// specified by the ParsePosition. If the string is successfully parsed, the
        /// index of the ParsePosition is updated to the index following the parsed
        /// text.
        /// </summary>
        ///
        /// <param name="string">the String to parse</param>
        /// <param name="position">the ParsePosition, updated on return with the index followingthe parsed text, or on error the index is unchanged and theerror index is set to the index where the error occurred</param>
        /// <returns>a Long or Double resulting from the parse, or null if there is an
        /// error. The result will be a Long if the parsed number is an
        /// integer in the range of a long, otherwise the result is a Double.</returns>
        public override object Parse(String str0, ParsePosition position)
        {
            object number = dform.Parse(str0, position);
            if (null == number)
            {
                return null;
            }
            if (this.IsParseBigDecimal())
            {
                if (number is Int64)
                {
                    return new Decimal(Convert.ToInt64(number));
                }
                if ((number is Double) && !Double.IsInfinity((double)((Double)number))
                        && !ILOG.J2CsMapping.Util.DoubleHelper.IsNaN(((Double)number)))
                {

                    return new Decimal(Convert.ToDouble(number));
                }
                if (number is Int64)
                {
                    return new Decimal(Convert.ToDouble(number));
                }
                if (number is IBM.ICU.Math.BigDecimal)
                {
                    return Decimal.Parse(number.ToString());
                }
                return number;
            }
            if ((number is IBM.ICU.Math.BigDecimal))
            {
                return ((IBM.ICU.Math.BigDecimal)number).DoubleValue();
            }
            /*
             *  TODO: Here Int64 is BigInteger ...
            if (number  is  Int64) {
                return (double) Convert.ToInt64(number);
            }*/

            if (this.IsParseIntegerOnly() && number.Equals(NEGATIVE_ZERO_DOUBLE))
            {
                return (long)(0);
            }
            return number;

        }

        /// <summary>
        /// Sets the DecimalFormatSymbols used by this DecimalFormat.
        /// </summary>
        ///
        /// <param name="value">the DecimalFormatSymbols</param>
        public void SetDecimalFormatSymbols(DecimalFormatSymbols value_ren)
        {
            if (value_ren != null)
            {
                symbols = (DecimalFormatSymbols)value_ren.Clone();
                icuSymbols = dform.GetDecimalFormatSymbols();
                CopySymbols(icuSymbols, symbols);
                dform.SetDecimalFormatSymbols(icuSymbols);
            }
        }

        /// <summary>
        /// Sets the currency used by this decimal format. The min and max fraction
        /// digits remain the same.
        /// </summary>
        ///
        /// <param name="currency"></param>
        /// <seealso cref="M:System.Globalization.NumberFormatInfo.SetCurrency(null)"/>
        public override void SetCurrency(Currency currency)
        {
            dform.SetCurrency(IBM.ICU.Util.Currency.GetInstance(currency
                    .GetCurrencyCode()));
            symbols.SetCurrency(currency);
        }

        /// <summary>
        /// Sets whether the decimal separator is shown when there are no fractional
        /// digits.
        /// </summary>
        ///
        /// <param name="value">true if the decimal separator should always be formatted,false otherwise</param>
        public void SetDecimalSeparatorAlwaysShown(bool value_ren)
        {
            dform.SetDecimalSeparatorAlwaysShown(value_ren);
        }

        /// <summary>
        /// Sets the number of digits grouped together by the grouping separator.
        /// </summary>
        ///
        /// <param name="value">the number of digits grouped together</param>
        public void SetGroupingSize(int value_ren)
        {
            dform.SetGroupingSize(value_ren);
        }

        /// <summary>
        /// Sets whether or not grouping will be used in this format. Grouping
        /// affects both parsing and formatting.
        /// </summary>
        ///
        /// <param name="value">true if uses grouping,false otherwise.</param>
        public override void SetGroupingUsed(bool value_ren)
        {
            dform.SetGroupingUsed(value_ren);
        }

        /// <summary>
        /// This value indicates whether grouping will be used in this format.
        /// </summary>
        ///
        /// <returns>true if grouping is used,false otherwise.</returns>
        public override bool IsGroupingUsed()
        {
            return dform.IsGroupingUsed();
        }

        /// <summary>
        /// Sets the maximum number of fraction digits that are printed when
        /// formatting. If the maximum is less than the number of fraction digits,
        /// the least significant digits are truncated. Limit the maximum to
        /// DOUBLE_FRACTION_DIGITS.
        /// </summary>
        ///
        /// <param name="value">the maximum number of fraction digits</param>
        public override void SetMaximumFractionDigits(int value_ren)
        {
            base.SetMaximumFractionDigits(value_ren);
            dform.SetMaximumFractionDigits(value_ren);
        }

        /// <summary>
        /// Sets the maximum number of integer digits that are printed when
        /// formatting. If the maximum is less than the number of integer digits, the
        /// most significant digits are truncated. Limit the maximum to
        /// DOUBLE_INTEGER_DIGITS.
        /// </summary>
        ///
        /// <param name="value">the maximum number of integer digits</param>
        public override void SetMaximumIntegerDigits(int value_ren)
        {
            base.SetMaximumIntegerDigits(value_ren);
            dform.SetMaximumIntegerDigits(value_ren);
        }

        /// <summary>
        /// Sets the minimum number of fraction digits that are printed when
        /// formatting. Limit the minimum to DOUBLE_FRACTION_DIGITS.
        /// </summary>
        ///
        /// <param name="value">the minimum number of fraction digits</param>
        public override void SetMinimumFractionDigits(int value_ren)
        {
            base.SetMinimumFractionDigits(value_ren);
            dform.SetMinimumFractionDigits(value_ren);
        }

        /// <summary>
        /// Sets the minimum number of integer digits that are printed when
        /// formatting. Limit the minimum to DOUBLE_INTEGER_DIGITS.
        /// </summary>
        ///
        /// <param name="value">the minimum number of integer digits</param>
        public override void SetMinimumIntegerDigits(int value_ren)
        {
            base.SetMinimumIntegerDigits(value_ren);
            dform.SetMinimumIntegerDigits(value_ren);
        }

        /// <summary>
        /// Sets the multiplier which is applied to the number before formatting or
        /// after parsing.
        /// </summary>
        ///
        /// <param name="value">the multiplier</param>
        public void SetMultiplier(int value_ren)
        {
            dform.SetMultiplier(value_ren);
        }

        /// <summary>
        /// Sets the prefix which is formatted or parsed before a negative number.
        /// </summary>
        ///
        /// <param name="value">the negative prefix</param>
        public void SetNegativePrefix(String value_ren)
        {
            dform.SetNegativePrefix(value_ren);
        }

        /// <summary>
        /// Sets the suffix which is formatted or parsed after a negative number.
        /// </summary>
        ///
        /// <param name="value">the negative suffix</param>
        public void SetNegativeSuffix(String value_ren)
        {
            dform.SetNegativeSuffix(value_ren);
        }

        /// <summary>
        /// Sets the prefix which is formatted or parsed before a positive number.
        /// </summary>
        ///
        /// <param name="value">the positive prefix</param>
        public void SetPositivePrefix(String value_ren)
        {
            dform.SetPositivePrefix(value_ren);
        }

        /// <summary>
        /// Sets the suffix which is formatted or parsed after a positive number.
        /// </summary>
        ///
        /// <param name="value">the positive suffix</param>
        public void SetPositiveSuffix(String value_ren)
        {
            dform.SetPositiveSuffix(value_ren);
        }

        /// <summary>
        /// Let users change the behavior of a DecimalFormat, If set to true all the
        /// returned objects will be of type BigDecimal
        /// </summary>
        ///
        /// <param name="newValue">true if all the returned objects should be type of BigDecimal</param>
        public void SetParseBigDecimal(bool newValue)
        {
            this.parseBigDecimal = newValue;
        }

        /// <summary>
        /// Answers the pattern of this DecimalFormat using localized pattern
        /// characters.
        /// </summary>
        ///
        /// <returns>the localized pattern</returns>
        public String ToLocalizedPattern()
        {
            return dform.ToLocalizedPattern();
        }

        /// <summary>
        /// Answers the pattern of this DecimalFormat using non-localized pattern
        /// characters.
        /// </summary>
        ///
        /// <returns>the non-localized pattern</returns>
        public String ToPattern()
        {
            return dform.ToPattern();
        }

        // the fields list to be serialized
        /*private static readonly ObjectStreamField[] serialPersistentFields = {
                new ObjectStreamField("positivePrefix", typeof(String)), //$NON-NLS-1$
                new ObjectStreamField("positiveSuffix", typeof(String)), //$NON-NLS-1$
                new ObjectStreamField("negativePrefix", typeof(String)), //$NON-NLS-1$
                new ObjectStreamField("negativeSuffix", typeof(String)), //$NON-NLS-1$
                new ObjectStreamField("posPrefixPattern", typeof(String)), //$NON-NLS-1$
                new ObjectStreamField("posSuffixPattern", typeof(String)), //$NON-NLS-1$
                new ObjectStreamField("negPrefixPattern", typeof(String)), //$NON-NLS-1$
                new ObjectStreamField("negSuffixPattern", typeof(String)), //$NON-NLS-1$
                new ObjectStreamField("multiplier", typeof(int)), //$NON-NLS-1$
                new ObjectStreamField("groupingSize", typeof(byte)), //$NON-NLS-1$
                new ObjectStreamField("decimalSeparatorAlwaysShown", typeof(bool)), //$NON-NLS-1$
                new ObjectStreamField("parseBigDecimal", typeof(bool)), //$NON-NLS-1$
                new ObjectStreamField("symbols", typeof(NumberFormatInfo)), //$NON-NLS-1$
                new ObjectStreamField("useExponentialNotation", typeof(bool)), //$NON-NLS-1$
                new ObjectStreamField("minExponentDigits", typeof(byte)), //$NON-NLS-1$
                new ObjectStreamField("maximumIntegerDigits", typeof(int)), //$NON-NLS-1$
                new ObjectStreamField("minimumIntegerDigits", typeof(int)), //$NON-NLS-1$
                new ObjectStreamField("maximumFractionDigits", typeof(int)), //$NON-NLS-1$
                new ObjectStreamField("minimumFractionDigits", typeof(int)), //$NON-NLS-1$
                new ObjectStreamField("serialVersionOnStream", typeof(int)), }; //$NON-NLS-1$*/

        /// <summary>
        /// Writes serialized fields following serialized forms specified by Java
        /// specification.
        /// </summary>
        ///
        /// <param name="stream">the output stream to write serialized bytes</param>
        /// <exception cref="IOException">if some I/O error occurs</exception>
        /// <exception cref="ClassNotFoundException"></exception>
        /* @SuppressWarnings("nls")*/
        private void WriteObject(IlObjectOutputStream stream)
        {
            /*ObjectOutputStream.PutField fields = stream.PutFields();
            fields.Put("positivePrefix", dform.GetPositivePrefix());
            fields.Put("positiveSuffix", dform.GetPositiveSuffix());
            fields.Put("negativePrefix", dform.GetNegativePrefix());
            fields.Put("negativeSuffix", dform.GetNegativeSuffix());
            String posPrefixPattern = (String) ILOG.J2CsMapping.Text.IlFormat.GetInternalField(
                    "posPrefixPattern", dform);
            fields.Put("posPrefixPattern", posPrefixPattern);
            String posSuffixPattern = (String) ILOG.J2CsMapping.Text.IlFormat.GetInternalField(
                    "posSuffixPattern", dform);
            fields.Put("posSuffixPattern", posSuffixPattern);
            String negPrefixPattern = (String) ILOG.J2CsMapping.Text.IlFormat.GetInternalField(
                    "negPrefixPattern", dform);
            fields.Put("negPrefixPattern", negPrefixPattern);
            String negSuffixPattern = (String) ILOG.J2CsMapping.Text.IlFormat.GetInternalField(
                    "negSuffixPattern", dform);
            fields.Put("negSuffixPattern", negSuffixPattern);
            fields.Put("multiplier", dform.GetMultiplier());
            fields.Put("groupingSize", (byte) dform.GetGroupingSize());
            fields.Put("decimalSeparatorAlwaysShown",
                    dform.IsDecimalSeparatorAlwaysShown());
            fields.Put("parseBigDecimal", parseBigDecimal);
            fields.Put("symbols", symbols);
            bool useExponentialNotation = (bool)(((Boolean) ILOG.J2CsMapping.Text.IlFormat.GetInternalField(
                            "useExponentialNotation", dform)));
            fields.Put("useExponentialNotation", useExponentialNotation);
            byte minExponentDigits = ((Byte) ILOG.J2CsMapping.Text.IlFormat.GetInternalField(
                            "minExponentDigits", dform));
            fields.Put("minExponentDigits", minExponentDigits);
            fields.Put("maximumIntegerDigits", dform.GetMaximumIntegerDigits());
            fields.Put("minimumIntegerDigits", dform.GetMinimumIntegerDigits());
            fields.Put("maximumFractionDigits", dform.GetMaximumFractionDigits());
            fields.Put("minimumFractionDigits", dform.GetMinimumFractionDigits());
            fields.Put("serialVersionOnStream", CURRENT_SERIAL_VERTION);
            stream.WriteFields();*/
        }

        /// <summary>
        /// Reads serialized fields following serialized forms specified by Java
        /// specification.
        /// </summary>
        ///
        /// <param name="stream">the input stream to read serialized bytes</param>
        /// <exception cref="IOException">if some I/O error occurs</exception>
        /// <exception cref="ClassNotFoundException">if some class of serialized objects or fields cannot be found</exception>
        /* @SuppressWarnings("nls")*/
        private void ReadObject(IlObjectInputStream stream)
        {
            /*
                    ObjectInputStream.GetField fields = stream.ReadFields();
                    String positivePrefix = (String) fields.Get("positivePrefix", "");
                    String positiveSuffix = (String) fields.Get("positiveSuffix", "");
                    String negativePrefix = (String) fields.Get("negativePrefix", "-");
                    String negativeSuffix = (String) fields.Get("negativeSuffix", "");
	
                    String posPrefixPattern = (String) fields.Get("posPrefixPattern", "");
                    String posSuffixPattern = (String) fields.Get("posSuffixPattern", "");
                    String negPrefixPattern = (String) fields.Get("negPrefixPattern", "-");
                    String negSuffixPattern = (String) fields.Get("negSuffixPattern", "");
	
                    int multiplier = fields.Get("multiplier", 1);
                    byte groupingSize = fields.Get("groupingSize", (byte) 3);
                    bool decimalSeparatorAlwaysShown = fields.Get(
                            "decimalSeparatorAlwaysShown", false);
                    bool parseBigDecimal_0 = fields.Get("parseBigDecimal", false);
                    symbols = (NumberFormatInfo) fields.Get("symbols", null);
	
                    bool useExponentialNotation = fields.Get("useExponentialNotation",
                            false);
                    byte minExponentDigits = fields.Get("minExponentDigits", (byte) 0);
	
                    int maximumIntegerDigits = fields.Get("maximumIntegerDigits", 309);
                    int minimumIntegerDigits = fields.Get("minimumIntegerDigits", 309);
                    int maximumFractionDigits = fields.Get("maximumFractionDigits", 340);
                    int minimumFractionDigits = fields.Get("minimumFractionDigits", 340);
                    this.serialVersionOnStream = fields.Get("serialVersionOnStream", 0);
	
                    CultureInfo locale = (CultureInfo) ILOG.J2CsMapping.Text.IlFormat.GetInternalField("locale", symbols);
                    dform = new Com.Ibm.Icu.Text.DecimalFormat("",
                            new Com.Ibm.Icu.Text.DecimalFormatSymbols(locale));
                    SetInternalField("useExponentialNotation", dform,
                            useExponentialNotation);
                    SetInternalField("minExponentDigits", dform,
                            (byte )(minExponentDigits));
                    dform.SetPositivePrefix(positivePrefix);
                    dform.SetPositiveSuffix(positiveSuffix);
                    dform.SetNegativePrefix(negativePrefix);
                    dform.SetNegativeSuffix(negativeSuffix);
                    SetInternalField("posPrefixPattern", dform, posPrefixPattern);
                    SetInternalField("posSuffixPattern", dform, posSuffixPattern);
                    SetInternalField("negPrefixPattern", dform, negPrefixPattern);
                    SetInternalField("negSuffixPattern", dform, negSuffixPattern);
                    dform.SetMultiplier(multiplier);
                    dform.SetGroupingSize(groupingSize);
                    dform.SetDecimalSeparatorAlwaysShown(decimalSeparatorAlwaysShown);
                    dform.SetMinimumIntegerDigits(minimumIntegerDigits);
                    dform.SetMaximumIntegerDigits(maximumIntegerDigits);
                    dform.SetMinimumFractionDigits(minimumFractionDigits);
                    dform.SetMaximumFractionDigits(maximumFractionDigits);
                    this.SetParseBigDecimal(parseBigDecimal_0);
	
                    if (serialVersionOnStream < 3) {
                        SetMaximumIntegerDigits(base.GetMaximumIntegerDigits());
                        SetMinimumIntegerDigits(base.GetMinimumIntegerDigits());
                        SetMaximumFractionDigits(base.GetMaximumFractionDigits());
                        SetMinimumFractionDigits(base.GetMinimumFractionDigits());
                    }
                    if (serialVersionOnStream < 1) {
                        this.SetInternalField("useExponentialNotation", dform,
                                false);
                    }
                    serialVersionOnStream = 3;*/
        }

        /*
         * Copies decimal format symbols from text object to ICU one.
         * 
         * @param icu the object which receives the new values. @param dfs the
         * object which contains the new values.
         */
        private void CopySymbols(IBM.ICU.Text.DecimalFormatSymbols icu,
                DecimalFormatSymbols dfs)
        {
            Currency currency = dfs.GetCurrency();
            if (currency == null)
            {
                icu.SetCurrency(IBM.ICU.Util.Currency.GetInstance("XXX"));
            }
            else
            {
                icu.SetCurrency(IBM.ICU.Util.Currency.GetInstance(dfs
                        .GetCurrency().GetCurrencyCode()));
            }

            icu.SetCurrencySymbol(dfs.GetCurrencySymbol());
            //icu.SetDecimalSeparator(dfs.NumberDecimalSeparator[0]);
            icu.SetDigit(dfs.GetDigit());
            //icu.SetGroupingSeparator(dfs.NumberGroupSeparator[0]);
            icu.SetInfinity(dfs.GetInfinity());
            icu.SetInternationalCurrencySymbol(dfs.GetInternationalCurrencySymbol());
            icu.SetMinusSign(dfs.GetMinusSign());
            icu.SetMonetaryDecimalSeparator(dfs.GetMonetaryDecimalSeparator());
            icu.SetNaN(dfs.GetNaN());
            icu.SetPatternSeparator(dfs.GetPatternSeparator());
            icu.SetPercent(dfs.GetPercent());
            icu.SetPerMill(dfs.GetPerMill());
            icu.SetZeroDigit(dfs.GetZeroDigit());
        }

        /*
         * Sets private field value by reflection.
         * 
         * @param fieldName the field name to be set @param target the object which
         * field to be set @param value the value to be set
         */
        private void SetInternalField(String fieldName_0, Object target_1,
                Object value_ren)
        {
            new DecimalFormat.Anonymous_C0(target_1, value_ren, fieldName_0).Run();
        }
    }
}
