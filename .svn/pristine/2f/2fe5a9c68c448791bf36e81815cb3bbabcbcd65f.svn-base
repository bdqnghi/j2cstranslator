// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/13/10 4:01 PM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2000-2005, International Business Machines Corporation and    
/// others. All Rights Reserved.                                                
/// </summary>
///
namespace IBM.ICU.Charset
{

    using IBM.ICU.Text;
    using IBM.ICU.Util;
    using ILOG.J2CsMapping.IO;
    using ILOG.J2CsMapping.Util;
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.Globalization;
    using System.IO;
    using System.Runtime.CompilerServices;
    using ILOG.J2CsMapping.Text;
    using NUnit.Framework;

    [TestFixture]
    public class CompatibilityTest : IBM.ICU.Charset.TestFmwk
    {

        public static void Main(String[] argv)
        {
            new CompatibilityTest().Run(argv);
        }

        static internal readonly String[] FIELD_NAME = { "ERA", "YEAR", "MONTH",
	            "WEEK_OF_YEAR", "WEEK_OF_MONTH", "DAY_OF_MONTH", "DAY_OF_YEAR",
	            "DAY_OF_WEEK", "DAY_OF_WEEK_IN_MONTH", "AM_PM", "HOUR",
	            "HOUR_OF_DAY", "MINUTE", "SECOND", "MILLISECOND", "ZONE_OFFSET",
	            "DST_OFFSET", "YEAR_WOY", "DOW_LOCAL", "EXTENDED_YEAR",
	            "JULIAN_DAY", "MILLISECONDS_IN_DAY", };

        /// <summary>
        /// Test the behavior of the GregorianCalendar around the changeover.
        /// </summary>
        [Test]
        public void TestGregorianChangeover()
        {

            IBM.ICU.Util.TimeZone jdkGMT = IBM.ICU.Util.TimeZone.GetTimeZone("GMT");
            IBM.ICU.Util.Calendar jdkCal = IBM.ICU.Util.Calendar.GetInstance(jdkGMT);
            jdkCal.Clear();
            jdkCal.Set(1582, IBM.ICU.Util.Calendar.OCTOBER, 15);

            // if(jdkCal instanceof java.util.GregorianCalendar) {
            // logln("jdk IS grego");
            // java.util.GregorianCalendar jdkgc = (java.util.GregorianCalendar)
            // jdkCal;
            // logln("jdk change at: " + jdkgc.getGregorianChange() + "(" +
            // jdkgc.getGregorianChange().getTime() +")" );
            // } else {
            // logln("jdk NOT grego");
            // }

            long a = DateUtil.DotNetDateToJavaMillis(jdkCal.GetTime());
            DateTime c = jdkCal.GetTime();
            c.ToString();
            long b = DateUtil.DotNetDateToJavaMillis(c);
            if (a != b)
            {
                Logln(" " + a + " != " + b);
                Logln("JDK has Gregorian cutover anomaly (1.5?) - skipping this test.");
                return;
            }

            DateTime co = jdkCal.GetTime();
            Logln("Change over (Oct 15 1582) = " + co + " (" + DateUtil.DotNetDateToJavaMillis(co) + ")");
            int ONE_DAY = 24 * 60 * 60 * 1000;
            IBM.ICU.Util.TimeZone gmt = IBM.ICU.Util.TimeZone.GetTimeZone("GMT");
            IBM.ICU.Util.GregorianCalendar cal = new IBM.ICU.Util.GregorianCalendar(gmt);
            int[] MON = { 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10 };
            int[] DOM = { 28, 29, 30, 1, 2, 3, 4, 15, 16, 17, 18, 19, 20, 21, 22 };
            int[] DOW = { 6, 7, 1, 2, 3, 4, 5, 6, 7, 1, 2, 3, 4, 5, 6 };
            // ^ <-Changeover Fri Oct 15 1582
            int j = 0;
            for (int i = -7; i <= 7; ++i, ++j)
            {
                DateTime d = DateUtil.DateFromJavaMillis((DateUtil.DotNetDateToJavaMillis(co) + i * ONE_DAY));
                cal.SetTime(d);
                int y = cal.Get(IBM.ICU.Util.Calendar.YEAR), mon = cal.Get(IBM.ICU.Util.Calendar.MONTH) + 1
                        - IBM.ICU.Util.Calendar.JANUARY, dom = cal.Get(IBM.ICU.Util.Calendar.DATE), dow = cal
                        .Get(IBM.ICU.Util.Calendar.DAY_OF_WEEK);
                Logln("Changeover " + ((i >= 0) ? "+" : "") + i + " days: " + y + "/"
                        + mon + "/" + dom + " dow=" + dow);
                if (y != 1582 || mon != MON[j] || dom != DOM[j] || dow != DOW[j])
                    Errln(" Fail: Above line is wrong");
            }
        }

        /// <summary>
        /// Test the mapping between millis and fields. For the purposes of this
        /// test, we don't care about timezones and week data (first day of week,
        /// minimal days in first week).
        /// </summary>
        [Test]
        public void TestMapping()
        {
            if (false)
            {
                DateTime PURE_GREGORIAN = DateUtil.DateFromJavaMillis((Int64.MinValue));
                DateTime PURE_JULIAN = DateUtil.DateFromJavaMillis((Int64.MaxValue));
                IBM.ICU.Util.GregorianCalendar cal = new IBM.ICU.Util.GregorianCalendar(
                        IBM.ICU.Util.TimeZone.GetTimeZone("UTC"));
                int EPOCH_JULIAN = 2440588;
                long ONE_DAY = 24 * 60 * 60 * 1000L;
                IBM.ICU.Text.SimpleDateFormat fmt = new IBM.ICU.Text.SimpleDateFormat(
                        "EEE MMM dd yyyy G");
                /* HH:mm:ss.SSS z */

                for (int type = 0; type < 2; ++type)
                {
                    System.Console.Out.WriteLine((type == 0) ? "Gregorian" : "Julian");
                    cal.SetGregorianChange((type == 0) ? PURE_GREGORIAN : PURE_JULIAN);
                    fmt.SetCalendar(cal);
                    int[] J = { 0x7FFFFFFF, 0x7FFFFFF0, 0x7F000000, 0x78000000,
	                        0x70000000, 0x60000000, 0x50000000, 0x40000000,
	                        0x30000000, 0x20000000, 0x10000000, };
                    for (int i = 0; i < J.Length; ++i)
                    {
                        String[] lim = new String[2];
                        long[] ms = new long[2];
                        int jd = J[i];
                        for (int sign = 0; sign < 2; ++sign)
                        {
                            int julian = jd;
                            if (sign == 0)
                                julian = -julian;
                            long millis = ((long)julian - EPOCH_JULIAN) * ONE_DAY;
                            ms[sign] = millis;
                            cal.SetTime(DateUtil.DateFromJavaMillis(millis));
                            lim[sign] = fmt.Format(cal.GetTime());
                        }
                        System.Console.Out.WriteLine("JD +/-" + jd /* hex ? */ + ": "
                                + ms[0] + ".." + ms[1] + ": " + lim[0] + ".."
                                + lim[1]);
                    }
                }
            }

            IBM.ICU.Util.TimeZone saveZone = IBM.ICU.Util.TimeZone.GetDefault();
            try
            {
                IBM.ICU.Util.TimeZone.SetDefault(IBM.ICU.Util.TimeZone.GetTimeZone("UTC"));
                // NEWCAL
                DateTime PURE_GREGORIAN_0 = DateUtil.DateFromJavaMillis((Int64.MinValue));
                DateTime PURE_JULIAN_1 = DateUtil.DateFromJavaMillis((Int64.MaxValue));
                IBM.ICU.Util.GregorianCalendar cal_2 = new IBM.ICU.Util.GregorianCalendar();
                int EPOCH_JULIAN_3 = 2440588;
                long ONE_DAY_4 = 24 * 60 * 60 * 1000L;
                int[] DATA = {
	                    // Julian# Year Month DOM JULIAN:Year, Month, DOM
	                    2440588, 1970, IBM.ICU.Util.Calendar.JANUARY, 1, 1969,
	                    IBM.ICU.Util.Calendar.DECEMBER, 19, 2415080, 1900, IBM.ICU.Util.Calendar.MARCH, 1,
	                    1900, IBM.ICU.Util.Calendar.FEBRUARY, 17, 2451604, 2000,
	                    IBM.ICU.Util.Calendar.FEBRUARY, 29, 2000, IBM.ICU.Util.Calendar.FEBRUARY, 16,
	                    2452269, 2001, IBM.ICU.Util.Calendar.DECEMBER, 25, 2001,
	                    IBM.ICU.Util.Calendar.DECEMBER, 12, 2416526, 1904, IBM.ICU.Util.Calendar.FEBRUARY,
	                    15, 1904, IBM.ICU.Util.Calendar.FEBRUARY, 2, 2416656, 1904,
	                    IBM.ICU.Util.Calendar.JUNE, 24, 1904, IBM.ICU.Util.Calendar.JUNE, 11, 1721426, 1,
	                    IBM.ICU.Util.Calendar.JANUARY, 1, 1, IBM.ICU.Util.Calendar.JANUARY, 3, 2000000, 763,
	                    IBM.ICU.Util.Calendar.SEPTEMBER, 18, 763, IBM.ICU.Util.Calendar.SEPTEMBER, 14,
	                    4000000, 6239, IBM.ICU.Util.Calendar.JULY, 12, 6239, IBM.ICU.Util.Calendar.MAY, 28,
	                    8000000, 17191, IBM.ICU.Util.Calendar.FEBRUARY, 26, 17190,
	                    IBM.ICU.Util.Calendar.OCTOBER, 22, 10000000, 22666, IBM.ICU.Util.Calendar.DECEMBER,
	                    20, 22666, IBM.ICU.Util.Calendar.JULY, 5, };
                for (int i_5 = 0; i_5 < DATA.Length; i_5 += 7)
                {
                    int julian_6 = DATA[i_5];
                    int year = DATA[i_5 + 1];
                    int month = DATA[i_5 + 2];
                    int dom = DATA[i_5 + 3];
                    int year2, month2, dom2;
                    long millis_7 = (julian_6 - EPOCH_JULIAN_3) * ONE_DAY_4;
                    String s;

                    // Test Gregorian computation
                    cal_2.SetGregorianChange(PURE_GREGORIAN_0);
                    cal_2.Clear();
                    cal_2.Set(year, month, dom);
                    long calMillis = DateUtil.DotNetDateToJavaMillis(cal_2.GetTime());
                    long delta = calMillis - millis_7;
                    cal_2.SetTime(DateUtil.DateFromJavaMillis((millis_7)));
                    year2 = cal_2.Get(IBM.ICU.Util.Calendar.YEAR);
                    month2 = cal_2.Get(IBM.ICU.Util.Calendar.MONTH);
                    dom2 = cal_2.Get(IBM.ICU.Util.Calendar.DAY_OF_MONTH);
                    s = "G " + year + "-" + (month + 1 - IBM.ICU.Util.Calendar.JANUARY) + "-"
                            + dom + " => " + calMillis + " ("
                            + ((float)delta / ONE_DAY_4) + " day delta) => " + year2
                            + "-" + (month2 + 1 - IBM.ICU.Util.Calendar.JANUARY) + "-" + dom2;
                    if (delta != 0 || year != year2 || month != month2
                            || dom != dom2)
                        Errln(s + " FAIL");
                    else
                        Logln(s);

                    // Test Julian computation
                    year = DATA[i_5 + 4];
                    month = DATA[i_5 + 5];
                    dom = DATA[i_5 + 6];
                    cal_2.SetGregorianChange(PURE_JULIAN_1);
                    cal_2.Clear();
                    cal_2.Set(year, month, dom);
                    calMillis = DateUtil.DotNetDateToJavaMillis(cal_2.GetTime());
                    delta = calMillis - millis_7;
                    cal_2.SetTime(DateUtil.DateFromJavaMillis(millis_7));
                    year2 = cal_2.Get(IBM.ICU.Util.Calendar.YEAR);
                    month2 = cal_2.Get(IBM.ICU.Util.Calendar.MONTH);
                    dom2 = cal_2.Get(IBM.ICU.Util.Calendar.DAY_OF_MONTH);
                    s = "J " + year + "-" + (month + 1 - IBM.ICU.Util.Calendar.JANUARY) + "-"
                            + dom + " => " + calMillis + " ("
                            + ((float)delta / ONE_DAY_4) + " day delta) => " + year2
                            + "-" + (month2 + 1 - IBM.ICU.Util.Calendar.JANUARY) + "-" + dom2;
                    if (delta != 0 || year != year2 || month != month2
                            || dom != dom2)
                        Errln(s + " FAIL");
                    else
                        Logln(s);
                }

                IBM.ICU.Util.Calendar tempcal = IBM.ICU.Util.Calendar.GetInstance();
                tempcal.Clear();
                tempcal.Set(1582, IBM.ICU.Util.Calendar.OCTOBER, 15);
                cal_2.SetGregorianChange(tempcal.GetTime());
                AuxMapping(cal_2, 1582, IBM.ICU.Util.Calendar.OCTOBER, 4);
                AuxMapping(cal_2, 1582, IBM.ICU.Util.Calendar.OCTOBER, 15);
                AuxMapping(cal_2, 1582, IBM.ICU.Util.Calendar.OCTOBER, 16);
                for (int y = 800; y < 3000; y += 1 + (int)(100 * (new Random()).Next()))
                {
                    for (int m = IBM.ICU.Util.Calendar.JANUARY; m <= IBM.ICU.Util.Calendar.DECEMBER; ++m)
                    {
                        AuxMapping(cal_2, y, m, 15);
                    }
                }
            }
            finally
            {
                IBM.ICU.Util.TimeZone.SetDefault(saveZone);
            }
        }

        private void AuxMapping(IBM.ICU.Util.Calendar cal, int y, int m, int d)
        {
            cal.Clear();
            cal.Set(y, m, d);
            long millis = (cal.GetTime().Ticks / 10000);
            cal.SetTime(DateUtil.DateFromJavaMillis(millis));
            int year2 = cal.Get(IBM.ICU.Util.Calendar.YEAR);
            int month2 = cal.Get(IBM.ICU.Util.Calendar.MONTH);
            int dom2 = cal.Get(IBM.ICU.Util.Calendar.DAY_OF_MONTH);
            if (y != year2 || m != month2 || dom2 != d)
                Errln("Round-trip failure: " + y + "-" + (m + 1) + "-" + d
                        + " =>ms=> " + year2 + "-" + (month2 + 1) + "-" + dom2);
        }

        [Test]
        public void TestGenericAPI()
        {
            // not used String str;

            IBM.ICU.Util.Calendar tempcal = IBM.ICU.Util.Calendar.GetInstance();
            tempcal.Clear();
            tempcal.Set(1990, IBM.ICU.Util.Calendar.APRIL, 15);
            DateTime when = tempcal.GetTime();

            String tzid = "TestZone";
            int tzoffset = 123400;

            SimpleTimeZone zone = new SimpleTimeZone(tzoffset, tzid);
            IBM.ICU.Util.Calendar cal = (IBM.ICU.Util.Calendar)IBM.ICU.Util.Calendar.GetInstance((SimpleTimeZone)zone
                    .Clone());

            if (!zone.Equals(cal.GetTimeZone()))
                Errln("FAIL: Calendar.getTimeZone failed");

            IBM.ICU.Util.Calendar cal2 = IBM.ICU.Util.Calendar.GetInstance(cal.GetTimeZone());

            cal.SetTime(when);
            cal2.SetTime(when);

            if (!(cal.Equals(cal2)))
                Errln("FAIL: Calendar.operator== failed");
            // if ((*cal != *cal2)) errln("FAIL: Calendar.operator!= failed");
            if (!cal.Equals(cal2) || cal.Before(cal2) || cal.After(cal2))
                Errln("FAIL: equals/before/after failed");

            cal2.SetTime(DateUtil.DateFromJavaMillis((DateUtil.DotNetDateToJavaMillis(when) + 1000)));
            if (cal.Equals(cal2) || cal2.Before(cal) || cal.After(cal2))
                Errln("FAIL: equals/before/after failed");

            cal.Roll(IBM.ICU.Util.Calendar.SECOND, true);
            if (!cal.Equals(cal2) || cal.Before(cal2) || cal.After(cal2))
                Errln("FAIL: equals/before/after failed");

            // Roll back to January
            cal.Roll(IBM.ICU.Util.Calendar.MONTH,
                    (int)(1 + IBM.ICU.Util.Calendar.DECEMBER - cal.Get(IBM.ICU.Util.Calendar.MONTH)));
            if (cal.Equals(cal2) || cal2.Before(cal) || cal.After(cal2))
                Errln("FAIL: equals/before/after failed");

            // C++ only
            /*
             * TimeZone z = cal.orphanTimeZone(); if (z.getID(str) != tzid ||
             * z.getRawOffset() != tzoffset) errln("FAIL: orphanTimeZone failed");
             */

            for (int i = 0; i < 2; ++i)
            {
                bool lenient = (i > 0);
                cal.SetLenient(lenient);
                if (lenient != cal.IsLenient())
                    Errln("FAIL: setLenient/isLenient failed");
                // Later: Check for lenient behavior
            }

            int i_0;
            for (i_0 = IBM.ICU.Util.Calendar.SUNDAY; i_0 <= IBM.ICU.Util.Calendar.SATURDAY; ++i_0)
            {
                cal.SetFirstDayOfWeek(i_0);
                if (cal.GetFirstDayOfWeek() != i_0)
                    Errln("FAIL: set/getFirstDayOfWeek failed");
            }

            for (i_0 = 1; i_0 <= 7; ++i_0)
            {
                cal.SetMinimalDaysInFirstWeek(i_0);
                if (cal.GetMinimalDaysInFirstWeek() != i_0)
                    Errln("FAIL: set/getFirstDayOfWeek failed");
            }

            for (i_0 = 0; i_0 < cal.GetFieldCount(); ++i_0)
            {
                if (cal.GetMinimum(i_0) != cal.GetGreatestMinimum(i_0))
                    Errln("FAIL: getMinimum doesn't match getGreatestMinimum for field "
                            + i_0);
                if (cal.GetLeastMaximum(i_0) > cal.GetMaximum(i_0))
                    Errln("FAIL: getLeastMaximum larger than getMaximum for field "
                            + i_0);
                if (cal.GetMinimum(i_0) >= cal.GetMaximum(i_0))
                    Errln("FAIL: getMinimum not less than getMaximum for field "
                            + i_0);
            }

            cal.SetTimeZone(IBM.ICU.Util.TimeZone.GetDefault());
            cal.Clear();
            cal.Set(1984, 5, 24);
            tempcal.Clear();
            tempcal.Set(1984, 5, 24);
            if ((cal.GetTime().Ticks / 10000) != (tempcal.GetTime().Ticks / 10000))
            {
                Errln("FAIL: Calendar.set(3 args) failed");
                Logln(" Got: " + cal.GetTime() + "  Expected: " + tempcal.GetTime());
            }

            cal.Clear();
            cal.Set(1985, 3, 2, 11, 49);
            tempcal.Clear();
            tempcal.Set(1985, 3, 2, 11, 49);
            if ((cal.GetTime().Ticks / 10000) != (tempcal.GetTime().Ticks / 10000))
            {
                Errln("FAIL: Calendar.set(5 args) failed");
                Logln(" Got: " + cal.GetTime() + "  Expected: " + tempcal.GetTime());
            }

            cal.Clear();
            cal.Set(1995, 9, 12, 1, 39, 55);
            tempcal.Clear();
            tempcal.Set(1995, 9, 12, 1, 39, 55);
            if ((cal.GetTime().Ticks / 10000) != (tempcal.GetTime().Ticks / 10000))
            {
                Errln("FAIL: Calendar.set(6 args) failed");
                Logln(" Got: " + cal.GetTime() + "  Expected: " + tempcal.GetTime());
            }

            cal.GetTime();
            // This test is strange -- why do we expect certain fields to be set,
            // and
            // others not to be? Revisit the appropriateness of this. - Alan NEWCAL
            for (i_0 = 0; i_0 < cal.GetFieldCount(); ++i_0)
            {
                switch (i_0)
                {
                    case IBM.ICU.Util.Calendar.YEAR:
                    case IBM.ICU.Util.Calendar.MONTH:
                    case IBM.ICU.Util.Calendar.DATE:
                    case IBM.ICU.Util.Calendar.HOUR_OF_DAY:
                    case IBM.ICU.Util.Calendar.MINUTE:
                    case IBM.ICU.Util.Calendar.SECOND:
                    case IBM.ICU.Util.Calendar.EXTENDED_YEAR:
                        if (!cal.IsSet(i_0))
                            Errln("FAIL: " + FIELD_NAME[i_0] + " is not set");
                        break;
                    default:
                        if (cal.IsSet(i_0))
                            Errln("FAIL: " + FIELD_NAME[i_0] + " is set");
                        break;
                }
                cal.Clear(i_0);
                if (cal.IsSet(i_0))
                    Errln("FAIL: Calendar.clear/isSet failed");
            }

            // delete cal;
            // delete cal2;

            ILOG.J2CsMapping.Util.Locale[] loc = IBM.ICU.Util.Calendar.GetAvailableLocales();
            long count = loc.Length;
            if (count < 1 || loc == null)
            {
                Errln("FAIL: getAvailableLocales failed");
            }
            else
            {
                for (i_0 = 0; i_0 < count; ++i_0)
                {
                    cal = IBM.ICU.Util.Calendar.GetInstance(loc[i_0]);
                    // delete cal;
                }
            }

            cal = IBM.ICU.Util.Calendar.GetInstance(IBM.ICU.Util.TimeZone.GetDefault(), new Locale("en"));
            // delete cal;

            cal = IBM.ICU.Util.Calendar.GetInstance(zone, new Locale("en"));
            // delete cal;

            IBM.ICU.Util.GregorianCalendar gc = new IBM.ICU.Util.GregorianCalendar(zone);
            // delete gc;

            gc = new IBM.ICU.Util.GregorianCalendar(new Locale("en"));
            // delete gc;

            gc = new IBM.ICU.Util.GregorianCalendar(new Locale("en"));
            // delete gc;

            gc = new IBM.ICU.Util.GregorianCalendar(zone, new Locale("en"));
            // delete gc;

            gc = new IBM.ICU.Util.GregorianCalendar(zone);
            // delete gc;

            gc = new IBM.ICU.Util.GregorianCalendar(1998, 10, 14, 21, 43);
            tempcal.Clear();
            tempcal.Set(1998, 10, 14, 21, 43);
            if ((gc.GetTime().Ticks / 10000) != (tempcal.GetTime().Ticks / 10000))
                Errln("FAIL: new GregorianCalendar(ymdhm) failed");
            // delete gc;

            gc = new IBM.ICU.Util.GregorianCalendar(1998, 10, 14, 21, 43, 55);
            tempcal.Clear();
            tempcal.Set(1998, 10, 14, 21, 43, 55);
            if ((gc.GetTime().Ticks / 10000) != (tempcal.GetTime().Ticks / 10000))
                Errln("FAIL: new GregorianCalendar(ymdhms) failed");

            // C++ only:
            // GregorianCalendar gc2 = new GregorianCalendar(Locale.ENGLISH);
            // gc2 = gc;
            // if (gc2 != gc || !(gc2 == gc))
            // errln("FAIL: GregorianCalendar assignment/operator==/operator!= failed");
            // delete gc;
            // delete z;
        }

        // Verify Roger Webster's bug
        [Test]
        public void TestRog()
        {
            IBM.ICU.Util.GregorianCalendar gc = new IBM.ICU.Util.GregorianCalendar();

            int year = 1997, month = IBM.ICU.Util.Calendar.APRIL, date = 1;
            gc.Set(year, month, date); // April 1, 1997

            gc.Set(IBM.ICU.Util.Calendar.HOUR_OF_DAY, 23);
            gc.Set(IBM.ICU.Util.Calendar.MINUTE, 0);
            gc.Set(IBM.ICU.Util.Calendar.SECOND, 0);
            gc.Set(IBM.ICU.Util.Calendar.MILLISECOND, 0);

            for (int i = 0; i < 9; i++, gc.Add(IBM.ICU.Util.Calendar.DATE, 1))
            {
                if (gc.Get(IBM.ICU.Util.Calendar.YEAR) != year
                        || gc.Get(IBM.ICU.Util.Calendar.MONTH) != month
                        || gc.Get(IBM.ICU.Util.Calendar.DATE) != (date + i))
                    Errln("FAIL: Date " + gc.GetTime() + " wrong");
            }
        }

        // Verify DAY_OF_WEEK
        [Test]
        public void TestDOW943()
        {
            DowTest(false);
            DowTest(true);
        }

        internal void DowTest(bool lenient)
        {
            IBM.ICU.Util.GregorianCalendar cal = new IBM.ICU.Util.GregorianCalendar();
            cal.Set(1997, IBM.ICU.Util.Calendar.AUGUST, 12); // Wednesday
            cal.GetTime(); // Force update
            cal.SetLenient(lenient);
            cal.Set(1996, IBM.ICU.Util.Calendar.DECEMBER, 1); // Set the date to be December 1,
            // 1996
            int dow = cal.Get(IBM.ICU.Util.Calendar.DAY_OF_WEEK);
            int min = cal.GetMinimum(IBM.ICU.Util.Calendar.DAY_OF_WEEK);
            int max = cal.GetMaximum(IBM.ICU.Util.Calendar.DAY_OF_WEEK);
            if (dow < min || dow > max)
                Errln("FAIL: Day of week " + dow + " out of range");
            if (dow != IBM.ICU.Util.Calendar.SUNDAY)
            {
                Errln("FAIL2: Day of week should be SUNDAY; is " + dow + ": "
                        + cal.GetTime());
            }
            if (min != IBM.ICU.Util.Calendar.SUNDAY || max != IBM.ICU.Util.Calendar.SATURDAY)
                Errln("FAIL: Min/max bad");
        }

        // Verify that the clone method produces distinct objects with no
        // unintentionally shared fields.
        [Test]
        public void TestClonesUnique908()
        {
            IBM.ICU.Util.Calendar c = IBM.ICU.Util.Calendar.GetInstance();
            IBM.ICU.Util.Calendar d = (IBM.ICU.Util.Calendar)c.Clone();
            c.Set(IBM.ICU.Util.Calendar.MILLISECOND, 123);
            d.Set(IBM.ICU.Util.Calendar.MILLISECOND, 456);
            if (c.Get(IBM.ICU.Util.Calendar.MILLISECOND) != 123
                    || d.Get(IBM.ICU.Util.Calendar.MILLISECOND) != 456)
            {
                Errln("FAIL: Clones share fields");
            }
        }

        // Verify effect of Gregorian cutoff value
        [Test]
        public void TestGregorianChange768()
        {
            bool b;
            IBM.ICU.Util.GregorianCalendar c = new IBM.ICU.Util.GregorianCalendar();
            Logln("With cutoff " + c.GetGregorianChange());
            Logln(" isLeapYear(1800) = " + (b = c.IsLeapYear(1800)));
            Logln(" (should be FALSE)");
            if (b != false)
                Errln("FAIL");
            IBM.ICU.Util.Calendar tempcal = IBM.ICU.Util.Calendar.GetInstance();
            tempcal.Clear();
            tempcal.Set(1900, 0, 1);
            c.SetGregorianChange(tempcal.GetTime()); // Jan 1 1900
            Logln("With cutoff " + c.GetGregorianChange());
            Logln(" isLeapYear(1800) = " + (b = c.IsLeapYear(1800)));
            Logln(" (should be TRUE)");
            if (b != true)
                Errln("FAIL");
        }

        // Test the correct behavior of the disambiguation algorithm.
        [Test]
        public void TestDisambiguation765()
        {
            IBM.ICU.Util.Calendar c = IBM.ICU.Util.Calendar.GetInstance();
            c.SetLenient(false);

            c.Clear();
            c.Set(IBM.ICU.Util.Calendar.YEAR, 1997);
            c.Set(IBM.ICU.Util.Calendar.MONTH, IBM.ICU.Util.Calendar.JUNE);
            c.Set(IBM.ICU.Util.Calendar.DATE, 3);

            Verify765("1997 third day of June = ", c, 1997, IBM.ICU.Util.Calendar.JUNE, 3);

            c.Clear();
            c.Set(IBM.ICU.Util.Calendar.YEAR, 1997);
            c.Set(IBM.ICU.Util.Calendar.DAY_OF_WEEK, IBM.ICU.Util.Calendar.TUESDAY);
            c.Set(IBM.ICU.Util.Calendar.MONTH, IBM.ICU.Util.Calendar.JUNE);
            c.Set(IBM.ICU.Util.Calendar.DAY_OF_WEEK_IN_MONTH, 1);
            Verify765("1997 first Tuesday in June = ", c, 1997, IBM.ICU.Util.Calendar.JUNE, 3);

            c.Clear();
            c.Set(IBM.ICU.Util.Calendar.YEAR, 1997);
            c.Set(IBM.ICU.Util.Calendar.DAY_OF_WEEK, IBM.ICU.Util.Calendar.TUESDAY);
            c.Set(IBM.ICU.Util.Calendar.MONTH, IBM.ICU.Util.Calendar.JUNE);
            c.Set(IBM.ICU.Util.Calendar.DAY_OF_WEEK_IN_MONTH, -1);
            Verify765("1997 last Tuesday in June = ", c, 1997, IBM.ICU.Util.Calendar.JUNE, 24);

            ArgumentException e = null;
            try
            {
                c.Clear();
                c.Set(IBM.ICU.Util.Calendar.YEAR, 1997);
                c.Set(IBM.ICU.Util.Calendar.DAY_OF_WEEK, IBM.ICU.Util.Calendar.TUESDAY);
                c.Set(IBM.ICU.Util.Calendar.MONTH, IBM.ICU.Util.Calendar.JUNE);
                c.Set(IBM.ICU.Util.Calendar.DAY_OF_WEEK_IN_MONTH, 0);
                c.GetTime();
            }
            catch (ArgumentException ex)
            {
                e = ex;
            }
            Verify765("1997 zero-th Tuesday in June = ", e, c);

            c.Clear();
            c.Set(IBM.ICU.Util.Calendar.YEAR, 1997);
            c.Set(IBM.ICU.Util.Calendar.DAY_OF_WEEK, IBM.ICU.Util.Calendar.TUESDAY);
            c.Set(IBM.ICU.Util.Calendar.MONTH, IBM.ICU.Util.Calendar.JUNE);
            c.Set(IBM.ICU.Util.Calendar.WEEK_OF_MONTH, 1);
            Verify765("1997 Tuesday in week 1 of June = ", c, 1997, IBM.ICU.Util.Calendar.JUNE,
                    3);

            c.Clear();
            c.Set(IBM.ICU.Util.Calendar.YEAR, 1997);
            c.Set(IBM.ICU.Util.Calendar.DAY_OF_WEEK, IBM.ICU.Util.Calendar.TUESDAY);
            c.Set(IBM.ICU.Util.Calendar.MONTH, IBM.ICU.Util.Calendar.JUNE);
            c.Set(IBM.ICU.Util.Calendar.WEEK_OF_MONTH, 5);
            Verify765("1997 Tuesday in week 5 of June = ", c, 1997, IBM.ICU.Util.Calendar.JULY,
                    1);

            try
            {
                c.Clear();
                c.Set(IBM.ICU.Util.Calendar.YEAR, 1997);
                c.Set(IBM.ICU.Util.Calendar.DAY_OF_WEEK, IBM.ICU.Util.Calendar.TUESDAY);
                c.Set(IBM.ICU.Util.Calendar.MONTH, IBM.ICU.Util.Calendar.JUNE);
                c.Set(IBM.ICU.Util.Calendar.WEEK_OF_MONTH, 0);
                Verify765("1997 Tuesday in week 0 of June = ", c, 1997,
                        IBM.ICU.Util.Calendar.MAY, 27);
            }
            catch (ArgumentException ex_0)
            {
                Errln("FAIL: Exception seen:");
                // ex.printStackTrace(log);
            }

            c.Clear();
            c.Set(IBM.ICU.Util.Calendar.YEAR, 1997);
            c.Set(IBM.ICU.Util.Calendar.DAY_OF_WEEK, IBM.ICU.Util.Calendar.TUESDAY);
            c.Set(IBM.ICU.Util.Calendar.WEEK_OF_YEAR, 1);
            Verify765("1997 Tuesday in week 1 of year = ", c, 1996,
                    IBM.ICU.Util.Calendar.DECEMBER, 31);

            c.Clear();
            c.Set(IBM.ICU.Util.Calendar.YEAR, 1997);
            c.Set(IBM.ICU.Util.Calendar.DAY_OF_WEEK, IBM.ICU.Util.Calendar.TUESDAY);
            c.Set(IBM.ICU.Util.Calendar.WEEK_OF_YEAR, 10);
            Verify765("1997 Tuesday in week 10 of year = ", c, 1997,
                    IBM.ICU.Util.Calendar.MARCH, 4);

            try
            {
                c.Clear();
                c.Set(IBM.ICU.Util.Calendar.YEAR, 1997);
                c.Set(IBM.ICU.Util.Calendar.DAY_OF_WEEK, IBM.ICU.Util.Calendar.TUESDAY);
                c.Set(IBM.ICU.Util.Calendar.WEEK_OF_YEAR, 0);
                Verify765("1997 Tuesday in week 0 of year = ", c, 1996,
                        IBM.ICU.Util.Calendar.DECEMBER, 24);
                throw new Exception("Fail: WEEK_OF_YEAR 0 should be illegal");
            }
            catch (ArgumentException ex_1)
            {
                System.Console.Out.Write("");
            }
        }

        internal void Verify765(String msg, IBM.ICU.Util.Calendar c, int year, int month, int day)
        {
            int cy = c.Get(IBM.ICU.Util.Calendar.YEAR); // NEWCAL
            int cm = c.Get(IBM.ICU.Util.Calendar.MONTH);
            int cd = c.Get(IBM.ICU.Util.Calendar.DATE);
            if (cy == year && cm == month && cd == day)
            {
                Logln("PASS: " + msg + c.GetTime());
            }
            else
            {
                Errln("FAIL: " + msg + cy + "/" + (cm + 1) + "/" + cd + "="
                        + c.GetTime() + "; expected " + year + "/" + (month + 1)
                        + "/" + day);
            }
        }

        // Called when e expected to be non-null
        internal void Verify765(String msg, ArgumentException e, IBM.ICU.Util.Calendar c)
        {
            if (e == null)
                Errln("FAIL: No IllegalArgumentException for " + msg + c.GetTime());
            else
                Logln("PASS: " + msg + "IllegalArgument as expected");
        }

        // Test the behavior of GMT vs. local time
        [Test]
        public void TestGMTvsLocal4064654()
        {
            // Sample output 1:
            // % /usr/local/java/jdk1.1.3/solaris/bin/java test 1997 1 1 12 0 0
            // date = Wed Jan 01 04:00:00 PST 1997
            // offset for Wed Jan 01 04:00:00 PST 1997= -8hr
            Aux4064654(1997, 1, 1, 12, 0, 0);

            // Sample output 2:
            // % /usr/local/java/jdk1.1.3/solaris/bin/java test 1997 4 16 18 30 0
            // date = Wed Apr 16 10:30:00 PDT 1997
            // offset for Wed Apr 16 10:30:00 PDT 1997= -7hr

            // Note that in sample output 2 according to the offset, the gmt time
            // of the result would be 1997 4 16 17 30 0 which is different from the
            // input of 1997 4 16 18 30 0.
            Aux4064654(1997, 4, 16, 18, 30, 0);
        }

        internal void Aux4064654(int yr, int mo, int dt, int hr, int mn, int sc)
        {
            DateTime date;
            IBM.ICU.Util.Calendar gmtcal = IBM.ICU.Util.Calendar.GetInstance();
            gmtcal.SetTimeZone(IBM.ICU.Util.TimeZone.GetTimeZone("Africa/Casablanca"));
            gmtcal.Set(yr, mo - 1, dt, hr, mn, sc);
            gmtcal.Set(IBM.ICU.Util.Calendar.MILLISECOND, 0);

            date = gmtcal.GetTime();
            Logln("date = " + date);

            IBM.ICU.Util.Calendar cal = IBM.ICU.Util.Calendar.GetInstance();
            cal.SetTimeZone(IBM.ICU.Util.TimeZone.GetTimeZone("America/Los_Angels"));
            cal.SetTime(date);

            int offset = cal.GetTimeZone().GetOffset(cal.Get(IBM.ICU.Util.Calendar.ERA),
                    cal.Get(IBM.ICU.Util.Calendar.YEAR), cal.Get(IBM.ICU.Util.Calendar.MONTH),
                    cal.Get(IBM.ICU.Util.Calendar.DATE), cal.Get(IBM.ICU.Util.Calendar.DAY_OF_WEEK),
                    cal.Get(IBM.ICU.Util.Calendar.MILLISECOND));

            Logln("offset for " + date + "= " + (offset / 1000 / 60 / 60.0d) + "hr");

            int utc = ((cal.Get(IBM.ICU.Util.Calendar.HOUR_OF_DAY) * 60 + cal
                    .Get(IBM.ICU.Util.Calendar.MINUTE)) * 60 + cal.Get(IBM.ICU.Util.Calendar.SECOND))
                    * 1000
                    + cal.Get(IBM.ICU.Util.Calendar.MILLISECOND) - offset;

            int expected = ((hr * 60 + mn) * 60 + sc) * 1000;

            if (utc != expected)
                Errln("FAIL: Discrepancy of " + (utc - expected) + " millis = "
                        + ((utc - expected) / 1000 / 60 / 60.0d) + " hr");
        }

        // Verify that add and set work regardless of the order in which
        // they are called.
        [Test]
        public void TestAddSetOrder621()
        {
            IBM.ICU.Util.Calendar tempcal = IBM.ICU.Util.Calendar.GetInstance();
            tempcal.Clear();
            tempcal.Set(1997, 4, 14, 13, 23, 45);
            DateTime d = tempcal.GetTime();

            IBM.ICU.Util.Calendar cal = IBM.ICU.Util.Calendar.GetInstance();
            cal.SetTime(d);
            cal.Add(IBM.ICU.Util.Calendar.DATE, -5);
            cal.Set(IBM.ICU.Util.Calendar.HOUR_OF_DAY, 0);
            cal.Set(IBM.ICU.Util.Calendar.MINUTE, 0);
            cal.Set(IBM.ICU.Util.Calendar.SECOND, 0);
            // ma feb 03 00:00:00 GMT+00:00 1997
            String s = cal.GetTime().ToString();

            cal = IBM.ICU.Util.Calendar.GetInstance();
            cal.SetTime(d);
            cal.Set(IBM.ICU.Util.Calendar.HOUR_OF_DAY, 0);
            cal.Set(IBM.ICU.Util.Calendar.MINUTE, 0);
            cal.Set(IBM.ICU.Util.Calendar.SECOND, 0);
            cal.Add(IBM.ICU.Util.Calendar.DATE, -5);
            // ma feb 03 13:11:06 GMT+00:00 1997
            String s2 = cal.GetTime().ToString();

            if (s.Equals(s2))
                Logln("Pass: " + s + " == " + s2);
            else
                Errln("FAIL: " + s + " != " + s2);
        }

        // Verify that add works.
        [Test]
        public void TestAdd520()
        {
            int y = 1997, m = IBM.ICU.Util.Calendar.FEBRUARY, d = 1;
            IBM.ICU.Util.GregorianCalendar temp = new IBM.ICU.Util.GregorianCalendar(y, m, d);
            Check520(temp, y, m, d);

            temp.Add(IBM.ICU.Util.Calendar.YEAR, 1);
            y++;
            Check520(temp, y, m, d);

            temp.Add(IBM.ICU.Util.Calendar.MONTH, 1);
            m++;
            Check520(temp, y, m, d);

            temp.Add(IBM.ICU.Util.Calendar.DATE, 1);
            d++;
            Check520(temp, y, m, d);

            temp.Add(IBM.ICU.Util.Calendar.DATE, 2);
            d += 2;
            Check520(temp, y, m, d);

            temp.Add(IBM.ICU.Util.Calendar.DATE, 28);
            d = 1;
            ++m;
            Check520(temp, y, m, d);
        }

        internal void Check520(IBM.ICU.Util.Calendar c, int y, int m, int d)
        {
            if (c.Get(IBM.ICU.Util.Calendar.YEAR) != y || c.Get(IBM.ICU.Util.Calendar.MONTH) != m
                    || c.Get(IBM.ICU.Util.Calendar.DATE) != d)
            {
                Errln("FAILURE: Expected YEAR/MONTH/DATE of " + y + "/" + (m + 1)
                        + "/" + d + "; got " + c.Get(IBM.ICU.Util.Calendar.YEAR) + "/"
                        + (c.Get(IBM.ICU.Util.Calendar.MONTH) + 1) + "/" + c.Get(IBM.ICU.Util.Calendar.DATE));
            }
            else
                Logln("Confirmed: " + y + "/" + (m + 1) + "/" + d);
        }

        // Verify that setting fields works. This test fails when an exception is
        // thrown.
        [Test]
        public void TestFieldSet4781()
        {
            try
            {
                IBM.ICU.Util.GregorianCalendar g = new IBM.ICU.Util.GregorianCalendar();
                IBM.ICU.Util.GregorianCalendar g2 = new IBM.ICU.Util.GregorianCalendar();
                // At this point UTC value is set, various fields are not.
                // Now set to noon.
                g2.Set(IBM.ICU.Util.Calendar.HOUR, 12);
                g2.Set(IBM.ICU.Util.Calendar.MINUTE, 0);
                g2.Set(IBM.ICU.Util.Calendar.SECOND, 0);
                // At this point the object thinks UTC is NOT set, but fields are
                // set.
                // The following line will result in IllegalArgumentException
                // because
                // it thinks the YEAR is set and it is NOT.
                if (g2.Equals(g))
                    Logln("Same");
                else
                    Logln("Different");
            }
            catch (ArgumentException e)
            {
                Errln("Unexpected exception seen: " + e);
            }
        }

        // Test serialization of a Calendar object
        [Ignore]
        public void TestSerialize337()
        {
            IBM.ICU.Util.Calendar cal = IBM.ICU.Util.Calendar.GetInstance();

            bool ok = false;

            try
            {
                /*MemoryStream f = new MemoryStream();
                ObjectOutput s = new IlObjectOutputStream(f);
                s.WriteObject(PREFIX);
                s.WriteObject(cal);
                s.WriteObject(POSTFIX);
                f.Close();
	
                MemoryStream ins0 = new MemoryStream(f.ToArray());
                IlObjectInputStream t = new IlObjectInputStream(ins0);
                String pre = (String) t.ReadObject();
                Calendar c = (Calendar) t.ReadObject();
                String post = (String) t.ReadObject();
                ins0.Close();
	
                ok = pre.Equals(PREFIX) && post.Equals(POSTFIX) && cal.Equals(c);*/
            }
            catch (IOException e)
            {
                Errln("FAIL: Exception received:");
                // e.printStackTrace(log);
            }
            catch (TypeLoadException e_0)
            {
                Errln("FAIL: Exception received:");
                // e.printStackTrace(log);
            }

            if (!ok)
                Errln("Serialization of Calendar object failed.");
        }

        internal const String PREFIX = "abc";

        internal const String POSTFIX = "def";

        internal const String FILENAME = "tmp337.bin";

        // Try to zero out the seconds field
        [Test]
        public void TestSecondsZero121()
        {
            IBM.ICU.Util.Calendar cal = new IBM.ICU.Util.GregorianCalendar();
            // Initialize with current date/time
            cal.SetTime(DateTime.Now);
            // Round down to minute
            cal.Set(IBM.ICU.Util.Calendar.SECOND, 0);
            DateTime d = cal.GetTime();
            String s = d.ToString();
            if (s.IndexOf(":00 ") < 0)
                Errln("Expected to see :00 in " + s);
        }

        // Try various sequences of add, set, and get method calls.
        [Test]
        public void TestAddSetGet0610()
        {
            //
            // Error case 1:
            // - Upon initialization calendar fields, millis = System.currentTime
            // - After set is called fields are initialized, time is not
            // - Addition uses millis which are still *now*
            //
            {
                IBM.ICU.Util.Calendar calendar = new IBM.ICU.Util.GregorianCalendar();
                calendar.Set(1993, IBM.ICU.Util.Calendar.JANUARY, 4);
                Logln("1A) " + Value(calendar));
                calendar.Add(IBM.ICU.Util.Calendar.DATE, 1);
                String v = Value(calendar);
                Logln("1B) " + v);
                Logln("--) 1993/0/5");
                if (!v.Equals(EXPECTED_0610))
                    Errln("Expected " + EXPECTED_0610 + "; saw " + v);
            }

            //
            // Error case 2:
            // - Upon initialization calendar fields set, millis = 0
            // - Addition uses millis which are still 1970, 0, 1
            //

            {
                IBM.ICU.Util.Calendar calendar_0 = new IBM.ICU.Util.GregorianCalendar(1993, IBM.ICU.Util.Calendar.JANUARY, 4);
                Logln("2A) " + Value(calendar_0));
                calendar_0.Add(IBM.ICU.Util.Calendar.DATE, 1);
                String v_1 = Value(calendar_0);
                Logln("2B) " + v_1);
                Logln("--) 1993/0/5");
                if (!v_1.Equals(EXPECTED_0610))
                    Errln("Expected " + EXPECTED_0610 + "; saw " + v_1);
            }

            //
            // Error case 3:
            // - Upon initialization calendar fields, millis = 0
            // - getTime( ) is called which forces the millis to be set
            // - Addition uses millis which are correct
            //

            {
                IBM.ICU.Util.Calendar calendar_2 = new IBM.ICU.Util.GregorianCalendar(1993, IBM.ICU.Util.Calendar.JANUARY, 4);
                Logln("3A) " + Value(calendar_2));
                calendar_2.GetTime();
                calendar_2.Add(IBM.ICU.Util.Calendar.DATE, 1);
                String v_3 = Value(calendar_2);
                Logln("3B) " + v_3);
                Logln("--) 1993/0/5");
                if (!v_3.Equals(EXPECTED_0610))
                    Errln("Expected " + EXPECTED_0610 + "; saw " + v_3);
            }
        }

        static internal String Value(IBM.ICU.Util.Calendar calendar)
        {
            return (calendar.Get(IBM.ICU.Util.Calendar.YEAR) + "/"
                    + calendar.Get(IBM.ICU.Util.Calendar.MONTH) + "/" + calendar
                    .Get(IBM.ICU.Util.Calendar.DATE));
        }

        static internal String EXPECTED_0610 = "1993/0/5";

        // Test that certain fields on a certain date are as expected.
        [Test]
        public void TestFields060()
        {
            int year = 1997;
            int month = IBM.ICU.Util.Calendar.OCTOBER; // october
            int dDate = 22; // DAYOFWEEK should return 3 for Wednesday
            IBM.ICU.Util.GregorianCalendar calendar = null;

            calendar = new IBM.ICU.Util.GregorianCalendar(year, month, dDate);
            for (int i = 0; i < EXPECTED_FIELDS.Length; )
            {
                int field = EXPECTED_FIELDS[i++];
                int expected = EXPECTED_FIELDS[i++];
                if (calendar.Get(field) != expected)
                {
                    Errln("Expected field " + field + " to have value " + expected
                            + "; received " + calendar.Get(field) + " instead");
                }
            }
        }

        static internal int[] EXPECTED_FIELDS = { IBM.ICU.Util.Calendar.YEAR, 1997,
	            IBM.ICU.Util.Calendar.MONTH, IBM.ICU.Util.Calendar.OCTOBER,
	            IBM.ICU.Util.Calendar.DAY_OF_MONTH, 22,
	            IBM.ICU.Util.Calendar.DAY_OF_WEEK,
	            IBM.ICU.Util.Calendar.WEDNESDAY,
	            IBM.ICU.Util.Calendar.DAY_OF_WEEK_IN_MONTH, 4,
	            IBM.ICU.Util.Calendar.DAY_OF_YEAR, 295 };

        // Verify that the fields are as expected (mostly zero) at the epoch start.
        // Note that we adjust for the default timezone to get most things to zero.
        [Test]
        public void TestEpochStartFields()
        {
            IBM.ICU.Util.TimeZone z = IBM.ICU.Util.TimeZone.GetDefault();
            IBM.ICU.Util.Calendar c = IBM.ICU.Util.Calendar.GetInstance();
            DateTime d = DateUtil.DateFromJavaMillis((-z.GetRawOffset()));
            if (z.InDaylightTime(d))
            {
                Logln("Warning: Skipping test because " + d + " is in DST.");
            }
            else
            {
                c.SetTime(d);
                for (int i = 0; i < IBM.ICU.Util.Calendar.ZONE_OFFSET; ++i)
                {
                    if (c.Get(i) != EPOCH_FIELDS[i])
                        Errln("Expected field " + i + " to have value "
                                + EPOCH_FIELDS[i] + "; saw " + c.Get(i)
                                + " instead");
                }
                if (c.Get(IBM.ICU.Util.Calendar.ZONE_OFFSET) != z.GetRawOffset())
                    Errln("Expected field ZONE_OFFSET to have value "
                            + z.GetRawOffset() + "; saw "
                            + c.Get(IBM.ICU.Util.Calendar.ZONE_OFFSET) + " instead");
                if (c.Get(IBM.ICU.Util.Calendar.DST_OFFSET) != 0)
                    Errln("Expected field DST_OFFSET to have value 0" + "; saw "
                            + c.Get(IBM.ICU.Util.Calendar.DST_OFFSET) + " instead");
            }
        }

        static internal int[] EPOCH_FIELDS = { 1, 1970, 0, 1, 1, 1, 1, 5, 1, 0, 0, 0, 0, 0,
	            0, -28800000, 0 };

        // Verify that as you add days to the calendar (e.g., 24 day periods),
        // the day of the week shifts in the expected pattern.
        [Test]
        public void TestDOWProgression()
        {
            IBM.ICU.Util.Calendar cal = new IBM.ICU.Util.GregorianCalendar(1972, IBM.ICU.Util.Calendar.OCTOBER, 26);
            MarchByDelta(cal, 24); // Last parameter must be != 0 modulo 7
        }

        // Supply a delta which is not a multiple of 7.
        internal void MarchByDelta(IBM.ICU.Util.Calendar cal, int delta)
        {
            IBM.ICU.Util.Calendar cur = (IBM.ICU.Util.Calendar)cal.Clone();
            int initialDOW = cur.Get(IBM.ICU.Util.Calendar.DAY_OF_WEEK);
            int DOW, newDOW = initialDOW;
            do
            {
                DOW = newDOW;
                Logln("DOW = " + DOW + "  " + cur.GetTime());

                cur.Add(IBM.ICU.Util.Calendar.DAY_OF_WEEK, delta);
                newDOW = cur.Get(IBM.ICU.Util.Calendar.DAY_OF_WEEK);
                int expectedDOW = 1 + (DOW + delta - 1) % 7;
                if (newDOW != expectedDOW)
                {
                    Errln("Day of week should be " + expectedDOW + " instead of "
                            + newDOW + " on " + cur.GetTime());
                    return;
                }
            } while (newDOW != initialDOW);
        }

        [Test]
        public void TestActualMinMax()
        {
            IBM.ICU.Util.Calendar cal = new IBM.ICU.Util.GregorianCalendar(1967, IBM.ICU.Util.Calendar.MARCH, 10);
            cal.SetFirstDayOfWeek(IBM.ICU.Util.Calendar.SUNDAY);
            cal.SetMinimalDaysInFirstWeek(3);

            if (cal.GetActualMinimum(IBM.ICU.Util.Calendar.DAY_OF_MONTH) != 1)
                Errln("Actual minimum date for 3/10/1967 should have been 1; got "
                        + cal.GetActualMinimum(IBM.ICU.Util.Calendar.DAY_OF_MONTH));
            if (cal.GetActualMaximum(IBM.ICU.Util.Calendar.DAY_OF_MONTH) != 31)
                Errln("Actual maximum date for 3/10/1967 should have been 31; got "
                        + cal.GetActualMaximum(IBM.ICU.Util.Calendar.DAY_OF_MONTH));

            cal.Set(IBM.ICU.Util.Calendar.MONTH, IBM.ICU.Util.Calendar.FEBRUARY);
            if (cal.GetActualMaximum(IBM.ICU.Util.Calendar.DAY_OF_MONTH) != 28)
                Errln("Actual maximum date for 2/10/1967 should have been 28; got "
                        + cal.GetActualMaximum(IBM.ICU.Util.Calendar.DAY_OF_MONTH));
            if (cal.GetActualMaximum(IBM.ICU.Util.Calendar.DAY_OF_YEAR) != 365)
                Errln("Number of days in 1967 should have been 365; got "
                        + cal.GetActualMaximum(IBM.ICU.Util.Calendar.DAY_OF_YEAR));

            cal.Set(IBM.ICU.Util.Calendar.YEAR, 1968);
            if (cal.GetActualMaximum(IBM.ICU.Util.Calendar.DAY_OF_MONTH) != 29)
                Errln("Actual maximum date for 2/10/1968 should have been 29; got "
                        + cal.GetActualMaximum(IBM.ICU.Util.Calendar.DAY_OF_MONTH));
            if (cal.GetActualMaximum(IBM.ICU.Util.Calendar.DAY_OF_YEAR) != 366)
                Errln("Number of days in 1968 should have been 366; got "
                        + cal.GetActualMaximum(IBM.ICU.Util.Calendar.DAY_OF_YEAR));
            // Using week settings of SUNDAY/3 (see above)
            if (cal.GetActualMaximum(IBM.ICU.Util.Calendar.WEEK_OF_YEAR) != 52)
                Errln("Number of weeks in 1968 should have been 52; got "
                        + cal.GetActualMaximum(IBM.ICU.Util.Calendar.WEEK_OF_YEAR));

            cal.Set(IBM.ICU.Util.Calendar.YEAR, 1976);
            cal.Set(IBM.ICU.Util.Calendar.DAY_OF_WEEK, cal.GetFirstDayOfWeek()); // Added - Liu
            // 11/6/00
            // Using week settings of SUNDAY/3 (see above)
            if (cal.GetActualMaximum(IBM.ICU.Util.Calendar.WEEK_OF_YEAR) != 53)
                Errln("Number of weeks in 1976 should have been 53; got "
                        + cal.GetActualMaximum(IBM.ICU.Util.Calendar.WEEK_OF_YEAR));
        }

        [Test]
        public void TestRoll()
        {
            IBM.ICU.Util.Calendar cal = new IBM.ICU.Util.GregorianCalendar(1997, IBM.ICU.Util.Calendar.JANUARY, 31);

            int[] dayValues = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 31 };
            for (int i = 0; i < dayValues.Length; i++)
            {
                IBM.ICU.Util.Calendar cal2 = (IBM.ICU.Util.Calendar)cal.Clone();
                cal2.Roll(IBM.ICU.Util.Calendar.MONTH, i);
                if (cal2.Get(IBM.ICU.Util.Calendar.DAY_OF_MONTH) != dayValues[i])
                    Errln("Rolling the month in 1/31/1997 up by " + i
                            + " should have yielded " + ((i + 1) % 12) + "/"
                            + dayValues[i] + "/1997, but actually yielded "
                            + ((i + 1) % 12) + "/"
                            + cal2.Get(IBM.ICU.Util.Calendar.DAY_OF_MONTH) + "/1997.");
            }

            cal.Set(1996, IBM.ICU.Util.Calendar.FEBRUARY, 29);

            // int[] monthValues = { 1, 2, 2, 2, 1, 2, 2, 2, 1, 2 };
            // int[] dayValues2 = { 29, 1, 1, 1, 29, 1, 1, 1, 29, 1 };

            // I've revised the expected values to make more sense -- rolling
            // the year should pin the DAY_OF_MONTH. - Liu 11/6/00
            int[] monthValues = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
            int[] dayValues2 = { 29, 28, 28, 28, 29, 28, 28, 28, 29, 28 };

            for (int i_0 = 0; i_0 < dayValues2.Length; i_0++)
            {
                IBM.ICU.Util.Calendar cal2_1 = (IBM.ICU.Util.Calendar)cal.Clone();
                cal2_1.Roll(IBM.ICU.Util.Calendar.YEAR, i_0);
                if (cal2_1.Get(IBM.ICU.Util.Calendar.DAY_OF_MONTH) != dayValues2[i_0]
                        || cal2_1.Get(IBM.ICU.Util.Calendar.MONTH) != monthValues[i_0])
                    Errln("Roll 2/29/1996 by " + i_0 + " year: expected "
                            + (monthValues[i_0] + 1) + "/" + dayValues2[i_0] + "/"
                            + (1996 + i_0) + ", got "
                            + (cal2_1.Get(IBM.ICU.Util.Calendar.MONTH) + 1) + "/"
                            + cal2_1.Get(IBM.ICU.Util.Calendar.DAY_OF_MONTH) + "/"
                            + cal2_1.Get(IBM.ICU.Util.Calendar.YEAR));
            }

            // Test rolling hour of day
            cal.Set(IBM.ICU.Util.Calendar.HOUR_OF_DAY, 0);
            cal.Roll(IBM.ICU.Util.Calendar.HOUR_OF_DAY, -2);
            int f = cal.Get(IBM.ICU.Util.Calendar.HOUR_OF_DAY);
            if (f != 22)
                Errln("Rolling HOUR_OF_DAY=0 delta=-2 gave " + f + " Wanted 22");
            cal.Roll(IBM.ICU.Util.Calendar.HOUR_OF_DAY, 5);
            f = cal.Get(IBM.ICU.Util.Calendar.HOUR_OF_DAY);
            if (f != 3)
                Errln("Rolling HOUR_OF_DAY=22 delta=5 gave " + f + " Wanted 3");
            cal.Roll(IBM.ICU.Util.Calendar.HOUR_OF_DAY, 21);
            f = cal.Get(IBM.ICU.Util.Calendar.HOUR_OF_DAY);
            if (f != 0)
                Errln("Rolling HOUR_OF_DAY=3 delta=21 gave " + f + " Wanted 0");

            // Test rolling hour
            cal.Set(IBM.ICU.Util.Calendar.HOUR_OF_DAY, 0);
            cal.Roll(IBM.ICU.Util.Calendar.HOUR, -2);
            f = cal.Get(IBM.ICU.Util.Calendar.HOUR);
            if (f != 10)
                Errln("Rolling HOUR=0 delta=-2 gave " + f + " Wanted 10");
            cal.Roll(IBM.ICU.Util.Calendar.HOUR, 5);
            f = cal.Get(IBM.ICU.Util.Calendar.HOUR);
            if (f != 3)
                Errln("Rolling HOUR=10 delta=5 gave " + f + " Wanted 3");
            cal.Roll(IBM.ICU.Util.Calendar.HOUR, 9);
            f = cal.Get(IBM.ICU.Util.Calendar.HOUR);
            if (f != 0)
                Errln("Rolling HOUR=3 delta=9 gave " + f + " Wanted 0");
        }

        [Test]
        public void TestComputeJulianDay4406()
        {
            // jb4406 is probably not a bug, this is to document the behavior
            IBM.ICU.Util.GregorianCalendar cal = new IBM.ICU.Util.GregorianCalendar();
            int MILLIS_IN_DAY = 1000 * 60 * 60 * 24;

            Logln("julian day value jumps at changeover");
            for (int day = 12; day < 18; ++day)
            {
                cal.Set(1582, 9, day);
                Logln("[" + day + "] " + (cal.GetTimeInMillis() / MILLIS_IN_DAY));
            }

            Logln("\njulian days not accurate before 1 March 0004");
            for (int day_0 = 1; day_0 < 3; ++day_0)
            {
                cal.Set(1, 0, day_0);
                Logln("[" + day_0 + "] " + (cal.GetTimeInMillis() / MILLIS_IN_DAY));
            }

            IBM.ICU.Text.DateFormat fmt = cal.GetDateTimeFormat(IBM.ICU.Text.DateFormat.LONG, 0,
                    Locale.GetDefault());

            Logln("\nswitchover in 1582");
            cal.Set(1582, 9, 4);
            Logln(fmt.FormatObject(cal));
            cal.Add(IBM.ICU.Util.Calendar.DATE, 1);
            Logln(fmt.FormatObject(cal));
            cal.Set(IBM.ICU.Util.Calendar.JULIAN_DAY, 1721426);
            Logln(fmt.FormatObject(cal));

            Logln("\nlate switchover - proleptic Julian");
            cal.Set(1582, 9, 4);
            cal.SetGregorianChange(DateUtil.DateFromJavaMillis((Int64.MaxValue)));
            Logln(fmt.FormatObject(cal));
            cal.Add(IBM.ICU.Util.Calendar.DATE, 1);
            Logln(fmt.FormatObject(cal));
            cal.Set(IBM.ICU.Util.Calendar.JULIAN_DAY, 1721426);
            Logln(fmt.FormatObject(cal));

            Logln("\nearly switchover - proleptic Gregorian");
            cal.Set(1582, 9, 4);
            cal.SetGregorianChange(DateUtil.DateFromJavaMillis((Int64.MinValue)));
            Logln(fmt.FormatObject(cal));
            cal.Add(IBM.ICU.Util.Calendar.DATE, 1);
            Logln(fmt.FormatObject(cal));
            cal.Set(IBM.ICU.Util.Calendar.JULIAN_DAY, 1721426);
            Logln(fmt.FormatObject(cal));
        }
    }

    // eof
}
