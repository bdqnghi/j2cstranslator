// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:30 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 1996-2007, International Business Machines Corporation and    
/// others. All Rights Reserved.                                                
/// </summary>
///
namespace IBM.ICU.Text {
	
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Text;
	
	/// <summary>
	/// <p>
	/// A <c>CollationKey</c> represents a <c>String</c> under the rules
	/// of a specific <c>Collator</c> object. Comparing two
	/// <c>CollationKey</c>s returns the relative order of the
	/// <c>String</c>s they represent.
	/// </p>
	/// <p>
	/// Since the rule set of <c>Collator</c>s can differ, the sort orders of
	/// the same string under two different <c>Collator</c>s might differ.
	/// Hence comparing <c>CollationKey</c>s generated from different
	/// <c>Collator</c>s can give incorrect results.
	/// </p>
	/// <p>
	/// Both the method <c>CollationKey.compareTo(CollationKey)</c> and the
	/// method <c>Collator.compare(String, String)</c> compare two strings and
	/// returns their relative order. The performance characterictics of these two
	/// approaches can differ.
	/// </p>
	/// <p>
	/// During the construction of a <c>CollationKey</c>, the entire source
	/// string is examined and processed into a series of bits terminated by a null,
	/// that are stored in the <c>CollationKey</c>. When
	/// <c>CollationKey.compareTo(CollationKey)</c> executes, it performs
	/// bitwise comparison on the bit sequences. This can incurs startup cost when
	/// creating the <c>CollationKey</c>, but once the key is created, binary
	/// comparisons are fast. This approach is recommended when the same strings are
	/// to be compared over and over again.
	/// </p>
	/// <p>
	/// On the other hand, implementations of
	/// <c>Collator.compare(String, String)</c> can examine and process the
	/// strings only until the first characters differing in order. This approach is
	/// recommended if the strings are to be compared only once.
	/// </p>
	/// <p>
	/// More information about the composition of the bit sequence can be found in
	/// the <a href=
	/// "http://www.icu-project.org/userguide/Collate_ServiceArchitecture.html"> user
	/// guide</a>.
	/// </p>
	/// <p>
	/// The following example shows how <c>CollationKey</c>s can be used to
	/// sort a list of <c>String</c>s.
	/// </p>
	/// <blockquote>
	/// <pre>
	/// // Create an array of CollationKeys for the Strings to be sorted.
	/// Collator myCollator = Collator.getInstance();
	/// CollationKey[] keys = new CollationKey[3];
	/// keys[0] = myCollator.getCollationKey("Tom");
	/// keys[1] = myCollator.getCollationKey("Dick");
	/// keys[2] = myCollator.getCollationKey("Harry");
	/// sort( keys );
	/// <br>
	/// //...
	/// <br>
	/// // Inside body of sort routine, compare keys this way
	/// if( keys[i].compareTo( keys[j] ) > 0 )
	/// // swap keys[i] and keys[j]
	/// <br>
	/// //...
	/// <br>
	/// // Finally, when we've returned from sort.
	/// System.out.println( keys[0].getSourceString() );
	/// System.out.println( keys[1].getSourceString() );
	/// System.out.println( keys[2].getSourceString() );
	/// </pre>
	/// </blockquote> </p>
	/// <p>
	/// This class is not subclassable
	/// </p>
	/// </summary>
	///
	/// <seealso cref="T:IBM.ICU.Text.Collator"/>
	/// <seealso cref="T:IBM.ICU.Text.RuleBasedCollator"/>
	/// @stable ICU 2.8
	public sealed class CollationKey : IComparable {
	    // public inner classes -------------------------------------------------
	
	    /// <summary>
	    /// Options that used in the API CollationKey.getBound() for getting a
	    /// CollationKey based on the bound mode requested.
	    /// </summary>
	    ///
	    /// @stable ICU 2.6
	    public sealed class BoundMode {
	        /*
	         * do not change the values assigned to the members of this enum.
	         * Underlying code depends on them having these numbers
	         */
	
	        /// <summary>
	        /// Lower bound
	        /// </summary>
	        ///
	        /// @stable ICU 2.6
	        public const int LOWER = 0;
	
	        /// <summary>
	        /// Upper bound that will match strings of exact size
	        /// </summary>
	        ///
	        /// @stable ICU 2.6
	        public const int UPPER = 1;
	
	        /// <summary>
	        /// Upper bound that will match all the strings that have the same
	        /// initial substring as the given string
	        /// </summary>
	        ///
	        /// @stable ICU 2.6
	        public const int UPPER_LONG = 2;
	
	        /// <summary>
	        /// Number of bound mode
	        /// </summary>
	        ///
	        /// @stable ICU 2.6
	        public const int COUNT = 3;
	
	        /// <summary>
	        /// Private Constructor
	        /// </summary>
	        ///
	        // /CLOVER:OFF
	        public BoundMode() {
	        }
	        // /CLOVER:ON
	    }
	
	    // public constructor ---------------------------------------------------
	
	    /// <summary>
	    /// CollationKey constructor. This constructor is given public access, unlike
	    /// the JDK version, to allow access to users extending the Collator class.
	    /// See <see cref="M:IBM.ICU.Text.Collator.GetCollationKey(System.String)"/>.
	    /// </summary>
	    ///
	    /// <param name="source">string this CollationKey is to represent</param>
	    /// <param name="key">array of bytes that represent the collation order of argumentsource terminated by a null</param>
	    /// <seealso cref="T:IBM.ICU.Text.Collator"/>
	    /// @stable ICU 2.8
	    public CollationKey(String source, byte[] key) {
	        m_source_ = source;
	        m_key_ = key;
	        m_hashCode_ = 0;
	        m_length_ = -1;
	    }
	
	    /// <summary>
	    /// CollationKey constructor that forces key to release its internal byte
	    /// array for adoption. key will have a null byte array after this
	    /// construction.
	    /// </summary>
	    ///
	    /// <param name="source">string this CollationKey is to represent</param>
	    /// <param name="key">RawCollationKey object that represents the collation order ofargument source.</param>
	    /// <seealso cref="T:IBM.ICU.Text.Collator"/>
	    /// <seealso cref="T:IBM.ICU.Text.RawCollationKey"/>
	    /// @stable ICU 2.8
	    public CollationKey(String source, RawCollationKey key) {
	        m_source_ = source;
	        m_key_ = key.ReleaseBytes();
	        m_hashCode_ = 0;
	        m_length_ = -1;
	    }
	
	    // public getters -------------------------------------------------------
	
	    /// <summary>
	    /// Return the source string that this CollationKey represents.
	    /// </summary>
	    ///
	    /// <returns>source string that this CollationKey represents</returns>
	    /// @stable ICU 2.8
	    public String GetSourceString() {
	        return m_source_;
	    }
	
	    /// <summary>
	    /// <p>
	    /// Duplicates and returns the value of this CollationKey as a sequence of
	    /// big-endian bytes terminated by a null.
	    /// </p>
	    /// <p>
	    /// If two CollationKeys can be legitimately compared, then one can compare
	    /// the byte arrays of each to obtain the same result, e.g.
	    /// <pre>
	    /// byte key1[] = collationkey1.toByteArray();
	    /// byte key2[] = collationkey2.toByteArray();
	    /// int key, targetkey;
	    /// int i = 0;
	    /// do {
	    /// key = key1[i] &amp; 0xFF;
	    /// targetkey = key2[i] &amp; 0xFF;
	    /// if (key &lt; targetkey) {
	    /// System.out.println(&quot;String 1 is less than string 2&quot;);
	    /// return;
	    /// }
	    /// if (targetkey &lt; key) {
	    /// System.out.println(&quot;String 1 is more than string 2&quot;);
	    /// }
	    /// i++;
	    /// } while (key != 0 &amp;&amp; targetKey != 0);
	    /// System.out.println(&quot;Strings are equal.&quot;);
	    /// </pre>
	    /// </p>
	    /// </summary>
	    ///
	    /// <returns>CollationKey value in a sequence of big-endian byte bytes
	    /// terminated by a null.</returns>
	    /// @stable ICU 2.8
	    public byte[] ToByteArray() {
	        int length = 0;
	        while (true) {
	            if (m_key_[length] == 0) {
	                break;
	            }
	            length++;
	        }
	        length++;
	        byte[] result = new byte[length];
	        System.Array.Copy((Array)(m_key_),0,(Array)(result),0,length);
	        return result;
	    }
	
	    // public other methods -------------------------------------------------
	
	    /// <summary>
	    /// <p>
	    /// Compare this CollationKey to another CollationKey. The collation rules of
	    /// the Collator that created this key are applied.
	    /// </p>
	    /// <p>
	    /// <strong>Note:</strong> Comparison between CollationKeys created by
	    /// different Collators might return incorrect results. See class
	    /// documentation.
	    /// </p>
	    /// </summary>
	    ///
	    /// <param name="target">target CollationKey</param>
	    /// <returns>an integer value. If the value is less than zero this
	    /// CollationKey is less than than target, if the value is zero they
	    /// are equal, and if the value is greater than zero this
	    /// CollationKey is greater than target.</returns>
	    /// <exception cref="NullPointerException">is thrown if argument is null.</exception>
	    /// <seealso cref="M:IBM.ICU.Text.Collator.Compare(System.String, System.String)"/>
	    /// @stable ICU 2.8
	    public int CompareTo(CollationKey target) {
	        for (int i = 0;; ++i) {
	            int l = m_key_[i] & 0xff;
	            int r = target.m_key_[i] & 0xff;
	            if (l < r) {
	                return -1;
	            } else if (l > r) {
	                return 1;
	            } else if (l == 0) {
	                return 0;
	            }
	        }
	    }
	
	    /// <summary>
	    /// <p>
	    /// Compare this CollationKey with the specified Object. The collation rules
	    /// of the Collator that created this key are applied.
	    /// </p>
	    /// <p>
	    /// See note in compareTo(CollationKey) for warnings about possible incorrect
	    /// results.
	    /// </p>
	    /// </summary>
	    ///
	    /// <param name="obj">the Object to be compared to.</param>
	    /// <returns>Returns a negative integer, zero, or a positive integer
	    /// respectively if this CollationKey is less than, equal to, or
	    /// greater than the given Object.</returns>
	    /// <exception cref="ClassCastException">is thrown when the argument is not a CollationKey.NullPointerException is thrown when the argument is null.</exception>
	    /// <seealso cref="M:IBM.ICU.Text.CollationKey.CompareTo(IBM.ICU.Text.CollationKey)"/>
	    /// @stable ICU 2.8
	    public int CompareTo(Object obj) {
	        return CompareTo((CollationKey) obj);
	    }
	
	    /// <summary>
	    /// <p>
	    /// Compare this CollationKey and the specified Object for equality. The
	    /// collation rules of the Collator that created this key are applied.
	    /// </p>
	    /// <p>
	    /// See note in compareTo(CollationKey) for warnings about possible incorrect
	    /// results.
	    /// </p>
	    /// </summary>
	    ///
	    /// <param name="target">the object to compare to.</param>
	    /// <returns>true if the two keys compare as equal, false otherwise.</returns>
	    /// <seealso cref="M:IBM.ICU.Text.CollationKey.CompareTo(IBM.ICU.Text.CollationKey)"/>
	    /// <exception cref="ClassCastException">is thrown when the argument is not a CollationKey.NullPointerException is thrown when the argument is null.</exception>
	    /// @stable ICU 2.8
	    public override bool Equals(Object target) {
	        if (!(target  is  CollationKey)) {
	            return false;
	        }
	
	        return Equals((CollationKey) target);
	    }
	
	    /// <summary>
	    /// <p>
	    /// Compare this CollationKey and the argument target CollationKey for
	    /// equality. The collation rules of the Collator object which created these
	    /// objects are applied.
	    /// </p>
	    /// <p>
	    /// See note in compareTo(CollationKey) for warnings of incorrect results
	    /// </p>
	    /// </summary>
	    ///
	    /// <param name="target">the CollationKey to compare to.</param>
	    /// <returns>true if two objects are equal, false otherwise.</returns>
	    /// <exception cref="NullPointerException">is thrown when the argument is null.</exception>
	    /// @stable ICU 2.8
	    public bool Equals(CollationKey target) {
	        if (this == target) {
	            return true;
	        }
	        if (target == null) {
	            return false;
	        }
	        CollationKey other = (CollationKey) target;
	        int i = 0;
	        while (true) {
	            if (m_key_[i] != other.m_key_[i]) {
	                return false;
	            }
	            if (m_key_[i] == 0) {
	                break;
	            }
	            i++;
	        }
	        return true;
	    }
	
	    /// <summary>
	    /// <p>
	    /// Returns a hash code for this CollationKey. The hash value is calculated
	    /// on the key itself, not the String from which the key was created. Thus if
	    /// x and y are CollationKeys, then x.hashCode(x) == y.hashCode() if
	    /// x.equals(y) is true. This allows language-sensitive comparison in a hash
	    /// table.
	    /// </p>
	    /// </summary>
	    ///
	    /// <returns>the hash value.</returns>
	    /// @stable ICU 2.8
	    public override int GetHashCode() {
	        if (m_hashCode_ == 0) {
	            if (m_key_ == null) {
	                m_hashCode_ = 1;
	            } else {
	                int size = m_key_.Length >> 1;
	                StringBuilder key = new StringBuilder(size);
	                int i = 0;
	                while (m_key_[i] != 0 && m_key_[i + 1] != 0) {
	                    key.Append((char) ((m_key_[i] << 8) | m_key_[i + 1]));
	                    i += 2;
	                }
	                if (m_key_[i] != 0) {
	                    key.Append((char) (m_key_[i] << 8));
	                }
	                m_hashCode_ = key.ToString().GetHashCode();
	            }
	        }
	        return m_hashCode_;
	    }
	
	    /// <summary>
	    /// <p>
	    /// Produce a bound for the sort order of a given collation key and a
	    /// strength level. This API does not attempt to find a bound for the
	    /// CollationKey String representation, hence null will be returned in its
	    /// place.
	    /// </p>
	    /// <p>
	    /// Resulting bounds can be used to produce a range of strings that are
	    /// between upper and lower bounds. For example, if bounds are produced for a
	    /// sortkey of string "smith", strings between upper and lower bounds with
	    /// primary strength would include "Smith", "SMITH", "sMiTh".
	    /// </p>
	    /// <p>
	    /// There are two upper bounds that can be produced. If BoundMode.UPPER is
	    /// produced, strings matched would be as above. However, if a bound is
	    /// produced using BoundMode.UPPER_LONG is used, the above example will also
	    /// match "Smithsonian" and similar.
	    /// </p>
	    /// <p>
	    /// For more on usage, see example in test procedure <a href=
	    /// "http://source.icu-project.org/repos/icu/icu4j/trunk/src/com/ibm/icu/dev/test/collator/CollationAPITest.java"
	    /// > src/com/ibm/icu/dev/test/collator/CollationAPITest/TestBounds. </a>
	    /// </p>
	    /// <p>
	    /// Collation keys produced may be compared using the <TT>compare</TT> API.
	    /// </p>
	    /// </summary>
	    ///
	    /// <param name="boundType">Mode of bound required. It can be BoundMode.LOWER, whichproduces a lower inclusive bound, BoundMode.UPPER, thatproduces upper bound that matches strings of the same lengthor BoundMode.UPPER_LONG that matches strings that have thesame starting substring as the source string.</param>
	    /// <param name="noOfLevels">Strength levels required in the resulting bound (for mostuses, the recommended value is PRIMARY). This strength shouldbe less than the maximum strength of this CollationKey. Seeusers guide for explanation on the strength levels a collationkey can have.</param>
	    /// <returns>the result bounded CollationKey with a valid sort order but a
	    /// null String representation.</returns>
	    /// <exception cref="IllegalArgumentException">thrown when the strength level requested is higher than orequal to the strength in this CollationKey. In the case ofan Exception, information about the maximum strength touse will be returned in the Exception. The user can thencall getBound() again with the appropriate strength.</exception>
	    /// <seealso cref="T:IBM.ICU.Text.CollationKey"/>
	    /// <seealso cref="T:IBM.ICU.Text.BoundMode"/>
	    /// <seealso cref="M:IBM.ICU.Text.Collator.PRIMARY"/>
	    /// <seealso cref="M:IBM.ICU.Text.Collator.SECONDARY"/>
	    /// <seealso cref="M:IBM.ICU.Text.Collator.TERTIARY"/>
	    /// <seealso cref="M:IBM.ICU.Text.Collator.QUATERNARY"/>
	    /// <seealso cref="M:IBM.ICU.Text.Collator.IDENTICAL"/>
	    /// @stable ICU 2.6
	    public CollationKey GetBound(int boundType, int noOfLevels) {
	        // Scan the string until we skip enough of the key OR reach the end of
	        // the key
	        int offset = 0;
	        int keystrength = IBM.ICU.Text.Collator.PRIMARY;
	
	        if (noOfLevels > IBM.ICU.Text.Collator.PRIMARY) {
	            while (offset < m_key_.Length && m_key_[offset] != 0) {
	                if (m_key_[offset++] == IBM.ICU.Text.RuleBasedCollator.SORT_LEVEL_TERMINATOR_) {
	                    keystrength++;
	                    noOfLevels--;
	                    if (noOfLevels == IBM.ICU.Text.Collator.PRIMARY
	                            || offset == m_key_.Length || m_key_[offset] == 0) {
	                        offset--;
	                        break;
	                    }
	                }
	            }
	        }
	
	        if (noOfLevels > 0) {
	            throw new ArgumentException("Source collation key has only "
	                    + keystrength + " strength level. Call getBound() again "
	                    + " with noOfLevels < " + keystrength);
	        }
	
	        byte[] resultkey = new byte[offset + boundType + 1];
	        System.Array.Copy((Array)(m_key_),0,(Array)(resultkey),0,offset);
	        switch (boundType) {
	        case IBM.ICU.Text.CollationKey.BoundMode.LOWER: // = 0
	            // Lower bound just gets terminated. No extra bytes
	            break;
	        case IBM.ICU.Text.CollationKey.BoundMode.UPPER: // = 1
	            // Upper bound needs one extra byte
	            resultkey[offset++] = 2;
	            break;
	        case IBM.ICU.Text.CollationKey.BoundMode.UPPER_LONG: // = 2
	            // Upper long bound needs two extra bytes
	            resultkey[offset++] = (byte) 0xFF;
	            resultkey[offset++] = (byte) 0xFF;
	            break;
	        default:
	            throw new ArgumentException("Illegal boundType argument");
	        }
	        resultkey[offset++] = 0;
	        return new CollationKey(null, resultkey);
	    }
	
	    /// <summary>
	    /// <p>
	    /// Merges this CollationKey with another. Only the sorting order of the
	    /// CollationKeys will be merged. This API does not attempt to merge the
	    /// String representations of the CollationKeys, hence null will be returned
	    /// as the String representation.
	    /// </p>
	    /// <p>
	    /// The strength levels are merged with their corresponding counterparts
	    /// (PRIMARIES with PRIMARIES, SECONDARIES with SECONDARIES etc.).
	    /// </p>
	    /// <p>
	    /// The merged String representation of the result CollationKey will be a
	    /// concatenation of the String representations of the 2 source
	    /// CollationKeys.
	    /// </p>
	    /// <p>
	    /// Between the values from the same level a separator is inserted. example
	    /// (uncompressed):
	    /// <pre>
	    /// 191B1D 01 050505 01 910505 00 and 1F2123 01 050505 01 910505 00
	    /// will be merged as 
	    /// 191B1D 02 1F212301 050505 02 050505 01 910505 02 910505 00
	    /// </pre>
	    /// </p>
	    /// <p>
	    /// This allows for concatenating of first and last names for sorting, among
	    /// other things.
	    /// </p>
	    /// </p>
	    /// </summary>
	    ///
	    /// <param name="source">CollationKey to merge with</param>
	    /// <returns>a CollationKey that contains the valid merged sorting order with
	    /// a null String representation, i.e.
	    /// <tt>new CollationKey(null, merge_sort_order)</tt></returns>
	    /// <exception cref="IllegalArgumentException">thrown if source CollationKey argument is null or of 0length.</exception>
	    /// @stable ICU 2.6
	    public CollationKey Merge(CollationKey source) {
	        // check arguments
	        if (source == null || source.GetLength() == 0) {
	            throw new ArgumentException(
	                    "CollationKey argument can not be null or of 0 length");
	        }
	
	        GetLength(); // gets the length of this sort key
	        int sourcelength = source.GetLength();
	        byte[] result = new byte[m_length_ + sourcelength + 2];
	
	        // merge the sort keys with the same number of levels
	        int rindex = 0;
	        int index = 0;
	        int sourceindex = 0;
	        while (true) {
	            // while both have another level
	            // copy level from src1 not including 00 or 01
	            // unsigned issues
	            while (m_key_[index] < 0 || m_key_[index] >= MERGE_SEPERATOR_) {
	                result[rindex++] = m_key_[index++];
	            }
	
	            // add a 02 merge separator
	            result[rindex++] = MERGE_SEPERATOR_;
	
	            // copy level from src2 not including 00 or 01
	            while (source.m_key_[sourceindex] < 0
	                    || source.m_key_[sourceindex] >= MERGE_SEPERATOR_) {
	                result[rindex++] = source.m_key_[sourceindex++];
	            }
	
	            // if both sort keys have another level, then add a 01 level
	            // separator and continue
	            if (m_key_[index] == IBM.ICU.Text.RuleBasedCollator.SORT_LEVEL_TERMINATOR_
	                    && source.m_key_[sourceindex] == IBM.ICU.Text.RuleBasedCollator.SORT_LEVEL_TERMINATOR_) {
	                ++index;
	                ++sourceindex;
	                result[rindex++] = IBM.ICU.Text.RuleBasedCollator.SORT_LEVEL_TERMINATOR_;
	            } else {
	                break;
	            }
	        }
	
	        // here, at least one sort key is finished now, but the other one
	        // might have some contents left from containing more levels;
	        // that contents is just appended to the result
	        if (m_key_[index] != 0) {
	            System.Array.Copy((Array)(m_key_),index,(Array)(result),rindex,m_length_ - index);
	        } else if (source.m_key_[sourceindex] != 0) {
	            System.Array.Copy((Array)(source.m_key_),sourceindex,(Array)(result),rindex,source.m_length_ - sourceindex);
	        }
	        result[result.Length - 1] = 0;
	
	        // trust that neither sort key contained illegally embedded zero bytes
	        return new CollationKey(null, result);
	    }
	
	    // private data members -------------------------------------------------
	
	    /// <summary>
	    /// Sequence of bytes that represents the sort key
	    /// </summary>
	    ///
	    private byte[] m_key_;
	
	    /// <summary>
	    /// Source string this CollationKey represents
	    /// </summary>
	    ///
	    private String m_source_;
	
	    /// <summary>
	    /// Hash code for the key
	    /// </summary>
	    ///
	    private int m_hashCode_;
	
	    /// <summary>
	    /// Gets the length of this CollationKey
	    /// </summary>
	    ///
	    private int m_length_;
	
	    /// <summary>
	    /// Collation key merge seperator
	    /// </summary>
	    ///
	    private const int MERGE_SEPERATOR_ = 2;
	
	    // private methods ------------------------------------------------------
	
	    /// <summary>
	    /// Gets the length of the CollationKey
	    /// </summary>
	    ///
	    /// <returns>length of the CollationKey</returns>
	    private int GetLength() {
	        if (m_length_ >= 0) {
	            return m_length_;
	        }
	        int length = m_key_.Length;
	        for (int index = 0; index < length; index++) {
	            if (m_key_[index] == 0) {
	                length = index;
	                break;
	            }
	        }
	        m_length_ = length;
	        return m_length_;
	    }
	}
}
