//##header J2SE15
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/13/10 4:01 PM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /*
 *******************************************************************************
 * Copyright (C) 1996-2007, International Business Machines Corporation and    *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 */
namespace IBM.ICU.Charset {
	
	using IBM.ICU.Text;
	using ILOG.J2CsMapping.Collections;
	using ILOG.J2CsMapping.Collections.Generics;
	using ILOG.J2CsMapping.Text;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Text;
	
	/// <summary>
	/// Utilities that ought to be on collections, but aren't
	/// </summary>
	///
	public sealed class CollectionUtilities {
	
	    public static String Join(Object[] array, String separator) {
	        StringBuilder result = new StringBuilder();
	        for (int i = 0; i < array.Length; ++i) {
	            if (i != 0)
	                result.Append(separator);
	            result.Append(array[i]);
	        }
	        return result.ToString();
	    }
	
	    public static String Join(ICollection collection, String separator) {
	        StringBuilder result = new StringBuilder();
	        bool first = true;
	        for (IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(collection.GetEnumerator()); it.HasNext();) {
	            if (first)
	                first = false;
	            else
	                result.Append(separator);
	            result.Append(it.Next());
	        }
	        return result.ToString();
	    }
	
	    /// <summary>
	    /// Utility like Arrays.asList()
	    /// </summary>
	    ///
	    public static IDictionary AsMap(Object[][] source, IDictionary target, bool reverse) {
	        int from = 0, to = 1;
	        if (reverse) {
	            from = 1;
	            to = 0;
	        }
	        for (int i = 0; i < source.Length; ++i) {
	            ILOG.J2CsMapping.Collections.Collections.Put(target,source[i][from],source[i][to]);
	        }
	        return target;
	    }
	
	    public static ICollection AddAll(IIterator source, ICollection target) {
	        while (source.HasNext()) {
	            ILOG.J2CsMapping.Collections.Collections.Add(target,source.Next());
	        }
	        return target; // for chaining
	    }
	
	    public static int Size(IIterator source) {
	        int result = 0;
	        while (source.HasNext()) {
	            source.Next();
	            ++result;
	        }
	        return result;
	    }
	
	    public static IDictionary AsMap(Object[][] source) {
	        return AsMap(source, new Hashtable(), false);
	    }
	
	    /// <summary>
	    /// Utility that ought to be on Map
	    /// </summary>
	    ///
	    public static IDictionary RemoveAll(IDictionary m, ICollection itemsToRemove) {
	        for (IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(itemsToRemove.GetEnumerator()); it.HasNext();) {
	            Object item = it.Next();
	            ILOG.J2CsMapping.Collections.Collections.Remove(m,item);
	        }
	        return m;
	    }
	
	    public Object GetFirst(ICollection c) {
	        IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(c.GetEnumerator());
	        if (!it.HasNext())
	            return null;
	        return it.Next();
	    }
	
	    public static Object GetBest(ICollection c, IComparer comp, int direction) {
	        IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(c.GetEnumerator());
	        if (!it.HasNext())
	            return null;
	        Object bestSoFar = it.Next();
	        if (direction < 0) {
	            while (it.HasNext()) {
	                Object item = it.Next();
	                int compValue = comp.Compare(item, bestSoFar);
	                if (compValue < 0) {
	                    bestSoFar = item;
	                }
	            }
	        } else {
	            while (it.HasNext()) {
	                Object item_0 = it.Next();
	                int compValue_1 = comp.Compare(item_0, bestSoFar);
	                if (compValue_1 > 0) {
	                    bestSoFar = item_0;
	                }
	            }
	        }
	        return bestSoFar;
	    }
	
	    public interface ObjectMatcher {
	        /// <summary>
	        /// Must handle null, never throw exception
	        /// </summary>
	        ///
	        bool Matches(Object o);
	    }
	
	    public class InverseMatcher : CollectionUtilities.ObjectMatcher  {
	        internal CollectionUtilities.ObjectMatcher  other;
	
	        public CollectionUtilities.ObjectMatcher  Set(CollectionUtilities.ObjectMatcher  toInverse) {
	            other = toInverse;
	            return this;
	        }
	
	        public virtual bool Matches(Object value_ren) {
	            return !other.Matches(value_ren);
	        }
	    }
	
	    public static ICollection RemoveAll(ICollection c, CollectionUtilities.ObjectMatcher  f) {
	        for (IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(c.GetEnumerator()); it.HasNext();) {
	            Object item = it.Next();
	            if (f.Matches(item))
	                it.Remove();
	        }
	        return c;
	    }
	
	    public static ICollection RetainAll(ICollection c, CollectionUtilities.ObjectMatcher  f) {
	        for (IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(c.GetEnumerator()); it.HasNext();) {
	            Object item = it.Next();
	            if (!f.Matches(item))
	                it.Remove();
	        }
	        return c;
	    }
	
	    public static bool ContainsSome(ICollection a, ICollection b) {
	        // fast paths
	        if (a.Count == 0 || b.Count == 0)
	            return false;
	        if (a == b)
	            return true; // must test after size test.

            throw new NotImplementedException();
            /*
	        if (a  is  SortedSet && b  is  SortedSet) {
	            SortedSet aa = (SortedSet) a;
	            SortedSet bb = (SortedSet) b;
	            ILOG.J2CsMapping.Collections.Collections.ContainsAll(aa,null);
	            IComparer bbc = bb.Comparator();
	            IComparer aac = aa.Comparator();
	            if (bbc == null) {
	                if (aac == null) {
	                    IIterator ai = new ILOG.J2CsMapping.Collections.IteratorAdapter(aa.GetEnumerator());
	                    IIterator bi = new ILOG.J2CsMapping.Collections.IteratorAdapter(bb.GetEnumerator());
	                    IComparable ao = (IComparable) ai.Next(); // these are ok,
	                                                            // since the sizes
	                                                            // are != 0
	                    IComparable bo = (IComparable) bi.Next();
	                    while (true) {
	                        int rel = ao.CompareTo(bo);
	                        if (rel < 0) {
	                            if (!ai.HasNext())
	                                return false;
	                            ao = (IComparable) ai.Next();
	                        } else if (rel > 0) {
	                            if (!bi.HasNext())
	                                return false;
	                            bo = (IComparable) bi.Next();
	                        } else {
	                            return true;
	                        }
	                    }
	                }
	            } else if (bbc.Equals(a)) {
	                IIterator ai_0 = new ILOG.J2CsMapping.Collections.IteratorAdapter(aa.GetEnumerator());
	                IIterator bi_1 = new ILOG.J2CsMapping.Collections.IteratorAdapter(bb.GetEnumerator());
	                Object ao_2 = ai_0.Next(); // these are ok, since the sizes are != 0
	                Object bo_3 = bi_1.Next();
	                while (true) {
	                    int rel_4 = aac.Compare(ao_2, bo_3);
	                    if (rel_4 < 0) {
	                        if (!ai_0.HasNext())
	                            return false;
	                        ao_2 = ai_0.Next();
	                    } else if (rel_4 > 0) {
	                        if (!bi_1.HasNext())
	                            return false;
	                        bo_3 = bi_1.Next();
	                    } else {
	                        return true;
	                    }
	                }
	            }
	        }
	        for (IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(a.GetEnumerator()); it.HasNext();) {
	            if (ILOG.J2CsMapping.Collections.Collections.Contains(it.Next(),b))
	                return true;
	        }*/
	        return false;
	    }
	
	    public static bool ContainsAll(ICollection a, ICollection b) {
	        // fast paths
	        if (a == b)
	            return true;
	        if (b.Count == 0)
	            return true;
	        if (a.Count == 0)
	            return false;

            throw new NotImplementedException();
            /*
	        if (a  is  SortedSet && b  is  SortedSet) {
	            SortedSet aa = (SortedSet) a;
	            SortedSet bb = (SortedSet) b;
	            IComparer bbc = bb.Comparator();
	            IComparer aac = aa.Comparator();
	            if (bbc == null) {
	                if (aac == null) {
	                    IIterator ai = new ILOG.J2CsMapping.Collections.IteratorAdapter(aa.GetEnumerator());
	                    IIterator bi = new ILOG.J2CsMapping.Collections.IteratorAdapter(bb.GetEnumerator());
	                    IComparable ao = (IComparable) ai.Next(); // these are ok,
	                                                            // since the sizes
	                                                            // are != 0
	                    IComparable bo = (IComparable) bi.Next();
	                    while (true) {
	                        int rel = ao.CompareTo(bo);
	                        if (rel == 0) {
	                            if (!bi.HasNext())
	                                return true;
	                            if (!ai.HasNext())
	                                return false;
	                            bo = (IComparable) bi.Next();
	                            ao = (IComparable) ai.Next();
	                        } else if (rel < 0) {
	                            if (!ai.HasNext())
	                                return false;
	                            ao = (IComparable) ai.Next();
	                        } else {
	                            return false;
	                        }
	                    }
	                }
	            } else if (bbc.Equals(a)) {
	                IIterator ai_0 = new ILOG.J2CsMapping.Collections.IteratorAdapter(aa.GetEnumerator());
	                IIterator bi_1 = new ILOG.J2CsMapping.Collections.IteratorAdapter(bb.GetEnumerator());
	                Object ao_2 = ai_0.Next(); // these are ok, since the sizes are != 0
	                Object bo_3 = bi_1.Next();
	                while (true) {
	                    int rel_4 = aac.Compare(ao_2, bo_3);
	                    if (rel_4 == 0) {
	                        if (!bi_1.HasNext())
	                            return true;
	                        if (!ai_0.HasNext())
	                            return false;
	                        bo_3 = bi_1.Next();
	                        ao_2 = ai_0.Next();
	                    } else if (rel_4 < 0) {
	                        if (!ai_0.HasNext())
	                            return false;
	                        ao_2 = ai_0.Next();
	                    } else {
	                        return false;
	                    }
	                }
	            }
	        }
	        return ILOG.J2CsMapping.Collections.Collections.ContainsAll(a,b);*/
	    }
	
	    public static bool ContainsNone(ICollection a, ICollection b) {
	        return !ContainsSome(a, b);
	    }
	
	    /// <summary>
	    /// Used for results of getContainmentRelation
	    /// </summary>
	    ///
	    public const int ALL_EMPTY = 0, NOT_A_SUPERSET_B = 1,
	            NOT_A_DISJOINT_B = 2, NOT_A_SUBSET_B = 4,
	            NOT_A_EQUALS_B = NOT_A_SUBSET_B | NOT_A_SUPERSET_B,
	            A_PROPER_SUBSET_OF_B = NOT_A_DISJOINT_B | NOT_A_SUPERSET_B,
	            A_PROPER_SUPERSET_B = NOT_A_SUBSET_B | NOT_A_DISJOINT_B,
	            A_PROPER_OVERLAPS_B = NOT_A_SUBSET_B | NOT_A_DISJOINT_B
	                    | NOT_A_SUPERSET_B;
	
	    /// <summary>
	    /// Assesses all the possible containment relations between collections A and
	    /// B with one call.<br>
	    /// Returns an int with bits set, according to a "Venn Diagram" view of A vs
	    /// B.<br>
	    /// NOT_A_SUPERSET_B: a - b != {}<br>
	    /// NOT_A_DISJOINT_B: a/// b != {} ///// is intersects<br>
	    /// NOT_A_SUBSET_B: b - a != {}<br>
	    /// Thus the bits can be used to get the following relations:<br>
	    /// for A_SUPERSET_B, use (x & CollectionUtilities.NOT_A_SUPERSET_B) == 0<br>
	    /// for A_SUBSET_B, use (x & CollectionUtilities.NOT_A_SUBSET_B) == 0<br>
	    /// for A_EQUALS_B, use (x & CollectionUtilities.NOT_A_EQUALS_B) == 0<br>
	    /// for A_DISJOINT_B, use (x & CollectionUtilities.NOT_A_DISJOINT_B) == 0<br>
	    /// for A_OVERLAPS_B, use (x & CollectionUtilities.NOT_A_DISJOINT_B) != 0<br>
	    /// </summary>
	    ///
	    public static int GetContainmentRelation(ICollection a, ICollection b) {
	        if (a.Count == 0) {
	            return (b.Count == 0) ? ALL_EMPTY : NOT_A_SUPERSET_B;
	        } else if (b.Count == 0) {
	            return NOT_A_SUBSET_B;
	        }
	        int result = 0;
	        // WARNING: one might think that the following can be short-circuited,
	        // by looking at
	        // the sizes of a and b. However, this would fail in general, where a
	        // different comparator is being
	        // used in the two collections. Unfortunately, there is no failsafe way
	        // to test for that.
	        for (IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(a.GetEnumerator()); result != 6 && it.HasNext();) {
	            result |= (ILOG.J2CsMapping.Collections.Collections.Contains(it.Next(),b)) ? NOT_A_DISJOINT_B
	                    : NOT_A_SUBSET_B;
	        }
	        for (IIterator it_0 = new ILOG.J2CsMapping.Collections.IteratorAdapter(b.GetEnumerator()); (result & 3) != 3 && it_0.HasNext();) {
	            result |= (ILOG.J2CsMapping.Collections.Collections.Contains(it_0.Next(),a)) ? NOT_A_DISJOINT_B
	                    : NOT_A_SUPERSET_B;
	        }
	        return result;
	    }
	
	    public static String Remove(String source, UnicodeSet removals) {
	        StringBuilder result = new StringBuilder();
	        int cp;
	        for (int i = 0; i < source.Length; i += IBM.ICU.Text.UTF16.GetCharCount(cp)) {
	            cp = IBM.ICU.Text.UTF16.CharAt(source, i);
	            if (!removals.Contains(cp))
	                IBM.ICU.Text.UTF16.Append(result, cp);
	        }
	        return result.ToString();
	    }
	
	    // #if defined(FOUNDATION10) || defined(J2SE13)
	    // #else
	    /// <summary>
	    /// Does one string contain another, starting at a specific offset?
	    /// </summary>
	    ///
	    /// <param name="text"></param>
	    /// <param name="offset"></param>
	    /// <param name="other_0"></param>
	    /// <returns></returns>
	    public static int MatchesAt(String text, int offset,
	            String other_0) {
	        int len = other_0.Length;
	        int i = 0;
	        int j = offset;
	        for (; i < len; ++i, ++j) {
	            char pc = other_0[i];
	            char tc = text[j];
	            if (pc != tc)
	                return -1;
	        }
	        return i;
	    }
	
	    /// <summary>
	    /// Returns the ending offset found by matching characters with testSet,
	    /// until a position is found that doen't match
	    /// </summary>
	    ///
	    /// <param name="string"></param>
	    /// <param name="offset"></param>
	    /// <param name="testSet"></param>
	    /// <returns></returns>
	    public int Span(String str0, int offset, UnicodeSet testSet) {
	        while (true) {
	            int newOffset = testSet.MatchesAt(str0, offset);
	            if (newOffset < 0)
	                return offset;
	        }
	    }
	
	    /// <summary>
	    /// Returns the ending offset found by matching characters with testSet,
	    /// until a position is found that does match
	    /// </summary>
	    ///
	    /// <param name="string"></param>
	    /// <param name="offset"></param>
	    /// <param name="testSet"></param>
	    /// <returns></returns>
	    public int SpanNot(String str0, int offset, UnicodeSet testSet) {
	        while (true) {
	            int newOffset = testSet.MatchesAt(str0, offset);
	            if (newOffset >= 0)
	                return offset;
	            ++offset; // try next character position
	            // we don't have to worry about surrogates for this.
	        }
	    }
	
	    // #endif
	
	    public static String PrettyPrint(UnicodeSet uset, bool compressRanges,
	            UnicodeSet toQuote, Transliterator quoter, IComparer ordering,
	            IComparer spaceComparator) {
	        PrettyPrinter pp = new PrettyPrinter()
	                .SetCompressRanges(compressRanges);
	        if (toQuote != null)
	            pp.SetToQuote(toQuote);
	        if (ordering != null)
	            pp.SetOrdering(ordering);
	        if (spaceComparator != null)
	            pp.SetSpaceComparator(spaceComparator);
	        return pp.ToPattern(uset);
	    }
	
	    public class MultiComparator : IComparer {
	        private IComparer[] comparators;
	
	        public MultiComparator(IComparer[] comparators_0) {
	            this.comparators = comparators_0;
	        }
	
	        /*
	         * Lexigraphic compare. Returns the first difference
	         * 
	         * @return zero if equal. Otherwise +/- (i+1) where i is the index of
	         * the first comparator finding a difference
	         * 
	         * @see java.util.Comparator#compare(java.lang.Object, java.lang.Object)
	         */
	        public virtual int Compare(Object arg0, Object arg1) {
	            for (int i = 0; i < comparators.Length; ++i) {
	                int result = comparators[i].Compare(arg0, arg1);
	                if (result == 0)
	                    continue;
	                if (result > 0)
	                    return i + 1;
	                return -(i + 1);
	            }
	            return 0;
	        }
	    }
	
	    /// <summary>
	    /// Modifies Unicode set to flatten the strings. Eg [abc{da}] => [abcd]
	    /// Returns the set for chaining.
	    /// </summary>
	    ///
	    /// <param name="exemplar1"></param>
	    /// <returns></returns>
	    public static UnicodeSet Flatten(UnicodeSet exemplar1) {
	        UnicodeSet result = new UnicodeSet();
	        bool gotString = false;
	        for (UnicodeSetIterator it = new UnicodeSetIterator(exemplar1); it
	                .NextRange();) {
	            if (it.codepoint == IBM.ICU.Text.UnicodeSetIterator.IS_STRING) {
	                result.AddAll(it.str0);
	                gotString = true;
	            } else {
	                result.Add(it.codepoint, it.codepointEnd);
	            }
	        }
	        if (gotString)
	            exemplar1.Set(result);
	        return exemplar1;
	    }
	
	    /// <summary>
	    /// For producing filtered iterators
	    /// </summary>
	    ///
	    public abstract class FilteredIterator : IIterator {
	        public FilteredIterator() {
	            this.nextObject = EMPTY;
	        }
	
	        private IIterator baseIterator;
	
	        private static readonly Object EMPTY = new Object();
	
	        private static readonly Object DONE = new Object();
	
	        private Object nextObject;
	
	        public CollectionUtilities.FilteredIterator  Set(IIterator baseIterator_0) {
	            this.baseIterator = baseIterator_0;
	            return this;
	        }
	
	        public virtual void Remove() {
	            throw new NotSupportedException("Doesn't support removal");
	        }
	
	        public virtual Object Next() {
	            Object result = nextObject;
	            nextObject = EMPTY;
	            return result;
	        }
	
	        public virtual bool HasNext() {
	            if (nextObject == DONE)
	                return false;
	            if (nextObject != EMPTY)
	                return true;
	            while (baseIterator.HasNext()) {
	                nextObject = baseIterator.Next();
	                if (IsIncluded(nextObject)) {
	                    return true;
	                }
	            }
	            nextObject = DONE;
	            return false;
	        }
	
	        abstract public bool IsIncluded(Object item);
	    
		#region AddedByTranslator
	
		object ILOG.J2CsMapping.Collections.IIterator.Next()
	            {
	                return this.Next();
	            }
	
		#endregion
	
	}
	
	    public class PrefixIterator : CollectionUtilities.FilteredIterator  {
	        private String prefix;
	
	        public CollectionUtilities.PrefixIterator  Set(IIterator baseIterator_0, String prefix_1) {
	            base.Set(baseIterator_0);
	            this.prefix = prefix_1;
	            return this;
	        }
	
	        public override bool IsIncluded(Object item) {
	            return ((String) item).StartsWith(prefix);
	        }
	    }
	
	    // #if defined(FOUNDATION10) || defined(J2SE13)
	    // #else
	    public class RegexIterator : CollectionUtilities.FilteredIterator  {
	        private ILOG.J2CsMapping.RegEx.Matcher matcher;

            public CollectionUtilities.RegexIterator Set(IIterator baseIterator_0, ILOG.J2CsMapping.RegEx.Matcher matcher_1)
            {
	            base.Set(baseIterator_0);
	            this.matcher = matcher_1;
	            return this;
	        }
	
	        public override bool IsIncluded(Object item) {
	            return matcher.Reset((String) item).Matches();
	        }
	    }
	    // #endif
	}
}
