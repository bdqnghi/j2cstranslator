/*
 * @(#)TimeZone.java    1.51 00/01/19
 *
 * Copyright (C) 1996-2007, International Business Machines
 * Corporation and others.  All Rights Reserved.
 */

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:48 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Util {
	
	using IBM.ICU.Text;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.Globalization;
	using System.IO;
	using System.Resources;
	using System.Runtime.CompilerServices;
	using System.Runtime.Serialization;
     using ILOG.J2CsMapping.Util;
	
	/// <summary>
	/// <c>TimeZone</c> represents a time zone offset, and also figures out
	/// daylight savings.
	/// <p>
	/// Typically, you get a <c>TimeZone</c> using <c>getDefault</c>
	/// which creates a <c>TimeZone</c> based on the time zone where the
	/// program is running. For example, for a program running in Japan,
	/// <c>getDefault</c> creates a <c>TimeZone</c> object based on
	/// Japanese Standard Time.
	/// <p>
	/// You can also get a <c>TimeZone</c> using <c>getTimeZone</c> along
	/// with a time zone ID. For instance, the time zone ID for the U.S. Pacific Time
	/// zone is "America/Los_Angeles". So, you can get a U.S. Pacific Time
	/// <c>TimeZone</c> object with: <blockquote>
	/// <pre>
	/// TimeZone tz = TimeZone.getTimeZone(&quot;America/Los_Angeles&quot;);
	/// </pre>
	/// </blockquote> You can use <c>getAvailableIDs</c> method to iterate
	/// through all the supported time zone IDs. You can then choose a supported ID
	/// to get a <c>TimeZone</c>. If the time zone you want is not represented
	/// by one of the supported IDs, then you can create a custom time zone ID with
	/// the following syntax:
	/// <blockquote>
	/// <pre>
	/// GMT[+|-]hh[[:]mm]
	/// </pre>
	/// </blockquote>
	/// For example, you might specify GMT+14:00 as a custom time zone ID. The
	/// <c>TimeZone</c> that is returned when you specify a custom time zone ID
	/// does not include daylight savings time.
	/// <p>
	/// For compatibility with JDK 1.1.x, some other three-letter time zone IDs (such
	/// as "PST", "CTT", "AST") are also supported. However, <strong>their use is
	/// deprecated</strong> because the same abbreviation is often used for multiple
	/// time zones (for example, "CST" could be U.S. "Central Standard
	/// Time" and "China Standard Time"), and the Java platform can then only
	/// recognize one of them.
	/// </summary>
	///
	/// <seealso cref="T:IBM.ICU.Util.Calendar"/>
	/// <seealso cref="T:IBM.ICU.Util.GregorianCalendar"/>
	/// <seealso cref="T:IBM.ICU.Util.SimpleTimeZone"/>
	/// @stable ICU 2.0
	[Serializable]
	abstract public class TimeZone : ICloneable {
	    // using serialver from jdk1.4.2_05
	    private const long serialVersionUID = -744942128318337471L;
	
	    /// <summary>
	    /// Default constructor. (For invocation by subclass constructors, typically
	    /// implicit.)
	    /// </summary>
	    ///
	    /// @stable ICU 2.8
	    public TimeZone() {
	    }
	
	    /// <summary>
	    /// A style specifier for <c>getDisplayName()</c> indicating a short
	    /// name, such as "PST."
	    /// </summary>
	    ///
	    /// <seealso cref="F:IBM.ICU.Util.TimeZone.LONG"/>
	    /// @stable ICU 2.0
	    public const int SHORT = 0;
	
	    /// <summary>
	    /// A style specifier for <c>getDisplayName()</c> indicating a long
	    /// name, such as "Pacific Standard Time."
	    /// </summary>
	    ///
	    /// <seealso cref="F:IBM.ICU.Util.TimeZone.SHORT"/>
	    /// @stable ICU 2.0
	    public const int LONG = 1;
	
	    /// <exclude/>
	    private const int SHORT_GENERIC = 2;
	
	    /// <exclude/>
	    private const int LONG_GENERIC = 3;
	
	    /// <summary>
	    /// Cache to hold the SimpleDateFormat objects for a Locale.
	    /// </summary>
	    ///
	    private static Hashtable cachedLocaleData = new Hashtable(3);
	
	    /// <summary>
	    /// Gets the time zone offset, for current date, modified in case of daylight
	    /// savings. This is the offset to add///to/// UTC to get local time.
	    /// </summary>
	    ///
	    /// <param name="era">the era of the given date.</param>
	    /// <param name="year">the year in the given date.</param>
	    /// <param name="month">the month in the given date. Month is 0-based. e.g., 0 forJanuary.</param>
	    /// <param name="day">the day-in-month of the given date.</param>
	    /// <param name="dayOfWeek">the day-of-week of the given date.</param>
	    /// <param name="milliseconds">the millis in day in <em>standard</em> local time.</param>
	    /// <returns>the offset to add ///to/// GMT to get local time.</returns>
	    /// @stable ICU 2.0
	    abstract public int GetOffset(int era, int year, int month, int day,
	            int dayOfWeek, int milliseconds);
	
	    /// <summary>
	    /// Returns the offset of this time zone from UTC at the specified date. If
	    /// Daylight Saving Time is in effect at the specified date, the offset value
	    /// is adjusted with the amount of daylight saving.
	    /// </summary>
	    ///
	    /// <param name="date">the date represented in milliseconds since January 1, 197000:00:00 GMT</param>
	    /// <returns>the amount of time in milliseconds to add to UTC to get local
	    /// time.</returns>
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.ZONE_OFFSET"/>
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.DST_OFFSET"/>
	    /// <seealso cref="M:IBM.ICU.Util.TimeZone.GetOffset(System.Int64, System.Boolean, null)"/>
	    /// @stable ICU 2.8
	    public int GetOffset(long date) {
	        int[] result = new int[2];
	        GetOffset(date, false, result);
	        return result[0] + result[1];
	    }
	
	    /// <summary>
	    /// Returns the time zone raw and GMT offset for the given moment in time.
	    /// Upon return, local-millis = GMT-millis + rawOffset + dstOffset. All
	    /// computations are performed in the proleptic Gregorian calendar. The
	    /// default implementation in the TimeZone class delegates to the 8-argument
	    /// getOffset().
	    /// </summary>
	    ///
	    /// <param name="date">moment in time for which to return offsets, in units ofmilliseconds from January 1, 1970 0:00 GMT, either GMT time orlocal wall time, depending on `local'.</param>
	    /// <param name="local">if true, `date' is local wall time; otherwise it is in GMTtime.</param>
	    /// <param name="offsets">output parameter to receive the raw offset, that is, theoffset not including DST adjustments, in offsets[0], and theDST offset, that is, the offset to be added to `rawOffset' toobtain the total offset between local and GMT time, inoffsets[1]. If DST is not in effect, the DST offset is zero;otherwise it is a positive value, typically one hour.</param>
	    /// @stable ICU 2.8
	    public virtual void GetOffset(long date, bool local, int[] offsets) {
	        offsets[0] = GetRawOffset();
	        if (!local) {
	            date += offsets[0]; // now in local standard millis
	        }
	
	        int[] fields = new int[4];
	        for (int pass = 0;; pass++) {
	            long day = FloorDivide(date, IBM.ICU.Impl.Grego.MILLIS_PER_DAY, fields);
	            int millis = fields[0];
	
	            ComputeGregorianFields(day, fields);
	            offsets[1] = GetOffset(IBM.ICU.Util.GregorianCalendar.AD, fields[0], fields[1],
	                    fields[2], fields[3], millis) - offsets[0];
	
	            if (pass != 0 || !local || offsets[1] == 0) {
	                break;
	            }
	            // adjust to local standard millis
	            date -= offsets[1];
	        }
	    }
	
	    /// <summary>
	    /// Divide two long integers, returning the floor of the quotient.
	    /// <p>
	    /// Unlike the built-in division, this is mathematically well-behaved. E.g.,
	    /// <code>-1/4</code> => 0 but <c>floorDivide(-1,4)</c> => -1. TODO:
	    /// This duplicates a method in Calendar; clean up and consolidate in ICU
	    /// 3.0.
	    /// </summary>
	    ///
	    /// <param name="numerator">the numerator</param>
	    /// <param name="denominator">a divisor which must be > 0</param>
	    /// <returns>the floor of the quotient.</returns>
	    static internal long FloorDivide(long numerator, long denominator) {
	        // We do this computation in order to handle
	        // a numerator of Long.MIN_VALUE correctly
	        return (numerator >= 0) ? numerator / denominator
	                : ((numerator + 1) / denominator) - 1;
	    }
	
	    /// <summary>
	    /// Divide two integers, returning the floor of the quotient, and the modulus
	    /// remainder.
	    /// <p>
	    /// Unlike the built-in division, this is mathematically well-behaved. E.g.,
	    /// <code>-1/4</code> => 0 and <c>-1%4</c> => -1, but
	    /// <c>floorDivide(-1,4)</c> => -1 with <c>remainder[0]</c> => 3.
	    /// TODO: This duplicates a method in Calendar; clean up and consolidate in
	    /// ICU 3.0.
	    /// </summary>
	    ///
	    /// <param name="numerator">the numerator</param>
	    /// <param name="denominator">a divisor which must be > 0</param>
	    /// <param name="remainder">an array of at least one element in which the value<c>numerator mod denominator</c> is returned. Unlike<c>numerator% denominator</c>, this will always be non-negative.</param>
	    /// <returns>the floor of the quotient.</returns>
	    static internal int FloorDivide(long numerator, int denominator, int[] remainder) {
	        if (numerator >= 0) {
	            remainder[0] = (int) (numerator % denominator);
	            return (int) (numerator / denominator);
	        }
	        int quotient = (int) (((numerator + 1) / denominator) - 1);
	        remainder[0] = (int) (numerator - (quotient * denominator));
	        return quotient;
	    }
	
	    /// <summary>
	    /// Compute the Gregorian calendar year, month, and day of month from the
	    /// epoch day, and return them in the given array. TODO: This duplicates a
	    /// method in Calendar; clean up and consolidate in ICU 3.0.
	    /// </summary>
	    ///
	    static internal void ComputeGregorianFields(long day, int[] fields) {
	        int year, month, dayOfMonth, dayOfYear;
	
	        // Convert from 1970 CE epoch to 1 CE epoch (Gregorian calendar)
	        // JULIAN_1_CE = 1721426; // January 1, 1 CE Gregorian
	        // JULIAN_1970_CE = 2440588; // January 1, 1970 CE Gregorian
	        day += (2440588 - 1721426);
	
	        // Here we convert from the day number to the multiple radix
	        // representation. We use 400-year, 100-year, and 4-year cycles.
	        // For example, the 4-year cycle has 4 years + 1 leap day; giving
	        // 1461 == 365*4 + 1 days.
	        int[] rem = new int[1];
	        int n400 = FloorDivide(day, 146097, rem); // 400-year cycle length
	        int n100 = FloorDivide(rem[0], 36524, rem); // 100-year cycle length
	        int n4 = FloorDivide(rem[0], 1461, rem); // 4-year cycle length
	        int n1 = FloorDivide(rem[0], 365, rem);
	        year = 400 * n400 + 100 * n100 + 4 * n4 + n1;
	        dayOfYear = rem[0]; // zero-based day of year
	        if (n100 == 4 || n1 == 4) {
	            dayOfYear = 365; // Dec 31 at end of 4- or 400-yr cycle
	        } else {
	            ++year;
	        }
	
	        bool isLeap = ((year & 0x3) == 0) && // equiv. to (year%4 == 0)
	                (year % 100 != 0 || year % 400 == 0);
	
	        int correction = 0;
	        int march1 = (isLeap) ? 60 : 59; // zero-based DOY for March 1
	        if (dayOfYear >= march1)
	            correction = (isLeap) ? 1 : 2;
	        month = (12 * (dayOfYear + correction) + 6) / 367; // zero-based month
	        dayOfMonth = dayOfYear - GREGORIAN_MONTH_COUNT[month][(isLeap) ? 1 : 0]
	                + 1; // one-based DOM
	
	        // Jan 1 1 CE is Monday
	        int dayOfWeek = (int) ((day + IBM.ICU.Util.Calendar.MONDAY) % 7);
	        if (dayOfWeek < IBM.ICU.Util.Calendar.SUNDAY) {
	            dayOfWeek += 7;
	        }
	
	        fields[0] = year;
	        fields[1] = month; // 0-based already
	        fields[2] = dayOfMonth; // 1-based already
	        fields[3] = dayOfWeek; // 1-based already
	        // fields[4] = dayOfYear + 1; // Convert from 0-based to 1-based
	    }
	
	    /// <summary>
	    /// For each month, the days in a non-leap year before the start the of
	    /// month, and the days in a leap year before the start of the month. TODO:
	    /// This duplicates data in Calendar.java; clean up and consolidate in ICU
	    /// 3.0.
	    /// </summary>
	    ///
	    static internal readonly int[][] GREGORIAN_MONTH_COUNT = { new int[] { 0, 0 }, new int[] { 31, 31 }, new int[] { 59, 60 },
	            new int[] { 90, 91 }, new int[] { 120, 121 },
	            new int[] { 151, 152 }, new int[] { 181, 182 },
	            new int[] { 212, 213 }, new int[] { 243, 244 },
	            new int[] { 273, 274 }, new int[] { 304, 305 },
	            new int[] { 334, 335 } };
	
	    /// <summary>
	    /// Sets the base time zone offset to GMT. This is the offset to add///to/// UTC
	    /// to get local time.
	    /// </summary>
	    ///
	    /// <param name="offsetMillis">the given base time zone offset to GMT.</param>
	    /// @stable ICU 2.0
	    abstract public void SetRawOffset(int offsetMillis);
	
	    /// <summary>
	    /// Gets unmodified offset, NOT modified in case of daylight savings. This is
	    /// the offset to add///to/// UTC to get local time.
	    /// </summary>
	    ///
	    /// <returns>the unmodified offset to add ///to/// UTC to get local time.</returns>
	    /// @stable ICU 2.0
	    abstract public int GetRawOffset();
	
	    /// <summary>
	    /// Gets the ID of this time zone.
	    /// </summary>
	    ///
	    /// <returns>the ID of this time zone.</returns>
	    /// @stable ICU 2.0
	    public String GetID() {
	        return ID;
	    }
	
	    /// <summary>
	    /// Sets the time zone ID. This does not change any other data in the time
	    /// zone object.
	    /// </summary>
	    ///
	    /// <param name="ID">the new time zone ID.</param>
	    /// @stable ICU 2.0
	    public virtual void SetID(String ID) {
	        if (ID == null) {
	            throw new NullReferenceException();
	        }
	        this.ID = ID;
	    }
	
	    /// <summary>
	    /// Returns a name of this time zone suitable for presentation to the user in
	    /// the default locale. This method returns the long generic name. If the
	    /// display name is not available for the locale, a fallback based on the
	    /// country, city, or time zone id will be used.
	    /// </summary>
	    ///
	    /// <returns>the human-readable name of this time zone in the default locale.</returns>
	    /// @stable ICU 2.0
	    public String GetDisplayName() {
	        return _getDisplayName(false, LONG_GENERIC, IBM.ICU.Util.ULocale.GetDefault());
	    }
	
	    /// <summary>
	    /// Returns a name of this time zone suitable for presentation to the user in
	    /// the specified locale. This method returns the long generic name. If the
	    /// display name is not available for the locale, a fallback based on the
	    /// country, city, or time zone id will be used.
	    /// </summary>
	    ///
	    /// <param name="locale">the locale in which to supply the display name.</param>
	    /// <returns>the human-readable name of this time zone in the given locale or
	    /// in the default locale if the given locale is not recognized.</returns>
	    /// @stable ICU 2.0
        public String GetDisplayName(Locale locale)
        {
	        return _getDisplayName(false, LONG_GENERIC, IBM.ICU.Util.ULocale.ForLocale(locale));
	    }
	
	    /// <summary>
	    /// Returns a name of this time zone suitable for presentation to the user in
	    /// the specified locale. This method returns the long name, not including
	    /// daylight savings. If the display name is not available for the locale, a
	    /// fallback based on the country, city, or time zone id will be used.
	    /// </summary>
	    ///
	    /// <param name="locale">the ulocale in which to supply the display name.</param>
	    /// <returns>the human-readable name of this time zone in the given locale or
	    /// in the default ulocale if the given ulocale is not recognized.</returns>
	    /// @stable ICU 3.2
	    public String GetDisplayName(ULocale locale) {
	        return _getDisplayName(false, LONG_GENERIC, locale);
	    }
	
	    /// <summary>
	    /// Returns a name of this time zone suitable for presentation to the user in
	    /// the default locale. If the display name is not available for the locale,
	    /// then this method returns a string in the format <c>GMT[+-]hh:mm</c>
	    /// .
	    /// </summary>
	    ///
	    /// <param name="daylight">if true, return the daylight savings name.</param>
	    /// <param name="style">either <c>LONG</c> or <c>SHORT</c></param>
	    /// <returns>the human-readable name of this time zone in the default locale.</returns>
	    /// @stable ICU 2.0
	    public String GetDisplayName(bool daylight, int style) {
	        return GetDisplayName(daylight, style, IBM.ICU.Util.ULocale.GetDefault());
	    }
	
	    /// <summary>
	    /// Returns a name of this time zone suitable for presentation to the user in
	    /// the specified locale. If the display name is not available for the
	    /// locale, then this method returns a string in the format
	    /// <c>GMT[+-]hh:mm</c>.
	    /// </summary>
	    ///
	    /// <param name="daylight">if true, return the daylight savings name.</param>
	    /// <param name="style">either <c>LONG</c> or <c>SHORT</c></param>
	    /// <param name="locale">the locale in which to supply the display name.</param>
	    /// <returns>the human-readable name of this time zone in the given locale or
	    /// in the default locale if the given locale is not recognized.</returns>
	    /// <exception cref="IllegalArgumentException">style is invalid.</exception>
	    /// @stable ICU 2.0
        public String GetDisplayName(bool daylight, int style, Locale locale)
        {
	        return GetDisplayName(daylight, style, IBM.ICU.Util.ULocale.ForLocale(locale));
	    }
	
	    /// <summary>
	    /// Returns a name of this time zone suitable for presentation to the user in
	    /// the specified locale. If the display name is not available for the
	    /// locale, then this method returns a string in the format
	    /// <c>GMT[+-]hh:mm</c>.
	    /// </summary>
	    ///
	    /// <param name="daylight">if true, return the daylight savings name.</param>
	    /// <param name="style">either <c>LONG</c> or <c>SHORT</c></param>
	    /// <param name="locale">the locale in which to supply the display name.</param>
	    /// <returns>the human-readable name of this time zone in the given locale or
	    /// in the default locale if the given locale is not recognized.</returns>
	    /// <exception cref="IllegalArgumentException">style is invalid.</exception>
	    /// @stable ICU 3.2
	    public String GetDisplayName(bool daylight, int style, ULocale locale) {
	        if (style != SHORT && style != LONG) {
	            throw new ArgumentException("Illegal style: " + style);
	        }
	        return _getDisplayName(daylight, style, locale);
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// The public version of this API only accepts LONG/SHORT, the internal
	    /// version (which this calls) also accepts LONG_GENERIC/SHORT_GENERIC.
	    /// </summary>
	    ///
	    private String _getDisplayName(bool daylight, int style, ULocale locale) {
	        /*
	         * NOTES: (1) We use SimpleDateFormat for simplicity; we could do this
	         * more efficiently but it would duplicate the SimpleDateFormat code
	         * here, which is undesirable. (2) Attempts to move the code from
	         * SimpleDateFormat to here also run aground because this requires
	         * SimpleDateFormat to keep a Locale object around, which it currently
	         * doesn't; to synthesize such a locale upon resurrection; and to
	         * somehow handle the special case of construction from a
	         * DateFormatSymbols object.
	         */
	
	        // We keep a cache, indexed by locale. The cache contains a
	        // SimpleDateFormat object, which we create on demand.
	        WeakReference data = (WeakReference) cachedLocaleData[locale];
	        IBM.ICU.Text.SimpleDateFormat format;
	        if (data == null || (format = (IBM.ICU.Text.SimpleDateFormat) data.Target) == null) {
	            format = new IBM.ICU.Text.SimpleDateFormat(null, locale);
	            ILOG.J2CsMapping.Collections.Collections.Put(cachedLocaleData,locale,new WeakReference(format));
	        }
	
	        String[] patterns = { "z", "zzzz", "v", "vvvv" };
	        format.ApplyPattern(patterns[style]);
	        if (style >= 2) {
	            // Generic names may change time to time even for a single time
	            // zone.
	            // This method returns the one used for the zone now.
	            format.SetTimeZone(this);
	            return format.Format(DateTime.Now);
	        } else {
	            // Create a new SimpleTimeZone as a stand-in for this zone; the
	            // stand-in
	            // will have no DST, or DST during January, but the same ID and
	            // offset,
	            // and hence the same display name. We don't cache these because
	            // they're small and cheap to create.
	            SimpleTimeZone tz;
	            if (daylight && UseDaylightTime()) {
	                int savings = GetDSTSavings();
	                tz = new SimpleTimeZone(GetRawOffset(), GetID(),
	                        IBM.ICU.Util.Calendar.JANUARY, 1, 0, 0, IBM.ICU.Util.Calendar.FEBRUARY, 1, 0, 0,
	                        savings);
	            } else {
	                tz = new SimpleTimeZone(GetRawOffset(), GetID());
	            }
	            format.SetTimeZone(tz);
	            // Format a date in January. We use the value 10*ONE_DAY == Jan 11
	            // 1970
	            // 0:00 GMT.
	            return format.Format(new DateTime((864000000L)*10000));
	        }
	    }
	
	    /// <summary>
	    /// Returns the amount of time to be added to local standard time to get
	    /// local wall clock time.
	    /// <p>
	    /// The default implementation always returns 3600000 milliseconds (i.e., one
	    /// hour) if this time zone observes Daylight Saving Time. Otherwise, 0
	    /// (zero) is returned.
	    /// <p>
	    /// If an underlying TimeZone implementation subclass supports historical
	    /// Daylight Saving Time changes, this method returns the known latest
	    /// daylight saving value.
	    /// </summary>
	    ///
	    /// <returns>the amount of saving time in milliseconds</returns>
	    /// @stable ICU 2.8
	    public virtual int GetDSTSavings() {
	        if (UseDaylightTime()) {
	            return 3600000;
	        }
	        return 0;
	    }
	
	    /// <summary>
	    /// Queries if this time zone uses daylight savings time.
	    /// </summary>
	    ///
	    /// <returns>true if this time zone uses daylight savings time, false,
	    /// otherwise.</returns>
	    /// @stable ICU 2.0
	    abstract public bool UseDaylightTime();
	
	    /// <summary>
	    /// Queries if the given date is in daylight savings time in this time zone.
	    /// </summary>
	    ///
	    /// <param name="date">the given Date.</param>
	    /// <returns>true if the given date is in daylight savings time, false,
	    /// otherwise.</returns>
	    /// @stable ICU 2.0
	    abstract public bool InDaylightTime(DateTime date);
	
	    /// <summary>
	    /// Gets the <c>TimeZone</c> for the given ID.
	    /// </summary>
	    ///
	    /// <param name="ID">the ID for a <c>TimeZone</c>, either an abbreviationsuch as "PST", a full name such as "America/Los_Angeles", or acustom ID such as "GMT-8:00". Note that the support ofabbreviations is for JDK 1.1.x compatibility only and fullnames should be used.</param>
	    /// <returns>the specified <c>TimeZone</c>, or the GMT zone if the given
	    /// ID cannot be understood.</returns>
	    /// @stable ICU 2.0
	    [MethodImpl(MethodImplOptions.Synchronized)]
	    public static TimeZone GetTimeZone(String ID) {
	        /*
	         * We first try to lookup the zone ID in our system list. If this fails,
	         * we try to parse it as a custom string GMT[+-]hh:mm. If all else
	         * fails, we return GMT, which is probably not what the user wants, but
	         * at least is a functioning TimeZone object.
	         * 
	         * We cannot return NULL, because that would break compatibility with
	         * the JDK.
	         */
	        if (ID == null) {
	            throw new NullReferenceException();
	        }
	        TimeZone result = IBM.ICU.Impl.ZoneMeta.GetSystemTimeZone(ID);
	
	        if (result == null) {
	            result = IBM.ICU.Impl.ZoneMeta.GetCustomTimeZone(ID);
	        }
	        if (result == null) {
	            result = IBM.ICU.Impl.ZoneMeta.GetGMT();
	        }
	        return result;
	    }
	
	    /// <summary>
	    /// Return a new String array containing all system TimeZone IDs with the
	    /// given raw offset from GMT. These IDs may be passed to <c>get()</c>
	    /// to construct the corresponding TimeZone object.
	    /// </summary>
	    ///
	    /// <param name="rawOffset">the offset in milliseconds from GMT</param>
	    /// <returns>an array of IDs for system TimeZones with the given raw offset.
	    /// If there are none, return a zero-length array.</returns>
	    /// @stable ICU 2.0
	    public static String[] GetAvailableIDs(int rawOffset) {
	        return IBM.ICU.Impl.ZoneMeta.GetAvailableIDs(rawOffset);
	
	    }
	
	    /// <summary>
	    /// Return a new String array containing all system TimeZone IDs associated
	    /// with the given country. These IDs may be passed to <c>get()</c> to
	    /// construct the corresponding TimeZone object.
	    /// </summary>
	    ///
	    /// <param name="country">a two-letter ISO 3166 country code, or <c>null</c> toreturn zones not associated with any country</param>
	    /// <returns>an array of IDs for system TimeZones in the given country. If
	    /// there are none, return a zero-length array.</returns>
	    /// @stable ICU 2.0
	    public static String[] GetAvailableIDs(String country) {
	        return IBM.ICU.Impl.ZoneMeta.GetAvailableIDs(country);
	    }
	
	    /// <summary>
	    /// Return a new String array containing all system TimeZone IDs. These IDs
	    /// (and only these IDs) may be passed to <c>get()</c> to construct the
	    /// corresponding TimeZone object.
	    /// </summary>
	    ///
	    /// <returns>an array of all system TimeZone IDs</returns>
	    /// @stable ICU 2.0
	    public static String[] GetAvailableIDs() {
	        return IBM.ICU.Impl.ZoneMeta.GetAvailableIDs();
	    }
	
	    /// <summary>
	    /// Returns the number of IDs in the equivalency group that includes the
	    /// given ID. An equivalency group contains zones that have the same GMT
	    /// offset and rules.
	    /// <p>
	    /// The returned count includes the given ID; it is always >= 1 for valid
	    /// IDs. The given ID must be a system time zone. If it is not, returns zero.
	    /// </summary>
	    ///
	    /// <param name="id">a system time zone ID</param>
	    /// <returns>the number of zones in the equivalency group containing 'id', or
	    /// zero if 'id' is not a valid system ID</returns>
	    /// <seealso cref="M:IBM.ICU.Util.TimeZone.GetEquivalentID(System.String, System.Int32)"/>
	    /// @stable ICU 2.0
	    public static int CountEquivalentIDs(String id) {
	        return IBM.ICU.Impl.ZoneMeta.CountEquivalentIDs(id);
	    }
	
	    /// <summary>
	    /// Returns an ID in the equivalency group that includes the given ID. An
	    /// equivalency group contains zones that have the same GMT offset and rules.
	    /// <p>
	    /// The given index must be in the range 0..n-1, where n is the value
	    /// returned by <c>countEquivalentIDs(id)</c>. For some value of
	    /// 'index', the returned value will be equal to the given id. If the given
	    /// id is not a valid system time zone, or if 'index' is out of range, then
	    /// returns an empty string.
	    /// </summary>
	    ///
	    /// <param name="id">a system time zone ID</param>
	    /// <param name="index">a value from 0 to n-1, where n is the value returned by<c>countEquivalentIDs(id)</c></param>
	    /// <returns>the ID of the index-th zone in the equivalency group containing
	    /// 'id', or an empty string if 'id' is not a valid system ID or
	    /// 'index' is out of range</returns>
	    /// <seealso cref="M:IBM.ICU.Util.TimeZone.CountEquivalentIDs(System.String)"/>
	    /// @stable ICU 2.0
	    public static String GetEquivalentID(String id, int index) {
	        return IBM.ICU.Impl.ZoneMeta.GetEquivalentID(id, index);
	    }
	
	    /// <summary>
	    /// Gets the default <c>TimeZone</c> for this host. The source of the
	    /// default <c>TimeZone</c> may vary with implementation.
	    /// </summary>
	    ///
	    /// <returns>a default <c>TimeZone</c>.</returns>
	    /// @stable ICU 2.0
	    [MethodImpl(MethodImplOptions.Synchronized)]
	    public static TimeZone GetDefault() {
	        if (defaultZone == null) {                
	           /* System.Collections.TimeZone temp = System.Collections.TimeZone.GetDefault();*/
                String name = System.TimeZoneInfo.Local.DisplayName;
                // String format with "(GMT+/-XXX) ...."
                int len = name.IndexOf(")");
                name = name.Substring(1, len - 1);
	            defaultZone = GetTimeZone(name);
	        }
	        return (TimeZone) defaultZone.Clone();
	    }
	
	    /// <summary>
	    /// Sets the <c>TimeZone</c> that is returned by the
	    /// <c>getDefault</c> method. If <c>zone</c> is null, reset the
	    /// default to the value it had originally when the VM first started.
	    /// </summary>
	    ///
	    /// <param name="tz">the new default time zone</param>
	    /// @stable ICU 2.0
	    [MethodImpl(MethodImplOptions.Synchronized)]
	    public static void SetDefault(TimeZone tz) {
	
	        defaultZone = tz;
	        // Keep java.util.TimeZone default in sync so java.util.Date
	        // can interoperate with com.ibm.icu.util classes.
	        TimeZone jdkZone = null;
	        if (tz != null) {
	            jdkZone = IBM.ICU.Impl.TimeZoneAdapter.Wrap(tz);
	        }
	        // TimeZone.SetDefault(jdkZone);
            // need to be :System.TimeZone.CurrentTimeZone = jdkZone;
	    }
	
	    /// <summary>
	    /// Returns true if this zone has the same rule and offset as another zone.
	    /// That is, if this zone differs only in ID, if at all. Returns false if the
	    /// other zone is null.
	    /// </summary>
	    ///
	    /// <param name="other">the <c>TimeZone</c> object to be compared with</param>
	    /// <returns>true if the other zone is not null and is the same as this one,
	    /// with the possible exception of the ID</returns>
	    /// @stable ICU 2.0
	    public virtual bool HasSameRules(TimeZone other) {
	        return other != null && GetRawOffset() == other.GetRawOffset()
	                && UseDaylightTime() == other.UseDaylightTime();
	    }
	
	    /// <summary>
	    /// Overrides Cloneable
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public virtual Object Clone() {
	        try {
	            TimeZone other = (TimeZone) base.MemberwiseClone();
	            other.ID = ID;
	            return other;
	        } catch (Exception e) {
	            throw new InvalidOperationException();
	        }
	    }
	
	    /// <summary>
	    /// Return true if obj is a TimeZone with the same class and ID as this.
	    /// </summary>
	    ///
	    /// <returns>true if obj is a TimeZone with the same class and ID as this</returns>
	    /// <param name="obj">the object to compare against</param>
	    /// @stable ICU 3.6
	    public override bool Equals(Object obj) {
	        if ((Object) this == obj)
	            return true;
	        if (obj == null || (Object) GetType() != (Object) obj.GetType())
	            return false;
	        return (ID.Equals(((TimeZone) obj).ID));
	    }
	
	    /// <summary>
	    /// Return the hash code.
	    /// </summary>
	    ///
	    /// <returns>the hash code</returns>
	    /// @stable ICU 3.6
	    public override int GetHashCode() {
	        return ID.GetHashCode();
	    }
	
	    /// <summary>
	    /// Returns the timezone data version currently used by ICU.
	    /// </summary>
	    ///
	    /// <returns>the version string, such as "2007f"</returns>
	    /// <exception cref="MissingResourceException">if ICU timezone resource bundle is missing or the versioninformation is not available.</exception>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    [MethodImpl(MethodImplOptions.Synchronized)]
	    public static String GetTZDataVersion() {
	        if (TZDATA_VERSION == null) {
	            UResourceBundle tzbundle = IBM.ICU.Util.UResourceBundle.GetBundleInstance(
	                    "com/ibm/icu/impl/data/icudt"
	                            + IBM.ICU.Util.VersionInfo.ICU_DATA_VERSION, "zoneinfo");
	            TZDATA_VERSION = tzbundle.GetString("TZVersion");
	        }
	        return TZDATA_VERSION;
	    }
	
	    // =======================privates===============================
	
	    /// <summary>
	    /// The string identifier of this <c>TimeZone</c>. This is a
	    /// programmatic identifier used internally to look up <c>TimeZone</c>
	    /// objects from the system table and also to map them to their localized
	    /// display names. <c>ID</c> values are unique in the system table but
	    /// may not be for dynamically created zones.
	    /// </summary>
	    ///
	    /// @serial
	    private String ID;
	
	    /// <summary>
	    /// The default time zone, or null if not set.
	    /// </summary>
	    ///
	    private static TimeZone defaultZone = null;
	
	    /// <summary>
	    /// The tzdata version
	    /// </summary>
	    ///
	    private static String TZDATA_VERSION = null;
	
	}
	
	// eof
}
