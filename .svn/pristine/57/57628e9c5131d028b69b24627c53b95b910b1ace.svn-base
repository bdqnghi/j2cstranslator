// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:47 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 1996-2004, International Business Machines Corporation and    
/// others. All Rights Reserved.                                                
/// </summary>
///
namespace IBM.ICU.Impl {
	
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Text;
	
	/// <summary>
	/// Internal character utility class for simple data type conversion and String
	/// parsing functions. Does not have an analog in the JDK.
	/// </summary>
	///
	
	public sealed class UCharacterUtility {
	    // public methods -----------------------------------------------------
	
	    /// <summary>
	    /// Determines if codepoint is a non character
	    /// </summary>
	    ///
	    /// <param name="ch">codepoint</param>
	    /// <returns>true if codepoint is a non character false otherwise</returns>
	    public static bool IsNonCharacter(int ch) {
	        if ((ch & NON_CHARACTER_SUFFIX_MIN_3_0_) == NON_CHARACTER_SUFFIX_MIN_3_0_) {
	            return true;
	        }
	
	        return ch >= NON_CHARACTER_MIN_3_1_ && ch <= NON_CHARACTER_MAX_3_1_;
	    }
	
	    // package private methods ---------------------------------------------
	
	    /// <summary>
	    /// joining 2 chars to form an int
	    /// </summary>
	    ///
	    /// <param name="msc">most significant char</param>
	    /// <param name="lsc">least significant char</param>
	    /// <returns>int form</returns>
	    static internal int ToInt(char msc, char lsc) {
	        return ((msc << 16) | lsc);
	    }
	
	    /// <summary>
	    /// Retrieves a null terminated substring from an array of bytes. Substring
	    /// is a set of non-zero bytes starting from argument start to the next zero
	    /// byte. If the first byte is a zero, the next byte will be taken as the
	    /// first byte.
	    /// </summary>
	    ///
	    /// <param name="str">stringbuffer to store data in, data will be store with eachbyte as a char</param>
	    /// <param name="array">byte array</param>
	    /// <param name="index">to start substring in byte count</param>
	    /// <returns>the end position of the substring within the character array</returns>
	    static internal int GetNullTermByteSubString(StringBuilder str, byte[] array,
	            int index) {
	        byte b = 1;
	
	        while (b != 0) {
	            b = array[index];
	            if (b != 0) {
	                str.Append((char) (b & 0x00FF));
	            }
	            index++;
	        }
	        return index;
	    }
	
	    /// <summary>
	    /// Compares a null terminated substring from an array of bytes. Substring is
	    /// a set of non-zero bytes starting from argument start to the next zero
	    /// byte. if the first byte is a zero, the next byte will be taken as the
	    /// first byte.
	    /// </summary>
	    ///
	    /// <param name="str">string to compare</param>
	    /// <param name="array">byte array</param>
	    /// <param name="strindex">index within str to start comparing</param>
	    /// <param name="aindex">array index to start in byte count</param>
	    /// <returns>the end position of the substring within str if matches otherwise
	    /// a -1</returns>
	    static internal int CompareNullTermByteSubString(String str, byte[] array,
	            int strindex, int aindex) {
	        byte b = 1;
	        int length = str.Length;
	
	        while (b != 0) {
	            b = array[aindex];
	            aindex++;
	            if (b == 0) {
	                break;
	            }
	            // if we have reached the end of the string and yet the array has
	            // not
	            // reached the end of their substring yet, abort
	            if (strindex == length
	                    || (str[strindex] != (char) (b & 0xFF))) {
	                return -1;
	            }
	            strindex++;
	        }
	        return strindex;
	    }
	
	    /// <summary>
	    /// Skip null terminated substrings from an array of bytes. Substring is a
	    /// set of non-zero bytes starting from argument start to the next zero byte.
	    /// If the first byte is a zero, the next byte will be taken as the first
	    /// byte.
	    /// </summary>
	    ///
	    /// <param name="array">byte array</param>
	    /// <param name="index">to start substrings in byte count</param>
	    /// <param name="skipcount">number of null terminated substrings to skip</param>
	    /// <returns>the end position of the substrings within the character array</returns>
	    static internal int SkipNullTermByteSubString(byte[] array, int index, int skipcount) {
	        byte b;
	        for (int i = 0; i < skipcount; i++) {
	            b = 1;
	            while (b != 0) {
	                b = array[index];
	                index++;
	            }
	        }
	        return index;
	    }
	
	    /// <summary>
	    /// skip substrings from an array of characters, where each character is a
	    /// set of 2 bytes. substring is a set of non-zero bytes starting from
	    /// argument start to the byte of the argument value. skips up to a max
	    /// number of characters
	    /// </summary>
	    ///
	    /// <param name="array">byte array to parse</param>
	    /// <param name="index">to start substrings in byte count</param>
	    /// <param name="length">the max number of bytes to skip</param>
	    /// <param name="skipend">value of byte to skip to</param>
	    /// <returns>the number of bytes skipped</returns>
	    static internal int SkipByteSubString(byte[] array, int index, int length,
	            byte skipend) {
	        int result;
	        byte b;
	
	        for (result = 0; result < length; result++) {
	            b = array[index + result];
	            if (b == skipend) {
	                result++;
	                break;
	            }
	        }
	
	        return result;
	    }
	
	    // private data member --------------------------------------------------
	
	    /// <summary>
	    /// Minimum suffix value that indicates if a character is non character.
	    /// Unicode 3.0 non characters
	    /// </summary>
	    ///
	    private const int NON_CHARACTER_SUFFIX_MIN_3_0_ = 0xFFFE;
	
	    /// <summary>
	    /// New minimum non character in Unicode 3.1
	    /// </summary>
	    ///
	    private const int NON_CHARACTER_MIN_3_1_ = 0xFDD0;
	
	    /// <summary>
	    /// New non character range in Unicode 3.1
	    /// </summary>
	    ///
	    private const int NON_CHARACTER_MAX_3_1_ = 0xFDEF;
	
	    // private constructor --------------------------------------------------
	
	    // /CLOVER:OFF
	    /// <summary>
	    /// private constructor to avoid initialisation
	    /// </summary>
	    ///
	    private UCharacterUtility() {
	    }
	    // /CLOVER:ON
	}
}
