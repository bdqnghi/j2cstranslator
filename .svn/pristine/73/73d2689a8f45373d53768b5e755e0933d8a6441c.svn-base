/*
 *******************************************************************************
 * Copyright (C) 2002-2007, International Business Machines Corporation and    *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 */
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/13/10 4:01 PM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
namespace IBM.ICU.Charset
{

    using IBM.ICU.Text;
    using ILOG.J2CsMapping.Collections;
    using ILOG.J2CsMapping.Collections.Generics;
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.IO;
    using System.Runtime.CompilerServices;
    using ILOG.J2CsMapping.Text;

    /// <summary>
    /// Provides a general interface for Unicode Properties, and extracting sets
    /// based on those values.
    /// </summary>
    ///
    public abstract class UnicodePropertySource : ICloneable
    {

        public UnicodePropertySource()
        {
            this.m_nameChoice = IBM.ICU.Lang.UProperty_Constants.NameChoice.LONG;
            this.filter = new UnicodePropertySource.StringFilter();
            this.matchIterator = new UnicodeSetIterator(
                    new UnicodeSet(0, 0x10FFFF));
        }

        protected internal String propertyAlias;

        protected internal int m_nameChoice;

        protected internal UnicodePropertySource.StringFilter filter;

        protected internal UnicodeSetIterator matchIterator;

        abstract public String GetPropertyValue(int codepoint);

        abstract public ILOG.J2CsMapping.Collections.ISet GetAvailablePropertyAliases(ILOG.J2CsMapping.Collections.ISet result);

        abstract public ILOG.J2CsMapping.Collections.ISet GetAvailablePropertyValueAliases(ILOG.J2CsMapping.Collections.ISet result);

        abstract public String GetPropertyAlias(int nameChoice);

        abstract public String GetPropertyValueAlias(String valueAlias,
                int nameChoice);

        /// <summary>
        /// Subclasses should override
        /// </summary>
        ///
        public virtual Object Clone()
        {
            try
            {
                UnicodePropertySource result = (UnicodePropertySource)base.MemberwiseClone();
                result.filter = (UnicodePropertySource.StringFilter)filter.Clone();
                return result;
            }
            catch (Exception e)
            {
                throw new InvalidOperationException("Should never happen.");
            }
        }

        public virtual UnicodePropertySource SetPropertyAlias(String propertyAlias_0)
        {
            this.propertyAlias = propertyAlias_0;
            return this;
        }

        public String GetPropertyAlias()
        {
            return propertyAlias;
        }

        public static bool Equals(int codepoint, String other)
        {
            if (other.Length == 1)
            {
                return codepoint == other[0];
            }
            return other.Equals(IBM.ICU.Text.UTF16.ValueOf(codepoint));
        }

        public UnicodeSet GetPropertySet(bool charEqualsValue, UnicodeSet result)
        {
            if (result == null)
                result = new UnicodeSet();
            matchIterator.Reset();
            while (matchIterator.Next())
            {
                String value_ren = filter
                        .Remap(GetPropertyValue(matchIterator.codepoint));
                if (Equals(matchIterator.codepoint, value_ren) == charEqualsValue)
                {
                    result.Add(matchIterator.codepoint);
                }
            }
            return result;
        }

        public UnicodeSet GetPropertySet(String propertyValue, UnicodeSet result)
        {
            if (result == null)
                result = new UnicodeSet();
            matchIterator.Reset();
            while (matchIterator.Next())
            {
                String value_ren = filter
                        .Remap(GetPropertyValue(matchIterator.codepoint));
                if (propertyValue.Equals(value_ren))
                {
                    result.Add(matchIterator.codepoint);
                }
            }
            return result;
        }

        public UnicodeSet GetPropertySet(UnicodePropertySource.Matcher matcher, UnicodeSet result)
        {
            if (result == null)
                result = new UnicodeSet();
            matchIterator.Reset();
            while (matchIterator.Next())
            {
                String value_ren = filter
                        .Remap(GetPropertyValue(matchIterator.codepoint));
                if (value_ren == null)
                    continue;
                if (matcher.Matches(value_ren))
                {
                    result.Add(matchIterator.codepoint);
                }
            }
            return result;
        }

        public interface Matcher
        {
            bool Matches(String value_ren);
        }

        public int GetNameChoice()
        {
            return m_nameChoice;
        }

        public UnicodePropertySource SetNameChoice(int choice)
        {
            m_nameChoice = choice;
            return this;
        }

        public class StringFilter : ICloneable
        {
            public virtual String Remap(String original)
            {
                return original;
            }

            public virtual Object Clone()
            {
                try
                {
                    return base.MemberwiseClone();
                }
                catch (Exception e)
                {
                    throw new InvalidOperationException("Should never happen.");
                }
            }
        }

        public class MapFilter : UnicodePropertySource.StringFilter
        {
            internal IDictionary valueMap;

            public override String Remap(String original)
            {
                Object changed = ILOG.J2CsMapping.Collections.Collections.Get(valueMap, original);
                return (changed == null) ? original : (String)changed;
            }

            public IDictionary GetMap()
            {
                return valueMap;
            }

            public UnicodePropertySource.MapFilter SetMap(IDictionary map)
            {
                valueMap = map;
                return this;
            }
        }

        public class ICU : UnicodePropertySource
        {
            public ICU()
            {
                matchIterator = new UnicodeSetIterator(new UnicodeSet(
                        "[^[:Cn:]-[:Default_Ignorable_Code_Point:]]"));
                this.propEnum = Int32.MinValue;
            }

            protected internal int propEnum;
            public override UnicodePropertySource SetPropertyAlias(String propertyAlias_0)
            {
                base.SetPropertyAlias(propertyAlias_0);
                int extraPosition = Extras.IndexOf(propertyAlias_0);
                if (extraPosition >= 0)
                {
                    propEnum = EXTRA_START + extraPosition;
                }
                else
                {
                    propEnum = IBM.ICU.Lang.UCharacter.GetPropertyEnum(propertyAlias_0);
                }
                return this;
            }

            public override String GetPropertyValue(int codePoint)
            {
                if (propEnum < IBM.ICU.Lang.UProperty_Constants.INT_LIMIT)
                {
                    int enumValue = IBM.ICU.Lang.UCharacter.GetIntPropertyValue(codePoint,
                            propEnum);
                    return IBM.ICU.Lang.UCharacter.GetPropertyValueName(propEnum, enumValue,
                            (int)m_nameChoice);
                }
                else if (propEnum < IBM.ICU.Lang.UProperty_Constants.DOUBLE_LIMIT)
                {
                    return String.Concat(IBM.ICU.Lang.UCharacter
                                            .GetUnicodeNumericValue(codePoint));
                    // TODO: Fix HACK -- API deficient
                }
                else
                    switch (propEnum)
                    {
                        case IBM.ICU.Lang.UProperty_Constants.AGE:
                            return IBM.ICU.Lang.UCharacter.GetAge(codePoint).ToString();
                        case IBM.ICU.Lang.UProperty_Constants.BIDI_MIRRORING_GLYPH:
                            return IBM.ICU.Text.UTF16.ValueOf(IBM.ICU.Lang.UCharacter.GetMirror(codePoint));
                        case IBM.ICU.Lang.UProperty_Constants.CASE_FOLDING:
                            return IBM.ICU.Lang.UCharacter.FoldCase(IBM.ICU.Text.UTF16.ValueOf(codePoint), true);
                        case IBM.ICU.Lang.UProperty_Constants.ISO_COMMENT:
                            return IBM.ICU.Lang.UCharacter.GetISOComment(codePoint);
                        case IBM.ICU.Lang.UProperty_Constants.LOWERCASE_MAPPING:
                            return IBM.ICU.Lang.UCharacter.ToLowerCase(ILOG.J2CsMapping.Util.Locale.US,
                                    IBM.ICU.Text.UTF16.ValueOf(codePoint));
                        case IBM.ICU.Lang.UProperty_Constants.NAME:
                            return IBM.ICU.Lang.UCharacter.GetName(codePoint);
                        case IBM.ICU.Lang.UProperty_Constants.SIMPLE_CASE_FOLDING:
                            return IBM.ICU.Text.UTF16.ValueOf(IBM.ICU.Lang.UCharacter.FoldCase(codePoint, true));
                        case IBM.ICU.Lang.UProperty_Constants.SIMPLE_LOWERCASE_MAPPING:
                            return IBM.ICU.Text.UTF16.ValueOf(IBM.ICU.Lang.UCharacter.ToLowerCase(codePoint));
                        case IBM.ICU.Lang.UProperty_Constants.SIMPLE_TITLECASE_MAPPING:
                            return IBM.ICU.Text.UTF16.ValueOf(IBM.ICU.Lang.UCharacter.ToTitleCase(codePoint));
                        case IBM.ICU.Lang.UProperty_Constants.SIMPLE_UPPERCASE_MAPPING:
                            return IBM.ICU.Text.UTF16.ValueOf(IBM.ICU.Lang.UCharacter.ToUpperCase(codePoint));
                        case IBM.ICU.Lang.UProperty_Constants.TITLECASE_MAPPING:
                            return IBM.ICU.Lang.UCharacter.ToTitleCase(ILOG.J2CsMapping.Util.Locale.US,
                                    IBM.ICU.Text.UTF16.ValueOf(codePoint), null);
                        case IBM.ICU.Lang.UProperty_Constants.UNICODE_1_NAME:
                            return IBM.ICU.Lang.UCharacter.GetName1_0(codePoint);
                        case IBM.ICU.Lang.UProperty_Constants.UPPERCASE_MAPPING:
                            return IBM.ICU.Lang.UCharacter.ToUpperCase(ILOG.J2CsMapping.Util.Locale.US,
                                    IBM.ICU.Text.UTF16.ValueOf(codePoint));
                        case NFC:
                            return IBM.ICU.Text.Normalizer.Normalize(codePoint, IBM.ICU.Text.Normalizer.NFC);
                        case NFD:
                            return IBM.ICU.Text.Normalizer.Normalize(codePoint, IBM.ICU.Text.Normalizer.NFD);
                        case NFKC:
                            return IBM.ICU.Text.Normalizer.Normalize(codePoint, IBM.ICU.Text.Normalizer.NFKC);
                        case NFKD:
                            return IBM.ICU.Text.Normalizer.Normalize(codePoint, IBM.ICU.Text.Normalizer.NFKD);
                    }
                return null;
            }

            static internal readonly IList Extras = ILOG.J2CsMapping.Collections.Arrays.AsList(new String[] { "NFC", "NFD",
	                        "NFKC", "NKFD" });

            internal const int NFC = 0x8000, NFD = 0x8001, NFKC = 0x8002,
                    NFKD = 0x8003, EXTRA_START = NFC, EXTRA_LIMIT = NFKD + 1;

            static internal readonly int[][] ranges = {
	                new int[] { IBM.ICU.Lang.UProperty_Constants.BINARY_START,
	                        IBM.ICU.Lang.UProperty_Constants.BINARY_LIMIT },
	                new int[] { IBM.ICU.Lang.UProperty_Constants.INT_START,
	                        IBM.ICU.Lang.UProperty_Constants.INT_LIMIT },
	                new int[] { IBM.ICU.Lang.UProperty_Constants.DOUBLE_START,
	                        IBM.ICU.Lang.UProperty_Constants.DOUBLE_LIMIT },
	                new int[] { IBM.ICU.Lang.UProperty_Constants.STRING_START,
	                        IBM.ICU.Lang.UProperty_Constants.STRING_LIMIT } };

            public override ILOG.J2CsMapping.Collections.ISet GetAvailablePropertyAliases(ILOG.J2CsMapping.Collections.ISet result)
            {
                for (int i = 0; i < ranges.Length; ++i)
                {
                    for (int j = ranges[i][0]; j < ranges[i][1]; ++j)
                    {
                        ILOG.J2CsMapping.Collections.Generics.Collections.Add(result, IBM.ICU.Lang.UCharacter.GetPropertyName(j, m_nameChoice));
                    }
                }
                ILOG.J2CsMapping.Collections.Generics.Collections.AddAll(Extras, result);
                return result;
            }

            public override ILOG.J2CsMapping.Collections.ISet GetAvailablePropertyValueAliases(ILOG.J2CsMapping.Collections.ISet result)
            {
                if (propEnum < IBM.ICU.Lang.UProperty_Constants.INT_LIMIT)
                {
                    int start = IBM.ICU.Lang.UCharacter.GetIntPropertyMinValue(propEnum);
                    int end = IBM.ICU.Lang.UCharacter.GetIntPropertyMaxValue(propEnum);
                    for (int i = start; i <= end; ++i)
                    {
                        ILOG.J2CsMapping.Collections.Generics.Collections.Add(result, GetFixedValueAlias(null, i, m_nameChoice));
                    }
                }
                else
                {
                    ILOG.J2CsMapping.Collections.Generics.Collections.Add(result, GetFixedValueAlias(null, -1, m_nameChoice));
                }
                return result;
            }


            /// <param name="valueAlias">null if unused.</param>
            /// <param name="valueEnum">-1 if unused</param>
            /// <param name="nameChoice"></param>
            /// <returns>the alias</returns>
            public String GetFixedValueAlias(String valueAlias, int valueEnum,
                    int nameChoice)
            {
                if (propEnum >= IBM.ICU.Lang.UProperty_Constants.STRING_START)
                {
                    return "<string>";
                }
                else if (propEnum >= IBM.ICU.Lang.UProperty_Constants.DOUBLE_START)
                {
                    return "<double>";
                }
                if (valueAlias != null && !valueAlias.Equals("<integer>"))
                {
                    valueEnum = IBM.ICU.Lang.UCharacter.GetPropertyValueEnum(propEnum,
                            valueAlias);
                }
                String result = FixedGetPropertyValueName(propEnum, valueEnum,
                        nameChoice);
                if (result != null)
                    return result;
                // try other namechoice
                result = FixedGetPropertyValueName(
                        propEnum,
                        valueEnum,
                        (nameChoice == IBM.ICU.Lang.UProperty_Constants.NameChoice.LONG) ? IBM.ICU.Lang.UProperty_Constants.NameChoice.SHORT
                                : IBM.ICU.Lang.UProperty_Constants.NameChoice.LONG);
                if (result != null)
                    return result;
                return "<integer>";
            }

            public static String FixedGetPropertyValueName(int propEnum_0,
                    int valueEnum, int nameChoice)
            {
                try
                {
                    return IBM.ICU.Lang.UCharacter.GetPropertyValueName(propEnum_0, valueEnum,
                            nameChoice);
                }
                catch (Exception e)
                {
                    return null;
                }
            }

            public override String GetPropertyAlias(int nameChoice)
            {
                if (propEnum < EXTRA_START)
                {
                    return IBM.ICU.Lang.UCharacter.GetPropertyName(propEnum, nameChoice);
                }
                return (String)Extras[propEnum - EXTRA_START];
            }

            public override String GetPropertyValueAlias(String valueAlias, int nameChoice)
            {
                return GetFixedValueAlias(valueAlias, -1, nameChoice);
            }
        }

        // TODO file bug on getPropertyValueName for Canonical_Combining_Class

        public UnicodePropertySource.StringFilter GetFilter()
        {
            return filter;
        }

        public UnicodePropertySource SetFilter(UnicodePropertySource.StringFilter filter_0)
        {
            this.filter = filter_0;
            return this;
        }

        static public void AddAll(UnicodeSetIterator source, UnicodeSet result)
        {
            while (source.NextRange())
            {
                if (source.codepoint == IBM.ICU.Text.UnicodeSetIterator.IS_STRING)
                {
                    result.Add(source.str0);
                }
                else
                {
                    result.Add(source.codepoint, source.codepointEnd);
                }
            }
        }

        public UnicodeSet GetMatchSet(UnicodeSet result)
        {
            if (result == null)
                result = new UnicodeSet();
            AddAll(matchIterator, result);
            return result;
        }


        /// <param name="set"></param>
        public void SetMatchSet(UnicodeSet set)
        {
            matchIterator = new UnicodeSetIterator(set);
        }

    }
}
