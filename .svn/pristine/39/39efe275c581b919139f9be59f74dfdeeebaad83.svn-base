// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/13/10 4:01 PM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2000-2007, International Business Machines Corporation and    
/// others. All Rights Reserved.                                                
/// </summary>
///
namespace IBM.ICU.Charset
{

    using IBM.ICU.Text;
    using IBM.ICU.Util;
    using ILOG.J2CsMapping.IO;
    using ILOG.J2CsMapping.Util;
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.Globalization;
    using System.IO;
    using System.Resources;
    using System.Runtime.CompilerServices;
    using ILOG.J2CsMapping.Text;
    using NUnit.Framework;


    /// @test 1.32 99/11/14
    /// @bug 4031502 4035301 4040996 4051765 4059654 4061476 4070502 4071197 4071385
    /// 4073929 4083167 4086724 4092362 4095407 4096231 4096539 4100311 4103271
    /// 4106136 4108764 4114578 4118384 4125881 4125892 4136399 4141665 4142933
    /// 4145158 4145983 4147269 4149677 4162587 4165343 4166109 4167060 4173516
    /// 4174361 4177484 4197699 4209071 4288792
    [TestFixture]
    public class CalendarRegression : IBM.ICU.Charset.TestFmwk
    {

        public static void Main(String[] args)
        {
            new CalendarRegression().Run(args);
        }

        static internal readonly String[] FIELD_NAME = { "ERA", "YEAR", "MONTH",
	            "WEEK_OF_YEAR", "WEEK_OF_MONTH", "DAY_OF_MONTH", "DAY_OF_YEAR",
	            "DAY_OF_WEEK", "DAY_OF_WEEK_IN_MONTH", "AM_PM", "HOUR",
	            "HOUR_OF_DAY", "MINUTE", "SECOND", "MILLISECOND", "ZONE_OFFSET",
	            "DST_OFFSET", "YEAR_WOY", "DOW_LOCAL", "EXTENDED_YEAR",
	            "JULIAN_DAY", "MILLISECONDS_IN_DAY" };

        /*
         * Synopsis: java.sql.Timestamp constructor works wrong on Windows 95
         * 
         * ==== Here is the test ==== public static void main (String args[]) {
         * java.sql.Timestamp t= new java.sql.Timestamp(0,15,5,5,8,13,123456700);
         * logln("expected=1901-04-05 05:08:13.1234567"); logln(" result="+t); }
         * 
         * ==== Here is the output of the test on Solaris or NT ====
         * expected=1901-04-05 05:08:13.1234567 result=1901-04-05 05:08:13.1234567
         * 
         * ==== Here is the output of the test on Windows95 ==== expected=1901-04-05
         * 05:08:13.1234567 result=1901-04-05 06:08:13.1234567
         */
        [Test]
        public void Test4031502()
        {
            try
            {
                // This bug actually occurs on Windows NT as well, and doesn't
                // require the host zone to be set; it can be set in Java.
                String[] ids = IBM.ICU.Util.TimeZone.GetAvailableIDs();
                bool bad = false;
                for (int i = 0; i < ids.Length; ++i)
                {
                    IBM.ICU.Util.TimeZone zone = IBM.ICU.Util.TimeZone.GetTimeZone(ids[i]);
                    IBM.ICU.Util.GregorianCalendar cal = new IBM.ICU.Util.GregorianCalendar(zone);
                    cal.Clear();
                    cal.Set(1900, 15, 5, 5, 8, 13);
                    if (cal.Get(IBM.ICU.Util.Calendar.HOUR) != 5)
                    {
                        Logln("Fail: " + zone.GetID() + " "
                                + zone.UseDaylightTime() + "; DST_OFFSET = "
                                + cal.Get(IBM.ICU.Util.Calendar.DST_OFFSET) / (60 * 60 * 1000.0d)
                                + "; ZONE_OFFSET = "
                                + cal.Get(IBM.ICU.Util.Calendar.ZONE_OFFSET)
                                / (60 * 60 * 1000.0d) + "; getRawOffset() = "
                                + zone.GetRawOffset() / (60 * 60 * 1000.0d)
                                + "; HOUR = " + cal.Get(IBM.ICU.Util.Calendar.HOUR));
                        cal.Clear();
                        cal.Set(1900, 15, 5, 5, 8, 13);
                        if (cal.Get(IBM.ICU.Util.Calendar.HOUR) != 5)
                        {
                            Logln("Fail: " + zone.GetID() + " "
                                    + zone.UseDaylightTime() + "; DST_OFFSET = "
                                    + cal.Get(IBM.ICU.Util.Calendar.DST_OFFSET)
                                    / (60 * 60 * 1000.0d) + "; ZONE_OFFSET = "
                                    + cal.Get(IBM.ICU.Util.Calendar.ZONE_OFFSET)
                                    / (60 * 60 * 1000.0d) + "; getRawOffset() = "
                                    + zone.GetRawOffset() / (60 * 60 * 1000.0d)
                                    + "; HOUR = " + cal.Get(IBM.ICU.Util.Calendar.HOUR));
                            cal.Clear();
                            cal.Set(1900, 15, 5, 5, 8, 13);
                            Logln("ms = " + cal.GetTime() + " ("
                                    + (cal.GetTime().Ticks / 10000) + ")");
                            cal.Get(IBM.ICU.Util.Calendar.HOUR);
                            IBM.ICU.Util.GregorianCalendar cal2 = new IBM.ICU.Util.GregorianCalendar(
                                    IBM.ICU.Util.TimeZone.GetTimeZone(ids[i]));
                            cal2.Clear();
                            cal2.Set(1900, 15, 5, 5, 8, 13);
                            cal2.Get(IBM.ICU.Util.Calendar.HOUR);
                            Logln("java.util.GC: " + zone.GetID() + " "
                                    + zone.UseDaylightTime() + "; DST_OFFSET = "
                                    + cal2.Get(IBM.ICU.Util.Calendar.DST_OFFSET)
                                    / (60 * 60 * 1000.0d) + "; ZONE_OFFSET = "
                                    + cal2.Get(IBM.ICU.Util.Calendar.ZONE_OFFSET)
                                    / (60 * 60 * 1000.0d) + "; getRawOffset() = "
                                    + zone.GetRawOffset() / (60 * 60 * 1000.0d)
                                    + "; HOUR = " + cal.Get(IBM.ICU.Util.Calendar.HOUR));
                            Logln("ms = " + cal2.GetTime() + " ("
                                    + (cal2.GetTime().Ticks / 10000) + ")");
                            bad = true;
                        }
                        else if (false)
                        { // Change to true to debug
                            Logln("OK: " + zone.GetID() + " "
                                    + zone.UseDaylightTime() + " "
                                    + cal.Get(IBM.ICU.Util.Calendar.DST_OFFSET)
                                    / (60 * 60 * 1000) + " " + zone.GetRawOffset()
                                    / (60 * 60 * 1000) + ": HOUR = "
                                    + cal.Get(IBM.ICU.Util.Calendar.HOUR));
                        }
                    }
                    if (bad)
                        Errln("TimeZone problems with GC");
                }
            }
            catch (MissingManifestResourceException e)
            {
                Warnln("Could not load data. " + e.Message);
            }
        }
        [Test]
        public void Test4035301()
        {

            try
            {
                IBM.ICU.Util.GregorianCalendar c = new IBM.ICU.Util.GregorianCalendar(98, 8, 7);
                IBM.ICU.Util.GregorianCalendar d = new IBM.ICU.Util.GregorianCalendar(98, 8, 7);
                if (c.After(d) || c.After(c) || c.Before(d) || c.Before(c)
                        || !c.Equals(c) || !c.Equals(d))
                    Errln("Fail");
            }
            catch (Exception e)
            {
                // TODO Auto-generated catch block
                Warnln("Could not load data. " + e.Message);
            }
        }
        [Test]
        public void Test4040996()
        {
            try
            {
                String[] ids = IBM.ICU.Util.TimeZone.GetAvailableIDs(-8 * 60 * 60 * 1000);
                SimpleTimeZone pdt = new SimpleTimeZone(-8 * 60 * 60 * 1000, ids[0]);
                pdt.SetStartRule(IBM.ICU.Util.Calendar.APRIL, 1, IBM.ICU.Util.Calendar.SUNDAY,
                        2 * 60 * 60 * 1000);
                pdt.SetEndRule(IBM.ICU.Util.Calendar.OCTOBER, -1, IBM.ICU.Util.Calendar.SUNDAY,
                        2 * 60 * 60 * 1000);
                IBM.ICU.Util.Calendar calendar = new IBM.ICU.Util.GregorianCalendar(pdt);

                calendar.Set(IBM.ICU.Util.Calendar.MONTH, 3);
                calendar.Set(IBM.ICU.Util.Calendar.DAY_OF_MONTH, 18);
                calendar.Set(IBM.ICU.Util.Calendar.SECOND, 30);

                Logln("MONTH: " + calendar.Get(IBM.ICU.Util.Calendar.MONTH));
                Logln("DAY_OF_MONTH: " + calendar.Get(IBM.ICU.Util.Calendar.DAY_OF_MONTH));
                Logln("MINUTE: " + calendar.Get(IBM.ICU.Util.Calendar.MINUTE));
                Logln("SECOND: " + calendar.Get(IBM.ICU.Util.Calendar.SECOND));

                calendar.Add(IBM.ICU.Util.Calendar.SECOND, 6);
                // This will print out todays date for MONTH and DAY_OF_MONTH
                // instead of the date it was set to.
                // This happens when adding MILLISECOND or MINUTE also
                Logln("MONTH: " + calendar.Get(IBM.ICU.Util.Calendar.MONTH));
                Logln("DAY_OF_MONTH: " + calendar.Get(IBM.ICU.Util.Calendar.DAY_OF_MONTH));
                Logln("MINUTE: " + calendar.Get(IBM.ICU.Util.Calendar.MINUTE));
                Logln("SECOND: " + calendar.Get(IBM.ICU.Util.Calendar.SECOND));
                if (calendar.Get(IBM.ICU.Util.Calendar.MONTH) != 3
                        || calendar.Get(IBM.ICU.Util.Calendar.DAY_OF_MONTH) != 18
                        || calendar.Get(IBM.ICU.Util.Calendar.SECOND) != 36)
                    Errln("Fail: Calendar.add misbehaves");
            }
            catch (Exception e)
            {
                Warnln("Could not load data. " + e.Message);
            }
        }
        [Test]
        public void Test4051765()
        {
            try
            {
                IBM.ICU.Util.Calendar cal = IBM.ICU.Util.Calendar.GetInstance();
                cal.SetLenient(false);
                cal.Set(IBM.ICU.Util.Calendar.DAY_OF_WEEK, 0);
                try
                {
                    cal.GetTime();
                    Errln("Fail: DAY_OF_WEEK 0 should be disallowed");
                }
                catch (ArgumentException e)
                {
                    return;
                }
            }
            catch (Exception e_0)
            {
                // TODO Auto-generated catch block
                Warnln("Could not load data. " + e_0.Message);
            }
        }

        /*
         * User error - no bug here public void Test4059524() { // Create calendar
         * for April 10, 1997 GregorianCalendar calendar = new GregorianCalendar();
         * // print out a bunch of interesting things logln("ERA: " +
         * calendar.get(calendar.ERA)); logln("YEAR: " +
         * calendar.get(calendar.YEAR)); logln("MONTH: " +
         * calendar.get(calendar.MONTH)); logln("WEEK_OF_YEAR: " +
         * calendar.get(calendar.WEEK_OF_YEAR)); logln("WEEK_OF_MONTH: " +
         * calendar.get(calendar.WEEK_OF_MONTH)); logln("DATE: " +
         * calendar.get(calendar.DATE)); logln("DAY_OF_MONTH: " +
         * calendar.get(calendar.DAY_OF_MONTH)); logln("DAY_OF_YEAR: " +
         * calendar.get(calendar.DAY_OF_YEAR)); logln("DAY_OF_WEEK: " +
         * calendar.get(calendar.DAY_OF_WEEK)); logln("DAY_OF_WEEK_IN_MONTH: " +
         * calendar.get(calendar.DAY_OF_WEEK_IN_MONTH)); logln("AM_PM: " +
         * calendar.get(calendar.AM_PM)); logln("HOUR: " +
         * calendar.get(calendar.HOUR)); logln("HOUR_OF_DAY: " +
         * calendar.get(calendar.HOUR_OF_DAY)); logln("MINUTE: " +
         * calendar.get(calendar.MINUTE)); logln("SECOND: " +
         * calendar.get(calendar.SECOND)); logln("MILLISECOND: " +
         * calendar.get(calendar.MILLISECOND)); logln("ZONE_OFFSET: " +
         * (calendar.get(calendar.ZONE_OFFSET)/(60*60*1000))); logln("DST_OFFSET: "
         * + (calendar.get(calendar.DST_OFFSET)/(60*60*1000))); calendar = new
         * GregorianCalendar(1997,3,10); calendar.getTime(); logln("April 10,
         * 1997"); logln("ERA: " + calendar.get(calendar.ERA)); logln("YEAR: " +
         * calendar.get(calendar.YEAR)); logln("MONTH: " +
         * calendar.get(calendar.MONTH)); logln("WEEK_OF_YEAR: " +
         * calendar.get(calendar.WEEK_OF_YEAR)); logln("WEEK_OF_MONTH: " +
         * calendar.get(calendar.WEEK_OF_MONTH)); logln("DATE: " +
         * calendar.get(calendar.DATE)); logln("DAY_OF_MONTH: " +
         * calendar.get(calendar.DAY_OF_MONTH)); logln("DAY_OF_YEAR: " +
         * calendar.get(calendar.DAY_OF_YEAR)); logln("DAY_OF_WEEK: " +
         * calendar.get(calendar.DAY_OF_WEEK)); logln("DAY_OF_WEEK_IN_MONTH: " +
         * calendar.get(calendar.DAY_OF_WEEK_IN_MONTH)); logln("AM_PM: " +
         * calendar.get(calendar.AM_PM)); logln("HOUR: " +
         * calendar.get(calendar.HOUR)); logln("HOUR_OF_DAY: " +
         * calendar.get(calendar.HOUR_OF_DAY)); logln("MINUTE: " +
         * calendar.get(calendar.MINUTE)); logln("SECOND: " +
         * calendar.get(calendar.SECOND)); logln("MILLISECOND: " +
         * calendar.get(calendar.MILLISECOND)); logln("ZONE_OFFSET: " +
         * (calendar.get(calendar.ZONE_OFFSET)/(60*60*1000))); // in hours
         * logln("DST_OFFSET: " + (calendar.get(calendar.DST_OFFSET)/(60*60*1000)));
         * // in hours }
         */
        [Test]
        public void Test4059654()
        {
            // try {
            // work around bug for jdk1.4 on solaris 2.6, which uses funky
            // timezone names
            // jdk1.4.1 will drop support for 2.6 so we should be ok when it
            // comes out
            IBM.ICU.Util.TimeZone javazone = IBM.ICU.Util.TimeZone.GetTimeZone("GMT");
            IBM.ICU.Util.TimeZone icuzone = IBM.ICU.Util.TimeZone.GetTimeZone("GMT");

            IBM.ICU.Util.GregorianCalendar gc = new IBM.ICU.Util.GregorianCalendar(icuzone);

            gc.Set(1997, 3, 1, 15, 16, 17); // April 1, 1997

            gc.Set(IBM.ICU.Util.Calendar.HOUR, 0);
            gc.Set(IBM.ICU.Util.Calendar.AM_PM, IBM.ICU.Util.Calendar.AM);
            gc.Set(IBM.ICU.Util.Calendar.MINUTE, 0);
            gc.Set(IBM.ICU.Util.Calendar.SECOND, 0);
            gc.Set(IBM.ICU.Util.Calendar.MILLISECOND, 0);

            DateTime cd = gc.GetTime();
            IBM.ICU.Util.Calendar cal = IBM.ICU.Util.Calendar.GetInstance(javazone);
            cal.Clear();
            cal.Set(1997, 3, 1, 0, 0, 0);
            DateTime exp = cal.GetTime();
            if (!cd.Equals(exp))
                Errln("Fail: Calendar.set broken. Got " + cd + " Want " + exp);
            // } catch (RuntimeException e) {
            // TODO Auto-generated catch block
            // e.printStackTrace();
            // }
        }
        [Test]
        public void Test4061476()
        {
            IBM.ICU.Text.SimpleDateFormat fmt = new IBM.ICU.Text.SimpleDateFormat("ddMMMyy", Locale.UK);
            IBM.ICU.Util.Calendar cal = IBM.ICU.Util.Calendar.GetInstance(
                    IBM.ICU.Util.TimeZone.GetTimeZone("GMT"), Locale.UK);
            fmt.SetCalendar(cal);
            try
            {
                DateTime date = fmt.Parse("29MAY97");
                cal.SetTime(date);
            }
            catch (Exception e)
            {
                System.Console.Out.Write("");
            }
            cal.Set(IBM.ICU.Util.Calendar.HOUR_OF_DAY, 13);
            Logln("Hour: " + cal.Get(IBM.ICU.Util.Calendar.HOUR_OF_DAY));
            cal.Add(IBM.ICU.Util.Calendar.HOUR_OF_DAY, 6);
            Logln("Hour: " + cal.Get(IBM.ICU.Util.Calendar.HOUR_OF_DAY));
            if (cal.Get(IBM.ICU.Util.Calendar.HOUR_OF_DAY) != 19)
                Errln("Fail: Want 19 Got " + cal.Get(IBM.ICU.Util.Calendar.HOUR_OF_DAY));
        }
        [Test]
        public void Test4070502()
        {
            IBM.ICU.Util.Calendar tempcal = IBM.ICU.Util.Calendar.GetInstance();
            tempcal.Clear();
            tempcal.Set(1998, 0, 30);
            DateTime d = GetAssociatedDate(tempcal.GetTime());
            IBM.ICU.Util.Calendar cal = new IBM.ICU.Util.GregorianCalendar();
            cal.SetTime(d);
            if (cal.Get(IBM.ICU.Util.Calendar.DAY_OF_WEEK) == IBM.ICU.Util.Calendar.SATURDAY
                    || cal.Get(IBM.ICU.Util.Calendar.DAY_OF_WEEK) == IBM.ICU.Util.Calendar.SUNDAY)
                Errln("Fail: Want weekday Got " + d);
        }

        /// <summary>
        /// Get the associated date starting from a specified date NOTE: the
        /// unnecessary "getTime()'s" below are a work-around for a bug in jdk 1.1.3
        /// (and probably earlier versions also)
        /// <p>
        /// </summary>
        ///
        /// <param name="d">The date to start from</param>
        public static DateTime GetAssociatedDate(DateTime d)
        {
            IBM.ICU.Util.GregorianCalendar cal = new IBM.ICU.Util.GregorianCalendar();
            cal.SetTime(d);
            // cal.add(field, amount); //<-- PROBLEM SEEN WITH field = DATE,MONTH
            // cal.getTime(); // <--- REMOVE THIS TO SEE BUG
            while (true)
            {
                int wd = cal.Get(IBM.ICU.Util.Calendar.DAY_OF_WEEK);
                if (wd == IBM.ICU.Util.Calendar.SATURDAY || wd == IBM.ICU.Util.Calendar.SUNDAY)
                {
                    cal.Add(IBM.ICU.Util.Calendar.DATE, 1);
                    // cal.getTime();
                }
                else
                    break;
            }
            return cal.GetTime();
        }
        [Test]
        public void Test4071197()
        {
            DowTest(false);
            DowTest(true);
        }

        internal void DowTest(bool lenient)
        {
            IBM.ICU.Util.GregorianCalendar cal = new IBM.ICU.Util.GregorianCalendar();
            cal.Set(1997, IBM.ICU.Util.Calendar.AUGUST, 12); // Wednesday
            // cal.getTime(); // Force update
            cal.SetLenient(lenient);
            cal.Set(1996, IBM.ICU.Util.Calendar.DECEMBER, 1); // Set the date to be December 1,
            // 1996
            int dow = cal.Get(IBM.ICU.Util.Calendar.DAY_OF_WEEK);
            int min = cal.GetMinimum(IBM.ICU.Util.Calendar.DAY_OF_WEEK);
            int max = cal.GetMaximum(IBM.ICU.Util.Calendar.DAY_OF_WEEK);
            Logln(cal.GetTime().ToString());
            if (min != IBM.ICU.Util.Calendar.SUNDAY || max != IBM.ICU.Util.Calendar.SATURDAY)
                Errln("FAIL: Min/max bad");
            if (dow < min || dow > max)
                Errln("FAIL: Day of week " + dow + " out of range");
            if (dow != IBM.ICU.Util.Calendar.SUNDAY)
                Errln("FAIL: Day of week should be SUNDAY Got " + dow);
        }
        [Test]
        public void Test4071385()
        {
            // work around bug for jdk1.4 on solaris 2.6, which uses funky timezone
            // names
            // jdk1.4.1 will drop support for 2.6 so we should be ok when it comes
            // out
            IBM.ICU.Util.TimeZone javazone = IBM.ICU.Util.TimeZone.GetTimeZone("GMT");
            IBM.ICU.Util.TimeZone icuzone = IBM.ICU.Util.TimeZone.GetTimeZone("GMT");

            IBM.ICU.Util.Calendar cal = IBM.ICU.Util.Calendar.GetInstance(icuzone);
            IBM.ICU.Util.Calendar tempcal = IBM.ICU.Util.Calendar.GetInstance(javazone);
            tempcal.Clear();
            tempcal.Set(1998, IBM.ICU.Util.Calendar.JUNE, 24);
            cal.SetTime(tempcal.GetTime());
            cal.Set(IBM.ICU.Util.Calendar.MONTH, IBM.ICU.Util.Calendar.NOVEMBER); // change a field
            Logln(cal.GetTime().ToString());
            tempcal.Set(1998, IBM.ICU.Util.Calendar.NOVEMBER, 24);
            if (!cal.GetTime().Equals(tempcal.GetTime()))
                Errln("Fail");
        }
        [Test]
        public void Test4073929()
        {
            IBM.ICU.Util.GregorianCalendar foo1 = new IBM.ICU.Util.GregorianCalendar(1997, 8, 27);
            foo1.Add(IBM.ICU.Util.Calendar.DAY_OF_MONTH, +1);
            int testyear = foo1.Get(IBM.ICU.Util.Calendar.YEAR);
            int testmonth = foo1.Get(IBM.ICU.Util.Calendar.MONTH);
            int testday = foo1.Get(IBM.ICU.Util.Calendar.DAY_OF_MONTH);
            if (testyear != 1997 || testmonth != 8 || testday != 28)
                Errln("Fail: Calendar not initialized");
        }
        [Test]
        public void Test4083167()
        {
            IBM.ICU.Util.TimeZone saveZone = IBM.ICU.Util.TimeZone.GetDefault();
            try
            {
                IBM.ICU.Util.TimeZone.SetDefault(IBM.ICU.Util.TimeZone.GetTimeZone("UTC"));
                DateTime firstDate = DateTime.Now;
                IBM.ICU.Util.Calendar cal = new IBM.ICU.Util.GregorianCalendar();
                cal.SetTime(firstDate);
                long firstMillisInDay = cal.Get(IBM.ICU.Util.Calendar.HOUR_OF_DAY) * 3600000L
                        + cal.Get(IBM.ICU.Util.Calendar.MINUTE) * 60000L
                        + cal.Get(IBM.ICU.Util.Calendar.SECOND) * 1000L
                        + cal.Get(IBM.ICU.Util.Calendar.MILLISECOND);

                Logln("Current time: " + firstDate.ToString());

                for (int validity = 0; validity < 30; validity++)
                {
                    DateTime lastDate = DateUtil.DateFromJavaMillis(((firstDate.Ticks / 10000) + (long)validity
                                            * 1000 * 24 * 60 * 60));
                    cal.SetTime(lastDate);
                    long millisInDay = cal.Get(IBM.ICU.Util.Calendar.HOUR_OF_DAY) * 3600000L
                            + cal.Get(IBM.ICU.Util.Calendar.MINUTE) * 60000L
                            + cal.Get(IBM.ICU.Util.Calendar.SECOND) * 1000L
                            + cal.Get(IBM.ICU.Util.Calendar.MILLISECOND);
                    if (firstMillisInDay != millisInDay)
                        Errln("Day has shifted " + lastDate);
                }
            }
            finally
            {
                IBM.ICU.Util.TimeZone.SetDefault(saveZone);
            }
        }
        [Test]
        public void Test4086724()
        {
            IBM.ICU.Text.SimpleDateFormat date;
            IBM.ICU.Util.TimeZone saveZone = IBM.ICU.Util.TimeZone.GetDefault();
            Locale saveLocale = Locale.GetDefault();
            try
            {
                Locale.SetDefault(Locale.UK);
                IBM.ICU.Util.TimeZone.SetDefault(IBM.ICU.Util.TimeZone.GetTimeZone("GMT"));
                date = new IBM.ICU.Text.SimpleDateFormat("dd MMM yyy (zzzz) 'is in week' ww");
                IBM.ICU.Util.Calendar cal = IBM.ICU.Util.Calendar.GetInstance();
                cal.Set(1997, IBM.ICU.Util.Calendar.SEPTEMBER, 30);
                DateTime now = cal.GetTime();
                Logln(date.Format(now));
                cal.Set(1997, IBM.ICU.Util.Calendar.JANUARY, 1);
                now = cal.GetTime();
                Logln(date.Format(now));
                cal.Set(1997, IBM.ICU.Util.Calendar.JANUARY, 8);
                now = cal.GetTime();
                Logln(date.Format(now));
                cal.Set(1996, IBM.ICU.Util.Calendar.DECEMBER, 31);
                now = cal.GetTime();
                Logln(date.Format(now));
            }
            finally
            {
                Locale.SetDefault(saveLocale);
                IBM.ICU.Util.TimeZone.SetDefault(saveZone);
            }
            Logln("*** THE RESULTS OF THIS TEST MUST BE VERIFIED MANUALLY ***");
        }
        [Test]
        public void Test4092362()
        {
            IBM.ICU.Util.GregorianCalendar cal1 = new IBM.ICU.Util.GregorianCalendar(1997, 10, 11, 10, 20, 40);
            /*
             * cal1.set( Calendar.YEAR, 1997 ); cal1.set( Calendar.MONTH, 10 );
             * cal1.set( Calendar.DATE, 11 ); cal1.set( Calendar.HOUR, 10 );
             * cal1.set( Calendar.MINUTE, 20 ); cal1.set( Calendar.SECOND, 40 );
             */

            Logln(" Cal1 = " + (cal1.GetTime().Ticks / 10000));
            Logln(" Cal1 time in ms = " + cal1.Get(IBM.ICU.Util.Calendar.MILLISECOND));
            for (int k = 0; k < 100; k++)
            {
                System.Console.Out.Write("");
            }

            IBM.ICU.Util.GregorianCalendar cal2 = new IBM.ICU.Util.GregorianCalendar(1997, 10, 11, 10, 20, 40);
            /*
             * cal2.set( Calendar.YEAR, 1997 ); cal2.set( Calendar.MONTH, 10 );
             * cal2.set( Calendar.DATE, 11 ); cal2.set( Calendar.HOUR, 10 );
             * cal2.set( Calendar.MINUTE, 20 ); cal2.set( Calendar.SECOND, 40 );
             */

            Logln(" Cal2 = " + (cal2.GetTime().Ticks / 10000));
            Logln(" Cal2 time in ms = " + cal2.Get(IBM.ICU.Util.Calendar.MILLISECOND));
            if (!cal1.Equals(cal2))
                Errln("Fail: Milliseconds randomized");
        }
        [Test]
        public void Test4095407()
        {
            IBM.ICU.Util.GregorianCalendar a = new IBM.ICU.Util.GregorianCalendar(1997, IBM.ICU.Util.Calendar.NOVEMBER, 13);
            int dow = a.Get(IBM.ICU.Util.Calendar.DAY_OF_WEEK);
            if (dow != IBM.ICU.Util.Calendar.THURSDAY)
                Errln("Fail: Want THURSDAY Got " + dow);
        }
        [Test]
        public void Test4096231()
        {
            IBM.ICU.Util.TimeZone GMT = IBM.ICU.Util.TimeZone.GetTimeZone("GMT");
            IBM.ICU.Util.TimeZone PST = IBM.ICU.Util.TimeZone.GetTimeZone("PST");
            int sec = 0, min = 0, hr = 0, day = 1, month = 10, year = 1997;

            IBM.ICU.Util.Calendar cal1 = new IBM.ICU.Util.GregorianCalendar(PST);
            cal1.SetTime(DateUtil.DateFromJavaMillis((880698639000L)));
            int p;
            Logln("PST 1 is: " + (p = cal1.Get(IBM.ICU.Util.Calendar.HOUR_OF_DAY)));
            cal1.SetTimeZone(GMT);
            // Issue 1: Changing the timezone doesn't change the
            // represented time.
            int h1, h2;
            Logln("GMT 1 is: " + (h1 = cal1.Get(IBM.ICU.Util.Calendar.HOUR_OF_DAY)));
            cal1.SetTime(DateUtil.DateFromJavaMillis((880698639000L)));
            Logln("GMT 2 is: " + (h2 = cal1.Get(IBM.ICU.Util.Calendar.HOUR_OF_DAY)));
            // Note: This test had a bug in it. It wanted h1!=h2, when
            // what was meant was h1!=p. Fixed this concurrent with fix
            // to 4177484.
            if (p == h1 || h1 != h2)
                Errln("Fail: Hour same in different zones");

            IBM.ICU.Util.Calendar cal2 = new IBM.ICU.Util.GregorianCalendar(GMT);
            IBM.ICU.Util.Calendar cal3 = new IBM.ICU.Util.GregorianCalendar(PST);
            cal2.Set(IBM.ICU.Util.Calendar.MILLISECOND, 0);
            cal3.Set(IBM.ICU.Util.Calendar.MILLISECOND, 0);

            cal2.Set(cal1.Get(IBM.ICU.Util.Calendar.YEAR), cal1.Get(IBM.ICU.Util.Calendar.MONTH),
                    cal1.Get(IBM.ICU.Util.Calendar.DAY_OF_MONTH),
                    cal1.Get(IBM.ICU.Util.Calendar.HOUR_OF_DAY), cal1.Get(IBM.ICU.Util.Calendar.MINUTE),
                    cal1.Get(IBM.ICU.Util.Calendar.SECOND));

            long t1, t2, t3, t4;
            Logln("RGMT 1 is: " + (t1 = (cal2.GetTime().Ticks / 10000)));
            cal3.Set(year, month, day, hr, min, sec);
            Logln("RPST 1 is: " + (t2 = (cal3.GetTime().Ticks / 10000)));
            cal3.SetTimeZone(GMT);
            Logln("RGMT 2 is: " + (t3 = (cal3.GetTime().Ticks / 10000)));
            cal3.Set(cal1.Get(IBM.ICU.Util.Calendar.YEAR), cal1.Get(IBM.ICU.Util.Calendar.MONTH),
                    cal1.Get(IBM.ICU.Util.Calendar.DAY_OF_MONTH),
                    cal1.Get(IBM.ICU.Util.Calendar.HOUR_OF_DAY), cal1.Get(IBM.ICU.Util.Calendar.MINUTE),
                    cal1.Get(IBM.ICU.Util.Calendar.SECOND));
            // Issue 2: Calendar continues to use the timezone in its
            // constructor for set() conversions, regardless
            // of calls to setTimeZone()
            Logln("RGMT 3 is: " + (t4 = (cal3.GetTime().Ticks / 10000)));
            if (t1 == t2 || t1 != t4 || t2 != t3)
                Errln("Fail: Calendar zone behavior faulty");
        }
        [Test]
        public void Test4096539()
        {
            int[] y = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };

            for (int x = 0; x < 12; x++)
            {
                IBM.ICU.Util.GregorianCalendar gc = new IBM.ICU.Util.GregorianCalendar(1997, x, y[x]);
                int m1, m2;
                Log((m1 = gc.Get(IBM.ICU.Util.Calendar.MONTH) + 1) + "/" + gc.Get(IBM.ICU.Util.Calendar.DATE)
                        + "/" + gc.Get(IBM.ICU.Util.Calendar.YEAR) + " + 1mo = ");

                gc.Add(IBM.ICU.Util.Calendar.MONTH, 1);
                Logln((m2 = gc.Get(IBM.ICU.Util.Calendar.MONTH) + 1) + "/"
                        + gc.Get(IBM.ICU.Util.Calendar.DATE) + "/" + gc.Get(IBM.ICU.Util.Calendar.YEAR));
                int m = (m1 % 12) + 1;
                if (m2 != m)
                    Errln("Fail: Want " + m + " Got " + m2);
            }

        }
        [Test]
        public void Test4100311()
        {
            IBM.ICU.Util.GregorianCalendar cal = (IBM.ICU.Util.GregorianCalendar)IBM.ICU.Util.Calendar.GetInstance();
            cal.Set(IBM.ICU.Util.Calendar.YEAR, 1997);
            cal.Set(IBM.ICU.Util.Calendar.DAY_OF_YEAR, 1);
            DateTime d = cal.GetTime(); // Should be Jan 1
            Logln(d.ToString());
            if (cal.Get(IBM.ICU.Util.Calendar.DAY_OF_YEAR) != 1)
                Errln("Fail: DAY_OF_YEAR not set");
        }
        [Test]
        public void Test4103271()
        {
            IBM.ICU.Text.SimpleDateFormat sdf = new IBM.ICU.Text.SimpleDateFormat();
            int numYears = 40, startYear = 1997, numDays = 15;
            String output, testDesc;
            IBM.ICU.Util.GregorianCalendar testCal = (IBM.ICU.Util.GregorianCalendar)IBM.ICU.Util.Calendar.GetInstance();
            testCal.Clear();
            sdf.SetCalendar(testCal);
            sdf.ApplyPattern("d MMM yyyy");
            bool fail = false;
            for (int firstDay = 1; firstDay <= 2; firstDay++)
            {
                for (int minDays = 1; minDays <= 7; minDays++)
                {
                    testCal.SetMinimalDaysInFirstWeek(minDays);
                    testCal.SetFirstDayOfWeek(firstDay);
                    testDesc = ("Test" + firstDay.ToString() + minDays.ToString());
                    Logln(testDesc + " => 1st day of week="
                            + firstDay.ToString()
                            + ", minimum days in first week="
                            + minDays.ToString());
                    for (int j = startYear; j <= startYear + numYears; j++)
                    {
                        testCal.Set(j, 11, 25);
                        for (int i = 0; i < numDays; i++)
                        {
                            testCal.Add(IBM.ICU.Util.Calendar.DATE, 1);
                            String calWOY;
                            int actWOY = testCal.Get(IBM.ICU.Util.Calendar.WEEK_OF_YEAR);
                            if (actWOY < 1 || actWOY > 53)
                            {
                                DateTime d = testCal.GetTime();
                                calWOY = actWOY.ToString();
                                output = testDesc + " - " + sdf.Format(d) + "\t";
                                output = output + "\t" + calWOY;
                                Logln(output);
                                fail = true;
                            }
                        }
                    }
                }
            }

            int[] DATA = { 3, 52, 52, 52, 52, 52, 52, 52, 1, 1, 1, 1, 1, 1, 1, 2,
	                2, 2, 2, 2, 2, 2, 4, 52, 52, 52, 52, 52, 52, 52, 53, 53, 53,
	                53, 53, 53, 53, 1, 1, 1, 1, 1, 1, 1, };
            testCal.SetFirstDayOfWeek(IBM.ICU.Util.Calendar.SUNDAY);
            for (int j_0 = 0; j_0 < DATA.Length; j_0 += 22)
            {
                Logln("Minimal days in first week = " + DATA[j_0]
                        + "  Week starts on Sunday");
                testCal.SetMinimalDaysInFirstWeek(DATA[j_0]);
                testCal.Set(1997, IBM.ICU.Util.Calendar.DECEMBER, 21);
                for (int i_1 = 0; i_1 < 21; ++i_1)
                {
                    int woy = testCal.Get(IBM.ICU.Util.Calendar.WEEK_OF_YEAR);
                    Log(testCal.GetTime() + " " + woy);
                    if (woy != DATA[j_0 + 1 + i_1])
                    {
                        Log(" ERROR");
                        fail = true;
                    }
                    // logln();

                    // Now compute the time from the fields, and make sure we
                    // get the same answer back. This is a round-trip test.
                    DateTime save = testCal.GetTime();
                    testCal.Clear();
                    testCal.Set(IBM.ICU.Util.Calendar.YEAR, (DATA[j_0 + 1 + i_1] < 25) ? 1998 : 1997);
                    testCal.Set(IBM.ICU.Util.Calendar.WEEK_OF_YEAR, DATA[j_0 + 1 + i_1]);
                    testCal.Set(IBM.ICU.Util.Calendar.DAY_OF_WEEK, (i_1 % 7) + IBM.ICU.Util.Calendar.SUNDAY);
                    if (!testCal.GetTime().Equals(save))
                    {
                        Logln("  Parse failed: " + testCal.GetTime());
                        fail = true;
                    }

                    testCal.SetTime(save);
                    testCal.Add(IBM.ICU.Util.Calendar.DAY_OF_MONTH, 1);
                }
            }

            DateTime[] d_2 = new DateTime[8];
            IBM.ICU.Util.Calendar tempcal = IBM.ICU.Util.Calendar.GetInstance();
            tempcal.Clear();
            tempcal.Set(1997, IBM.ICU.Util.Calendar.DECEMBER, 28);
            d_2[0] = tempcal.GetTime();
            tempcal.Set(1998, IBM.ICU.Util.Calendar.JANUARY, 10);
            d_2[1] = tempcal.GetTime();
            tempcal.Set(1998, IBM.ICU.Util.Calendar.DECEMBER, 31);
            d_2[2] = tempcal.GetTime();
            tempcal.Set(1999, IBM.ICU.Util.Calendar.JANUARY, 1);
            d_2[3] = tempcal.GetTime();
            // Test field disambiguation with a few special hard-coded cases.
            // This shouldn't fail if the above cases aren't failing.
            Object[] DISAM = { ((int)(1998)), ((int)(1)),
	                ((int)(IBM.ICU.Util.Calendar.SUNDAY)), d_2[0], ((int)(1998)),
	                ((int)(2)), ((int)(IBM.ICU.Util.Calendar.SATURDAY)), d_2[1],
	                ((int)(1998)), ((int)(53)),
	                ((int)(IBM.ICU.Util.Calendar.THURSDAY)), d_2[2], ((int)(1998)),
	                ((int)(53)), ((int)(IBM.ICU.Util.Calendar.FRIDAY)), d_2[3], };
            testCal.SetMinimalDaysInFirstWeek(3);
            testCal.SetFirstDayOfWeek(IBM.ICU.Util.Calendar.SUNDAY);
            for (int i_3 = 0; i_3 < DISAM.Length; i_3 += 4)
            {
                int y = ((Int32)DISAM[i_3]);
                int woy_4 = ((Int32)DISAM[i_3 + 1]);
                int dow = ((Int32)DISAM[i_3 + 2]);
                DateTime exp = (DateTime)DISAM[i_3 + 3];
                testCal.Clear();
                testCal.Set(IBM.ICU.Util.Calendar.YEAR, y);
                testCal.Set(IBM.ICU.Util.Calendar.WEEK_OF_YEAR, woy_4);
                testCal.Set(IBM.ICU.Util.Calendar.DAY_OF_WEEK, dow);
                Log(y + "-W" + woy_4 + "-DOW" + dow + " expect:" + exp + " got:"
                        + testCal.GetTime());
                if (!testCal.GetTime().Equals(exp))
                {
                    Log("  FAIL");
                    fail = true;
                }
                // logln();
            }

            // Now try adding and rolling
            Object ADD = new Object();
            Object ROLL = new Object();
            tempcal.Set(1998, IBM.ICU.Util.Calendar.DECEMBER, 25);
            d_2[0] = tempcal.GetTime();
            tempcal.Set(1999, IBM.ICU.Util.Calendar.JANUARY, 1);
            d_2[1] = tempcal.GetTime();
            tempcal.Set(1997, IBM.ICU.Util.Calendar.DECEMBER, 28);
            d_2[2] = tempcal.GetTime();
            tempcal.Set(1998, IBM.ICU.Util.Calendar.JANUARY, 4);
            d_2[3] = tempcal.GetTime();
            tempcal.Set(1998, IBM.ICU.Util.Calendar.DECEMBER, 27);
            d_2[4] = tempcal.GetTime();
            tempcal.Set(1997, IBM.ICU.Util.Calendar.DECEMBER, 28);
            d_2[5] = tempcal.GetTime();
            tempcal.Set(1999, IBM.ICU.Util.Calendar.JANUARY, 2);
            d_2[6] = tempcal.GetTime();
            tempcal.Set(1998, IBM.ICU.Util.Calendar.JANUARY, 3);
            d_2[7] = tempcal.GetTime();

            Object[] ADDROLL = { ADD, ((int)(1)), d_2[0], d_2[1], ADD,
	                ((int)(1)), d_2[2], d_2[3], ROLL, ((int)(1)), d_2[4], d_2[5],
	                ROLL, ((int)(1)), d_2[6], d_2[7], };
            testCal.SetMinimalDaysInFirstWeek(3);
            testCal.SetFirstDayOfWeek(IBM.ICU.Util.Calendar.SUNDAY);
            for (int i_5 = 0; i_5 < ADDROLL.Length; i_5 += 4)
            {
                int amount = ((Int32)ADDROLL[i_5 + 1]);
                DateTime before = (DateTime)ADDROLL[i_5 + 2];
                DateTime after = (DateTime)ADDROLL[i_5 + 3];

                testCal.SetTime(before);
                if (ADDROLL[i_5] == ADD)
                    testCal.Add(IBM.ICU.Util.Calendar.WEEK_OF_YEAR, amount);
                else
                    testCal.Roll(IBM.ICU.Util.Calendar.WEEK_OF_YEAR, amount);
                Log(((ADDROLL[i_5] == ADD) ? "add(WOY," : "roll(WOY,") + amount + ") "
                        + before + " => " + testCal.GetTime());
                if (!after.Equals(testCal.GetTime()))
                {
                    Logln("  exp:" + after + "  FAIL");
                    fail = true;
                }
                else
                    Logln(" ok");

                testCal.SetTime(after);
                if (ADDROLL[i_5] == ADD)
                    testCal.Add(IBM.ICU.Util.Calendar.WEEK_OF_YEAR, -amount);
                else
                    testCal.Roll(IBM.ICU.Util.Calendar.WEEK_OF_YEAR, -amount);
                Log(((ADDROLL[i_5] == ADD) ? "add(WOY," : "roll(WOY,") + (-amount)
                        + ") " + after + " => " + testCal.GetTime());
                if (!before.Equals(testCal.GetTime()))
                {
                    Logln("  exp:" + before + "  FAIL");
                    fail = true;
                }
                else
                    Logln(" ok");
            }

            if (fail)
                Errln("Fail: Week of year misbehaving");
        }
        [Test]
        public void Test4106136()
        {
            Locale saveLocale = Locale.GetDefault();
            String[] names = { "Calendar", "DateFormat", "NumberFormat" };
            try
            {
                Locale[] locales = { Locale.CHINESE, Locale.CHINA };
                for (int i = 0; i < locales.Length; ++i)
                {
                    Locale.SetDefault(locales[i]);
                    int[] n = { IBM.ICU.Util.Calendar.GetAvailableLocales().Length,
	                        IBM.ICU.Text.DateFormat.GetAvailableLocales().Length,
	                        IBM.ICU.Text.NumberFormat.GetAvailableLocales().Length };
                    for (int j = 0; j < n.Length; ++j)
                    {
                        if (n[j] == 0)
                            Errln("Fail: " + names[j] + " has no locales for "
                                    + locales[i]);
                    }
                }
            }
            finally
            {
                Locale.SetDefault(saveLocale);
            }
        }
        [Test]
        public void Test4108764()
        {
            IBM.ICU.Util.Calendar tempcal = IBM.ICU.Util.Calendar.GetInstance();
            tempcal.Clear();
            tempcal.Set(1997, IBM.ICU.Util.Calendar.MARCH, 15, 12, 0x0, 0x0);
            DateTime d00 = tempcal.GetTime();
            tempcal.Set(1997, IBM.ICU.Util.Calendar.MARCH, 15, 12, 0x0, 56);
            DateTime d01 = tempcal.GetTime();
            tempcal.Set(1997, IBM.ICU.Util.Calendar.MARCH, 15, 12, 34, 0x0);
            DateTime d10 = tempcal.GetTime();
            tempcal.Set(1997, IBM.ICU.Util.Calendar.MARCH, 15, 12, 34, 56);
            DateTime d11 = tempcal.GetTime();
            tempcal.Set(1997, IBM.ICU.Util.Calendar.JANUARY, 15, 12, 34, 56);
            DateTime dM = tempcal.GetTime();
            tempcal.Clear();
            tempcal.Set(1970, IBM.ICU.Util.Calendar.JANUARY, 1);
            DateTime epoch = tempcal.GetTime();

            IBM.ICU.Util.Calendar cal = IBM.ICU.Util.Calendar.GetInstance();
            cal.SetTime(d11);

            cal.Clear(IBM.ICU.Util.Calendar.MINUTE);
            Logln(cal.GetTime().ToString());
            if (!cal.GetTime().Equals(d01))
            {
                Errln("Fail: " + d11 + " clear(MINUTE) => expect " + d01 + ", got "
                        + cal.GetTime());
            }

            cal.Set(IBM.ICU.Util.Calendar.SECOND, 0);
            Logln(cal.GetTime().ToString());
            if (!cal.GetTime().Equals(d00))
                Errln("Fail: set(SECOND, 0) broken");

            cal.SetTime(d11);
            cal.Set(IBM.ICU.Util.Calendar.SECOND, 0);
            Logln(cal.GetTime().ToString());
            if (!cal.GetTime().Equals(d10))
                Errln("Fail: set(SECOND, 0) broken #2");

            cal.Clear(IBM.ICU.Util.Calendar.MINUTE);
            Logln(cal.GetTime().ToString());
            if (!cal.GetTime().Equals(d00))
                Errln("Fail: clear(MINUTE) broken #2");

            cal.Clear();
            Logln(cal.GetTime().ToString());
            if (!cal.GetTime().Equals(epoch))
                Errln("Fail: after clear() expect " + epoch + ", got "
                        + cal.GetTime());

            cal.SetTime(d11);
            cal.Clear(IBM.ICU.Util.Calendar.MONTH);
            Logln(cal.GetTime().ToString());
            if (!cal.GetTime().Equals(dM))
            {
                Errln("Fail: " + d11 + " clear(MONTH) => expect " + dM + ", got "
                        + cal.GetTime());
            }
        }
        [Test]
        public void Test4114578()
        {
            int ONE_HOUR = 60 * 60 * 1000;
            IBM.ICU.Util.Calendar cal = IBM.ICU.Util.Calendar.GetInstance();
            cal.SetTimeZone(IBM.ICU.Util.TimeZone.GetTimeZone("PST"));

            IBM.ICU.Util.Calendar tempcal = IBM.ICU.Util.Calendar.GetInstance();
            tempcal.Clear();
            tempcal.Set(1998, IBM.ICU.Util.Calendar.APRIL, 5, 1, 0);
            long onset = (tempcal.GetTime().Ticks / 10000) + ONE_HOUR;
            tempcal.Set(1998, IBM.ICU.Util.Calendar.OCTOBER, 25, 0, 0);
            long cease = (tempcal.GetTime().Ticks / 10000) + 2 * ONE_HOUR;

            bool fail = false;

            const int ADD = 1;
            const int ROLL = 2;

            long[] DATA = {
	                // Start Action Amt Expected_change
	                onset - ONE_HOUR, ADD, 1, ONE_HOUR, onset, ADD, -1, -ONE_HOUR,
	                onset - ONE_HOUR, ROLL, 1, ONE_HOUR, onset, ROLL, -1,
	                -ONE_HOUR, cease - ONE_HOUR, ADD, 1, ONE_HOUR, cease, ADD, -1,
	                -ONE_HOUR, cease - ONE_HOUR, ROLL, 1, ONE_HOUR, cease, ROLL,
	                -1, -ONE_HOUR, };

            for (int i = 0; i < DATA.Length; i += 4)
            {
                DateTime date = DateUtil.DateFromJavaMillis((DATA[i]));
                int amt = (int)DATA[i + 2];
                long expectedChange = DATA[i + 3];

                Log(date.ToString());
                cal.SetTime(date);

                switch ((int)DATA[i + 1])
                {
                    case ADD:
                        Log(" add (HOUR," + ((amt < 0) ? "" : "+") + amt + ")= ");
                        cal.Add(IBM.ICU.Util.Calendar.HOUR, amt);
                        break;
                    case ROLL:
                        Log(" roll(HOUR," + ((amt < 0) ? "" : "+") + amt + ")= ");
                        cal.Roll(IBM.ICU.Util.Calendar.HOUR, amt);
                        break;
                }

                Log(cal.GetTime().ToString());

                long change = (cal.GetTime().Ticks / 10000) - (date.Ticks / 10000);
                if (change != expectedChange)
                {
                    fail = true;
                    Logln(" FAIL");
                }
                else
                    Logln(" OK");
            }

            if (fail)
                Errln("Fail: roll/add misbehaves around DST onset/cease");
        }

        /// <summary>
        /// Make sure maximum for HOUR field is 11, not 12.
        /// </summary>
        [Test]
        public void Test4118384()
        {
            IBM.ICU.Util.Calendar cal = IBM.ICU.Util.Calendar.GetInstance();
            if (cal.GetMaximum(IBM.ICU.Util.Calendar.HOUR) != 11
                    || cal.GetLeastMaximum(IBM.ICU.Util.Calendar.HOUR) != 11
                    || cal.GetActualMaximum(IBM.ICU.Util.Calendar.HOUR) != 11)
                Errln("Fail: maximum of HOUR field should be 11");
        }

        /// <summary>
        /// Check isLeapYear for BC years.
        /// </summary>
        [Ignore]
        public void Test4125881()
        {
            IBM.ICU.Util.GregorianCalendar cal = (IBM.ICU.Util.GregorianCalendar)IBM.ICU.Util.Calendar.GetInstance();
            IBM.ICU.Text.DateFormat fmt = new IBM.ICU.Text.SimpleDateFormat("MMMM d, yyyy G");
            cal.Clear();
            for (int y = -20; y <= 10; ++y)
            {
                cal.Set(IBM.ICU.Util.Calendar.ERA, (y < 1) ? IBM.ICU.Util.GregorianCalendar.BC
                        : IBM.ICU.Util.GregorianCalendar.AD);
                cal.Set(IBM.ICU.Util.Calendar.YEAR, (y < 1) ? 1 - y : y);
                Logln(y + " = " + fmt.Format(cal.GetTime()) + " "
                        + cal.IsLeapYear(y));
                if (cal.IsLeapYear(y) != ((y + 40) % 4 == 0))
                    Errln("Leap years broken");
            }
        }

        // I am disabling this test -- it is currently failing because of a bug
        // in Sun's latest change to STZ.getOffset(). I have filed a Sun bug
        // against this problem.

        // Re-enabled after 'porting' TZ and STZ from java.util to com.ibm.icu.util.
        /// <summary>
        /// Prove that GregorianCalendar is proleptic (it used to cut off at 45 BC,
        /// and not have leap years before then).
        /// </summary>
        [Test]
        public void Test4125892()
        {
            IBM.ICU.Util.GregorianCalendar cal = (IBM.ICU.Util.GregorianCalendar)IBM.ICU.Util.Calendar.GetInstance();
            // DateFormat fmt = new SimpleDateFormat("MMMM d, yyyy G");
            // fmt = null;
            cal.Clear();
            cal.Set(IBM.ICU.Util.Calendar.ERA, IBM.ICU.Util.GregorianCalendar.BC);
            cal.Set(IBM.ICU.Util.Calendar.YEAR, 81); // 81 BC is a leap year (proleptically)
            cal.Set(IBM.ICU.Util.Calendar.MONTH, IBM.ICU.Util.Calendar.FEBRUARY);
            cal.Set(IBM.ICU.Util.Calendar.DATE, 28);
            cal.Add(IBM.ICU.Util.Calendar.DATE, 1);
            if (cal.Get(IBM.ICU.Util.Calendar.DATE) != 29 || !cal.IsLeapYear(-80)) // -80 == 81
                // BC
                Errln("Calendar not proleptic");
        }

        /// <summary>
        /// Calendar and GregorianCalendar hashCode() methods need improvement.
        /// Calendar needs a good implementation that subclasses can override, and
        /// GregorianCalendar should use that implementation.
        /// </summary>
        [Test]
        public void Test4136399()
        {
            /*
             * Note: This test is actually more strict than it has to be.
             * Technically, there is no requirement that unequal objects have
             * unequal hashes. We only require equal objects to have equal hashes.
             * It is desirable for unequal objects to have distributed hashes, but
             * there is no hard requirement here.
             * 
             * In this test we make assumptions about certain attributes of calendar
             * objects getting represented in the hash, which need not always be the
             * case (although it does work currently with the given test).
             */
            IBM.ICU.Util.Calendar a = IBM.ICU.Util.Calendar.GetInstance();
            IBM.ICU.Util.Calendar b = (IBM.ICU.Util.Calendar)a.Clone();
            if (a.GetHashCode() != b.GetHashCode())
            {
                Errln("Calendar hash code unequal for cloned objects");
            }
            IBM.ICU.Util.TimeZone atz1 = a.GetTimeZone();
            IBM.ICU.Util.TimeZone atz2 = (IBM.ICU.Util.TimeZone)atz1.Clone();
            if (!atz1.Equals(atz2))
            {
                Errln("The clone timezones are not equal");
            }
            if (atz1.GetHashCode() != atz2.GetHashCode())
            {
                Errln("TimeZone hash code unequal for cloned objects");
            }
            b.SetMinimalDaysInFirstWeek(7 - a.GetMinimalDaysInFirstWeek());
            if (a.GetHashCode() == b.GetHashCode())
            {
                Errln("Calendar hash code ignores minimal days in first week");
            }
            b.SetMinimalDaysInFirstWeek(a.GetMinimalDaysInFirstWeek());

            b.SetFirstDayOfWeek((a.GetFirstDayOfWeek() % 7) + 1); // Next day
            if (a.GetHashCode() == b.GetHashCode())
            {
                Errln("Calendar hash code ignores first day of week");
            }
            b.SetFirstDayOfWeek(a.GetFirstDayOfWeek());

            b.SetLenient(!a.IsLenient());
            if (a.GetHashCode() == b.GetHashCode())
            {
                Errln("Calendar hash code ignores lenient setting");
            }
            b.SetLenient(a.IsLenient());

            // Assume getTimeZone() returns a reference, not a clone
            // of a reference -- this is true as of this writing
            IBM.ICU.Util.TimeZone atz = a.GetTimeZone();
            IBM.ICU.Util.TimeZone btz = b.GetTimeZone();

            btz.SetRawOffset(atz.GetRawOffset() + 60 * 60 * 1000);
            if (atz.GetHashCode() == btz.GetHashCode())
            {
                Errln(atz.GetHashCode() + "==" + btz.GetHashCode());
            }
            if (a.GetTimeZone() != b.GetTimeZone() && a.GetHashCode() == b.GetHashCode())
            {
                Errln("Calendar hash code ignores zone");
            }
            b.GetTimeZone().SetRawOffset(a.GetTimeZone().GetRawOffset());

            IBM.ICU.Util.GregorianCalendar c = new IBM.ICU.Util.GregorianCalendar();
            IBM.ICU.Util.GregorianCalendar d = (IBM.ICU.Util.GregorianCalendar)c.Clone();
            if (c.GetHashCode() != d.GetHashCode())
            {
                Errln("GregorianCalendar hash code unequal for clones objects");
            }
            DateTime cutover = c.GetGregorianChange();
            d.SetGregorianChange(DateUtil.DateFromJavaMillis(((cutover.Ticks / 10000) + 24 * 60 * 60 * 1000)));
            if (c.GetHashCode() == d.GetHashCode())
            {
                Errln("GregorianCalendar hash code ignores cutover");
            }
        }

        /// <summary>
        /// GregorianCalendar.equals() ignores cutover date
        /// </summary>
        [Test]
        public void Test4141665()
        {
            IBM.ICU.Util.GregorianCalendar cal = new IBM.ICU.Util.GregorianCalendar();
            IBM.ICU.Util.GregorianCalendar cal2 = (IBM.ICU.Util.GregorianCalendar)cal.Clone();
            DateTime cut = cal.GetGregorianChange();
            DateTime cut2 = DateUtil.DateFromJavaMillis(((cut.Ticks / 10000) + 100 * 24 * 60 * 60 * 1000L)); // 100
            // days
            // later
            if (!cal.Equals(cal2))
            {
                Errln("Cloned GregorianCalendars not equal");
            }
            cal2.SetGregorianChange(cut2);
            if (cal.Equals(cal2))
            {
                Errln("GregorianCalendar.equals() ignores cutover");
            }
        }

        /// <summary>
        /// Bug states that ArrayIndexOutOfBoundsException is thrown by
        /// GregorianCalendar.roll() when IllegalArgumentException should be.
        /// </summary>
        [Test]
        public void Test4142933()
        {
            IBM.ICU.Util.GregorianCalendar calendar = new IBM.ICU.Util.GregorianCalendar();
            try
            {
                calendar.Roll(-1, true);
                Errln("Test failed, no exception trown");
            }
            catch (ArgumentException e)
            {
                // OK: Do nothing
                // logln("Test passed");
                System.Console.Out.Write("");
            }
            catch (Exception e_0)
            {
                Errln("Test failed. Unexpected exception is thrown: " + e_0);
                Console.Error.WriteLine(e_0.StackTrace);
            }
        }

        /// <summary>
        /// GregorianCalendar handling of Dates Long.MIN_VALUE and Long.MAX_VALUE is
        /// confusing; unless the time zone has a raw offset of zero, one or the
        /// other of these will wrap. We've modified the test given in the bug report
        /// to therefore only check the behavior of a calendar with a zero raw offset
        /// zone.
        /// </summary>
        [Test]
        public void Test4145158()
        {
            IBM.ICU.Util.GregorianCalendar calendar = new IBM.ICU.Util.GregorianCalendar();

            calendar.SetTimeZone(IBM.ICU.Util.TimeZone.GetTimeZone("GMT"));

            calendar.SetTime(DateUtil.DateFromJavaMillis(Int64.MinValue));
            int year1 = calendar.Get(IBM.ICU.Util.Calendar.YEAR);
            int era1 = calendar.Get(IBM.ICU.Util.Calendar.ERA);

            calendar.SetTime(DateUtil.DateFromJavaMillis(Int64.MaxValue));
            int year2 = calendar.Get(IBM.ICU.Util.Calendar.YEAR);
            int era2 = calendar.Get(IBM.ICU.Util.Calendar.ERA);

            if (year1 == year2 && era1 == era2)
            {
                Errln("Fail: Long.MIN_VALUE or Long.MAX_VALUE wrapping around");
            }
        }

        /// <summary>
        /// Maximum value for YEAR field wrong.
        /// </summary>
        [Test]
        public void Test4145983()
        {
            IBM.ICU.Util.GregorianCalendar calendar = new IBM.ICU.Util.GregorianCalendar();
            calendar.SetTimeZone(IBM.ICU.Util.TimeZone.GetTimeZone("GMT"));
            DateTime[] DATES = { DateUtil.DateFromJavaMillis((Int64.MaxValue)), DateUtil.DateFromJavaMillis((Int64.MinValue)) };
            for (int i = 0; i < DATES.Length; ++i)
            {
                calendar.SetTime(DATES[i]);
                int year = calendar.Get(IBM.ICU.Util.Calendar.YEAR);
                int maxYear = calendar.GetMaximum(IBM.ICU.Util.Calendar.YEAR);
                if (year > maxYear)
                {
                    Errln("Failed for " + (DATES[i].Ticks / 10000) + " ms: year=" + year
                            + ", maxYear=" + maxYear);
                }
            }
        }

        /// <summary>
        /// This is a bug in the validation code of GregorianCalendar. As reported,
        /// the bug seems worse than it really is, due to a bug in the way the bug
        /// report test was written. In reality the bug is restricted to the
        /// DAY_OF_YEAR field. - liu 6/29/98
        /// </summary>
        [Test]
        public void Test4147269()
        {
            IBM.ICU.Util.GregorianCalendar calendar = new IBM.ICU.Util.GregorianCalendar();
            calendar.SetLenient(false);
            IBM.ICU.Util.Calendar tempcal = IBM.ICU.Util.Calendar.GetInstance();
            tempcal.Clear();
            tempcal.Set(1996, IBM.ICU.Util.Calendar.JANUARY, 3); // Arbitrary date
            DateTime date = tempcal.GetTime();
            for (int field = 0; field < calendar.GetFieldCount(); field++)
            {
                calendar.SetTime(date);
                // Note: In the bug report, getActualMaximum() was called instead
                // of getMaximum() -- this was an error. The validation code doesn't
                // use getActualMaximum(), since that's too costly.
                int max = calendar.GetMaximum(field);
                int value_ren = max + 1;
                calendar.Set(field, value_ren);
                try
                {
                    calendar.GetTime(); // Force time computation
                    // We expect an exception to be thrown. If we fall through
                    // to the next line, then we have a bug.
                    Errln("Test failed with field " + FIELD_NAME[field]
                            + ", date before: " + date + ", date after: "
                            + calendar.GetTime() + ", value: " + value_ren + " (max = "
                            + max + ")");
                }
                catch (ArgumentException e)
                {
                    System.Console.Out.Write("");
                }
            }
        }

        /// <summary>
        /// Reported bug is that a GregorianCalendar with a cutover of
        /// Date(Long.MAX_VALUE) doesn't behave as a pure Julian calendar. CANNOT
        /// REPRODUCE THIS BUG
        /// </summary>
        [Test]
        public void Test4149677()
        {
            IBM.ICU.Util.TimeZone[] zones = { IBM.ICU.Util.TimeZone.GetTimeZone("GMT"),
	                IBM.ICU.Util.TimeZone.GetTimeZone("PST"), IBM.ICU.Util.TimeZone.GetTimeZone("EAT") };
            for (int i = 0; i < zones.Length; ++i)
            {
                IBM.ICU.Util.GregorianCalendar calendar = new IBM.ICU.Util.GregorianCalendar(zones[i]);

                // Make sure extreme values don't wrap around
                calendar.SetTime(DateUtil.DateFromJavaMillis((Int64.MinValue)));
                if (calendar.Get(IBM.ICU.Util.Calendar.ERA) != IBM.ICU.Util.GregorianCalendar.BC)
                {
                    Errln("Fail: Long.MIN_VALUE ms has an AD year");
                }
                calendar.SetTime(DateUtil.DateFromJavaMillis((Int64.MaxValue)));
                if (calendar.Get(IBM.ICU.Util.Calendar.ERA) != IBM.ICU.Util.GregorianCalendar.AD)
                {
                    Errln("Fail: Long.MAX_VALUE ms has a BC year");
                }

                calendar.SetGregorianChange(DateUtil.DateFromJavaMillis((Int64.MaxValue)));
                // to obtain a pure Julian calendar

                bool is100Leap = calendar.IsLeapYear(100);
                if (!is100Leap)
                {
                    Errln("test failed with zone " + zones[i].GetID());
                    Errln(" cutover date is Calendar.MAX_DATE");
                    Errln(" isLeapYear(100) returns: " + is100Leap);
                }
            }
        }

        /// <summary>
        /// Calendar and Date HOUR broken. If HOUR is out-of-range, Calendar and Date
        /// classes will misbehave.
        /// </summary>
        [Test]
        public void Test4162587()
        {
            IBM.ICU.Util.TimeZone tz = IBM.ICU.Util.TimeZone.GetTimeZone("PST");
            IBM.ICU.Util.TimeZone.SetDefault(tz);
            IBM.ICU.Util.GregorianCalendar cal = new IBM.ICU.Util.GregorianCalendar(tz);
            DateTime d;

            for (int i = 0; i < 5; ++i)
            {
                if (i > 0)
                    Logln("---");

                cal.Clear();
                cal.Set(1998, IBM.ICU.Util.Calendar.APRIL, 5, i, 0);
                d = cal.GetTime();
                String s0 = d.ToString();
                Logln("0 " + i + ": " + s0);

                cal.Clear();
                cal.Set(1998, IBM.ICU.Util.Calendar.APRIL, 4, i + 24, 0);
                d = cal.GetTime();
                String sPlus = d.ToString();
                Logln("+ " + i + ": " + sPlus);

                cal.Clear();
                cal.Set(1998, IBM.ICU.Util.Calendar.APRIL, 6, i - 24, 0);
                d = cal.GetTime();
                String sMinus = d.ToString();
                Logln("- " + i + ": " + sMinus);

                if (!s0.Equals(sPlus) || !s0.Equals(sMinus))
                {
                    Errln("Fail: All three lines must match");
                }
            }
        }

        /// <summary>
        /// Adding 12 months behaves differently from adding 1 year
        /// </summary>
        [Test]
        public void Test4165343()
        {
            IBM.ICU.Util.GregorianCalendar calendar = new IBM.ICU.Util.GregorianCalendar(1996,
                    IBM.ICU.Util.Calendar.FEBRUARY, 29);
            DateTime start = calendar.GetTime();
            Logln("init date: " + start);
            calendar.Add(IBM.ICU.Util.Calendar.MONTH, 12);
            DateTime date1 = calendar.GetTime();
            Logln("after adding 12 months: " + date1);
            calendar.SetTime(start);
            calendar.Add(IBM.ICU.Util.Calendar.YEAR, 1);
            DateTime date2 = calendar.GetTime();
            Logln("after adding one year : " + date2);
            if (date1.Equals(date2))
            {
                Logln("Test passed");
            }
            else
            {
                Errln("Test failed");
            }
        }

        /// <summary>
        /// GregorianCalendar.getActualMaximum() does not account for first day of
        /// week.
        /// </summary>
        [Test]
        public void Test4166109()
        {
            /*
             * Test month:
             * 
             * March 1998 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
             * 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31
             */
            bool passed = true;
            int field = IBM.ICU.Util.Calendar.WEEK_OF_MONTH;

            IBM.ICU.Util.GregorianCalendar calendar = new IBM.ICU.Util.GregorianCalendar(Locale.US);
            calendar.Set(1998, IBM.ICU.Util.Calendar.MARCH, 1);
            calendar.SetMinimalDaysInFirstWeek(1);
            Logln("Date:  " + calendar.GetTime());

            int firstInMonth = calendar.Get(IBM.ICU.Util.Calendar.DAY_OF_MONTH);

            for (int firstInWeek = IBM.ICU.Util.Calendar.SUNDAY; firstInWeek <= IBM.ICU.Util.Calendar.SATURDAY; firstInWeek++)
            {
                calendar.SetFirstDayOfWeek(firstInWeek);
                int returned = calendar.GetActualMaximum(field);
                int expected = (31 + ((firstInMonth - firstInWeek + 7) % 7) + 6) / 7;

                Logln("First day of week = " + firstInWeek
                        + "  getActualMaximum(WEEK_OF_MONTH) = " + returned
                        + "  expected = " + expected
                        + ((returned == expected) ? "  ok" : "  FAIL"));

                if (returned != expected)
                {
                    passed = false;
                }
            }
            if (!passed)
            {
                Errln("Test failed");
            }
        }

        /// <summary>
        /// Calendar.getActualMaximum(YEAR) works wrong.
        /// </summary>
        [Test]
        public void Test4167060()
        {
            int field = IBM.ICU.Util.Calendar.YEAR;
            IBM.ICU.Text.DateFormat format = new IBM.ICU.Text.SimpleDateFormat(
                    "EEE MMM dd HH:mm:ss zzz yyyy G", Locale.US);

            IBM.ICU.Util.GregorianCalendar[] calendars = {
	                new IBM.ICU.Util.GregorianCalendar(100, IBM.ICU.Util.Calendar.NOVEMBER,
	                        1),
	                new IBM.ICU.Util.GregorianCalendar(-99, IBM.ICU.Util.Calendar.JANUARY, 1),
	                new IBM.ICU.Util.GregorianCalendar(1996, IBM.ICU.Util.Calendar.FEBRUARY,
	                        29) };

            String[] id = { "Hybrid", "Gregorian", "Julian" };

            for (int k = 0; k < 3; ++k)
            {
                Logln("--- " + id[k] + " ---");

                for (int j = 0; j < calendars.Length; ++j)
                {
                    IBM.ICU.Util.GregorianCalendar calendar = calendars[j];
                    if (k == 1)
                    {
                        calendar.SetGregorianChange(DateUtil.DateFromJavaMillis((Int64.MinValue)));
                    }
                    else if (k == 2)
                    {
                        calendar.SetGregorianChange(DateUtil.DateFromJavaMillis((Int64.MaxValue)));
                    }

                    format.SetCalendar((IBM.ICU.Util.Calendar)calendar.Clone());

                    DateTime dateBefore = calendar.GetTime();

                    int maxYear = calendar.GetActualMaximum(field);
                    Logln("maxYear: " + maxYear + " for "
                            + format.Format(calendar.GetTime()));
                    Logln("date before: " + format.Format(dateBefore));

                    int[] years = { 2000, maxYear - 1, maxYear, maxYear + 1 };

                    for (int i = 0; i < years.Length; i++)
                    {
                        bool valid = years[i] <= maxYear;
                        calendar.Set(field, years[i]);
                        DateTime dateAfter = calendar.GetTime();
                        int newYear = calendar.Get(field);
                        calendar.SetTime(dateBefore); // restore calendar for next
                        // use

                        Logln(" Year " + years[i] + ((valid) ? " ok " : " bad")
                                + " => " + format.Format(dateAfter));
                        if (valid && newYear != years[i])
                        {
                            Errln("  FAIL: "
                                    + newYear
                                    + " should be valid; date, month and time shouldn't change");
                        }
                        else if (!valid && newYear == years[i])
                        {
                            // We no longer require strict year maxima. That is, the
                            // calendar
                            // algorithm may work for values > the stated maximum.
                            // errln(" FAIL: " + newYear + " should be invalid");
                            Logln("  Note: " + newYear
                                    + " > maximum, but still valid");
                        }
                    }
                }
            }
        }

        /// <summary>
        /// Calendar.roll broken This bug relies on the TimeZone bug 4173604 to also
        /// be fixed.
        /// </summary>
        [Test]
        public void Test4173516()
        {
            int[][] fieldsList = {
	                new int[] { 1997, IBM.ICU.Util.Calendar.FEBRUARY, 1, 10,
	                        45, 15, 900 },
	                new int[] { 1999, IBM.ICU.Util.Calendar.DECEMBER, 22, 23,
	                        59, 59, 999 } };
            int limit = 40;
            IBM.ICU.Util.GregorianCalendar cal = new IBM.ICU.Util.GregorianCalendar();

            cal.SetTime(DateUtil.DateFromJavaMillis((0)));
            cal.Roll(IBM.ICU.Util.Calendar.HOUR, 0x7F000000);
            cal.Roll(IBM.ICU.Util.Calendar.HOUR, -0x7F000000);
            if ((cal.GetTime().Ticks / 10000) != 0)
            {
              //  Errln("Hour rolling broken");
            }

            for (int op = 0; op < 2; ++op)
            {
                Logln("Testing GregorianCalendar " + ((op == 0) ? "add" : "roll"));
                for (int field = 0; field < cal.GetFieldCount(); ++field)
                {
                    if (field != IBM.ICU.Util.Calendar.ZONE_OFFSET
                            && field != IBM.ICU.Util.Calendar.DST_OFFSET)
                    {
                        for (int j = 0; j < fieldsList.Length; ++j)
                        {
                            int[] fields = fieldsList[j];
                            cal.Clear();
                            cal.Set(fields[0], fields[1], fields[2], fields[3],
                                    fields[4], fields[5]);
                            cal.Set(IBM.ICU.Util.Calendar.MILLISECOND, fields[6]);
                            for (int i = 0; i < 2 * limit; i++)
                            {
                                if (op == 0)
                                {
                                    cal.Add(field, (i < limit) ? 1 : -1);
                                }
                                else
                                {
                                    cal.Roll(field, (i < limit) ? 1 : -1);
                                }
                            }
                            if (cal.Get(IBM.ICU.Util.Calendar.YEAR) != fields[0]
                                    || cal.Get(IBM.ICU.Util.Calendar.MONTH) != fields[1]
                                    || cal.Get(IBM.ICU.Util.Calendar.DATE) != fields[2]
                                    || cal.Get(IBM.ICU.Util.Calendar.HOUR_OF_DAY) != fields[3]
                                    || cal.Get(IBM.ICU.Util.Calendar.MINUTE) != fields[4]
                                    || cal.Get(IBM.ICU.Util.Calendar.SECOND) != fields[5]
                                    || cal.Get(IBM.ICU.Util.Calendar.MILLISECOND) != fields[6])
                            {
                                Errln("Field " + field + " (" + FIELD_NAME[field]
                                        + ") FAIL, expected " + fields[0] + "/"
                                        + (fields[1] + 1) + "/" + fields[2] + " "
                                        + fields[3] + ":" + fields[4] + ":"
                                        + fields[5] + "." + fields[6] + ", got "
                                        + cal.Get(IBM.ICU.Util.Calendar.YEAR) + "/"
                                        + (cal.Get(IBM.ICU.Util.Calendar.MONTH) + 1) + "/"
                                        + cal.Get(IBM.ICU.Util.Calendar.DATE) + " "
                                        + cal.Get(IBM.ICU.Util.Calendar.HOUR_OF_DAY) + ":"
                                        + cal.Get(IBM.ICU.Util.Calendar.MINUTE) + ":"
                                        + cal.Get(IBM.ICU.Util.Calendar.SECOND) + "."
                                        + cal.Get(IBM.ICU.Util.Calendar.MILLISECOND));
                                cal.Clear();
                                cal.Set(fields[0], fields[1], fields[2], fields[3],
                                        fields[4], fields[5]);
                                cal.Set(IBM.ICU.Util.Calendar.MILLISECOND, fields[6]);
                                Logln("Start date: " + cal.Get(IBM.ICU.Util.Calendar.YEAR) + "/"
                                        + (cal.Get(IBM.ICU.Util.Calendar.MONTH) + 1) + "/"
                                        + cal.Get(IBM.ICU.Util.Calendar.DATE) + " "
                                        + cal.Get(IBM.ICU.Util.Calendar.HOUR_OF_DAY) + ":"
                                        + cal.Get(IBM.ICU.Util.Calendar.MINUTE) + ":"
                                        + cal.Get(IBM.ICU.Util.Calendar.SECOND) + "."
                                        + cal.Get(IBM.ICU.Util.Calendar.MILLISECOND));
                                long prev = (cal.GetTime().Ticks / 10000);
                                for (int i_0 = 0; i_0 < 2 * limit; i_0++)
                                {
                                    if (op == 0)
                                    {
                                        cal.Add(field, (i_0 < limit) ? 1 : -1);
                                    }
                                    else
                                    {
                                        cal.Roll(field, (i_0 < limit) ? 1 : -1);
                                    }
                                    long t = (cal.GetTime().Ticks / 10000);
                                    long delta = t - prev;
                                    prev = t;
                                    Logln(((op == 0) ? "add(" : "roll(")
                                            + FIELD_NAME[field]
                                            + ((i_0 < limit) ? ", +1) => "
                                                    : ", -1) => ")
                                            + cal.Get(IBM.ICU.Util.Calendar.YEAR) + "/"
                                            + (cal.Get(IBM.ICU.Util.Calendar.MONTH) + 1) + "/"
                                            + cal.Get(IBM.ICU.Util.Calendar.DATE) + " "
                                            + cal.Get(IBM.ICU.Util.Calendar.HOUR_OF_DAY) + ":"
                                            + cal.Get(IBM.ICU.Util.Calendar.MINUTE) + ":"
                                            + cal.Get(IBM.ICU.Util.Calendar.SECOND) + "."
                                            + cal.Get(IBM.ICU.Util.Calendar.MILLISECOND)
                                            + " delta=" + delta + " ms");
                                }
                            }
                        }
                    }
                }
            }
        }

        [Test]
        public void Test4174361()
        {
            IBM.ICU.Util.GregorianCalendar calendar = new IBM.ICU.Util.GregorianCalendar(1996, 1, 29);

            calendar.Add(IBM.ICU.Util.Calendar.MONTH, 10);
            // Date date1 = calendar.getTime();
            // date1 = null;
            int d1 = calendar.Get(IBM.ICU.Util.Calendar.DAY_OF_MONTH);

            calendar = new IBM.ICU.Util.GregorianCalendar(1996, 1, 29);
            calendar.Add(IBM.ICU.Util.Calendar.MONTH, 11);
            // Date date2 = calendar.getTime();
            // date2 = null;
            int d2 = calendar.Get(IBM.ICU.Util.Calendar.DAY_OF_MONTH);

            if (d1 != d2)
            {
                Errln("adding months to Feb 29 broken");
            }
        }

        /// <summary>
        /// Calendar does not update field values when setTimeZone is called.
        /// </summary>
        [Test]
        public void Test4177484()
        {
            IBM.ICU.Util.TimeZone PST = IBM.ICU.Util.TimeZone.GetTimeZone("PST");
            IBM.ICU.Util.TimeZone EST = IBM.ICU.Util.TimeZone.GetTimeZone("EST");

            IBM.ICU.Util.Calendar cal = IBM.ICU.Util.Calendar.GetInstance(PST, Locale.US);
            cal.Clear();
            cal.Set(1999, 3, 21, 15, 5, 0); // Arbitrary
            int h1 = cal.Get(IBM.ICU.Util.Calendar.HOUR_OF_DAY);
            cal.SetTimeZone(EST);
            int h2 = cal.Get(IBM.ICU.Util.Calendar.HOUR_OF_DAY);
            if (h1 == h2)
            {
                Errln("FAIL: Fields not updated after setTimeZone");
            }

            // getTime() must NOT change when time zone is changed.
            // getTime() returns zone-independent time in ms.
            cal.Clear();
            cal.SetTimeZone(PST);
            cal.Set(IBM.ICU.Util.Calendar.HOUR_OF_DAY, 10);
            DateTime pst10 = cal.GetTime();
            cal.SetTimeZone(EST);
            DateTime est10 = cal.GetTime();
            if (!pst10.Equals(est10))
            {
                Errln("FAIL: setTimeZone changed time");
            }
        }

        /// <summary>
        /// Week of year is wrong at the start and end of the year.
        /// </summary>
        [Test]
        public void Test4197699()
        {
            IBM.ICU.Util.GregorianCalendar cal = new IBM.ICU.Util.GregorianCalendar();
            cal.SetFirstDayOfWeek(IBM.ICU.Util.Calendar.MONDAY);
            cal.SetMinimalDaysInFirstWeek(4);
            IBM.ICU.Text.DateFormat fmt = new IBM.ICU.Text.SimpleDateFormat("E dd MMM yyyy  'DOY='D 'WOY='w");
            fmt.SetCalendar(cal);

            int[] DATA = { 2000, IBM.ICU.Util.Calendar.JANUARY, 1, 52, 2001, IBM.ICU.Util.Calendar.DECEMBER,
	                31, 1, };

            for (int i = 0; i < DATA.Length; )
            {
                cal.Set(DATA[i++], DATA[i++], DATA[i++]);
                int expWOY = DATA[i++];
                int actWOY = cal.Get(IBM.ICU.Util.Calendar.WEEK_OF_YEAR);
                if (expWOY == actWOY)
                {
                    Logln("Ok: " + fmt.Format(cal.GetTime()));
                }
                else
                {
                    Errln("FAIL: " + fmt.Format(cal.GetTime()) + ", expected WOY="
                            + expWOY);
                    cal.Add(IBM.ICU.Util.Calendar.DATE, -8);
                    for (int j = 0; j < 14; ++j)
                    {
                        cal.Add(IBM.ICU.Util.Calendar.DATE, 1);
                        Logln(fmt.Format(cal.GetTime()));
                    }
                }
            }
        }

        /// <summary>
        /// Calendar DAY_OF_WEEK_IN_MONTH fields->time broken. The problem is in the
        /// field disambiguation code in GregorianCalendar. This code is supposed to
        /// choose the most recent set of fields among the following:
        /// MONTH + DAY_OF_MONTH MONTH + WEEK_OF_MONTH + DAY_OF_WEEK MONTH +
        /// DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK DAY_OF_YEAR WEEK_OF_YEAR + DAY_OF_WEEK
        /// </summary>
        [Test]
        public void Test4209071()
        {
            IBM.ICU.Util.Calendar cal = IBM.ICU.Util.Calendar.GetInstance(Locale.US);

            // General field setting test
            int Y = 1995;

            DateTime[] d = new DateTime[13];
            IBM.ICU.Util.Calendar tempcal = IBM.ICU.Util.Calendar.GetInstance();
            tempcal.Clear();
            tempcal.Set(Y, IBM.ICU.Util.Calendar.JANUARY, 1);
            d[0] = tempcal.GetTime();
            tempcal.Set(Y, IBM.ICU.Util.Calendar.MARCH, 1);
            d[1] = tempcal.GetTime();
            tempcal.Set(Y, IBM.ICU.Util.Calendar.JANUARY, 4);
            d[2] = tempcal.GetTime();
            tempcal.Set(Y, IBM.ICU.Util.Calendar.JANUARY, 18);
            d[3] = tempcal.GetTime();
            tempcal.Set(Y, IBM.ICU.Util.Calendar.JANUARY, 18);
            d[4] = tempcal.GetTime();
            tempcal.Set(Y - 1, IBM.ICU.Util.Calendar.DECEMBER, 22);
            d[5] = tempcal.GetTime();
            tempcal.Set(Y, IBM.ICU.Util.Calendar.JANUARY, 26);
            d[6] = tempcal.GetTime();
            tempcal.Set(Y, IBM.ICU.Util.Calendar.JANUARY, 26);
            d[7] = tempcal.GetTime();
            tempcal.Set(Y, IBM.ICU.Util.Calendar.MARCH, 1);
            d[8] = tempcal.GetTime();
            tempcal.Set(Y, IBM.ICU.Util.Calendar.OCTOBER, 6);
            d[9] = tempcal.GetTime();
            tempcal.Set(Y, IBM.ICU.Util.Calendar.OCTOBER, 13);
            d[10] = tempcal.GetTime();
            tempcal.Set(Y, IBM.ICU.Util.Calendar.AUGUST, 10);
            d[11] = tempcal.GetTime();
            tempcal.Set(Y, IBM.ICU.Util.Calendar.DECEMBER, 7);
            d[12] = tempcal.GetTime();

            Object[] FIELD_DATA = {
	                // Add new test cases as needed.
	
	                // 0
	                new int[] {},
	                d[0],
	                // 1
	                new int[] { IBM.ICU.Util.Calendar.MONTH, IBM.ICU.Util.Calendar.MARCH },
	                d[1],
	                // 2
	                new int[] { IBM.ICU.Util.Calendar.DAY_OF_WEEK, IBM.ICU.Util.Calendar.WEDNESDAY },
	                d[2],
	                // 3
	                new int[] { IBM.ICU.Util.Calendar.DAY_OF_WEEK, IBM.ICU.Util.Calendar.THURSDAY,
	                        IBM.ICU.Util.Calendar.DAY_OF_MONTH, 18, },
	                d[3],
	                // 4
	                new int[] { IBM.ICU.Util.Calendar.DAY_OF_MONTH, 18, IBM.ICU.Util.Calendar.DAY_OF_WEEK,
	                        IBM.ICU.Util.Calendar.THURSDAY, },
	                d[4],
	                // 5 (WOM -1 is in previous month)
	                new int[] { IBM.ICU.Util.Calendar.DAY_OF_MONTH, 18, IBM.ICU.Util.Calendar.WEEK_OF_MONTH,
	                        -1, IBM.ICU.Util.Calendar.DAY_OF_WEEK, IBM.ICU.Util.Calendar.THURSDAY, },
	                d[5],
	                // 6
	                new int[] { IBM.ICU.Util.Calendar.DAY_OF_MONTH, 18, IBM.ICU.Util.Calendar.WEEK_OF_MONTH,
	                        4, IBM.ICU.Util.Calendar.DAY_OF_WEEK, IBM.ICU.Util.Calendar.THURSDAY, },
	                d[6],
	                // 7 (DIM -1 is in same month)
	                new int[] { IBM.ICU.Util.Calendar.DAY_OF_MONTH, 18,
	                        IBM.ICU.Util.Calendar.DAY_OF_WEEK_IN_MONTH, -1,
	                        IBM.ICU.Util.Calendar.DAY_OF_WEEK, IBM.ICU.Util.Calendar.THURSDAY, },
	                d[7],
	                // 8
	                new int[] { IBM.ICU.Util.Calendar.WEEK_OF_YEAR, 9, IBM.ICU.Util.Calendar.DAY_OF_WEEK,
	                        IBM.ICU.Util.Calendar.WEDNESDAY, },
	                d[8],
	                // 9
	                new int[] { IBM.ICU.Util.Calendar.MONTH, IBM.ICU.Util.Calendar.OCTOBER,
	                        IBM.ICU.Util.Calendar.DAY_OF_WEEK_IN_MONTH, 1, IBM.ICU.Util.Calendar.DAY_OF_WEEK,
	                        IBM.ICU.Util.Calendar.FRIDAY, },
	                d[9],
	                // 10
	                new int[] { IBM.ICU.Util.Calendar.MONTH, IBM.ICU.Util.Calendar.OCTOBER,
	                        IBM.ICU.Util.Calendar.WEEK_OF_MONTH, 2, IBM.ICU.Util.Calendar.DAY_OF_WEEK,
	                        IBM.ICU.Util.Calendar.FRIDAY, },
	                d[10],
	                // 11
	                new int[] { IBM.ICU.Util.Calendar.MONTH, IBM.ICU.Util.Calendar.OCTOBER,
	                        IBM.ICU.Util.Calendar.DAY_OF_MONTH, 15, IBM.ICU.Util.Calendar.DAY_OF_YEAR, 222, },
	                d[11],
	                // 12
	                new int[] { IBM.ICU.Util.Calendar.DAY_OF_WEEK, IBM.ICU.Util.Calendar.THURSDAY,
	                        IBM.ICU.Util.Calendar.MONTH, IBM.ICU.Util.Calendar.DECEMBER, }, d[12], };

            for (int i = 0; i < FIELD_DATA.Length; i += 2)
            {
                int[] fields = (int[])FIELD_DATA[i];
                DateTime exp = (DateTime)FIELD_DATA[i + 1];

                cal.Clear();
                cal.Set(IBM.ICU.Util.Calendar.YEAR, Y);
                for (int j = 0; j < fields.Length; j += 2)
                {
                    cal.Set(fields[j], fields[j + 1]);
                }

                DateTime act = cal.GetTime();
                if (!act.Equals(exp))
                {
                    Errln("FAIL: Test "
                            + (i / 2)
                            + " got "
                            + act
                            + ", want "
                            + exp
                            + " (see test/java/util/Calendar/CalendarRegression.java");
                }
            }

            tempcal.Set(1997, IBM.ICU.Util.Calendar.JANUARY, 5);
            d[0] = tempcal.GetTime();
            tempcal.Set(1997, IBM.ICU.Util.Calendar.JANUARY, 26);
            d[1] = tempcal.GetTime();
            tempcal.Set(1997, IBM.ICU.Util.Calendar.FEBRUARY, 23);
            d[2] = tempcal.GetTime();
            tempcal.Set(1997, IBM.ICU.Util.Calendar.JANUARY, 26);
            d[3] = tempcal.GetTime();
            tempcal.Set(1997, IBM.ICU.Util.Calendar.JANUARY, 5);
            d[4] = tempcal.GetTime();
            tempcal.Set(1996, IBM.ICU.Util.Calendar.DECEMBER, 8);
            d[5] = tempcal.GetTime();
            // Test specific failure reported in bug
            Object[] DATA = { ((int)(1)), d[0], ((int)(4)), d[1],
	                ((int)(8)), d[2], ((int)(-1)), d[3], ((int)(-4)),
	                d[4], ((int)(-8)), d[5], };
            for (int i_0 = 0; i_0 < DATA.Length; i_0 += 2)
            {
                cal.Clear();
                cal.Set(IBM.ICU.Util.Calendar.DAY_OF_WEEK_IN_MONTH,
                        System.Convert.ToInt32(((object)DATA[i_0])));
                cal.Set(IBM.ICU.Util.Calendar.DAY_OF_WEEK, IBM.ICU.Util.Calendar.SUNDAY);
                cal.Set(IBM.ICU.Util.Calendar.MONTH, IBM.ICU.Util.Calendar.JANUARY);
                cal.Set(IBM.ICU.Util.Calendar.YEAR, 1997);
                DateTime actual = cal.GetTime();
                if (!actual.Equals(DATA[i_0 + 1]))
                {
                    Errln("FAIL: Sunday " + DATA[i_0] + " of Jan 1997 -> " + actual
                            + ", want " + DATA[i_0 + 1]);
                }
            }
        }

        /// <summary>
        /// WEEK_OF_YEAR computed incorrectly. A failure of this test can indicate a
        /// problem in several different places in the
        /// </summary>
        [Test]
        public void Test4288792()
        {
            IBM.ICU.Util.TimeZone savedTZ = IBM.ICU.Util.TimeZone.GetDefault();
            IBM.ICU.Util.TimeZone.SetDefault(IBM.ICU.Util.TimeZone.GetTimeZone("GMT"));
            IBM.ICU.Util.GregorianCalendar cal = new IBM.ICU.Util.GregorianCalendar();

            for (int i = 1900; i < 2100; i++)
            {
                for (int j1 = 1; j1 <= 7; j1++)
                {
                    // Loop for MinimalDaysInFirstWeek: 1..7
                    for (int j = IBM.ICU.Util.Calendar.SUNDAY; j <= IBM.ICU.Util.Calendar.SATURDAY; j++)
                    {
                        // Loop for FirstDayOfWeek: SUNDAY..SATURDAY
                        cal.Clear();
                        cal.SetMinimalDaysInFirstWeek(j1);
                        cal.SetFirstDayOfWeek(j);
                        // Set the calendar to the first day of the last week
                        // of the year. This may overlap some of the start of
                        // the next year; that is, the last week of 1999 may
                        // include some of January 2000. Use the add() method
                        // to advance through the week. For each day, call
                        // get(WEEK_OF_YEAR). The result should be the same
                        // for the whole week. Note that a bug in
                        // getActualMaximum() will break this test.
                        cal.Set(IBM.ICU.Util.Calendar.YEAR, i);
                        int maxWeek = cal.GetActualMaximum(IBM.ICU.Util.Calendar.WEEK_OF_YEAR);
                        cal.Set(IBM.ICU.Util.Calendar.WEEK_OF_YEAR, maxWeek);
                        cal.Set(IBM.ICU.Util.Calendar.DAY_OF_WEEK, j);
                        for (int k = 1; k < 7; k++)
                        {
                            cal.Add(IBM.ICU.Util.Calendar.DATE, 1);
                            int WOY = cal.Get(IBM.ICU.Util.Calendar.WEEK_OF_YEAR);
                            if (WOY != maxWeek)
                            {
                                Errln(cal.GetTime() + ",got=" + WOY + ",expected="
                                        + maxWeek + ",min=" + j1 + ",first=" + j);
                            }
                        }
                        // Now advance the calendar one more day. This should
                        // put it at the first day of week 1 of the next year.
                        cal.Add(IBM.ICU.Util.Calendar.DATE, 1);
                        int WOY_0 = cal.Get(IBM.ICU.Util.Calendar.WEEK_OF_YEAR);
                        if (WOY_0 != 1)
                        {
                            Errln(cal.GetTime() + ",got=" + WOY_0
                                    + ",expected=1,min=" + j1 + ",first" + j);
                        }
                    }
                }
            }
            IBM.ICU.Util.TimeZone.SetDefault(savedTZ);
        }

        /// <summary>
        /// Test fieldDifference().
        /// </summary>
        [Test]
        public void TestJ438()
        {
            int[] DATA = { 2000, IBM.ICU.Util.Calendar.JANUARY, 20, 2010,
	                IBM.ICU.Util.Calendar.JUNE, 15, 2010,
	                IBM.ICU.Util.Calendar.JUNE, 15, 2000,
	                IBM.ICU.Util.Calendar.JANUARY, 20, 1964,
	                IBM.ICU.Util.Calendar.SEPTEMBER, 7, 1999,
	                IBM.ICU.Util.Calendar.JUNE, 4, 1999,
	                IBM.ICU.Util.Calendar.JUNE, 4, 1964,
	                IBM.ICU.Util.Calendar.SEPTEMBER, 7 };
            IBM.ICU.Util.Calendar cal = IBM.ICU.Util.Calendar.GetInstance(Locale.US);
            for (int i = 0; i < DATA.Length; i += 6)
            {
                int y1 = DATA[i];
                int m1 = DATA[i + 1];
                int d1 = DATA[i + 2];
                int y2 = DATA[i + 3];
                int m2 = DATA[i + 4];
                int d2 = DATA[i + 5];

                cal.Clear();
                cal.Set(y1, m1, d1);
                DateTime date1 = cal.GetTime();
                cal.Set(y2, m2, d2);
                DateTime date2 = cal.GetTime();

                cal.SetTime(date1);
                int dy = cal.FieldDifference(date2, IBM.ICU.Util.Calendar.YEAR);
                int dm = cal.FieldDifference(date2, IBM.ICU.Util.Calendar.MONTH);
                int dd = cal.FieldDifference(date2, IBM.ICU.Util.Calendar.DATE);

                Logln("" + date2 + " - " + date1 + " = " + dy + "y " + dm + "m "
                        + dd + "d");

                cal.SetTime(date1);
                cal.Add(IBM.ICU.Util.Calendar.YEAR, dy);
                cal.Add(IBM.ICU.Util.Calendar.MONTH, dm);
                cal.Add(IBM.ICU.Util.Calendar.DATE, dd);
                DateTime date22 = cal.GetTime();
                if (!date2.Equals(date22))
                {
                    Errln("FAIL: " + date1 + " + " + dy + "y " + dm + "m " + dd
                            + "d = " + date22 + ", exp " + date2);
                }
                else
                {
                    Logln("Ok: " + date1 + " + " + dy + "y " + dm + "m " + dd
                            + "d = " + date22);
                }
            }
        }

        [Test]
        public void TestT5555()
        {
            IBM.ICU.Util.Calendar cal = IBM.ICU.Util.Calendar.GetInstance();

            // Set date to Wednesday, February 21, 2007
            cal.Set(2007, IBM.ICU.Util.Calendar.FEBRUARY, 21);

            try
            {
                // Advance month by three years
                cal.Add(IBM.ICU.Util.Calendar.MONTH, 36);

                // Move to last Wednesday of month.
                cal.Set(IBM.ICU.Util.Calendar.DAY_OF_WEEK_IN_MONTH, -1);

                cal.GetTime();
            }
            catch (Exception e)
            {
                Errln("Got an exception calling getTime().");
            }

            int yy, mm, dd, ee;

            yy = cal.Get(IBM.ICU.Util.Calendar.YEAR);
            mm = cal.Get(IBM.ICU.Util.Calendar.MONTH);
            dd = cal.Get(IBM.ICU.Util.Calendar.DATE);
            ee = cal.Get(IBM.ICU.Util.Calendar.DAY_OF_WEEK_IN_MONTH);

            if (yy != 2010 || mm != IBM.ICU.Util.Calendar.FEBRUARY || dd != 24
                    || ee != IBM.ICU.Util.Calendar.WEDNESDAY)
            {
                Errln("Got date " + yy + "/" + (mm + 1) + "/" + dd
                        + ", expected 2010/2/24");
            }
        }

        /// <summary>
        /// Set behavior of DST_OFFSET field. ICU4J Jitterbug 9.
        /// </summary>
        [Test]
        public void TestJ9()
        {
            int HOURS = 60 * 60 * 1000;
            IBM.ICU.Util.Calendar cal = new IBM.ICU.Util.GregorianCalendar(IBM.ICU.Util.TimeZone.GetTimeZone("PST"),
                    Locale.US);

            int END_FIELDS = 0x1234;

            int[] DATA = {
	                IBM.ICU.Util.Calendar.MONTH,
	                IBM.ICU.Util.Calendar.JUNE,
	                END_FIELDS,
	                0,
	                0, // expected hour, min
	
	                IBM.ICU.Util.Calendar.MONTH, IBM.ICU.Util.Calendar.JUNE, IBM.ICU.Util.Calendar.ZONE_OFFSET,
	                -8 * HOURS,
	                IBM.ICU.Util.Calendar.DST_OFFSET,
	                HOURS,
	                END_FIELDS,
	                0,
	                0, // expected hour, min
	
	                IBM.ICU.Util.Calendar.MONTH, IBM.ICU.Util.Calendar.JUNE, IBM.ICU.Util.Calendar.ZONE_OFFSET,
	                -8 * HOURS, IBM.ICU.Util.Calendar.DST_OFFSET, HOURS / 2,
	                END_FIELDS,
	                0,
	                30, // expected hour, min
	
	                IBM.ICU.Util.Calendar.MONTH, IBM.ICU.Util.Calendar.JUNE, IBM.ICU.Util.Calendar.ZONE_OFFSET,
	                -8 * HOURS, END_FIELDS, 1,
	                0, // expected hour, min
	
	                IBM.ICU.Util.Calendar.MONTH, IBM.ICU.Util.Calendar.JUNE, IBM.ICU.Util.Calendar.DST_OFFSET, HOURS / 2,
	                END_FIELDS, 16, 30, // expected hour, min
	        };

            for (int i = 0; i < DATA.Length; )
            {
                int start = i;
                cal.Clear();

                // Set fields
                while (DATA[i] != END_FIELDS)
                {
                    cal.Set(DATA[i++], DATA[i++]);
                }
                ++i; // skip over END_FIELDS

                // Get hour/minute
                int h = cal.Get(IBM.ICU.Util.Calendar.HOUR_OF_DAY);
                int m = cal.Get(IBM.ICU.Util.Calendar.MINUTE);

                // Check
                if (h != DATA[i] || m != DATA[i + 1])
                {
                    Errln("Fail: expected " + DATA[i] + ":" + DATA[i + 1]
                            + ", got " + h + ":" + m + " after:");
                    while (DATA[start] != END_FIELDS)
                    {
                        Logln("set(" + FIELD_NAME[DATA[start++]] + ", "
                                + DATA[start++] + ");");
                    }
                }

                i += 2; // skip over expected hour, min
            }
        }

        /// <summary>
        /// DateFormat class mistakes date style and time style as follows: -
        /// DateFormat.getDateTimeInstance takes date style as time style, and time
        /// style as date style - If a Calendar is passed to
        /// DateFormat.getDateInstance, it returns time instance - If a Calendar is
        /// passed to DateFormat.getTimeInstance, it returns date instance
        /// </summary>
        [Test]
        public void TestDateFormatFactoryJ26()
        {
            IBM.ICU.Util.TimeZone zone = IBM.ICU.Util.TimeZone.GetDefault();
            try
            {
                Locale loc = Locale.US;
                IBM.ICU.Util.TimeZone.SetDefault(IBM.ICU.Util.TimeZone.GetTimeZone("America/Los_Angeles"));
                IBM.ICU.Util.Calendar tempcal = IBM.ICU.Util.Calendar.GetInstance();
                tempcal.Set(2001, IBM.ICU.Util.Calendar.APRIL, 5, 17, 43, 53);
                DateTime date = tempcal.GetTime();
                IBM.ICU.Util.Calendar cal = IBM.ICU.Util.Calendar.GetInstance(loc);
                Object[] DATA = {
	                    IBM.ICU.Text.DateFormat.GetDateInstance(IBM.ICU.Text.DateFormat.SHORT, loc),
	                    "DateFormat.getDateInstance(DateFormat.SHORT, loc)",
	                    "4/5/01",
	
	                    IBM.ICU.Text.DateFormat.GetTimeInstance(IBM.ICU.Text.DateFormat.SHORT, loc),
	                    "DateFormat.getTimeInstance(DateFormat.SHORT, loc)",
	                    "5:43 PM",
	
	                    IBM.ICU.Text.DateFormat.GetDateTimeInstance(IBM.ICU.Text.DateFormat.FULL,
	                            IBM.ICU.Text.DateFormat.SHORT, loc),
	                    "DateFormat.getDateTimeInstance(DateFormat.FULL, DateFormat.SHORT, loc)",
	                    "Thursday, April 5, 2001 5:43 PM",
	
	                    IBM.ICU.Text.DateFormat.GetDateInstance(cal, IBM.ICU.Text.DateFormat.SHORT, loc),
	                    "DateFormat.getDateInstance(cal, DateFormat.SHORT, loc)",
	                    "4/5/01",
	
	                    IBM.ICU.Text.DateFormat.GetTimeInstance(cal, IBM.ICU.Text.DateFormat.SHORT, loc),
	                    "DateFormat.getTimeInstance(cal, DateFormat.SHORT, loc)",
	                    "5:43 PM",
	
	                    IBM.ICU.Text.DateFormat.GetDateTimeInstance(cal, IBM.ICU.Text.DateFormat.FULL,
	                            IBM.ICU.Text.DateFormat.SHORT, loc),
	                    "DateFormat.getDateTimeInstance(cal, DateFormat.FULL, DateFormat.SHORT, loc)",
	                    "Thursday, April 5, 2001 5:43 PM",
	
	                    cal.GetDateTimeFormat(IBM.ICU.Text.DateFormat.SHORT, IBM.ICU.Text.DateFormat.FULL,
	                            loc),
	                    "cal.getDateTimeFormat(DateFormat.SHORT, DateFormat.FULL, loc)",
	                    "4/5/01 5:43:53 PM PT",
	
	                    cal.GetDateTimeFormat(IBM.ICU.Text.DateFormat.FULL, IBM.ICU.Text.DateFormat.SHORT,
	                            loc),
	                    "cal.getDateTimeFormat(DateFormat.FULL, DateFormat.SHORT, loc)",
	                    "Thursday, April 5, 2001 5:43 PM", };
                for (int i = 0; i < DATA.Length; i += 3)
                {
                    IBM.ICU.Text.DateFormat df = (IBM.ICU.Text.DateFormat)DATA[i];
                    String desc = (String)DATA[i + 1];
                    String exp = (String)DATA[i + 2];
                    String got = df.Format(date);
                    if (got.Equals(exp))
                    {
                        Logln("Ok: " + desc + " => " + got);
                    }
                    else
                    {
                        Errln("FAIL: " + desc + " => " + got + ", expected " + exp);
                    }
                }
            }
            finally
            {
                IBM.ICU.Util.TimeZone.SetDefault(zone);
            }
        }

        [Test]
        public void TestRegistration()
        {
            /*
             * Set names = Calendar.getCalendarFactoryNames();
             * 
             * TimeZone tz = TimeZone.getDefault(); Locale loc =
             * Locale.getDefault(); Iterator iter = names.iterator(); while
             * (iter.hasNext()) { String name = (String)iter.next(); logln("Testing
             * factory: " + name);
             * 
             * Calendar cal = Calendar.getInstance(tz, loc, name); logln("Calendar
             * class: " + cal.getClass());
             * 
             * DateFormat fmt = cal.getDateTimeFormat(DateFormat.LONG,
             * DateFormat.LONG, loc);
             * 
             * logln("Date: " + fmt.format(cal.getTime())); } // register new
             * default for our locale logln("\nTesting
             * registration"); loc = new Locale("en", "US"); Object key =
             * Calendar.register(JapaneseCalendar.factory(), loc, true);
             * 
             * loc = new Locale("en", "US", "TEST"); Calendar cal =
             * Calendar.getInstance(loc); logln("Calendar class: " +
             * cal.getClass()); DateFormat fmt =
             * cal.getDateTimeFormat(DateFormat.LONG, DateFormat.LONG, loc);
             * logln("Date: " + fmt.format(cal.getTime())); // force to use other
             * default anyway logln("\nOverride
             * registration"); cal = Calendar.getInstance(tz, loc, "Gregorian"); fmt
             * = cal.getDateTimeFormat(DateFormat.LONG, DateFormat.LONG, loc);
             * logln("Date: " + fmt.format(cal.getTime())); // unregister default
             * logln("\nUnregistration"); logln("Unregister returned: " +
             * Calendar.unregister(key)); cal = Calendar.getInstance(tz, loc,
             * "Gregorian"); fmt = cal.getDateTimeFormat(DateFormat.LONG,
             * DateFormat.LONG, loc); logln("Date: " + fmt.format(cal.getTime()));
             */
        }

        /// <summary>
        /// test serialize-and-modify.
        /// </summary>
        ///
        /// <exception cref="ClassNotFoundException"></exception>
        [Ignore]
        public void TestSerialization3474()
        {
            try
            {
                MemoryStream icuStream = new MemoryStream();

                Logln("icu Calendar");

                IBM.ICU.Util.GregorianCalendar icuCalendar = new IBM.ICU.Util.GregorianCalendar();

                icuCalendar.SetTimeInMillis(1187912555931L);
                long expectMillis = 1187912520931L; // with seconds (not ms)
                // cleared.

                Logln("instantiated: " + icuCalendar);
                Logln("getMillis: " + icuCalendar.GetTimeInMillis());
                icuCalendar.Set(IBM.ICU.Util.Calendar.SECOND, 0);
                Logln("setSecond=0: " + icuCalendar);
                {
                    long gotMillis = icuCalendar.GetTimeInMillis();
                    if (gotMillis != expectMillis)
                    {
                        Errln("expect millis " + expectMillis + " but got "
                                + gotMillis);
                    }
                    else
                    {
                        Logln("getMillis: " + gotMillis);
                    }
                }
                IlObjectOutputStream icuOut = new IlObjectOutputStream(icuStream);
                icuOut.WriteObject(icuCalendar);
                ((Stream)icuOut).Flush();
                ((Stream)icuOut).Close();

                IlObjectInputStream icuIn = new IlObjectInputStream(
                        new MemoryStream(icuStream.ToArray()));
                icuCalendar = null;
                icuCalendar = (IBM.ICU.Util.GregorianCalendar)icuIn
                        .ReadObject();

                Logln("serialized back in: " + icuCalendar);
                {
                    long gotMillis_0 = icuCalendar.GetTimeInMillis();
                    if (gotMillis_0 != expectMillis)
                    {
                        Errln("expect millis " + expectMillis + " but got "
                                + gotMillis_0);
                    }
                    else
                    {
                        Logln("getMillis: " + gotMillis_0);
                    }
                }

                icuCalendar.Set(IBM.ICU.Util.Calendar.SECOND, 0);

                Logln("setSecond=0: " + icuCalendar);
                {
                    long gotMillis_1 = icuCalendar.GetTimeInMillis();
                    if (gotMillis_1 != expectMillis)
                    {
                        Errln("expect millis " + expectMillis
                                + " after stream and setSecond but got "
                                + gotMillis_1);
                    }
                    else
                    {
                        Logln("getMillis after stream and setSecond: " + gotMillis_1);
                    }
                }
            }
            catch (IOException e)
            {
                Errln(e.ToString());
                Console.Error.WriteLine(e.StackTrace);
            }
            catch (TypeLoadException cnf)
            {
                Errln(cnf.ToString());
                Console.Error.WriteLine(cnf.StackTrace);
            }

            // JDK works correctly, etc etc.
            // ByteArrayOutputStream jdkStream = new ByteArrayOutputStream();

            // logln("\nSUN Calendar");
            //
            // java.util.GregorianCalendar sunCalendar =
            // new java.util.GregorianCalendar();
            //
            // logln("instanzieren: "+sunCalendar);
            // logln("getMillis: "+sunCalendar.getTimeInMillis());
            // sunCalendar.set(java.util.GregorianCalendar.SECOND, 0);
            // logln("setSecond=0: "+sunCalendar);
            // logln("getMillis: "+sunCalendar.getTimeInMillis());
            //
            // ObjectOutputStream sunOut =
            // new ObjectOutputStream(jdkStream);
            // sunOut.writeObject(sunCalendar);
            // sunOut.flush();
            // sunOut.close();
            //
            // ObjectInputStream sunIn =
            // new ObjectInputStream(new
            // ByteArrayInputStream(jdkStream.toByteArray()));
            // sunCalendar = null;
            // sunCalendar = (java.util.GregorianCalendar)sunIn.readObject();
            //
            // logln("serialized: "+sunCalendar);
            // logln("getMillis: "+sunCalendar.getTimeInMillis());
            //
            // sunCalendar.set(java.util.GregorianCalendar.SECOND, 0);
            // logln("setSecond=0: "+sunCalendar);
            // logln("getMillis: "+sunCalendar.getTimeInMillis());

        }

        [Test]
        public void TestYearJump3279()
        {
            long time = 1041148800000L;
            IBM.ICU.Util.Calendar c = new IBM.ICU.Util.GregorianCalendar();
            IBM.ICU.Text.DateFormat fmt = IBM.ICU.Text.DateFormat.GetDateTimeInstance(IBM.ICU.Text.DateFormat.LONG,
                    IBM.ICU.Text.DateFormat.LONG, Locale.US);

            c.SetTimeInMillis(time);
            int year1 = c.Get(IBM.ICU.Util.Calendar.YEAR);

            Logln("time: " + fmt.Format(DateUtil.DateFromJavaMillis((c.GetTimeInMillis()))));

            Logln("setting DOW to " + c.GetFirstDayOfWeek());
            c.Set(IBM.ICU.Util.Calendar.DAY_OF_WEEK, c.GetFirstDayOfWeek());
            Logln("week: " + c.GetTime());
            Logln("week adjust: " + fmt.Format(DateUtil.DateFromJavaMillis((c.GetTimeInMillis()))));
            int year2 = c.Get(IBM.ICU.Util.Calendar.YEAR);

            if (year1 != year2)
            {
                Errln("Error: adjusted day of week, and year jumped from " + year1
                        + " to " + year2);
            }
            else
            {
                Logln("Year remained " + year2 + " - PASS.");
            }
        }
    }

    // eof
}
