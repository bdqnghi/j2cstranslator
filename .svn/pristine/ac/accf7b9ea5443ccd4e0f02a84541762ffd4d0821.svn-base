/*
 *******************************************************************************
 * Copyright (C) 1996-2007, International Business Machines Corporation and    *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 *
 */

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:30 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Text {
	
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	
	/// <exclude/>
	/// <summary>
	/// This class matches UTF-16 and UTF-32, both big- and little-endian. The BOM
	/// will be used if it is present.
	/// </summary>
	///
	abstract internal class CharsetRecog_Unicode : CharsetRecognizer {
	
	    /*
	     * (non-Javadoc)
	     * 
	     * @see com.ibm.icu.text.CharsetRecognizer#getName()
	     */
	    abstract internal override String GetName();
	
	    /*
	     * (non-Javadoc)
	     * 
	     * @see
	     * com.ibm.icu.text.CharsetRecognizer#match(com.ibm.icu.text.CharsetDetector
	     * )
	     */
	    abstract internal override int Match(CharsetDetector det);
	
	    internal class CharsetRecog_UTF_16_BE : CharsetRecog_Unicode {
	        internal override String GetName() {
	            return "UTF-16BE";
	        }
	
	        internal override int Match(CharsetDetector det) {
	            byte[] input = det.fRawInput;
	
	            if (input.Length >= 2
	                    && ((input[0] & 0xFF) == 0xFE && (input[1] & 0xFF) == 0xFF)) {
	                return 100;
	            }
	
	            // TODO: Do some statistics to check for unsigned UTF-16BE
	            return 0;
	        }
	    }
	
	    internal class CharsetRecog_UTF_16_LE : CharsetRecog_Unicode {
	        internal override String GetName() {
	            return "UTF-16LE";
	        }
	
	        internal override int Match(CharsetDetector det) {
	            byte[] input = det.fRawInput;
	
	            if (input.Length >= 2
	                    && ((input[0] & 0xFF) == 0xFF && (input[1] & 0xFF) == 0xFE)) {
	                // An LE BOM is present.
	                if (input.Length >= 4 && input[2] == 0x00 && input[3] == 0x00) {
	                    // It is probably UTF-32 LE, not UTF-16
	                    return 0;
	                }
	                return 100;
	            }
	
	            // TODO: Do some statistics to check for unsigned UTF-16LE
	            return 0;
	        }
	    }
	
	    abstract internal class CharsetRecog_UTF_32 : CharsetRecog_Unicode {
	        abstract internal int GetChar(byte[] input, int index);
	
	        abstract internal override String GetName();
	
	        internal override int Match(CharsetDetector det) {
	            byte[] input = det.fRawInput;
	            int limit = (det.fRawLength / 4) * 4;
	            int numValid = 0;
	            int numInvalid = 0;
	            bool hasBOM = false;
	            int confidence = 0;
	
	            if (limit == 0) {
	                return 0;
	            }
	            if (GetChar(input, 0) == 0x0000FEFF) {
	                hasBOM = true;
	            }
	
	            for (int i = 0; i < limit; i += 4) {
	                int ch = GetChar(input, i);
	
	                if (ch < 0 || ch >= 0x10FFFF || (ch >= 0xD800 && ch <= 0xDFFF)) {
	                    numInvalid += 1;
	                } else {
	                    numValid += 1;
	                }
	            }
	
	            // Cook up some sort of confidence score, based on presence of a BOM
	            // and the existence of valid and/or invalid multi-byte sequences.
	            if (hasBOM && numInvalid == 0) {
	                confidence = 100;
	            } else if (hasBOM && numValid > numInvalid * 10) {
	                confidence = 80;
	            } else if (numValid > 3 && numInvalid == 0) {
	                confidence = 100;
	            } else if (numValid > 0 && numInvalid == 0) {
	                confidence = 80;
	            } else if (numValid > numInvalid * 10) {
	                // Probably corrupt UTF-32BE data. Valid sequences aren't likely
	                // by chance.
	                confidence = 25;
	            }
	
	            return confidence;
	        }
	    }
	
	    internal class CharsetRecog_UTF_32_BE : CharsetRecog_Unicode.CharsetRecog_UTF_32  {
	        internal override int GetChar(byte[] input, int index) {
	            return (input[index + 0] & 0xFF) << 24
	                    | (input[index + 1] & 0xFF) << 16
	                    | (input[index + 2] & 0xFF) << 8
	                    | (input[index + 3] & 0xFF);
	        }
	
	        internal override String GetName() {
	            return "UTF-32BE";
	        }
	    }
	
	    internal class CharsetRecog_UTF_32_LE : CharsetRecog_Unicode.CharsetRecog_UTF_32  {
	        internal override int GetChar(byte[] input, int index) {
	            return (input[index + 3] & 0xFF) << 24
	                    | (input[index + 2] & 0xFF) << 16
	                    | (input[index + 1] & 0xFF) << 8
	                    | (input[index + 0] & 0xFF);
	        }
	
	        internal override String GetName() {
	            return "UTF-32LE";
	        }
	    }
	}
}
