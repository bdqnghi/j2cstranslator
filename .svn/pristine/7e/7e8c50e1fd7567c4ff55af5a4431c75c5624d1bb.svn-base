/*
 *******************************************************************************
 *   Copyright (C) 2001-2007, International Business Machines
 *   Corporation and others.  All Rights Reserved.
 *******************************************************************************
 */

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/13/10 10:46 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Charset {
	
	using IBM.ICU.Text;
	using NUnit;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	
	/// <summary>
	/// Regression test for the basic "inverse" Bidi mode.
	/// ported from C by Lina Kemmel, Matitiahu Allouche
	/// </summary>
	///
	
	[NUnit.Framework.TestFixture]
	public class TestInverse : BidiTest {
	
	    public TestInverse() {
	        this.countRoundtrips = 0;
	        this.countNonRoundtrips = 0;
	    }
	
	    private int countRoundtrips;
	
	    private int countNonRoundtrips;
	
	    static internal readonly String[] testCases = {
	            "\u006c\u0061\u0028\u0074\u0069\u006e\u0020\u05d0\u05d1\u0029\u05d2\u05d3",
	            "\u006c\u0061\u0074\u0020\u05d0\u05d1\u05d2\u0020\u0031\u0032\u0033",
	            "\u006c\u0061\u0074\u0020\u05d0\u0028\u05d1\u05d2\u0020\u0031\u0029\u0032\u0033",
	            "\u0031\u0032\u0033\u0020\u05d0\u05d1\u05d2\u0020\u0034\u0035\u0036",
	            "\u0061\u0062\u0020\u0061\u0062\u0020\u0661\u0662" };
	
	    [NUnit.Framework.Test]
	    public void TestInverse2() {
	        Bidi bidi;
	        int i;
	
	        Logln("\nEntering TestInverse\n");
	        bidi = new Bidi();
	        Log("inverse Bidi: testInverse(L) with " + testCases.Length
	                + " test cases ---\n");
	        for (i = 0; i < testCases.Length; ++i) {
	            Logln("Testing case " + i);
	            _testInverseBidi(bidi, testCases[i], IBM.ICU.Text.Bidi.DIRECTION_LEFT_TO_RIGHT);
	        }
	
	        Log("inverse Bidi: testInverse(R) with " + testCases.Length
	                + " test cases ---\n");
	        for (i = 0; i < testCases.Length; ++i) {
	            Logln("Testing case " + i);
	            _testInverseBidi(bidi, testCases[i], IBM.ICU.Text.Bidi.DIRECTION_RIGHT_TO_LEFT);
	        }
	
	        _testManyInverseBidi(bidi, IBM.ICU.Text.Bidi.DIRECTION_LEFT_TO_RIGHT);
	        _testManyInverseBidi(bidi, IBM.ICU.Text.Bidi.DIRECTION_RIGHT_TO_LEFT);
	
	        Logln("inverse Bidi: rountrips: " + countRoundtrips
	                + "   non-roundtrips: " + countNonRoundtrips);
	
	        _testWriteReverse();
	
	        _testManyAddedPoints();
	
	        _testMisc();
	
	        Logln("\nExiting TestInverse\n");
	    }

        private static readonly char[][] repeatSegments = { new char[] { (char) 0x61, (char) 0x62 }, new char[] { (char) 0x5d0, (char) 0x5d1 },
	            new char[] { (char) 0x627, (char) 0x628 }, new char[] { (char) 0x31, (char) 0x32 },
	            new char[] { (char) 0x661, (char) 0x662 }, new char[] { (char) 0x20, (char) 0x20 } };
	
	    private const int COUNT_REPEAT_SEGMENTS = 6;
	
	    private void _testManyInverseBidi(Bidi bidi, int direction) {
            char[] text = { (char)0, (char)0, (char)0x20, (char)0, (char)0, (char)0x20, (char)0, (char)0 };
	        int i, j, k;
	
	        Log("inverse Bidi: testManyInverseBiDi("
	                + ((direction == IBM.ICU.Text.Bidi.DIRECTION_LEFT_TO_RIGHT) ? 'L' : 'R')
	                + ") - test permutations of text snippets ---\n");
	        for (i = 0; i < COUNT_REPEAT_SEGMENTS; ++i) {
	            text[0] = repeatSegments[i][0];
	            text[1] = repeatSegments[i][1];
	            for (j = 0; j < COUNT_REPEAT_SEGMENTS; ++j) {
	                text[3] = repeatSegments[j][0];
	                text[4] = repeatSegments[j][1];
	                for (k = 0; k < COUNT_REPEAT_SEGMENTS; ++k) {
	                    text[6] = repeatSegments[k][0];
	                    text[7] = repeatSegments[k][1];
	
	                    Log("inverse Bidi: testManyInverseBiDi()[" + i + " " + j
	                            + " " + k + "]\n");
	                    _testInverseBidi(bidi, ILOG.J2CsMapping.Util.StringUtil.NewString(text), direction);
	                }
	            }
	        }
	    }
	
	    private void _testInverseBidi(Bidi bidi, String src, int direction) {
	        String visualLTR, logicalDest, visualDest;
	        try {
	            if (direction == IBM.ICU.Text.Bidi.DIRECTION_LEFT_TO_RIGHT) {
	                Log("inverse Bidi: testInverse(L)\n");
	
	                /* convert visual to logical */
	                bidi.SetInverse(true);
	                if (!bidi.IsInverse()) {
	                    Err("Error while doing setInverse(true)\n");
	                }
	                bidi.SetPara(src, IBM.ICU.Text.Bidi.LTR, null);
	                if (!ILOG.J2CsMapping.Collections.Arrays.Equals(src.ToCharArray(),bidi.GetText())) {
	                    Err("Wrong value returned by getText\n");
	                }
	                if (!src.Equals(bidi.GetTextAsString())) {
	                    Err("Wrong value returned by getTextAsString\n");
	                }
	                logicalDest = bidi.WriteReordered(IBM.ICU.Text.Bidi.DO_MIRRORING
	                        | IBM.ICU.Text.Bidi.INSERT_LRM_FOR_NUMERIC);
	                Log("  v ");
	                PrintUnicode(src.ToCharArray(), bidi.GetLevels());
	                Log("\n");
	
	                /* convert back to visual LTR */
	                bidi.SetInverse(false);
	                if (bidi.IsInverse()) {
	                    Err("Error while doing setInverse(false)\n");
	                }
	                bidi.SetPara(logicalDest, IBM.ICU.Text.Bidi.LTR, null);
	                visualDest = bidi.WriteReordered(IBM.ICU.Text.Bidi.DO_MIRRORING
	                        | IBM.ICU.Text.Bidi.REMOVE_BIDI_CONTROLS);
	            } else {
	                Logln("inverse Bidi: testInverse(R)\n");
	
	                /* reverse visual from RTL to LTR */
	                visualLTR = IBM.ICU.Text.Bidi.WriteReverse(src, 0);
	                Log("  vr");
	                PrintUnicode(src.ToCharArray(), null);
	                Log("\n");
	
	                /* convert visual RTL to logical */
	                bidi.SetInverse(true);
	                bidi.SetPara(visualLTR, IBM.ICU.Text.Bidi.LTR, null);
	                logicalDest = bidi.WriteReordered(IBM.ICU.Text.Bidi.DO_MIRRORING
	                        | IBM.ICU.Text.Bidi.INSERT_LRM_FOR_NUMERIC);
	                Log("  vl");
	                PrintUnicode(visualLTR.ToCharArray(), bidi.GetLevels());
	                Log("\n");
	
	                /* convert back to visual RTL */
	                bidi.SetInverse(false);
	                bidi.SetPara(logicalDest, IBM.ICU.Text.Bidi.LTR, null);
	                visualDest = bidi.WriteReordered(IBM.ICU.Text.Bidi.DO_MIRRORING
	                        | IBM.ICU.Text.Bidi.REMOVE_BIDI_CONTROLS | IBM.ICU.Text.Bidi.OUTPUT_REVERSE);
	            }
	            Log("  l ");
	            PrintUnicode(logicalDest.ToCharArray(), bidi.GetLevels());
	            Log("\n");
	            Log("  v ");
	            PrintUnicode(visualDest.ToCharArray(), null);
	            Log("\n");
	        } catch (Exception e) {
	            Errln("inverse Bidi: *** failed");
	            visualDest = null;
	        }
	
	        /* check and print results */
	        if (src.Equals(visualDest)) {
	            ++countRoundtrips;
	            Log(" + roundtripped\n");
	        } else {
	            ++countNonRoundtrips;
	            Log(" * did not roundtrip\n");
	        }
	    }
	
	    private void _testWriteReverse() {
	        /* U+064e and U+0650 are combining marks (Mn) */
	        String forward = "\u200f\u0627\u064e\u0650\u0020\u0028\u0031\u0029", reverseKeepCombining = "\u0029\u0031\u0028\u0020\u0627\u064e\u0650\u200f", reverseRemoveControlsKeepCombiningDoMirror = "\u0028\u0031\u0029\u0020\u0627\u064e\u0650";
	
	        String reverse;
	
	        /* test Bidi.writeReverse() with "interesting" options */
	        try {
	            reverse = IBM.ICU.Text.Bidi.WriteReverse(forward, IBM.ICU.Text.Bidi.KEEP_BASE_COMBINING);
	        } catch (Exception e) {
	            Errln("Failure in Bidi.writeReverse(KEEP_BASE_COMBINING)");
	            reverse = null;
	        }
	        AssertEquals("\nFailure in " + GetType().ToString()
	                + " in Bidi.writeReverse", reverseKeepCombining, reverse,
	                forward, null, "KEEP_BASE_COMBINING", null);
	
	        try {
	            reverse = IBM.ICU.Text.Bidi.WriteReverse(forward, IBM.ICU.Text.Bidi.REMOVE_BIDI_CONTROLS
	                    | IBM.ICU.Text.Bidi.DO_MIRRORING | IBM.ICU.Text.Bidi.KEEP_BASE_COMBINING);
	        } catch (Exception e_0) {
	            Errln("Failure in Bidi.writeReverse(KEEP_BASE_COMBINING)");
	        }
	        AssertEquals("\nFailure in " + GetType().ToString()
	                + " in Bidi.writeReverse",
	                reverseRemoveControlsKeepCombiningDoMirror, reverse, forward,
	                null, "REMOVE_BIDI_CONTROLS|DO_MIRRORING|KEEP_BASE_COMBINING",
	                null);
	    }
	
	    private void PrintUnicode(char[] chars, sbyte[] levels) {
	        int i;
	
	        Log("{ ");
	        for (i = 0; i < chars.Length; ++i) {
	            Log("0x" + IBM.ICU.Impl.Utility.Hex(chars[i]));
	            if (levels != null) {
	                Log("." + levels[i]);
	            }
	            Log("   ");
	        }
	        Log(" }");
	    }
	
	    private void _testManyAddedPoints() {
	        Bidi bidi = new Bidi();
	        char[] text = new char[90];
	        for (int i = 0; i < text.Length; i += 3) {
	            text[i] = 'a';
	            text[i + 1] = '\u05d0';
	            text[i + 2] = '3';
	        }
	        bidi.SetReorderingMode(IBM.ICU.Text.Bidi.REORDER_INVERSE_LIKE_DIRECT);
	        bidi.SetReorderingOptions(IBM.ICU.Text.Bidi.OPTION_INSERT_MARKS);
	        bidi.SetPara(text, IBM.ICU.Text.Bidi.LTR, null);
	        String xout = bidi.WriteReordered(0);
	        char[] expected = new char[120];
	        for (int i_0 = 0; i_0 < expected.Length; i_0 += 4) {
	            expected[i_0] = 'a';
	            expected[i_0 + 1] = '\u05d0';
	            expected[i_0 + 2] = '\u200e';
	            expected[i_0 + 3] = '3';
	        }
	        AssertEquals("\nInvalid output with many added points", ILOG.J2CsMapping.Util.StringUtil.NewString(expected), xout);
	    }
	
	    private void _testMisc() {
	        Bidi bidi = new Bidi();
	        bidi.SetInverse(true);
	        bidi.SetPara("   ", IBM.ICU.Text.Bidi.RTL, null);
	        String xout = bidi.WriteReordered(IBM.ICU.Text.Bidi.OUTPUT_REVERSE
	                | IBM.ICU.Text.Bidi.INSERT_LRM_FOR_NUMERIC);
	        AssertEquals("\nInvalid output with RLM at both sides",
	                "\u200f   \u200f", xout);
	    }
	
	    public static void Main(String[] args) {
	        try {
	            new TestInverse().Run(args);
	        } catch (Exception e) {
	            System.Console.Out.WriteLine(e);
	        }
	    }
	
	}
}
