/*
 *******************************************************************************
 * Copyright (C) 2002-2004, International Business Machines Corporation and    *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 */
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:47 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
namespace IBM.ICU.Impl
{

    using IBM.ICU.Text;
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.IO;
    using System.Runtime.CompilerServices;
    using System.Text;

    // This class contains utility functions so testing not needed
    // /CLOVER:OFF
    public class UtilityExtensions
    {
        /// <summary>
        /// Append the given string to the rule. Calls the single-character version
        /// of appendToRule for each character.
        /// </summary>
        ///
        public static void AppendToRule(StringBuilder rule, String text,
                bool isLiteral, bool escapeUnprintable, StringBuilder quoteBuf)
        {
            for (int i = 0; i < text.Length; ++i)
            {
                // Okay to process in 16-bit code units here
                IBM.ICU.Impl.Utility.AppendToRule(rule, text[i], isLiteral,
                        escapeUnprintable, quoteBuf);
            }
        }

        /// <summary>
        /// Given a matcher reference, which may be null, append its pattern as a
        /// literal to the given rule.
        /// </summary>
        ///
        public static void AppendToRule(StringBuilder rule, UnicodeMatcher matcher,
                bool escapeUnprintable, StringBuilder quoteBuf)
        {
            if (matcher != null)
            {
                AppendToRule(rule, matcher.ToPattern(escapeUnprintable), true,
                        escapeUnprintable, quoteBuf);
            }
        }

        /// <summary>
        /// For debugging purposes; format the given text in the form
        /// aaa{bbb|ccc|ddd}eee, where the {} indicate the context start and limit,
        /// and the || indicate the start and limit.
        /// </summary>
        ///
        public static String FormatInput(ReplaceableString input,
                Transliterator.Position pos)
        {
            StringBuilder appendTo = new StringBuilder();
            FormatInput(appendTo, input, pos);
            return IBM.ICU.Impl.Utility.Escape(appendTo.ToString());
        }

        /// <summary>
        /// For debugging purposes; format the given text in the form
        /// aaa{bbb|ccc|ddd}eee, where the {} indicate the context start and limit,
        /// and the || indicate the start and limit.
        /// </summary>
        ///
        public static StringBuilder FormatInput(StringBuilder appendTo,
                ReplaceableString input, Transliterator.Position pos)
        {
            if (0 <= pos.contextStart && pos.contextStart <= pos.start
                    && pos.start <= pos.limit && pos.limit <= pos.contextLimit
                    && pos.contextLimit <= input.Length())
            {

                String b, c, d;
                // a = input.substring(0, pos.contextStart);
                b = input.Substring(pos.contextStart, pos.start);
                c = input.Substring(pos.start, pos.limit);
                d = input.Substring(pos.limit, pos.contextLimit);
                // e = input.substring(pos.contextLimit, input.length());
                appendTo.// append(a).
                Append('{').Append(b).Append('|').Append(c).Append('|').Append(d)
                        .Append('}')
                    // .append(e)
                ;
            }
            else
            {
                appendTo.Append("INVALID Position {cs=" + pos.contextStart + ", s="
                        + pos.start + ", l=" + pos.limit + ", cl="
                        + pos.contextLimit + "} on " + input);
            }
            return appendTo;
        }

        /// <summary>
        /// Convenience method.
        /// </summary>
        ///
        public static String FormatInput(Replaceable input,
                Transliterator.Position pos)
        {
            return FormatInput((ReplaceableString)input, pos);
        }

        /// <summary>
        /// Convenience method.
        /// </summary>
        ///
        public static StringBuilder FormatInput(StringBuilder appendTo,
                Replaceable input, Transliterator.Position pos)
        {
            return FormatInput(appendTo, (ReplaceableString)input, pos);
        }

    }
    // CLOVER:ON
}
