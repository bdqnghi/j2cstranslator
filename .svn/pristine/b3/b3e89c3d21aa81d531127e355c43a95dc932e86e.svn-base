/* 
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/1/10 3:36 PM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
namespace ILOG.J2CsMapping.Formatting
{
	
	using ILOG.J2CsMapping.IO;
	using ILOG.J2CsMapping.Util;
    using ILOG.J2CsMapping.Text;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.Globalization;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Text;
	
	/// <summary>
	/// SimpleDateFormat is used to format and parse Gregorian calendar dates and
	/// times based on a pattern of date and time fields. Each date and time field is
	/// specified in the pattern by a specific character. The characters used can be
	/// either localized or non-localized. For some fields, which have both numeric
	/// and text representations or abbreviated as well as full names, the number of
	/// grouped characters specifies how the field is formatted or parsed.
	/// </summary>
	///
	public class SimpleDateFormat : DateFormat {
	
		private const long serialVersionUID = 4774881970558875024L;
	
		private const String patternChars = "GyMdkHmsSEDFwWahKzYeugAZvcLQqV"; //$NON-NLS-1$
	
		protected internal String pattern;
	
		private DateFormatSymbols formatData;
	
		private int creationYear;
	
		private DateTime defaultCenturyStart;
	
		private IBM.ICU.Text.SimpleDateFormat icuFormat;
	
		/// <summary>
		/// Constructs a new SimpleDateFormat for formatting and parsing dates and
		/// times in the SHORT style for the default Locale.
		/// </summary>
		///
        public SimpleDateFormat()
            : this(Locale.GetDefault())
        {
            icuFormat = new IBM.ICU.Text.SimpleDateFormat();
            pattern = (String)ILOG.J2CsMapping.Formatting.Format.GetInternalField("pattern", icuFormat);
            formatData = new DateFormatSymbols(Locale.GetDefault());
		}
	
		/// <summary>
		/// Constructs a new SimpleDateFormat using the specified non-localized
		/// pattern and the DateFormatSymbols and Calendar for the default Locale.
		/// </summary>
		///
		/// <param name="pattern_0">the pattern</param>
		/// <exception cref="NullPointerException">if a <c>null</c> value of <c>pattern</c>is supplied.</exception>
		/// <exception cref="IllegalArgumentException">if <c>pattern</c> is not considered to be useableby this formatter.</exception>
        public SimpleDateFormat(String pattern_0)
            : this(pattern_0, Locale.GetDefault())
        {
		}
	
		/// <summary>
		/// Validate the format character.
		/// </summary>
		///
		/// <param name="format">the format character</param>
		/// <exception cref="IllegalArgumentException">when the format character is invalid</exception>
		private void ValidateFormat(char format) {
			int index = patternChars.IndexOf(format);
			if (index == -1) {
				// text.03=Unknown pattern character - '{0}'
				throw new ArgumentException("text.03" + format); //$NON-NLS-1$
			}
		}
	
		/// <summary>
		/// Validate the pattern.
		/// </summary>
		///
		/// <param name="template">the pattern to validate.</param>
		/// <exception cref="NullPointerException">if the pattern is null</exception>
		/// <exception cref="IllegalArgumentException">if the pattern is invalid</exception>
		private void ValidatePattern(String template) {
			bool quote = false;
			int next, last = -1, count = 0;
	
			int patternLength = template.Length;
			for (int i = 0; i < patternLength; i++) {
				next = (template[i]);
				if (next == '\'') {
					if (count > 0) {
						ValidateFormat((char) last);
						count = 0;
					}
					if (last == next) {
						last = -1;
					} else {
						last = next;
					}
					quote = !quote;
					continue;
				}
				if (!quote
						&& (last == next || (next >= 'a' && next <= 'z') || (next >= 'A' && next <= 'Z'))) {
					if (last == next) {
						count++;
					} else {
						if (count > 0) {
							ValidateFormat((char) last);
						}
						last = next;
						count = 1;
					}
				} else {
					if (count > 0) {
						ValidateFormat((char) last);
						count = 0;
					}
					last = -1;
				}
			}
			if (count > 0) {
				ValidateFormat((char) last);
			}
	
			if (quote) {
				// text.04=Unterminated quote {0}
				throw new ArgumentException("text.04"); //$NON-NLS-1$
			}
	
		}
	
		/// <summary>
		/// Constructs a new SimpleDateFormat using the specified non-localized
		/// pattern and DateFormatSymbols and the Calendar for the default Locale.
		/// </summary>
		///
		/// <param name="template">the pattern</param>
		/// <param name="value">the DateFormatSymbols</param>
		/// <exception cref="NullPointerException">if the pattern is null</exception>
		/// <exception cref="IllegalArgumentException">if the pattern is invalid</exception>
        public SimpleDateFormat(String template, DateFormatSymbols value_ren)
            : this(Locale.GetDefault())
        {
			ValidatePattern(template);
            icuFormat = new IBM.ICU.Text.SimpleDateFormat(template,
                    Locale.GetDefault());
			pattern = template;
			formatData = (DateFormatSymbols) value_ren.Clone();
		}
	
		private void CopySymbols(DateFormatSymbols value_ren,
                IBM.ICU.Text.DateFormatSymbols icuSymbols)
        {
			icuSymbols.SetAmPmStrings(value_ren.GetAmPmStrings());
			icuSymbols.SetEras(value_ren.GetEras());
			icuSymbols.SetLocalPatternChars(value_ren.GetLocalPatternChars());
			icuSymbols.SetMonths(value_ren.GetMonths());
			icuSymbols.SetShortMonths(value_ren.GetShortMonths());
			icuSymbols.SetShortWeekdays(value_ren.GetShortWeekdays());
			icuSymbols.SetWeekdays(value_ren.GetWeekdays());
			icuSymbols.SetZoneStrings(value_ren.GetZoneStrings());
		}
	
		/// <summary>
		/// Constructs a new SimpleDateFormat using the specified non-localized
		/// pattern and the DateFormatSymbols and Calendar for the specified Locale.
		/// </summary>
		///
		/// <param name="template">the pattern</param>
		/// <param name="locale">the Locale</param>
		/// <exception cref="NullPointerException">if the pattern is null</exception>
		/// <exception cref="IllegalArgumentException">if the pattern is invalid</exception>
        public SimpleDateFormat(String template, Locale locale)
            : this(locale)
        {
			ValidatePattern(template);
            icuFormat = new IBM.ICU.Text.SimpleDateFormat(template, locale);
			pattern = template;
			formatData = new DateFormatSymbols(locale);
		}

        internal SimpleDateFormat(Locale locale, IBM.ICU.Text.SimpleDateFormat icuFormat_0)
            : this(locale)
        {
			this.icuFormat = icuFormat_0;
            pattern = (String)ILOG.J2CsMapping.Formatting.Format.GetInternalField("pattern", icuFormat_0);
			formatData = new DateFormatSymbols(locale);
		}

        private SimpleDateFormat(Locale locale)
        {
			numberFormat = NumberFormat.GetInstance(locale);
			numberFormat.SetParseIntegerOnly(true);
			numberFormat.SetGroupingUsed(false);
			calendar = new IBM.ICU.Util.GregorianCalendar(locale);
			calendar.Add(ILOG.J2CsMapping.Util.Calendar.YEAR, -80);
			creationYear = calendar.Get(ILOG.J2CsMapping.Util.Calendar.YEAR);
			defaultCenturyStart = calendar.GetTime();
		}
	
		/// <summary>
		/// Changes the pattern of this SimpleDateFormat to the specified pattern
		/// which uses localized pattern characters.
		/// </summary>
		///
		/// <param name="template">the localized pattern</param>
		public void ApplyLocalizedPattern(String template) {
			icuFormat.ApplyLocalizedPattern(template);
			pattern = icuFormat.ToPattern();
		}
	
		/// <summary>
		/// Changes the pattern of this SimpleDateFormat to the specified pattern
		/// which uses non-localized pattern characters.
		/// </summary>
		///
		/// <param name="template">the non-localized pattern</param>
		/// <exception cref="NullPointerException">if the pattern is null</exception>
		/// <exception cref="IllegalArgumentException">if the pattern is invalid</exception>
		public void ApplyPattern(String template) {
			ValidatePattern(template);
			icuFormat.ApplyPattern(template);
			pattern = template;
		}
	
		/// <summary>
		/// Answers a new SimpleDateFormat with the same pattern and properties as
		/// this SimpleDateFormat.
		/// </summary>
		///
		/// <returns>a shallow copy of this SimpleDateFormat</returns>
		/// <seealso cref="T:System.ICloneable"/>
		public override Object Clone() {
			SimpleDateFormat clone = (SimpleDateFormat) base.Clone();
			clone.formatData = (DateFormatSymbols) formatData.Clone();
			clone.defaultCenturyStart = new DateTime(((defaultCenturyStart.Ticks/10000))*10000);
			return clone;
		}
	
		/// <summary>
		/// Compares the specified object to this SimpleDateFormat and answer if they
		/// are equal. The object must be an instance of SimpleDateFormat and have
		/// the same DateFormat properties, pattern, DateFormatSymbols, and creation
		/// year.
		/// </summary>
		///
		/// <param name="object">the object to compare with this object</param>
		/// <returns>true if the specified object is equal to this SimpleDateFormat,
		/// false otherwise</returns>
		/// <seealso cref="M:ILOG.J2CsMapping.Text.SimpleDateFormat.HashCode"/>
		public override bool Equals(Object obj0) {
			if ((Object) this == obj0) {
				return true;
			}
			if (!(obj0   is  SimpleDateFormat)) {
				return false;
			}
			SimpleDateFormat simple = (SimpleDateFormat) obj0;
			return base.Equals(obj0) && pattern.Equals(simple.pattern)
					&& formatData.Equals(simple.formatData);
		}
	
		/// <summary>
		/// Formats the specified object using the rules of this SimpleDateFormat and
		/// returns an AttributedCharacterIterator with the formatted Date and
		/// attributes.
		/// </summary>
		///
		/// <param name="object">the object to format</param>
		/// <returns>an AttributedCharacterIterator with the formatted date and
		/// attributes</returns>
		/// <exception cref="NullPointerException">when the object is null</exception>
		/// <exception cref="IllegalArgumentException">when the object cannot be formatted by this Format</exception>
		public override ILOG.J2CsMapping.Text.AttributedCharacterIterator FormatToCharacterIterator(Object obj0) {
			if (obj0 == null) {
				throw new NullReferenceException();
			}
			if (obj0   is  DateTime) {
				return FormatToCharacterIteratorImpl((DateTime) obj0);
			}
			if (obj0   is  object) {
				return FormatToCharacterIteratorImpl(new DateTime((Convert.ToInt64(((object) obj0)))*10000));
			}
			throw new ArgumentException();
	
		}
	
		private ILOG.J2CsMapping.Text.AttributedCharacterIterator FormatToCharacterIteratorImpl(DateTime date) {
			StringBuilder buffer = new StringBuilder();
			List<FieldPosition> fields = new List<FieldPosition>();
	
			// format the date, and find fields
			FormatImpl(date, buffer, null, fields);
	
			// create and AttributedString with the formatted buffer
			ILOG.J2CsMapping.Text.AttributedString // create and AttributedString with the formatted buffer
					al = new ILOG.J2CsMapping.Text.AttributedString(buffer.ToString());
	
			// add DateFormat field attributes to the AttributedString
			for (int i = 0; i < fields.Count; i++) {
				FieldPosition pos = fields[i];
				Format.Field attribute = pos.GetFieldAttribute();
				al.AddAttribute(attribute, attribute, pos.GetBeginIndex(),
						pos.GetEndIndex());
			}
	
			// return the CharacterIterator from AttributedString
			return al.GetIterator();
		}
	
		/// <summary>
		/// Formats the date.
		/// <p>
		/// If the FieldPosition <c>field</c> is not null, and the field
		/// specified by this FieldPosition is formatted, set the begin and end index
		/// of the formatted field in the FieldPosition.
		/// <p>
		/// If the Vector <c>fields</c> is not null, find fields of this
		/// date, set FieldPositions with these fields, and add them to the fields
		/// vector.
		/// </summary>
		///
		/// <param name="date">Date to Format</param>
		/// <param name="buffer">StringBuffer to store the resulting formatted String</param>
		/// <param name="field">FieldPosition to set begin and end index of the fieldspecified, if it is part of the format for this date</param>
		/// <param name="fields">Vector used to store the FieldPositions for each field in thisdate</param>
		/// <returns>the formatted Date</returns>
		/// <exception cref="IllegalArgumentException">when the object cannot be formatted by this Format</exception>
		private StringBuilder FormatImpl(DateTime date, StringBuilder buffer,
				FieldPosition field, List<FieldPosition> fields) {
	
			bool quote = false;
			int next, last = -1, count = 0;
			calendar.SetTime(date);
			if (field != null) {
				field.Clear();
			}
	
			int patternLength = pattern.Length;
			for (int i = 0; i < patternLength; i++) {
				next = (pattern[i]);
				if (next == '\'') {
					if (count > 0) {
						Append(buffer, field, fields, (char) last, count);
						count = 0;
					}
					if (last == next) {
						buffer.Append('\'');
						last = -1;
					} else {
						last = next;
					}
					quote = !quote;
					continue;
				}
				if (!quote
						&& (last == next || (next >= 'a' && next <= 'z') || (next >= 'A' && next <= 'Z'))) {
					if (last == next) {
						count++;
					} else {
						if (count > 0) {
							Append(buffer, field, fields, (char) last, count);
						}
						last = next;
						count = 1;
					}
				} else {
					if (count > 0) {
						Append(buffer, field, fields, (char) last, count);
						count = 0;
					}
					last = -1;
					buffer.Append((char) next);
				}
			}
			if (count > 0) {
				Append(buffer, field, fields, (char) last, count);
			}
			return buffer;
		}
	
		private void Append(StringBuilder buffer, FieldPosition position,
				List<FieldPosition> fields, char format, int count) {
			int field = -1;
			int index = patternChars.IndexOf(format);
			if (index == -1) {
				// text.03=Unknown pattern character - '{0}'
				throw new ArgumentException("text.03" + format); //$NON-NLS-1$
			}
	
			int beginPosition = buffer.Length;
			DateFormat.Field  dateFormatField = null;
			System.Console.Out.WriteLine("index:" + index);
			switch (index) {
			case DateFormat.ERA_FIELD:
				dateFormatField = DateFormat.Field.ERA;
				buffer.Append(formatData.eras[calendar.Get(ILOG.J2CsMapping.Util.Calendar.ERA)]);
				break;
			case DateFormat.YEAR_FIELD:
				dateFormatField = DateFormat.Field.YEAR;
				int year = calendar.Get(ILOG.J2CsMapping.Util.Calendar.YEAR);
				if (count < 4) {
					AppendNumber(buffer, 2, year %= 100);
				} else {
					AppendNumber(buffer, count, year);
				}
				break;
			case DateFormat.MONTH_FIELD:
				dateFormatField = DateFormat.Field.MONTH;
				int month = calendar.Get(ILOG.J2CsMapping.Util.Calendar.MONTH);
				if (count <= 2) {
					AppendNumber(buffer, count, month + 1);
				} else if (count == 3) {
					buffer.Append(formatData.shortMonths[month]);
				} else {
					buffer.Append(formatData.months[month]);
				}
				break;
			case DateFormat.DATE_FIELD:
				dateFormatField = DateFormat.Field.DAY_OF_MONTH;
				field = ILOG.J2CsMapping.Util.Calendar.DATE;
				break;
			case DateFormat.HOUR_OF_DAY1_FIELD: // k
				dateFormatField = DateFormat.Field.HOUR_OF_DAY1;
				int hour = calendar.Get(ILOG.J2CsMapping.Util.Calendar.HOUR_OF_DAY);
				AppendNumber(buffer, count, (hour == 0) ? 24 : hour);
				break;
			case DateFormat.HOUR_OF_DAY0_FIELD: // H
				dateFormatField = DateFormat.Field.HOUR_OF_DAY0;
				field = ILOG.J2CsMapping.Util.Calendar.HOUR_OF_DAY;
				break;
			case DateFormat.MINUTE_FIELD:
				dateFormatField = DateFormat.Field.MINUTE;
				field = ILOG.J2CsMapping.Util.Calendar.MINUTE;
				break;
			case DateFormat.SECOND_FIELD:
				dateFormatField = DateFormat.Field.SECOND;
				field = ILOG.J2CsMapping.Util.Calendar.SECOND;
				break;
			case DateFormat.MILLISECOND_FIELD:
				dateFormatField = DateFormat.Field.MILLISECOND;
				int value_ren = calendar.Get(ILOG.J2CsMapping.Util.Calendar.MILLISECOND);
				AppendNumber(buffer, count, value_ren);
				break;
			case DateFormat.DAY_OF_WEEK_FIELD:
				dateFormatField = DateFormat.Field.DAY_OF_WEEK;
				int day = calendar.Get(ILOG.J2CsMapping.Util.Calendar.DAY_OF_WEEK);
				if (count < 4) {
					buffer.Append(formatData.shortWeekdays[day]);
				} else {
					buffer.Append(formatData.weekdays[day]);
				}
				break;
			case DateFormat.DAY_OF_YEAR_FIELD:
				dateFormatField = DateFormat.Field.DAY_OF_YEAR;
				field = ILOG.J2CsMapping.Util.Calendar.DAY_OF_YEAR;
				break;
			case DateFormat.DAY_OF_WEEK_IN_MONTH_FIELD:
				dateFormatField = DateFormat.Field.DAY_OF_WEEK_IN_MONTH;
				field = ILOG.J2CsMapping.Util.Calendar.DAY_OF_WEEK_IN_MONTH;
				break;
			case DateFormat.WEEK_OF_YEAR_FIELD:
				dateFormatField = DateFormat.Field.WEEK_OF_YEAR;
				field = ILOG.J2CsMapping.Util.Calendar.WEEK_OF_YEAR;
				break;
			case DateFormat.WEEK_OF_MONTH_FIELD:
				dateFormatField = DateFormat.Field.WEEK_OF_MONTH;
				field = ILOG.J2CsMapping.Util.Calendar.WEEK_OF_MONTH;
				break;
			case DateFormat.AM_PM_FIELD:
				dateFormatField = DateFormat.Field.AM_PM;
				buffer.Append(formatData.ampms[calendar.Get(ILOG.J2CsMapping.Util.Calendar.AM_PM)]);
				break;
			case DateFormat.HOUR1_FIELD: // h
				dateFormatField = DateFormat.Field.HOUR1;
				hour = calendar.Get(ILOG.J2CsMapping.Util.Calendar.HOUR);
				AppendNumber(buffer, count, (hour == 0) ? 12 : hour);
				break;
			case DateFormat.HOUR0_FIELD: // K
				dateFormatField = DateFormat.Field.HOUR0;
				field = ILOG.J2CsMapping.Util.Calendar.HOUR;
				break;
			case DateFormat.TIMEZONE_FIELD: // z
				dateFormatField = DateFormat.Field.TIME_ZONE;
				AppendTimeZone(buffer, count, true);
				break;
			case IBM.ICU.Text.DateFormat.TIMEZONE_RFC_FIELD: // Z
				dateFormatField = DateFormat.Field.TIME_ZONE;
				AppendTimeZone(buffer, count, false);
				break;
			}
			if (field != -1) {
				AppendNumber(buffer, count, calendar.Get(field));
			}
	
			if (fields != null) {
				position = new FieldPosition(dateFormatField);
				position.SetBeginIndex(beginPosition);
				position.SetEndIndex(buffer.Length);
				fields.Add(position);
			} else {
				// Set to the first occurrence
				if (((Object) position.GetFieldAttribute() == (Object) dateFormatField || (position
						.GetFieldAttribute() == null && position.GetField() == index))
						&& position.GetEndIndex() == 0) {
					position.SetBeginIndex(beginPosition);
					position.SetEndIndex(buffer.Length);
				}
			}
		}
	
		private void AppendTimeZone(StringBuilder buffer, int count,
				bool generalTimezone) {
			// cannot call TimeZone.getDisplayName() because it would not use
			// the DateFormatSymbols of this SimpleDateFormat
	
			if (generalTimezone) {
				String id = calendar.GetTimeZone().GetID();
				String[][] zones = formatData.zoneStrings;
				String[] zone = null;
				/* foreach */
				foreach (String[] element  in  zones) {
					if (id.Equals(element[0])) {
						zone = element;
						break;
					}
				}
				if (zone == null) {
					int offset = calendar.Get(ILOG.J2CsMapping.Util.Calendar.ZONE_OFFSET)
							+ calendar.Get(ILOG.J2CsMapping.Util.Calendar.DST_OFFSET);
					char sign = '+';
					if (offset < 0) {
						sign = '-';
						offset = -offset;
					}
					buffer.Append("GMT"); //$NON-NLS-1$
					buffer.Append(sign);
					AppendNumber(buffer, 2, offset / 3600000);
					buffer.Append(':');
					AppendNumber(buffer, 2, (offset % 3600000) / 60000);
				} else {
					int daylight = (calendar.Get(ILOG.J2CsMapping.Util.Calendar.DST_OFFSET) == 0) ? 0 : 2;
					if (count < 4) {
						buffer.Append(zone[2 + daylight]);
					} else {
						buffer.Append(zone[1 + daylight]);
					}
				}
			} else {
				int offset_0 = calendar.Get(ILOG.J2CsMapping.Util.Calendar.ZONE_OFFSET)
						+ calendar.Get(ILOG.J2CsMapping.Util.Calendar.DST_OFFSET);
				char sign_1 = '+';
				if (offset_0 < 0) {
					sign_1 = '-';
					offset_0 = -offset_0;
				}
				buffer.Append(sign_1);
				AppendNumber(buffer, 2, offset_0 / 3600000);
				AppendNumber(buffer, 2, (offset_0 % 3600000) / 60000);
			}
		}
	
		private void AppendNumber(StringBuilder buffer, int count, int value_ren) {
			int minimumIntegerDigits = numberFormat.GetMinimumIntegerDigits();
			numberFormat.SetMinimumIntegerDigits(count);
			numberFormat.Format(((int)(value_ren)), buffer, new FieldPosition(0));
			numberFormat.SetMinimumIntegerDigits(minimumIntegerDigits);
		}
	
		/// <summary>
		/// Formats the specified Date into the specified StringBuffer using the
		/// pattern of this SimpleDateFormat. If the field specified by the
		/// FieldPosition is formatted, set the begin and end index of the formatted
		/// field in the FieldPosition.
		/// </summary>
		///
		/// <param name="date">the Date to format</param>
		/// <param name="buffer">the StringBuffer</param>
		/// <param name="field">the FieldPosition</param>
		/// <returns>the StringBuffer parameter <c>buffer</c></returns>
		/// <exception cref="IllegalArgumentException">when there are invalid characters in the pattern</exception>
		public override StringBuilder Format(DateTime date, StringBuilder buffer,
				FieldPosition field) {
			icuFormat.SetTimeZone(IBM.ICU.Util.TimeZone.GetTimeZone(calendar
					.GetTimeZone().GetID()));
			return icuFormat.Format(date, buffer, field);
		}
	
		/// <summary>
		/// Answers the Date which is the start of the one hundred year period for
		/// two digits year values.
		/// </summary>
		///
		/// <returns>a Date</returns>
		public DateTime Get2DigitYearStart() {
			return defaultCenturyStart;
		}
	
		/// <summary>
		/// Answers the DateFormatSymbols used by this SimpleDateFormat.
		/// </summary>
		///
		/// <returns>a DateFormatSymbols</returns>
		public DateFormatSymbols GetDateFormatSymbols() {
			// Return a clone so the arrays in the ResourceBundle are not modified
			return (DateFormatSymbols) formatData.Clone();
		}
	
		/// <summary>
		/// Answers an integer hash code for the receiver. Objects which are equal
		/// answer the same value for this method.
		/// </summary>
		///
		/// <returns>the receiver's hash</returns>
		/// <seealso cref="M:ILOG.J2CsMapping.Text.SimpleDateFormat.Equals(System.Object)"/>
		public override int GetHashCode() {
			return base.GetHashCode() + pattern.GetHashCode() + formatData.GetHashCode()
					+ creationYear;
		}
	
		/// <summary>
		/// Parse a Date from the specified String starting at the index specified by
		/// the ParsePosition. If the string is successfully parsed, the index of the
		/// ParsePosition is updated to the index following the parsed text.
		/// </summary>
		///
		/// <param name="string">the String to parse according to the pattern of thisSimpleDateFormat</param>
		/// <param name="position">the ParsePosition, updated on return with the index followingthe parsed text, or on error the index is unchanged and theerror index is set to the index where the error occurred</param>
		/// <returns>the Date resulting from the parse, or null if there is an error</returns>
		/// <exception cref="IllegalArgumentException">when there are invalid characters in the pattern</exception>
		public override DateTime Parse(String str0, ParsePosition position) {
            icuFormat.SetTimeZone(IBM.ICU.Util.TimeZone.GetTimeZone(calendar
					.GetTimeZone().GetID()));
			return icuFormat.Parse(str0, position);
		}
	
		/// <summary>
		/// Sets the Date which is the start of the one hundred year period for two
		/// digits year values.
		/// </summary>
		///
		/// <param name="date">the Date</param>
		public void Set2DigitYearStart(DateTime date) {
			icuFormat.Set2DigitYearStart(date);
			defaultCenturyStart = date;
			IBM.ICU.Util.Calendar cal = new IBM.ICU.Util.GregorianCalendar();
			cal.SetTime(date);
			creationYear = cal.Get(ILOG.J2CsMapping.Util.Calendar.YEAR);
		}
	
		/// <summary>
		/// Sets the DateFormatSymbols used by this SimpleDateFormat.
		/// </summary>
		///
		/// <param name="value">the DateFormatSymbols</param>
		public void SetDateFormatSymbols(DateFormatSymbols value_ren) {
            IBM.ICU.Text.DateFormatSymbols icuSymbols = new IBM.ICU.Text.DateFormatSymbols();
			CopySymbols(value_ren, icuSymbols);
			icuFormat.SetDateFormatSymbols(icuSymbols);
			formatData = (DateFormatSymbols) value_ren.Clone();
		}
	
		/// <summary>
		/// Answers the pattern of this SimpleDateFormat using localized pattern
		/// characters.
		/// </summary>
		///
		/// <returns>the localized pattern</returns>
		public String ToLocalizedPattern() {
			return icuFormat.ToLocalizedPattern();
		}
	
		/// <summary>
		/// Answers the pattern of this SimpleDateFormat using non-localized pattern
		/// characters.
		/// </summary>
		///
		/// <returns>the non-localized pattern</returns>
		public String ToPattern() {
			return pattern;
		}
	
		/*private static readonly ObjectStreamField[] serialPersistentFields = {
				new ObjectStreamField("defaultCenturyStart", typeof(DateTime)), //$NON-NLS-1$
				new ObjectStreamField("formatData", typeof(DateFormatSymbols)), //$NON-NLS-1$
				new ObjectStreamField("pattern", typeof(String)), //$NON-NLS-1$
				new ObjectStreamField("serialVersionOnStream", typeof(Int32)), }; //$NON-NLS-1$*/
	
		private void WriteObject(IlObjectOutputStream stream) {
			/*ObjectOutputStream.PutField fields = stream.PutFields();
			fields.Put("defaultCenturyStart", defaultCenturyStart); //$NON-NLS-1$
			fields.Put("formatData", formatData); //$NON-NLS-1$
			fields.Put("pattern", pattern); //$NON-NLS-1$
			fields.Put("serialVersionOnStream", 1); //$NON-NLS-1$
			stream.WriteFields();*/
		}
	
		private void ReadObject(IlObjectInputStream stream) {
			/*ObjectInputStream.GetField fields = stream.ReadFields();
			int version = fields.Get("serialVersionOnStream", 0); //$NON-NLS-1$
			DateTime date;
			if (version > 0) {
				date = (DateTime) fields.Get("defaultCenturyStart", DateTime.Now); //$NON-NLS-1$
			} else {
				date = DateTime.Now;
			}
			Set2DigitYearStart(date);
			formatData = (DateFormatSymbols) fields.Get("formatData", null); //$NON-NLS-1$
			pattern = (String) fields.Get("pattern", ""); //$NON-NLS-1$ //$NON-NLS-2$*/
		}
	}
}
