/*
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101221_01     
// 1/4/11 10:26 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace ILOG.J2CsMapping.IO {
	
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	
	/// <summary>
	/// FilterReader is a class which takes a Reader and <em>filters</em> the input
	/// in some way. The filtered view may be a buffered view or one which
	/// uncompresses data before returning characters read.
	/// </summary>
	///
	/// <seealso cref="T:ILOG.J2CsMapping.IO.IlFilterWriter"/>
	public abstract class FilterReader : TextReader {
	
		/// <summary>
		/// The target Reader which is being filtered.
		/// </summary>
		///
		protected internal TextReader ins0;
	
		/// <summary>
		/// Constructs a new FilterReader on the Reader <c>in</c>. All reads
		/// are now filtered through this Reader.
		/// </summary>
		///
		/// <param name="in">The non-null Reader to filter reads on.</param>
		protected internal FilterReader(TextReader ins0) : base() {
			this.ins0 = ins0;
		}
	
		/// <summary>
		/// Close this FilterReader. This implementation closes the target Reader.
		/// </summary>
		///
		/// <exception cref="IOException">If an error occurs attempting to close this Reader.</exception>
		public override void Close() {
			 lock (this) {
						ins0.Close();
					}
		}
	
		/// <summary>
		/// Set a Mark position in this FilterReader. The parameter
		/// <c>readLimit</c> indicates how many characters can be read before
		/// a mark is invalidated. Sending reset() will reposition the Reader back to
		/// the marked position provided <c>readLimit</c> has not been
		/// surpassed.
		/// <p>
		/// This implementation sets a mark in the target Reader.
		/// </summary>
		///
		/// <param name="readlimit">the number of characters to be able to read beforeinvalidating the mark.</param>
		/// <exception cref="IOException">If an error occurs attempting mark this Reader.</exception>
		[MethodImpl(MethodImplOptions.Synchronized)]
        public virtual void Mark(int readlimit)
        {
            throw new NotImplementedException();
			/* lock (this) {
						ins0.Mark(readlimit);
					}*/
		}
	
		/// <summary>
		/// Answers a boolean indicating whether or not this FilterReader supports
		/// mark() and reset(). This implementation answers whether or not the target
		/// Reader supports marking.
		/// </summary>
		///
		/// <returns>indicates whether or not mark() and reset() are supported.</returns>
        public virtual bool MarkSupported()
        {
            throw new NotImplementedException();
            /*
			 lock (this) {
						return ins0.MarkSupported();
					}*/
		}
	
		/// <summary>
		/// Reads a single char from this FilterReader and returns the result as an
		/// int. The 2 lowest order bytes are returned or -1 of the end of reader was
		/// encountered. This implementation returns a char from the target Reader.
		/// </summary>
		///
		/// <returns>The byte read or -1 if end of reader.</returns>
		/// <exception cref="IOException">If an error occurs attempting to read from this Reader.</exception>
		public override int Read() {
			 lock (this) {
						return ins0.Read();
					}
		}
	
		/// <summary>
		/// Reads at most <c>count</c> chars from this FilterReader and
		/// stores them in char array <c>buffer</c> starting at offset
		/// <c>offset</c>. Answer the number of chars actually read or -1 if
		/// no chars were read and end of reader was encountered. This implementation
		/// reads chars from the target reader.
		/// </summary>
		///
		/// <param name="buffer">the char array in which to store the read chars.</param>
		/// <param name="offset">the offset in <c>buffer</c> to store the read chars.</param>
		/// <param name="count">the maximum number of chars to store in <c>buffer</c>.</param>
		/// <returns>the number of chars actually read or -1 if end of reader.</returns>
		/// <exception cref="IOException">If an error occurs attempting to read from this Reader.</exception>
		public override int Read(char[] buffer, int offset, int count) {
			 lock (this) {
						return ins0.Read(buffer, offset, count);
					}
		}
	
		/// <summary>
		/// Answers a <c>boolean</c> indicating whether or not this Reader is
		/// ready to be read without blocking. If the result is <c>true</c>,
		/// the next <c>read()</c> will not block. If the result is
		/// <c>false</c> this Reader may or may not block when
		/// <c>read()</c> is sent.
		/// </summary>
		///
		/// <returns><c>true</c> if the receiver will not block when
		/// <c>read()</c> is called, <c>false</c> if unknown
		/// or blocking will occur.</returns>
		/// <exception cref="IOException">If the Reader is already closed or some other IO erroroccurs.</exception>
		public virtual bool Ready() {
            throw new NotImplementedException();
            /*
			 lock (this) {
                 return ins0.Ready();
					}*/
		}
	
		/// <summary>
		/// Reset this Readers position to the last <c>mark()</c> location.
		/// Invocations of <code>read()/skip()</code> will occur from this new
		/// location. If this Reader was not marked, the implementation of
		/// <c>reset()</c> is implementation specific. See the comment for
		/// the specific Reader subclass for implementation details. The default
		/// action is to throw <c>IOException</c>.
		/// </summary>
		///
		/// <exception cref="IOException">if a problem occurred or the target Reader does not support<code>mark()/reset()</code>.</exception>
        public virtual void Reset()
        {
            throw new NotImplementedException();
            /*
			 lock (this) {
                 ins0.Reset();
					}*/
		}
	
		/// <summary>
		/// Skips <c>count</c> number of characters in this Reader.
		/// Subsequent <c>read()</c>'s will not return these characters
		/// unless <c>reset()</c> is used. The default implementation is to
		/// skip chars in the filtered Reader.
		/// </summary>
		///
		/// <param name="count">the maximum number of characters to skip.</param>
		/// <returns>the number of characters actually skipped.</returns>
		/// <exception cref="IOException">If the Reader is already closed or some other IO erroroccurs.</exception>
        public virtual long Skip(long count)
        {
            throw new NotImplementedException();
            /*
			 lock (this) {
						return ins0.Skip(count);
					}*/
		}
	}
}
