//
//    Copyright (C) 2002-2007, International Business Machines Corporation and others.
//    All Rights Reserved.
//
//

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:30 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Text {
	
	using ILOG.J2CsMapping.IO;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	
	internal class RBBIRuleBuilder {
	    // This is the main class for building (compiling) break rules into the
	    // tables
	    // required by the runtime RBBI engine.
	    //
	
	    internal String fDebugEnv; // controls debug trace output
	
	    internal String fRules; // The rule string that we are compiling
	
	    internal RBBIRuleScanner fScanner; // The scanner.
	
	    //
	    // There are four separate parse trees generated, one for each of the
	    // forward rules, reverse rules, safe forward rules and safe reverse rules.
	    // This array references the root of each of the trees.
	    //
	    internal RBBINode[] fTreeRoots;
	
	    internal const int fForwardTree = 0; // Indexes into the above fTreeRoots
	                                       // array
	
	    internal const int fReverseTree = 1; // for each of the trees.
	
	    internal const int fSafeFwdTree = 2; // (in C, these are pointer variables and
	
	    internal const int fSafeRevTree = 3; // there is no array.)
	
	    internal int fDefaultTree; // For rules not qualified with a !
	                                     // the tree to which they belong to.
	
	    internal bool fChainRules; // True for chained Unicode TR style rules.
	                         // False for traditional regexp rules.
	
	    internal bool fLBCMNoChain; // True: suppress chaining of rules on
	                          // chars with LineBreak property == CM.
	
	    internal bool fLookAheadHardBreak; // True: Look ahead matches cause an
	                                 // immediate break, no continuing for the
	                                 // longest match.
	
	    internal RBBISetBuilder fSetBuilder; // Set and Character Category builder.
	
	    internal IList fUSetNodes; // Vector of all uset nodes.
	
	    internal RBBITableBuilder fForwardTables; // State transition tables
	
	    internal RBBITableBuilder fReverseTables;
	
	    internal RBBITableBuilder fSafeFwdTables;
	
	    internal RBBITableBuilder fSafeRevTables;
	
	    //
	    // Status {tag} values. These structures are common to all of the rule sets
	    // (Forward, Reverse, etc.).
	    //
	    internal IDictionary fStatusSets; // Status value sets encountered so far.
	                                     // Map Key is the set of values.
	                                     // Map Value is the runtime array index.
	
	    internal IList fRuleStatusVals; // List of Integer objects. Has same layout as the
	                          // runtime array of status (tag) values -
	                          // number of values in group 1
	                          // first status value in group 1
	                          // 2nd status value in group 1
	                          // ...
	                          // number of values in group 2
	                          // first status value in group 2
	                          // etc.
	                          //
	
	    // Error codes from ICU4C.
	    // using these simplified the porting, and consolidated the
	    // creation of Java exceptions
	    //
	    internal const int U_BRK_ERROR_START = 0x10200;
	
	    /// <summary>
	    /// < Start of codes indicating Break Iterator failures 
	    /// </summary>
	    ///
	
	    internal const int U_BRK_INTERNAL_ERROR = 0x10201;
	
	    /// <summary>
	    /// < An internal error (bug) was detected. 
	    /// </summary>
	    ///
	
	    internal const int U_BRK_HEX_DIGITS_EXPECTED = 0x10202;
	
	    /// <summary>
	    /// < Hex digits expected as part of a escaped char in a rule. 
	    /// </summary>
	    ///
	
	    internal const int U_BRK_SEMICOLON_EXPECTED = 0x10203;
	
	    /// <summary>
	    /// < Missing ';' at the end of a RBBI rule. 
	    /// </summary>
	    ///
	
	    internal const int U_BRK_RULE_SYNTAX = 0x10204;
	
	    /// <summary>
	    /// < Syntax error in RBBI rule. 
	    /// </summary>
	    ///
	
	    internal const int U_BRK_UNCLOSED_SET = 0x10205;
	
	    /// <summary>
	    /// < UnicodeSet witing an RBBI rule missing a closing ']'. 
	    /// </summary>
	    ///
	
	    internal const int U_BRK_ASSIGN_ERROR = 0x10206;
	
	    /// <summary>
	    /// < Syntax error in RBBI rule assignment statement. 
	    /// </summary>
	    ///
	
	    internal const int U_BRK_VARIABLE_REDFINITION = 0x10207;
	
	    /// <summary>
	    /// < RBBI rule $Variable redefined. 
	    /// </summary>
	    ///
	
	    internal const int U_BRK_MISMATCHED_PAREN = 0x10208;
	
	    /// <summary>
	    /// < Mis-matched parentheses in an RBBI rule. 
	    /// </summary>
	    ///
	
	    internal const int U_BRK_NEW_LINE_IN_QUOTED_STRING = 0x10209;
	
	    /// <summary>
	    /// < Missing closing quote in an RBBI rule. 
	    /// </summary>
	    ///
	
	    internal const int U_BRK_UNDEFINED_VARIABLE = 0x1020a;
	
	    /// <summary>
	    /// < Use of an undefined $Variable in an RBBI rule. 
	    /// </summary>
	    ///
	
	    internal const int U_BRK_INIT_ERROR = 0x1020b;
	
	    /// <summary>
	    /// < Initialization failure. Probable missing ICU Data. 
	    /// </summary>
	    ///
	
	    internal const int U_BRK_RULE_EMPTY_SET = 0x1020c;
	
	    /// <summary>
	    /// < Rule contains an empty Unicode Set. 
	    /// </summary>
	    ///
	
	    internal const int U_BRK_UNRECOGNIZED_OPTION = 0x1020d;
	
	    /// <summary>
	    /// < !!option in RBBI rules not recognized. 
	    /// </summary>
	    ///
	
	    internal const int U_BRK_MALFORMED_RULE_TAG = 0x1020e;
	
	    /// <summary>
	    /// < The {nnn} tag on a rule is mal formed 
	    /// </summary>
	    ///
	    internal const int U_BRK_MALFORMED_SET = 0x1020f;
	
	    internal const int U_BRK_ERROR_LIMIT = 0x10210;
	
	    /// <summary>
	    /// < This must always be the last value to indicate the limit for Break
	    /// Iterator failures
	    /// </summary>
	    ///
	
	    internal // ----------------------------------------------------------------------------------------
	    //
	    // Constructor.
	    //
	    // ----------------------------------------------------------------------------------------
	    RBBIRuleBuilder(String rules) {
	        this.fTreeRoots = new RBBINode[4];
	        this.fDefaultTree = fForwardTree;
	        this.fStatusSets = new Hashtable();
	        fDebugEnv = (IBM.ICU.Impl.ICUDebug.Enabled("rbbi")) ? IBM.ICU.Impl.ICUDebug.Value("rbbi") : null;
	        fRules = rules;
	        fUSetNodes = new ArrayList();
	        fRuleStatusVals = new ArrayList();
	        fScanner = new RBBIRuleScanner(this);
	        fSetBuilder = new RBBISetBuilder(this);
	    }
	
	    // ----------------------------------------------------------------------------------------
	    //
	    // flattenData() - Collect up the compiled RBBI rule data and put it into
	    // the format for saving in ICU data files,
	    //
	    // See the ICU4C file common/rbidata.h for a detailed description.
	    //
	    // ----------------------------------------------------------------------------------------
	    static internal int Align8(int i) {
	        return (i + 7) & -8;
	    }
	
	    internal void FlattenData(Stream os) {
	        DataOutputStream dos = new DataOutputStream(os);
	        int i;
	
	        // Remove comments and whitespace from the rules to make it smaller.
	        String strippedRules = IBM.ICU.Text.RBBIRuleScanner.StripRules(fRules);
	
	        // Calculate the size of each section in the data in bytes.
	        // Sizes here are padded up to a multiple of 8 for better memory
	        // alignment.
	        // Sections sizes actually stored in the header are for the actual data
	        // without the padding.
	        //
	        int headerSize = 24 * 4; // align8(sizeof(RBBIDataHeader));
	        int forwardTableSize = Align8(fForwardTables.GetTableSize());
	        int reverseTableSize = Align8(fReverseTables.GetTableSize());
	        int safeFwdTableSize = Align8(fSafeFwdTables.GetTableSize());
	        int safeRevTableSize = Align8(fSafeRevTables.GetTableSize());
	        int trieSize = Align8(fSetBuilder.GetTrieSize());
	        int statusTableSize = Align8(fRuleStatusVals.Count * 4);
	        int rulesSize = Align8((strippedRules.Length) * 2);
	        int totalSize = headerSize + forwardTableSize + reverseTableSize
	                + safeFwdTableSize + safeRevTableSize + statusTableSize
	                + trieSize + rulesSize;
	        int outputPos = 0; // Track stream position, starting from
	                           // RBBIDataHeader.
	
	        //
	        // Write out an ICU Data Header
	        // TODO: actually create a real header, rather than just a placeholder.
	        // The empty placeholder is ok for compile-and-go from within ICU4J.
	        // Replicating the ICU4C genbrk tool for building .brk resources would
	        // need a real header.
	        //
	        byte[] ICUDataHeader = new byte[0x80];
	        dos.Write(ICUDataHeader,0,ICUDataHeader.Length);
	
	        //
	        // Write out the RBBIDataHeader
	        //
	        int[] header = new int[IBM.ICU.Text.RBBIDataWrapper.DH_SIZE]; // sizeof struct
	                                                         // RBBIDataHeader
	        header[IBM.ICU.Text.RBBIDataWrapper.DH_MAGIC] = 0xb1a0;
	        header[IBM.ICU.Text.RBBIDataWrapper.DH_FORMATVERSION] = 0x03010000; // uint8_t
	                                                               // fFormatVersion[4];
	        header[IBM.ICU.Text.RBBIDataWrapper.DH_LENGTH] = totalSize; // fLength, the total
	                                                       // size of all rule
	                                                       // sections.
	        header[IBM.ICU.Text.RBBIDataWrapper.DH_CATCOUNT] = fSetBuilder
	                .GetNumCharCategories(); // fCatCount.
	        header[IBM.ICU.Text.RBBIDataWrapper.DH_FTABLE] = headerSize; // fFTable
	        header[IBM.ICU.Text.RBBIDataWrapper.DH_FTABLELEN] = forwardTableSize; // fTableLen
	        header[IBM.ICU.Text.RBBIDataWrapper.DH_RTABLE] = header[IBM.ICU.Text.RBBIDataWrapper.DH_FTABLE]
	                + forwardTableSize; // fRTable
	        header[IBM.ICU.Text.RBBIDataWrapper.DH_RTABLELEN] = reverseTableSize; // fRTableLen
	        header[IBM.ICU.Text.RBBIDataWrapper.DH_SFTABLE] = header[IBM.ICU.Text.RBBIDataWrapper.DH_RTABLE]
	                + reverseTableSize; // fSTable
	        header[IBM.ICU.Text.RBBIDataWrapper.DH_SFTABLELEN] = safeFwdTableSize; // fSTableLen
	        header[IBM.ICU.Text.RBBIDataWrapper.DH_SRTABLE] = header[IBM.ICU.Text.RBBIDataWrapper.DH_SFTABLE]
	                + safeFwdTableSize; // fSRTable
	        header[IBM.ICU.Text.RBBIDataWrapper.DH_SRTABLELEN] = safeRevTableSize; // fSRTableLen
	        header[IBM.ICU.Text.RBBIDataWrapper.DH_TRIE] = header[IBM.ICU.Text.RBBIDataWrapper.DH_SRTABLE]
	                + safeRevTableSize; // fTrie
	        header[IBM.ICU.Text.RBBIDataWrapper.DH_TRIELEN] = fSetBuilder.GetTrieSize(); // fTrieLen
	        header[IBM.ICU.Text.RBBIDataWrapper.DH_STATUSTABLE] = header[IBM.ICU.Text.RBBIDataWrapper.DH_TRIE]
	                + header[IBM.ICU.Text.RBBIDataWrapper.DH_TRIELEN];
	        header[IBM.ICU.Text.RBBIDataWrapper.DH_STATUSTABLELEN] = statusTableSize; // fStatusTableLen
	        header[IBM.ICU.Text.RBBIDataWrapper.DH_RULESOURCE] = header[IBM.ICU.Text.RBBIDataWrapper.DH_STATUSTABLE]
	                + statusTableSize;
	        header[IBM.ICU.Text.RBBIDataWrapper.DH_RULESOURCELEN] = strippedRules.Length * 2;
	        for (i = 0; i < header.Length; i++) {
	            dos.WriteInt(header[i]);
	            outputPos += 4;
	        }
	
	        // Write out the actual state tables.
	        short[] tableData;
	        tableData = fForwardTables.ExportTable();
	        IBM.ICU.Impl.Assert.Assrt(outputPos == header[4]);
	        for (i = 0; i < tableData.Length; i++) {
	            dos.WriteShort(tableData[i]);
	            outputPos += 2;
	        }
	
	        tableData = fReverseTables.ExportTable();
	        IBM.ICU.Impl.Assert.Assrt(outputPos == header[6]);
	        for (i = 0; i < tableData.Length; i++) {
	            dos.WriteShort(tableData[i]);
	            outputPos += 2;
	        }
	
	        IBM.ICU.Impl.Assert.Assrt(outputPos == header[8]);
	        tableData = fSafeFwdTables.ExportTable();
	        for (i = 0; i < tableData.Length; i++) {
	            dos.WriteShort(tableData[i]);
	            outputPos += 2;
	        }
	
	        IBM.ICU.Impl.Assert.Assrt(outputPos == header[10]);
	        tableData = fSafeRevTables.ExportTable();
	        for (i = 0; i < tableData.Length; i++) {
	            dos.WriteShort(tableData[i]);
	            outputPos += 2;
	        }
	
	        // write out the Trie table
	        IBM.ICU.Impl.Assert.Assrt(outputPos == header[12]);
	        fSetBuilder.SerializeTrie(os);
	        outputPos += header[13];
	        while (outputPos % 8 != 0) { // pad to an 8 byte boundary
	            dos.WriteByte((byte)0);
	            outputPos += 1;
	        }
	
	        // Write out the status {tag} table.
	        IBM.ICU.Impl.Assert.Assrt(outputPos == header[16]);
	        for (i = 0; i < fRuleStatusVals.Count; i++) {
	            Int32 val = (Int32) fRuleStatusVals[i];
	            dos.WriteInt(val);
	            outputPos += 4;
	        }
	
	        while (outputPos % 8 != 0) { // pad to an 8 byte boundary
	            dos.WriteByte((byte)0);
	            outputPos += 1;
	        }
	
	        // Write out the stripped rules (rules with extra spaces removed
	        // These go last in the data area, even though they are not last in the
	        // header.
	        IBM.ICU.Impl.Assert.Assrt(outputPos == header[14]);
	        dos.WriteChars(strippedRules);
	        outputPos += strippedRules.Length * 2;
	        while (outputPos % 8 != 0) { // pad to an 8 byte boundary
	            dos.WriteByte((byte)0);
	            outputPos += 1;
	        }
	    }
	
	    // ----------------------------------------------------------------------------------------
	    //
	    // compileRules compile source rules, placing the compiled form into a
	    // output stream
	    // The compiled form is identical to that from ICU4C (Big Endian).
	    //
	    // ----------------------------------------------------------------------------------------
	    static internal void CompileRules(String rules, Stream os) {
	        //
	        // Read the input rules, generate a parse tree, symbol table,
	        // and list of all Unicode Sets referenced by the rules.
	        //
	        RBBIRuleBuilder builder = new RBBIRuleBuilder(rules);
	        builder.fScanner.Parse();
	
	        //
	        // UnicodeSet processing.
	        // Munge the Unicode Sets to create a set of character categories.
	        // Generate the mapping tables (TRIE) from input 32-bit characters to
	        // the character categories.
	        //
	        builder.fSetBuilder.Build();
	
	        //
	        // Generate the DFA state transition table.
	        //
	        builder.fForwardTables = new RBBITableBuilder(builder, fForwardTree);
	        builder.fReverseTables = new RBBITableBuilder(builder, fReverseTree);
	        builder.fSafeFwdTables = new RBBITableBuilder(builder, fSafeFwdTree);
	        builder.fSafeRevTables = new RBBITableBuilder(builder, fSafeRevTree);
	        builder.fForwardTables.Build();
	        builder.fReverseTables.Build();
	        builder.fSafeFwdTables.Build();
	        builder.fSafeRevTables.Build();
	        if (builder.fDebugEnv != null
	                && builder.fDebugEnv.IndexOf("states") >= 0) {
	            builder.fForwardTables.PrintRuleStatusTable();
	        }
	
	        //
	        // Package up the compiled data, writing it to an output stream
	        // in the serialization format. This is the same as the ICU4C runtime
	        // format.
	        //
	        builder.FlattenData(os);
	    }
	}
}
