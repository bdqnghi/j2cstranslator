// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/13/10 4:01 PM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 1996-2007, International Business Machines Corporation and    
/// others. All Rights Reserved.                                                
/// </summary>
///
namespace IBM.ICU.Charset {
	
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	
	/// <summary>
	/// VERY Basic Diff program. Compares two sequences of objects fed into it, and
	/// lets you know where they are different.
	/// </summary>
	///
	
	public sealed class Differ {
	    // public static final String copyright =
	    // "Copyright (C) 2000, International Business Machines Corporation and others. All Rights Reserved.";
	
	    
	    /// <param name="stackSize">The size of the largest difference you expect.</param>
	    /// <param name="matchCount">The number of items that have to be the same to count as amatch</param>
	    public Differ(int stackSize, int matchCount) {
	        this.last = "";
	        this.next = "";
	        this.aCount = 0;
	        this.bCount = 0;
	        this.aLine = 1;
	        this.bLine = 1;
	        this.maxSame = 0;
	        this.aTop = 0;
	        this.bTop = 0;
	        this.STACKSIZE = stackSize;
	        this.EQUALSIZE = matchCount;
	        a = new Object[stackSize + matchCount];
	        b = new Object[stackSize + matchCount];
	    }
	
	    public void Add(Object aStr, Object bStr) {
	        AddA(aStr);
	        AddB(bStr);
	    }
	
	    public void AddA(Object aStr) {
	        Flush();
	        a[aCount++] = aStr;
	    }
	
	    public void AddB(Object bStr) {
	        Flush();
	        b[bCount++] = bStr;
	    }
	
	    public int GetALine(int offset) {
	        return aLine + maxSame + offset;
	    }
	
	    public Object GetA(int offset) {
	        if (offset < 0)
	            return last;
	        if (offset > aTop - maxSame)
	            return next;
	        return a[offset];
	    }
	
	    public int GetACount() {
	        return aTop - maxSame;
	    }
	
	    public int GetBCount() {
	        return bTop - maxSame;
	    }
	
	    public int GetBLine(int offset) {
	        return bLine + maxSame + offset;
	    }
	
	    public Object GetB(int offset) {
	        if (offset < 0)
	            return last;
	        if (offset > bTop - maxSame)
	            return next;
	        return b[offset];
	    }
	
	    public void CheckMatch(bool finalPass) {
	        // find the initial strings that are the same
	        int max = aCount;
	        if (max > bCount)
	            max = bCount;
	        int i;
	        for (i = 0; i < max; ++i) {
	            if (!a[i].Equals(b[i]))
	                break;
	        }
	        // at this point, all items up to i are equal
	        maxSame = i;
	        aTop = bTop = maxSame;
	        if (maxSame > 0)
	            last = a[maxSame - 1];
	        next = "";
	
	        if (finalPass) {
	            aTop = aCount;
	            bTop = bCount;
	            next = "";
	            return;
	        }
	
	        if (aCount - maxSame < EQUALSIZE || bCount - maxSame < EQUALSIZE)
	            return;
	
	        // now see if the last few a's occur anywhere in the b's, or vice versa
	        int match = Find(a, aCount - EQUALSIZE, aCount, b, maxSame, bCount);
	        if (match != -1) {
	            aTop = aCount - EQUALSIZE;
	            bTop = match;
	            next = a[aTop];
	            return;
	        }
	        match = Find(b, bCount - EQUALSIZE, bCount, a, maxSame, aCount);
	        if (match != -1) {
	            bTop = bCount - EQUALSIZE;
	            aTop = match;
	            next = b[bTop];
	            return;
	        }
	        if (aCount >= STACKSIZE || bCount >= STACKSIZE) {
	            // flush some of them
	            aCount = (aCount + maxSame) / 2;
	            bCount = (bCount + maxSame) / 2;
	            next = "";
	        }
	    }
	
	    /// <summary>
	    /// Convenient utility finds a segment of the first array in the second
	    /// array.
	    /// </summary>
	    ///
	    /// <returns>-1 if not found, otherwise start position in b</returns>
	
	    public int Find(Object[] aArr, int aStart, int aEnd, Object[] bArr,
	            int bStart, int bEnd) {
	        int len = aEnd - aStart;
	        int bEndMinus = bEnd - len;
	        tryA: {
	            for (int i = bStart; i <= bEndMinus; ++i) {
	                for (int j = 0; j < len; ++j) {
	                    if (!bArr[i + j].Equals(aArr[aStart + j]))
	                        goto tryA;
	                }
	                return i; // we have a match!
	            }
	        }
	        gototryA:
	        ;
	        return -1;
	    }
	
	    // ====================== PRIVATES ======================
	
	    private void Flush() {
	        if (aTop != 0) {
	            int newCount = aCount - aTop;
	            System.Array.Copy((Array)(a),aTop,(Array)(a),0,newCount);
	            aCount = newCount;
	            aLine += aTop;
	            aTop = 0;
	        }
	
	        if (bTop != 0) {
	            int newCount_0 = bCount - bTop;
	            System.Array.Copy((Array)(b),bTop,(Array)(b),0,newCount_0);
	            bCount = newCount_0;
	            bLine += bTop;
	            bTop = 0;
	        }
	    }
	
	    private int STACKSIZE;
	
	    private int EQUALSIZE;
	
	    private Object[] a;
	
	    private Object[] b;
	
	    private Object last;
	
	    private Object next;
	
	    private int aCount;
	
	    private int bCount;
	
	    private int aLine;
	
	    private int bLine;
	
	    private int maxSame, aTop, bTop;
	
	}
}
