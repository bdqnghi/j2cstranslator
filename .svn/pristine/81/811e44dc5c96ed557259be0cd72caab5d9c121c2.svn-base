/*
 *******************************************************************************
 * Copyright (C) 1996-2004, International Business Machines Corporation and    *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 */
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:47 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Impl {
	
	using ILOG.J2CsMapping.IO;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	
	public sealed class ICUBinary {
	    // public inner interface ------------------------------------------------
	
	    /// <summary>
	    /// Special interface for data authentication
	    /// </summary>
	    ///
	    public interface Authenticate {
	        /// <summary>
	        /// Method used in ICUBinary.readHeader() to provide data format
	        /// authentication.
	        /// </summary>
	        ///
	        /// <param name="version">version of the current data</param>
	        /// <returns>true if dataformat is an acceptable version, false otherwise</returns>
	        bool IsDataVersionAcceptable(byte[] version);
	    }
	
	    // public methods --------------------------------------------------------
	
	    /// <summary>
	    /// <p>
	    /// ICU data header reader method. Takes a ICU generated big-endian input
	    /// stream, parse the ICU standard file header and authenticates them.
	    /// </p>
	    /// <p>
	    /// Header format:
	    /// <ul>
	    /// <li>Header size (char)
	    /// <li>Magic number 1 (byte)
	    /// <li>Magic number 2 (byte)
	    /// <li>Rest of the header size (char)
	    /// <li>Reserved word (char)
	    /// <li>Big endian indicator (byte)
	    /// <li>Character set family indicator (byte)
	    /// <li>Size of a char (byte) for c++ and c use
	    /// <li>Reserved byte (byte)
	    /// <li>Data format identifier (4 bytes), each ICU data has its own
	    /// identifier to distinguish them. [0] major [1] minor [2] milli [3] micro
	    /// <li>Data version (4 bytes), the change version of the ICU data [0] major
	    /// [1] minor [2] milli [3] micro
	    /// <li>Unicode version (4 bytes) this ICU is based on.
	    /// </ul>
	    /// </p>
	    /// <p>
	    /// Example of use:<br>
	    /// <pre>
	    /// try {
	    /// FileInputStream input = new FileInputStream(filename);
	    /// If (Utility.readICUDataHeader(input, dataformat, dataversion, 
	    /// unicode) {
	    /// System.out.println("Verified file header, this is a ICU data file");
	    /// }
	    /// } catch (IOException e) {
	    /// System.out.println("This is not a ICU data file");
	    /// }
	    /// </pre>
	    /// </p>
	    /// </summary>
	    ///
	    /// <param name="inputStream">input stream that contains the ICU data header</param>
	    /// <param name="dataFormatIDExpected">Data format expected. An array of 4 bytes information aboutthe data format. E.g. data format ID 1.2.3.4. will became anarray of {1, 2, 3, 4}</param>
	    /// <param name="authenticate">user defined extra data authentication. This value can benull, if no extra authentication is needed.</param>
	    /// <exception cref="IOException">thrown if there is a read error or when headerauthentication fails.</exception>
	    /// @draft 2.1
	    public static byte[] ReadHeader(Stream inputStream,
	            byte[] dataFormatIDExpected, ICUBinary.Authenticate  authenticate) {
	        DataInputStream input = new DataInputStream(inputStream);
	        char headersize = input.ReadChar();
	        int readcount = 2;
	        // reading the header format
	        byte magic1 = (byte) input.ReadByte();
	        readcount++;
	        byte magic2 = (byte) input.ReadByte();
	        readcount++;
	        if (magic1 != MAGIC1 || magic2 != MAGIC2) {
	            throw new IOException(MAGIC_NUMBER_AUTHENTICATION_FAILED_);
	        }
	
	        input.ReadChar(); // reading size
	        readcount += 2;
	        input.ReadChar(); // reading reserved word
	        readcount += 2;
	        sbyte bigendian = input.ReadByte();
	        readcount++;
	        sbyte charset = input.ReadByte();
	        readcount++;
	        sbyte charsize = input.ReadByte();
	        readcount++;
	        input.ReadByte(); // reading reserved byte
	        readcount++;
	
	        byte[] dataFormatID = new byte[4];
	        input.ReadFully(dataFormatID);
	        readcount += 4;
	        byte[] dataVersion = new byte[4];
	        input.ReadFully(dataVersion);
	        readcount += 4;
	        byte[] unicodeVersion = new byte[4];
	        input.ReadFully(unicodeVersion);
	        readcount += 4;
	        if (headersize < readcount) {
	            throw new IOException("Internal Error: Header size error");
	        }
	        input.SkipBytes(headersize - readcount);
	
	        if (bigendian != BIG_ENDIAN_
	                || charset != CHAR_SET_
	                || charsize != CHAR_SIZE_
	                || !ILOG.J2CsMapping.Collections.Arrays.Equals(dataFormatIDExpected,dataFormatID)
	                || (authenticate != null && !authenticate
	                        .IsDataVersionAcceptable(dataVersion))) {
	            throw new IOException(HEADER_AUTHENTICATION_FAILED_);
	        }
	        return unicodeVersion;
	    }

        public static byte[] ReadHeader(DataInputStream input,
        byte[] dataFormatIDExpected, ICUBinary.Authenticate authenticate)
        {
            char headersize = input.ReadChar();
            int readcount = 2;
            // reading the header format
            byte magic1 = (byte)input.ReadByte();
            readcount++;
            byte magic2 = (byte)input.ReadByte();
            readcount++;
            if (magic1 != MAGIC1 || magic2 != MAGIC2)
            {
                throw new IOException(MAGIC_NUMBER_AUTHENTICATION_FAILED_);
            }

            input.ReadChar(); // reading size
            readcount += 2;
            input.ReadChar(); // reading reserved word
            readcount += 2;
            sbyte bigendian = input.ReadByte();
            readcount++;
            sbyte charset = input.ReadByte();
            readcount++;
            sbyte charsize = input.ReadByte();
            readcount++;
            input.ReadByte(); // reading reserved byte
            readcount++;

            byte[] dataFormatID = new byte[4];
            input.ReadFully(dataFormatID);
            readcount += 4;
            byte[] dataVersion = new byte[4];
            input.ReadFully(dataVersion);
            readcount += 4;
            byte[] unicodeVersion = new byte[4];
            input.ReadFully(unicodeVersion);
            readcount += 4;
            if (headersize < readcount)
            {
                throw new IOException("Internal Error: Header size error");
            }
            input.SkipBytes(headersize - readcount);

            if (bigendian != BIG_ENDIAN_
                    || charset != CHAR_SET_
                    || charsize != CHAR_SIZE_
                    || !ILOG.J2CsMapping.Collections.Arrays.Equals(dataFormatIDExpected, dataFormatID)
                    || (authenticate != null && !authenticate
                            .IsDataVersionAcceptable(dataVersion)))
            {
                throw new IOException(HEADER_AUTHENTICATION_FAILED_);
            }
            return unicodeVersion;
        }

	    // private variables -------------------------------------------------
	
	    /// <summary>
	    /// Magic numbers to authenticate the data file
	    /// </summary>
	    ///
	    private const byte MAGIC1 = (byte) 0xda;
	
	    private const byte MAGIC2 = (byte) 0x27;
	
	    /// <summary>
	    /// File format authentication values
	    /// </summary>
	    ///
	    private const byte BIG_ENDIAN_ = 1;
	
	    private const byte CHAR_SET_ = 0;
	
	    private const byte CHAR_SIZE_ = 2;
	
	    /// <summary>
	    /// Error messages
	    /// </summary>
	    ///
	    private const String MAGIC_NUMBER_AUTHENTICATION_FAILED_ = "ICU data file error: Not an ICU data file";
	
	    private const String HEADER_AUTHENTICATION_FAILED_ = "ICU data file error: Header authentication failed, please check if you have a valid ICU data file";
	}
}
