/*
 * Copyright (C) 1996-2004, International Business Machines Corporation and
 * others. All Rights Reserved.
 */
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:30 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Text {
	
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Text;
	
	
	/// <summary>
	/// A transliterator that performs name to character mapping.
	/// </summary>
	///
	internal class NameUnicodeTransliterator : Transliterator {
	
	    public sealed class Anonymous_C0 : Transliterator.Factory {
	        public Transliterator GetInstance(String ID) {
	            return new NameUnicodeTransliterator(null);
	        }
	    }
	
	    internal char openDelimiter;
	
	    internal char closeDelimiter;
	
	    internal const String _ID = "Name-Any";
	
	    internal const String OPEN_PAT = "\\N~{~";
	
	    internal const char OPEN_DELIM = '\\'; // first char of OPEN_PAT
	
	    internal const char CLOSE_DELIM = '}';
	
	    internal const char SPACE = ' ';
	
	    /// <summary>
	    /// System registration hook.
	    /// </summary>
	    ///
	    static internal void Register() {
	        IBM.ICU.Text.Transliterator.RegisterFactory(_ID, new NameUnicodeTransliterator.Anonymous_C0 ());
	    }
	
	    /// <summary>
	    /// Constructs a transliterator.
	    /// </summary>
	    ///
	    public NameUnicodeTransliterator(UnicodeFilter filter) : base(_ID, filter) {
	    }
	
	    /// <summary>
	    /// Implements <see cref="M:IBM.ICU.Text.Transliterator.HandleTransliterate(IBM.ICU.Text.Replaceable, null, System.Boolean)"/>.
	    /// </summary>
	    ///
	    protected internal override void HandleTransliterate(Replaceable text, Transliterator.Position  offsets,
	            bool isIncremental) {
	
	        int maxLen = IBM.ICU.Impl.UCharacterName.GetInstance().GetMaxCharNameLength() + 1; // allow
	                                                                              // for
	                                                                              // temporary
	                                                                              // trailing
	                                                                              // space
	
	        StringBuilder name = new StringBuilder(maxLen);
	
	        // Get the legal character set
	        UnicodeSet legal = new UnicodeSet();
	        IBM.ICU.Impl.UCharacterName.GetInstance().GetCharNameCharacters(legal);
	
	        int cursor = offsets.start;
	        int limit = offsets.limit;
	
	        // Modes:
	        // 0 - looking for open delimiter
	        // 1 - after open delimiter
	        int mode = 0;
	        int openPos = -1; // open delim candidate pos
	
	        int c;
	        while (cursor < limit) {
	            c = text.Char32At(cursor);
	
	            switch (mode) {
	            case 0: // looking for open delimiter
	                if (c == OPEN_DELIM) { // quick check first
	                    openPos = cursor;
	                    int i = IBM.ICU.Impl.Utility.ParsePattern(OPEN_PAT, text, cursor, limit);
	                    if (i >= 0 && i < limit) {
	                        mode = 1;
	                        name.Length=0;
	                        cursor = i;
	                        continue; // *** reprocess char32At(cursor)
	                    }
	                }
	                break;
	
	            case 1: // after open delimiter
	                // Look for legal chars. If \s+ is found, convert it
	                // to a single space. If closeDelimiter is found, exit
	                // the loop. If any other character is found, exit the
	                // loop. If the limit is reached, exit the loop.
	
	                // Convert \s+ => SPACE. This assumes there are no
	                // runs of >1 space characters in names.
	                if (IBM.ICU.Impl.UCharacterProperty.IsRuleWhiteSpace(c)) {
	                    // Ignore leading whitespace
	                    if (name.Length > 0
	                            && name[name.Length - 1] != SPACE) {
	                        name.Append(SPACE);
	                        // If we are too long then abort. maxLen includes
	                        // temporary trailing space, so use '>'.
	                        if (name.Length > maxLen) {
	                            mode = 0;
	                        }
	                    }
	                    break;
	                }
	
	                if (c == CLOSE_DELIM) {
	
	                    int len = name.Length;
	
	                    // Delete trailing space, if any
	                    if (len > 0 && name[len - 1] == SPACE) {
	                        name.Length=--len;
	                    }
	
	                    c = IBM.ICU.Lang.UCharacter.GetCharFromExtendedName(name.ToString());
	                    if (c != -1) {
	                        // Lookup succeeded
	
	                        // assert(UTF16.getCharCount(CLOSE_DELIM) == 1);
	                        cursor++; // advance over CLOSE_DELIM
	
	                        String str = IBM.ICU.Text.UTF16.ValueOf(c);
	                        text.Replace(openPos, cursor, str);
	
	                        // Adjust indices for the change in the length of
	                        // the string. Do not assume that str.length() ==
	                        // 1, in case of surrogates.
	                        int delta = cursor - openPos - str.Length;
	                        cursor -= delta;
	                        limit -= delta;
	                        // assert(cursor == openPos + str.length());
	                    }
	                    // If the lookup failed, we leave things as-is and
	                    // still switch to mode 0 and continue.
	                    mode = 0;
	                    openPos = -1; // close off candidate
	                    continue; // *** reprocess char32At(cursor)
	                }
	
	                if (legal.Contains(c)) {
	                    IBM.ICU.Text.UTF16.Append(name, c);
	                    // If we go past the longest possible name then abort.
	                    // maxLen includes temporary trailing space, so use '>='.
	                    if (name.Length >= maxLen) {
	                        mode = 0;
	                    }
	                }
	
	                // Invalid character
	                else {
	                    --cursor; // Backup and reprocess this character
	                    mode = 0;
	                }
	
	                break;
	            }
	
	            cursor += IBM.ICU.Text.UTF16.GetCharCount(c);
	        }
	
	        offsets.contextLimit += limit - offsets.limit;
	        offsets.limit = limit;
	        // In incremental mode, only advance the cursor up to the last
	        // open delimiter candidate.
	        offsets.start = (isIncremental && openPos >= 0) ? openPos : cursor;
	    }
	}
}
