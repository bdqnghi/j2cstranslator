//##header J2SE15
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/16/10 2:47 PM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2005-2007, International Business Machines Corporation and    
/// others. All Rights Reserved.                                                
/// </summary>
///
namespace IBM.ICU.Dev.Test.CharsetDet {
	
	using IBM.ICU.Dev.Test;
	using IBM.ICU.Text;
	using ILOG.J2CsMapping.XML;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Text;
	using System.Xml;
	
	public class TestCharsetDetector : TestFmwk {
	
	    /// <summary>
	    /// Constructor
	    /// </summary>
	    ///
	    public TestCharsetDetector() {
	    }
	
	    public static void Main(String[] args) {
	        try {
	            TestCharsetDetector test = new TestCharsetDetector();
	            test.Run(args);
	        } catch (Exception e) {
	            Console.Error.WriteLine(e.StackTrace);
	        }
	    }
	
	    private void CheckAssert(bool exp) {
	        if (exp == false) {
	            String msg;
	            try {
	                throw new Exception();
	            } catch (Exception e) {
	                // #if defined(FOUNDATION10) || defined(J2SE13)
	                // ## msg = "Test failure  " + e.getMessage() ;
	                // #else
	                String failPoint = e.StackTrace[1];
	                msg = "Test failure in file " + failPoint.GetFileName()
	                        + " at line " + failPoint.GetLineNumber();
	                // #endif
	            }
	            Errln(msg);
	        }
	
	    }
	
	    private String StringFromReader(TextReader reader) {
	        StringBuilder sb = new StringBuilder();
	        char[] buffer = new char[1024];
	        int bytesRead = 0;
	
	        try {
	            while ((bytesRead = reader.Read(buffer, 0, 1024)) >= 0) {
	                sb.Append(buffer, 0, bytesRead);
	            }
	
	            return sb.ToString();
	        } catch (Exception e) {
	            Errln("stringFromReader() failed: " + e.ToString());
	            return null;
	        }
	    }
	
	    private void CheckMatch(CharsetDetector det, String testString,
	            String encoding, String language, String id) {
	        CharsetMatch m = det.Detect();
	        String decoded;
	
	        if (!m.GetName().Equals(encoding)) {
	            Errln(id + ": encoding detection failure - expected " + encoding
	                    + ", got " + m.GetName());
	            return;
	        }
	
	        String charsetMatchLanguage = m.GetLanguage();
	        if ((language != null && !charsetMatchLanguage.Equals(language))
	                || (language == null && charsetMatchLanguage != null)
	                || (language != null && charsetMatchLanguage == null)) {
	            Errln(id + ", " + encoding
	                    + ": language detection failure - expected " + language
	                    + ", got " + m.GetLanguage());
	        }
	
	        if (encoding.StartsWith("UTF-32")) {
	            return;
	        }
	
	        decoded = m.GetString();
	
	        if (!testString.Equals(decoded)) {
	            Errln(id + ", " + encoding
	                    + ": getString() didn't return the original string!");
	        }
	
	        decoded = StringFromReader(m.GetReader());
	
	        if (!testString.Equals(decoded)) {
	            Errln(id + ", " + encoding
	                    + ": getReader() didn't yield the original string!");
	        }
	    }
	
	    private void CheckEncoding(String testString, String encoding, String id) {
	        String enc = null, lang = null;
	        // #if defined(FOUNDATION10) || defined(J2SE13)
	        // ## String[] split = Utility.split(encoding,'/');
	        // #else
	        String[] split = ILOG.J2CsMapping.Text.RegExUtil.Split(encoding, "/");
	        // #endif
	
	        enc = split[0];
	
	        if (split.Length > 1) {
	            lang = split[1];
	        }
	
	        try {
	            CharsetDetector det = new CharsetDetector();
	            byte[] bytes;
	
	            // if (enc.startsWith("UTF-32")) {
	            // UTF32 utf32 = UTF32.getInstance(enc);
	
	            // bytes = utf32.toBytes(testString);
	            // } else {
	            String from = enc;
	
	            while (true) {
	                try {
	                    bytes = ILOG.J2CsMapping.Util.StringUtil.GetBytes(testString,from);
	                } catch (NotSupportedException uoe) {
	                    // In some runtimes, the ISO-2022-CN converter
	                    // only converts *to* Unicode - we have to use
	                    // x-ISO-2022-CN-GB to convert *from* Unicode.
	                    if (from.Equals("ISO-2022-CN")) {
	                        from = "x-ISO-2022-CN-GB";
	                        continue;
	                    }
	
	                    // Ignore any other converters that can't
	                    // convert from Unicode.
	                    return;
	                } catch (IOException uee) {
	                    // Ignore any encodings that this runtime
	                    // doesn't support.
	                    return;
	                }
	
	                break;
	            }
	            // }
	
	            det.SetText(bytes);
	            CheckMatch(det, testString, enc, lang, id);
	
	            det.SetText(new MemoryStream(bytes));
	            CheckMatch(det, testString, enc, lang, id);
	        } catch (Exception e) {
	            Errln(id + ": " + e.ToString() + "enc=" + enc);
	            Console.Error.WriteLine(e.StackTrace);
	        }
	    }
	
	    public void TestConstruction() {
	        int i;
	        CharsetDetector det = new CharsetDetector();
	        if (det == null) {
	            Errln("Could not construct a charset detector");
	        }
	        String[] charsetNames = IBM.ICU.Text.CharsetDetector.GetAllDetectableCharsets();
	        CheckAssert(charsetNames.Length != 0);
	        for (i = 0; i < charsetNames.Length; i++) {
	            CheckAssert(charsetNames[i].Equals("") == false);
	            // System.out.println("\"" + charsetNames[i] + "\"");
	        }
	    }
	
	    public void TestInputFilter() {
	        String s = "<a> <lot> <of> <English> <inside> <the> <markup> Un tr\u00E8s petit peu de Fran\u00E7ais. <to> <confuse> <the> <detector>";
	        byte[] bytes = ILOG.J2CsMapping.Util.StringUtil.GetBytes(s,"ISO-8859-1");
	        CharsetDetector det = new CharsetDetector();
	        CharsetMatch m;
	
	        det.EnableInputFilter(true);
	        if (!det.InputFilterEnabled()) {
	            Errln("input filter should be enabled");
	        }
	
	        det.SetText(bytes);
	        m = det.Detect();
	
	        if (!m.GetLanguage().Equals("fr")) {
	            Errln("input filter did not strip markup!");
	        }
	
	        det.EnableInputFilter(false);
	        det.SetText(bytes);
	        m = det.Detect();
	
	        if (!m.GetLanguage().Equals("en")) {
	            Errln("unfiltered input did not detect as English!");
	        }
	    }
	
	    public void TestUTF8() {
	
	        String s = "This is a string with some non-ascii characters that will "
	                + "be converted to UTF-8, then shoved through the detection process.  "
	                + "\u0391\u0392\u0393\u0394\u0395"
	                + "Sure would be nice if our source could contain Unicode directly!";
	        byte[] bytes = ILOG.J2CsMapping.Util.StringUtil.GetBytes(s,"UTF-8");
	        CharsetDetector det = new CharsetDetector();
	        String retrievedS;
	        TextReader reader;
	
	        retrievedS = det.GetString(bytes, "UTF-8");
	        CheckAssert(s.Equals(retrievedS));
	
	        reader = det.GetReader(new MemoryStream(bytes), "UTF-8");
	        CheckAssert(s.Equals(StringFromReader(reader)));
	        det.SetDeclaredEncoding("UTF-8"); // Jitterbug 4451, for coverage
	    }
	
	    public void TestUTF16() {
	        String source = "u0623\u0648\u0631\u0648\u0628\u0627, \u0628\u0631\u0645\u062c\u064a\u0627\u062a "
	                + "\u0627\u0644\u062d\u0627\u0633\u0648\u0628 \u002b\u0020\u0627\u0646\u062a\u0631\u0646\u064a\u062a";
	
	        byte[] beBytes = ILOG.J2CsMapping.Util.StringUtil.GetBytes(source,"UnicodeBig");
	        byte[] leBytes = ILOG.J2CsMapping.Util.StringUtil.GetBytes(source,"UnicodeLittle");
	        CharsetDetector det = new CharsetDetector();
	        CharsetMatch m;
	
	        det.SetText(beBytes);
	        m = det.Detect();
	
	        if (!m.GetName().Equals("UTF-16BE")) {
	            Errln("Encoding detection failure: expected UTF-16BE, got "
	                    + m.GetName());
	        }
	
	        det.SetText(leBytes);
	        m = det.Detect();
	
	        if (!m.GetName().Equals("UTF-16LE")) {
	            Errln("Encoding detection failure: expected UTF-16LE, got "
	                    + m.GetName());
	        }
	
	        // Jitterbug 4451, for coverage
	        int confidence = m.GetConfidence();
	        if (confidence != 100) {
	            Errln("Did not get the expected confidence level " + confidence);
	        }
	        int matchType = m.GetMatchType();
	        if (matchType != 0) {
	            Errln("Did not get the expected matchType level " + matchType);
	        }
	    }
	
	    public void TestC1Bytes() {
	        String sISO = "This is a small sample of some English text. Just enough to be sure that it detects correctly.";
	
	        String sWindows = "This is another small sample of some English text. Just enough to be sure that it detects correctly. It also includes some \u201CC1\u201D bytes.";
	
	        byte[] bISO = ILOG.J2CsMapping.Util.StringUtil.GetBytes(sISO,"ISO-8859-1");
	        byte[] bWindows = ILOG.J2CsMapping.Util.StringUtil.GetBytes(sWindows,"windows-1252");
	
	        CharsetDetector det = new CharsetDetector();
	        CharsetMatch m;
	
	        det.SetText(bWindows);
	        m = det.Detect();
	
	        if (m.GetName() != "windows-1252") {
	            Errln("Text with C1 bytes not correctly detected as windows-1252.");
	            return;
	        }
	
	        det.SetText(bISO);
	        m = det.Detect();
	
	        if (m.GetName() != "ISO-8859-1") {
	            Errln("Text without C1 bytes not correctly detected as ISO-8859-1.");
	        }
	    }
	
	    public void TestShortInput() {
	        // Test that detection with very short byte strings does not crash and
	        // burn.
	        // The shortest input that should produce positive detection result is
	        // two bytes,
	        // a UTF-16 BOM.
	        // TODO: Detector confidence levels needs to be refined for very short
	        // input.
	        // Too high now, for some charsets that happen to be compatible with a
	        // few bytes of input.
	        byte[][] shortBytes = new byte[][] {
	                        new byte[] {},
	                        new byte[] { (byte) 0x0a },
	                        new byte[] { (byte) 'A', (byte) 'B' },
	                        new byte[] { (byte) 'A', (byte) 'B', (byte) 'C' },
	                        new byte[] { (byte) 'A', (byte) 'B', (byte) 'C',
	                                (byte) 'D' } };
	
	        CharsetDetector det = new CharsetDetector();
	        CharsetMatch m;
	        for (int i = 0; i < shortBytes.Length; i++) {
	            det.SetText(shortBytes[i]);
	            m = det.Detect();
	        }
	    }
	
	    public void TestDetection() {
	        //
	        // Open and read the test data file.
	        //
	        // InputStreamReader isr = null;
	
	        try {
	            Stream mask0 = typeof(TestCharsetDetector).Assembly.GetFile("CharsetDetectionTests.xml");
	            if (mask0 == null) {
	                Errln("Could not open test data file CharsetDetectionTests.xml");
	                return;
	            }
	
	            // isr = new InputStreamReader(is, "UTF-8");
	
	            // Set up an xml parser.
	            XmlDocumentBuilderFactory factory = ILOG.J2CsMapping.XML.XmlDocumentBuilderFactory
	                    .NewInstance();
	
	            factory.SetIgnoringComments(true);
	
	            XmlDocumentBuilder builder = factory.NewDocumentBuilder();
	
	            // Parse the xml content from the test case file.
	            XmlDocument doc = builder.Parse(mask0, null);
	            XmlElement root = doc.DocumentElement;
	
	            XmlNodeList testCases = root.GetElementsByTagName("test-case");
	
	            // Process each test case
	            for (int n = 0; n < testCases.Count; n += 1) {
	                XmlNode testCase = testCases.Item(n);
	                XmlAttributeCollection attrs = testCase.Attributes;
	                XmlNodeList testData = testCase.ChildNodes;
	                StringBuilder testText = new StringBuilder();
	                String id = attrs.GetNamedItem("id").Value;
	                String encodings = attrs.GetNamedItem("encodings").Value;
	
	                // Collect the test case text.
	                for (int t = 0; t < testData.Count; t += 1) {
	                    XmlNode textNode = testData.Item(t);
	
	                    testText.Append(textNode.Value);
	                }
	
	                // Process test text with each encoding / language pair.
	                String testString = testText.ToString();
	                // #if defined(FOUNDATION10) || defined(J2SE13)
	                // ## String[] encodingList = Utility.split(encodings, ' ');
	                // #else
	                String[] encodingList = ILOG.J2CsMapping.Text.RegExUtil.Split(encodings, " ");
	                // #endif
	
	                for (int e = 0; e < encodingList.Length; e += 1) {
	                    CheckEncoding(testString, encodingList[e], id);
	                }
	            }
	
	        } catch (Exception e_0) {
	            Errln("exception while processing test cases: " + e_0.ToString());
	        }
	    }
	}
}
