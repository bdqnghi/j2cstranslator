/*
 *******************************************************************************
 * Copyright (C) 1996-2006, International Business Machines Corporation and    *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 */
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:48 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Impl {
	
	using IBM.ICU.Text;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	
	/// <summary>
	/// Used by Collation. UCharacterIterator on Strings. Can't use
	/// ReplaceableUCharacterIterator because it is not easy to do a fast setText.
	/// </summary>
	///
	// TODO: Investivate if setText is a feature required by users so that we can
	// move this method to the base class!
	public sealed class StringUCharacterIterator : UCharacterIterator {
	
	    // public constructor ------------------------------------------------------
	
	    /// <summary>
	    /// Public constructor
	    /// </summary>
	    ///
	    /// <param name="str">text which the iterator will be based on</param>
	    public StringUCharacterIterator(String str) {
	        if (str == null) {
	            throw new ArgumentException();
	        }
	        m_text_ = str;
	        m_currentIndex_ = 0;
	    }
	
	    /// <summary>
	    /// Public default constructor
	    /// </summary>
	    ///
	    public StringUCharacterIterator() {
	        m_text_ = "";
	        m_currentIndex_ = 0;
	    }
	
	    // public methods ----------------------------------------------------------
	
	    /// <summary>
	    /// Creates a copy of this iterator, does not clone the underlying
	    /// <c>String</c>object
	    /// </summary>
	    ///
	    /// <returns>copy of this iterator</returns>
	    // /CLOVER:OFF
	    public override Object Clone() {
	        try {
	            return base.Clone();
	        } catch (Exception e) {
	            return null; // never invoked
	        }
	    }
	
	    // /CLOVER:ON
	    /// <summary>
	    /// Returns the current UTF16 character.
	    /// </summary>
	    ///
	    /// <returns>current UTF16 character</returns>
	    public override int Current() {
	        if (m_currentIndex_ < m_text_.Length) {
	            return m_text_[m_currentIndex_];
	        }
	        return IBM.ICU.Text.UForwardCharacterIterator_Constants.DONE;
	    }
	
	    /// <summary>
	    /// Returns the length of the text
	    /// </summary>
	    ///
	    /// <returns>length of the text</returns>
	    public override int GetLength() {
	        return m_text_.Length;
	    }
	
	    /// <summary>
	    /// Gets the current currentIndex in text.
	    /// </summary>
	    ///
	    /// <returns>current currentIndex in text.</returns>
	    public override int GetIndex() {
	        return m_currentIndex_;
	    }
	
	    /// <summary>
	    /// Returns next UTF16 character and increments the iterator's currentIndex
	    /// by 1. If the resulting currentIndex is greater or equal to the text
	    /// length, the currentIndex is reset to the text length and a value of DONE
	    /// is returned.
	    /// </summary>
	    ///
	    /// <returns>next UTF16 character in text or DONE if the new currentIndex is
	    /// off the end of the text range.</returns>
	    public override int Next() {
	        if (m_currentIndex_ < m_text_.Length) {
	            return m_text_[m_currentIndex_++];
	        }
	        return IBM.ICU.Text.UForwardCharacterIterator_Constants.DONE;
	    }
	
	    /// <summary>
	    /// Returns previous UTF16 character and decrements the iterator's
	    /// currentIndex by 1. If the resulting currentIndex is less than 0, the
	    /// currentIndex is reset to 0 and a value of DONE is returned.
	    /// </summary>
	    ///
	    /// <returns>next UTF16 character in text or DONE if the new currentIndex is
	    /// off the start of the text range.</returns>
	    public override int Previous() {
	        if (m_currentIndex_ > 0) {
	            return m_text_[--m_currentIndex_];
	        }
	        return IBM.ICU.Text.UForwardCharacterIterator_Constants.DONE;
	    }
	
	    /// <summary>
	    /// <p>
	    /// Sets the currentIndex to the specified currentIndex in the text and
	    /// returns that single UTF16 character at currentIndex. This assumes the
	    /// text is stored as 16-bit code units.
	    /// </p>
	    /// </summary>
	    ///
	    /// <param name="currentIndex">the currentIndex within the text.</param>
	    /// <exception cref="IndexOutOfBoundsException">is thrown if an invalid currentIndex is supplied. i.e.currentIndex is out of bounds.</exception>
	    public override void SetIndex(int currentIndex) {
	        if (currentIndex < 0 || currentIndex > m_text_.Length) {
	            throw new IndexOutOfRangeException();
	        }
	        m_currentIndex_ = currentIndex;
	    }
	
	    /// <summary>
	    /// Fills the buffer with the underlying text storage of the iterator If the
	    /// buffer capacity is not enough a exception is thrown. The capacity of the
	    /// fill in buffer should at least be equal to length of text in the iterator
	    /// obtained by calling <code>getLength()</code). <b>Usage:</b>
	    /// <code>
	    /// <pre>
	    /// UChacterIterator iter = new UCharacterIterator.getInstance(text);
	    /// char[] buf = new char[iter.getLength()];
	    /// iter.getText(buf);
	    /// OR
	    /// char[] buf= new char[1];
	    /// int len = 0;
	    /// for(;;){
	    /// try{
	    /// len = iter.getText(buf);
	    /// break;
	    /// }catch(IndexOutOfBoundsException e){
	    /// buf = new char[iter.getLength()];
	    /// }
	    /// }
	    /// </pre>
	    /// </code>
	    /// </summary>
	    ///
	    /// <param name="fillIn">an array of chars to fill with the underlying UTF-16 codeunits.</param>
	    /// <param name="offset">the position within the array to start putting the data.</param>
	    /// <returns>the number of code units added to fillIn, as a convenience</returns>
	    /// <exception cref="IndexOutOfBoundsException">exception if there is not enough room after offset in thearray, or if offset &lt; 0.</exception>
	    // /CLOVER:OFF
	    public override int GetText(char[] fillIn, int offset) {
	        int length = m_text_.Length;
	        if (offset < 0 || offset + length > fillIn.Length) {
	            throw new IndexOutOfRangeException(ILOG.J2CsMapping.Util.IlNumber.ToString(length).ToString());
	        }
	        m_text_.CopyTo(0,fillIn,offset,length-0);
	        return length;
	    }
	
	    // /CLOVER:ON
	    /// <summary>
	    /// Convenience method for returning the underlying text storage as as string
	    /// </summary>
	    ///
	    /// <returns>the underlying text storage in the iterator as a string</returns>
	    public override String GetText() {
	        return m_text_;
	    }
	
	    /// <summary>
	    /// Reset this iterator to point to a new string. This method is used by
	    /// other classes that want to avoid allocating new
	    /// ReplaceableCharacterIterator objects every time their setText method is
	    /// called.
	    /// </summary>
	    ///
	    /// <param name="text">The String to be iterated over</param>
	    public void SetText(String text) {
	        if (text == null) {
	            throw new NullReferenceException();
	        }
	        m_text_ = text;
	        m_currentIndex_ = 0;
	    }
	
	    // private data members ----------------------------------------------------
	
	    /// <summary>
	    /// Text string object
	    /// </summary>
	    ///
	    private String m_text_;
	
	    /// <summary>
	    /// Current currentIndex
	    /// </summary>
	    ///
	    private int m_currentIndex_;
	
	}
}
