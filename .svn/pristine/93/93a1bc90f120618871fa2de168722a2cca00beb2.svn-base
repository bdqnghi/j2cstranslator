/*
 *******************************************************************************
 * Copyright (C) 2005-2007, International Business Machines Corporation and         *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 */
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:48 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Impl {
	
	using IBM.ICU.Util;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Text;
	
	/// <summary>
	/// A time zone based on the Olson database. Olson time zones change behavior
	/// over time. The raw offset, rules, presence or absence of daylight savings
	/// time, and even the daylight savings amount can all vary.
	/// This class uses a resource bundle named "zoneinfo". Zoneinfo is a table
	/// containing different kinds of resources. In several places, zones are
	/// referred to using integers. A zone's integer is a number from 0..n-1, where n
	/// is the number of zones, with the zones sorted in lexicographic order.
	/// 1. Zones. These have keys corresponding to the Olson IDs, e.g.,
	/// "Asia/Shanghai". Each resource describes the behavior of the given zone.
	/// Zones come in several formats, which are differentiated based on length.
	/// a. Alias (int, length 1). An alias zone is an int resource. The integer is
	/// the zone number of the target zone. The key of this resource is an alternate
	/// name for the target zone. Aliases represent Olson links and ICU compatibility
	/// IDs.
	/// b. Simple zone (array, length 3). The three subelements are:
	/// i. An intvector of transitions. These are given in epoch seconds. This may be
	/// an empty invector (length 0). If the transtions list is empty, then the
	/// zone's behavior is fixed and given by the offset list, which will contain
	/// exactly one pair. Otherwise each transtion indicates a time after which
	/// (inclusive) the associated offset pair is in effect.
	/// ii. An intvector of offsets. These are in pairs of raw offset / DST offset,
	/// in units of seconds. There will be at least one pair (length >= 2 && length %
	/// 2 == 0).
	/// iii. A binary resource. This is of the same length as the transitions vector,
	/// so length may be zero. Each unsigned byte corresponds to one transition, and
	/// has a value of 0..n-1, where n is the number of pairs in the offset vector.
	/// This forms a map between transitions and offset pairs.
	/// c. Simple zone with aliases (array, length 4). This is like a simple zone,
	/// but also contains a fourth element:
	/// iv. An intvector of aliases. This list includes this zone itself, and lists
	/// all aliases of this zone.
	/// d. Complex zone (array, length 5). This is like a simple zone, but contains
	/// two more elements:
	/// iv. A string, giving the name of a rule. This is the "final
	/// rule", which governs the zone's behavior beginning in the "final year". The
	/// rule ID is given without leading underscore, e.g., "EU".
	/// v. An intvector of length 2, containing the raw offset for the final rule (in
	/// seconds), and the final year. The final rule takes effect for years >= the
	/// final year.
	/// e. Complex zone with aliases (array, length 6). This is like a complex zone,
	/// but also contains a sixth element:
	/// vi. An intvector of aliases. This list includes this zone itself, and lists
	/// all aliases of this zone.
	/// 2. Rules. These have keys corresponding to the Olson rule IDs, with an
	/// underscore prepended, e.g., "_EU". Each resource describes the behavior of
	/// the given rule using an intvector, containing the onset list, the cessation
	/// list, and the DST savings. The onset and cessation lists consist of the
	/// month, dowim, dow, time, and time mode. The end result is that the 11
	/// integers describing the rule can be passed directly into the SimpleTimeZone
	/// 13-argument constructor (the other two arguments will be the raw offset,
	/// taken from the complex zone element 5, and the ID string, which is not used),
	/// with the times and the DST savings multiplied by 1000 to scale from seconds
	/// to milliseconds.
	/// 3. Countries. These have keys corresponding to the 2-letter ISO country
	/// codes, with a percent sign prepended, e.g., "%US". Each resource is an
	/// intvector listing the zones associated with the given country. The special
	/// entry "%" corresponds to "no country", that is, the category of zones
	/// assigned to no country in the Olson DB.
	/// 4. Metadata. Metadata is stored under the key "_". It is an intvector of
	/// length three containing the number of zones resources, rule resources, and
	/// country resources. For the purposes of this count, the metadata entry itself
	/// is considered a rule resource, since its key begins with an underscore.
	/// </summary>
	///
	public class OlsonTimeZone : BasicTimeZone {
	
	    // Generated by serialver from JDK 1.4.1_01
	    internal const long serialVersionUID = -6281977362477515376L;
	
	    private const bool ASSERT = false;
	
	    /*
	     * (non-Javadoc)
	     * 
	     * @see com.ibm.icu.util.TimeZone#getOffset(int, int, int, int, int, int)
	     */
	    public override int GetOffset(int era, int year, int month, int day, int dayOfWeek,
	            int milliseconds) {
	        if (month < IBM.ICU.Util.Calendar.JANUARY || month > IBM.ICU.Util.Calendar.DECEMBER) {
	            throw new ArgumentException(
	                    "Month is not in the legal range: " + month);
	        } else {
	            return GetOffset(era, year, month, day, dayOfWeek, milliseconds,
	                    IBM.ICU.Impl.Grego.MonthLength(year, month));
	        }
	    }
	
	    /// <summary>
	    /// TimeZone API.
	    /// </summary>
	    ///
	    public int GetOffset(int era, int year, int month, int dom, int dow,
	            int millis, int monthLength) {
	
	        if ((era != IBM.ICU.Util.GregorianCalendar.AD && era != IBM.ICU.Util.GregorianCalendar.BC)
	                || month < IBM.ICU.Util.Calendar.JANUARY || month > IBM.ICU.Util.Calendar.DECEMBER
	                || dom < 1 || dom > monthLength || dow < IBM.ICU.Util.Calendar.SUNDAY
	                || dow > IBM.ICU.Util.Calendar.SATURDAY || millis < 0
	                || millis >= IBM.ICU.Impl.Grego.MILLIS_PER_DAY || monthLength < 28
	                || monthLength > 31) {
	            throw new ArgumentException();
	        }
	
	        if (era == IBM.ICU.Util.GregorianCalendar.BC) {
	            year = -year;
	        }
	
	        if (year > finalYear) { // [sic] >, not >=; see above
	            if (ASSERT)
	                IBM.ICU.Impl.Assert.Assrt("(finalZone != null)", finalZone != null);
	            return finalZone.GetOffset(era, year, month, dom, dow, millis);
	        }
	
	        // Compute local epoch millis from input fields
	        long time = IBM.ICU.Impl.Grego.FieldsToDay(year, month, dom) * IBM.ICU.Impl.Grego.MILLIS_PER_DAY
	                + millis;
	
	        int[] offsets = new int[2];
	        GetHistoricalOffset(time, true, IBM.ICU.Util.BasicTimeZone.LOCAL_DST, IBM.ICU.Util.BasicTimeZone.LOCAL_STD, offsets);
	        return offsets[0] + offsets[1];
	    }
	
	    /*
	     * (non-Javadoc)
	     * 
	     * @see com.ibm.icu.util.TimeZone#setRawOffset(int)
	     */
	    public override void SetRawOffset(int offsetMillis) {
	        if (GetRawOffset() == offsetMillis) {
	            return;
	        }
	        GregorianCalendar cal = new GregorianCalendar(IBM.ICU.Util.ULocale.ROOT);
	        cal.SetTimeZone(this);
	        int tmpFinalYear = cal.Get(IBM.ICU.Util.Calendar.YEAR) - 1;
	
	        // Apply the raw offset starting current year and beyond
	        if (finalYear > tmpFinalYear) {
	            finalYear = tmpFinalYear;
	            finalMillis = IBM.ICU.Impl.Grego.FieldsToDay(tmpFinalYear, 0, 1)
	                    * IBM.ICU.Impl.Grego.MILLIS_PER_DAY;
	        }
	        if (finalZone == null) {
	            // Create SimpleTimeZone instance to store the offset
	            finalZone = new SimpleTimeZone(offsetMillis, GetID());
	        } else {
	            finalZone.SetRawOffset(offsetMillis);
	            finalZone.SetStartYear(finalYear);
	        }
	
	        transitionRulesInitialized = false;
	    }
	
	    public override Object Clone() {
	        OlsonTimeZone other = (OlsonTimeZone) base.Clone();
	        if (finalZone != null) {
	            finalZone.SetID(GetID());
	            other.finalZone = (SimpleTimeZone) finalZone.Clone();
	        }
	        other.transitionTimes = (int[]) transitionTimes.Clone();
	        other.typeData = (byte[]) typeData.Clone();
	        other.typeOffsets = (int[]) typeOffsets.Clone();
	        return other;
	    }
	
	    /// <summary>
	    /// TimeZone API.
	    /// </summary>
	    ///
	    public override void GetOffset(long date, bool local, int[] offsets) {
	        // The check against finalMillis will suffice most of the time, except
	        // for the case in which finalMillis == DBL_MAX, date == DBL_MAX,
	        // and finalZone == 0. For this case we add "&& finalZone != 0".
	        if (date >= finalMillis && finalZone != null) {
	            finalZone.GetOffset(date, local, offsets);
	        } else {
	            GetHistoricalOffset(date, local, IBM.ICU.Util.BasicTimeZone.LOCAL_FORMER, IBM.ICU.Util.BasicTimeZone.LOCAL_LATTER,
	                    offsets);
	        }
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// 
	    /// </summary>
	    ///
	    public override void GetOffsetFromLocal(long date, int nonExistingTimeOpt,
	            int duplicatedTimeOpt, int[] offsets) {
	        if (date >= finalMillis && finalZone != null) {
	            finalZone.GetOffsetFromLocal(date, nonExistingTimeOpt,
	                    duplicatedTimeOpt, offsets);
	        } else {
	            GetHistoricalOffset(date, true, nonExistingTimeOpt,
	                    duplicatedTimeOpt, offsets);
	        }
	    }
	
	    /*
	     * (non-Javadoc)
	     * 
	     * @see com.ibm.icu.util.TimeZone#getRawOffset()
	     */
	    public override int GetRawOffset() {
	        int[] ret = new int[2];
	        GetOffset(DateTime.Now.Millisecond, false, ret);
	        return ret[0];
	    }
	
	    /*
	     * (non-Javadoc)
	     * 
	     * @see com.ibm.icu.util.TimeZone#useDaylightTime()
	     */
	    public override bool UseDaylightTime() {
	        // If DST was observed in 1942 (for example) but has never been
	        // observed from 1943 to the present, most clients will expect
	        // this method to return FALSE. This method determines whether
	        // DST is in use in the current year (at any point in the year)
	        // and returns TRUE if so.
	        int[] fields = IBM.ICU.Impl.Grego.TimeToFields(DateTime.Now.Millisecond, null);
	        int year = fields[0];
	
	        if (year > finalYear) { // [sic] >, not >=; see above
	            return (finalZone != null && finalZone.UseDaylightTime());
	        }
	
	        // Find start of this year, and start of next year
	        long start = IBM.ICU.Impl.Grego.FieldsToDay(year, 0, 1) * SECONDS_PER_DAY;
	        long limit = IBM.ICU.Impl.Grego.FieldsToDay(year + 1, 0, 1) * SECONDS_PER_DAY;
	
	        // Return TRUE if DST is observed at any time during the current
	        // year.
	        for (int i = 0; i < transitionCount; ++i) {
	            if (transitionTimes[i] >= limit) {
	                break;
	            }
	            if (transitionTimes[i] >= start && DstOffset(typeData[i]) != 0) {
	                return true;
	            }
	        }
	        return false;
	    }
	
	    /// <summary>
	    /// TimeZone API Returns the amount of time to be added to local standard
	    /// time to get local wall clock time.
	    /// </summary>
	    ///
	    public override int GetDSTSavings() {
	        if (finalZone != null) {
	            return finalZone.GetDSTSavings();
	        }
	        return base.GetDSTSavings();
	    }
	
	    /*
	     * (non-Javadoc)
	     * 
	     * @see com.ibm.icu.util.TimeZone#inDaylightTime(java.util.Date)
	     */
	    public override bool InDaylightTime(DateTime date) {
	        int[] temp = new int[2];
	        GetOffset((date.Ticks/10000), false, temp);
	        return temp[1] != 0;
	    }
	
	    /*
	     * (non-Javadoc)
	     * 
	     * @see com.ibm.icu.util.TimeZone#hasSameRules(com.ibm.icu.util.TimeZone)
	     */
	    public override bool HasSameRules(IBM.ICU.Util.TimeZone other) {
	        // The super class implementation only check raw offset and
	        // use of daylight saving time.
	        if (!base.HasSameRules(other)) {
	            return false;
	        }
	
	        if (!(other  is  OlsonTimeZone)) {
	            // We cannot reasonably compare rules in different types
	            return false;
	        }
	
	        // Check final zone
	        OlsonTimeZone o = (OlsonTimeZone) other;
	        if (finalZone == null) {
	            if (o.finalZone != null && finalYear != Int32.MaxValue) {
	                return false;
	            }
	        } else {
	            if (o.finalZone == null || finalYear != o.finalYear
	                    || !(finalZone.HasSameRules(o.finalZone))) {
	                return false;
	            }
	        }
	        // Check transitions
	        // Note: The code below actually fails to compare two equivalent rules
	        // in
	        // different representation properly.
	        if (transitionCount != o.transitionCount
	                || !ILOG.J2CsMapping.Collections.Arrays.Equals(transitionTimes,o.transitionTimes)
	                || typeCount != o.typeCount
	                || !ILOG.J2CsMapping.Collections.Arrays.Equals(typeData,o.typeData)
	                || !ILOG.J2CsMapping.Collections.Arrays.Equals(typeOffsets,o.typeOffsets)) {
	            return false;
	        }
	        return true;
	    }
	
	    /// <summary>
	    /// Construct a GMT+0 zone with no transitions. This is done when a
	    /// constructor fails so the resultant object is well-behaved.
	    /// </summary>
	    ///
	    private void ConstructEmpty() {
	        transitionCount = 0;
	        typeCount = 1;
	        transitionTimes = typeOffsets = new int[] { 0, 0 };
	        typeData = new byte[2];
	
	    }
	
	    /// <summary>
	    /// Construct from a resource bundle
	    /// </summary>
	    ///
	    /// <param name="top">the top-level zoneinfo resource bundle. This is used to lookupthe rule that `res' may refer to, if there is one.</param>
	    /// <param name="res">the resource bundle of the zone to be constructed</param>
	    public OlsonTimeZone(UResourceBundle top, UResourceBundle res) {
	        this.finalYear = Int32.MaxValue;
	        this.finalMillis = System.Double.MaxValue;
	        this.finalZone = null;
	        Construct(top, res);
	    }
	
	    private void Construct(UResourceBundle top, UResourceBundle res) {
	
	        if ((top == null || res == null)) {
	            throw new ArgumentException();
	        }
	        if (DEBUG)
	            System.Console.Out.WriteLine("OlsonTimeZone(" + res.GetKey() + ")");
	
	        // TODO -- clean up -- Doesn't work if res points to an alias
	        // // TODO remove nonconst casts below when ures_* API is fixed
	        // setID(ures_getKey((UResourceBundle*) res)); // cast away const
	
	        // Size 1 is an alias TO another zone (int)
	        // HOWEVER, the caller should dereference this and never pass it in to
	        // us
	        // Size 3 is a purely historical zone (no final rules)
	        // Size 4 is like size 3, but with an alias list at the end
	        // Size 5 is a hybrid zone, with historical and final elements
	        // Size 6 is like size 5, but with an alias list at the end
	        int size = res.GetSize();
	        if (size < 3 || size > 6) {
	            // ec = U_INVALID_FORMAT_ERROR;
	            throw new ArgumentException("Invalid Formatting");
	        }
	
	        // Transitions list may be empty
	        UResourceBundle r = res.Get(0);
	        transitionTimes = r.GetIntVector();
	
	        if ((transitionTimes.Length < 0 || transitionTimes.Length > 0x7FFF)) {
	            throw new ArgumentException("Invalid Formatting");
	        }
	        transitionCount = (int) transitionTimes.Length;
	
	        // Type offsets list must be of even size, with size >= 2
	        r = res.Get(1);
	        typeOffsets = r.GetIntVector();
	        if ((typeOffsets.Length < 2 || typeOffsets.Length > 0x7FFE || ((typeOffsets.Length & 1) != 0))) {
	            throw new ArgumentException("Invalid Formatting");
	        }
	        typeCount = (int) typeOffsets.Length >> 1;
	
	        // Type data must be of the same size as the transitions list
	        r = res.Get(2);
	        typeData = r.GetBinary().GetBytes(); // .Array();
	        if (typeData.Length != transitionCount) {
	            throw new ArgumentException("Invalid Formatting");
	        }
	
	        // Process final rule and data, if any
	        if (size >= 5) {
	            String ruleid = res.GetString(3);
	            r = res.Get(4);
	            int[] data = r.GetIntVector();
	
	            if (data != null && data.Length == 2) {
	                int rawOffset = data[0] * IBM.ICU.Impl.Grego.MILLIS_PER_SECOND;
	                // Subtract one from the actual final year; we
	                // actually store final year - 1, and compare
	                // using > rather than >=. This allows us to use
	                // INT32_MAX as an exclusive upper limit for all
	                // years, including INT32_MAX.
	                if (ASSERT)
	                    IBM.ICU.Impl.Assert.Assrt("data[1] > Integer.MIN_VALUE",
	                            data[1] > Int32.MinValue);
	                finalYear = data[1] - 1;
	                // Also compute the millis for Jan 1, 0:00 GMT of the
	                // finalYear. This reduces runtime computations.
	                finalMillis = IBM.ICU.Impl.Grego.FieldsToDay(data[1], 0, 1)
	                        * IBM.ICU.Impl.Grego.MILLIS_PER_DAY;
	                // U_DEBUG_TZ_MSG(("zone%s|%s: {%d,%d}, finalYear%d, finalMillis%.1lf\n",
	                // zKey,rKey, data[0], data[1], finalYear, finalMillis));
	                r = LoadRule(top, ruleid);
	
	                // 3, 1, -1, 7200, 0, 9, -31, -1, 7200, 0, 3600
	                data = r.GetIntVector();
	                if (data.Length == 11) {
	                    // U_DEBUG_TZ_MSG(("zone%s, rule%s: {%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d}",
	                    // zKey, ures_getKey(r),
	                    // data[0], data[1], data[2], data[3], data[4], data[5],
	                    // data[6], data[7], data[8], data[9], data[10]));
	                    finalZone = new SimpleTimeZone(rawOffset, "", data[0],
	                            data[1], data[2],
	                            data[3] * IBM.ICU.Impl.Grego.MILLIS_PER_SECOND, data[4],
	                            data[5], data[6], data[7], data[8]
	                                    * IBM.ICU.Impl.Grego.MILLIS_PER_SECOND, data[9],
	                            data[10] * IBM.ICU.Impl.Grego.MILLIS_PER_SECOND);
	                } else {
	                    throw new ArgumentException("Invalid Formatting");
	                }
	            } else {
	                throw new ArgumentException("Invalid Formatting");
	            }
	        }
	    }
	
	    public OlsonTimeZone() {
	        this.finalYear = Int32.MaxValue;
	        this.finalMillis = System.Double.MaxValue;
	        this.finalZone = null;
	        /*
	         * 
	         * finalYear = Integer.MAX_VALUE; finalMillis = Double.MAX_VALUE;
	         * finalZone = null;
	         */
	        ConstructEmpty();
	    }
	
	    public OlsonTimeZone(String id) {
	        this.finalYear = Int32.MaxValue;
	        this.finalMillis = System.Double.MaxValue;
	        this.finalZone = null;
	        UResourceBundle top = (UResourceBundle) IBM.ICU.Util.UResourceBundle
	                .GetBundleInstance(IBM.ICU.Impl.ICUResourceBundle.ICU_BASE_NAME, "zoneinfo",
	                        IBM.ICU.Impl.ICUResourceBundle.ICU_DATA_CLASS_LOADER);
	        UResourceBundle res = IBM.ICU.Impl.ZoneMeta.OpenOlsonResource(id);
	        Construct(top, res);
	        if (finalZone != null) {
	            finalZone.SetID(id);
	        }
	        base.SetID(id);
	    }
	
	    public override void SetID(String id) {
	        if (finalZone != null) {
	            finalZone.SetID(id);
	        }
	        base.SetID(id);
	        transitionRulesInitialized = false;
	    }
	
	    private const int UNSIGNED_BYTE_MASK = 0xFF;
	
	    private int GetInt(byte val) {
	        return (int) (UNSIGNED_BYTE_MASK & val);
	    }
	
	    private void GetHistoricalOffset(long date, bool local,
	            int NonExistingTimeOpt, int DuplicatedTimeOpt, int[] offsets) {
	        if (transitionCount != 0) {
	            long sec = MyFloorDivide(date, IBM.ICU.Impl.Grego.MILLIS_PER_SECOND);
	            // Linear search from the end is the fastest approach, since
	            // most lookups will happen at/near the end.
	            int i = 0;
	            for (i = transitionCount - 1; i > 0; --i) {
	                int transition = transitionTimes[i];
	                if (local) {
	                    int offsetBefore = ZoneOffset(GetInt(typeData[i - 1]));
	                    bool dstBefore = DstOffset(GetInt(typeData[i - 1])) != 0;
	
	                    int offsetAfter = ZoneOffset(GetInt(typeData[i]));
	                    bool dstAfter = DstOffset(GetInt(typeData[i])) != 0;
	
	                    bool dstToStd = dstBefore && !dstAfter;
	                    bool stdToDst = !dstBefore && dstAfter;
	
	                    if (offsetAfter - offsetBefore >= 0) {
	                        // Positive transition, which makes a non-existing local
	                        // time range
	                        if (((NonExistingTimeOpt & IBM.ICU.Util.BasicTimeZone.STD_DST_MASK) == IBM.ICU.Util.BasicTimeZone.LOCAL_STD && dstToStd)
	                                || ((NonExistingTimeOpt & IBM.ICU.Util.BasicTimeZone.STD_DST_MASK) == IBM.ICU.Util.BasicTimeZone.LOCAL_DST && stdToDst)) {
	                            transition += offsetBefore;
	                        } else if (((NonExistingTimeOpt & IBM.ICU.Util.BasicTimeZone.STD_DST_MASK) == IBM.ICU.Util.BasicTimeZone.LOCAL_STD && stdToDst)
	                                || ((NonExistingTimeOpt & IBM.ICU.Util.BasicTimeZone.STD_DST_MASK) == IBM.ICU.Util.BasicTimeZone.LOCAL_DST && dstToStd)) {
	                            transition += offsetAfter;
	                        } else if ((NonExistingTimeOpt & IBM.ICU.Util.BasicTimeZone.FORMER_LATTER_MASK) == IBM.ICU.Util.BasicTimeZone.LOCAL_LATTER) {
	                            transition += offsetBefore;
	                        } else {
	                            // Interprets the time with rule before the
	                            // transition,
	                            // default for non-existing time range
	                            transition += offsetAfter;
	                        }
	                    } else {
	                        // Negative transition, which makes a duplicated local
	                        // time range
	                        if (((DuplicatedTimeOpt & IBM.ICU.Util.BasicTimeZone.STD_DST_MASK) == IBM.ICU.Util.BasicTimeZone.LOCAL_STD && dstToStd)
	                                || ((DuplicatedTimeOpt & IBM.ICU.Util.BasicTimeZone.STD_DST_MASK) == IBM.ICU.Util.BasicTimeZone.LOCAL_DST && stdToDst)) {
	                            transition += offsetAfter;
	                        } else if (((DuplicatedTimeOpt & IBM.ICU.Util.BasicTimeZone.STD_DST_MASK) == IBM.ICU.Util.BasicTimeZone.LOCAL_STD && stdToDst)
	                                || ((DuplicatedTimeOpt & IBM.ICU.Util.BasicTimeZone.STD_DST_MASK) == IBM.ICU.Util.BasicTimeZone.LOCAL_DST && dstToStd)) {
	                            transition += offsetBefore;
	                        } else if ((DuplicatedTimeOpt & IBM.ICU.Util.BasicTimeZone.FORMER_LATTER_MASK) == IBM.ICU.Util.BasicTimeZone.LOCAL_FORMER) {
	                            transition += offsetBefore;
	                        } else {
	                            // Interprets the time with rule after the
	                            // transition,
	                            // default for duplicated local time range
	                            transition += offsetAfter;
	                        }
	                    }
	                }
	
	                if (sec >= transition) {
	                    break;
	                }
	            }
	
	            if (ASSERT)
	                IBM.ICU.Impl.Assert.Assrt("i>=0 && i<transitionCount", i >= 0
	                        && i < transitionCount);
	
	            // Check invariants for GMT times; if these pass for GMT times
	            // the local logic should be working too.
	            if (ASSERT) {
	                IBM.ICU.Impl.Assert.Assrt(
	                        "local || sec < transitionTimes[0] || sec >= transitionTimes[i]",
	                        local || sec < transitionTimes[0]
	                                || sec >= transitionTimes[i]);
	                IBM.ICU.Impl.Assert.Assrt(
	                        "local || i == transitionCount-1 || sec < transitionTimes[i+1]",
	                        local || i == transitionCount - 1
	                                || sec < transitionTimes[i + 1]);
	            }
	            // Since ICU tzdata 2007c, the first transition data is actually not
	            // a
	            // transition, but used for representing the initial offset. So the
	            // code
	            // below works even if i == 0.
	            int index = GetInt(typeData[i]);
	            offsets[0] = RawOffset(index) * IBM.ICU.Impl.Grego.MILLIS_PER_SECOND;
	            offsets[1] = DstOffset(index) * IBM.ICU.Impl.Grego.MILLIS_PER_SECOND;
	        } else {
	            // No transitions, single pair of offsets only
	            offsets[0] = RawOffset(0) * IBM.ICU.Impl.Grego.MILLIS_PER_SECOND;
	            offsets[1] = DstOffset(0) * IBM.ICU.Impl.Grego.MILLIS_PER_SECOND;
	        }
	    }
	
	    private int ZoneOffset(int index) {
	        index = index << 1;
	        return typeOffsets[index] + typeOffsets[index + 1];
	    }
	
	    private int RawOffset(int index) {
	        return typeOffsets[(int) (index << 1)];
	    }
	
	    private int DstOffset(int index) {
	        return typeOffsets[(int) ((index << 1) + 1)];
	    }
	
	    // temp
	    public override String ToString() {
	        StringBuilder buf = new StringBuilder();
	        buf.Append(base.ToString());
	        buf.Append('[');
	        buf.Append("transitionCount=" + transitionCount);
	        buf.Append(",typeCount=" + typeCount);
	        buf.Append(",transitionTimes=");
	        if (transitionTimes != null) {
	            buf.Append('[');
	            for (int i = 0; i < transitionTimes.Length; ++i) {
	                if (i > 0) {
	                    buf.Append(',');
	                }
	                buf.Append(ILOG.J2CsMapping.Util.IlNumber.ToString(transitionTimes[i]));
	            }
	            buf.Append(']');
	        } else {
	            buf.Append("null");
	        }
	        buf.Append(",typeOffsets=");
	        if (typeOffsets != null) {
	            buf.Append('[');
	            for (int i_0 = 0; i_0 < typeOffsets.Length; ++i_0) {
	                if (i_0 > 0) {
	                    buf.Append(',');
	                }
	                buf.Append(ILOG.J2CsMapping.Util.IlNumber.ToString(typeOffsets[i_0]));
	            }
	            buf.Append(']');
	        } else {
	            buf.Append("null");
	        }
	        buf.Append(",finalYear=" + finalYear);
	        buf.Append(",finalMillis=" + finalMillis);
	        buf.Append(",finalZone=" + finalZone);
	        buf.Append(']');
	
	        return buf.ToString();
	    }
	
	    /// <summary>
	    /// Number of transitions, 0..~370
	    /// </summary>
	    ///
	    private int transitionCount;
	
	    /// <summary>
	    /// Number of types, 1..255
	    /// </summary>
	    ///
	    private int typeCount;
	
	    /// <summary>
	    /// Time of each transition in seconds from 1970 epoch. Length is
	    /// transitionCount int32_t's.
	    /// </summary>
	    ///
	    private int[] transitionTimes; // alias into res; do not delete
	
	    /// <summary>
	    /// Offset from GMT in seconds for each type. Length is typeCount int32_t's.
	    /// </summary>
	    ///
	    private int[] typeOffsets; // alias into res; do not delete
	
	    /// <summary>
	    /// Type description data, consisting of transitionCount uint8_t type indices
	    /// (from 0..typeCount-1). Length is transitionCount int8_t's.
	    /// </summary>
	    ///
	    private byte[] typeData; // alias into res; do not delete
	
	    /// <summary>
	    /// The last year for which the transitions data are to be used rather than
	    /// the finalZone. If there is no finalZone, then this is set to INT32_MAX.
	    /// NOTE: This corresponds to the year _before_ the one indicated by
	    /// finalMillis.
	    /// </summary>
	    ///
	    private int finalYear;
	
	    /// <summary>
	    /// The millis for the start of the first year for which finalZone is to be
	    /// used, or DBL_MAX if finalZone is 0. NOTE: This is 0:00 GMT Jan 1,
	    /// <finalYear + 1> (not <finalMillis>).
	    /// </summary>
	    ///
	    private double finalMillis;
	
	    /// <summary>
	    /// A SimpleTimeZone that governs the behavior for years > finalYear. If and
	    /// only if finalYear == INT32_MAX then finalZone == 0.
	    /// </summary>
	    ///
	    private SimpleTimeZone finalZone; // owned, may be NULL
	
	    private static readonly bool DEBUG = IBM.ICU.Impl.ICUDebug.Enabled("olson");
	
	    private const int SECONDS_PER_DAY = 24 * 60 * 60;
	
	    private static UResourceBundle LoadRule(UResourceBundle top, String ruleid) {
	        UResourceBundle r = top.Get("Rules");
	        r = r.Get(ruleid);
	        return r;
	    }
	
	    /// <summary>
	    /// Divide two long integers, returning the floor of the quotient.
	    /// <p>
	    /// Unlike the built-in division, this is mathematically well-behaved. E.g.,
	    /// <code>-1/4</code> => 0 but <c>floorDivide(-1,4)</c> => -1.
	    /// </summary>
	    ///
	    /// <param name="numerator">the numerator</param>
	    /// <param name="denominator">a divisor which must be > 0</param>
	    /// <returns>the floor of the quotient.</returns>
	    /// @stable ICU 2.0
	    private static long MyFloorDivide(long numerator, long denominator) {
	        // We do this computation in order to handle
	        // a numerator of Long.MIN_VALUE correctly
	        return (numerator >= 0) ? numerator / denominator
	                : ((numerator + 1) / denominator) - 1;
	    }
	
	    public override bool Equals(Object obj) {
	        if (!base.Equals(obj))
	            return false; // super does class check
	
	        OlsonTimeZone z = (OlsonTimeZone) obj;
	
	        return (IBM.ICU.Impl.Utility.ArrayEquals(typeData, z.typeData) ||
	        // If the pointers are not equal, the zones may still
	        // be equal if their rules and transitions are equal
	        (finalYear == z.finalYear &&
	        // Don't compare finalMillis; if finalYear is ==, so is finalMillis
	        ((finalZone == null && z.finalZone == null) || (finalZone != null
	                && z.finalZone != null && finalZone.Equals(z.finalZone))
	                && transitionCount == z.transitionCount
	                && typeCount == z.typeCount
	                && IBM.ICU.Impl.Utility.ArrayEquals(transitionTimes, z.transitionTimes)
	                && IBM.ICU.Impl.Utility.ArrayEquals(typeOffsets, z.typeOffsets)
	                && IBM.ICU.Impl.Utility.ArrayEquals(typeData, z.typeData))));
	
	    }
	
	    public override int GetHashCode() {
	        int ret = (int) (finalYear ^ ((int) (((uint) finalYear) >> 4)) + transitionCount
	                ^ ((int) (((uint) transitionCount) >> 6)) + typeCount ^ ((int) (((uint) typeCount) >> 8))
	                + BitConverter.DoubleToInt64Bits(finalMillis)
	                + ((finalZone == null) ? 0 : finalZone.GetHashCode())
	                + base.GetHashCode());
	        for (int i = 0; i < transitionTimes.Length; i++) {
	            ret += transitionTimes[i] ^ ((int) (((uint) transitionTimes[i]) >> 8));
	        }
	        for (int i_0 = 0; i_0 < typeOffsets.Length; i_0++) {
	            ret += typeOffsets[i_0] ^ ((int) (((uint) typeOffsets[i_0]) >> 8));
	        }
	        for (int i_1 = 0; i_1 < typeData.Length; i_1++) {
	            ret += typeData[i_1] & UNSIGNED_BYTE_MASK;
	        }
	        return ret;
	    }
	
	    /*
	     * private void readObject(ObjectInputStream s) throws IOException {
	     * s.defaultReadObject(); // customized deserialization code
	     * 
	     * // followed by code to update the object, if necessary }
	     */
	
	    //
	    // BasicTimeZone methods
	    //
	
	    /*
	     * (non-Javadoc)
	     * 
	     * @see com.ibm.icu.util.BasicTimeZone#getNextTransition(long, boolean)
	     */
	    public override TimeZoneTransition GetNextTransition(long bs, bool inclusive) {
	        InitTransitionRules();
	
	        if (finalZone != null) {
	            if (inclusive && bs == firstFinalTZTransition.GetTime()) {
	                return firstFinalTZTransition;
	            } else if (bs >= firstFinalTZTransition.GetTime()) {
	                if (finalZone.UseDaylightTime()) {
	                    // return finalZone.getNextTransition(base, inclusive);
	                    return finalZoneWithStartYear.GetNextTransition(bs,
	                            inclusive);
	                } else {
	                    // No more transitions
	                    return null;
	                }
	            }
	        }
	        if (historicRules != null) {
	            // Find a historical transition
	            int ttidx = transitionCount - 1;
	            for (; ttidx >= firstTZTransitionIdx; ttidx--) {
	                long t = ((long) transitionTimes[ttidx])
	                        * IBM.ICU.Impl.Grego.MILLIS_PER_SECOND;
	                if (bs > t || (!inclusive && bs == t)) {
	                    break;
	                }
	            }
	            if (ttidx == transitionCount - 1) {
	                return firstFinalTZTransition;
	            } else if (ttidx < firstTZTransitionIdx) {
	                return firstTZTransition;
	            } else {
	                // Create a TimeZoneTransition
	                TimeZoneRule to = historicRules[GetInt(typeData[ttidx + 1])];
	                TimeZoneRule from = historicRules[GetInt(typeData[ttidx])];
	                long startTime = ((long) transitionTimes[ttidx + 1])
	                        * IBM.ICU.Impl.Grego.MILLIS_PER_SECOND;
	
	                // The transitions loaded from zoneinfo.res may contain
	                // non-transition data
	                if (from.GetName().Equals(to.GetName())
	                        && from.GetRawOffset() == to.GetRawOffset()
	                        && from.GetDSTSavings() == to.GetDSTSavings()) {
	                    return GetNextTransition(startTime, false);
	                }
	
	                return new TimeZoneTransition(startTime, from, to);
	            }
	        }
	        return null;
	    }
	
	    /*
	     * (non-Javadoc)
	     * 
	     * @see com.ibm.icu.util.BasicTimeZone#getPreviousTransition(long, boolean)
	     */
	    public override TimeZoneTransition GetPreviousTransition(long bs, bool inclusive) {
	        InitTransitionRules();
	
	        if (finalZone != null) {
	            if (inclusive && bs == firstFinalTZTransition.GetTime()) {
	                return firstFinalTZTransition;
	            } else if (bs > firstFinalTZTransition.GetTime()) {
	                if (finalZone.UseDaylightTime()) {
	                    // return finalZone.getPreviousTransition(base, inclusive);
	                    return finalZoneWithStartYear.GetPreviousTransition(bs,
	                            inclusive);
	                } else {
	                    return firstFinalTZTransition;
	                }
	            }
	        }
	
	        if (historicRules != null) {
	            // Find a historical transition
	            int ttidx = transitionCount - 1;
	            for (; ttidx >= firstTZTransitionIdx; ttidx--) {
	                long t = ((long) transitionTimes[ttidx])
	                        * IBM.ICU.Impl.Grego.MILLIS_PER_SECOND;
	                if (bs > t || (inclusive && bs == t)) {
	                    break;
	                }
	            }
	            if (ttidx < firstTZTransitionIdx) {
	                // No more transitions
	                return null;
	            } else if (ttidx == firstTZTransitionIdx) {
	                return firstTZTransition;
	            } else {
	                // Create a TimeZoneTransition
	                TimeZoneRule to = historicRules[GetInt(typeData[ttidx])];
	                TimeZoneRule from = historicRules[GetInt(typeData[ttidx - 1])];
	                long startTime = ((long) transitionTimes[ttidx])
	                        * IBM.ICU.Impl.Grego.MILLIS_PER_SECOND;
	
	                // The transitions loaded from zoneinfo.res may contain
	                // non-transition data
	                if (from.GetName().Equals(to.GetName())
	                        && from.GetRawOffset() == to.GetRawOffset()
	                        && from.GetDSTSavings() == to.GetDSTSavings()) {
	                    return GetPreviousTransition(startTime, false);
	                }
	
	                return new TimeZoneTransition(startTime, from, to);
	            }
	        }
	        return null;
	    }
	
	    /*
	     * (non-Javadoc)
	     * 
	     * @see com.ibm.icu.util.BasicTimeZone#getTimeZoneRules()
	     */
	    public override TimeZoneRule[] GetTimeZoneRules() {
	        InitTransitionRules();
	        int size = 1;
	        if (historicRules != null) {
	            // historicRules may contain null entries when original zoneinfo
	            // data
	            // includes non transition data.
	            for (int i = 0; i < historicRules.Length; i++) {
	                if (historicRules[i] != null) {
	                    size++;
	                }
	            }
	        }
	        if (finalZone != null) {
	            if (finalZone.UseDaylightTime()) {
	                size += 2;
	            } else {
	                size++;
	            }
	        }
	
	        TimeZoneRule[] rules = new TimeZoneRule[size];
	        int idx = 0;
	        rules[idx++] = initialRule;
	
	        if (historicRules != null) {
	            for (int i_0 = 0; i_0 < historicRules.Length; i_0++) {
	                if (historicRules[i_0] != null) {
	                    rules[idx++] = historicRules[i_0];
	                }
	            }
	        }
	
	        if (finalZone != null) {
	            if (finalZone.UseDaylightTime()) {
	                TimeZoneRule[] stzr = finalZoneWithStartYear.GetTimeZoneRules();
	                // Adding only transition rules
	                rules[idx++] = stzr[1];
	                rules[idx++] = stzr[2];
	            } else {
	                // Create a TimeArrayTimeZoneRule at finalMillis
	                rules[idx++] = new TimeArrayTimeZoneRule(GetID() + "(STD)",
	                        finalZone.GetRawOffset(), 0,
	                        new long[] { (long) finalMillis },
	                        IBM.ICU.Util.DateTimeRule.UTC_TIME);
	            }
	        }
	        return rules;
	    }
	
	    private InitialTimeZoneRule initialRule;
	
	    private TimeZoneTransition firstTZTransition;
	
	    private int firstTZTransitionIdx;
	
	    private TimeZoneTransition firstFinalTZTransition;
	
	    private TimeArrayTimeZoneRule[] historicRules;
	
	    private SimpleTimeZone finalZoneWithStartYear; // hack
	
	    private bool transitionRulesInitialized;
	
	    [MethodImpl(MethodImplOptions.Synchronized)]
	    private void InitTransitionRules() {
	        if (transitionRulesInitialized) {
	            return;
	        }
	
	        initialRule = null;
	        firstTZTransition = null;
	        firstFinalTZTransition = null;
	        historicRules = null;
	        firstTZTransitionIdx = 0;
	        finalZoneWithStartYear = null;
	
	        String stdName = GetID() + "(STD)";
	        String dstName = GetID() + "(DST)";
	
	        int raw, dst;
	        if (transitionCount > 0) {
	            int transitionIdx, typeIdx;
	
	            // Note: Since 2007c, the very first transition data is a dummy
	            // entry
	            // added for resolving a offset calculation problem.
	
	            // Create initial rule
	            typeIdx = GetInt(typeData[0]); // initial type
	            raw = typeOffsets[typeIdx * 2] * IBM.ICU.Impl.Grego.MILLIS_PER_SECOND;
	            dst = typeOffsets[typeIdx * 2 + 1] * IBM.ICU.Impl.Grego.MILLIS_PER_SECOND;
	            initialRule = new InitialTimeZoneRule(
	                    ((dst == 0) ? stdName : dstName), raw, dst);
	
	            for (transitionIdx = 1; transitionIdx < transitionCount; transitionIdx++) {
	                firstTZTransitionIdx++;
	                if (typeIdx != GetInt(typeData[transitionIdx])) {
	                    break;
	                }
	            }
	            if (transitionIdx == transitionCount) {
	                // Actually no transitions...
	            } else {
	                // Build historic rule array
	                long[] times = new long[transitionCount];
	                for (typeIdx = 0; typeIdx < typeCount; typeIdx++) {
	                    // Gather all start times for each pair of offsets
	                    int nTimes = 0;
	                    for (transitionIdx = firstTZTransitionIdx; transitionIdx < transitionCount; transitionIdx++) {
	                        if (typeIdx == GetInt(typeData[transitionIdx])) {
	                            long tt = ((long) transitionTimes[transitionIdx])
	                                    * IBM.ICU.Impl.Grego.MILLIS_PER_SECOND;
	                            if (tt < finalMillis) {
	                                // Exclude transitions after finalMillis
	                                times[nTimes++] = tt;
	                            }
	                        }
	                    }
	                    if (nTimes > 0) {
	                        long[] startTimes = new long[nTimes];
	                        System.Array.Copy((Array)(times),0,(Array)(startTimes),0,nTimes);
	                        // Create a TimeArrayTimeZoneRule
	                        raw = typeOffsets[typeIdx * 2]
	                                * IBM.ICU.Impl.Grego.MILLIS_PER_SECOND;
	                        dst = typeOffsets[typeIdx * 2 + 1]
	                                * IBM.ICU.Impl.Grego.MILLIS_PER_SECOND;
	                        if (historicRules == null) {
	                            historicRules = new TimeArrayTimeZoneRule[typeCount];
	                        }
	                        historicRules[typeIdx] = new TimeArrayTimeZoneRule(
	                                ((dst == 0) ? stdName : dstName), raw, dst,
	                                startTimes, IBM.ICU.Util.DateTimeRule.UTC_TIME);
	                    }
	                }
	
	                // Create initial transition
	                typeIdx = GetInt(typeData[firstTZTransitionIdx]);
	                firstTZTransition = new TimeZoneTransition(
	                        ((long) transitionTimes[firstTZTransitionIdx])
	                                * IBM.ICU.Impl.Grego.MILLIS_PER_SECOND, initialRule,
	                        historicRules[typeIdx]);
	
	            }
	        }
	
	        if (initialRule == null) {
	            // No historic transitions
	            raw = typeOffsets[0] * IBM.ICU.Impl.Grego.MILLIS_PER_SECOND;
	            dst = typeOffsets[1] * IBM.ICU.Impl.Grego.MILLIS_PER_SECOND;
	            initialRule = new InitialTimeZoneRule(
	                    ((dst == 0) ? stdName : dstName), raw, dst);
	        }
	
	        if (finalZone != null) {
	            // Get the first occurrence of final rule starts
	            long startTime = (long) finalMillis;
	            TimeZoneRule firstFinalRule;
	            if (finalZone.UseDaylightTime()) {
	                /*
	                 * Note: When an OlsonTimeZone is constructed, we should set the
	                 * final year as the start year of finalZone. However, the
	                 * boundary condition used for getting offset from finalZone has
	                 * some problems. So setting the start year in the finalZone
	                 * will cause a problem. For now, we do not set the valid start
	                 * year when the construction time and create a clone and set
	                 * the start year when extracting rules.
	                 */
	                finalZoneWithStartYear = (SimpleTimeZone) finalZone.Clone();
	                // finalYear is 1 year before the actual final year.
	                // See the comment in the construction method.
	                finalZoneWithStartYear.SetStartYear(finalYear + 1);
	
	                TimeZoneTransition tzt = finalZoneWithStartYear
	                        .GetNextTransition(startTime, false);
	                firstFinalRule = tzt.GetTo();
	                startTime = tzt.GetTime();
	            } else {
	                finalZoneWithStartYear = finalZone;
	                firstFinalRule = new TimeArrayTimeZoneRule(finalZone.GetID(),
	                        finalZone.GetRawOffset(), 0, new long[] { startTime },
	                        IBM.ICU.Util.DateTimeRule.UTC_TIME);
	            }
	            TimeZoneRule prevRule = null;
	            if (transitionCount > 0) {
	                prevRule = historicRules[GetInt(typeData[transitionCount - 1])];
	            }
	            if (prevRule == null) {
	                // No historic transitions, but only finalZone available
	                prevRule = initialRule;
	            }
	            firstFinalTZTransition = new TimeZoneTransition(startTime,
	                    prevRule, firstFinalRule);
	        }
	
	        transitionRulesInitialized = true;
	    }
	}
}
