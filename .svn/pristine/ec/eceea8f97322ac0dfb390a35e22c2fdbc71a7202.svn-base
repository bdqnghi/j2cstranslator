/*
 *******************************************************************************
 * Copyright (C) 1996-2007, International Business Machines Corporation and    *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 */

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:30 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Text {
	
	using IBM.ICU.Impl;
	using IBM.ICU.Util;
	using ILOG.J2CsMapping.IO;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.Globalization;
	using System.IO;
	using System.Resources;
	using System.Runtime.CompilerServices;
	using System.Runtime.Serialization;
     using ILOG.J2CsMapping.Util;
     using ILOG.J2CsMapping.Util;
	
	/// <summary>
	/// <c>DateFormatSymbols</c> is a public class for encapsulating
	/// localizable date-time formatting data, such as the names of the months, the
	/// names of the days of the week, and the time zone data.
	/// <c>DateFormat</c> and <c>SimpleDateFormat</c> both use
	/// <c>DateFormatSymbols</c> to encapsulate this information.
	/// <p>
	/// Typically you shouldn't use <c>DateFormatSymbols</c> directly. Rather,
	/// you are encouraged to create a date-time formatter with the
	/// <c>DateFormat</c> class's factory methods: <c>getTimeInstance</c>, <c>getDateInstance</c>, or <c>getDateTimeInstance</c>. These
	/// methods automatically create a <c>DateFormatSymbols</c> for the
	/// formatter so that you don't have to. After the formatter is created, you may
	/// modify its format pattern using the <c>setPattern</c> method. For more
	/// information about creating formatters using <c>DateFormat</c>'s factory
	/// methods, see <see cref="T:IBM.ICU.Text.DateFormat"/>.
	/// <p>
	/// If you decide to create a date-time formatter with a specific format pattern
	/// for a specific locale, you can do so with: <blockquote>
	/// <pre>
	/// new SimpleDateFormat(aPattern, new DateFormatSymbols(aLocale)).
	/// </pre>
	/// </blockquote>
	/// <p>
	/// <c>DateFormatSymbols</c> objects are clonable. When you obtain a
	/// <c>DateFormatSymbols</c> object, feel free to modify the date-time
	/// formatting data. For instance, you can replace the localized date-time format
	/// pattern characters with the ones that you feel easy to remember. Or you can
	/// change the representative cities to your favorite ones.
	/// <p>
	/// New <c>DateFormatSymbols</c> subclasses may be added to support
	/// <c>SimpleDateFormat</c> for date-time formatting for additional
	/// locales.
	/// </summary>
	///
	/// <seealso cref="T:IBM.ICU.Text.DateFormat"/>
	/// <seealso cref="T:IBM.ICU.Text.SimpleDateFormat"/>
	/// <seealso cref="T:IBM.ICU.Text.SimpleTimeZone"/>
	/// @stable ICU 2.0
	[Serializable]
	public class DateFormatSymbols : ICloneable {
	
	    // TODO make sure local pattern char string is 18 characters long,
	    // that is, that it encompasses the new 'u' char for
	    // EXTENDED_YEAR. Two options: 1. Make sure resource data is
	    // correct; 2. Make code add in 'u' at end if len == 17.
	
	    // Constants for context
	    /// <summary>
	    /// Constant for context.
	    /// </summary>
	    ///
	    /// @draft ICU 3.6
	    /// @provisional This API might change or be removed in a future release.
	    public const int FORMAT = 0;
	
	    /// <summary>
	    /// Constant for context.
	    /// </summary>
	    ///
	    /// @draft ICU 3.6
	    /// @provisional This API might change or be removed in a future release.
	    public const int STANDALONE = 1;
	
	    /// <exclude/>
	    /// <summary>
	    /// Constant for context.
	    /// </summary>
	    ///
	    public const int DT_CONTEXT_COUNT = 2;
	
	    // Constants for width
	
	    /// <summary>
	    /// Constant for width.
	    /// </summary>
	    ///
	    /// @draft ICU 3.6
	    /// @provisional This API might change or be removed in a future release.
	    public const int ABBREVIATED = 0;
	
	    /// <summary>
	    /// Constant for width.
	    /// </summary>
	    ///
	    /// @draft ICU 3.6
	    /// @provisional This API might change or be removed in a future release.
	    public const int WIDE = 1;
	
	    /// <summary>
	    /// Constant for width.
	    /// </summary>
	    ///
	    /// @draft ICU 3.6
	    /// @provisional This API might change or be removed in a future release.
	    public const int NARROW = 2;
	
	    /// <exclude/>
	    /// <summary>
	    /// Constant for width.
	    /// </summary>
	    ///
	    public const int DT_WIDTH_COUNT = 3;
	
	    /// <summary>
	    /// Construct a DateFormatSymbols object by loading format data from
	    /// resources for the default locale.
	    /// </summary>
	    ///
	    /// <exception cref="System.Resources.MissingManifestResourceException">if the resources for the default locale cannot be found orcannot be loaded.</exception>
	    /// @stable ICU 2.0
	    public DateFormatSymbols() {
	        this.eras = null;
	        this.eraNames = null;
	        this.narrowEras = null;
	        this.months = null;
	        this.shortMonths = null;
	        this.narrowMonths = null;
	        this.standaloneMonths = null;
	        this.standaloneShortMonths = null;
	        this.standaloneNarrowMonths = null;
	        this.weekdays = null;
	        this.shortWeekdays = null;
	        this.narrowWeekdays = null;
	        this.standaloneWeekdays = null;
	        this.standaloneShortWeekdays = null;
	        this.standaloneNarrowWeekdays = null;
	        this.ampms = null;
	        this.shortQuarters = null;
	        this.quarters = null;
	        this.standaloneShortQuarters = null;
	        this.standaloneQuarters = null;
	        this.gmtFormat = null;
	        this.gmtHourFormats = null;
	        this.zoneStrings = null;
	        this.zsformat = null;
	        this.localPatternChars = null;
	        InitializeData(IBM.ICU.Util.ULocale.GetDefault(), ""); // TODO: type?
	    }
	
	    /// <summary>
	    /// Construct a DateFormatSymbols object by loading format data from
	    /// resources for the given locale.
	    /// </summary>
	    ///
	    /// <exception cref="System.Resources.MissingManifestResourceException">if the resources for the specified locale cannot be found orcannot be loaded.</exception>
	    /// @stable ICU 2.0
        public DateFormatSymbols(Locale locale)
        {
	        this.eras = null;
	        this.eraNames = null;
	        this.narrowEras = null;
	        this.months = null;
	        this.shortMonths = null;
	        this.narrowMonths = null;
	        this.standaloneMonths = null;
	        this.standaloneShortMonths = null;
	        this.standaloneNarrowMonths = null;
	        this.weekdays = null;
	        this.shortWeekdays = null;
	        this.narrowWeekdays = null;
	        this.standaloneWeekdays = null;
	        this.standaloneShortWeekdays = null;
	        this.standaloneNarrowWeekdays = null;
	        this.ampms = null;
	        this.shortQuarters = null;
	        this.quarters = null;
	        this.standaloneShortQuarters = null;
	        this.standaloneQuarters = null;
	        this.gmtFormat = null;
	        this.gmtHourFormats = null;
	        this.zoneStrings = null;
	        this.zsformat = null;
	        this.localPatternChars = null;
	        InitializeData(IBM.ICU.Util.ULocale.ForLocale(locale), ""); // TODO: type?
	    }
	
	    /// <summary>
	    /// Construct a DateFormatSymbols object by loading format data from
	    /// resources for the given ulocale.
	    /// </summary>
	    ///
	    /// <exception cref="System.Resources.MissingManifestResourceException">if the resources for the specified locale cannot be found orcannot be loaded.</exception>
	    /// @stable ICU 3.2
	    public DateFormatSymbols(ULocale locale) {
	        this.eras = null;
	        this.eraNames = null;
	        this.narrowEras = null;
	        this.months = null;
	        this.shortMonths = null;
	        this.narrowMonths = null;
	        this.standaloneMonths = null;
	        this.standaloneShortMonths = null;
	        this.standaloneNarrowMonths = null;
	        this.weekdays = null;
	        this.shortWeekdays = null;
	        this.narrowWeekdays = null;
	        this.standaloneWeekdays = null;
	        this.standaloneShortWeekdays = null;
	        this.standaloneNarrowWeekdays = null;
	        this.ampms = null;
	        this.shortQuarters = null;
	        this.quarters = null;
	        this.standaloneShortQuarters = null;
	        this.standaloneQuarters = null;
	        this.gmtFormat = null;
	        this.gmtHourFormats = null;
	        this.zoneStrings = null;
	        this.zsformat = null;
	        this.localPatternChars = null;
	        InitializeData(locale, ""); // TODO: type?
	    }
	
	    /// <summary>
	    /// Gets a DateFormatSymbols instance for the default locale. <br>
	    /// <br>
	    /// <b>Note:</b> Unlike <c>java.text.DateFormatSymbols#getInstance</c>,
	    /// this method simply returns
	    /// <c>new com.ibm.icu.text.DateFormatSymbols()</c>. ICU does not
	    /// support <c>DateFormatSymbolsProvider</c> introduced in Java 6 or
	    /// its equivalent implementation for now.
	    /// </summary>
	    ///
	    /// <returns>A DateFormatSymbols instance.</returns>
	    /// @stable ICU 3.8
	    public static DateFormatSymbols GetInstance() {
	        return new DateFormatSymbols();
	    }
	
	    /// <summary>
	    /// Gets a DateFormatSymbols instance for the given locale. <br>
	    /// <br>
	    /// <b>Note:</b> Unlike <c>java.text.DateFormatSymbols#getInstance</c>,
	    /// this method simply returns
	    /// <c>new com.ibm.icu.text.DateFormatSymbols(locale)</c>. ICU does not
	    /// support <c>DateFormatSymbolsProvider</c> introduced in Java 6 or
	    /// its equivalent implementation for now.
	    /// </summary>
	    ///
	    /// <param name="locale">the locale.</param>
	    /// <returns>A DateFormatSymbols instance.</returns>
	    /// @stable ICU 3.8
        public static DateFormatSymbols GetInstance(Locale locale)
        {
	        return new DateFormatSymbols(locale);
	    }
	
	    /// <summary>
	    /// Gets a DateFormatSymbols instance for the given locale. <br>
	    /// <br>
	    /// <b>Note:</b> Unlike <c>java.text.DateFormatSymbols#getInstance</c>,
	    /// this method simply returns
	    /// <c>new com.ibm.icu.text.DateFormatSymbols(locale)</c>. ICU does not
	    /// support <c>DateFormatSymbolsProvider</c> introduced in Java 6 or
	    /// its equivalent implementation for now.
	    /// </summary>
	    ///
	    /// <param name="locale">the locale.</param>
	    /// <returns>A DateFormatSymbols instance.</returns>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public static DateFormatSymbols GetInstance(ULocale locale) {
	        return new DateFormatSymbols(locale);
	    }
	
	    /// <summary>
	    /// Returns an array of all locales for which the <c>getInstance</c>
	    /// methods of this class can return localized instances. <br>
	    /// <br>
	    /// <b>Note:</b> Unlike
	    /// <c>java.text.DateFormatSymbols#getAvailableLocales</c>, this method
	    /// simply returns the array of <c>Locale</c>s available in this class.
	    /// ICU does not support <c>DateFormatSymbolsProvider</c> introduced in
	    /// Java 6 or its equivalent implementation for now.
	    /// </summary>
	    ///
	    /// <returns>An array of <c>Locale</c>s for which localized
	    /// <c>DateFormatSymbols</c> instances are available.</returns>
	    /// @stable ICU 3.8
        public static Locale[] GetAvailableLocales()
        {
	        return IBM.ICU.Impl.ICUResourceBundle
	                .GetAvailableLocales(IBM.ICU.Impl.ICUResourceBundle.ICU_BASE_NAME);
	    }
	
	    /// <summary>
	    /// Returns an array of all locales for which the <c>getInstance</c>
	    /// methods of this class can return localized instances. <br>
	    /// <br>
	    /// <b>Note:</b> Unlike
	    /// <c>java.text.DateFormatSymbols#getAvailableLocales</c>, this method
	    /// simply returns the array of <c>ULocale</c>s available in this
	    /// class. ICU does not support <c>DateFormatSymbolsProvider</c>
	    /// introduced in Java 6 or its equivalent implementation for now.
	    /// </summary>
	    ///
	    /// <returns>An array of <c>ULocale</c>s for which localized
	    /// <c>DateFormatSymbols</c> instances are available.</returns>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public static ULocale[] GetAvailableULocales() {
	        return IBM.ICU.Impl.ICUResourceBundle
	                .GetAvailableULocales(IBM.ICU.Impl.ICUResourceBundle.ICU_BASE_NAME);
	    }
	
	    /// <summary>
	    /// Era strings. For example: "AD" and "BC". An array of 2 strings, indexed by <c>Calendar.BC</c> and <c>Calendar.AD</c>.
	    /// </summary>
	    ///
	    /// @serial
	    internal String[] eras;
	
	    /// <summary>
	    /// Era name strings. For example: "Anno Domini" and "Before Christ". An array of 2 strings, indexed by <c>Calendar.BC</c> and <c>Calendar.AD</c>.
	    /// </summary>
	    ///
	    /// @serial
	    internal String[] eraNames;
	
	    /// <summary>
	    /// Narrow era names. For example: "A" and "B". An array of 2 strings, indexed by <c>Calendar.BC</c> and <c>Calendar.AD</c>.
	    /// </summary>
	    ///
	    /// @serial
	    internal String[] narrowEras;
	
	    /// <summary>
	    /// Month strings. For example: "January", "February", etc. An array of 13 strings (some calendars have 13 months), indexed by <c>Calendar.JANUARY</c>, <c>Calendar.FEBRUARY</c>, etc.
	    /// </summary>
	    ///
	    /// @serial
	    internal String[] months;
	
	    /// <summary>
	    /// Short month strings. For example: "Jan", "Feb", etc. An array of 13 strings (some calendars have 13 months), indexed by <c>Calendar.JANUARY</c>, <c>Calendar.FEBRUARY</c>, etc.
	    /// </summary>
	    ///
	    /// @serial
	    internal String[] shortMonths;
	
	    /// <summary>
	    /// Narrow month strings. For example: "J", "F", etc. An array of 13 strings (some calendars have 13 months), indexed by <c>Calendar.JANUARY</c> , <c>Calendar.FEBRUARY</c>, etc.
	    /// </summary>
	    ///
	    /// @serial
	    internal String[] narrowMonths;
	
	    /// <summary>
	    /// Standalone month strings. For example: "January", "February", etc. An array of 13 strings (some calendars have 13 months), indexed by <c>Calendar.JANUARY</c>, <c>Calendar.FEBRUARY</c>, etc.
	    /// </summary>
	    ///
	    /// @serial
	    internal String[] standaloneMonths;
	
	    /// <summary>
	    /// Standalone short month strings. For example: "Jan", "Feb", etc. An array of 13 strings (some calendars have 13 months), indexed by <c>Calendar.JANUARY</c>, <c>Calendar.FEBRUARY</c>, etc.
	    /// </summary>
	    ///
	    /// @serial
	    internal String[] standaloneShortMonths;
	
	    /// <summary>
	    /// Standalone narrow month strings. For example: "J", "F", etc. An array of 13 strings (some calendars have 13 months), indexed by <c>Calendar.JANUARY</c>, <c>Calendar.FEBRUARY</c>, etc.
	    /// </summary>
	    ///
	    /// @serial
	    internal String[] standaloneNarrowMonths;
	
	    /// <summary>
	    /// Weekday strings. For example: "Sunday", "Monday", etc. An array of 8 strings, indexed by <c>Calendar.SUNDAY</c>, <c>Calendar.MONDAY</c>, etc. The element <c>weekdays[0]</c> is ignored.
	    /// </summary>
	    ///
	    /// @serial
	    internal String[] weekdays;
	
	    /// <summary>
	    /// Short weekday strings. For example: "Sun", "Mon", etc. An array of 8 strings, indexed by <c>Calendar.SUNDAY</c>, <c>Calendar.MONDAY</c>, etc. The element <c>shortWeekdays[0]</c> is ignored.
	    /// </summary>
	    ///
	    /// @serial
	    internal String[] shortWeekdays;
	
	    /// <summary>
	    /// Narrow weekday strings. For example: "S", "M", etc. An array of 8 strings, indexed by <c>Calendar.SUNDAY</c>, <c>Calendar.MONDAY</c>, etc. The element <c>narrowWeekdays[0]</c> is ignored.
	    /// </summary>
	    ///
	    /// @serial
	    internal String[] narrowWeekdays;
	
	    /// <summary>
	    /// Standalone weekday strings. For example: "Sunday", "Monday", etc. An array of 8 strings, indexed by <c>Calendar.SUNDAY</c>, <c>Calendar.MONDAY</c>, etc. The element <c>standaloneWeekdays[0]</c> is ignored.
	    /// </summary>
	    ///
	    /// @serial
	    internal String[] standaloneWeekdays;
	
	    /// <summary>
	    /// Standalone short weekday strings. For example: "Sun", "Mon", etc. An array of 8 strings, indexed by <c>Calendar.SUNDAY</c>, <c>Calendar.MONDAY</c>, etc. The element <c>standaloneShortWeekdays[0]</c> is ignored.
	    /// </summary>
	    ///
	    /// @serial
	    internal String[] standaloneShortWeekdays;
	
	    /// <summary>
	    /// Standalone narrow weekday strings. For example: "S", "M", etc. An array of 8 strings, indexed by <c>Calendar.SUNDAY</c>, <c>Calendar.MONDAY</c>, etc. The element <c>standaloneNarrowWeekdays[0]</c> is ignored.
	    /// </summary>
	    ///
	    /// @serial
	    internal String[] standaloneNarrowWeekdays;
	
	    /// <summary>
	    /// AM and PM strings. For example: "AM" and "PM". An array of 2 strings, indexed by <c>Calendar.AM</c> and <c>Calendar.PM</c>.
	    /// </summary>
	    ///
	    /// @serial
	    internal String[] ampms;
	
	    /// <summary>
	    /// Abbreviated quarter names. For example: "Q1", "Q2", "Q3", "Q4". An array of 4 strings indexed by the month divided by 3.
	    /// </summary>
	    ///
	    /// @serial
	    internal String[] shortQuarters;
	
	    /// <summary>
	    /// Full quarter names. For example: "1st Quarter", "2nd Quarter", "3rd Quarter", "4th Quarter". An array of 4 strings, indexed by the month divided by 3.
	    /// </summary>
	    ///
	    /// @serial
	    internal String[] quarters;
	
	    /// <summary>
	    /// Standalone abbreviated quarter names. For example: "Q1", "Q2", "Q3", "Q4". An array of 4 strings indexed by the month divided by 3.
	    /// </summary>
	    ///
	    /// @serial
	    internal String[] standaloneShortQuarters;
	
	    /// <summary>
	    /// Standalone full quarter names. For example: "1st Quarter", "2nd Quarter", "3rd Quarter", "4th Quarter". An array of 4 strings, indexed by the month divided by 3.
	    /// </summary>
	    ///
	    /// @serial
	    internal String[] standaloneQuarters;
	
	    /// <summary>
	    /// Pattern string used for localized time zone GMT format. For example,
	    /// "GMT{0}"
	    /// </summary>
	    ///
	    /// @serial
	    internal String gmtFormat;
	
	    /// <summary>
	    /// Pattern strings used for formatting zone offset in a localized time zone GMT string. This is 2x2 String array holding followings [0][0] Negative H + m + s [0][1] Negative H + m [1][0] Positive H + m + s [1][1] Positive H + m
	    /// </summary>
	    ///
	    /// @serial
	    internal String[][] gmtHourFormats;
	
	    /// <summary>
	    /// Localized names of time zones in this locale. This is a two-dimensional array of strings of size <em>n</em> by <em>m</em>, where <em>m</em> is at least 5 and up to 7. Each of the <em>n</em> rows is an entry containing the localized names for a single <c>TimeZone</c>. Each such row contains (with <c>i</c> ranging from 0..<em>n</em>-1): <ul> <li><c>zoneStrings[i][0]</c> - time zone ID</li> <li><c>zoneStrings[i][1]</c> - long name of zone in standard time</li> <li><c>zoneStrings[i][2]</c> - short name of zone in standard time</li> <li><c>zoneStrings[i][3]</c> - long name of zone in daylight savings time</li> <li><c>zoneStrings[i][4]</c> - short name of zone in daylight savings time</li> <li><c>zoneStrings[i][5]</c> - location name of zone</li> <li><c>zoneStrings[i][6]</c> - long generic name of zone</li> <li><c>zoneStrings[i][7]</c> - short generic of zone</li> The zone ID is <em>not</em> localized; it corresponds to the ID value associated with a system time zone object. All other entries are localized names. If a zone does not implement daylight savings time, the daylight savings time names are ignored. <em>Note:</em>CLDR 1.5 introduced metazone and its historical mappings. This simple two-dimensional array is no longer sufficient to represent localized names and its historic changes. Since ICU 3.8.1, localized zone names extracted from ICU locale data is stored in a ZoneStringFormat instance. But we still need to support the old way of customizing localized zone names, so we keep this field for the purpose.
	    /// </summary>
	    ///
	    /// <seealso cref="T:IBM.ICU.Text.TimeZone"/>
	    /// @serial
	    private String[][] zoneStrings;
	
	    /// <summary>
	    /// Since ICU 3.8.1, we use ZoneStringFormat to access localized zone names.
	    /// This field remains null unless setZoneStrings is called.
	    /// </summary>
	    ///
	    private ZoneStringFormat zsformat;
	
	    /// <summary>
	    /// Unlocalized date-time pattern characters. For example: 'y', 'd', etc. All
	    /// locales use the same unlocalized pattern characters.
	    /// </summary>
	    ///
	    internal const String patternChars = "GyMdkHmsSEDFwWahKzYeugAZvcLQqV";
	
	    /// <summary>
	    /// Localized date-time pattern characters. For example, a locale may wish to
	    /// use 'u' rather than 'y' to represent years in its date format pattern
	    /// strings. This string must be exactly 18 characters long, with the index
	    /// of the characters described by <c>DateFormat.ERA_FIELD</c>,
	    /// <c>DateFormat.YEAR_FIELD</c>, etc. Thus, if the string were
	    /// "Xz...", then localized patterns would use 'X' for era and 'z' for year.
	    /// </summary>
	    ///
	    /// @serial
	    internal String localPatternChars;
	
	    /* use serialVersionUID from JDK 1.1.4 for interoperability */
	    private const long serialVersionUID = -5987973545549424702L;
	
	    /// <summary>
	    /// Gets era strings. For example: "AD" and "BC".
	    /// </summary>
	    ///
	    /// <returns>the era strings.</returns>
	    /// @stable ICU 2.0
	    public String[] GetEras() {
	        return Duplicate(eras);
	    }
	
	    /// <summary>
	    /// Sets era strings. For example: "AD" and "BC".
	    /// </summary>
	    ///
	    /// <param name="newEras">the new era strings.</param>
	    /// @stable ICU 2.0
	    public void SetEras(String[] newEras) {
	        eras = Duplicate(newEras);
	    }
	
	    /// <summary>
	    /// Gets era name strings. For example: "Anno Domini" and "Before Christ".
	    /// </summary>
	    ///
	    /// <returns>the era strings.</returns>
	    /// @stable ICU 3.4
	    public String[] GetEraNames() {
	        return Duplicate(eraNames);
	    }
	
	    /// <summary>
	    /// Sets era name strings. For example: "Anno Domini" and "Before Christ".
	    /// </summary>
	    ///
	    /// <param name="newEraNames">the new era strings.</param>
	    /// @stable ICU 3.8
	    public void SetEraNames(String[] newEraNames) {
	        eraNames = Duplicate(newEraNames);
	    }
	
	    /// <summary>
	    /// Gets month strings. For example: "January", "February", etc.
	    /// </summary>
	    ///
	    /// <returns>the month strings.</returns>
	    /// @stable ICU 2.0
	    public String[] GetMonths() {
	        return Duplicate(months);
	    }
	
	    /// <summary>
	    /// Gets month strings. For example: "January", "February", etc.
	    /// </summary>
	    ///
	    /// <param name="context">The month context, FORMAT or STANDALONE.</param>
	    /// <param name="width">The width or the returned month string, either WIDE,ABBREVIATED, or NARROW.</param>
	    /// <returns>the month strings.</returns>
	    /// @stable ICU 3.4
	    public String[] GetMonths(int context, int width) {
	        String[] returnValue = null;
	        switch (context) {
	        case FORMAT:
	            switch (width) {
	            case WIDE:
	                returnValue = months;
	                break;
	            case ABBREVIATED:
	                returnValue = shortMonths;
	                break;
	            case NARROW:
	                returnValue = narrowMonths;
	                break;
	            }
	            break;
	        case STANDALONE:
	            switch (width) {
	            case WIDE:
	                returnValue = standaloneMonths;
	                break;
	            case ABBREVIATED:
	                returnValue = standaloneShortMonths;
	                break;
	            case NARROW:
	                returnValue = standaloneNarrowMonths;
	                break;
	            }
	            break;
	        }
	        return Duplicate(returnValue);
	    }
	
	    /// <summary>
	    /// Sets month strings. For example: "January", "February", etc.
	    /// </summary>
	    ///
	    /// <param name="newMonths">the new month strings.</param>
	    /// @stable ICU 2.0
	    public void SetMonths(String[] newMonths) {
	        months = Duplicate(newMonths);
	    }
	
	    /// <summary>
	    /// Sets month strings. For example: "January", "February", etc.
	    /// </summary>
	    ///
	    /// <param name="newMonths">the new month strings.</param>
	    /// <param name="context">The formatting context, FORMAT or STANDALONE.</param>
	    /// <param name="width">The width of the month string, either WIDE, ABBREVIATED, orNARROW.</param>
	    /// @stable ICU 3.8
	    public void SetMonths(String[] newMonths, int context, int width) {
	        switch (context) {
	        case FORMAT:
	            switch (width) {
	            case WIDE:
	                months = Duplicate(newMonths);
	                break;
	            case ABBREVIATED:
	                shortMonths = Duplicate(newMonths);
	                break;
	            case NARROW:
	                narrowMonths = Duplicate(newMonths);
	                break;
	            }
	            break;
	        case STANDALONE:
	            switch (width) {
	            case WIDE:
	                standaloneMonths = Duplicate(newMonths);
	                break;
	            case ABBREVIATED:
	                standaloneShortMonths = Duplicate(newMonths);
	                break;
	            case NARROW:
	                standaloneNarrowMonths = Duplicate(newMonths);
	                break;
	            }
	            break;
	        }
	    }
	
	    /// <summary>
	    /// Gets short month strings. For example: "Jan", "Feb", etc.
	    /// </summary>
	    ///
	    /// <returns>the short month strings.</returns>
	    /// @stable ICU 2.0
	    public String[] GetShortMonths() {
	        return Duplicate(shortMonths);
	    }
	
	    /// <summary>
	    /// Sets short month strings. For example: "Jan", "Feb", etc.
	    /// </summary>
	    ///
	    /// <param name="newShortMonths">the new short month strings.</param>
	    /// @stable ICU 2.0
	    public void SetShortMonths(String[] newShortMonths) {
	        shortMonths = Duplicate(newShortMonths);
	    }
	
	    /// <summary>
	    /// Gets weekday strings. For example: "Sunday", "Monday", etc.
	    /// </summary>
	    ///
	    /// <returns>the weekday strings. Use <c>Calendar.SUNDAY</c>,
	    /// <c>Calendar.MONDAY</c>, etc. to index the result array.</returns>
	    /// @stable ICU 2.0
	    public String[] GetWeekdays() {
	        return Duplicate(weekdays);
	    }
	
	    /// <summary>
	    /// Gets weekday strings. For example: "Sunday", "Monday", etc.
	    /// </summary>
	    ///
	    /// <returns>the weekday strings. Use <c>Calendar.SUNDAY</c>,
	    /// <c>Calendar.MONDAY</c>, etc. to index the result array.</returns>
	    /// <param name="context">Formatting context, either FORMAT or STANDALONE.</param>
	    /// <param name="width">Width of strings to be returned, either WIDE, ABBREVIATED, orNARROW</param>
	    /// @stable ICU 3.4
	    public String[] GetWeekdays(int context, int width) {
	        String[] returnValue = null;
	        switch (context) {
	        case FORMAT:
	            switch (width) {
	            case WIDE:
	                returnValue = weekdays;
	                break;
	            case ABBREVIATED:
	                returnValue = shortWeekdays;
	                break;
	            case NARROW:
	                returnValue = narrowWeekdays;
	                break;
	            }
	            break;
	        case STANDALONE:
	            switch (width) {
	            case WIDE:
	                returnValue = standaloneWeekdays;
	                break;
	            case ABBREVIATED:
	                returnValue = standaloneShortWeekdays;
	                break;
	            case NARROW:
	                returnValue = standaloneNarrowWeekdays;
	                break;
	            }
	            break;
	        }
	        return Duplicate(returnValue);
	    }
	
	    /// <summary>
	    /// Sets weekday strings. For example: "Sunday", "Monday", etc.
	    /// </summary>
	    ///
	    /// <param name="newWeekdays">The new weekday strings.</param>
	    /// <param name="context">The formatting context, FORMAT or STANDALONE.</param>
	    /// <param name="width">The width of the strings, either WIDE, ABBREVIATED, or NARROW.</param>
	    /// @stable ICU 3.8
	    public void SetWeekdays(String[] newWeekdays, int context, int width) {
	        switch (context) {
	        case FORMAT:
	            switch (width) {
	            case WIDE:
	                weekdays = Duplicate(newWeekdays);
	                break;
	            case ABBREVIATED:
	                shortWeekdays = Duplicate(newWeekdays);
	                break;
	            case NARROW:
	                narrowWeekdays = Duplicate(newWeekdays);
	                break;
	            }
	            break;
	        case STANDALONE:
	            switch (width) {
	            case WIDE:
	                standaloneWeekdays = Duplicate(newWeekdays);
	                break;
	            case ABBREVIATED:
	                standaloneShortWeekdays = Duplicate(newWeekdays);
	                break;
	            case NARROW:
	                standaloneNarrowWeekdays = Duplicate(newWeekdays);
	                break;
	            }
	            break;
	        }
	    }
	
	    /// <summary>
	    /// Sets weekday strings. For example: "Sunday", "Monday", etc.
	    /// </summary>
	    ///
	    /// <param name="newWeekdays">the new weekday strings. The array should be indexed by<c>Calendar.SUNDAY</c>, <c>Calendar.MONDAY</c>,etc.</param>
	    /// @stable ICU 2.0
	    public void SetWeekdays(String[] newWeekdays) {
	        weekdays = Duplicate(newWeekdays);
	    }
	
	    /// <summary>
	    /// Gets short weekday strings. For example: "Sun", "Mon", etc.
	    /// </summary>
	    ///
	    /// <returns>the short weekday strings. Use <c>Calendar.SUNDAY</c>,
	    /// <c>Calendar.MONDAY</c>, etc. to index the result array.</returns>
	    /// @stable ICU 2.0
	    public String[] GetShortWeekdays() {
	        return Duplicate(shortWeekdays);
	    }
	
	    /// <summary>
	    /// Sets short weekday strings. For example: "Sun", "Mon", etc.
	    /// </summary>
	    ///
	    /// <param name="newShortWeekdays">the new short weekday strings. The array should be indexed by<c>Calendar.SUNDAY</c>, <c>Calendar.MONDAY</c>,etc.</param>
	    /// @stable ICU 2.0
	    public void SetShortWeekdays(String[] newShortWeekdays) {
	        shortWeekdays = Duplicate(newShortWeekdays);
	    }
	
	    /// <summary>
	    /// Gets quarter strings. For example: "1st Quarter", "2nd Quarter", etc.
	    /// </summary>
	    ///
	    /// <param name="context">The quarter context, FORMAT or STANDALONE.</param>
	    /// <param name="width">The width or the returned quarter string, either WIDE orABBREVIATED. There are no NARROW quarters.</param>
	    /// <returns>the quarter strings.</returns>
	    /// @draft ICU 3.6
	    /// @provisional This API might change or be removed in a future release.
	    public String[] GetQuarters(int context, int width) {
	        String[] returnValue = null;
	        switch (context) {
	        case FORMAT:
	            switch (width) {
	            case WIDE:
	                returnValue = quarters;
	                break;
	            case ABBREVIATED:
	                returnValue = shortQuarters;
	                break;
	            case NARROW:
	                returnValue = null;
	                break;
	            }
	            break;
	
	        case STANDALONE:
	            switch (width) {
	            case WIDE:
	                returnValue = standaloneQuarters;
	                break;
	            case ABBREVIATED:
	                returnValue = standaloneShortQuarters;
	                break;
	            case NARROW:
	                returnValue = null;
	                break;
	            }
	            break;
	        }
	        return Duplicate(returnValue);
	    }
	
	    /// <summary>
	    /// Sets quarter strings. For example: "1st Quarter", "2nd Quarter", etc.
	    /// </summary>
	    ///
	    /// <param name="newQuarters">the new quarter strings.</param>
	    /// <param name="context">The formatting context, FORMAT or STANDALONE.</param>
	    /// <param name="width">The width of the quarter string, either WIDE or ABBREVIATED.There are no NARROW quarters.</param>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public void SetQuarters(String[] newQuarters, int context, int width) {
	        switch (context) {
	        case FORMAT:
	            switch (width) {
	            case WIDE:
	                quarters = Duplicate(newQuarters);
	                break;
	            case ABBREVIATED:
	                shortQuarters = Duplicate(newQuarters);
	                break;
	            case NARROW:
	                // narrowQuarters = duplicate(newQuarters);
	                break;
	            }
	            break;
	        case STANDALONE:
	            switch (width) {
	            case WIDE:
	                standaloneQuarters = Duplicate(newQuarters);
	                break;
	            case ABBREVIATED:
	                standaloneShortQuarters = Duplicate(newQuarters);
	                break;
	            case NARROW:
	                // standaloneNarrowQuarters = duplicate(newQuarters);
	                break;
	            }
	            break;
	        }
	    }
	
	    /// <summary>
	    /// Gets ampm strings. For example: "AM" and "PM".
	    /// </summary>
	    ///
	    /// <returns>the weekday strings.</returns>
	    /// @stable ICU 2.0
	    public String[] GetAmPmStrings() {
	        return Duplicate(ampms);
	    }
	
	    /// <summary>
	    /// Sets ampm strings. For example: "AM" and "PM".
	    /// </summary>
	    ///
	    /// <param name="newAmpms">the new ampm strings.</param>
	    /// @stable ICU 2.0
	    public void SetAmPmStrings(String[] newAmpms) {
	        ampms = Duplicate(newAmpms);
	    }
	
	    /// <summary>
	    /// Gets timezone strings.
	    /// </summary>
	    ///
	    /// <returns>the timezone strings.</returns>
	    /// @stable ICU 2.0
	    public String[][] GetZoneStrings() {
	        if (zoneStrings != null) {
	            return Duplicate(zoneStrings);
	        }
	        return IBM.ICU.Impl.ZoneStringFormat.GetInstance(requestedLocale).GetZoneStrings();
	    }
	
	    /// <summary>
	    /// Sets timezone strings.
	    /// </summary>
	    ///
	    /// <param name="newZoneStrings">the new timezone strings.</param>
	    /// @stable ICU 2.0
	    public void SetZoneStrings(String[][] newZoneStrings) {
	        zoneStrings = Duplicate(newZoneStrings);
	        zsformat = new ZoneStringFormat(zoneStrings);
	    }
	
	    /// <summary>
	    /// Gets localized date-time pattern characters. For example: 'u', 't', etc.
	    /// <p>
	    /// Note: ICU no longer provides localized date-time pattern characters for a
	    /// locale starting ICU 3.8. This method returns the non-localized date-time
	    /// pattern characters unless user defined localized data is set by
	    /// setLocalPatternChars.
	    /// </summary>
	    ///
	    /// <returns>the localized date-time pattern characters.</returns>
	    /// @stable ICU 2.0
	    public String GetLocalPatternChars() {
	        return localPatternChars;
	    }
	
	    /// <summary>
	    /// Sets localized date-time pattern characters. For example: 'u', 't', etc.
	    /// </summary>
	    ///
	    /// <param name="newLocalPatternChars">the new localized date-time pattern characters.</param>
	    /// @stable ICU 2.0
	    public void SetLocalPatternChars(String newLocalPatternChars) {
	        localPatternChars = newLocalPatternChars;
	    }
	
	    /// <summary>
	    /// Overrides Cloneable
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public virtual Object Clone() {
	        try {
	            DateFormatSymbols other = (DateFormatSymbols) base.MemberwiseClone();
	            return other;
	        } catch (Exception e) {
	            // /CLOVER:OFF
	            throw new InvalidOperationException();
	            // /CLOVER:ON
	        }
	    }
	
	    /// <summary>
	    /// Override hashCode. Generates a hash code for the DateFormatSymbols
	    /// object.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public override int GetHashCode() {
	        // Is this sufficient?
	        return requestedLocale.ToString().GetHashCode();
	    }
	
	    /// <summary>
	    /// Override equals
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public override bool Equals(Object obj) {
	        if ((Object) this == obj)
	            return true;
	        if (obj == null || (Object) GetType() != (Object) obj.GetType())
	            return false;
	        DateFormatSymbols that = (DateFormatSymbols) obj;
	        return (IBM.ICU.Impl.Utility.ArrayEquals(eras, that.eras)
	                && IBM.ICU.Impl.Utility.ArrayEquals(eraNames, that.eraNames)
	                && IBM.ICU.Impl.Utility.ArrayEquals(months, that.months)
	                && IBM.ICU.Impl.Utility.ArrayEquals(shortMonths, that.shortMonths)
	                && IBM.ICU.Impl.Utility.ArrayEquals(narrowMonths, that.narrowMonths)
	                && IBM.ICU.Impl.Utility.ArrayEquals(standaloneMonths, that.standaloneMonths)
	                && IBM.ICU.Impl.Utility.ArrayEquals(standaloneShortMonths,
	                        that.standaloneShortMonths)
	                && IBM.ICU.Impl.Utility.ArrayEquals(standaloneNarrowMonths,
	                        that.standaloneNarrowMonths)
	                && IBM.ICU.Impl.Utility.ArrayEquals(weekdays, that.weekdays)
	                && IBM.ICU.Impl.Utility.ArrayEquals(shortWeekdays, that.shortWeekdays)
	                && IBM.ICU.Impl.Utility.ArrayEquals(narrowWeekdays, that.narrowWeekdays)
	                && IBM.ICU.Impl.Utility.ArrayEquals(standaloneWeekdays,
	                        that.standaloneWeekdays)
	                && IBM.ICU.Impl.Utility.ArrayEquals(standaloneShortWeekdays,
	                        that.standaloneShortWeekdays)
	                && IBM.ICU.Impl.Utility.ArrayEquals(standaloneNarrowWeekdays,
	                        that.standaloneNarrowWeekdays)
	                && IBM.ICU.Impl.Utility.ArrayEquals(ampms, that.ampms)
	                && gmtFormat.Equals(that.gmtFormat)
	                && ArrayOfArrayEquals(gmtHourFormats, that.gmtHourFormats)
	                && ArrayOfArrayEquals(zoneStrings, that.zoneStrings)
	                // getDiplayName maps deprecated country and language codes to
	                // the current ones
	                // too bad there is no way to get the current codes!
	                // I thought canolicalize() would map the codes but .. alas! it
	                // doesn't.
	                && requestedLocale.GetDisplayName().Equals(
	                        that.requestedLocale.GetDisplayName()) && IBM.ICU.Impl.Utility
	                .ArrayEquals(localPatternChars, that.localPatternChars));
	    }
	
	    // =======================privates===============================
	
	    /*
	     * Useful constant for defining timezone offsets.
	     */
	    internal const int millisPerHour = 60 * 60 * 1000;
	
	    // DateFormatSymbols cache
	    private static ICUCache DFSCACHE = new SimpleCache();
	
	    /// <summary>
	    /// Initialize format symbols for the locale and calendar type
	    /// </summary>
	    ///
	    /// <param name="desiredLocale">The locale whose symbols are desired.</param>
	    /// <param name="type">The calendar type whose date format symbols are desired.</param>
	    /// @stable ICU 3.0
	    // TODO: This protected seems to be marked as @stable accidentally.
	    // We may need to deescalate this API to @internal.
	    protected internal void InitializeData(ULocale desiredLocale, String type) {
	        String key = desiredLocale.ToString() + "+" + type;
	        DateFormatSymbols dfs = (DateFormatSymbols) DFSCACHE.Get(key);
	        if (dfs == null) {
	            // Initialize data from scratch put a clone of this instance into
	            // the cache
	            CalendarData calData = new CalendarData(desiredLocale, type);
	            InitializeData(desiredLocale, calData);
	            dfs = (DateFormatSymbols) this.Clone();
	            DFSCACHE.Put(key, dfs);
	        } else {
	            InitializeData(dfs);
	        }
	    }
	
	    /*
	     * Initialize format symbols using another instance.
	     * 
	     * TODO Clean up initialization methods for subclasses
	     */
	    internal virtual void InitializeData(DateFormatSymbols dfs) {
	        this.eras = dfs.eras;
	        this.eraNames = dfs.eraNames;
	        this.narrowEras = dfs.narrowEras;
	        this.months = dfs.months;
	        this.shortMonths = dfs.shortMonths;
	        this.narrowMonths = dfs.narrowMonths;
	        this.standaloneMonths = dfs.standaloneMonths;
	        this.standaloneShortMonths = dfs.standaloneShortMonths;
	        this.standaloneNarrowMonths = dfs.standaloneNarrowMonths;
	        this.weekdays = dfs.weekdays;
	        this.shortWeekdays = dfs.shortWeekdays;
	        this.narrowWeekdays = dfs.narrowWeekdays;
	        this.standaloneWeekdays = dfs.standaloneWeekdays;
	        this.standaloneShortWeekdays = dfs.standaloneShortWeekdays;
	        this.standaloneNarrowWeekdays = dfs.standaloneNarrowWeekdays;
	        this.ampms = dfs.ampms;
	        this.shortQuarters = dfs.shortQuarters;
	        this.quarters = dfs.quarters;
	        this.standaloneShortQuarters = dfs.standaloneShortQuarters;
	        this.standaloneQuarters = dfs.standaloneQuarters;
	
	        this.gmtFormat = dfs.gmtFormat;
	        this.gmtHourFormats = dfs.gmtHourFormats;
	
	        this.zoneStrings = dfs.zoneStrings; // always null at initialization
	                                            // time for now
	        this.localPatternChars = dfs.localPatternChars;
	
	        this.actualLocale = dfs.actualLocale;
	        this.validLocale = dfs.validLocale;
	        this.requestedLocale = dfs.requestedLocale;
	    }
	
	    /// <summary>
	    /// Initialize format symbols for the locale and calendar type
	    /// </summary>
	    ///
	    /// <param name="desiredLocale">The locale whose symbols are desired.</param>
	    /// <param name="calData">The calendar resource data</param>
	    /// @stable ICU 3.0
	    // FIXME: This protected method must not be a stable API, because
	    // CalendarData is a non API class
	    protected internal virtual void InitializeData(ULocale desiredLocale, CalendarData calData) {
	        // FIXME: cache only ResourceBundle. Hence every time, will do
	        // getObject(). This won't be necessary if the Resource itself
	        // is cached.
	        eras = calData.GetEras("abbreviated");
	
	        try {
	            eraNames = calData.GetEras("wide");
	        } catch (MissingManifestResourceException e) {
	            eraNames = calData.GetEras("abbreviated");
	        }
	
	        // NOTE: since the above code assumes that abbreviated
	        // era names exist, we make the same assumption here too.
	        try {
	            narrowEras = calData.GetEras("narrow");
	        } catch (MissingManifestResourceException e_0) {
	            narrowEras = calData.GetEras("abbreviated");
	        }
	
	        months = calData.GetStringArray("monthNames", "wide");
	        shortMonths = calData.GetStringArray("monthNames", "abbreviated");
	
	        try {
	            narrowMonths = calData.GetStringArray("monthNames", "narrow");
	        } catch (MissingManifestResourceException e_1) {
	            try {
	                narrowMonths = calData.GetStringArray("monthNames",
	                        "stand-alone", "narrow");
	            } catch (MissingManifestResourceException e1) {
	                narrowMonths = calData.GetStringArray("monthNames",
	                        "abbreviated");
	            }
	        }
	
	        try {
	            standaloneMonths = calData.GetStringArray("monthNames",
	                    "stand-alone", "wide");
	        } catch (MissingManifestResourceException e_2) {
	            standaloneMonths = calData.GetStringArray("monthNames", "format",
	                    "wide");
	        }
	
	        try {
	            standaloneShortMonths = calData.GetStringArray("monthNames",
	                    "stand-alone", "abbreviated");
	        } catch (MissingManifestResourceException e_3) {
	            standaloneShortMonths = calData.GetStringArray("monthNames",
	                    "format", "abbreviated");
	        }
	
	        try {
	            standaloneNarrowMonths = calData.GetStringArray("monthNames",
	                    "stand-alone", "narrow");
	        } catch (MissingManifestResourceException e_4) {
	            try {
	                standaloneNarrowMonths = calData.GetStringArray("monthNames",
	                        "format", "narrow");
	            } catch (MissingManifestResourceException e1_5) {
	                standaloneNarrowMonths = calData.GetStringArray("monthNames",
	                        "format", "abbreviated");
	            }
	        }
	
	        String[] lWeekdays = calData.GetStringArray("dayNames", "wide");
	        weekdays = new String[8];
	        weekdays[0] = ""; // 1-based
	        System.Array.Copy((Array)(lWeekdays),0,(Array)(weekdays),1,lWeekdays.Length);
	
	        String[] sWeekdays = calData.GetStringArray("dayNames", "abbreviated");
	        shortWeekdays = new String[8];
	        shortWeekdays[0] = ""; // 1-based
	        System.Array.Copy((Array)(sWeekdays),0,(Array)(shortWeekdays),1,sWeekdays.Length);
	
	        String[] nWeekdays = null;
	        try {
	            nWeekdays = calData.GetStringArray("dayNames", "narrow");
	        } catch (MissingManifestResourceException e_6) {
	            try {
	                nWeekdays = calData.GetStringArray("dayNames", "stand-alone",
	                        "narrow");
	            } catch (MissingManifestResourceException e1_7) {
	                nWeekdays = calData.GetStringArray("dayNames", "abbreviated");
	            }
	        }
	        narrowWeekdays = new String[8];
	        narrowWeekdays[0] = ""; // 1-based
	        System.Array.Copy((Array)(nWeekdays),0,(Array)(narrowWeekdays),1,nWeekdays.Length);
	
	        String[] saWeekdays = null;
	        try {
	            saWeekdays = calData.GetStringArray("dayNames", "stand-alone",
	                    "wide");
	        } catch (MissingManifestResourceException e_8) {
	            saWeekdays = calData.GetStringArray("dayNames", "format", "wide");
	        }
	        standaloneWeekdays = new String[8];
	        standaloneWeekdays[0] = ""; // 1-based
	        System.Array.Copy((Array)(saWeekdays),0,(Array)(standaloneWeekdays),1,saWeekdays.Length);
	
	        String[] ssWeekdays = null;
	        try {
	            ssWeekdays = calData.GetStringArray("dayNames", "stand-alone",
	                    "abbreviated");
	        } catch (MissingManifestResourceException e_9) {
	            ssWeekdays = calData.GetStringArray("dayNames", "format",
	                    "abbreviated");
	        }
	        standaloneShortWeekdays = new String[8];
	        standaloneShortWeekdays[0] = ""; // 1-based
	        System.Array.Copy((Array)(ssWeekdays),0,(Array)(standaloneShortWeekdays),1,ssWeekdays.Length);
	
	        String[] snWeekdays = null;
	        try {
	            snWeekdays = calData.GetStringArray("dayNames", "stand-alone",
	                    "narrow");
	        } catch (MissingManifestResourceException e_10) {
	            try {
	                snWeekdays = calData.GetStringArray("dayNames", "format",
	                        "narrow");
	            } catch (MissingManifestResourceException e1_11) {
	                snWeekdays = calData.GetStringArray("dayNames", "format",
	                        "abbreviated");
	            }
	        }
	        standaloneNarrowWeekdays = new String[8];
	        standaloneNarrowWeekdays[0] = ""; // 1-based
	        System.Array.Copy((Array)(snWeekdays),0,(Array)(standaloneNarrowWeekdays),1,snWeekdays.Length);
	
	        ampms = calData.GetStringArray("AmPmMarkers");
	
	        quarters = calData.GetStringArray("quarters", "wide");
	        shortQuarters = calData.GetStringArray("quarters", "abbreviated");
	
	        try {
	            standaloneQuarters = calData.GetStringArray("quarters",
	                    "stand-alone", "wide");
	        } catch (MissingManifestResourceException e_12) {
	            standaloneQuarters = calData.GetStringArray("quarters", "format",
	                    "wide");
	        }
	
	        try {
	            standaloneShortQuarters = calData.GetStringArray("quarters",
	                    "stand-alone", "abbreviated");
	        } catch (MissingManifestResourceException e_13) {
	            standaloneShortQuarters = calData.GetStringArray("quarters",
	                    "format", "abbreviated");
	        }
	
	        // Initialize localized GMT format patterns
	        InitializeGMTFormat(desiredLocale);
	
	        requestedLocale = desiredLocale;
	
	        ICUResourceBundle rb = (ICUResourceBundle) IBM.ICU.Util.UResourceBundle
	                .GetBundleInstance(IBM.ICU.Impl.ICUResourceBundle.ICU_BASE_NAME,
	                        desiredLocale);
	
	        // Because localized date/time pattern characters will be obsolete in
	        // CLDR,
	        // we decided not to maintain localized pattern characters in ICU any
	        // more.
	        // We always use the base pattern characters by default. (ticket#5597)
	
	        // localPatternChars = rb.getString("localPatternChars");
	        localPatternChars = patternChars;
	
	        // TODO: obtain correct actual/valid locale later
	        ULocale uloc = rb.GetULocale();
	        SetLocale(uloc, uloc);
	    }
	
	    internal const String DEFAULT_GMT_PATTERN = "GMT{0}";
	
	    static internal readonly String[][] DEFAULT_GMT_HOUR_PATTERNS = { new String[] { "-HH:mm:ss", "-HH:mm" },
	            new String[] { "+HH:mm:ss", "+HH:mm" } };
	
	    /*
	     * Initialize localized GMT format patterns
	     */
	    private void InitializeGMTFormat(ULocale desiredLocale) {
	        // TimeZone format localization is not included in CalendarData
	        try {
	            gmtFormat = IBM.ICU.Impl.ZoneMeta.GetTZLocalizationInfo(desiredLocale,
	                    IBM.ICU.Impl.ZoneMeta.GMT);
	        } catch (MissingManifestResourceException e) {
	            gmtFormat = DEFAULT_GMT_PATTERN;
	        }
	
	        try {
	            String offsetHM = IBM.ICU.Impl.ZoneMeta.GetTZLocalizationInfo(desiredLocale,
	                    IBM.ICU.Impl.ZoneMeta.HOUR);
	            gmtHourFormats = (String[][])ILOG.J2CsMapping.Collections.Arrays.CreateJaggedArray(typeof(String), 2, 2);
	            int sepIdx = offsetHM.IndexOf(';');
	            if (sepIdx != -1) {
	                gmtHourFormats[OFFSET_POSITIVE][OFFSET_HM] = offsetHM.Substring(0,(sepIdx)-(0));
	                gmtHourFormats[OFFSET_NEGATIVE][OFFSET_HM] = offsetHM.Substring(sepIdx + 1);
	            } else {
	                gmtHourFormats[OFFSET_POSITIVE][OFFSET_HM] = "+HH:mm";
	                gmtHourFormats[OFFSET_NEGATIVE][OFFSET_HM] = "-HH:mm";
	            }
	            // CLDR 1.5 does not have GMT offset pattern including second field.
	            // For now, append "ss" to the end.
	            if (gmtHourFormats[OFFSET_POSITIVE][OFFSET_HM].IndexOf(':') != -1) {
	                gmtHourFormats[OFFSET_POSITIVE][OFFSET_HMS] = gmtHourFormats[OFFSET_POSITIVE][OFFSET_HM]
	                        + ":ss";
	            } else {
	                gmtHourFormats[OFFSET_POSITIVE][OFFSET_HMS] = gmtHourFormats[OFFSET_POSITIVE][OFFSET_HM]
	                        + "ss";
	            }
	            if (gmtHourFormats[OFFSET_NEGATIVE][OFFSET_HM].IndexOf(':') != -1) {
	                gmtHourFormats[OFFSET_NEGATIVE][OFFSET_HMS] = gmtHourFormats[OFFSET_NEGATIVE][OFFSET_HM]
	                        + ":ss";
	            } else {
	                gmtHourFormats[OFFSET_NEGATIVE][OFFSET_HMS] = gmtHourFormats[OFFSET_NEGATIVE][OFFSET_HM]
	                        + "ss";
	            }
	        } catch (MissingManifestResourceException e_0) {
	            gmtHourFormats = DEFAULT_GMT_HOUR_PATTERNS;
	        }
	    }
	
	    private static bool ArrayOfArrayEquals(Object[][] aa1,
	            Object[][] aa2) {
	        if (aa1 == aa2) { // both are null
	            return true;
	        }
	        if (aa1 == null || aa2 == null) { // one is null and the other is not
	            return false;
	        }
	        if (aa1.Length != aa2.Length) {
	            return false;
	        }
	        bool equal = true;
	        for (int i = 0; i < aa1.Length; i++) {
	            equal = IBM.ICU.Impl.Utility.ArrayEquals(aa1[i], aa2[i]);
	            if (!equal) {
	                break;
	            }
	        }
	        return equal;
	    }
	
	    /*
	     * Package local method (for now) to get localized GMT format pattern.
	     */
	    internal String GetGmtFormat() {
	        return gmtFormat;
	    }
	
	    internal const int OFFSET_HMS = 0;
	
	    internal const int OFFSET_HM = 1;
	
	    internal const int OFFSET_NEGATIVE = 0;
	
	    internal const int OFFSET_POSITIVE = 1;
	
	    /*
	     * Package local method (for now) to get hour format pattern used by
	     * localized GMT string.
	     */
	    internal String GetGmtHourFormat(int sign, int width) {
	        return gmtHourFormats[sign][width];
	    }
	
	    /*
	     * Package local method to access ZoneStringFormat used by this
	     * DateFormatSymbols instance.
	     */
	    internal ZoneStringFormat GetZoneStringFormat() {
	        if (zsformat != null) {
	            return zsformat;
	        }
	        if (zoneStrings != null) {
	            zsformat = new ZoneStringFormat(zoneStrings);
	            return zsformat;
	        }
	        // We do not want to hold the reference to an instance of
	        // ZoneStringFormat. An instance of ZoneStringFormat for
	        // a locale is shared and cached in ZoneStringFormat class
	        // itself.
	        return IBM.ICU.Impl.ZoneStringFormat.GetInstance(requestedLocale);
	    }
	
	    /*
	     * save the input locale
	     */
	    private ULocale requestedLocale;
	
	    /*
	     * Clones an array of Strings.
	     * 
	     * @param srcArray the source array to be cloned.
	     * 
	     * @return a cloned array.
	     */
	    private String[] Duplicate(String[] srcArray) {
	        return (String[]) srcArray.Clone();
	    }
	
	    private String[][] Duplicate(String[][] srcArray) {
	        String[][] aCopy = new String[srcArray.Length][];
	        for (int i = 0; i < srcArray.Length; ++i)
	            aCopy[i] = Duplicate(srcArray[i]);
	        return aCopy;
	    }
	
	    /*
	     * Compares the equality of the two arrays of String.
	     * 
	     * @param current this String array.
	     * 
	     * @param other that String array. private final boolean equals(String[]
	     * current, String[] other) { int count = current.length;
	     * 
	     * for (int i = 0; i < count; ++i) if (!current[i].equals(other[i])) return
	     * false; return true; }
	     */
	
	    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	
	    /// <summary>
	    /// Get the <see cref="T:IBM.ICU.Text.DateFormatSymbols"/> object that should be used to format a
	    /// calendar system's dates in the given locale.
	    /// <p>
	    /// <b>Subclassing:</b><br>
	    /// When creating a new Calendar subclass, you must create the<see cref="null"/> containing its<see cref="null"/> in a specific place. The
	    /// resource bundle name is based on the calendar's fully-specified class
	    /// name, with ".resources" inserted at the end of the package name (just
	    /// before the class name) and "Symbols" appended to the end. For example,
	    /// the bundle corresponding to "com.ibm.icu.util.HebrewCalendar" is
	    /// "com.ibm.icu.impl.data.HebrewCalendarSymbols".
	    /// <p>
	    /// Within the ResourceBundle, this method searches for five keys:
	    /// <ul>
	    /// <li><b>DayNames</b> - An array of strings corresponding to each possible
	    /// value of the <c>DAY_OF_WEEK</c> field. Even though
	    /// <c>DAY_OF_WEEK</c> starts with <c>SUNDAY</c> = 1, This array
	    /// is 0-based; the name for Sunday goes in the first position, at index 0.
	    /// If this key is not found in the bundle, the day names are inherited from
	    /// the default <c>DateFormatSymbols</c> for the requested locale.
	    /// <li><b>DayAbbreviations</b> - An array of abbreviated day names
	    /// corresponding to the values in the "DayNames" array. If this key is not
	    /// found in the resource bundle, the "DayNames" values are used instead. If
	    /// neither key is found, the day abbreviations are inherited from the
	    /// default <c>DateFormatSymbols</c> for the locale.
	    /// <li><b>MonthNames</b> - An array of strings corresponding to each
	    /// possible value of the <c>MONTH</c> field. If this key is not found
	    /// in the bundle, the month names are inherited from the default
	    /// <c>DateFormatSymbols</c> for the requested locale.
	    /// <li><b>MonthAbbreviations</b> - An array of abbreviated day names
	    /// corresponding to the values in the "MonthNames" array. If this key is not
	    /// found in the resource bundle, the "MonthNames" values are used instead.
	    /// If neither key is found, the day abbreviations are inherited from the
	    /// default <c>DateFormatSymbols</c> for the locale.
	    /// <li><b>Eras</b> - An array of strings corresponding to each possible
	    /// value of the <c>ERA</c> field. If this key is not found in the
	    /// bundle, the era names are inherited from the default
	    /// <c>DateFormatSymbols</c> for the requested locale.
	    /// </ul>
	    /// <p>
	    /// </summary>
	    ///
	    /// <param name="cal">The calendar system whose date format symbols are desired.</param>
	    /// <param name="locale">The locale whose symbols are desired.</param>
	    /// <seealso cref="M:IBM.ICU.Text.DateFormatSymbols.DateFormatSymbols(System.Globalization.CultureInfo)"/>
	    /// @stable ICU 2.0
        public DateFormatSymbols(IBM.ICU.Util.Calendar cal, Locale locale)
        {
	        this.eras = null;
	        this.eraNames = null;
	        this.narrowEras = null;
	        this.months = null;
	        this.shortMonths = null;
	        this.narrowMonths = null;
	        this.standaloneMonths = null;
	        this.standaloneShortMonths = null;
	        this.standaloneNarrowMonths = null;
	        this.weekdays = null;
	        this.shortWeekdays = null;
	        this.narrowWeekdays = null;
	        this.standaloneWeekdays = null;
	        this.standaloneShortWeekdays = null;
	        this.standaloneNarrowWeekdays = null;
	        this.ampms = null;
	        this.shortQuarters = null;
	        this.quarters = null;
	        this.standaloneShortQuarters = null;
	        this.standaloneQuarters = null;
	        this.gmtFormat = null;
	        this.gmtHourFormats = null;
	        this.zoneStrings = null;
	        this.zsformat = null;
	        this.localPatternChars = null;
	        InitializeData(IBM.ICU.Util.ULocale.ForLocale(locale), cal.GetType());
	    }
	
	    /// <summary>
	    /// Get the <see cref="T:IBM.ICU.Text.DateFormatSymbols"/> object that should be used to format a
	    /// calendar system's dates in the given locale.
	    /// <p>
	    /// <b>Subclassing:</b><br>
	    /// When creating a new Calendar subclass, you must create the<see cref="null"/> containing its<see cref="null"/> in a specific place. The
	    /// resource bundle name is based on the calendar's fully-specified class
	    /// name, with ".resources" inserted at the end of the package name (just
	    /// before the class name) and "Symbols" appended to the end. For example,
	    /// the bundle corresponding to "com.ibm.icu.util.HebrewCalendar" is
	    /// "com.ibm.icu.impl.data.HebrewCalendarSymbols".
	    /// <p>
	    /// Within the ResourceBundle, this method searches for five keys:
	    /// <ul>
	    /// <li><b>DayNames</b> - An array of strings corresponding to each possible
	    /// value of the <c>DAY_OF_WEEK</c> field. Even though
	    /// <c>DAY_OF_WEEK</c> starts with <c>SUNDAY</c> = 1, This array
	    /// is 0-based; the name for Sunday goes in the first position, at index 0.
	    /// If this key is not found in the bundle, the day names are inherited from
	    /// the default <c>DateFormatSymbols</c> for the requested locale.
	    /// <li><b>DayAbbreviations</b> - An array of abbreviated day names
	    /// corresponding to the values in the "DayNames" array. If this key is not
	    /// found in the resource bundle, the "DayNames" values are used instead. If
	    /// neither key is found, the day abbreviations are inherited from the
	    /// default <c>DateFormatSymbols</c> for the locale.
	    /// <li><b>MonthNames</b> - An array of strings corresponding to each
	    /// possible value of the <c>MONTH</c> field. If this key is not found
	    /// in the bundle, the month names are inherited from the default
	    /// <c>DateFormatSymbols</c> for the requested locale.
	    /// <li><b>MonthAbbreviations</b> - An array of abbreviated day names
	    /// corresponding to the values in the "MonthNames" array. If this key is not
	    /// found in the resource bundle, the "MonthNames" values are used instead.
	    /// If neither key is found, the day abbreviations are inherited from the
	    /// default <c>DateFormatSymbols</c> for the locale.
	    /// <li><b>Eras</b> - An array of strings corresponding to each possible
	    /// value of the <c>ERA</c> field. If this key is not found in the
	    /// bundle, the era names are inherited from the default
	    /// <c>DateFormatSymbols</c> for the requested locale.
	    /// </ul>
	    /// <p>
	    /// </summary>
	    ///
	    /// <param name="cal">The calendar system whose date format symbols are desired.</param>
	    /// <param name="locale">The ulocale whose symbols are desired.</param>
	    /// <seealso cref="M:IBM.ICU.Text.DateFormatSymbols.DateFormatSymbols(System.Globalization.CultureInfo)"/>
	    /// @stable ICU 3.2
        public DateFormatSymbols(IBM.ICU.Util.Calendar cal, ULocale locale)
        {
	        this.eras = null;
	        this.eraNames = null;
	        this.narrowEras = null;
	        this.months = null;
	        this.shortMonths = null;
	        this.narrowMonths = null;
	        this.standaloneMonths = null;
	        this.standaloneShortMonths = null;
	        this.standaloneNarrowMonths = null;
	        this.weekdays = null;
	        this.shortWeekdays = null;
	        this.narrowWeekdays = null;
	        this.standaloneWeekdays = null;
	        this.standaloneShortWeekdays = null;
	        this.standaloneNarrowWeekdays = null;
	        this.ampms = null;
	        this.shortQuarters = null;
	        this.quarters = null;
	        this.standaloneShortQuarters = null;
	        this.standaloneQuarters = null;
	        this.gmtFormat = null;
	        this.gmtHourFormats = null;
	        this.zoneStrings = null;
	        this.zsformat = null;
	        this.localPatternChars = null;
	        InitializeData(locale, cal.GetType());
	    }
	
	    /// <summary>
	    /// Variant of DateFormatSymbols(Calendar, Locale) that takes the Calendar
	    /// class instead of a Calandar instance.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.DateFormatSymbols.DateFormatSymbols(null, null)"/>
	    /// @stable ICU 2.2
        public DateFormatSymbols(Type calendarClass, Locale locale)
            : this(calendarClass, IBM.ICU.Util.ULocale.ForLocale(locale))
        {
	    }
	
	    /// <summary>
	    /// Variant of DateFormatSymbols(Calendar, ULocale) that takes the Calendar
	    /// class instead of a Calandar instance.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.DateFormatSymbols.DateFormatSymbols(null, null)"/>
	    /// @stable ICU 3.2
	    public DateFormatSymbols(Type calendarClass, ULocale locale) {
	        this.eras = null;
	        this.eraNames = null;
	        this.narrowEras = null;
	        this.months = null;
	        this.shortMonths = null;
	        this.narrowMonths = null;
	        this.standaloneMonths = null;
	        this.standaloneShortMonths = null;
	        this.standaloneNarrowMonths = null;
	        this.weekdays = null;
	        this.shortWeekdays = null;
	        this.narrowWeekdays = null;
	        this.standaloneWeekdays = null;
	        this.standaloneShortWeekdays = null;
	        this.standaloneNarrowWeekdays = null;
	        this.ampms = null;
	        this.shortQuarters = null;
	        this.quarters = null;
	        this.standaloneShortQuarters = null;
	        this.standaloneQuarters = null;
	        this.gmtFormat = null;
	        this.gmtHourFormats = null;
	        this.zoneStrings = null;
	        this.zsformat = null;
	        this.localPatternChars = null;
	        String fullName = calendarClass.FullName;
	        int lastDot = fullName.LastIndexOf('.');
	        String className = fullName.Substring(lastDot + 1);
	        String calType = IBM.ICU.Impl.Utility.ReplaceAll(className, "Calendar", "")
	                .ToLower();
	
	        InitializeData(locale, calType);
	    }
	
	    /// <summary>
	    /// Fetch a custom calendar's DateFormatSymbols out of the given resource
	    /// bundle. Symbols that are not overridden are inherited from the default
	    /// DateFormatSymbols for the locale.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.DateFormatSymbols.DateFormatSymbols(System.Globalization.CultureInfo)"/>
	    /// @stable ICU 2.0
        public DateFormatSymbols(ResourceBundle bundle, Locale locale)
            : this(bundle, IBM.ICU.Util.ULocale.ForLocale(locale))
        {
	    }
	
	    /// <summary>
	    /// Fetch a custom calendar's DateFormatSymbols out of the given resource
	    /// bundle. Symbols that are not overridden are inherited from the default
	    /// DateFormatSymbols for the locale.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.DateFormatSymbols.DateFormatSymbols(System.Globalization.CultureInfo)"/>
	    /// @stable ICU 3.2
	    public DateFormatSymbols(ResourceBundle bundle, ULocale locale) {
	        this.eras = null;
	        this.eraNames = null;
	        this.narrowEras = null;
	        this.months = null;
	        this.shortMonths = null;
	        this.narrowMonths = null;
	        this.standaloneMonths = null;
	        this.standaloneShortMonths = null;
	        this.standaloneNarrowMonths = null;
	        this.weekdays = null;
	        this.shortWeekdays = null;
	        this.narrowWeekdays = null;
	        this.standaloneWeekdays = null;
	        this.standaloneShortWeekdays = null;
	        this.standaloneNarrowWeekdays = null;
	        this.ampms = null;
	        this.shortQuarters = null;
	        this.quarters = null;
	        this.standaloneShortQuarters = null;
	        this.standaloneQuarters = null;
	        this.gmtFormat = null;
	        this.gmtHourFormats = null;
	        this.zoneStrings = null;
	        this.zsformat = null;
	        this.localPatternChars = null;
	        InitializeData(locale, new CalendarData((ICUResourceBundle) bundle,
	                null));
	    }
	
	    /// <summary>
	    /// Find the ResourceBundle containing the date format information for a
	    /// specified calendar subclass in a given locale.
	    /// <p>
	    /// The resource bundle name is based on the calendar's fully-specified class
	    /// name, with ".resources" inserted at the end of the package name (just
	    /// before the class name) and "Symbols" appended to the end. For example,
	    /// the bundle corresponding to "com.ibm.icu.util.HebrewCalendar" is
	    /// "com.ibm.icu.impl.data.HebrewCalendarSymbols".
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
        static public ResourceBundle GetDateFormatBundle(Type calendarClass,
                Locale locale)
        {
	        return GetDateFormatBundle(calendarClass, IBM.ICU.Util.ULocale.ForLocale(locale));
	    }
	
	    /// <summary>
	    /// Find the ResourceBundle containing the date format information for a
	    /// specified calendar subclass in a given locale.
	    /// <p>
	    /// The resource bundle name is based on the calendar's fully-specified class
	    /// name, with ".resources" inserted at the end of the package name (just
	    /// before the class name) and "Symbols" appended to the end. For example,
	    /// the bundle corresponding to "com.ibm.icu.util.HebrewCalendar" is
	    /// "com.ibm.icu.impl.data.HebrewCalendarSymbols".
	    /// </summary>
	    ///
	    /// @stable ICU 3.2
        static public ResourceBundle GetDateFormatBundle(Type calendarClass,
	            ULocale locale) {
	
	        // Find the calendar's class name, which we're going to use to construct
	        // the
	        // resource bundle name.
	        String fullName = calendarClass.FullName;
	        int lastDot = fullName.LastIndexOf('.');
	        String className = fullName.Substring(lastDot + 1);
	
	        String bundleName = className + "Symbols";
	
	        UResourceBundle result = null;
	        try {
	            result = IBM.ICU.Util.UResourceBundle.GetBundleInstance(bundleName, locale);
	        } catch (MissingManifestResourceException e) {
	            // /CLOVER:OFF
	            // coverage requires test without data, so skip
	            // if (!(cal instanceof GregorianCalendar)) {
	            if (!(typeof(IBM.ICU.Util.GregorianCalendar).IsAssignableFrom(calendarClass))) {
	                // Ok for symbols to be missing for a Gregorian calendar, but
	                // not for any other type.
	                throw e;
	            }
	            // /CLOVER:ON
	        }
	        return result;
	    }
	
	    /// <summary>
	    /// Variant of getDateFormatBundle(java.lang.Class, java.util.Locale) that
	    /// takes a Calendar instance instead of a Calendar class.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.DateFormatSymbols.GetDateFormatBundle(System.Type, System.Globalization.CultureInfo)"/>
	    /// @stable ICU 2.2
        public static ResourceBundle GetDateFormatBundle(IBM.ICU.Util.Calendar cal, Locale locale)
        {
	        return GetDateFormatBundle(((object) cal).GetType(), IBM.ICU.Util.ULocale.ForLocale(locale));
	    }
	
	    /// <summary>
	    /// Variant of getDateFormatBundle(java.lang.Class, java.util.Locale) that
	    /// takes a Calendar instance instead of a Calendar class.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.DateFormatSymbols.GetDateFormatBundle(System.Type, System.Globalization.CultureInfo)"/>
	    /// @stable ICU 3.2
        public static ResourceBundle GetDateFormatBundle(IBM.ICU.Util.Calendar cal,
	            ULocale locale) {
                    return GetDateFormatBundle(((object)cal).GetType(), locale);
	    }
	
	    // -------- BEGIN ULocale boilerplate --------
	
	    /// <summary>
	    /// Return the locale that was used to create this object, or null. This may
	    /// may differ from the locale requested at the time of this object's
	    /// creation. For example, if an object is created for locale
	    /// <tt>en_US_CALIFORNIA</tt>, the actual data may be drawn from <tt>en</tt>
	    /// (the <i>actual</i> locale), and <tt>en_US</tt> may be the most specific
	    /// locale that exists (the <i>valid</i> locale).
	    /// <p>
	    /// Note: This method will be implemented in ICU 3.0; ICU 2.8 contains a
	    /// partial preview implementation. The/// <i>actual</i> locale is returned
	    /// correctly, but the <i>valid</i> locale is not, in most cases.
	    /// </summary>
	    ///
	    /// <param name="type">type of information requested, either<see cref="M:IBM.ICU.Text.ULocale.VALID_LOCALE"/> or<see cref="M:IBM.ICU.Text.ULocale.ACTUAL_LOCALE"/>.</param>
	    /// <returns>the information specified by <i>type</i>, or null if this object
	    /// was not constructed from locale data.</returns>
	    /// <seealso cref="T:IBM.ICU.Text.ULocale"/>
	    /// <seealso cref="M:IBM.ICU.Text.ULocale.VALID_LOCALE"/>
	    /// <seealso cref="M:IBM.ICU.Text.ULocale.ACTUAL_LOCALE"/>
	    /// @draft ICU 2.8 (retain)
	    /// @provisional This API might change or be removed in a future release.
	    public ULocale GetLocale(ULocale.Type type) {
	        return (type == IBM.ICU.Util.ULocale.ACTUAL_LOCALE) ? this.actualLocale
	                : this.validLocale;
	    }
	
	    /*
	     * Set information about the locales that were used to create this object.
	     * If the object was not constructed from locale data, both arguments should
	     * be set to null. Otherwise, neither should be null. The actual locale must
	     * be at the same level or less specific than the valid locale. This method
	     * is intended for use by factories or other entities that create objects of
	     * this class.
	     * 
	     * @param valid the most specific locale containing any resource data, or
	     * null
	     * 
	     * @param actual the locale containing data used to construct this object,
	     * or null
	     * 
	     * @see com.ibm.icu.util.ULocale
	     * 
	     * @see com.ibm.icu.util.ULocale#VALID_LOCALE
	     * 
	     * @see com.ibm.icu.util.ULocale#ACTUAL_LOCALE
	     */
	    internal void SetLocale(ULocale valid, ULocale actual) {
	        // Change the following to an assertion later
	        if ((valid == null) != (actual == null)) {
	            // /CLOVER:OFF
	            throw new ArgumentException();
	            // /CLOVER:ON
	        }
	        // Another check we could do is that the actual locale is at
	        // the same level or less specific than the valid locale.
	        this.validLocale = valid;
	        this.actualLocale = actual;
	    }
	
	    /*
	     * The most specific locale containing any resource data, or null.
	     * 
	     * @see com.ibm.icu.util.ULocale
	     */
	    private ULocale validLocale;
	
	    /*
	     * The locale containing data used to construct this object, or null.
	     * 
	     * @see com.ibm.icu.util.ULocale
	     */
	    private ULocale actualLocale;
	
	    // -------- END ULocale boilerplate --------
	
	    /*
	     * 3.8 or older version did not have localized GMT format patterns.
	     */
	    private void ReadObject(IlObjectInputStream stream) {
	        stream.DefaultReadObject();
	        if (gmtFormat == null) {
	            InitializeGMTFormat(requestedLocale);
	        }
	    }
	}
}
