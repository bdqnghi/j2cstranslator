/*
 *******************************************************************************
 * Copyright (C) 1996-2005, International Business Machines Corporation and    *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 */
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/13/10 4:01 PM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Charset {
	
	using ILOG.J2CsMapping.Collections;
	using ILOG.J2CsMapping.Collections.Generics;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	
	/// <summary>
	/// Everything that maps to the same value is part of the same equivalence class
	/// </summary>
	///
	public class XEquivalenceMap {
	    public XEquivalenceMap() {
	        this.source_target = new Hashtable();
	        this.target_sourceSet = new Hashtable();
	        this.source_Set = new Hashtable();
	    }
	
	    internal Hashtable source_target;
	
	    internal Hashtable target_sourceSet;
	
	    internal Hashtable source_Set;
	
	    public XEquivalenceMap Clear() {
	        source_target.Clear();
	        target_sourceSet.Clear();
	        source_Set.Clear();
	        return this;
	    }
	
	    public XEquivalenceMap Add(Object source, Object target) {
	        Object otherTarget = ILOG.J2CsMapping.Collections.Collections.Get(source_target,source);
	        if (otherTarget != null) {
	            if (otherTarget.Equals(target))
	                return this;
	            throw new ArgumentException(
	                    "Same source mapping to different targets: " + source
	                            + " => " + otherTarget + " & " + target);
	        }
	        ILOG.J2CsMapping.Collections.Collections.Put(source_target,source,target);
	        ILOG.J2CsMapping.Collections.ISet s = (ISet) ILOG.J2CsMapping.Collections.Collections.Get(target_sourceSet,target);
	        if (s == null)
	            ILOG.J2CsMapping.Collections.Collections.Put(target_sourceSet,target,s = new HashedSet());
	        ILOG.J2CsMapping.Collections.Generics.Collections.Add(s,source);
	        ILOG.J2CsMapping.Collections.Collections.Put(source_Set,source,s);
	        return this;
	    }
	
	    public ILOG.J2CsMapping.Collections.ISet GetEquivalences(Object source) {
	        ILOG.J2CsMapping.Collections.ISet s = (ISet) ILOG.J2CsMapping.Collections.Collections.Get(source_Set,source);
	        if (s == null)
	            return null;
	        return ILOG.J2CsMapping.Collections.Generics.Collections.UnmodifiableSet(s);
	    }
	
	    public bool AreEquivalent(Object source1, Object source2) {
	        ILOG.J2CsMapping.Collections.ISet s = (ISet) ILOG.J2CsMapping.Collections.Collections.Get(source_Set,source1);
	        if (s == null)
	            return false;
	        return ILOG.J2CsMapping.Collections.Collections.Contains(source2,s);
	    }
	
	    public Object GetTarget(Object source) {
	        return ILOG.J2CsMapping.Collections.Collections.Get(source_target,source);
	    }
	
	    public ILOG.J2CsMapping.Collections.ISet GetSources(Object target) {
	        ILOG.J2CsMapping.Collections.ISet s = (ISet) ILOG.J2CsMapping.Collections.Collections.Get(target_sourceSet,target);
	        return ILOG.J2CsMapping.Collections.Generics.Collections.UnmodifiableSet(s);
	    }
	
	    public IIterator Iterator() {
	        XEquivalenceMap.MyIterator  result = new XEquivalenceMap.MyIterator (this);
	        result.target_sourceSet_iterator = new ILOG.J2CsMapping.Collections.IteratorAdapter(new ILOG.J2CsMapping.Collections.ListSet(target_sourceSet.Keys).GetEnumerator());
	        return result;
	    }
	
	    public int Size() {
	        return target_sourceSet.Count;
	    }
	
	    internal class MyIterator : IIterator {
	            private XEquivalenceMap outer_XEquivalenceMap;
	    
	            
	            /// <param name="map"></param>
	            public MyIterator(XEquivalenceMap map) {
	                outer_XEquivalenceMap = map;
	            }
	    
	            internal IIterator target_sourceSet_iterator;
	    
	            public virtual void Remove() {
	                throw new NotSupportedException();
	            }
	    
	            public virtual bool HasNext() {
	                return target_sourceSet_iterator.HasNext();
	            }
	    
	            public virtual Object Next() {
	                return outer_XEquivalenceMap.GetSources(target_sourceSet_iterator.Next());
	            }
	        
		#region AddedByTranslator
	
		object ILOG.J2CsMapping.Collections.IIterator.Next()
	            {
	                return this.Next();
	            }
	
		#endregion
	
	}
	}}
