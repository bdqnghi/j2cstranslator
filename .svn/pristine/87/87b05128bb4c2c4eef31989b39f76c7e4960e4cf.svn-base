//##header J2SE15
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:47 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /*
 *******************************************************************************
 * Copyright (C) 1996-2007, International Business Machines Corporation and    *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 */
namespace IBM.ICU.Impl {
	
	using IBM.ICU.Text;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Text;
    using ILOG.J2CsMapping.Util;
	
	public sealed class Utility {
	
	    private const char APOSTROPHE = '\'';
	
	    private const char BACKSLASH = '\\';
	
	    private const int MAGIC_UNSIGNED = -2147483648;
	
	    /// <summary>
	    /// Convenience utility to compare two Object[]s. Ought to be in System
	    /// </summary>
	    ///
	    public static bool ArrayEquals(Object[] source, Object target) {
	        if (source == null)
	            return (target == null);
	        if (!(target  is  Object[]))
	            return false;
	        Object[] targ = (Object[]) target;
	        return (source.Length == targ.Length && ArrayRegionMatches(source, 0,
	                targ, 0, source.Length));
	    }
	
	    /// <summary>
	    /// Convenience utility to compare two int[]s Ought to be in System
	    /// </summary>
	    ///
	    public static bool ArrayEquals(int[] source, Object target) {
	        if (source == null)
	            return (target == null);
	        if (!(target  is  int[]))
	            return false;
	        int[] targ = (int[]) target;
	        return (source.Length == targ.Length && ArrayRegionMatches(source, 0,
	                targ, 0, source.Length));
	    }
	
	    /// <summary>
	    /// Convenience utility to compare two double[]s Ought to be in System
	    /// </summary>
	    ///
	    public static bool ArrayEquals(double[] source, Object target) {
	        if (source == null)
	            return (target == null);
	        if (!(target  is  double[]))
	            return false;
	        double[] targ = (double[]) target;
	        return (source.Length == targ.Length && ArrayRegionMatches(source, 0,
	                targ, 0, source.Length));
	    }
	
	    public static bool ArrayEquals(byte[] source, Object target) {
	        if (source == null)
	            return (target == null);
	        if (!(target  is  byte[]))
	            return false;
	        byte[] targ = (byte[]) target;
	        return (source.Length == targ.Length && ArrayRegionMatches(source, 0,
	                targ, 0, source.Length));
	    }
	
	    /// <summary>
	    /// Convenience utility to compare two Object[]s Ought to be in System
	    /// </summary>
	    ///
	    public static bool ArrayEquals(Object source, Object target) {
	        if (source == null)
	            return (target == null);
	        // for some reason, the correct arrayEquals is not being called
	        // so do it by hand for now.
	        if (source  is  Object[])
	            return (ArrayEquals((Object[]) source, target));
	        if (source  is  int[])
	            return (ArrayEquals((int[]) source, target));
	        if (source  is  double[])
	            return (ArrayEquals((int[]) source, target));
	        if (source  is  byte[])
	            return (ArrayEquals((byte[]) source, target));
	        return source.Equals(target);
	    }
	
	    /// <summary>
	    /// Convenience utility to compare two Object[]s Ought to be in System.
	    /// </summary>
	    ///
	    /// <param name="len">the length to compare. The start indices and start+len must bevalid.</param>
	    public static bool ArrayRegionMatches(Object[] source,
	            int sourceStart, Object[] target, int targetStart, int len) {
	        int sourceEnd = sourceStart + len;
	        int delta = targetStart - sourceStart;
	        for (int i = sourceStart; i < sourceEnd; i++) {
	            if (!ArrayEquals(source[i], target[i + delta]))
	                return false;
	        }
	        return true;
	    }
	
	    /// <summary>
	    /// Convenience utility to compare two Object[]s Ought to be in System.
	    /// </summary>
	    ///
	    /// <param name="len">the length to compare. The start indices and start+len must bevalid.</param>
	    public static bool ArrayRegionMatches(char[] source,
	            int sourceStart, char[] target, int targetStart, int len) {
	        int sourceEnd = sourceStart + len;
	        int delta = targetStart - sourceStart;
	        for (int i = sourceStart; i < sourceEnd; i++) {
	            if (source[i] != target[i + delta])
	                return false;
	        }
	        return true;
	    }
	
	    /// <summary>
	    /// Convenience utility to compare two int[]s.
	    /// </summary>
	    ///
	    /// <param name="len">the length to compare. The start indices and start+len must bevalid. Ought to be in System</param>
	    public static bool ArrayRegionMatches(int[] source,
	            int sourceStart, int[] target, int targetStart, int len) {
	        int sourceEnd = sourceStart + len;
	        int delta = targetStart - sourceStart;
	        for (int i = sourceStart; i < sourceEnd; i++) {
	            if (source[i] != target[i + delta])
	                return false;
	        }
	        return true;
	    }
	
	    /// <summary>
	    /// Convenience utility to compare two arrays of doubles.
	    /// </summary>
	    ///
	    /// <param name="len">the length to compare. The start indices and start+len must bevalid. Ought to be in System</param>
	    public static bool ArrayRegionMatches(double[] source,
	            int sourceStart, double[] target, int targetStart, int len) {
	        int sourceEnd = sourceStart + len;
	        int delta = targetStart - sourceStart;
	        for (int i = sourceStart; i < sourceEnd; i++) {
	            if (source[i] != target[i + delta])
	                return false;
	        }
	        return true;
	    }
	
	    public static bool ArrayRegionMatches(byte[] source,
	            int sourceStart, byte[] target, int targetStart, int len) {
	        int sourceEnd = sourceStart + len;
	        int delta = targetStart - sourceStart;
	        for (int i = sourceStart; i < sourceEnd; i++) {
	            if (source[i] != target[i + delta])
	                return false;
	        }
	        return true;
	    }
	
	    /// <summary>
	    /// Convenience utility. Does null checks on objects, then calls equals.
	    /// </summary>
	    ///
	    public static bool ObjectEquals(Object source, Object target) {
	        if (source == null)
	            return (target == null);
	        else
	            return source.Equals(target);
	    }
	
	    /// <summary>
	    /// The ESCAPE character is used during run-length encoding. It signals a run
	    /// of identical chars.
	    /// </summary>
	    ///
	    private const char ESCAPE = '\uA5A5';
	
	    /// <summary>
	    /// The ESCAPE_BYTE character is used during run-length encoding. It signals
	    /// a run of identical bytes.
	    /// </summary>
	    ///
	    internal const byte ESCAPE_BYTE = (byte) 0xA5;
	
	    /// <summary>
	    /// Construct a string representing an int array. Use run-length encoding. A
	    /// character represents itself, unless it is the ESCAPE character. Then the
	    /// following notations are possible: ESCAPE ESCAPE ESCAPE literal ESCAPE n c
	    /// n instances of character c Since an encoded run occupies 3 characters, we
	    /// only encode runs of 4 or more characters. Thus we have n > 0 and n !=
	    /// ESCAPE and n <= 0xFFFF. If we encounter a run where n == ESCAPE, we
	    /// represent this as: c ESCAPE n-1 c The ESCAPE value is chosen so as not to
	    /// collide with commonly seen values.
	    /// </summary>
	    ///
	    static public String ArrayToRLEString(int[] a) {
	        StringBuilder buffer = new StringBuilder();
	
	        AppendInt(buffer, a.Length);
	        int runValue = a[0];
	        int runLength = 1;
	        for (int i = 1; i < a.Length; ++i) {
	            int s = a[i];
	            if (s == runValue && runLength < 0xFFFF) {
	                ++runLength;
	            } else {
	                EncodeRun(buffer, runValue, runLength);
	                runValue = s;
	                runLength = 1;
	            }
	        }
	        EncodeRun(buffer, runValue, runLength);
	        return buffer.ToString();
	    }
	
	    /// <summary>
	    /// Construct a string representing a short array. Use run-length encoding. A
	    /// character represents itself, unless it is the ESCAPE character. Then the
	    /// following notations are possible: ESCAPE ESCAPE ESCAPE literal ESCAPE n c
	    /// n instances of character c Since an encoded run occupies 3 characters, we
	    /// only encode runs of 4 or more characters. Thus we have n > 0 and n !=
	    /// ESCAPE and n <= 0xFFFF. If we encounter a run where n == ESCAPE, we
	    /// represent this as: c ESCAPE n-1 c The ESCAPE value is chosen so as not to
	    /// collide with commonly seen values.
	    /// </summary>
	    ///
	    static public String ArrayToRLEString(short[] a) {
	        StringBuilder buffer = new StringBuilder();
	        // for (int i=0; i<a.length; ++i) buffer.append((char) a[i]);
	        buffer.Append((char) (a.Length >> 16));
	        buffer.Append((char) a.Length);
	        short runValue = a[0];
	        int runLength = 1;
	        for (int i = 1; i < a.Length; ++i) {
	            short s = a[i];
	            if (s == runValue && runLength < 0xFFFF)
	                ++runLength;
	            else {
	                EncodeRun(buffer, runValue, runLength);
	                runValue = s;
	                runLength = 1;
	            }
	        }
	        EncodeRun(buffer, runValue, runLength);
	        return buffer.ToString();
	    }
	
	    /// <summary>
	    /// Construct a string representing a char array. Use run-length encoding. A
	    /// character represents itself, unless it is the ESCAPE character. Then the
	    /// following notations are possible: ESCAPE ESCAPE ESCAPE literal ESCAPE n c
	    /// n instances of character c Since an encoded run occupies 3 characters, we
	    /// only encode runs of 4 or more characters. Thus we have n > 0 and n !=
	    /// ESCAPE and n <= 0xFFFF. If we encounter a run where n == ESCAPE, we
	    /// represent this as: c ESCAPE n-1 c The ESCAPE value is chosen so as not to
	    /// collide with commonly seen values.
	    /// </summary>
	    ///
	    static public String ArrayToRLEString(char[] a) {
	        StringBuilder buffer = new StringBuilder();
	        buffer.Append((char) (a.Length >> 16));
	        buffer.Append((char) a.Length);
	        char runValue = a[0];
	        int runLength = 1;
	        for (int i = 1; i < a.Length; ++i) {
	            char s = a[i];
	            if (s == runValue && runLength < 0xFFFF)
	                ++runLength;
	            else {
	                EncodeRun(buffer, (short) runValue, runLength);
	                runValue = s;
	                runLength = 1;
	            }
	        }
	        EncodeRun(buffer, (short) runValue, runLength);
	        return buffer.ToString();
	    }
	
	    /// <summary>
	    /// Construct a string representing a byte array. Use run-length encoding.
	    /// Two bytes are packed into a single char, with a single extra zero byte at
	    /// the end if needed. A byte represents itself, unless it is the
	    /// ESCAPE_BYTE. Then the following notations are possible: ESCAPE_BYTE
	    /// ESCAPE_BYTE ESCAPE_BYTE literal ESCAPE_BYTE n b n instances of byte b
	    /// Since an encoded run occupies 3 bytes, we only encode runs of 4 or more
	    /// bytes. Thus we have n > 0 and n != ESCAPE_BYTE and n <= 0xFF. If we
	    /// encounter a run where n == ESCAPE_BYTE, we represent this as: b
	    /// ESCAPE_BYTE n-1 b The ESCAPE_BYTE value is chosen so as not to collide
	    /// with commonly seen values.
	    /// </summary>
	    ///
	    static public String ArrayToRLEString(byte[] a) {
	        StringBuilder buffer = new StringBuilder();
	        buffer.Append((char) (a.Length >> 16));
	        buffer.Append((char) a.Length);
	        byte runValue = a[0];
	        int runLength = 1;
	        byte[] state = new byte[2];
	        for (int i = 1; i < a.Length; ++i) {
	            byte b = a[i];
	            if (b == runValue && runLength < 0xFF)
	                ++runLength;
	            else {
	                EncodeRun(buffer, runValue, runLength, state);
	                runValue = b;
	                runLength = 1;
	            }
	        }
	        EncodeRun(buffer, runValue, runLength, state);
	
	        // We must save the final byte, if there is one, by padding
	        // an extra zero.
	        if (state[0] != 0)
	            AppendEncodedByte(buffer, (byte) 0, state);
	
	        return buffer.ToString();
	    }
	
	    /// <summary>
	    /// Encode a run, possibly a degenerate run (of < 4 values).
	    /// </summary>
	    ///
	    /// <param name="length">The length of the run; must be > 0 && <= 0xFFFF.</param>
	    private static void EncodeRun(StringBuilder buffer, int value_ren,
	            int length) {
	        if (length < 4) {
	            for (int j = 0; j < length; ++j) {
	                if (value_ren == ESCAPE) {
	                    AppendInt(buffer, value_ren);
	                }
	                AppendInt(buffer, value_ren);
	            }
	        } else {
	            if (length == (int) ESCAPE) {
	                if (value_ren == (int) ESCAPE) {
	                    AppendInt(buffer, ESCAPE);
	                }
	                AppendInt(buffer, value_ren);
	                --length;
	            }
	            AppendInt(buffer, ESCAPE);
	            AppendInt(buffer, length);
	            AppendInt(buffer, value_ren); // Don't need to escape this value
	        }
	    }
	
	    private static void AppendInt(StringBuilder buffer, int value_ren) {
	        buffer.Append((char) ((int) (((uint) value_ren) >> 16)));
	        buffer.Append((char) (value_ren & 0xFFFF));
	    }
	
	    /// <summary>
	    /// Encode a run, possibly a degenerate run (of < 4 values).
	    /// </summary>
	    ///
	    /// <param name="length">The length of the run; must be > 0 && <= 0xFFFF.</param>
	    private static void EncodeRun(StringBuilder buffer, short value_ren,
	            int length) {
	        if (length < 4) {
	            for (int j = 0; j < length; ++j) {
	                if (value_ren == (int) ESCAPE)
	                    buffer.Append(ESCAPE);
	                buffer.Append((char) value_ren);
	            }
	        } else {
	            if (length == (int) ESCAPE) {
	                if (value_ren == (int) ESCAPE)
	                    buffer.Append(ESCAPE);
	                buffer.Append((char) value_ren);
	                --length;
	            }
	            buffer.Append(ESCAPE);
	            buffer.Append((char) length);
	            buffer.Append((char) value_ren); // Don't need to escape this value
	        }
	    }
	
	    /// <summary>
	    /// Encode a run, possibly a degenerate run (of < 4 values).
	    /// </summary>
	    ///
	    /// <param name="length">The length of the run; must be > 0 && <= 0xFF.</param>
	    private static void EncodeRun(StringBuilder buffer, byte value_ren,
	            int length, byte[] state) {
	        if (length < 4) {
	            for (int j = 0; j < length; ++j) {
	                if (value_ren == ESCAPE_BYTE)
	                    AppendEncodedByte(buffer, ESCAPE_BYTE, state);
	                AppendEncodedByte(buffer, value_ren, state);
	            }
	        } else {
	            if (length == ESCAPE_BYTE) {
	                if (value_ren == ESCAPE_BYTE)
	                    AppendEncodedByte(buffer, ESCAPE_BYTE, state);
	                AppendEncodedByte(buffer, value_ren, state);
	                --length;
	            }
	            AppendEncodedByte(buffer, ESCAPE_BYTE, state);
	            AppendEncodedByte(buffer, (byte) length, state);
	            AppendEncodedByte(buffer, value_ren, state); // Don't need to escape
	                                                     // this value
	        }
	    }
	
	    /// <summary>
	    /// Append a byte to the given StringBuffer, packing two bytes into each
	    /// character. The state parameter maintains intermediary data between calls.
	    /// </summary>
	    ///
	    /// <param name="state">A two-element array, with state[0] == 0 if this is the firstbyte of a pair, or state[0] != 0 if this is the second byte ofa pair, in which case state[1] is the first byte.</param>
	    private static void AppendEncodedByte(StringBuilder buffer,
	            byte value_ren, byte[] state) {
	        if (state[0] != 0) {
	            char c = (char) ((state[1] << 8) | (((int) value_ren) & 0xFF));
	            buffer.Append(c);
	            state[0] = 0;
	        } else {
	            state[0] = 1;
	            state[1] = value_ren;
	        }
	    }
	
	    /// <summary>
	    /// Construct an array of ints from a run-length encoded string.
	    /// </summary>
	    ///
	    static public int[] RLEStringToIntArray(String s) {
	        int length = GetInt(s, 0);
	        int[] array = new int[length];
	        int ai = 0, i = 1;
	
	        int maxI = s.Length / 2;
	        while (ai < length && i < maxI) {
	            int c = GetInt(s, i++);
	
	            if (c == ESCAPE) {
	                c = GetInt(s, i++);
	                if (c == ESCAPE) {
	                    array[ai++] = c;
	                } else {
	                    int runLength = c;
	                    int runValue = GetInt(s, i++);
	                    for (int j = 0; j < runLength; ++j) {
	                        array[ai++] = runValue;
	                    }
	                }
	            } else {
	                array[ai++] = c;
	            }
	        }
	
	        if (ai != length || i != maxI) {
	            throw new InvalidOperationException("Bad run-length encoded int array");
	        }
	
	        return array;
	    }
	
	    static internal int GetInt(String s, int i) {
	        return (((int) s[2 * i]) << 16) | (int) s[2 * i + 1];
	    }
	
	    /// <summary>
	    /// Construct an array of shorts from a run-length encoded string.
	    /// </summary>
	    ///
	    static public short[] RLEStringToShortArray(String s) {
	        int length = (((int) s[0]) << 16) | ((int) s[1]);
	        short[] array = new short[length];
	        int ai = 0;
	        for (int i = 2; i < s.Length; ++i) {
	            char c = s[i];
	            if (c == ESCAPE) {
	                c = s[++i];
	                if (c == ESCAPE) {
	                    array[ai++] = (short) c;
	                } else {
	                    int runLength = (int) c;
	                    short runValue = (short) s[++i];
	                    for (int j = 0; j < runLength; ++j)
	                        array[ai++] = runValue;
	                }
	            } else {
	                array[ai++] = (short) c;
	            }
	        }
	
	        if (ai != length)
	            throw new InvalidOperationException(
	                    "Bad run-length encoded short array");
	
	        return array;
	    }
	
	    /// <summary>
	    /// Construct an array of shorts from a run-length encoded string.
	    /// </summary>
	    ///
	    static public char[] RLEStringToCharArray(String s) {
	        int length = (((int) s[0]) << 16) | ((int) s[1]);
	        char[] array = new char[length];
	        int ai = 0;
	        for (int i = 2; i < s.Length; ++i) {
	            char c = s[i];
	            if (c == ESCAPE) {
	                c = s[++i];
	                if (c == ESCAPE) {
	                    array[ai++] = c;
	                } else {
	                    int runLength = (int) c;
	                    char runValue = s[++i];
	                    for (int j = 0; j < runLength; ++j)
	                        array[ai++] = runValue;
	                }
	            } else {
	                array[ai++] = c;
	            }
	        }
	
	        if (ai != length)
	            throw new InvalidOperationException(
	                    "Bad run-length encoded short array");
	
	        return array;
	    }
	
	    /// <summary>
	    /// Construct an array of bytes from a run-length encoded string.
	    /// </summary>
	    ///
	    static public sbyte[] RLEStringToByteArray(String s) {
	        int length = (((int) s[0]) << 16) | ((int) s[1]);
	        sbyte[] array = new sbyte[length];
	        bool nextChar = true;
	        char c = (char) (0);
	        int node = 0;
	        int runLength = 0;
	        int i = 2;
	        for (int ai = 0; ai < length;) {
	            // This part of the loop places the next byte into the local
	            // variable 'b' each time through the loop. It keeps the
	            // current character in 'c' and uses the boolean 'nextChar'
	            // to see if we've taken both bytes out of 'c' yet.
	            sbyte b;
	            if (nextChar) {
	                c = s[i++];
	                b = (sbyte) (c >> 8);
	                nextChar = false;
	            } else {
	                b = (sbyte) (c & 0xFF);
	                nextChar = true;
	            }
	
	            // This part of the loop is a tiny state machine which handles
	            // the parsing of the run-length encoding. This would be simpler
	            // if we could look ahead, but we can't, so we use 'node' to
	            // move between three nodes in the state machine.
	            switch (node) {
	            case 0:
	                // Normal idle node
	                if (b == ESCAPE_BYTE) {
	                    node = 1;
	                } else {
	                    array[ai++] = b;
	                }
	                break;
	            case 1:
	                // We have seen one ESCAPE_BYTE; we expect either a second
	                // one, or a run length and value.
	                if (b == ESCAPE_BYTE) {
                        throw new NotImplementedException();
	                    // array[ai++] = (sbyte) ESCAPE_BYTE;
	                    node = 0;
	                } else {
	                    runLength = b;
	                    // Interpret signed byte as unsigned
	                    if (runLength < 0)
	                        runLength += 0x100;
	                    node = 2;
	                }
	                break;
	            case 2:
	                // We have seen an ESCAPE_BYTE and length byte. We interpret
	                // the next byte as the value to be repeated.
	                for (int j = 0; j < runLength; ++j)
	                    array[ai++] = b;
	                node = 0;
	                break;
	            }
	        }
	
	        if (node != 0)
	            throw new InvalidOperationException("Bad run-length encoded byte array");
	
	        if (i != s.Length)
	            throw new InvalidOperationException(
	                    "Excess data in RLE byte array string");
	
	        return array;
	    }
	
	    static public String LINE_SEPARATOR = System.Environment.GetEnvironmentVariable("line.separator");
	
	    /// <summary>
	    /// Format a String for representation in a source file. This includes
	    /// breaking it into lines and escaping characters using octal notation when
	    /// necessary (control characters and double quotes).
	    /// </summary>
	    ///
	    static public String FormatForSource(String s) {
	        StringBuilder buffer = new StringBuilder();
	        for (int i = 0; i < s.Length;) {
	            if (i > 0)
	                buffer.Append('+').Append(LINE_SEPARATOR);
	            buffer.Append("        \"");
	            int count = 11;
	            while (i < s.Length && count < 80) {
	                char c = s[i++];
	                if (c < '\u0020' || c == '"' || c == '\\') {
	                    if (c == '\n') {
	                        buffer.Append("\\n");
	                        count += 2;
	                    } else if (c == '\t') {
	                        buffer.Append("\\t");
	                        count += 2;
	                    } else if (c == '\r') {
	                        buffer.Append("\\r");
	                        count += 2;
	                    } else {
	                        // Represent control characters, backslash and double
	                        // quote
	                        // using octal notation; otherwise the string we form
	                        // won't compile, since Unicode escape sequences are
	                        // processed before tokenization.
	                        buffer.Append('\\');
	                        buffer.Append(HEX_DIGIT[(c & 0x1c0) >> 6]); // HEX_DIGIT
	                                                                   // works for
	                                                                   // octal
	                        buffer.Append(HEX_DIGIT[(c & 0x38) >> 3]);
	                        buffer.Append(HEX_DIGIT[(c & 0x7)]);
	                        count += 4;
	                    }
	                } else if (c <= '\u007E') {
	                    buffer.Append(c);
	                    count += 1;
	                } else {
	                    buffer.Append("\\u");
	                    buffer.Append(HEX_DIGIT[(c & 0xF000) >> 12]);
	                    buffer.Append(HEX_DIGIT[(c & 0x0F00) >> 8]);
	                    buffer.Append(HEX_DIGIT[(c & 0x00F0) >> 4]);
	                    buffer.Append(HEX_DIGIT[(c & 0x000F)]);
	                    count += 6;
	                }
	            }
	            buffer.Append('"');
	        }
	        return buffer.ToString();
	    }
	
	    static internal readonly char[] HEX_DIGIT = { '0', '1', '2', '3', '4', '5', '6', '7',
	            '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
	
	    /// <summary>
	    /// Format a String for representation in a source file. Like formatForSource
	    /// but does not do line breaking.
	    /// </summary>
	    ///
	    static public String Format1ForSource(String s) {
	        StringBuilder buffer = new StringBuilder();
	        buffer.Append("\"");
	        for (int i = 0; i < s.Length;) {
	            char c = s[i++];
	            if (c < '\u0020' || c == '"' || c == '\\') {
	                if (c == '\n') {
	                    buffer.Append("\\n");
	                } else if (c == '\t') {
	                    buffer.Append("\\t");
	                } else if (c == '\r') {
	                    buffer.Append("\\r");
	                } else {
	                    // Represent control characters, backslash and double quote
	                    // using octal notation; otherwise the string we form
	                    // won't compile, since Unicode escape sequences are
	                    // processed before tokenization.
	                    buffer.Append('\\');
	                    buffer.Append(HEX_DIGIT[(c & 0x1c0) >> 6]); // HEX_DIGIT
	                                                               // works for
	                                                               // octal
	                    buffer.Append(HEX_DIGIT[(c & 0x38) >> 3]);
	                    buffer.Append(HEX_DIGIT[(c & 0x7)]);
	                }
	            } else if (c <= '\u007E') {
	                buffer.Append(c);
	            } else {
	                buffer.Append("\\u");
	                buffer.Append(HEX_DIGIT[(c & 0xF000) >> 12]);
	                buffer.Append(HEX_DIGIT[(c & 0x0F00) >> 8]);
	                buffer.Append(HEX_DIGIT[(c & 0x00F0) >> 4]);
	                buffer.Append(HEX_DIGIT[(c & 0x000F)]);
	            }
	        }
	        buffer.Append('"');
	        return buffer.ToString();
	    }
	
	    /// <summary>
	    /// Convert characters outside the range U+0020 to U+007F to Unicode escapes,
	    /// and convert backslash to a double backslash.
	    /// </summary>
	    ///
	    public static String Escape(String s) {
	        StringBuilder buf = new StringBuilder();
	        for (int i = 0; i < s.Length;) {
	            int c = IBM.ICU.Text.UTF16.CharAt(s, i);
	            i += IBM.ICU.Text.UTF16.GetCharCount(c);
	            if (c >= ' ' && c <= 0x007F) {
	                if (c == '\\') {
	                    buf.Append("\\\\"); // That is, "\\"
	                } else {
	                    buf.Append((char) c);
	                }
	            } else {
	                bool four = c <= 0xFFFF;
	                buf.Append((four) ? "\\u" : "\\U");
	                Hex(c, (four) ? 4 : 8, buf);
	            }
	        }
	        return buf.ToString();
	    }
	
	    /* This map must be in ASCENDING ORDER OF THE ESCAPE CODE */
	    static private readonly int[] UNESCAPE_MAP = {
	    /* " 0x22, 0x22 */
	    /* ' 0x27, 0x27 */
	    /* ? 0x3F, 0x3F */
	    /* \ 0x5C, 0x5C */
	    /* a */0x61, 0x07,
	    /* b */0x62, 0x08,
	    /* e */0x65, 0x1b,
	    /* f */0x66, 0x0c,
	    /* n */0x6E, 0x0a,
	    /* r */0x72, 0x0d,
	    /* t */0x74, 0x09,
	    /* v */0x76, 0x0b };
	
	    /// <summary>
	    /// Convert an escape to a 32-bit code point value. We attempt to parallel
	    /// the icu4c unescapeAt() function.
	    /// </summary>
	    ///
	    /// <param name="offset16">an array containing offset to the character <em>after</em> thebackslash. Upon return offset16[0] will be updated to pointafter the escape sequence.</param>
	    /// <returns>character value from 0 to 10FFFF, or -1 on error.</returns>
	    public static int UnescapeAt(String s, int[] offset16) {
	        int c;
	        int result = 0;
	        int n = 0;
	        int minDig = 0;
	        int maxDig = 0;
	        int bitsPerDigit = 4;
	        int dig;
	        int i;
	        bool braces = false;
	
	        /* Check that offset is in range */
	        int offset = offset16[0];
	        int length = s.Length;
	        if (offset < 0 || offset >= length) {
	            return -1;
	        }
	
	        /* Fetch first UChar after '\\' */
	        c = IBM.ICU.Text.UTF16.CharAt(s, offset);
	        offset += IBM.ICU.Text.UTF16.GetCharCount(c);
	
	        /* Convert hexadecimal and octal escapes */
	        switch (c) {
	        case 'u':
	            minDig = maxDig = 4;
	            break;
	        case 'U':
	            minDig = maxDig = 8;
	            break;
	        case 'x':
	            minDig = 1;
	            if (offset < length && IBM.ICU.Text.UTF16.CharAt(s, offset) == 0x7B /* { */) {
	                ++offset;
	                braces = true;
	                maxDig = 8;
	            } else {
	                maxDig = 2;
	            }
	            break;
	        default:
	            dig = IBM.ICU.Lang.UCharacter.Digit(c, 8);
	            if (dig >= 0) {
	                minDig = 1;
	                maxDig = 3;
	                n = 1; /* Already have first octal digit */
	                bitsPerDigit = 3;
	                result = dig;
	            }
	            break;
	        }
	        if (minDig != 0) {
	            while (offset < length && n < maxDig) {
	                c = IBM.ICU.Text.UTF16.CharAt(s, offset);
	                dig = IBM.ICU.Lang.UCharacter.Digit(c, (bitsPerDigit == 3) ? 8 : 16);
	                if (dig < 0) {
	                    break;
	                }
	                result = (result << bitsPerDigit) | dig;
	                offset += IBM.ICU.Text.UTF16.GetCharCount(c);
	                ++n;
	            }
	            if (n < minDig) {
	                return -1;
	            }
	            if (braces) {
	                if (c != 0x7D /* } */) {
	                    return -1;
	                }
	                ++offset;
	            }
	            if (result < 0 || result >= 0x110000) {
	                return -1;
	            }
	            // If an escape sequence specifies a lead surrogate, see
	            // if there is a trail surrogate after it, either as an
	            // escape or as a literal. If so, join them up into a
	            // supplementary.
	            if (offset < length && IBM.ICU.Text.UTF16.IsLeadSurrogate((char) result)) {
	                int ahead = offset + 1;
	                c = s[offset]; // [sic] get 16-bit code unit
	                if (c == '\\' && ahead < length) {
	                    int[] o = new int[] { ahead };
	                    c = UnescapeAt(s, o);
	                    ahead = o[0];
	                }
	                if (IBM.ICU.Text.UTF16.IsTrailSurrogate((char) c)) {
	                    offset = ahead;
	                    result = IBM.ICU.Impl.UCharacterProperty.GetRawSupplementary(
	                            (char) result, (char) c);
	                }
	            }
	            offset16[0] = offset;
	            return result;
	        }
	
	        /* Convert C-style escapes in table */
	        for (i = 0; i < UNESCAPE_MAP.Length; i += 2) {
	            if (c == UNESCAPE_MAP[i]) {
	                offset16[0] = offset;
	                return UNESCAPE_MAP[i + 1];
	            } else if (c < UNESCAPE_MAP[i]) {
	                break;
	            }
	        }
	
	        /* Map \cX to control-X: X & 0x1F */
	        if (c == 'c' && offset < length) {
	            c = IBM.ICU.Text.UTF16.CharAt(s, offset);
	            offset16[0] = offset + IBM.ICU.Text.UTF16.GetCharCount(c);
	            return 0x1F & c;
	        }
	
	        /*
	         * If no special forms are recognized, then consider the backslash to
	         * generically escape the next character.
	         */
	        offset16[0] = offset;
	        return c;
	    }
	
	    /// <summary>
	    /// Convert all escapes in a given string using unescapeAt().
	    /// </summary>
	    ///
	    /// <exception cref="IllegalArgumentException">if an invalid escape is seen.</exception>
	    public static String Unescape(String s) {
	        StringBuilder buf = new StringBuilder();
	        int[] pos = new int[1];
	        for (int i = 0; i < s.Length;) {
	            char c = s[i++];
	            if (c == '\\') {
	                pos[0] = i;
	                int e = UnescapeAt(s, pos);
	                if (e < 0) {
	                    throw new ArgumentException(
	                            "Invalid escape sequence "
	                                    + s.Substring(i - 1,(Math.Min(i + 8,s.Length))-(i - 1)));
	                }
	                IBM.ICU.Text.UTF16.Append(buf, e);
	                i = pos[0];
	            } else {
	                buf.Append(c);
	            }
	        }
	        return buf.ToString();
	    }
	
	    /// <summary>
	    /// Convert all escapes in a given string using unescapeAt(). Leave invalid
	    /// escape sequences unchanged.
	    /// </summary>
	    ///
	    public static String UnescapeLeniently(String s) {
	        StringBuilder buf = new StringBuilder();
	        int[] pos = new int[1];
	        for (int i = 0; i < s.Length;) {
	            char c = s[i++];
	            if (c == '\\') {
	                pos[0] = i;
	                int e = UnescapeAt(s, pos);
	                if (e < 0) {
	                    buf.Append(c);
	                } else {
	                    IBM.ICU.Text.UTF16.Append(buf, e);
	                    i = pos[0];
	                }
	            } else {
	                buf.Append(c);
	            }
	        }
	        return buf.ToString();
	    }
	
	    /// <summary>
	    /// Convert a char to 4 hex uppercase digits. E.g., hex('a') => "0041".
	    /// </summary>
	    ///
	    public static String Hex(char ch) {
	        StringBuilder temp = new StringBuilder();
	        return Hex(ch, temp).ToString();
	    }
	
	    /// <summary>
	    /// Convert a string to comma-separated groups of 4 hex uppercase digits.
	    /// E.g., hex('ab') => "0041,0042".
	    /// </summary>
	    ///
	    public static String Hex(String s) {
	        StringBuilder temp = new StringBuilder();
	        return Hex(s, temp).ToString();
	    }
	
	    /// <summary>
	    /// Convert a string to comma-separated groups of 4 hex uppercase digits.
	    /// E.g., hex('ab') => "0041,0042".
	    /// </summary>
	    ///
	    public static String Hex(StringBuilder s) {
	        return Hex(s.ToString());
	    }
	
	    /// <summary>
	    /// Convert a char to 4 hex uppercase digits. E.g., hex('a') => "0041".
	    /// Append the output to the given StringBuffer.
	    /// </summary>
	    ///
	    public static StringBuilder Hex(char ch, StringBuilder output) {
	        return AppendNumber(output, ch, 16, 4);
	    }
	
	    /// <summary>
	    /// Convert a integer to size width hex uppercase digits. E.g., hex('a', 4,
	    /// str) => "0041". Append the output to the given StringBuffer. If width is
	    /// too small to fit, nothing will be appended to output.
	    /// </summary>
	    ///
	    public static StringBuilder Hex(int ch, int width, StringBuilder output) {
	        return AppendNumber(output, ch, 16, width);
	    }
	
	    /// <summary>
	    /// Convert a integer to size width (minimum) hex uppercase digits. E.g.,
	    /// hex('a', 4, str) => "0041". If the integer requires more than width
	    /// digits, more will be used.
	    /// </summary>
	    ///
	    public static String Hex(int ch, int width) {
	        StringBuilder buf = new StringBuilder();
	        return AppendNumber(buf, ch, 16, width).ToString();
	    }
	
	    /// <summary>
	    /// Supplies a zero-padded hex representation of an integer (without 0x)
	    /// </summary>
	    ///
	    static public String Hex(long i, int places) {
	        if (i == Int64.MinValue)
	            return "-8000000000000000";
	        bool negative = i < 0;
	        if (negative) {
	            i = -i;
	        }
            
	        String result = Int64Helper.ToString(i, 16).ToUpper();
	        if (result.Length < places) {
	            result = "0000000000000000".Substring(result.Length,(places)-(result.Length))
	                    + result;
	        }
	        if (negative) {
	            return '-' + result;
	        }
	        return result;
	    }
	
	    public static String Hex(long ch) {
	        return Hex(ch, 4);
	    }
	
	    /// <summary>
	    /// Convert a string to comma-separated groups of 4 hex uppercase digits.
	    /// E.g., hex('ab') => "0041,0042". Append the output to the given
	    /// StringBuffer.
	    /// </summary>
	    ///
	    public static StringBuilder Hex(String s, StringBuilder result) {
	        for (int i = 0; i < s.Length; ++i) {
	            if (i != 0)
	                result.Append(',');
	            Hex(s[i], result);
	        }
	        return result;
	    }
	
	    /// <summary>
	    /// Split a string into pieces based on the given divider character
	    /// </summary>
	    ///
	    /// <param name="s">the string to split</param>
	    /// <param name="divider">the character on which to split. Occurrences of this characterare not included in the output</param>
	    /// <param name="output">an array to receive the substrings between instances ofdivider. It must be large enough on entry to accomodate alloutput. Adjacent instances of the divider character will placeempty strings into output. Before returning, output is paddedout with empty strings.</param>
	    public static void Split(String s, char divider, String[] output) {
	        int last = 0;
	        int current = 0;
	        int i;
	        for (i = 0; i < s.Length; ++i) {
	            if (s[i] == divider) {
	                output[current++] = s.Substring(last,(i)-(last));
	                last = i + 1;
	            }
	        }
	        output[current++] = s.Substring(last,(i)-(last));
	        while (current < output.Length) {
	            output[current++] = "";
	        }
	    }
	
	    /// <summary>
	    /// Split a string into pieces based on the given divider character
	    /// </summary>
	    ///
	    /// <param name="s">the string to split</param>
	    /// <param name="divider">the character on which to split. Occurrences of this characterare not included in the output</param>
	    /// <returns>output an array to receive the substrings between instances of
	    /// divider. Adjacent instances of the divider character will place
	    /// empty strings into output.</returns>
	    public static String[] Split(String s, char divider) {
	        int last = 0;
	        int i;
	        ArrayList output = new ArrayList();
	        for (i = 0; i < s.Length; ++i) {
	            if (s[i] == divider) {
	                ILOG.J2CsMapping.Collections.Generics.Collections.Add(output,s.Substring(last,(i)-(last)));
	                last = i + 1;
	            }
	        }
	        ILOG.J2CsMapping.Collections.Generics.Collections.Add(output,s.Substring(last,(i)-(last)));
	        return (String[]) ILOG.J2CsMapping.Collections.Generics.Collections.ToArray(output,new String[output.Count]);
	    }
	
	    /// <summary>
	    /// Look up a given string in a string array. Returns the index at which the
	    /// first occurrence of the string was found in the array, or -1 if it was
	    /// not found.
	    /// </summary>
	    ///
	    /// <param name="source">the string to search for</param>
	    /// <param name="target">the array of zero or more strings in which to look for source</param>
	    /// <returns>the index of target at which source first occurs, or -1 if not
	    /// found</returns>
	    public static int Lookup(String source, String[] target) {
	        for (int i = 0; i < target.Length; ++i) {
	            if (source.Equals(target[i]))
	                return i;
	        }
	        return -1;
	    }
	
	    /// <summary>
	    /// Skip over a sequence of zero or more white space characters at pos.
	    /// Return the index of the first non-white-space character at or after pos,
	    /// or str.length(), if there is none.
	    /// </summary>
	    ///
	    public static int SkipWhitespace(String str, int pos) {
	        while (pos < str.Length) {
	            int c = IBM.ICU.Text.UTF16.CharAt(str, pos);
	            if (!IBM.ICU.Impl.UCharacterProperty.IsRuleWhiteSpace(c)) {
	                break;
	            }
	            pos += IBM.ICU.Text.UTF16.GetCharCount(c);
	        }
	        return pos;
	    }
	
	    /// <summary>
	    /// Skip over a sequence of zero or more white space characters at pos[0],
	    /// advancing it.
	    /// </summary>
	    ///
	    public static void SkipWhitespace(String str, int[] pos) {
	        pos[0] = SkipWhitespace(str, pos[0]);
	    }
	
	    /// <summary>
	    /// Remove all rule white space from a string.
	    /// </summary>
	    ///
	    public static String DeleteRuleWhiteSpace(String str) {
	        StringBuilder buf = new StringBuilder();
	        for (int i = 0; i < str.Length;) {
	            int ch = IBM.ICU.Text.UTF16.CharAt(str, i);
	            i += IBM.ICU.Text.UTF16.GetCharCount(ch);
	            if (IBM.ICU.Impl.UCharacterProperty.IsRuleWhiteSpace(ch)) {
	                continue;
	            }
	            IBM.ICU.Text.UTF16.Append(buf, ch);
	        }
	        return buf.ToString();
	    }
	
	    /// <summary>
	    /// Parse a single non-whitespace character 'ch', optionally preceded by
	    /// whitespace.
	    /// </summary>
	    ///
	    /// <param name="id">the string to be parsed</param>
	    /// <param name="pos">INPUT-OUTPUT parameter. On input, pos[0] is the offset of thefirst character to be parsed. On output, pos[0] is the indexafter the last parsed character. If the parse fails, pos[0]will be unchanged.</param>
	    /// <param name="ch">the non-whitespace character to be parsed.</param>
	    /// <returns>true if 'ch' is seen preceded by zero or more whitespace
	    /// characters.</returns>
	    public static bool ParseChar(String id, int[] pos, char ch) {
	        int start = pos[0];
	        SkipWhitespace(id, pos);
	        if (pos[0] == id.Length || id[pos[0]] != ch) {
	            pos[0] = start;
	            return false;
	        }
	        ++pos[0];
	        return true;
	    }
	
	    /// <summary>
	    /// Parse a pattern string starting at offset pos. Keywords are matched
	    /// case-insensitively. Spaces may be skipped and may be optional or
	    /// required. Integer values may be parsed, and if they are, they will be
	    /// returned in the given array. If successful, the offset of the next
	    /// non-space character is returned. On failure, -1 is returned.
	    /// </summary>
	    ///
	    /// <param name="pattern">must only contain lowercase characters, which will match theiruppercase equivalents as well. A space character matches oneor more required spaces. A '~' character matches zero or moreoptional spaces. A '#' character matches an integer and storesit in parsedInts, which the caller must ensure has enoughcapacity.</param>
	    /// <param name="parsedInts">array to receive parsed integers. Caller must ensure thatparsedInts.length is >= the number of '#' signs in 'pattern'.</param>
	    /// <returns>the position after the last character parsed, or -1 if the parse
	    /// failed</returns>
	    public static int ParsePattern(String rule, int pos, int limit,
	            String pattern, int[] parsedInts) {
	        // TODO Update this to handle surrogates
	        int[] p = new int[1];
	        int intCount = 0; // number of integers parsed
	        for (int i = 0; i < pattern.Length; ++i) {
	            char cpat = pattern[i];
	            char c;
	            switch ((int) cpat) {
	            case ' ':
	                if (pos >= limit) {
	                    return -1;
	                }
	                c = rule[pos++];
	                if (!IBM.ICU.Impl.UCharacterProperty.IsRuleWhiteSpace(c)) {
	                    return -1;
	                }
	                {
	                    pos = SkipWhitespace(rule, pos);
	                    break;
	                }
	                break;
	            // FALL THROUGH to skipWhitespace
	            case '~':
	                pos = SkipWhitespace(rule, pos);
	                break;
	            case '#':
	                p[0] = pos;
	                parsedInts[intCount++] = ParseInteger(rule, p, limit);
	                if (p[0] == pos) {
	                    // Syntax error; failed to parse integer
	                    return -1;
	                }
	                pos = p[0];
	                break;
	            default:
	                if (pos >= limit) {
	                    return -1;
	                }
	                c = (char) IBM.ICU.Lang.UCharacter.ToLowerCase(rule[pos++]);
	                if (c != cpat) {
	                    return -1;
	                }
	                break;
	            }
	        }
	        return pos;
	    }
	
	    /// <summary>
	    /// Parse a pattern string within the given Replaceable and a parsing
	    /// pattern. Characters are matched literally and case-sensitively except for
	    /// the following special characters:
	    /// ~ zero or more uprv_isRuleWhiteSpace chars
	    /// If end of pattern is reached with all matches along the way, pos is
	    /// advanced to the first unparsed index and returned. Otherwise -1 is
	    /// returned.
	    /// </summary>
	    ///
	    /// <param name="pat">pattern that controls parsing</param>
	    /// <param name="text">text to be parsed, starting at index</param>
	    /// <param name="index">offset to first character to parse</param>
	    /// <param name="limit">offset after last character to parse</param>
	    /// <returns>index after last parsed character, or -1 on parse failure.</returns>
	    public static int ParsePattern(String pat, Replaceable text, int index,
	            int limit) {
	        int ipat = 0;
	
	        // empty pattern matches immediately
	        if (ipat == pat.Length) {
	            return index;
	        }
	
	        int cpat = IBM.ICU.Text.UTF16.CharAt(pat, ipat);
	
	        while (index < limit) {
	            int c = text.Char32At(index);
	
	            // parse \s*
	            if (cpat == '~') {
	                if (IBM.ICU.Impl.UCharacterProperty.IsRuleWhiteSpace(c)) {
	                    index += IBM.ICU.Text.UTF16.GetCharCount(c);
	                    continue;
	                } else {
	                    if (++ipat == pat.Length) {
	                        return index; // success; c unparsed
	                    }
	                    // fall thru; process c again with next cpat
	                }
	            }
	
	            // parse literal
	            else if (c == cpat) {
	                int n = IBM.ICU.Text.UTF16.GetCharCount(c);
	                index += n;
	                ipat += n;
	                if (ipat == pat.Length) {
	                    return index; // success; c parsed
	                }
	                // fall thru; get next cpat
	            }
	
	            // match failure of literal
	            else {
	                return -1;
	            }
	
	            cpat = IBM.ICU.Text.UTF16.CharAt(pat, ipat);
	        }
	
	        return -1; // text ended before end of pat
	    }
	
	    /// <summary>
	    /// Parse an integer at pos, either of the form \d+ or of the form
	    /// 0x[0-9A-Fa-f]+ or 0[0-7]+, that is, in standard decimal, hex, or octal
	    /// format.
	    /// </summary>
	    ///
	    /// <param name="pos">INPUT-OUTPUT parameter. On input, the first character toparse. On output, the character after the last parsedcharacter.</param>
	    public static int ParseInteger(String rule, int[] pos, int limit) {
	        int count = 0;
	        int value_ren = 0;
	        int p = pos[0];
	        int radix = 10;
	
	        if (StringUtil.RegionMatches(rule, true, p, "0x", 0, 2)) {
	            p += 2;
	            radix = 16;
	        } else if (p < limit && rule[p] == '0') {
	            p++;
	            count = 1;
	            radix = 8;
	        }
	
	        while (p < limit) {
	            int d = IBM.ICU.Lang.UCharacter.Digit(rule[p++], radix);
	            if (d < 0) {
	                --p;
	                break;
	            }
	            ++count;
	            int v = (value_ren * radix) + d;
	            if (v <= value_ren) {
	                // If there are too many input digits, at some point
	                // the value will go negative, e.g., if we have seen
	                // "0x8000000" already and there is another '0', when
	                // we parse the next 0 the value will go negative.
	                return 0;
	            }
	            value_ren = v;
	        }
	        if (count > 0) {
	            pos[0] = p;
	        }
	        return value_ren;
	    }
	
	    /// <summary>
	    /// Parse a Unicode identifier from the given string at the given position.
	    /// Return the identifier, or null if there is no identifier.
	    /// </summary>
	    ///
	    /// <param name="str">the string to parse</param>
	    /// <param name="pos">INPUT-OUPUT parameter. On INPUT, pos[0] is the first characterto examine. It must be less than str.length(), and it must notpoint to a whitespace character. That is, must have pos[0] <str.length() and!UCharacterProperty.isRuleWhiteSpace(UTF16.charAt(str,pos[0])). On OUTPUT, the position after the last parsedcharacter.</param>
	    /// <returns>the Unicode identifier, or null if there is no valid identifier
	    /// at pos[0].</returns>
	    public static String ParseUnicodeIdentifier(String str, int[] pos) {
	        // assert(pos[0] < str.length());
	        // assert(!UCharacterProperty.isRuleWhiteSpace(UTF16.charAt(str,
	        // pos[0])));
	        StringBuilder buf = new StringBuilder();
	        int p = pos[0];
	        while (p < str.Length) {
	            int ch = IBM.ICU.Text.UTF16.CharAt(str, p);
	            if (buf.Length == 0) {
	                if (IBM.ICU.Lang.UCharacter.IsUnicodeIdentifierStart(ch)) {
	                    IBM.ICU.Text.UTF16.Append(buf, ch);
	                } else {
	                    return null;
	                }
	            } else {
	                if (IBM.ICU.Lang.UCharacter.IsUnicodeIdentifierPart(ch)) {
	                    IBM.ICU.Text.UTF16.Append(buf, ch);
	                } else {
	                    break;
	                }
	            }
	            p += IBM.ICU.Text.UTF16.GetCharCount(ch);
	        }
	        pos[0] = p;
	        return buf.ToString();
	    }
	
	    /// <summary>
	    /// Trim whitespace from ends of a StringBuffer.
	    /// </summary>
	    ///
	    public static StringBuilder Trim(StringBuilder b) {
	        // TODO update to handle surrogates
	        int i;
	        for (i = 0; i < b.Length && Char.IsWhiteSpace(b[i]); ++i) {
	        }
	        b.Remove(0,i-(0));
	        for (i = b.Length - 1; i >= 0 && Char.IsWhiteSpace(b[i]); --i) {
	        }
	        return b.Remove(i + 1,b.Length-(i + 1));
	    }
	
	    static internal readonly char[] DIGITS = { '0', '1', '2', '3', '4', '5', '6', '7', '8',
	            '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L',
	            'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y',
	            'Z' };
	
	    /// <summary>
	    /// Append a number to the given StringBuffer in the radix 10 generating at
	    /// least one digit.
	    /// </summary>
	    ///
	    public static StringBuilder AppendNumber(StringBuilder result, int n) {
	        return AppendNumber(result, n, 10, 1);
	    }
	
	    /// <summary>
	    /// Append the digits of a positive integer to the given
	    /// <c>StringBuffer</c> in the given radix. This is done recursively
	    /// since it is easiest to generate the low- order digit first, but it must
	    /// be appended last.
	    /// </summary>
	    ///
	    /// <param name="result">is the <c>StringBuffer</c> to append to</param>
	    /// <param name="n">is the positive integer</param>
	    /// <param name="radix">is the radix, from 2 to 36 inclusive</param>
	    /// <param name="minDigits">is the minimum number of digits to append.</param>
	    private static void RecursiveAppendNumber(StringBuilder result, int n,
	            int radix, int minDigits) {
	        int digit = n % radix;
	
	        if (n >= radix || minDigits > 1) {
	            RecursiveAppendNumber(result, n / radix, radix, minDigits - 1);
	        }
	
	        result.Append(DIGITS[digit]);
	    }
	
	    /// <summary>
	    /// Append a number to the given StringBuffer in the given radix. Standard
	    /// digits '0'-'9' are used and letters 'A'-'Z' for radices 11 through 36.
	    /// </summary>
	    ///
	    /// <param name="result">the digits of the number are appended here</param>
	    /// <param name="n">the number to be converted to digits; may be negative. Ifnegative, a '-' is prepended to the digits.</param>
	    /// <param name="radix">a radix from 2 to 36 inclusive.</param>
	    /// <param name="minDigits">the minimum number of digits, not including any '-', toproduce. Values less than 2 have no effect. One digit isalways emitted regardless of this parameter.</param>
	    /// <returns>a reference to result</returns>
	    public static StringBuilder AppendNumber(StringBuilder result, int n,
	            int radix, int minDigits) {
	        if (radix < 2 || radix > 36) {
	            throw new ArgumentException("Illegal radix " + radix);
	        }
	
	        int abs = n;
	
	        if (n < 0) {
	            abs = -n;
	            result.Append("-");
	        }
	
	        RecursiveAppendNumber(result, abs, radix, minDigits);
	
	        return result;
	    }
	
	    /// <summary>
	    /// Parse an unsigned 31-bit integer at the given offset. Use
	    /// UCharacter.digit() to parse individual characters into digits.
	    /// </summary>
	    ///
	    /// <param name="text">the text to be parsed</param>
	    /// <param name="pos">INPUT-OUTPUT parameter. On entry, pos[0] is the offset withintext at which to start parsing; it should point to a validdigit. On exit, pos[0] is the offset after the last parsedcharacter. If the parse failed, it will be unchanged on exit.Must be >= 0 on entry.</param>
	    /// <param name="radix">the radix in which to parse; must be >= 2 and <= 36.</param>
	    /// <returns>a non-negative parsed number, or -1 upon parse failure. Parse
	    /// fails if there are no digits, that is, if pos[0] does not point
	    /// to a valid digit on entry, or if the number to be parsed does not
	    /// fit into a 31-bit unsigned integer.</returns>
	    public static int ParseNumber(String text, int[] pos, int radix) {
	        // assert(pos[0] >= 0);
	        // assert(radix >= 2);
	        // assert(radix <= 36);
	        int n = 0;
	        int p = pos[0];
	        while (p < text.Length) {
	            int ch = IBM.ICU.Text.UTF16.CharAt(text, p);
	            int d = IBM.ICU.Lang.UCharacter.Digit(ch, radix);
	            if (d < 0) {
	                break;
	            }
	            n = radix * n + d;
	            // ASSUME that when a 32-bit integer overflows it becomes
	            // negative. E.g., 214748364 * 10 + 8 => negative value.
	            if (n < 0) {
	                return -1;
	            }
	            ++p;
	        }
	        if (p == pos[0]) {
	            return -1;
	        }
	        pos[0] = p;
	        return n;
	    }
	
	    /// <summary>
	    /// Return true if the character is NOT printable ASCII. The tab, newline and
	    /// linefeed characters are considered unprintable.
	    /// </summary>
	    ///
	    public static bool IsUnprintable(int c) {
	        return !(c >= 0x20 && c <= 0x7E);
	    }
	
	    /// <summary>
	    /// Escape unprintable characters using <backslash>uxxxx notation for U+0000
	    /// to U+FFFF and <backslash>Uxxxxxxxx for U+10000 and above. If the
	    /// character is printable ASCII, then do nothing and return FALSE.
	    /// Otherwise, append the escaped notation and return TRUE.
	    /// </summary>
	    ///
	    public static bool EscapeUnprintable(StringBuilder result, int c) {
	        if (IsUnprintable(c)) {
	            result.Append('\\');
	            if ((c & ~0xFFFF) != 0) {
	                result.Append('U');
	                result.Append(DIGITS[0xF & (c >> 28)]);
	                result.Append(DIGITS[0xF & (c >> 24)]);
	                result.Append(DIGITS[0xF & (c >> 20)]);
	                result.Append(DIGITS[0xF & (c >> 16)]);
	            } else {
	                result.Append('u');
	            }
	            result.Append(DIGITS[0xF & (c >> 12)]);
	            result.Append(DIGITS[0xF & (c >> 8)]);
	            result.Append(DIGITS[0xF & (c >> 4)]);
	            result.Append(DIGITS[0xF & c]);
	            return true;
	        }
	        return false;
	    }
	
	    /// <summary>
	    /// Returns the index of the first character in a set, ignoring quoted text.
	    /// For example, in the string "abc'hide'h", the 'h' in "hide" will not be
	    /// found by a search for "h". Unlike String.indexOf(), this method searches
	    /// not for a single character, but for any character of the string
	    /// <c>setOfChars</c>.
	    /// </summary>
	    ///
	    /// <param name="text">text to be searched</param>
	    /// <param name="start">the beginning index, inclusive; <code>0 <= start<= limit</code>.</param>
	    /// <param name="limit">the ending index, exclusive; <code>start <= limit<= text.length()</code>.</param>
	    /// <param name="setOfChars">string with one or more distinct characters</param>
	    /// <returns>Offset of the first character in <c>setOfChars</c> found,
	    /// or -1 if not found.</returns>
	    /// <seealso cref="null"/>
	    public static int QuotedIndexOf(String text, int start, int limit,
	            String setOfChars) {
	        for (int i = start; i < limit; ++i) {
	            char c = text[i];
	            if (c == BACKSLASH) {
	                ++i;
	            } else if (c == APOSTROPHE) {
	                while (++i < limit && text[i] != APOSTROPHE) {
	                }
	            } else if (setOfChars.IndexOf(c) >= 0) {
	                return i;
	            }
	        }
	        return -1;
	    }
	
	    /// <summary>
	    /// Similar to StringBuffer.getChars, version 1.3. Since JDK 1.2 implements
	    /// StringBuffer.getChars differently, this method is here to provide
	    /// consistent results. To be removed after JDK 1.2 ceased to be the
	    /// reference platform.
	    /// </summary>
	    ///
	    /// <param name="src">source string buffer</param>
	    /// <param name="srcBegin">offset to the start of the src to retrieve from</param>
	    /// <param name="srcEnd">offset to the end of the src to retrieve from</param>
	    /// <param name="dst">char array to store the retrieved chars</param>
	    /// <param name="dstBegin">offset to the start of the destination char array to store theretrieved chars</param>
	    /// @draft since ICU4J 2.0
	    public static void GetChars(StringBuilder src, int srcBegin, int srcEnd,
	            char[] dst, int dstBegin) {
	        if (srcBegin == srcEnd) {
	            return;
	        }
	        src.CopyTo(srcBegin,dst,dstBegin,srcEnd);
	    }
	
	    /// <summary>
	    /// Append a character to a rule that is being built up. To flush the
	    /// quoteBuf to rule, make one final call with isLiteral == true. If there is
	    /// no final character, pass in (int)-1 as c.
	    /// </summary>
	    ///
	    /// <param name="rule">the string to append the character to</param>
	    /// <param name="c">the character to append, or (int)-1 if none.</param>
	    /// <param name="isLiteral">if true, then the given character should not be quoted orescaped. Usually this means it is a syntactic element such as> or $</param>
	    /// <param name="escapeUnprintable">if true, then unprintable characters should be escaped usingescapeUnprintable(). These escapes will appear outside ofquotes.</param>
	    /// <param name="quoteBuf">a buffer which is used to build up quoted substrings. Thecaller should initially supply an empty buffer, and thereaftershould not modify the buffer. The buffer should be cleared outby, at the end, calling this method with a literal character(which may be -1).</param>
	    public static void AppendToRule(StringBuilder rule, int c,
	            bool isLiteral, bool escapeUnprintable, StringBuilder quoteBuf) {
	        // If we are escaping unprintables, then escape them outside
	        // quotes. \\u and \\U are not recognized within quotes. The same
	        // logic applies to literals, but literals are never escaped.
	        if (isLiteral || (escapeUnprintable && Utility.IsUnprintable(c))) {
	            if (quoteBuf.Length > 0) {
	                // We prefer backslash APOSTROPHE to double APOSTROPHE
	                // (more readable, less similar to ") so if there are
	                // double APOSTROPHEs at the ends, we pull them outside
	                // of the quote.
	
	                // If the first thing in the quoteBuf is APOSTROPHE
	                // (doubled) then pull it out.
	                while (quoteBuf.Length >= 2
	                        && quoteBuf[0] == APOSTROPHE
	                        && quoteBuf[1] == APOSTROPHE) {
	                    rule.Append(BACKSLASH).Append(APOSTROPHE);
	                    quoteBuf.Remove(0,2-(0));
	                }
	                // If the last thing in the quoteBuf is APOSTROPHE
	                // (doubled) then remove and count it and add it after.
	                int trailingCount = 0;
	                while (quoteBuf.Length >= 2
	                        && quoteBuf[quoteBuf.Length - 2] == APOSTROPHE
	                        && quoteBuf[quoteBuf.Length - 1] == APOSTROPHE) {
	                    quoteBuf.Length=quoteBuf.Length - 2;
	                    ++trailingCount;
	                }
	                if (quoteBuf.Length > 0) {
	                    rule.Append(APOSTROPHE);
	                    // jdk 1.3.1 does not have append(StringBuffer) yet
	                    if (IBM.ICU.Impl.ICUDebug.isJDK14OrHigher) {
	                        rule.Append(quoteBuf);
	                    } else {
	                        rule.Append(quoteBuf.ToString());
	                    }
	                    rule.Append(APOSTROPHE);
	                    quoteBuf.Length=0;
	                }
	                while (trailingCount-- > 0) {
	                    rule.Append(BACKSLASH).Append(APOSTROPHE);
	                }
	            }
	            if (c != -1) {
	                /*
	                 * Since spaces are ignored during parsing, they are emitted
	                 * only for readability. We emit one here only if there isn't
	                 * already one at the end of the rule.
	                 */
	                if (c == ' ') {
	                    int len = rule.Length;
	                    if (len > 0 && rule[len - 1] != ' ') {
	                        rule.Append(' ');
	                    }
	                } else if (!escapeUnprintable
	                        || !Utility.EscapeUnprintable(rule, c)) {
	                    IBM.ICU.Text.UTF16.Append(rule, c);
	                }
	            }
	        }
	
	        // Escape ' and '\' and don't begin a quote just for them
	        else if (quoteBuf.Length == 0 && (c == APOSTROPHE || c == BACKSLASH)) {
	            rule.Append(BACKSLASH).Append((char) c);
	        }
	
	        // Specials (printable ascii that isn't [0-9a-zA-Z]) and
	        // whitespace need quoting. Also append stuff to quotes if we are
	        // building up a quoted substring already.
	        else if (quoteBuf.Length > 0
	                || (c >= 0x0021 && c <= 0x007E && !((c >= 0x0030/* '0' */&& c <= 0x0039/* '9' */)
	                        || (c >= 0x0041/* 'A' */&& c <= 0x005A/* 'Z' */) || (c >= 0x0061/* 'a' */&& c <= 0x007A/* 'z' */)))
	                || IBM.ICU.Impl.UCharacterProperty.IsRuleWhiteSpace(c)) {
	            IBM.ICU.Text.UTF16.Append(quoteBuf, c);
	            // Double ' within a quote
	            if (c == APOSTROPHE) {
	                quoteBuf.Append((char) c);
	            }
	        }
	
	        // Otherwise just append
	        else {
	            IBM.ICU.Text.UTF16.Append(rule, c);
	        }
	    }
	
	    /// <summary>
	    /// Append the given string to the rule. Calls the single-character version
	    /// of appendToRule for each character.
	    /// </summary>
	    ///
	    public static void AppendToRule(StringBuilder rule, String text,
	            bool isLiteral, bool escapeUnprintable, StringBuilder quoteBuf) {
	        for (int i = 0; i < text.Length; ++i) {
	            // Okay to process in 16-bit code units here
	            AppendToRule(rule, text[i], isLiteral, escapeUnprintable,
	                    quoteBuf);
	        }
	    }
	
	    /// <summary>
	    /// Given a matcher reference, which may be null, append its pattern as a
	    /// literal to the given rule.
	    /// </summary>
	    ///
	    public static void AppendToRule(StringBuilder rule, UnicodeMatcher matcher,
	            bool escapeUnprintable, StringBuilder quoteBuf) {
	        if (matcher != null) {
	            AppendToRule(rule, matcher.ToPattern(escapeUnprintable), true,
	                    escapeUnprintable, quoteBuf);
	        }
	    }
	
	    /// <summary>
	    /// Compares 2 unsigned integers
	    /// </summary>
	    ///
	    /// <param name="source">32 bit unsigned integer</param>
	    /// <param name="target">32 bit unsigned integer</param>
	    /// <returns>0 if equals, 1 if source is greater than target and -1 otherwise</returns>
	    public static int CompareUnsigned(int source, int target) {
	        source += MAGIC_UNSIGNED;
	        target += MAGIC_UNSIGNED;
	        if (source < target) {
	            return -1;
	        } else if (source > target) {
	            return 1;
	        }
	        return 0;
	    }
	
	    /// <summary>
	    /// Find the highest bit in a positive integer. This is done by doing a
	    /// binary search through the bits.
	    /// </summary>
	    ///
	    /// <param name="n">is the integer</param>
	    /// <returns>the bit number of the highest bit, with 0 being the low order
	    /// bit, or -1 if <c>n</c> is not positive</returns>
	    public static sbyte HighBit(int n) {
	        if (n <= 0) {
	            return -1;
	        }
	
	        sbyte bit = 0;
	
	        if (n >= 1 << 16) {
	            n >>= 16;
	            bit += 16;
	        }
	
	        if (n >= 1 << 8) {
	            n >>= 8;
	            bit += 8;
	        }
	
	        if (n >= 1 << 4) {
	            n >>= 4;
	            bit += 4;
	        }
	
	        if (n >= 1 << 2) {
	            n >>= 2;
	            bit += 2;
	        }
	
	        if (n >= 1 << 1) {
	            n >>= 1;
	            bit += 1;
	        }
	
	        return bit;
	    }
	
	    /// <summary>
	    /// Utility method to take a int[] containing codepoints and return a string
	    /// representation with code units.
	    /// </summary>
	    ///
	    public static String ValueOf(int[] source) {
	        // TODO: Investigate why this method is not on UTF16 class
	        StringBuilder result = new StringBuilder(source.Length);
	        for (int i = 0; i < source.Length; i++) {
	            IBM.ICU.Text.UTF16.Append(result, source[i]);
	        }
	        return result.ToString();
	    }
	
	    /// <summary>
	    /// Utility to duplicate a string count times
	    /// </summary>
	    ///
	    /// <param name="s"></param>
	    /// <param name="count"></param>
	    public static String Repeat(String s, int count) {
	        if (count <= 0)
	            return "";
	        if (count == 1)
	            return s;
	        StringBuilder result = new StringBuilder();
	        for (int i = 0; i < count; ++i) {
	            result.Append(s);
	        }
	        return result.ToString();
	    }
	
	    // !!! 1.3 compatibility
	    public static int IndexOf(StringBuilder buf, String s) {
	        // #if defined(FOUNDATION10) || defined(J2SE13)
	        // ## return buf.toString().indexOf(s);
	        // #else
	        return buf.ToString().IndexOf(s);
	        // #endif
	    }
	
	    // !!! 1.3 compatibility
	    public static int LastIndexOf(StringBuilder buf, String s) {
	        // #if defined(FOUNDATION10) || defined(J2SE13)
	        // ## return buf.toString().lastIndexOf(s);
	        // #else
            return buf.ToString().LastIndexOf(s);
	        // #endif
	    }
	
	    // !!! 1.3 compatibility
	    public static int IndexOf(StringBuilder buf, String s, int i) {
	        // #if defined(FOUNDATION10) || defined(J2SE13)
	        // ## return buf.toString().indexOf(s, i);
	        // #else
            return buf.ToString().IndexOf(s, i);
	        // #endif
	    }
	
	    // !!! 1.3 compatibility
	    public static int LastIndexOf(StringBuilder buf, String s, int i) {
	        // #if defined(FOUNDATION10) || defined(J2SE13)
	        // ## return buf.toString().lastIndexOf(s, i);
	        // #else
            return buf.ToString().LastIndexOf(s, i);
	        // #endif
	    }
	
	    // !!! 1.3 compatibility
	    public static String ReplaceAll(String src, String target,
	            String replacement) {
	        // #if defined(FOUNDATION10) || defined(J2SE13)
	        // ## int i = src.indexOf(target);
	        // ## if (i == -1) {
	        // ## return src;
	        // ## }
	        // ## StringBuffer buf = new StringBuffer();
	        // ## int n = 0;
	        // ## do {
	        // ## buf.append(src.substring(n, i));
	        // ## buf.append(replacement);
	        // ## n = i + target.length();
	        // ## i = src.indexOf(target, n);
	        // ## } while (i != -1);
	        // ## if (n < src.length()) {
	        // ## buf.append(src.substring(n));
	        // ## }
	        // ## return buf.toString();
	        // #else
	        return src.Replace(target, replacement);
	        // #endif
	    }
	
	    // private static final String REGEX_SPECIALS = ".^$[]*+?|()";
	
	    // !!! 1.3 compatibility
	    // Note: target is not a string literal, not a regular expression.
	    public static String[] SplitString(String src, String target) {
	        // #if defined(FOUNDATION10) || defined(J2SE13)
	        // ## int i = src.indexOf(target);
	        // ## if (i == -1) {
	        // ## return new String[] { src };
	        // ## }
	        // ## ArrayList output = new ArrayList();
	        // ## int n = 0;
	        // ## do {
	        // ## output.add(src.substring(n, i));
	        // ## n = i + target.length();
	        // ## i = src.indexOf(target, n);
	        // ## } while (i != -1);
	        // ## if (n < src.length()) {
	        // ## output.add(src.substring(n));
	        // ## }
	        // ## return (String[]) output.toArray(new String[output.size()]);
	        // #else
	        return ILOG.J2CsMapping.Text.RegExUtil.Split(src, "\\Q" + target + "\\E");
	        // #endif
	    }
	
	    // !!! 1.3 compatibility
	    /// <summary>
	    /// Split the string at runs of ascii whitespace characters.
	    /// </summary>
	    ///
	    public static String[] SplitWhitespace(String src) {
	        // #if defined(FOUNDATION10) || defined(J2SE13)
	        // ## char ws[] = "\u0020\u0009\n\u000b\u000c\r".toCharArray();
	        // ## ArrayList output = new ArrayList();
	        // ## boolean inWhitespace = true;
	        // ## int n = 0;
	        // ## loop:
	        // ## for (int i = 0; i < src.length(); ++i) {
	        // ## char c = src.charAt(i);
	        // ## for (int j = 0; j < ws.length; ++j) {
	        // ## if (ws[j] == c) {
	        // ## if (!inWhitespace) {
	        // ## output.add(src.substring(n, i));
	        // ## inWhitespace = true;
	        // ## }
	        // ## continue loop;
	        // ## }
	        // ## }
	        // ## if (inWhitespace) {
	        // ## n = i;
	        // ## inWhitespace = false;
	        // ## }
	        // ## }
	        // ## if (n < src.length()) {
	        // ## output.add(src.substring(n));
	        // ## }
	        // ## return (String[]) output.toArray(new String[output.size()]);
	        // #else
	        return ILOG.J2CsMapping.Text.RegExUtil.Split(src, "\\s+");
	        // #endif
	    }
	}
}
