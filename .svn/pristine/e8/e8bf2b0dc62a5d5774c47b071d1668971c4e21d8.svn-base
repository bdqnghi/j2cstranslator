/*
 *******************************************************************************
 * Copyright (C) 2001-2004, International Business Machines Corporation and    *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 */
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:30 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Text {
	
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Text;
	
	
	/// <summary>
	/// An object that matches a fixed input string, implementing the UnicodeMatcher
	/// API. This object also implements the UnicodeReplacer API, allowing it to emit
	/// the matched text as output. Since the match text may contain flexible match
	/// elements, such as UnicodeSets, the emitted text is not the match pattern, but
	/// instead a substring of the actual matched text. Following convention, the
	/// output text is the leftmost match seen up to this point.
	/// A StringMatcher may represent a segment, in which case it has a positive
	/// segment number. This affects how the matcher converts itself to a pattern but
	/// does not otherwise affect its function.
	/// A StringMatcher that is not a segment should not be used as a
	/// UnicodeReplacer.
	/// </summary>
	///
	internal class StringMatcher : UnicodeMatcher, UnicodeReplacer {
	
	    /// <summary>
	    /// The text to be matched.
	    /// </summary>
	    ///
	    private String pattern;
	
	    /// <summary>
	    /// Start offset, in the match text, of the <em>rightmost</em> match.
	    /// </summary>
	    ///
	    private int matchStart;
	
	    /// <summary>
	    /// Limit offset, in the match text, of the <em>rightmost</em> match.
	    /// </summary>
	    ///
	    private int matchLimit;
	
	    /// <summary>
	    /// The segment number, 1-based, or 0 if not a segment.
	    /// </summary>
	    ///
	    private int segmentNumber;
	
	    /// <summary>
	    /// Context object that maps stand-ins to matcher and replacer objects.
	    /// </summary>
	    ///
	    private readonly RuleBasedTransliterator.Data data;
	
	    /// <summary>
	    /// Construct a matcher that matches the given pattern string.
	    /// </summary>
	    ///
	    /// <param name="theString">the pattern to be matched, possibly containing stand-ins thatrepresent nested UnicodeMatcher objects.</param>
	    /// <param name="segmentNum">the segment number from 1..n, or 0 if this is not a segment.</param>
	    /// <param name="theData">context object mapping stand-ins to UnicodeMatcher objects.</param>
	    public StringMatcher(String theString, int segmentNum,
	            RuleBasedTransliterator.Data theData) {
	        data = theData;
	        pattern = theString;
	        matchStart = matchLimit = -1;
	        segmentNumber = segmentNum;
	    }
	
	    /// <summary>
	    /// Construct a matcher that matches a substring of the given pattern string.
	    /// </summary>
	    ///
	    /// <param name="theString">the pattern to be matched, possibly containing stand-ins thatrepresent nested UnicodeMatcher objects.</param>
	    /// <param name="start">first character of theString to be matched</param>
	    /// <param name="limit">index after the last character of theString to be matched.</param>
	    /// <param name="segmentNum">the segment number from 1..n, or 0 if this is not a segment.</param>
	    /// <param name="theData">context object mapping stand-ins to UnicodeMatcher objects.</param>
	    public StringMatcher(String theString, int start, int limit,
	            int segmentNum, RuleBasedTransliterator.Data theData) : this(theString.Substring(start,(limit) - (start)), segmentNum, theData) {
	    }
	
	    /// <summary>
	    /// Implement UnicodeMatcher
	    /// </summary>
	    ///
	    public virtual int Matches(Replaceable text, int[] offset, int limit,
	            bool incremental) {
	        // Note (1): We process text in 16-bit code units, rather than
	        // 32-bit code points. This works because stand-ins are
	        // always in the BMP and because we are doing a literal match
	        // operation, which can be done 16-bits at a time.
	        int i;
	        int[] cursor = new int[] { offset[0] };
	        if (limit < cursor[0]) {
	            // Match in the reverse direction
	            for (i = pattern.Length - 1; i >= 0; --i) {
	                char keyChar = pattern[i]; // OK; see note (1) above
	                UnicodeMatcher subm = data.LookupMatcher(keyChar);
	                if (subm == null) {
	                    if (cursor[0] > limit && keyChar == text.CharAt(cursor[0])) { // OK;
	                                                                                  // see
	                                                                                  // note
	                                                                                  // (1)
	                                                                                  // above
	                        --cursor[0];
	                    } else {
	                        return IBM.ICU.Text.UnicodeMatcher_Constants.U_MISMATCH;
	                    }
	                } else {
	                    int m = subm.Matches(text, cursor, limit, incremental);
	                    if (m != IBM.ICU.Text.UnicodeMatcher_Constants.U_MATCH) {
	                        return m;
	                    }
	                }
	            }
	            // Record the match position, but adjust for a normal
	            // forward start, limit, and only if a prior match does not
	            // exist -- we want the rightmost match.
	            if (matchStart < 0) {
	                matchStart = cursor[0] + 1;
	                matchLimit = offset[0] + 1;
	            }
	        } else {
	            for (i = 0; i < pattern.Length; ++i) {
	                if (incremental && cursor[0] == limit) {
	                    // We've reached the context limit without a mismatch and
	                    // without completing our match.
	                    return IBM.ICU.Text.UnicodeMatcher_Constants.U_PARTIAL_MATCH;
	                }
	                char keyChar_0 = pattern[i]; // OK; see note (1) above
	                UnicodeMatcher subm_1 = data.LookupMatcher(keyChar_0);
	                if (subm_1 == null) {
	                    // Don't need the cursor < limit check if
	                    // incremental is true (because it's done above); do need
	                    // it otherwise.
	                    if (cursor[0] < limit && keyChar_0 == text.CharAt(cursor[0])) { // OK;
	                                                                                  // see
	                                                                                  // note
	                                                                                  // (1)
	                                                                                  // above
	                        ++cursor[0];
	                    } else {
	                        return IBM.ICU.Text.UnicodeMatcher_Constants.U_MISMATCH;
	                    }
	                } else {
	                    int m_2 = subm_1.Matches(text, cursor, limit, incremental);
	                    if (m_2 != IBM.ICU.Text.UnicodeMatcher_Constants.U_MATCH) {
	                        return m_2;
	                    }
	                }
	            }
	            // Record the match position
	            matchStart = offset[0];
	            matchLimit = cursor[0];
	        }
	
	        offset[0] = cursor[0];
	        return IBM.ICU.Text.UnicodeMatcher_Constants.U_MATCH;
	    }
	
	    /// <summary>
	    /// Implement UnicodeMatcher
	    /// </summary>
	    ///
	    public virtual String ToPattern(bool escapeUnprintable) {
	        StringBuilder result = new StringBuilder();
	        StringBuilder quoteBuf = new StringBuilder();
	        if (segmentNumber > 0) { // i.e., if this is a segment
	            result.Append('(');
	        }
	        for (int i = 0; i < pattern.Length; ++i) {
	            char keyChar = pattern[i]; // OK; see note (1) above
	            UnicodeMatcher m = data.LookupMatcher(keyChar);
	            if (m == null) {
	                IBM.ICU.Impl.Utility.AppendToRule(result, keyChar, false, escapeUnprintable,
	                        quoteBuf);
	            } else {
	                IBM.ICU.Impl.Utility.AppendToRule(result, m.ToPattern(escapeUnprintable),
	                        true, escapeUnprintable, quoteBuf);
	            }
	        }
	        if (segmentNumber > 0) { // i.e., if this is a segment
	            result.Append(')');
	        }
	        // Flush quoteBuf out to result
	        IBM.ICU.Impl.Utility.AppendToRule(result, -1, true, escapeUnprintable, quoteBuf);
	        return result.ToString();
	    }
	
	    /// <summary>
	    /// Implement UnicodeMatcher
	    /// </summary>
	    ///
	    public virtual bool MatchesIndexValue(int v) {
	        if (pattern.Length == 0) {
	            return true;
	        }
	        int c = IBM.ICU.Text.UTF16.CharAt(pattern, 0);
	        UnicodeMatcher m = data.LookupMatcher(c);
	        return (m == null) ? ((c & 0xFF) == v) : m.MatchesIndexValue(v);
	    }
	
	    /// <summary>
	    /// Implementation of UnicodeMatcher API. Union the set of all characters
	    /// that may be matched by this object into the given set.
	    /// </summary>
	    ///
	    /// <param name="toUnionTo">the set into which to union the source characters</param>
	    public virtual void AddMatchSetTo(UnicodeSet toUnionTo) {
	        int ch;
	        for (int i = 0; i < pattern.Length; i += IBM.ICU.Text.UTF16.GetCharCount(ch)) {
	            ch = IBM.ICU.Text.UTF16.CharAt(pattern, i);
	            UnicodeMatcher matcher = data.LookupMatcher(ch);
	            if (matcher == null) {
	                toUnionTo.Add(ch);
	            } else {
	                matcher.AddMatchSetTo(toUnionTo);
	            }
	        }
	    }
	
	    /// <summary>
	    /// UnicodeReplacer API
	    /// </summary>
	    ///
	    public virtual int Replace(Replaceable text, int start, int limit, int[] cursor) {
	
	        int outLen = 0;
	
	        // Copy segment with out-of-band data
	        int dest = limit;
	        // If there was no match, that means that a quantifier
	        // matched zero-length. E.g., x (a)* y matched "xy".
	        if (matchStart >= 0) {
	            if (matchStart != matchLimit) {
	                text.Copy(matchStart, matchLimit, dest);
	                outLen = matchLimit - matchStart;
	            }
	        }
	
	        text.Replace(start, limit, ""); // delete original text
	
	        return outLen;
	    }
	
	    /// <summary>
	    /// UnicodeReplacer API
	    /// </summary>
	    ///
	    public virtual String ToReplacerPattern(bool escapeUnprintable) {
	        // assert(segmentNumber > 0);
	        StringBuilder rule = new StringBuilder("$");
	        IBM.ICU.Impl.Utility.AppendNumber(rule, segmentNumber, 10, 1);
	        return rule.ToString();
	    }
	
	    /// <summary>
	    /// Remove any match data. This must be called before performing a set of
	    /// matches with this segment.
	    /// </summary>
	    ///
	    public void ResetMatch() {
	        matchStart = matchLimit = -1;
	    }
	
	    /// <summary>
	    /// Union the set of all characters that may output by this object into the
	    /// given set.
	    /// </summary>
	    ///
	    /// <param name="toUnionTo">the set into which to union the output characters</param>
	    public virtual void AddReplacementSetTo(UnicodeSet toUnionTo) {
	        // The output of this replacer varies; it is the source text between
	        // matchStart and matchLimit. Since this varies depending on the
	        // input text, we can't compute it here. We can either do nothing
	        // or we can add ALL characters to the set. It's probably more useful
	        // to do nothing.
	    }
	}
	
	// eof
}
