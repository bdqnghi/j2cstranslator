//##header J2SE15
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/13/10 4:01 PM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 //#if defined(FOUNDATION10) || defined(J2SE13)
//#else
/*
 *******************************************************************************
 * Copyright (C) 2002-2007, International Business Machines Corporation and    *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 */
namespace IBM.ICU.Charset {
	
	using IBM.ICU.Text;
	using ILOG.J2CsMapping.Collections;
	using ILOG.J2CsMapping.Collections.Generics;
	using ILOG.J2CsMapping.Text;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Security;
	using System.Text;
	
	public class BagFormatter {
	    internal const bool DEBUG = false;
	
	    public static readonly bool SHOW_FILES;
	    public static readonly StreamWriter CONSOLE = ILOG.J2CsMapping.IO.IOUtility.NewStreamWriter(System.Console.Out, true);
	
	    private static StreamWriter log = CONSOLE;
	
	    private bool abbreviated;
	
	    internal String separator;
	
	    internal String prefix;
	
	    internal String suffix;
	
	    private UnicodeProperty.Factory source;
	
	    private UnicodeLabel nameSource;
	
	    private UnicodeLabel labelSource;
	
	    private UnicodeLabel rangeBreakSource;
	
	    private UnicodeLabel valueSource;
	
	    internal String propName;
	
	    internal bool showCount;
	
	    // private boolean suppressReserved = true;
	    private bool hexValue;
	
	    internal const String NULL_VALUE = "_NULL_VALUE_";
	
	    internal int fullTotal;
	
	    internal bool showTotal;
	
	    internal String lineSeparator;
	
	    internal Tabber tabber;
	
	    /// <summary>
	    /// Compare two UnicodeSets, and show the differences
	    /// </summary>
	    ///
	    /// <param name="name1">name of first set to be compared</param>
	    /// <param name="set1">first set</param>
	    /// <param name="name2">name of second set to be compared</param>
	    /// <param name="set2">second set</param>
	    /// <returns>formatted string</returns>
	    public String ShowSetDifferences(String name1, UnicodeSet set1,
	            String name2, UnicodeSet set2) {
	
	        StringWriter result = new StringWriter(System.Globalization.NumberFormatInfo.InvariantInfo);
	        ShowSetDifferences(ILOG.J2CsMapping.IO.IOUtility.NewStreamWriter(result) /* Warning: if writer (arg) is a StringWriter exception raised */, name1, set1, name2, set2);
	        result.Flush();
	        return result.GetStringBuilder().ToString();
	    }
	
	    public String ShowSetDifferences(String name1, ICollection set1,
	            String name2, ICollection set2) {
	
	        StringWriter result = new StringWriter(System.Globalization.NumberFormatInfo.InvariantInfo);
	        ShowSetDifferences(ILOG.J2CsMapping.IO.IOUtility.NewStreamWriter(result) /* Warning: if writer (arg) is a StringWriter exception raised */, name1, set1, name2, set2);
	        result.Flush();
	        return result.GetStringBuilder().ToString();
	    }
	
	    public void ShowSetDifferences(StreamWriter pw, String name1,
	            UnicodeSet set1, String name2, UnicodeSet set2) {
	        ShowSetDifferences(pw, name1, set1, name2, set2, -1);
	    }
	
	    /// <summary>
	    /// Compare two UnicodeSets, and show the differences
	    /// </summary>
	    ///
	    /// <param name="name1">name of first set to be compared</param>
	    /// <param name="set1">first set</param>
	    /// <param name="name2">name of second set to be compared</param>
	    /// <param name="set2">second set</param>
	    public void ShowSetDifferences(StreamWriter pw, String name1,
	            UnicodeSet set1, String name2, UnicodeSet set2, int flags) {
	        if (pw == null)
	            pw = CONSOLE;
	        String[] names = { name1, name2 };
	
	        UnicodeSet temp;
	
	        if ((flags & 1) != 0) {
	            temp = new UnicodeSet(set1).RemoveAll(set2);
	            pw.Write(lineSeparator);
	            pw.Write(inOut.FormatObject(names));
	            pw.Write(lineSeparator);
	            ShowSetNames(pw, temp);
	        }
	
	        if ((flags & 2) != 0) {
	            temp = new UnicodeSet(set2).RemoveAll(set1);
	            pw.Write(lineSeparator);
                pw.Write(outIn.FormatObject(names));
	            pw.Write(lineSeparator);
	            ShowSetNames(pw, temp);
	        }
	
	        if ((flags & 4) != 0) {
	            temp = new UnicodeSet(set2).RetainAll(set1);
	            pw.Write(lineSeparator);
                pw.Write(inIn.FormatObject(names));
	            pw.Write(lineSeparator);
	            ShowSetNames(pw, temp);
	        }
	        pw.Flush();
	    }
	
	    public void ShowSetDifferences(StreamWriter pw, String name1,
	            ICollection set1, String name2, ICollection set2) {
	
	        if (pw == null)
	            pw = CONSOLE;
	        String[] names = { name1, name2 };
	        // damn'd collection doesn't have a clone, so
	        // we go with Set, even though that
	        // may not preserve order and duplicates
	        ICollection temp = new HashedSet(set1);
            throw new NotImplementedException();
            /*
	        temp.RemoveAll(set2);
	        pw.WriteLine();
            pw.WriteLine(inOut.FormatObject(names));
	        ShowSetNames(pw, temp);
	
	        ILOG.J2CsMapping.Collections.Collections.Clear(temp);
	        ILOG.J2CsMapping.Collections.Generics.Collections.AddAll(set2,temp);
	        temp.RemoveAll(set1);
	        pw.WriteLine();
            pw.WriteLine(outIn.FormatObject(names));
	        ShowSetNames(pw, temp);
	
	        ILOG.J2CsMapping.Collections.Collections.Clear(temp);
	        ILOG.J2CsMapping.Collections.Generics.Collections.AddAll(set1,temp);
	        temp.RetainAll(set2);
	        pw.WriteLine();
            pw.WriteLine(inIn.FormatObject(names));
	        ShowSetNames(pw, temp);*/
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Returns a list of items in the collection, with each separated by the
	    /// separator. Each item must not be null; its toString() is called for a
	    /// printable representation
	    /// </summary>
	    ///
	    /// <param name="c">source collection</param>
	    /// <returns>a String representation of the list</returns>
	    public String ShowSetNames(Object c) {
	        StringWriter buffer = new StringWriter(System.Globalization.NumberFormatInfo.InvariantInfo);
	        StreamWriter output = ILOG.J2CsMapping.IO.IOUtility.NewStreamWriter(buffer) /* Warning: if writer (arg) is a StringWriter exception raised */;
	        ShowSetNames(output, c);
	        return buffer.ToString();
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Returns a list of items in the collection, with each separated by the
	    /// separator. Each item must not be null; its toString() is called for a
	    /// printable representation
	    /// </summary>
	    ///
	    /// <param name="output">destination to which to write names</param>
	    /// <param name="c">source collection</param>
	    public void ShowSetNames(StreamWriter output, Object c) {
	        mainVisitor.DoAt(c, output);
	        output.Flush();
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Returns a list of items in the collection, with each separated by the
	    /// separator. Each item must not be null; its toString() is called for a
	    /// printable representation
	    /// </summary>
	    ///
	    /// <param name="filename">destination to which to write names</param>
	    /// <param name="c">source collection</param>
	    public void ShowSetNames(String filename, Object c) {
	        StreamWriter pw = ILOG.J2CsMapping.IO.IOUtility.NewStreamWriter(File.OpenWrite(filename)); /* Warning: if writer (arg) is a StringWriter exception raised */;
	        ShowSetNames(log, c);
	        pw.Close();
	    }
	
	    public String GetAbbreviatedName(String source_0, String pattern,
	            String substitute) {
	
	        int matchEnd = IBM.ICU.Charset.BagFormatter.NameIterator.FindMatchingEnd(source_0, pattern);
	        int sdiv = source_0.Length - matchEnd;
	        int pdiv = pattern.Length - matchEnd;
	        StringBuilder result = new StringBuilder();
	        AddMatching(source_0.Substring(0,(sdiv)-(0)), pattern.Substring(0,(pdiv)-(0)),
	                substitute, result);
	        AddMatching(source_0.Substring(sdiv), pattern.Substring(pdiv),
	                substitute, result);
	        return result.ToString();
	    }
	
	    abstract public class Relation {
	        abstract public String GetRelation(String a, String b);
	    }
	
	    internal class NullRelation : BagFormatter.Relation  {
	        public override String GetRelation(String a, String b) {
	            return "";
	        }
	    }
	
	    private BagFormatter.Relation  r;
	
	    public BagFormatter SetRelation(BagFormatter.Relation  r_0) {
	        this.r = r_0;
	        return this; // for chaining
	    }
	
	    public BagFormatter.Relation  GetRelation() {
	        return r;
	    }
	
	    /*
	     * r.getRelati on(last, s) + quote(s) + "\t#" +
	     * UnicodeSetFormatter.getResolvedName(s)
	     */
	    /*
	     * static final UnicodeSet NO_NAME = new
	     * UnicodeSet("[\\u0080\\u0081\\u0084\\u0099\\p{Cn}\\p{Co}]"); static final
	     * UnicodeSet HAS_NAME = new UnicodeSet(NO_NAME).complement(); static final
	     * UnicodeSet NAME_CHARACTERS = new UnicodeSet("[A-Za-z0-9\\<\\>\\-\\ ]");
	     * 
	     * public UnicodeSet getSetForName(String namePattern) { UnicodeSet result =
	     * new UnicodeSet(); Matcher m = Pattern.compile(namePattern).matcher("");
	     * // check for no-name items, and add in bulk m.reset("<no name>"); if
	     * (m.matches()) { result.addAll(NO_NAME); } // check all others
	     * UnicodeSetIterator usi = new UnicodeSetIterator(HAS_NAME); while
	     * (usi.next()) { String name = getName(usi.codepoint); if (name == null)
	     * continue; m.reset(name); if (m.matches()) { result.add(usi.codepoint); }
	     * } // Note: if Regex had some API so that if we could tell that // an
	     * initial substring couldn't match, e.g. "CJK IDEOGRAPH-" // then we could
	     * optimize by skipping whole swathes of characters return result; }
	     */
	
	    public BagFormatter SetMergeRanges(bool ins0) {
	        mergeRanges = ins0;
	        return this;
	    }
	
	    public BagFormatter SetShowSetAlso(bool b) {
	        showSetAlso = b;
	        return this;
	    }
	
	    public String GetName(int codePoint) {
	        return GetName("", codePoint, codePoint);
	    }
	
	    public String GetName(String separator_0, int start, int end) {
	        if (GetNameSource() == null || GetNameSource() == IBM.ICU.Charset.UnicodeLabel.NULL)
	            return "";
	        String result = GetName(start, false);
	        if (start == end)
	            return separator_0 + result;
	        String endString = GetName(end, false);
	        if (result.Length == 0 && endString.Length == 0)
	            return separator_0;
	        if (abbreviated)
	            endString = GetAbbreviatedName(endString, result, "~");
	        return separator_0 + result + ".." + endString;
	    }
	
	    public String GetName(String s) {
	        return GetName(s, false);
	    }
	
	    public class NameLabel : UnicodeLabel {
	        internal UnicodeProperty nameProp;
	
	        internal UnicodeSet control;
	
	        internal UnicodeSet private_use;
	
	        internal UnicodeSet noncharacter;
	
	        internal UnicodeSet surrogate;
	
	        public NameLabel(UnicodeProperty.Factory source_0) {
	            nameProp = source_0.GetProperty("Name");
	            control = source_0.GetSet("gc=Cc");
	            private_use = source_0.GetSet("gc=Co");
	            surrogate = source_0.GetSet("gc=Cs");
	            noncharacter = source_0.GetSet("noncharactercodepoint=true");
	        }
	
	        public override String GetValue(int codePoint, bool isShort) {
	            String hcp = (!isShort) ? "U+" + IBM.ICU.Impl.Utility.Hex(codePoint, 4) + " " : "";
	            String result = nameProp.GetValue(codePoint);
	            if (result != null)
	                return hcp + result;
	            if (control.Contains(codePoint))
	                return "<control-" + IBM.ICU.Impl.Utility.Hex(codePoint, 4) + ">";
	            if (private_use.Contains(codePoint))
	                return "<private-use-" + IBM.ICU.Impl.Utility.Hex(codePoint, 4) + ">";
	            if (noncharacter.Contains(codePoint))
	                return "<noncharacter-" + IBM.ICU.Impl.Utility.Hex(codePoint, 4) + ">";
	            if (surrogate.Contains(codePoint))
	                return "<surrogate-" + IBM.ICU.Impl.Utility.Hex(codePoint, 4) + ">";
	            // if (suppressReserved) return "";
	            return hcp + "<reserved-" + IBM.ICU.Impl.Utility.Hex(codePoint, 4) + ">";
	        }
	
	    }
	
	    // refactored
	    public String GetName(int codePoint, bool withCodePoint) {
	        String result = GetNameSource().GetValue(codePoint, !withCodePoint);
	        return (fixName == null) ? result : fixName.Transliterate(result);
	    }
	
	    public String GetName(String s, bool withCodePoint) {
	        String result = GetNameSource().GetValue(s, separator, !withCodePoint);
	        return (fixName == null) ? result : fixName.Transliterate(result);
	    }
	
	    public String Hex(String s) {
	        return Hex(s, separator);
	    }
	
	    public String Hex(String s, String separator_0) {
	        return IBM.ICU.Charset.UnicodeLabel.HEX.GetValue(s, separator_0, true);
	    }
	
	    public String Hex(int start, int end) {
	        String s = IBM.ICU.Impl.Utility.Hex(start, 4);
	        if (start == end)
	            return s;
	        return s + ".." + IBM.ICU.Impl.Utility.Hex(end, 4);
	    }
	
	    public BagFormatter SetUnicodePropertyFactory(UnicodeProperty.Factory source_0) {
	        this.source = source_0;
	        return this;
	    }
	
	    public UnicodeProperty.Factory GetUnicodePropertyFactory() {
            throw new NotImplementedException();
	        //if (source == null)
	        //    source = IBM.ICU.Charset.ICUPropertyFactory.Make();
	        return source;
	    }
	
	    public BagFormatter() {
	        this.abbreviated = false;
	        this.separator = ",";
	        this.prefix = "[";
	        this.suffix = "]";
	        this.propName = "";
	        this.showCount = true;
	        this.hexValue = false;
	        this.fullTotal = -1;
	        this.showTotal = true;
	        this.lineSeparator = "\r\n";
	        this.tabber = new Tabber.MonoTabber();
	        this.r = new BagFormatter.NullRelation ();
	        this.labelVisitor = new BagFormatter.Join (this);
	        this.mergeRanges = true;
	        this.showLiteral = null;
	        this.fixName = null;
	        this.showSetAlso = false;
	        this.rf = new BagFormatter.RangeFinder (this);
	        this.inOut = new IBM.ICU.Text.MessageFormat("In {0}, but not in {1}:");
            this.outIn = new IBM.ICU.Text.MessageFormat("Not in {0}, but in {1}:");
            this.inIn = new IBM.ICU.Text.MessageFormat("In both {0}, and in {1}:");
	        this.mainVisitor = new BagFormatter.MyVisitor (this);
	        this.shortLabel = true;
	        this.shortValue = true;
	    }
	
	    public BagFormatter(UnicodeProperty.Factory source_0) {
	        this.abbreviated = false;
	        this.separator = ",";
	        this.prefix = "[";
	        this.suffix = "]";
	        this.propName = "";
	        this.showCount = true;
	        this.hexValue = false;
	        this.fullTotal = -1;
	        this.showTotal = true;
	        this.lineSeparator = "\r\n";
	        this.tabber = new Tabber.MonoTabber();
	        this.r = new BagFormatter.NullRelation ();
	        this.labelVisitor = new BagFormatter.Join (this);
	        this.mergeRanges = true;
	        this.showLiteral = null;
	        this.fixName = null;
	        this.showSetAlso = false;
	        this.rf = new BagFormatter.RangeFinder (this);
            this.inOut = new IBM.ICU.Text.MessageFormat("In {0}, but not in {1}:");
            this.outIn = new IBM.ICU.Text.MessageFormat("Not in {0}, but in {1}:");
            this.inIn = new IBM.ICU.Text.MessageFormat("In both {0}, and in {1}:");
	        this.mainVisitor = new BagFormatter.MyVisitor (this);
	        this.shortLabel = true;
	        this.shortValue = true;
	        SetUnicodePropertyFactory(source_0);
	    }
	
	    public String JoinMthd(Object o) {
	        return labelVisitor.JoinMthd(o);
	    }
	
	    // ===== PRIVATES =====
	
	    private BagFormatter.Join  labelVisitor;
	
	    internal bool mergeRanges;
	
	    internal Transliterator showLiteral;
	
	    private Transliterator fixName;
	
	    internal bool showSetAlso;
	
	    internal BagFormatter.RangeFinder  rf;
	
	    private IBM.ICU.Text.MessageFormat inOut;

        private IBM.ICU.Text.MessageFormat outIn;

        private IBM.ICU.Text.MessageFormat inIn;
	
	    private BagFormatter.MyVisitor  mainVisitor;
	
	    /*
	     * private String getLabels(int start, int end) { Set names = new TreeSet();
	     * for (int cp = start; cp <= end; ++cp) { names.add(getLabel(cp)); } return
	     * labelVisitor.join(names); }
	     */
	
	    private void AddMatching(String source_0, String pattern, String substitute,
	            StringBuilder result) {
	        BagFormatter.NameIterator  n1 = new BagFormatter.NameIterator (source_0);
	        BagFormatter.NameIterator  n2 = new BagFormatter.NameIterator (pattern);
	        bool first = true;
	        while (true) {
	            String s1 = n1.Next();
	            if (s1 == null)
	                break;
	            String s2 = n2.Next();
	            if (!first)
	                result.Append(" ");
	            first = false;
	            if (s1.Equals(s2))
	                result.Append(substitute);
	            else
	                result.Append(s1);
	        }
	    }
	
	    static internal NumberFormat nf = IBM.ICU.Text.NumberFormat
	            .GetIntegerInstance(new ILOG.J2CsMapping.Util.Locale("en"));

	    internal class MyVisitor : Visitor {
	            private BagFormatter outer_BagFormatter;
	    
	            public MyVisitor(BagFormatter formatter) {
	                outer_BagFormatter = formatter;
	                this.inTable = false;
	            }
	    
	            private StreamWriter output;
	    
	            internal String commentSeparator;
	    
	            internal int counter;
	    
	            internal int valueSize;
	    
	            internal int labelSize;
	    
	            internal bool isHtml;
	    
	            internal bool inTable;
	    
	            public void ToOutput(String s) {
	                if (isHtml) {
	                    if (inTable) {
	                        output.Write("</table>");
	                        inTable = false;
	                    }
	                    output.Write("<p>");
	                }
	                output.Write(s);
	                if (isHtml)
	                    output.WriteLine("</p>");
	                else
	                    output.Write(outer_BagFormatter.lineSeparator);
	            }
	    
	            public void ToTable(String s) {
	                if (isHtml && !inTable) {
	                    output.Write("<table>");
	                    inTable = true;
	                }
	                output.Write(outer_BagFormatter.tabber.Process(s) + outer_BagFormatter.lineSeparator);
	            }
	    
	            public void DoAt(Object c, StreamWriter output_0) {
	                this.output = output_0;
	                isHtml = outer_BagFormatter.tabber  is  Tabber.HTMLTabber;
	                counter = 0;
	    
	                outer_BagFormatter.tabber.Clear();
	                outer_BagFormatter.tabber.Add((outer_BagFormatter.mergeRanges) ? 14 : 6, IBM.ICU.Charset.Tabber.LEFT);
	    
	                if (outer_BagFormatter.propName.Length > 0)
	                    outer_BagFormatter.tabber.Add(outer_BagFormatter.propName.Length + 2, IBM.ICU.Charset.Tabber.LEFT);
	    
	                valueSize = outer_BagFormatter.GetValueSource().GetMaxWidth(outer_BagFormatter.shortValue);
	                if (IBM.ICU.Charset.BagFormatter.DEBUG)
	                    System.Console.Out.WriteLine("ValueSize: " + valueSize);
	                if (outer_BagFormatter.GetValueSource() != IBM.ICU.Charset.UnicodeLabel.NULL)
	                    outer_BagFormatter.tabber.Add(valueSize + 2, IBM.ICU.Charset.Tabber.LEFT); // value
	    
	                outer_BagFormatter.tabber.Add(3, IBM.ICU.Charset.Tabber.LEFT); // comment character
	    
	                labelSize = outer_BagFormatter.GetLabelSource(true).GetMaxWidth(outer_BagFormatter.shortLabel);
	                if (labelSize > 0)
	                    outer_BagFormatter.tabber.Add(labelSize + 1, IBM.ICU.Charset.Tabber.LEFT); // value
	    
	                if (outer_BagFormatter.mergeRanges && outer_BagFormatter.showCount)
	                    outer_BagFormatter.tabber.Add(5, IBM.ICU.Charset.Tabber.RIGHT);
	    
	                if (outer_BagFormatter.showLiteral != null)
	                    outer_BagFormatter.tabber.Add(4, IBM.ICU.Charset.Tabber.LEFT);
	                // myTabber.add(7,Tabber.LEFT);
	    
	                commentSeparator = (outer_BagFormatter.showCount || outer_BagFormatter.showLiteral != null
	                        || outer_BagFormatter.GetLabelSource(true) != IBM.ICU.Charset.UnicodeLabel.NULL || outer_BagFormatter.GetNameSource() != IBM.ICU.Charset.UnicodeLabel.NULL) ? "\t #"
	                        : "";
	    
	                if (IBM.ICU.Charset.BagFormatter.DEBUG)
	                    System.Console.Out.WriteLine("Tabber: " + outer_BagFormatter.tabber.ToString());
	                if (IBM.ICU.Charset.BagFormatter.DEBUG)
	                    System.Console.Out.WriteLine("Tabber: "
	                            + outer_BagFormatter.tabber.Process("a\tb\td\td\tf\tg\th"));
	                DoAt(c);
	            }
	    
	            public String Format(Object o) {
	                StringWriter sw = new StringWriter(System.Globalization.NumberFormatInfo.InvariantInfo);
	                StreamWriter pw = ILOG.J2CsMapping.IO.IOUtility.NewStreamWriter(sw) /* Warning: if writer (arg) is a StringWriter exception raised */;
	                DoAt(o);
	                pw.Flush();
	                String result = sw.GetStringBuilder().ToString();
	                pw.Close();
	                return result;
	            }
	    
	            protected internal override void DoBefore(Object container, Object o) {
	                if (outer_BagFormatter.showSetAlso && container  is  UnicodeSet) {
	                    ToOutput("#" + container);
	                }
	            }
	    
	            protected internal override void DoBetween(Object container, Object lastItem,
	                    Object nextItem) {
	            }
	    
	            protected internal override void DoAfter(Object container, Object o) {
	                if (outer_BagFormatter.fullTotal != -1 && outer_BagFormatter.fullTotal != counter) {
	                    if (outer_BagFormatter.showTotal) {
	                        ToOutput("");
	                        ToOutput("# The above property value applies to "
	                                + IBM.ICU.Charset.BagFormatter.nf.Format(outer_BagFormatter.fullTotal - counter)
	                                + " code points not listed here.");
	                        ToOutput("# Total code points: " + IBM.ICU.Charset.BagFormatter.nf.Format(outer_BagFormatter.fullTotal));
	                    }
	                    outer_BagFormatter.fullTotal = -1;
	                } else if (outer_BagFormatter.showTotal) {
	                    ToOutput("");
	                    ToOutput("# Total code points: " + IBM.ICU.Charset.BagFormatter.nf.Format(counter));
	                }
	            }
	    
	            protected internal override void DoSimpleAt(Object o) {
	                if (o  is  DictionaryEntry) {
	                    DictionaryEntry oo = (DictionaryEntry) o;
	                    Object key = ((DictionaryEntry) oo).Key;
	                    Object value_ren = ((DictionaryEntry) oo).Value;
	                    DoBefore(o, key);
	                    DoAt(key);
	                    output.WriteLine("\u2192");
	                    DoAt(value_ren);
	                    DoAfter(o, value_ren);
	                    counter++;
	                } else if (o  is  Visitor.CodePointRange) {
	                    DoAt((Visitor.CodePointRange) o);
	                } else {
	                    String thing = o.ToString();
	                    String value_0 = (outer_BagFormatter.GetValueSource() == IBM.ICU.Charset.UnicodeLabel.NULL) ? ""
	                            : outer_BagFormatter.GetValueSource().GetValue(thing, ",", true);
	                    if (outer_BagFormatter.GetValueSource() != IBM.ICU.Charset.UnicodeLabel.NULL)
	                        value_0 = "\t; " + value_0;
	                    String label = (outer_BagFormatter.GetLabelSource(true) == IBM.ICU.Charset.UnicodeLabel.NULL) ? ""
	                            : outer_BagFormatter.GetLabelSource(true).GetValue(thing, ",", true);
	                    if (label.Length != 0)
	                        label = " " + label;
	                    ToTable(outer_BagFormatter.Hex(thing) + value_0 + commentSeparator + label
	                            + InsertLiteral(thing) + "\t" + outer_BagFormatter.GetName(thing));
	                    counter++;
	                }
	            }
	    
	            protected internal void DoAt(Visitor.CodePointRange usi) {
	                if (!outer_BagFormatter.mergeRanges) {
	                    for (int cp = usi.codepoint; cp <= usi.codepointEnd; ++cp) {
	                        ShowLine(cp, cp);
	                    }
	                } else {
	                    outer_BagFormatter.rf.Reset(usi.codepoint, usi.codepointEnd + 1);
	                    while (outer_BagFormatter.rf.Next()) {
	                        ShowLine(outer_BagFormatter.rf.start, outer_BagFormatter.rf.limit - 1);
	                    }
	                }
	            }
	    
	            public void ShowLine(int start, int end) {
	                String label = outer_BagFormatter.GetLabelSource(true).GetValue(start, outer_BagFormatter.shortLabel);
	                String value_ren = outer_BagFormatter.GetValue(start, outer_BagFormatter.shortValue);
	                if (value_ren == IBM.ICU.Charset.BagFormatter.NULL_VALUE)
	                    return;
	    
	                counter += end - start + 1;
	                String pn = outer_BagFormatter.propName;
	                if (pn.Length != 0) {
	                    pn = "\t; " + pn;
	                }
	                if (valueSize > 0) {
	                    value_ren = "\t; " + value_ren;
	                } else if (value_ren.Length > 0) {
	                    throw new ArgumentException("maxwidth bogus " + value_ren
	                            + "," + outer_BagFormatter.GetValueSource().GetMaxWidth(outer_BagFormatter.shortValue));
	                }
	                if (labelSize > 0) {
	                    label = "\t" + label;
	                } else if (label.Length > 0) {
	                    throw new ArgumentException("maxwidth bogus " + label
	                            + ", " + outer_BagFormatter.GetLabelSource(true).GetMaxWidth(outer_BagFormatter.shortLabel));
	                }
	    
	                String count = "";
	                if (outer_BagFormatter.mergeRanges && outer_BagFormatter.showCount) {
	                    if (end == start)
	                        count = "\t";
	                    else
	                        count = "\t [" + IBM.ICU.Charset.BagFormatter.nf.Format(end - start + 1) + "]";
	                }
	    
	                ToTable(outer_BagFormatter.Hex(start, end) + pn + value_ren + commentSeparator + label
	                        + count + InsertLiteral(start, end)
	                        + outer_BagFormatter.GetName("\t ", start, end));
	            }
	    
	            public String InsertLiteral(String thing) {
	                return ((outer_BagFormatter.showLiteral == null) ? "" : " \t("
	                        + outer_BagFormatter.showLiteral.Transliterate(thing) + ") ");
	            }
	    
	            public String InsertLiteral(int start, int end) {
	                return ((outer_BagFormatter.showLiteral == null) ? "" : " \t("
	                        + outer_BagFormatter.showLiteral.Transliterate(IBM.ICU.Text.UTF16.ValueOf(start))
	                        + ((start != end) ? (".." + outer_BagFormatter.showLiteral.Transliterate(IBM.ICU.Text.UTF16
	                                .ValueOf(end))) : "") + ") ");
	            }
	            /*
	             * private String insertLiteral(int cp) { return (showLiteral == null ?
	             * "" : " \t(" + showLiteral.transliterate(UTF16.valueOf(cp)) + ") "); }
	             */
	        }
	
	    /// <summary>
	    /// Iterate through a string, breaking at words.
	    /// </summary>
	    ///
	    private class NameIterator {
	        internal String source;
	
	        internal int position;
	
	        internal int start;
	
	        internal int limit;
	
	        internal NameIterator(String source_0) {
	            this.source = source_0;
	            this.start = 0;
	            this.limit = source_0.Length;
	        }
	
	        /// <summary>
	        /// Find next word, including trailing spaces
	        /// </summary>
	        ///
	        /// <returns>the next word</returns>
	        internal String Next() {
	            if (position >= limit)
	                return null;
	            int pos = source.IndexOf(' ', position);
	            if (pos < 0 || pos >= limit)
	                pos = limit;
	            String result = source.Substring(position,(pos)-(position));
	            position = pos + 1;
	            return result;
	        }
	
	        static internal int FindMatchingEnd(String s1, String s2) {
	            int i = s1.Length;
	            int j = s2.Length;
	            try {
	                while (true) {
	                    --i; // decrement both before calling function!
	                    --j;
	                    if (s1[i] != s2[j])
	                        break;
	                }
	            } catch (Exception e) {
	            } // run off start
	
	            ++i; // counteract increment
	            i = s1.IndexOf(' ', i); // move forward to space
	            if (i < 0)
	                return 0;
	            return s1.Length - i;
	        }
	    }
	
	    public class RangeFinder {
	            private BagFormatter outer_BagFormatter;
	    
	            
	            /// <param name="formatter"></param>
	            public RangeFinder(BagFormatter formatter) {
	                outer_BagFormatter = formatter;
	            }
	    
	            internal int start, limit;
	    
	            private int veryLimit;
	    
	            // String label, value;
	            internal void Reset(int start_0, int limit_1) {
	                this.limit = start_0;
	                this.veryLimit = limit_1;
	            }
	    
	            internal bool Next() {
	                if (limit >= veryLimit)
	                    return false;
	                start = limit; // set to end of last
	                String label = outer_BagFormatter.GetLabelSource(false).GetValue(limit, true);
	                String value_ren = outer_BagFormatter.GetValue(limit, true);
	                String breaker = outer_BagFormatter.GetRangeBreakSource().GetValue(limit, true);
	                if (IBM.ICU.Charset.BagFormatter.DEBUG && limit < 0x7F)
	                    System.Console.Out.WriteLine("Label: " + label + ", Value: " + value_ren
	                            + ", Break: " + breaker);
	                limit++;
	                for (; limit < veryLimit; limit++) {
	                    String s = outer_BagFormatter.GetLabelSource(false).GetValue(limit, true);
	                    String v = outer_BagFormatter.GetValue(limit, true);
	                    String b = outer_BagFormatter.GetRangeBreakSource().GetValue(limit, true);
	                    if (IBM.ICU.Charset.BagFormatter.DEBUG && limit < 0x7F)
	                        System.Console.Out.WriteLine("*Label: " + label + ", Value: " + value_ren
	                                + ", Break: " + breaker);
	                    if (!outer_BagFormatter.EqualTo(s, label) || !outer_BagFormatter.EqualTo(v, value_ren)
	                            || !outer_BagFormatter.EqualTo(b, breaker))
	                        break;
	                }
	                // at this point, limit is the first item that has a different label
	                // than source
	                // OR, we got to the end, and limit == veryLimit
	                return true;
	            }
	        }
	
	    internal bool EqualTo(Object a, Object b) {
	        if (a == b)
	            return true;
	        if (a == null)
	            return false;
	        return a.Equals(b);
	    }
	
	    internal bool shortLabel;
	
	    internal bool shortValue;
	
	    public String GetPrefix() {
	        return prefix;
	    }
	
	    public String GetSuffix() {
	        return suffix;
	    }
	
	    public BagFormatter SetPrefix(String str0) {
	        prefix = str0;
	        return this;
	    }
	
	    public BagFormatter SetSuffix(String str0) {
	        suffix = str0;
	        return this;
	    }
	
	    public bool IsAbbreviated() {
	        return abbreviated;
	    }
	
	    public BagFormatter SetAbbreviated(bool b) {
	        abbreviated = b;
	        return this;
	    }
	
	    public UnicodeLabel GetLabelSource(bool visible) {
	        if (labelSource == null) {
	            IDictionary labelMap = new Hashtable();
	            // labelMap.put("Lo","L&");
	            ILOG.J2CsMapping.Collections.Collections.Put(labelMap,"Lu","L&");
	            ILOG.J2CsMapping.Collections.Collections.Put(labelMap,"Lt","L&");
	            ILOG.J2CsMapping.Collections.Collections.Put(labelMap,"Ll","L&");
	            labelSource = new UnicodeProperty.FilteredProperty(
	                    GetUnicodePropertyFactory().GetProperty("General_Category"),
	                    new UnicodeProperty.MapFilter(labelMap))
	                    .SetAllowValueAliasCollisions(true);
	        }
	        return labelSource;
	    }
	
	    public static void AddAll(UnicodeSet source_0, ICollection target) {
	        source_0.AddAllTo(target);
	    }
	
	    // UTILITIES
	
	    public static readonly Transliterator hex = IBM.ICU.Text.Transliterator
	            .GetInstance("[^\\u0009\\u0020-\\u007E\\u00A0-\\u00FF] hex");
	
	    public static TextReader OpenUTF8Reader(String dir, String filename) {
	        return OpenReader(dir, filename, "UTF-8");
	    }
	
	    public static TextReader OpenReader(String dir, String filename,
	            String encoding) {
	        FileInfo file = new FileInfo(dir + filename);
	        if (SHOW_FILES && log != null) {
	            log.WriteLine("Opening File: " + file.FullName);
	        }
	        return new StreamReader(file.OpenRead(),System.Text.Encoding.GetEncoding(encoding));
	    }
	
	    public static StreamWriter OpenUTF8Writer(String dir, String filename) {
	        return OpenWriter(dir, filename, "UTF-8");
	    }
	
	    public static StreamWriter OpenWriter(String dir, String filename,
	            String encoding) {
	        FileInfo file = new FileInfo(dir + filename);
	        if (SHOW_FILES && log != null) {
	            log.WriteLine("Creating File: " + file.FullName);
	        }
            String parentName = file.DirectoryName;
	        if (parentName != null) {
	            FileInfo parent = new FileInfo(parentName);
	            System.IO.Directory.CreateDirectory(parent.FullName);
	        }
	        return new StreamWriter(new BufferedStream(file.OpenWrite())) /* Warning: if writer (arg) is a StringWriter exception raised */;
	    }
	
	    public static StreamWriter GetLog() {
	        return log;
	    }
	
	    public BagFormatter SetLog(StreamWriter writer) {
	        log = writer;
	        return this;
	    }
	
	    public String GetSeparator() {
	        return separator;
	    }
	
	    public BagFormatter SetSeparator(String str0) {
	        separator = str0;
	        return this;
	    }
	
	    public Transliterator GetShowLiteral() {
	        return showLiteral;
	    }
	
	    public BagFormatter SetShowLiteral(Transliterator transliterator) {
	        showLiteral = transliterator;
	        return this;
	    }
	
	    internal class Join : Visitor {
	            private BagFormatter outer_BagFormatter;
	    
	            public Join(BagFormatter formatter) {
	                outer_BagFormatter = formatter;
	                this.output = new StringBuilder();
	                this.depth = 0;
	            }
	    
	            internal StringBuilder output;
	    
	            internal int depth;
	    
	            internal String JoinMthd(Object o) {
	                output.Length=0;
	                DoAt(o);
	                return output.ToString();
	            }
	    
	            protected internal override void DoBefore(Object container, Object item) {
	                ++depth;
	                output.Append(outer_BagFormatter.prefix);
	            }
	    
	            protected internal override void DoAfter(Object container, Object item) {
	                output.Append(outer_BagFormatter.suffix);
	                --depth;
	            }
	    
	            protected internal override void DoBetween(Object container, Object lastItem,
	                    Object nextItem) {
	                output.Append(outer_BagFormatter.separator);
	            }
	    
	            protected internal override void DoSimpleAt(Object o) {
	                if (o != null)
	                    output.Append(o.ToString());
	            }
	        }
	
	    
	    /// <param name="label"></param>
	    public BagFormatter SetLabelSource(UnicodeLabel label) {
	        if (label == null)
	            label = IBM.ICU.Charset.UnicodeLabel.NULL;
	        labelSource = label;
	        return this;
	    }
	
	    
	    /// <returns>the NameLable representing the source</returns>
	    public UnicodeLabel GetNameSource() {
	        if (nameSource == null) {
	            nameSource = new BagFormatter.NameLabel (GetUnicodePropertyFactory());
	        }
	        return nameSource;
	    }
	
	    
	    /// <param name="label"></param>
	    public BagFormatter SetNameSource(UnicodeLabel label) {
	        if (label == null)
	            label = IBM.ICU.Charset.UnicodeLabel.NULL;
	        nameSource = label;
	        return this;
	    }
	
	    
	    /// <returns>the UnicodeLabel representing the value</returns>
	    public UnicodeLabel GetValueSource() {
	        if (valueSource == null)
	            valueSource = IBM.ICU.Charset.UnicodeLabel.NULL;
	        return valueSource;
	    }
	
	    internal String GetValue(int cp, bool shortValue_0) {
	        String result = GetValueSource().GetValue(cp, shortValue_0);
	        if (result == null)
	            return NULL_VALUE;
	        if (hexValue)
	            result = Hex(result, " ");
	        return result;
	    }
	
	    
	    /// <param name="label"></param>
	    public BagFormatter SetValueSource(UnicodeLabel label) {
	        if (label == null)
	            label = IBM.ICU.Charset.UnicodeLabel.NULL;
	        valueSource = label;
	        return this;
	    }
	
	    public BagFormatter SetValueSource(String label) {
	        return SetValueSource(new UnicodeLabel.Constant(label));
	    }
	
	    
	    /// <returns>true if showCount is true</returns>
	    public bool IsShowCount() {
	        return showCount;
	    }
	
	    
	    /// <param name="b">true to show the count</param>
	    /// <returns>this (for chaining)</returns>
	    public BagFormatter SetShowCount(bool b) {
	        showCount = b;
	        return this;
	    }
	
	    
	    /// <returns>the property name</returns>
	    public String GetPropName() {
	        return propName;
	    }
	
	    
	    /// <param name="string"></param>
	    /// <returns>this (for chaining)</returns>
	    public BagFormatter SetPropName(String str0) {
	        if (str0 == null)
	            str0 = "";
	        propName = str0;
	        return this;
	    }
	
	    
	    /// <returns>true if this is a hexValue</returns>
	    public bool IsHexValue() {
	        return hexValue;
	    }
	
	    
	    /// <param name="b"></param>
	    /// <returns>this (for chaining)</returns>
	    public BagFormatter SetHexValue(bool b) {
	        hexValue = b;
	        return this;
	    }
	
	    
	    /// <returns>the full total</returns>
	    public int GetFullTotal() {
	        return fullTotal;
	    }
	
	    
	    /// <param name="i">set the full total</param>
	    /// <returns>this (for chaining)</returns>
	    public BagFormatter SetFullTotal(int i) {
	        fullTotal = i;
	        return this;
	    }
	
	    
	    /// <returns>the line separator</returns>
	    public String GetLineSeparator() {
	        return lineSeparator;
	    }
	
	    
	    /// <param name="string"></param>
	    /// <returns>this (for chaining)</returns>
	    public BagFormatter SetLineSeparator(String str0) {
	        lineSeparator = str0;
	        return this;
	    }
	
	    
	    /// <returns>the UnicodeLabel representing the range break source</returns>
	    public UnicodeLabel GetRangeBreakSource() {
	        if (rangeBreakSource == null) {
	            IDictionary labelMap = new Hashtable();
	            // reflects the code point types on p 25
	            ILOG.J2CsMapping.Collections.Collections.Put(labelMap,"Lo","G&");
	            ILOG.J2CsMapping.Collections.Collections.Put(labelMap,"Lm","G&");
	            ILOG.J2CsMapping.Collections.Collections.Put(labelMap,"Lu","G&");
	            ILOG.J2CsMapping.Collections.Collections.Put(labelMap,"Lt","G&");
	            ILOG.J2CsMapping.Collections.Collections.Put(labelMap,"Ll","G&");
	            ILOG.J2CsMapping.Collections.Collections.Put(labelMap,"Mn","G&");
	            ILOG.J2CsMapping.Collections.Collections.Put(labelMap,"Me","G&");
	            ILOG.J2CsMapping.Collections.Collections.Put(labelMap,"Mc","G&");
	            ILOG.J2CsMapping.Collections.Collections.Put(labelMap,"Nd","G&");
	            ILOG.J2CsMapping.Collections.Collections.Put(labelMap,"Nl","G&");
	            ILOG.J2CsMapping.Collections.Collections.Put(labelMap,"No","G&");
	            ILOG.J2CsMapping.Collections.Collections.Put(labelMap,"Zs","G&");
	            ILOG.J2CsMapping.Collections.Collections.Put(labelMap,"Pd","G&");
	            ILOG.J2CsMapping.Collections.Collections.Put(labelMap,"Ps","G&");
	            ILOG.J2CsMapping.Collections.Collections.Put(labelMap,"Pe","G&");
	            ILOG.J2CsMapping.Collections.Collections.Put(labelMap,"Pc","G&");
	            ILOG.J2CsMapping.Collections.Collections.Put(labelMap,"Po","G&");
	            ILOG.J2CsMapping.Collections.Collections.Put(labelMap,"Pi","G&");
	            ILOG.J2CsMapping.Collections.Collections.Put(labelMap,"Pf","G&");
	            ILOG.J2CsMapping.Collections.Collections.Put(labelMap,"Sm","G&");
	            ILOG.J2CsMapping.Collections.Collections.Put(labelMap,"Sc","G&");
	            ILOG.J2CsMapping.Collections.Collections.Put(labelMap,"Sk","G&");
	            ILOG.J2CsMapping.Collections.Collections.Put(labelMap,"So","G&");
	
	            ILOG.J2CsMapping.Collections.Collections.Put(labelMap,"Zl","Cf");
	            ILOG.J2CsMapping.Collections.Collections.Put(labelMap,"Zp","Cf");
	
	            rangeBreakSource = new UnicodeProperty.FilteredProperty(
	                    GetUnicodePropertyFactory().GetProperty("General_Category"),
	                    new UnicodeProperty.MapFilter(labelMap))
	                    .SetAllowValueAliasCollisions(true);
	
	            /*
	             * "Cn", // = Other, Not Assigned 0 "Cc", // = Other, Control 15
	             * "Cf", // = Other, Format 16 UnicodeProperty.UNUSED, // missing
	             * "Co", // = Other, Private Use 18 "Cs", // = Other, Surrogate 19
	             */
	        }
	        return rangeBreakSource;
	    }
	
	    
	    /// <param name="label"></param>
	    public BagFormatter SetRangeBreakSource(UnicodeLabel label) {
	        if (label == null)
	            label = IBM.ICU.Charset.UnicodeLabel.NULL;
	        rangeBreakSource = label;
	        return this;
	    }
	
	    
	    /// <returns>Returns the fixName.</returns>
	    public Transliterator GetFixName() {
	        return fixName;
	    }
	
	    
	    /// <param name="fixName_0">The fixName to set.</param>
	    public void SetFixName(Transliterator fixName_0) {
	        this.fixName = fixName_0;
	    }
	
	    public Tabber GetTabber() {
	        return tabber;
	    }
	
	    public void SetTabber(Tabber tabber_0) {
	        this.tabber = tabber_0;
	    }
	
	    public bool IsShowTotal() {
	        return showTotal;
	    }
	
	    public void SetShowTotal(bool showTotal_0) {
	        this.showTotal = showTotal_0;
	    }
	
	    static BagFormatter() {
	            bool showFiles = false;
	            try {
	                showFiles = System.Environment.GetEnvironmentVariable("SHOW_FILES") != null;
	            } catch (SecurityException e) {
	            }
	            SHOW_FILES = showFiles;
	            nf.SetGroupingUsed(false);
	        }
	}
	// #endif
}
