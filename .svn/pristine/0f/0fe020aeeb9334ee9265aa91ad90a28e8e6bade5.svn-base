// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:47 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /// <summary>
/// Copyright (C) 2001-2004, International Business Machines Corporation and    
/// others. All Rights Reserved.                                                
/// </summary>
///
namespace IBM.ICU.Util {
	
	using ILOG.J2CsMapping.Collections;
	using ILOG.J2CsMapping.Collections.Generics;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.Globalization;
	using System.IO;
	using System.Resources;
	using System.Runtime.CompilerServices;
    using ILOG.J2CsMapping.Util;
    using ILOG.J2CsMapping.Util;
	
	/// <exclude/>
	/// <summary>
	/// A ResourceBundle that overlays one hierarchy atop another. This is best
	/// explained by example. Suppose one wants to use the resource hiararchy (in JDK
	/// 1.2 and 1.3, but not 1.4) at "java.text.resources.LocaleElements", but one
	/// wants to use a modified version of the "NumberPatterns" resource in the fr_FR
	/// locale. One way to do this is to add special case code to the lookup
	/// operation to check for fr_FR and the key "NumberPatterns", and in that case,
	/// load up custom data. However, this becomes unwieldy and places some
	/// information about the effective resource hierarchy into the code.
	/// The OverlayBundle solves this problem by layering another hierarchy, e.g,
	/// "com.acme.resources.LocaleElements", on top of a base hierarchy. When a
	/// resource is requested, it is first sought in the overlay hierarchy, and if
	/// not found there, it is sought in the base hierarchy. Multiple overlays are
	/// supported, but in practice one is usually sufficient.
	/// The OverlayBundle also addresses the problem of country-oriented data. To
	/// specify the default data for a language, one just sets the language resource
	/// bundle data. However, specifying the default data for a country using the
	/// standard ResourceBundle mechanism is impossible. The OverlayBundle recognizes
	/// "wildcard" locales with the special language code "xx". When looking up data
	/// for a locale with a non-empty country, if an exact locale match cannot be
	/// found, the OverlayBundle looks for data in the locale xx_YY, where YY is the
	/// country being sought. This effectively adds another entry in the fallback
	/// sequence for a locale aa_BB: aa_BB, xx_BB, aa, root. Wildcard locales are not
	/// implemented for the base hierarchy, only for overlays.
	/// The OverlayBundle is implemented as an array of n ResourceBundle base names.
	/// The base names are searched from 0 to n-1. Base name n-1 is special; it is
	/// the base hierarchy. This should be a well-populated hierarchy with most of
	/// the default data, typically, the icu or sun core hierarchies. The base
	/// hierarchy is treated differently from the overlays above it. It does not get
	/// wildcard resolution, and the getKeys() framework method is delegated to the
	/// base hierarchy bundle.
	/// Usage: Instantiate an OverlayBundle directly (not via a factory method as in
	/// ResourceBundle). Instead of specifying a single base name, pass it an array
	/// of 2 or more base names. After that, use it exactly as you would use
	/// ResourceBundle.
	/// </summary>
	///
	/// <seealso cref="T:System.Resources.ResourceManager"/>
	// prepare to deprecate in next release
	// /CLOVER:OFF
	public class OverlayBundle : ResourceBundle {
	
	    /// <summary>
	    /// The array of base names, with the length-1 entry being the base
	    /// hierarchy, typically "sun.text.resources.LocaleElements".
	    /// </summary>
	    ///
	    private String[] baseNames;
	
	    /// <summary>
	    /// The requested locale.
	    /// </summary>
	    ///
	    private Locale locale;
	
	    /// <summary>
	    /// Loaded bundles. These will be null until they are loaded on demand.
	    /// </summary>
	    ///
	    private ResourceBundle[] bundles;
	
	    /// <exclude/>
	    /// <summary>
	    /// Construct an overlay bundle given a sequence of base names and a locale.
	    /// </summary>
	    ///
	    public OverlayBundle(String[] baseNames_0, Locale locale_1) {
	        this.baseNames = baseNames_0;
	        this.locale = locale_1;
	        bundles = new ResourceBundle[baseNames_0.Length];
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// ResourceBundle framework method. Delegates to bundles[i].getObject().
	    /// </summary>
	    ///
	    public override Object HandleGetObject(String key) {
	
	        Object o = null;
	
	        for (int i = 0; i < bundles.Length; ++i) {
	            Load(i);
	            try {
	                o = bundles[i].GetObject(key);
	            } catch (MissingManifestResourceException e) {
	                if (i == bundles.Length - 1) {
	                    throw e;
	                }
	            }
	            if (o != null) {
	                break;
	            }
	        }
	
	        return o;
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// ResourceBundle framework method. Delegates to
	    /// bundles[bundles.length-1].getKeys().
	    /// </summary>
	    ///
	    public override IIterator<String> GetKeys() {
	        // Return the enumeration of the last bundle, which is the base
	        // of our hierarchy stack.
	        int i = bundles.Length - 1;
	        Load(i);
	        return bundles[i].GetKeys();
	    }
	
	    /// <summary>
	    /// Load the i-th bundle and implement wildcard resolution.
	    /// </summary>
	    ///
	    private void Load(int i) {
	
	        if (bundles[i] == null) {
	            bool tryWildcard = false;
	            try {
	                bundles[i] = ResourceBundle.GetBundle(baseNames[i], locale);
	                if (bundles[i].GetLocale().Equals(locale)) {
	                    return;
	                }
                    if (locale.GetCountry().Length != 0
	                        && i != bundles.Length - 1) {
	                    tryWildcard = true;
	                }
	            } catch (MissingManifestResourceException e) {
	                if (i == bundles.Length - 1) {
	                    throw e;
	                }
	                tryWildcard = true;
	            }
	            if (tryWildcard) {
                    Locale wildcard = new Locale("xx", locale.GetCountry(),
	                        locale.GetLanguage());
	                try {
	                    bundles[i] = ResourceBundle.GetBundle(baseNames[i],
	                            wildcard);
	                } catch (MissingManifestResourceException e_0) {
	                    if (bundles[i] == null) {
	                        throw e_0;
	                    }
	                }
	            }
	        }
	    }
	}
}
