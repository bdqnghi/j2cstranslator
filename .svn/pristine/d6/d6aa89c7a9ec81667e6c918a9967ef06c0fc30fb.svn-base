//##header J2SE15
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:57 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /* Generated from 'BigDecimal.nrx' 8 Sep 2000 11:10:50 [v2.00] */
/* Options: Binary Comments Crossref Format Java Logo Strictargs Strictcase Trace2 Verbose3 */
namespace IBM.ICU.Math {
	
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Runtime.Serialization;
	using System.Text;
	
	/* ------------------------------------------------------------------ */
	/* BigDecimal -- Decimal arithmetic for Java                          */
	/* ------------------------------------------------------------------ */
	/* Copyright IBM Corporation, 1996-2007.  All Rights Reserved.       */
	/*                                                                    */
	/* The BigDecimal class provides immutable arbitrary-precision        */
	/* floating point (including integer) decimal numbers.                */
	/*                                                                    */
	/* As the numbers are decimal, there is an exact correspondence       */
	/* between an instance of a BigDecimal object and its String          */
	/* representation; the BigDecimal class provides direct conversions   */
	/* to and from String and character array objects, and well as        */
	/* conversions to and from the Java primitive types (which may not    */
	/* be exact).                                                         */
	/* ------------------------------------------------------------------ */
	/* Notes:                                                             */
	/*                                                                    */
	/* 1. A BigDecimal object is never changed in value once constructed; */
	/*    this avoids the need for locking.  Note in particular that the  */
	/*    mantissa array may be shared between many BigDecimal objects,   */
	/*    so that once exposed it must not be altered.                    */
	/*                                                                    */
	/* 2. This class looks at MathContext class fields directly (for      */
	/*    performance).  It must not and does not change them.            */
	/*                                                                    */
	/* 3. Exponent checking is delayed until finish(), as we know         */
	/*    intermediate calculations cannot cause 31-bit overflow.         */
	/*    [This assertion depends on MAX_DIGITS in MathContext.]          */
	/*                                                                    */
	/* 4. Comments for the public API now follow the javadoc conventions. */
	/*    The NetRexx -comments option is used to pass these comments     */
	/*    through to the generated Java code (with -format, if desired).  */
	/*                                                                    */
	/* 5. System.arraycopy is faster than explicit loop as follows        */
	/*      Mean length 4:  equal                                         */
	/*      Mean length 8:  x2                                            */
	/*      Mean length 16: x3                                            */
	/*      Mean length 24: x4                                            */
	/*    From prior experience, we expect mean length a little below 8,  */
	/*    but arraycopy is still the one to use, in general, until later  */
	/*    measurements suggest otherwise.                                 */
	/*                                                                    */
	/* 6. 'DMSRCN' referred to below is the original (1981) IBM S/370     */
	/*    assembler code implementation of the algorithms below; it is    */
	/*    now called IXXRCN and is available with the OS/390 and VM/ESA   */
	/*    operating systems.                                              */
	/* ------------------------------------------------------------------ */
	/* Change History:                                                    */
	/* 1997.09.02 Initial version (derived from netrexx.lang classes)     */
	/* 1997.09.12 Add lostDigits checking                                 */
	/* 1997.10.06 Change mantissa to a byte array                         */
	/* 1997.11.22 Rework power [did not prepare arguments, etc.]          */
	/* 1997.12.13 multiply did not prepare arguments                      */
	/* 1997.12.14 add did not prepare and align arguments correctly       */
	/* 1998.05.02 0.07 packaging changes suggested by Sun and Oracle      */
	/* 1998.05.21 adjust remainder operator finalization                  */
	/* 1998.06.04 rework to pass MathContext to finish() and round()      */
	/* 1998.06.06 change format to use round(); support rounding modes    */
	/* 1998.06.25 rename to BigDecimal and begin merge                    */
	/*            zero can now have trailing zeros (i.e., exp\=0)         */
	/* 1998.06.28 new methods: movePointXxxx, scale, toBigInteger         */
	/*                         unscaledValue, valueof                     */
	/* 1998.07.01 improve byteaddsub to allow array reuse, etc.           */
	/* 1998.07.01 make null testing explicit to avoid JIT bug [Win32]     */
	/* 1998.07.07 scaled division  [divide(BigDecimal, int, int)]         */
	/* 1998.07.08 setScale, faster equals                                 */
	/* 1998.07.11 allow 1E6 (no sign) <sigh>; new double/float conversion */
	/* 1998.10.12 change package to com.ibm.icu.math                          */
	/* 1998.12.14 power operator no longer rounds RHS [to match ANSI]     */
	/*            add toBigDecimal() and BigDecimal(java.math.BigDecimal) */
	/* 1998.12.29 improve byteaddsub by using table lookup                */
	/* 1999.02.04 lostdigits=0 behaviour rounds instead of digits+1 guard */
	/* 1999.02.05 cleaner code for BigDecimal(char[])                     */
	/* 1999.02.06 add javadoc comments                                    */
	/* 1999.02.11 format() changed from 7 to 2 method form                */
	/* 1999.03.05 null pointer checking is no longer explicit             */
	/* 1999.03.05 simplify; changes from discussion with J. Bloch:        */
	/*            null no longer permitted for MathContext; drop boolean, */
	/*            byte, char, float, short constructor, deprecate double  */
	/*            constructor, no blanks in string constructor, add       */
	/*            offset and length version of char[] constructor;        */
	/*            add valueOf(double); drop booleanValue, charValue;      */
	/*            add ...Exact versions of remaining convertors           */
	/* 1999.03.13 add toBigIntegerExact                                   */
	/* 1999.03.13 1.00 release to IBM Centre for Java Technology          */
	/* 1999.05.27 1.01 correct 0-0.2 bug under scaled arithmetic          */
	/* 1999.06.29 1.02 constructors should not allow exponent > 9 digits  */
	/* 1999.07.03 1.03 lost digits should not be checked if digits=0      */
	/* 1999.07.06      lost digits Exception message changed              */
	/* 1999.07.10 1.04 more work on 0-0.2 (scaled arithmetic)             */
	/* 1999.07.17      improve messages from pow method                   */
	/* 1999.08.08      performance tweaks                                 */
	/* 1999.08.15      fastpath in multiply                               */
	/* 1999.11.05 1.05 fix problem in intValueExact [e.g., 5555555555]    */
	/* 1999.12.22 1.06 remove multiply fastpath, and improve performance  */
	/* 2000.01.01      copyright update [Y2K has arrived]                 */
	/* 2000.06.18 1.08 no longer deprecate BigDecimal(double)             */
	/* ------------------------------------------------------------------ */
	
	/// <summary>
	/// The <c>BigDecimal</c> class implements immutable arbitrary-precision
	/// decimal numbers. The methods of the <c>BigDecimal</c> class provide
	/// operations for fixed and floating point arithmetic, comparison, format
	/// conversions, and hashing.
	/// <p>
	/// As the numbers are decimal, there is an exact correspondence between an
	/// instance of a <c>BigDecimal</c> object and its <c>String</c>
	/// representation; the <c>BigDecimal</c> class provides direct conversions
	/// to and from <c>String</c> and character array (<c>char[]</c>)
	/// objects, as well as conversions to and from the Java primitive types (which
	/// may not be exact) and <c>BigInteger</c>.
	/// <p>
	/// In the descriptions of constructors and methods in this documentation, the
	/// value of a <c>BigDecimal</c> number object is shown as the result of
	/// invoking the <c>toString()</c> method on the object. The internal
	/// representation of a decimal number is neither defined nor exposed, and is not
	/// permitted to affect the result of any operation.
	/// <p>
	/// The floating point arithmetic provided by this class is defined by the ANSI
	/// X3.274-1996 standard, and is also documented at
	/// <code>http://www2.hursley.ibm.com/decimal</code> <br>
	/// <i>[This URL will change.]</i>
	/// <h3>Operator methods</h3>
	/// <p>
	/// Operations on <c>BigDecimal</c> numbers are controlled by a<see cref="T:IBM.ICU.Math.MathContext"/> object, which provides the context (precision and other
	/// information) for the operation. Methods that can take a
	/// <c>MathContext</c> parameter implement the standard arithmetic
	/// operators for <c>BigDecimal</c> objects and are known as <i>operator
	/// methods</i>. The default settings provided by the constant<see cref="M:IBM.ICU.Math.MathContext.DEFAULT"/> (<code>digits=9,
	/// form=SCIENTIFIC, lostDigits=false, roundingMode=ROUND_HALF_UP</code>) perform
	/// general-purpose floating point arithmetic to nine digits of precision. The
	/// <c>MathContext</c> parameter must not be <c>null</c>.
	/// <p>
	/// Each operator method also has a version provided which does not take a
	/// <c>MathContext</c> parameter. For this version of each method, the
	/// context settings used are <code>digits=0,
	/// form=PLAIN, lostDigits=false, roundingMode=ROUND_HALF_UP</code>; these
	/// settings perform fixed point arithmetic with unlimited precision, as defined
	/// for the original BigDecimal class in Java 1.1 and Java 1.2.
	/// <p>
	/// For monadic operators, only the optional <c>MathContext</c> parameter
	/// is present; the operation acts upon the current object.
	/// <p>
	/// For dyadic operators, a <c>BigDecimal</c> parameter is always present;
	/// it must not be <c>null</c>. The operation acts with the current object
	/// being the left-hand operand and the <c>BigDecimal</c> parameter being
	/// the right-hand operand.
	/// <p>
	/// For example, adding two <c>BigDecimal</c> objects referred to by the
	/// names <c>award</c> and <c>extra</c> could be written as any of:
	/// <p>
	/// <code>
	/// award.add(extra)
	/// <br>award.add(extra, MathContext.DEFAULT)
	/// <br>award.add(extra, acontext)
	/// </code>
	/// <p>
	/// (where <c>acontext</c> is a <c>MathContext</c> object), which
	/// would return a <c>BigDecimal</c> object whose value is the result of
	/// adding <c>award</c> and <c>extra</c> under the appropriate
	/// context settings.
	/// <p>
	/// When a <c>BigDecimal</c> operator method is used, a set of rules define
	/// what the result will be (and, by implication, how the result would be
	/// represented as a character string). These rules are defined in the BigDecimal
	/// arithmetic documentation (see the URL above), but in summary:
	/// <ul>
	/// <li>Results are normally calculated with up to some maximum number of
	/// significant digits. For example, if the <c>MathContext</c> parameter
	/// for an operation were <c>MathContext.DEFAULT</c> then the result would
	/// be rounded to 9 digits; the division of 2 by 3 would then result in
	/// 0.666666667. <br>
	/// You can change the default of 9 significant digits by providing the method
	/// with a suitable <c>MathContext</c> object. This lets you calculate
	/// using as many digits as you need -- thousands, if necessary. Fixed point
	/// (scaled) arithmetic is indicated by using a <c>digits</c> setting of 0
	/// (or omitting the <c>MathContext</c> parameter). <br>
	/// Similarly, you can change the algorithm used for rounding from the default
	/// "classic" algorithm.
	/// <li>
	/// In standard arithmetic (that is, when the <c>form</c> setting is not
	/// <c>PLAIN</c>), a zero result is always expressed as the single digit
	/// <c>'0'</c> (that is, with no sign, decimal point, or exponent part).
	/// <li>
	/// Except for the division and power operators in standard arithmetic, trailing
	/// zeros are preserved (this is in contrast to binary floating point operations
	/// and most electronic calculators, which lose the information about trailing
	/// zeros in the fractional part of results). <br>
	/// So, for example:
	/// <p>
	/// <code>
	/// new BigDecimal("2.40").add(     new BigDecimal("2"))      =&gt; "4.40"
	/// <br>new BigDecimal("2.40").subtract(new BigDecimal("2"))      =&gt; "0.40"
	/// <br>new BigDecimal("2.40").multiply(new BigDecimal("2"))      =&gt; "4.80"
	/// <br>new BigDecimal("2.40").divide(  new BigDecimal("2"), def) =&gt; "1.2"
	/// </code>
	/// <p>
	/// where the value on the right of the <c>=&gt;</c> would be the result of
	/// the operation, expressed as a <c>String</c>, and <c>def</c> (in
	/// this and following examples) refers to <c>MathContext.DEFAULT</c>).
	/// This preservation of trailing zeros is desirable for most calculations
	/// (including financial calculations). If necessary, trailing zeros may be
	/// easily removed using division by 1.
	/// <li>
	/// In standard arithmetic, exponential form is used for a result depending on
	/// its value and the current setting of <c>digits</c> (the default is 9
	/// digits). If the number of places needed before the decimal point exceeds the
	/// <c>digits</c> setting, or the absolute value of the number is less than
	/// <c>0.000001</c>, then the number will be expressed in exponential
	/// notation; thus
	/// <p>
	/// <code>
	/// new BigDecimal("1e+6").multiply(new BigDecimal("1e+6"), def)
	/// </code>
	/// <p>
	/// results in <c>1E+12</c> instead of <c>1000000000000</c>, and
	/// <p>
	/// <code>
	/// new BigDecimal("1").divide(new BigDecimal("3E+10"), def)
	/// </code>
	/// <p>
	/// results in <c>3.33333333E-11</c> instead of
	/// <c>0.0000000000333333333</c>.
	/// <p>
	/// The form of the exponential notation (scientific or engineering) is
	/// determined by the <c>form</c> setting. <eul>
	/// <p>
	/// The names of methods in this class follow the conventions established by
	/// <c>java.lang.Number</c>, <c>java.math.BigInteger</c>, and
	/// <c>java.math.BigDecimal</c> in Java 1.1 and Java 1.2.
	/// </summary>
	///
	/// <seealso cref="T:IBM.ICU.Math.MathContext"/>
	/// @stable ICU 2.0
	[Serializable]	
	public class BigDecimal : object, 
	        IComparable {
	    // private static final java.lang.String $0="BigDecimal.nrx";
	
	    /* ----- Constants ----- */
	    /* properties constant public */// useful to others
	    /// <summary>
	    /// The <c>BigDecimal</c> constant "0".
	    /// </summary>
	    ///
	    /// <seealso cref="F:IBM.ICU.Math.BigDecimal.ONE"/>
	    /// <seealso cref="F:IBM.ICU.Math.BigDecimal.TEN"/>
	    /// @stable ICU 2.0
	    public static readonly IBM.ICU.Math.BigDecimal ZERO = new IBM.ICU.Math.BigDecimal(
	            (long) 0); // use long as we want the int constructor
	
	    // .. to be able to use this, for speed
	
	    /// <summary>
	    /// The <c>BigDecimal</c> constant "1".
	    /// </summary>
	    ///
	    /// <seealso cref="F:IBM.ICU.Math.BigDecimal.TEN"/>
	    /// <seealso cref="F:IBM.ICU.Math.BigDecimal.ZERO"/>
	    /// @stable ICU 2.0
	    public static readonly IBM.ICU.Math.BigDecimal ONE = new IBM.ICU.Math.BigDecimal(
	            (long) 1); // use long as we want the int constructor
	
	    // .. to be able to use this, for speed
	
	    /// <summary>
	    /// The <c>BigDecimal</c> constant "10".
	    /// </summary>
	    ///
	    /// <seealso cref="F:IBM.ICU.Math.BigDecimal.ONE"/>
	    /// <seealso cref="F:IBM.ICU.Math.BigDecimal.ZERO"/>
	    /// @stable ICU 2.0
	    public static readonly IBM.ICU.Math.BigDecimal TEN = new IBM.ICU.Math.BigDecimal(
	            10);
	
	    // the rounding modes (copied here for upwards compatibility)
	    /// <summary>
	    /// Rounding mode to round to a more positive number.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Math.MathContext.ROUND_CEILING"/>
	    /// @stable ICU 2.0
	    public const int ROUND_CEILING = IBM.ICU.Math.MathContext.ROUND_CEILING;
	
	    /// <summary>
	    /// Rounding mode to round towards zero.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Math.MathContext.ROUND_DOWN"/>
	    /// @stable ICU 2.0
	    public const int ROUND_DOWN = IBM.ICU.Math.MathContext.ROUND_DOWN;
	
	    /// <summary>
	    /// Rounding mode to round to a more negative number.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Math.MathContext.ROUND_FLOOR"/>
	    /// @stable ICU 2.0
	    public const int ROUND_FLOOR = IBM.ICU.Math.MathContext.ROUND_FLOOR;
	
	    /// <summary>
	    /// Rounding mode to round to nearest neighbor, where an equidistant value is
	    /// rounded down.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Math.MathContext.ROUND_HALF_DOWN"/>
	    /// @stable ICU 2.0
	    public const int ROUND_HALF_DOWN = IBM.ICU.Math.MathContext.ROUND_HALF_DOWN;
	
	    /// <summary>
	    /// Rounding mode to round to nearest neighbor, where an equidistant value is
	    /// rounded to the nearest even neighbor.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Math.MathContext.ROUND_HALF_EVEN"/>
	    /// @stable ICU 2.0
	    public const int ROUND_HALF_EVEN = IBM.ICU.Math.MathContext.ROUND_HALF_EVEN;
	
	    /// <summary>
	    /// Rounding mode to round to nearest neighbor, where an equidistant value is
	    /// rounded up.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Math.MathContext.ROUND_HALF_UP"/>
	    /// @stable ICU 2.0
	    public const int ROUND_HALF_UP = IBM.ICU.Math.MathContext.ROUND_HALF_UP;
	
	    /// <summary>
	    /// Rounding mode to assert that no rounding is necessary.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Math.MathContext.ROUND_UNNECESSARY"/>
	    /// @stable ICU 2.0
	    public const int ROUND_UNNECESSARY = IBM.ICU.Math.MathContext.ROUND_UNNECESSARY;
	
	    /// <summary>
	    /// Rounding mode to round away from zero.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Math.MathContext.ROUND_UP"/>
	    /// @stable ICU 2.0
	    public const int ROUND_UP = IBM.ICU.Math.MathContext.ROUND_UP;
	
	    /* properties constant private */// locals
	    private const sbyte ispos = 1; // ind: indicates positive (must be 1)
	
	    private const sbyte iszero = 0; // ind: indicates zero (must be 0)
	
	    private const sbyte isneg = -1; // ind: indicates negative (must be
	                                          // -1)
	
	    // [later could add NaN, +/- infinity, here]
	
	    private const int MinExp = -999999999; // minimum exponent allowed
	
	    private const int MaxExp = 999999999; // maximum exponent allowed
	
	    private const int MinArg = -999999999; // minimum argument integer
	
	    private const int MaxArg = 999999999; // maximum argument integer
	
	    private static readonly IBM.ICU.Math.MathContext plainMC = new IBM.ICU.Math.MathContext(
	            0, IBM.ICU.Math.MathContext.PLAIN); // context for plain
	                                                    // unlimited math
	
	    /* properties constant private unused */// present but not referenced
	
	    // Serialization version
	    private const long serialVersionUID = 8245355804974198832L;
	
	    // private static final java.lang.String
	    // copyright=" Copyright (c) IBM Corporation 1996, 2000.  All rights reserved. ";
	
	    private static byte[] bytecar = new byte[(90 + 99) + 1];
	
	    private static byte[] bytedig = Diginit();
	
	    /* ----- Instance properties [all private and immutable] ----- */
	    /* properties private */
	
	    /// <summary>
	    /// The indicator. This may take the values:
	    /// <ul>
	    /// <li>ispos -- the number is positive
	    /// <li>iszero -- the number is zero
	    /// <li>isneg -- the number is negative
	    /// </ul>
	    /// </summary>
	    ///
	    /// @serial
	    private sbyte ind; // assumed undefined
	
	    // Note: some code below assumes IND = Sign [-1, 0, 1], at present.
	    // We only need two bits for this, but use a byte [also permits
	    // smooth future extension].
	
	    /// <summary>
	    /// The formatting style. This may take the values:
	    /// <ul>
	    /// <li>MathContext.PLAIN -- no exponent needed
	    /// <li>MathContext.SCIENTIFIC -- scientific notation required
	    /// <li>MathContext.ENGINEERING -- engineering notation required
	    /// </ul>
	    /// <p>
	    /// This property is an optimization; it allows us to defer number layout
	    /// until it is actually needed as a string, hence avoiding unnecessary
	    /// formatting.
	    /// </summary>
	    ///
	    /// @serial
	    private byte form; // assumed
	                                                                   // PLAIN
	
	    // We only need two bits for this, at present, but use a byte
	    // [again, to allow for smooth future extension]
	
	    /// <summary>
	    /// The value of the mantissa. <p> Once constructed, this may become shared between several BigDecimal objects, so must not be altered. <p> For efficiency (speed), this is a byte array, with each byte taking a value of 0 -> 9. <p> If the first byte is 0 then the value of the number is zero (and mant.length=1, except when constructed from a plain number, for example, 0.000).
	    /// </summary>
	    ///
	    /// @serial
	    private byte[] mant;
	
	    /// <summary>
	    /// The exponent.
	    /// <p>
	    /// For fixed point arithmetic, scale is <c>-exp</c>, and can apply to
	    /// zero.
	    /// Note that this property can have a value less than MinExp when the
	    /// mantissa has more than one digit.
	    /// </summary>
	    ///
	    /// @serial
	    private int exp;
	
	    // assumed 0
	
	    /* ---------------------------------------------------------------- */
	    /* Constructors */
	    /* ---------------------------------------------------------------- */
	
	    // #if defined(FOUNDATION10) || defined(J2SE13)
	    // #else
	    /// <summary>
	    /// Constructs a <c>BigDecimal</c> object from a
	    /// <c>java.math.BigDecimal</c>.
	    /// <p>
	    /// Constructs a <c>BigDecimal</c> as though the parameter had been
	    /// represented as a <c>String</c> (using its <c>toString</c>
	    /// method) and the <see cref="M:IBM.ICU.Math.BigDecimal.BigDecimal(System.String)"/> constructor had
	    /// then been used. The parameter must not be <c>null</c>.
	    /// <p>
	    /// <i>(Note: this constructor is provided only in the
	    /// <c>com.ibm.icu.math</c> version of the BigDecimal class. It would
	    /// not be present in a <c>java.math</c> version.)</i>
	    /// </summary>
	    ///
	    /// <param name="bd">The <c>BigDecimal</c> to be translated.</param>
	    /// @stable ICU 2.0
	
	    public BigDecimal(Decimal bd) : this(bd.ToString()) {
	        return;
	    }
	
	    // #endif
	
	    /// <summary>
	    /// Constructs a <c>BigDecimal</c> object from a
	    /// <c>BigInteger</c>, with scale 0.
	    /// <p>
	    /// Constructs a <c>BigDecimal</c> which is the exact decimal
	    /// representation of the <c>BigInteger</c>, with a scale of zero. The
	    /// value of the <c>BigDecimal</c> is identical to the value of the
	    /// <c>BigInteger</c>. The parameter must not be <c>null</c>.
	    /// <p>
	    /// The <c>BigDecimal</c> will contain only decimal digits, prefixed
	    /// with a leading minus sign (hyphen) if the <c>BigInteger</c> is
	    /// negative. A leading zero will be present only if the
	    /// <c>BigInteger</c> is zero.
	    /// </summary>
	    ///
	    /// <param name="bi">The <c>BigInteger</c> to be converted.</param>
	    /// @stable ICU 2.0
	
	    /*public BigDecimal(Int64 bi) : this(bi.ToString(10)) {
	        return;
	    }*/
	
	    // exp remains 0
	
	    /// <summary>
	    /// Constructs a <c>BigDecimal</c> object from a
	    /// <c>BigInteger</c> and a scale.
	    /// <p>
	    /// Constructs a <c>BigDecimal</c> which is the exact decimal
	    /// representation of the <c>BigInteger</c>, scaled by the second
	    /// parameter, which may not be negative. The value of the
	    /// <c>BigDecimal</c> is the <c>BigInteger</c> divided by ten to
	    /// the power of the scale. The <c>BigInteger</c> parameter must not be
	    /// <c>null</c>.
	    /// <p>
	    /// The <c>BigDecimal</c> will contain only decimal digits, (with an
	    /// embedded decimal point followed by <c>scale</c> decimal digits if
	    /// the scale is positive), prefixed with a leading minus sign (hyphen) if
	    /// the <c>BigInteger</c> is negative. A leading zero will be present
	    /// only if the <c>BigInteger</c> is zero.
	    /// </summary>
	    ///
	    /// <param name="bi">The <c>BigInteger</c> to be converted.</param>
	    /// <param name="scale">The <c>int</c> specifying the scale.</param>
	    /// <exception cref="NumberFormatException">if the scale is negative.</exception>
	    /// @stable ICU 2.0
	
	    public BigDecimal(Decimal bi, int scale) : this(bi.ToString()) {
	        if (scale < 0)
	            throw new FormatException("Negative scale:" + " "
	                    + scale);
	        exp = (int) -scale; // exponent is -scale
	        return;
	    }
	
	    /// <summary>
	    /// Constructs a <c>BigDecimal</c> object from an array of characters.
	    /// <p>
	    /// Constructs a <c>BigDecimal</c> as though a <c>String</c> had
	    /// been constructed from the character array and the<see cref="M:IBM.ICU.Math.BigDecimal.BigDecimal(System.String)"/> constructor had then been used. The
	    /// parameter must not be <c>null</c>.
	    /// <p>
	    /// Using this constructor is faster than using the
	    /// <c>BigDecimal(String)</c> constructor if the string is already
	    /// available in character array form.
	    /// </summary>
	    ///
	    /// <param name="inchars">The <c>char[]</c> array containing the number to beconverted.</param>
	    /// <exception cref="NumberFormatException">if the parameter is not a valid number.</exception>
	    /// @stable ICU 2.0
	
	    public BigDecimal(char[] inchars) : this(inchars, 0, inchars.Length) {
	        return;
	    }
	
	    /// <summary>
	    /// Constructs a <c>BigDecimal</c> object from an array of characters.
	    /// <p>
	    /// Constructs a <c>BigDecimal</c> as though a <c>String</c> had
	    /// been constructed from the character array (or a subarray of that array)
	    /// and the <see cref="M:IBM.ICU.Math.BigDecimal.BigDecimal(System.String)"/> constructor had then been
	    /// used. The first parameter must not be <c>null</c>, and the subarray
	    /// must be wholly contained within it.
	    /// <p>
	    /// Using this constructor is faster than using the
	    /// <c>BigDecimal(String)</c> constructor if the string is already
	    /// available within a character array.
	    /// </summary>
	    ///
	    /// <param name="inchars">The <c>char[]</c> array containing the number to beconverted.</param>
	    /// <param name="offset">The <c>int</c> offset into the array of the start of thenumber to be converted.</param>
	    /// <param name="length">The <c>int</c> length of the number.</param>
	    /// <exception cref="NumberFormatException">if the parameter is not a valid number for any reason.</exception>
	    /// @stable ICU 2.0
	
	    public BigDecimal(char[] inchars, int offset, int length) : base() {
	        this.form = (byte) IBM.ICU.Math.MathContext.PLAIN;
	        bool exotic;
	        bool hadexp;
	        int d;
	        int dotoff;
	        int last;
	        int i = 0;
	        char si = (char) (0);
	        bool eneg = false;
	        int k = 0;
	        int elen = 0;
	        int j = 0;
	        char sj = (char) (0);
	        int dvalue = 0;
	        int mag = 0;
	        // This is the primary constructor; all incoming strings end up
	        // here; it uses explicit (inline) parsing for speed and to avoid
	        // generating intermediate (temporary) objects of any kind.
	        // 1998.06.25: exponent form built only if E/e in string
	        // 1998.06.25: trailing zeros not removed for zero
	        // 1999.03.06: no embedded blanks; allow offset and length
	        if (length <= 0)
	            Bad(inchars); // bad conversion (empty string)
	        // [bad offset will raise array bounds exception]
	
	        /* Handle and step past sign */
	        ind = ispos; // assume positive
	        if (inchars[offset] == ('-')) {
	            length--;
	            if (length == 0)
	                Bad(inchars); // nothing after sign
	            ind = isneg;
	            offset++;
	        } else if (inchars[offset] == ('+')) {
	            length--;
	            if (length == 0)
	                Bad(inchars); // nothing after sign
	            offset++;
	        }
	
	        /* We're at the start of the number */
	        exotic = false; // have extra digits
	        hadexp = false; // had explicit exponent
	        d = 0; // count of digits found
	        dotoff = -1; // offset where dot was found
	        last = -1; // last character of mantissa
	        {
	            int _1 = length;
	            i = offset;
	            i: {
	                for (; _1 > 0; _1--, i++) {
	                    si = inchars[i];
	                    if (si >= '0') // test for Arabic digit
	                        if (si <= '9') {
	                            last = i;
	                            d++; // still in mantissa
                                continue;
	                        }
	                    if (si == '.') { // record and ignore
	                        if (dotoff >= 0)
	                            Bad(inchars); // two dots
	                        dotoff = i - offset; // offset into mantissa
                            continue;
	                    }
	                    if (si != 'e')
	                        if (si != 'E') { // expect an extra digit
	                            if ((!(Char.IsDigit(si))))
	                                Bad(inchars); // not a number
	                            // defer the base 10 check until later to avoid extra
	                            // method call
	                            exotic = true; // will need conversion later
	                            last = i;
	                            d++; // still in mantissa
                                continue;
	                        }
	                    /* Found 'e' or 'E' -- now process explicit exponent */
	                    // 1998.07.11: sign no longer required
	                    if ((i - offset) > (length - 2))
	                        Bad(inchars); // no room for even one digit
	                    eneg = false;
	                    if ((inchars[i + 1]) == ('-')) {
	                        eneg = true;
	                        k = i + 2;
	                    } else if ((inchars[i + 1]) == ('+'))
	                        k = i + 2;
	                    else
	                        k = i + 1;
	                    // k is offset of first expected digit
	                    elen = length - ((k - offset)); // possible number of digits
	                    if ((elen == 0) | (elen > 9))
	                        Bad(inchars); // 0 or more than 9 digits
	                    {
	                        int _2 = elen;
	                        j = k;
	                        for (; _2 > 0; _2--, j++) {
	                            sj = inchars[j];
	                            if (sj < '0')
	                                Bad(inchars); // always bad
	                            if (sj > '9') { // maybe an exotic digit
	                                if ((!(Char.IsDigit(sj))))
	                                    Bad(inchars); // not a number
	                                dvalue = ILOG.J2CsMapping.Util.Character.Digit(sj,10); // check
	                                                                            // base
	                                if (dvalue < 0)
	                                    Bad(inchars); // not base 10
	                            } else
	                                dvalue = ((int) (sj)) - ((int) ('0'));
	                            exp = (exp * 10) + dvalue;
	                        }
	                    }/* j */
	                    if (eneg)
	                        exp = (int) -exp; // was negative
	                    hadexp = true; // remember we had one
	                    goto gotoi;
	                }
	            }
	            gotoi:
	            ;
	        }/* i */
	
	        /* Here when all inspected */
	        if (d == 0)
	            Bad(inchars); // no mantissa digits
	        if (dotoff >= 0)
	            exp = (exp + dotoff) - d; // adjust exponent if had dot
	
	        /* strip leading zeros/dot (leave final if all 0's) */
	        {
	            int _3 = last - 1;
	            i = offset;
	            i: {
	                for (; i <= _3; i++) {
	                    si = inchars[i];
	                    if (si == '0') {
	                        offset++;
	                        dotoff--;
	                        d--;
	                    } else if (si == '.') {
	                        offset++; // step past dot
	                        dotoff--;
	                    } else if (si <= '9')
	                        goto gotoi;
	                    else {/* exotic */
	                        if ((ILOG.J2CsMapping.Util.Character.Digit(si,10)) != 0)
	                         goto gotoi;
	                        // is 0 .. strip like '0'
	                        offset++;
	                        dotoff--;
	                        d--;
	                    }
	                }
	            }
	            gotoi:
	            ;
	        }/* i */
	
	        /* Create the mantissa array */
	        mant = new byte[d]; // we know the length
	        j = offset; // input offset
	        if (exotic) {
	            do { // slow: check for exotica
	                {
	                    int _4 = d;
	                    i = 0;
	                    for (; _4 > 0; _4--, i++) {
	                        if (i == dotoff)
	                            j++; // at dot
	                        sj = inchars[j];
	                        if (sj <= '9')
	                            mant[i] = (byte) (((int) (sj)) - ((int) ('0')));/* easy */
	                        else {
	                            dvalue = ILOG.J2CsMapping.Util.Character.Digit(sj,10);
	                            if (dvalue < 0)
	                                Bad(inchars); // not a number after all
	                            mant[i] = (byte) dvalue;
	                        }
	                        j++;
	                    }
	                }/* i */
	            } while (false);
	        }/* exotica */
	        else {
	            do {
	                {
	                    int _5 = d;
	                    i = 0;
	                    for (; _5 > 0; _5--, i++) {
	                        if (i == dotoff)
	                            j++;
	                        mant[i] = (byte) (((int) (inchars[j])) - ((int) ('0')));
	                        j++;
	                    }
	                }/* i */
	            } while (false);
	        }/* simple */
	
	        /* Looks good. Set the sign indicator and form, as needed. */
	        // Trailing zeros are preserved
	        // The rule here for form is:
	        // If no E-notation, then request plain notation
	        // Otherwise act as though add(0,DEFAULT) and request scientific
	        // notation
	        // [form is already PLAIN]
	        if (mant[0] == 0) {
	            ind = iszero; // force to show zero
	            // negative exponent is significant (e.g., -3 for 0.000) if plain
	            if (exp > 0)
	                exp = 0; // positive exponent can be ignored
	            if (hadexp) { // zero becomes single digit from add
	                mant = ZERO.mant;
	                exp = 0;
	            }
	        } else { // non-zero
	                 // [ind was set earlier]
	                 // now determine form
	            if (hadexp) {
	                form = (byte) IBM.ICU.Math.MathContext.SCIENTIFIC;
	                // 1999.06.29 check for overflow
	                mag = (exp + mant.Length) - 1; // true exponent in scientific
	                                               // notation
	                if ((mag < MinExp) | (mag > MaxExp))
	                    Bad(inchars);
	            }
	        }
	        // say 'BD(c[]): mant[0] mantlen exp ind form:' mant[0] mant.length exp
	        // ind form
	        return;
	    }
	
	    /// <summary>
	    /// Constructs a <c>BigDecimal</c> object directly from a
	    /// <c>double</c>.
	    /// <p>
	    /// Constructs a <c>BigDecimal</c> which is the exact decimal
	    /// representation of the 64-bit signed binary floating point parameter.
	    /// <p>
	    /// Note that this constructor it an exact conversion; it does not give the
	    /// same result as converting <c>num</c> to a <c>String</c> using
	    /// the <c>Double.toString()</c> method and then using the<see cref="M:IBM.ICU.Math.BigDecimal.BigDecimal(System.String)"/> constructor. To get that result,
	    /// use the static <see cref="M:IBM.ICU.Math.BigDecimal.ValueOf(System.Double)"/> method to construct a
	    /// <c>BigDecimal</c> from a <c>double</c>.
	    /// </summary>
	    ///
	    /// <param name="num">The <c>double</c> to be converted.</param>
	    /// <exception cref="NumberFormatException">if the parameter is infinite or not a number.</exception>
	    /// @stable ICU 2.0
	
	    public BigDecimal(double num) : this((new Decimal(num)).ToString()) {
	        // #endif
	        return;
	    }
	
	    /// <summary>
	    /// Constructs a <c>BigDecimal</c> object directly from a
	    /// <c>int</c>.
	    /// <p>
	    /// Constructs a <c>BigDecimal</c> which is the exact decimal
	    /// representation of the 32-bit signed binary integer parameter. The
	    /// <c>BigDecimal</c> will contain only decimal digits, prefixed with a
	    /// leading minus sign (hyphen) if the parameter is negative. A leading zero
	    /// will be present only if the parameter is zero.
	    /// </summary>
	    ///
	    /// <param name="num">The <c>int</c> to be converted.</param>
	    /// @stable ICU 2.0
	
	    public BigDecimal(int num) : base() {
	        this.form = (byte) IBM.ICU.Math.MathContext.PLAIN;
	        int mun;
	        int i = 0;
	        // We fastpath commoners
	        if (num <= 9)
	            if (num >= (-9)) {
	                do {
	                    // very common single digit case
	                    {/* select */
	                        if (num == 0) {
	                            mant = ZERO.mant;
	                            ind = iszero;
	                        } else if (num == 1) {
	                            mant = ONE.mant;
	                            ind = ispos;
	                        } else if (num == (-1)) {
	                            mant = ONE.mant;
	                            ind = isneg;
	                        } else {
	                            {
	                                mant = new byte[1];
	                                if (num > 0) {
	                                    mant[0] = (byte) num;
	                                    ind = ispos;
	                                } else { // num<-1
	                                    mant[0] = (byte) ((int) -num);
	                                    ind = isneg;
	                                }
	                            }
	                        }
	                    }
	                    return;
	                } while (false);
	            }/* singledigit */
	
	        /* We work on negative numbers so we handle the most negative number */
	        if (num > 0) {
	            ind = ispos;
	            num = (int) -num;
	        } else
	            ind = isneg;/* negative */// [0 case already handled]
	        // [it is quicker, here, to pre-calculate the length with
	        // one loop, then allocate exactly the right length of byte array,
	        // then re-fill it with another loop]
	        mun = num; // working copy
	        {
	            i = 9;
	            i: {
	                for (;; i--) {
	                    mun = mun / 10;
	                    if (mun == 0)
	                        goto gotoi;
	                }
	            }
	            gotoi:
	            ;
	        }/* i */
	        // i is the position of the leftmost digit placed
	        mant = new byte[10 - i];
	        {
	            i = (10 - i) - 1;
	            i: {
	                for (;; i--) {
	                    mant[i] = (byte) -(((byte) (num % 10)));
	                    num = num / 10;
	                    if (num == 0)
	                        goto gotoi;
	                }
	            }
	            gotoi:
	            ;
	        }/* i */
	        return;
	    }
	
	    /// <summary>
	    /// Constructs a <c>BigDecimal</c> object directly from a
	    /// <c>long</c>.
	    /// <p>
	    /// Constructs a <c>BigDecimal</c> which is the exact decimal
	    /// representation of the 64-bit signed binary integer parameter. The
	    /// <c>BigDecimal</c> will contain only decimal digits, prefixed with a
	    /// leading minus sign (hyphen) if the parameter is negative. A leading zero
	    /// will be present only if the parameter is zero.
	    /// </summary>
	    ///
	    /// <param name="num">The <c>long</c> to be converted.</param>
	    /// @stable ICU 2.0
	
	    public BigDecimal(long num) : base() {
	        this.form = (byte) IBM.ICU.Math.MathContext.PLAIN;
	        long mun;
	        int i = 0;
	        // Not really worth fastpathing commoners in this constructor [also,
	        // we use this to construct the static constants].
	        // This is much faster than: this(String.valueOf(num).toCharArray())
	        /* We work on negative num so we handle the most negative number */
	        if (num > 0) {
	            ind = ispos;
	            num = (long) -num;
	        } else if (num == 0)
	            ind = iszero;
	        else
	            ind = isneg;/* negative */
	        mun = num;
	        {
	            i = 18;
	            i: {
	                for (;; i--) {
	                    mun = mun / 10;
	                    if (mun == 0)
	                        goto gotoi;
	                }
	            }
	            gotoi:
	            ;
	        }/* i */
	        // i is the position of the leftmost digit placed
	        mant = new byte[19 - i];
	        {
	            i = (19 - i) - 1;
	            i: {
	                for (;; i--) {
	                    mant[i] = (byte) -(((byte) (num % 10)));
	                    num = num / 10;
	                    if (num == 0)
	                        goto gotoi;
	                }
	            }
	            gotoi:
	            ;
	        }/* i */
	        return;
	    }
	
	    /// <summary>
	    /// Constructs a <c>BigDecimal</c> object from a <c>String</c>.
	    /// <p>
	    /// Constructs a <c>BigDecimal</c> from the parameter, which must not
	    /// be <c>null</c> and must represent a valid <i>number</i>, as
	    /// described formally in the documentation referred to <see cref="null"/>.
	    /// <p>
	    /// In summary, numbers in <c>String</c> form must have at least one
	    /// digit, may have a leading sign, may have a decimal point, and exponential
	    /// notation may be used. They follow conventional syntax, and may not
	    /// contain blanks.
	    /// <p>
	    /// Some valid strings from which a <c>BigDecimal</c> might be
	    /// constructed are:
	    /// <pre>
	    /// "0"         -- Zero
	    /// "12"         -- A whole number
	    /// "-76"         -- A signed whole number
	    /// "12.70"      -- Some decimal places
	    /// "+0.003"      -- Plus sign is allowed
	    /// "17."        -- The same as 17
	    /// ".5"       -- The same as 0.5
	    /// "4E+9"       -- Exponential notation
	    /// "0.73e-7"   -- Exponential notation
	    /// </pre>
	    /// <p>
	    /// (Exponential notation means that the number includes an optional sign and
	    /// a power of ten following an '</code>E</code>' that indicates how the
	    /// decimal point will be shifted. Thus the <c>"4E+9"</c> above is just
	    /// a short way of writing <c>4000000000</c>, and the
	    /// <c>"0.73e-7"</c> is short for <c>0.000000073</c>.)
	    /// <p>
	    /// The <c>BigDecimal</c> constructed from the String is in a standard
	    /// form, with no blanks, as though the <see cref="M:IBM.ICU.Math.BigDecimal.Add(IBM.ICU.Math.BigDecimal)"/> method had
	    /// been used to add zero to the number with unlimited precision. If the
	    /// string uses exponential notation (that is, includes an <c>e</c> or
	    /// an <c>E</c>), then the <c>BigDecimal</c> number will be
	    /// expressed in scientific notation (where the power of ten is adjusted so
	    /// there is a single non-zero digit to the left of the decimal point); in
	    /// this case if the number is zero then it will be expressed as the single
	    /// digit 0, and if non-zero it will have an exponent unless that exponent
	    /// would be 0. The exponent must fit in nine digits both before and after it
	    /// is expressed in scientific notation.
	    /// <p>
	    /// Any digits in the parameter must be decimal; that is,
	    /// <c>Character.digit(c, 10)</c> (where </code>c</code> is the
	    /// character in question) would not return -1.
	    /// </summary>
	    ///
	    /// <param name="string">The <c>String</c> to be converted.</param>
	    /// <exception cref="NumberFormatException">if the parameter is not a valid number.</exception>
	    /// @stable ICU 2.0
	
	    public BigDecimal(System.String str0) : this(str0.ToCharArray(), 0, str0.Length) {
	        return;
	    }
	
	    /* <sgml> Make a default BigDecimal object for local use. </sgml> */
	
	    private BigDecimal() : base() {
	        this.form = (byte) IBM.ICU.Math.MathContext.PLAIN;
	        return;
	    }
	
	    /* ---------------------------------------------------------------- */
	    /* Operator methods [methods which take a context parameter] */
	    /* ---------------------------------------------------------------- */
	
	    /// <summary>
	    /// Returns a plain <c>BigDecimal</c> whose value is the absolute value
	    /// of this <c>BigDecimal</c>.
	    /// <p>
	    /// The same as <see cref="M:IBM.ICU.Math.BigDecimal.Abs(IBM.ICU.Math.MathContext)"/>, where the context is
	    /// <c>new MathContext(0, MathContext.PLAIN)</c>.
	    /// <p>
	    /// The length of the decimal part (the scale) of the result will be
	    /// <c>this.scale()</c>
	    /// </summary>
	    ///
	    /// <returns>A <c>BigDecimal</c> whose value is the absolute value of
	    /// this <c>BigDecimal</c>.</returns>
	    /// @stable ICU 2.0
	
	    public IBM.ICU.Math.BigDecimal Abs() {
	        return this.Abs(plainMC);
	    }
	
	    /// <summary>
	    /// Returns a <c>BigDecimal</c> whose value is the absolute value of
	    /// this <c>BigDecimal</c>.
	    /// <p>
	    /// If the current object is zero or positive, then the same result as
	    /// invoking the <see cref="M:IBM.ICU.Math.BigDecimal.Plus(IBM.ICU.Math.MathContext)"/> method with the same parameter is
	    /// returned. Otherwise, the same result as invoking the<see cref="M:IBM.ICU.Math.BigDecimal.Negate(IBM.ICU.Math.MathContext)"/> method with the same parameter is returned.
	    /// </summary>
	    ///
	    /// <param name="set">The <c>MathContext</c> arithmetic settings.</param>
	    /// <returns>A <c>BigDecimal</c> whose value is the absolute value of
	    /// this <c>BigDecimal</c>.</returns>
	    /// @stable ICU 2.0
	
	    public IBM.ICU.Math.BigDecimal Abs(IBM.ICU.Math.MathContext set) {
	        if (this.ind == isneg)
	            return this.Negate(set);
	        return this.Plus(set);
	    }
	
	    /// <summary>
	    /// Returns a plain <c>BigDecimal</c> whose value is
	    /// <c>this+rhs</c>, using fixed point arithmetic.
	    /// <p>
	    /// The same as <see cref="M:IBM.ICU.Math.BigDecimal.Add(IBM.ICU.Math.BigDecimal, IBM.ICU.Math.MathContext)"/>, where the
	    /// <c>BigDecimal</c> is <c>rhs</c>, and the context is
	    /// <c>new MathContext(0, MathContext.PLAIN)</c>.
	    /// <p>
	    /// The length of the decimal part (the scale) of the result will be the
	    /// maximum of the scales of the two operands.
	    /// </summary>
	    ///
	    /// <param name="rhs">The <c>BigDecimal</c> for the right hand side of theaddition.</param>
	    /// <returns>A <c>BigDecimal</c> whose value is <c>this+rhs</c>,
	    /// using fixed point arithmetic.</returns>
	    /// @stable ICU 2.0
	
	    public IBM.ICU.Math.BigDecimal Add(IBM.ICU.Math.BigDecimal rhs) {
	        return this.Add(rhs, plainMC);
	    }
	
	    /// <summary>
	    /// Returns a <c>BigDecimal</c> whose value is <c>this+rhs</c>.
	    /// <p>
	    /// Implements the addition (<b><c>+</c></b>) operator (as defined in
	    /// the decimal documentation, see <see cref="null"/>), and
	    /// returns the result as a <c>BigDecimal</c> object.
	    /// </summary>
	    ///
	    /// <param name="rhs">The <c>BigDecimal</c> for the right hand side of theaddition.</param>
	    /// <param name="set">The <c>MathContext</c> arithmetic settings.</param>
	    /// <returns>A <c>BigDecimal</c> whose value is <c>this+rhs</c>.</returns>
	    /// @stable ICU 2.0
	
	    public IBM.ICU.Math.BigDecimal Add(IBM.ICU.Math.BigDecimal rhs,
	            IBM.ICU.Math.MathContext set) {
	        IBM.ICU.Math.BigDecimal lhs;
	        int reqdig;
	        IBM.ICU.Math.BigDecimal res;
	        byte[] usel;
	        int usellen;
	        byte[] user;
	        int userlen;
	        int newlen = 0;
	        int tlen = 0;
	        int mult = 0;
	        byte[] t = null;
	        int ia = 0;
	        int ib = 0;
	        int ea = 0;
	        int eb = 0;
	        byte ca = 0;
	        byte cb = 0;
	        /* determine requested digits and form */
	        if (set.lostDigits)
	            Checkdigits(rhs, set.digits);
	        lhs = this; // name for clarity and proxy
	
	        /* Quick exit for add floating 0 */
	        // plus() will optimize to return same object if possible
	        if (lhs.ind == 0)
	            if (set.form != IBM.ICU.Math.MathContext.PLAIN)
	                return rhs.Plus(set);
	        if (rhs.ind == 0)
	            if (set.form != IBM.ICU.Math.MathContext.PLAIN)
	                return lhs.Plus(set);
	
	        /* Prepare numbers (round, unless unlimited precision) */
	        reqdig = set.digits; // local copy (heavily used)
	        if (reqdig > 0) {
	            if (lhs.mant.Length > reqdig)
	                lhs = Clone(lhs).Round(set);
	            if (rhs.mant.Length > reqdig)
	                rhs = Clone(rhs).Round(set);
	            // [we could reuse the new LHS for result in this case]
	        }
	
	        res = new IBM.ICU.Math.BigDecimal(); // build result here
	
	        /*
	         * Now see how much we have to pad or truncate lhs or rhs in order to
	         * align the numbers. If one number is much larger than the other, then
	         * the smaller cannot affect the answer [but we may still need to pad
	         * with up to DIGITS trailing zeros].
	         */
	        // Note sign may be 0 if digits (reqdig) is 0
	        // usel and user will be the byte arrays passed to the adder; we'll
	        // use them on all paths except quick exits
	        usel = lhs.mant;
	        usellen = lhs.mant.Length;
	        user = rhs.mant;
	        userlen = rhs.mant.Length;
	        {
	            do {/* select */
	                if (lhs.exp == rhs.exp) {/* no padding needed */
	                    // This is the most common, and fastest, path
	                    res.exp = lhs.exp;
	                } else if (lhs.exp > rhs.exp) { // need to pad lhs and/or
	                                                // truncate rhs
	                    newlen = (usellen + lhs.exp) - rhs.exp;
	                    /*
	                     * If, after pad, lhs would be longer than rhs by digits+1
	                     * or more (and digits>0) then rhs cannot affect answer, so
	                     * we only need to pad up to a length of DIGITS+1.
	                     */
	                    if (newlen >= ((userlen + reqdig) + 1))
	                        if (reqdig > 0) {
	                            // LHS is sufficient
	                            res.mant = usel;
	                            res.exp = lhs.exp;
	                            res.ind = lhs.ind;
	                            if (usellen < reqdig) { // need 0 padding
	                                res.mant = Extend(lhs.mant, reqdig);
	                                res.exp = res.exp - ((reqdig - usellen));
	                            }
	                            return res.Finish(set, false);
	                        }
	                    // RHS may affect result
	                    res.exp = rhs.exp; // expected final exponent
	                    if (newlen > (reqdig + 1))
	                        if (reqdig > 0) {
	                            // LHS will be max; RHS truncated
	                            tlen = (newlen - reqdig) - 1; // truncation length
	                            userlen = userlen - tlen;
	                            res.exp = res.exp + tlen;
	                            newlen = reqdig + 1;
	                        }
	                    if (newlen > usellen)
	                        usellen = newlen; // need to pad LHS
	                } else { // need to pad rhs and/or truncate lhs
	                    newlen = (userlen + rhs.exp) - lhs.exp;
	                    if (newlen >= ((usellen + reqdig) + 1))
	                        if (reqdig > 0) {
	                            // RHS is sufficient
	                            res.mant = user;
	                            res.exp = rhs.exp;
	                            res.ind = rhs.ind;
	                            if (userlen < reqdig) { // need 0 padding
	                                res.mant = Extend(rhs.mant, reqdig);
	                                res.exp = res.exp - ((reqdig - userlen));
	                            }
	                            return res.Finish(set, false);
	                        }
	                    // LHS may affect result
	                    res.exp = lhs.exp; // expected final exponent
	                    if (newlen > (reqdig + 1))
	                        if (reqdig > 0) {
	                            // RHS will be max; LHS truncated
	                            tlen = (newlen - reqdig) - 1; // truncation length
	                            usellen = usellen - tlen;
	                            res.exp = res.exp + tlen;
	                            newlen = reqdig + 1;
	                        }
	                    if (newlen > userlen)
	                        userlen = newlen; // need to pad RHS
	                }
	            } while (false);
	        }/* padder */
	
	        /* OK, we have aligned mantissas. Now add or subtract. */
	        // 1998.06.27 Sign may now be 0 [e.g., 0.000] .. treat as positive
	        // 1999.05.27 Allow for 00 on lhs [is not larger than 2 on rhs]
	        // 1999.07.10 Allow for 00 on rhs [is not larger than 2 on rhs]
	        if (lhs.ind == iszero)
	            res.ind = ispos;
	        else
	            res.ind = lhs.ind; // likely sign, all paths
	        if (((lhs.ind == isneg) ? 1 : 0) == ((rhs.ind == isneg) ? 1 : 0)) // same
	                                                                          // sign,
	                                                                          // 0
	                                                                          // non-negative
	            mult = 1;
	        else {
	            do { // different signs, so subtraction is needed
	                mult = -1; // will cause subtract
	                /*
	                 * Before we can subtract we must determine which is the larger,
	                 * as our add/subtract routine only handles non-negative results
	                 * so we may need to swap the operands.
	                 */
	                {
	                    do {/* select */
	                        if (rhs.ind == iszero) {
	                            // original A bigger
	                        } else if ((usellen < userlen) | (lhs.ind == iszero)) { // original
	                                                                                // B
	                                                                                // bigger
	                            t = usel;
	                            usel = user;
	                            user = t; // swap
	                            tlen = usellen;
	                            usellen = userlen;
	                            userlen = tlen; // ..
	                            res.ind = (sbyte) -res.ind; // and set sign
	                        } else if (usellen > userlen) {
	                            // original A bigger
	                        } else {
	                            {/* logical lengths the same */// need compare
	                                /* may still need to swap: compare the strings */
	                                ia = 0;
	                                ib = 0;
	                                ea = usel.Length - 1;
	                                eb = user.Length - 1;
	                                {
	                                    compare: {
	                                        for (;;) {
	                                            if (ia <= ea)
	                                                ca = usel[ia];
	                                            else {
	                                                if (ib > eb) {/* identical */
	                                                    if (set.form != IBM.ICU.Math.MathContext.PLAIN)
	                                                        return ZERO;
	                                                    goto gotocompare;
	                                                }
	                                                ca = (byte) 0;
	                                            }
	                                            if (ib <= eb)
	                                                cb = user[ib];
	                                            else
	                                                cb = (byte) 0;
	                                            if (ca != cb) {
	                                                if (ca < cb) {/* swap needed */
	                                                    t = usel;
	                                                    usel = user;
	                                                    user = t; // swap
	                                                    tlen = usellen;
	                                                    usellen = userlen;
	                                                    userlen = tlen; // ..
	                                                    res.ind = (sbyte) -res.ind;
	                                                }
	                                                goto gotocompare;
	                                            }
	                                            /* mantissas the same, so far */
	                                            ia++;
	                                            ib++;
	                                        }
	                                    }
	                                    gotocompare:
	                                    ;
	                                }/* compare */
	                            } // lengths the same
	                        }
	                    } while (false);
	                }/* swaptest */
	            } while (false);
	        }/* signdiff */
	
	        /* here, A is > B if subtracting */
	        // add [A+B*1] or subtract [A+(B*-1)]
	        res.mant = Byteaddsub(usel, usellen, user, userlen, mult, false);
	        // [reuse possible only after chop; accounting makes not worthwhile]
	
	        // Finish() rounds before stripping leading 0's, then sets form, etc.
	        return res.Finish(set, false);
	    }
	
	    /// <summary>
	    /// Compares this <c>BigDecimal</c> to another, using unlimited
	    /// precision.
	    /// <p>
	    /// The same as <see cref="M:IBM.ICU.Math.BigDecimal.CompareTo(IBM.ICU.Math.BigDecimal, IBM.ICU.Math.MathContext)"/>, where the
	    /// <c>BigDecimal</c> is <c>rhs</c>, and the context is
	    /// <c>new MathContext(0, MathContext.PLAIN)</c>.
	    /// </summary>
	    ///
	    /// <param name="rhs">The <c>BigDecimal</c> for the right hand side of thecomparison.</param>
	    /// <returns>An <c>int</c> whose value is -1, 0, or 1 as
	    /// <c>this</c> is numerically less than, equal to, or greater
	    /// than <c>rhs</c>.</returns>
	    /// <seealso cref="M:IBM.ICU.Math.BigDecimal.CompareTo(System.Object)"/>
	    /// @stable ICU 2.0
	
	    public int CompareTo(IBM.ICU.Math.BigDecimal rhs) {
	        return this.CompareTo(rhs, plainMC);
	    }
	
	    /// <summary>
	    /// Compares this <c>BigDecimal</c> to another.
	    /// <p>
	    /// Implements numeric comparison, (as defined in the decimal documentation,
	    /// see <see cref="null"/>), and returns a result of type
	    /// <c>int</c>.
	    /// <p>
	    /// The result will be:
	    /// <table cellpadding=2>
	    /// <tr>
	    /// <td align=right><b>-1</b></td>
	    /// <td>if the current object is less than the first parameter</td>
	    /// </tr>
	    /// <tr>
	    /// <td align=right><b>0</b></td>
	    /// <td>if the current object is equal to the first parameter</td>
	    /// </tr>
	    /// <tr>
	    /// <td align=right><b>1</b></td>
	    /// <td>if the current object is greater than the first parameter.</td>
	    /// </tr>
	    /// </table>
	    /// <p>
	    /// A <see cref="M:IBM.ICU.Math.BigDecimal.CompareTo(System.Object)"/> method is also provided.
	    /// </summary>
	    ///
	    /// <param name="rhs">The <c>BigDecimal</c> for the right hand side of thecomparison.</param>
	    /// <param name="set">The <c>MathContext</c> arithmetic settings.</param>
	    /// <returns>An <c>int</c> whose value is -1, 0, or 1 as
	    /// <c>this</c> is numerically less than, equal to, or greater
	    /// than <c>rhs</c>.</returns>
	    /// <seealso cref="M:IBM.ICU.Math.BigDecimal.CompareTo(System.Object)"/>
	    /// @stable ICU 2.0
	
	    public int CompareTo(IBM.ICU.Math.BigDecimal rhs,
	            IBM.ICU.Math.MathContext set) {
	        int thislength = 0;
	        int i = 0;
	        IBM.ICU.Math.BigDecimal newrhs;
	        // rhs=null will raise NullPointerException, as per Comparable interface
	        if (set.lostDigits)
	            Checkdigits(rhs, set.digits);
	        // [add will recheck in slowpath cases .. but would report -rhs]
	        if ((this.ind == rhs.ind) & (this.exp == rhs.exp)) {
	            /* sign & exponent the same [very common] */
	            thislength = this.mant.Length;
	            if (thislength < rhs.mant.Length)
	                return (sbyte) -this.ind;
	            if (thislength > rhs.mant.Length)
	                return this.ind;
	            /*
	             * lengths are the same; we can do a straight mantissa compare
	             * unless maybe rounding [rounding is very unusual]
	             */
	            if ((thislength <= set.digits) | (set.digits == 0)) {
	                {
	                    int _6 = thislength;
	                    i = 0;
	                    for (; _6 > 0; _6--, i++) {
	                        if (this.mant[i] < rhs.mant[i])
	                            return (sbyte) -this.ind;
	                        if (this.mant[i] > rhs.mant[i])
	                            return this.ind;
	                    }
	                }/* i */
	                return 0; // identical
	            }
	            /* drop through for full comparison */
	        } else {
	            /* More fastpaths possible */
	            if (this.ind < rhs.ind)
	                return -1;
	            if (this.ind > rhs.ind)
	                return 1;
	        }
	        /* carry out a subtract to make the comparison */
	        newrhs = Clone(rhs); // safe copy
	        newrhs.ind = (sbyte) -newrhs.ind; // prepare to subtract
	        return this.Add(newrhs, set).ind; // add, and return sign of result
	    }
	
	    /// <summary>
	    /// Returns a plain <c>BigDecimal</c> whose value is
	    /// <code>this/rhs</code>, using fixed point arithmetic.
	    /// <p>
	    /// The same as <see cref="M:IBM.ICU.Math.BigDecimal.Divide(IBM.ICU.Math.BigDecimal, System.Int32)"/>, where the
	    /// <c>BigDecimal</c> is <c>rhs</c>, and the rounding mode is<see cref="M:IBM.ICU.Math.MathContext.ROUND_HALF_UP"/>.
	    /// The length of the decimal part (the scale) of the result will be the same
	    /// as the scale of the current object, if the latter were formatted without
	    /// exponential notation.
	    /// </summary>
	    ///
	    /// <param name="rhs">The <c>BigDecimal</c> for the right hand side of thedivision.</param>
	    /// <returns>A plain <c>BigDecimal</c> whose value is
	    /// <code>this/rhs</code>, using fixed point arithmetic.</returns>
	    /// <exception cref="ArithmeticException">if <c>rhs</c> is zero.</exception>
	    /// @stable ICU 2.0
	
	    public IBM.ICU.Math.BigDecimal Divide(IBM.ICU.Math.BigDecimal rhs) {
	        return this.Dodivide('D', rhs, plainMC, -1);
	    }
	
	    /// <summary>
	    /// Returns a plain <c>BigDecimal</c> whose value is
	    /// <code>this/rhs</code>, using fixed point arithmetic and a rounding mode.
	    /// <p>
	    /// The same as <see cref="M:IBM.ICU.Math.BigDecimal.Divide(IBM.ICU.Math.BigDecimal, System.Int32, System.Int32)"/>, where the
	    /// <c>BigDecimal</c> is <c>rhs</c>, and the second parameter is
	    /// <c>this.scale()</c>, and the third is <c>round</c>.
	    /// <p>
	    /// The length of the decimal part (the scale) of the result will therefore
	    /// be the same as the scale of the current object, if the latter were
	    /// formatted without exponential notation.
	    /// <p>
	    /// </summary>
	    ///
	    /// <param name="rhs">The <c>BigDecimal</c> for the right hand side of thedivision.</param>
	    /// <param name="round">The <c>int</c> rounding mode to be used for the division(see the <see cref="T:IBM.ICU.Math.MathContext"/> class).</param>
	    /// <returns>A plain <c>BigDecimal</c> whose value is
	    /// <code>this/rhs</code>, using fixed point arithmetic and the
	    /// specified rounding mode.</returns>
	    /// <exception cref="IllegalArgumentException">if <c>round</c> is not a valid rounding mode.</exception>
	    /// <exception cref="ArithmeticException">if <c>rhs</c> is zero.</exception>
	    /// <exception cref="ArithmeticException">if <c>round</c> is<see cref="M:IBM.ICU.Math.MathContext.ROUND_UNNECESSARY"/> and<c>this.scale()</c> is insufficient to represent theresult exactly.</exception>
	    /// @stable ICU 2.0
	
	    public IBM.ICU.Math.BigDecimal Divide(IBM.ICU.Math.BigDecimal rhs,
	            int round) {
	        IBM.ICU.Math.MathContext set;
	        set = new IBM.ICU.Math.MathContext(0,
	                IBM.ICU.Math.MathContext.PLAIN, false, round); // [checks
	                                                                   // round,
	                                                                   // too]
	        return this.Dodivide('D', rhs, set, -1); // take scale from LHS
	    }
	
	    /// <summary>
	    /// Returns a plain <c>BigDecimal</c> whose value is
	    /// <code>this/rhs</code>, using fixed point arithmetic and a given scale and
	    /// rounding mode.
	    /// <p>
	    /// The same as <see cref="M:IBM.ICU.Math.BigDecimal.Divide(IBM.ICU.Math.BigDecimal, IBM.ICU.Math.MathContext)"/>, where the
	    /// <c>BigDecimal</c> is <c>rhs</c>,
	    /// <c>new MathContext(0, MathContext.PLAIN, false, round)</c>, except
	    /// that the length of the decimal part (the scale) to be used for the result
	    /// is explicit rather than being taken from <c>this</c>.
	    /// <p>
	    /// The length of the decimal part (the scale) of the result will be the same
	    /// as the scale of the current object, if the latter were formatted without
	    /// exponential notation.
	    /// <p>
	    /// </summary>
	    ///
	    /// <param name="rhs">The <c>BigDecimal</c> for the right hand side of thedivision.</param>
	    /// <param name="scale">The <c>int</c> scale to be used for the result.</param>
	    /// <param name="round">The <c>int</c> rounding mode to be used for the division(see the <see cref="T:IBM.ICU.Math.MathContext"/> class).</param>
	    /// <returns>A plain <c>BigDecimal</c> whose value is
	    /// <code>this/rhs</code>, using fixed point arithmetic and the
	    /// specified rounding mode.</returns>
	    /// <exception cref="IllegalArgumentException">if <c>round</c> is not a valid rounding mode.</exception>
	    /// <exception cref="ArithmeticException">if <c>rhs</c> is zero.</exception>
	    /// <exception cref="ArithmeticException">if <c>scale</c> is negative.</exception>
	    /// <exception cref="ArithmeticException">if <c>round</c> is<see cref="M:IBM.ICU.Math.MathContext.ROUND_UNNECESSARY"/> and <c>scale</c>is insufficient to represent the result exactly.</exception>
	    /// @stable ICU 2.0
	
	    public IBM.ICU.Math.BigDecimal Divide(IBM.ICU.Math.BigDecimal rhs,
	            int scale, int round) {
	        IBM.ICU.Math.MathContext set;
	        if (scale < 0)
	            throw new System.ArithmeticException("Negative scale:" + " "
	                    + scale);
	        set = new IBM.ICU.Math.MathContext(0,
	                IBM.ICU.Math.MathContext.PLAIN, false, round); // [checks
	                                                                   // round]
	        return this.Dodivide('D', rhs, set, scale);
	    }
	
	    /// <summary>
	    /// Returns a <c>BigDecimal</c> whose value is <code>this/rhs</code>.
	    /// <p>
	    /// Implements the division (<b><code>/</code></b>) operator (as defined in
	    /// the decimal documentation, see <see cref="null"/>), and
	    /// returns the result as a <c>BigDecimal</c> object.
	    /// </summary>
	    ///
	    /// <param name="rhs">The <c>BigDecimal</c> for the right hand side of thedivision.</param>
	    /// <param name="set">The <c>MathContext</c> arithmetic settings.</param>
	    /// <returns>A <c>BigDecimal</c> whose value is <code>this/rhs</code>.</returns>
	    /// <exception cref="ArithmeticException">if <c>rhs</c> is zero.</exception>
	    /// @stable ICU 2.0
	
	    public IBM.ICU.Math.BigDecimal Divide(IBM.ICU.Math.BigDecimal rhs,
	            IBM.ICU.Math.MathContext set) {
	        return this.Dodivide('D', rhs, set, -1);
	    }
	
	    /// <summary>
	    /// Returns a plain <c>BigDecimal</c> whose value is the integer part
	    /// of <code>this/rhs</code>.
	    /// <p>
	    /// The same as <see cref="M:IBM.ICU.Math.BigDecimal.DivideInteger(IBM.ICU.Math.BigDecimal, IBM.ICU.Math.MathContext)"/>, where the
	    /// <c>BigDecimal</c> is <c>rhs</c>, and the context is
	    /// <c>new MathContext(0, MathContext.PLAIN)</c>.
	    /// </summary>
	    ///
	    /// <param name="rhs">The <c>BigDecimal</c> for the right hand side of theinteger division.</param>
	    /// <returns>A <c>BigDecimal</c> whose value is the integer part of
	    /// <code>this/rhs</code>.</returns>
	    /// <exception cref="ArithmeticException">if <c>rhs</c> is zero.</exception>
	    /// @stable ICU 2.0
	
	    public IBM.ICU.Math.BigDecimal DivideInteger(
	            IBM.ICU.Math.BigDecimal rhs) {
	        // scale 0 to drop .000 when plain
	        return this.Dodivide('I', rhs, plainMC, 0);
	    }
	
	    /// <summary>
	    /// Returns a <c>BigDecimal</c> whose value is the integer part of
	    /// <code>this/rhs</code>.
	    /// <p>
	    /// Implements the integer division operator (as defined in the decimal
	    /// documentation, see <see cref="null"/>), and returns the
	    /// result as a <c>BigDecimal</c> object.
	    /// </summary>
	    ///
	    /// <param name="rhs">The <c>BigDecimal</c> for the right hand side of theinteger division.</param>
	    /// <param name="set">The <c>MathContext</c> arithmetic settings.</param>
	    /// <returns>A <c>BigDecimal</c> whose value is the integer part of
	    /// <code>this/rhs</code>.</returns>
	    /// <exception cref="ArithmeticException">if <c>rhs</c> is zero.</exception>
	    /// <exception cref="ArithmeticException">if the result will not fit in the number of digits specifiedfor the context.</exception>
	    /// @stable ICU 2.0
	
	    public IBM.ICU.Math.BigDecimal DivideInteger(
	            IBM.ICU.Math.BigDecimal rhs, IBM.ICU.Math.MathContext set) {
	        // scale 0 to drop .000 when plain
	        return this.Dodivide('I', rhs, set, 0);
	    }
	
	    /// <summary>
	    /// Returns a plain <c>BigDecimal</c> whose value is the maximum of
	    /// <c>this</c> and <c>rhs</c>.
	    /// <p>
	    /// The same as <see cref="M:IBM.ICU.Math.BigDecimal.Max(IBM.ICU.Math.BigDecimal, IBM.ICU.Math.MathContext)"/>, where the
	    /// <c>BigDecimal</c> is <c>rhs</c>, and the context is
	    /// <c>new MathContext(0, MathContext.PLAIN)</c>.
	    /// </summary>
	    ///
	    /// <param name="rhs">The <c>BigDecimal</c> for the right hand side of thecomparison.</param>
	    /// <returns>A <c>BigDecimal</c> whose value is the maximum of
	    /// <c>this</c> and <c>rhs</c>.</returns>
	    /// @stable ICU 2.0
	
	    public IBM.ICU.Math.BigDecimal Max(IBM.ICU.Math.BigDecimal rhs) {
	        return this.Max(rhs, plainMC);
	    }
	
	    /// <summary>
	    /// Returns a <c>BigDecimal</c> whose value is the maximum of
	    /// <c>this</c> and <c>rhs</c>.
	    /// <p>
	    /// Returns the larger of the current object and the first parameter.
	    /// <p>
	    /// If calling the <see cref="M:IBM.ICU.Math.BigDecimal.CompareTo(IBM.ICU.Math.BigDecimal, IBM.ICU.Math.MathContext)"/> method with
	    /// the same parameters would return <c>1</c> or <c>0</c>, then
	    /// the result of calling the <see cref="M:IBM.ICU.Math.BigDecimal.Plus(IBM.ICU.Math.MathContext)"/> method on the
	    /// current object (using the same <c>MathContext</c> parameter) is
	    /// returned. Otherwise, the result of calling the <see cref="M:IBM.ICU.Math.BigDecimal.Plus(IBM.ICU.Math.MathContext)"/>method on the first parameter object (using the same
	    /// <c>MathContext</c> parameter) is returned.
	    /// </summary>
	    ///
	    /// <param name="rhs">The <c>BigDecimal</c> for the right hand side of thecomparison.</param>
	    /// <param name="set">The <c>MathContext</c> arithmetic settings.</param>
	    /// <returns>A <c>BigDecimal</c> whose value is the maximum of
	    /// <c>this</c> and <c>rhs</c>.</returns>
	    /// @stable ICU 2.0
	
	    public IBM.ICU.Math.BigDecimal Max(IBM.ICU.Math.BigDecimal rhs,
	            IBM.ICU.Math.MathContext set) {
	        if ((this.CompareTo(rhs, set)) >= 0)
	            return this.Plus(set);
	        else
	            return rhs.Plus(set);
	    }
	
	    /// <summary>
	    /// Returns a plain <c>BigDecimal</c> whose value is the minimum of
	    /// <c>this</c> and <c>rhs</c>.
	    /// <p>
	    /// The same as <see cref="M:IBM.ICU.Math.BigDecimal.Min(IBM.ICU.Math.BigDecimal, IBM.ICU.Math.MathContext)"/>, where the
	    /// <c>BigDecimal</c> is <c>rhs</c>, and the context is
	    /// <c>new MathContext(0, MathContext.PLAIN)</c>.
	    /// </summary>
	    ///
	    /// <param name="rhs">The <c>BigDecimal</c> for the right hand side of thecomparison.</param>
	    /// <returns>A <c>BigDecimal</c> whose value is the minimum of
	    /// <c>this</c> and <c>rhs</c>.</returns>
	    /// @stable ICU 2.0
	
	    public IBM.ICU.Math.BigDecimal Min(IBM.ICU.Math.BigDecimal rhs) {
	        return this.Min(rhs, plainMC);
	    }
	
	    /// <summary>
	    /// Returns a <c>BigDecimal</c> whose value is the minimum of
	    /// <c>this</c> and <c>rhs</c>.
	    /// <p>
	    /// Returns the smaller of the current object and the first parameter.
	    /// <p>
	    /// If calling the <see cref="M:IBM.ICU.Math.BigDecimal.CompareTo(IBM.ICU.Math.BigDecimal, IBM.ICU.Math.MathContext)"/> method with
	    /// the same parameters would return <c>-1</c> or <c>0</c>, then
	    /// the result of calling the <see cref="M:IBM.ICU.Math.BigDecimal.Plus(IBM.ICU.Math.MathContext)"/> method on the
	    /// current object (using the same <c>MathContext</c> parameter) is
	    /// returned. Otherwise, the result of calling the <see cref="M:IBM.ICU.Math.BigDecimal.Plus(IBM.ICU.Math.MathContext)"/>method on the first parameter object (using the same
	    /// <c>MathContext</c> parameter) is returned.
	    /// </summary>
	    ///
	    /// <param name="rhs">The <c>BigDecimal</c> for the right hand side of thecomparison.</param>
	    /// <param name="set">The <c>MathContext</c> arithmetic settings.</param>
	    /// <returns>A <c>BigDecimal</c> whose value is the minimum of
	    /// <c>this</c> and <c>rhs</c>.</returns>
	    /// @stable ICU 2.0
	
	    public IBM.ICU.Math.BigDecimal Min(IBM.ICU.Math.BigDecimal rhs,
	            IBM.ICU.Math.MathContext set) {
	        if ((this.CompareTo(rhs, set)) <= 0)
	            return this.Plus(set);
	        else
	            return rhs.Plus(set);
	    }
	
	    /// <summary>
	    /// Returns a plain <c>BigDecimal</c> whose value is
	    /// <code>this///rhs</code>, using fixed point arithmetic.
	    /// <p>
	    /// The same as <see cref="M:IBM.ICU.Math.BigDecimal.Add(IBM.ICU.Math.BigDecimal, IBM.ICU.Math.MathContext)"/>, where the
	    /// <c>BigDecimal</c> is <c>rhs</c>, and the context is
	    /// <c>new MathContext(0, MathContext.PLAIN)</c>.
	    /// <p>
	    /// The length of the decimal part (the scale) of the result will be the sum
	    /// of the scales of the operands, if they were formatted without exponential
	    /// notation.
	    /// </summary>
	    ///
	    /// <param name="rhs">The <c>BigDecimal</c> for the right hand side of themultiplication.</param>
	    /// <returns>A <c>BigDecimal</c> whose value is <code>this///rhs</code>,
	    /// using fixed point arithmetic.</returns>
	    /// @stable ICU 2.0
	
	    public IBM.ICU.Math.BigDecimal Multiply(IBM.ICU.Math.BigDecimal rhs) {
	        return this.Multiply(rhs, plainMC);
	    }
	
	    /// <summary>
	    /// Returns a <c>BigDecimal</c> whose value is <code>this///rhs</code>.
	    /// <p>
	    /// Implements the multiplication (<b><code>///</code></b>) operator (as
	    /// defined in the decimal documentation, see <see cref="null"/>), and returns the result as a <c>BigDecimal</c> object.
	    /// </summary>
	    ///
	    /// <param name="rhs">The <c>BigDecimal</c> for the right hand side of themultiplication.</param>
	    /// <param name="set">The <c>MathContext</c> arithmetic settings.</param>
	    /// <returns>A <c>BigDecimal</c> whose value is <code>this///rhs</code>.</returns>
	    /// @stable ICU 2.0
	
	    public IBM.ICU.Math.BigDecimal Multiply(
	            IBM.ICU.Math.BigDecimal rhs, IBM.ICU.Math.MathContext set) {
	        IBM.ICU.Math.BigDecimal lhs;
	        int padding;
	        int reqdig;
	        byte[] multer = null;
	        byte[] multand = null;
	        int multandlen;
	        int acclen = 0;
	        IBM.ICU.Math.BigDecimal res;
	        byte[] acc;
	        int n = 0;
	        byte mult = 0;
	        if (set.lostDigits)
	            Checkdigits(rhs, set.digits);
	        lhs = this; // name for clarity and proxy
	
	        /* Prepare numbers (truncate, unless unlimited precision) */
	        padding = 0; // trailing 0's to add
	        reqdig = set.digits; // local copy
	        if (reqdig > 0) {
	            if (lhs.mant.Length > reqdig)
	                lhs = Clone(lhs).Round(set);
	            if (rhs.mant.Length > reqdig)
	                rhs = Clone(rhs).Round(set);
	            // [we could reuse the new LHS for result in this case]
	        } else {/* unlimited */
	            // fixed point arithmetic will want every trailing 0; we add these
	            // after the calculation rather than before, for speed.
	            if (lhs.exp > 0)
	                padding = padding + lhs.exp;
	            if (rhs.exp > 0)
	                padding = padding + rhs.exp;
	        }
	
	        // For best speed, as in DMSRCN, we use the shorter number as the
	        // multiplier and the longer as the multiplicand.
	        // 1999.12.22: We used to special case when the result would fit in
	        // a long, but with Java 1.3 this gave no advantage.
	        if (lhs.mant.Length < rhs.mant.Length) {
	            multer = lhs.mant;
	            multand = rhs.mant;
	        } else {
	            multer = rhs.mant;
	            multand = lhs.mant;
	        }
	
	        /* Calculate how long result byte array will be */
	        multandlen = (multer.Length + multand.Length) - 1; // effective length
	        // optimize for 75% of the cases where a carry is expected...
	        if ((multer[0] * multand[0]) > 9)
	            acclen = multandlen + 1;
	        else
	            acclen = multandlen;
	
	        /* Now the main long multiplication loop */
	        res = new IBM.ICU.Math.BigDecimal(); // where we'll build result
	        acc = new byte[acclen]; // accumulator, all zeros
	        // 1998.07.01: calculate from left to right so that accumulator goes
	        // to likely final length on first addition; this avoids a one-digit
	        // extension (and object allocation) each time around the loop.
	        // Initial number therefore has virtual zeros added to right.
	        {
	            int _7 = multer.Length;
	            n = 0;
	            for (; _7 > 0; _7--, n++) {
	                mult = multer[n];
	                if (mult != 0) { // [optimization]
	                                 // accumulate [accumulator is reusable array]
	                    acc = Byteaddsub(acc, acc.Length, multand, multandlen,
	                            mult, true);
	                }
	                // divide multiplicand by 10 for next digit to right
	                multandlen--; // 'virtual length'
	            }
	        }/* n */
	
	        res.ind = (sbyte) (lhs.ind * rhs.ind); // final sign
	        res.exp = (lhs.exp + rhs.exp) - padding; // final exponent
	        // [overflow is checked by finish]
	
	        /* add trailing zeros to the result, if necessary */
	        if (padding == 0)
	            res.mant = acc;
	        else
	            res.mant = Extend(acc, acc.Length + padding); // add trailing 0s
	        return res.Finish(set, false);
	    }
	
	    /// <summary>
	    /// Returns a plain <c>BigDecimal</c> whose value is <c>-this</c>
	    /// .
	    /// <p>
	    /// The same as <see cref="M:IBM.ICU.Math.BigDecimal.Negate(IBM.ICU.Math.MathContext)"/>, where the context is
	    /// <c>new MathContext(0, MathContext.PLAIN)</c>.
	    /// <p>
	    /// The length of the decimal part (the scale) of the result will be be
	    /// <c>this.scale()</c>
	    /// </summary>
	    ///
	    /// <returns>A <c>BigDecimal</c> whose value is <c>-this</c>.</returns>
	    /// @stable ICU 2.0
	
	    public IBM.ICU.Math.BigDecimal Negate() {
	        return this.Negate(plainMC);
	    }
	
	    /// <summary>
	    /// Returns a <c>BigDecimal</c> whose value is <c>-this</c>.
	    /// <p>
	    /// Implements the negation (Prefix <b><c>-</c></b>) operator (as
	    /// defined in the decimal documentation, see <see cref="null"/>), and returns the result as a <c>BigDecimal</c> object.
	    /// </summary>
	    ///
	    /// <param name="set">The <c>MathContext</c> arithmetic settings.</param>
	    /// <returns>A <c>BigDecimal</c> whose value is <c>-this</c>.</returns>
	    /// @stable ICU 2.0
	
	    public IBM.ICU.Math.BigDecimal Negate(IBM.ICU.Math.MathContext set) {
	        IBM.ICU.Math.BigDecimal res;
	        // Originally called minus(), changed to matched Java precedents
	        // This simply clones, flips the sign, and possibly rounds
	        if (set.lostDigits)
	            Checkdigits((IBM.ICU.Math.BigDecimal) null, set.digits);
	        res = Clone(this); // safe copy
	        res.ind = (sbyte) -res.ind;
	        return res.Finish(set, false);
	    }
	
	    /// <summary>
	    /// Returns a plain <c>BigDecimal</c> whose value is <c>+this</c>
	    /// . Note that <c>this</c> is not necessarily a plain
	    /// <c>BigDecimal</c>, but the result will always be.
	    /// <p>
	    /// The same as <see cref="M:IBM.ICU.Math.BigDecimal.Plus(IBM.ICU.Math.MathContext)"/>, where the context is
	    /// <c>new MathContext(0, MathContext.PLAIN)</c>.
	    /// <p>
	    /// The length of the decimal part (the scale) of the result will be be
	    /// <c>this.scale()</c>
	    /// </summary>
	    ///
	    /// <returns>A <c>BigDecimal</c> whose value is <c>+this</c>.</returns>
	    /// @stable ICU 2.0
	
	    public IBM.ICU.Math.BigDecimal Plus() {
	        return this.Plus(plainMC);
	    }
	
	    /// <summary>
	    /// Returns a <c>BigDecimal</c> whose value is <c>+this</c>.
	    /// <p>
	    /// Implements the plus (Prefix <b><c>+</c></b>) operator (as defined
	    /// in the decimal documentation, see <see cref="null"/>), and
	    /// returns the result as a <c>BigDecimal</c> object.
	    /// <p>
	    /// This method is useful for rounding or otherwise applying a context to a
	    /// decimal value.
	    /// </summary>
	    ///
	    /// <param name="set">The <c>MathContext</c> arithmetic settings.</param>
	    /// <returns>A <c>BigDecimal</c> whose value is <c>+this</c>.</returns>
	    /// @stable ICU 2.0
	
	    public IBM.ICU.Math.BigDecimal Plus(IBM.ICU.Math.MathContext set) {
	        // This clones and forces the result to the new settings
	        // May return same object
	        if (set.lostDigits)
	            Checkdigits((IBM.ICU.Math.BigDecimal) null, set.digits);
	        // Optimization: returns same object for some common cases
	        if (set.form == IBM.ICU.Math.MathContext.PLAIN)
	            if (this.form == IBM.ICU.Math.MathContext.PLAIN) {
	                if (this.mant.Length <= set.digits)
	                    return this;
	                if (set.digits == 0)
	                    return this;
	            }
	        return Clone(this).Finish(set, false);
	    }
	
	    /// <summary>
	    /// Returns a plain <c>BigDecimal</c> whose value is
	    /// <code>this//////rhs</code>, using fixed point arithmetic.
	    /// <p>
	    /// The same as <see cref="M:IBM.ICU.Math.BigDecimal.Pow(IBM.ICU.Math.BigDecimal, IBM.ICU.Math.MathContext)"/>, where the
	    /// <c>BigDecimal</c> is <c>rhs</c>, and the context is
	    /// <c>new MathContext(0, MathContext.PLAIN)</c>.
	    /// <p>
	    /// The parameter is the power to which the <c>this</c> will be raised;
	    /// it must be in the range 0 through 999999999, and must have a decimal part
	    /// of zero. Note that these restrictions may be removed in the future, so
	    /// they should not be used as a test for a whole number.
	    /// <p>
	    /// In addition, the power must not be negative, as no
	    /// <c>MathContext</c> is used and so the result would then always be
	    /// 0.
	    /// </summary>
	    ///
	    /// <param name="rhs">The <c>BigDecimal</c> for the right hand side of theoperation (the power).</param>
	    /// <returns>A <c>BigDecimal</c> whose value is <code>this//////rhs</code>,
	    /// using fixed point arithmetic.</returns>
	    /// <exception cref="ArithmeticException">if <c>rhs</c> is out of range or is not a whole number.</exception>
	    /// @stable ICU 2.0
	
	    public IBM.ICU.Math.BigDecimal Pow(IBM.ICU.Math.BigDecimal rhs) {
	        return this.Pow(rhs, plainMC);
	    }
	
	    // The name for this method is inherited from the precedent set by the
	    // BigInteger and Math classes.
	
	    /// <summary>
	    /// Returns a <c>BigDecimal</c> whose value is <code>this//////rhs</code>.
	    /// <p>
	    /// Implements the power (<b><code>//////</code></b>) operator (as defined in the
	    /// decimal documentation, see <see cref="null"/>), and returns
	    /// the result as a <c>BigDecimal</c> object.
	    /// <p>
	    /// The first parameter is the power to which the <c>this</c> will be
	    /// raised; it must be in the range -999999999 through 999999999, and must
	    /// have a decimal part of zero. Note that these restrictions may be removed
	    /// in the future, so they should not be used as a test for a whole number.
	    /// <p>
	    /// If the <c>digits</c> setting of the <c>MathContext</c>
	    /// parameter is 0, the power must be zero or positive.
	    /// </summary>
	    ///
	    /// <param name="rhs">The <c>BigDecimal</c> for the right hand side of theoperation (the power).</param>
	    /// <param name="set">The <c>MathContext</c> arithmetic settings.</param>
	    /// <returns>A <c>BigDecimal</c> whose value is <code>this//////rhs</code>.</returns>
	    /// <exception cref="ArithmeticException">if <c>rhs</c> is out of range or is not a whole number.</exception>
	    /// @stable ICU 2.0
	
	    public IBM.ICU.Math.BigDecimal Pow(IBM.ICU.Math.BigDecimal rhs,
	            IBM.ICU.Math.MathContext set) {
	        int n;
	        IBM.ICU.Math.BigDecimal lhs;
	        int reqdig;
	        int workdigits = 0;
	        int L = 0;
	        IBM.ICU.Math.MathContext workset;
	        IBM.ICU.Math.BigDecimal res;
	        bool seenbit;
	        int i = 0;
	        if (set.lostDigits)
	            Checkdigits(rhs, set.digits);
	        n = rhs.Intcheck(MinArg, MaxArg); // check RHS by the rules
	        lhs = this; // clarified name
	
	        reqdig = set.digits; // local copy (heavily used)
	        if (reqdig == 0) {
	            if (rhs.ind == isneg)
	                throw new System.ArithmeticException("Negative power:" + " "
	                        + rhs.ToString());
	            workdigits = 0;
	        } else {/* non-0 digits */
	            if ((rhs.mant.Length + rhs.exp) > reqdig)
	                throw new System.ArithmeticException("Too many digits:"
	                        + " " + rhs.ToString());
	
	            /* Round the lhs to DIGITS if need be */
	            if (lhs.mant.Length > reqdig)
	                lhs = Clone(lhs).Round(set);
	
	            /* L for precision calculation [see ANSI X3.274-1996] */
	            L = rhs.mant.Length + rhs.exp; // length without decimal zeros/exp
	            workdigits = (reqdig + L) + 1; // calculate the working DIGITS
	        }
	
	        /* Create a copy of set for working settings */
	        // Note: no need to check for lostDigits again.
	        // 1999.07.17 Note: this construction must follow RHS check
	        workset = new IBM.ICU.Math.MathContext(workdigits, set.form, false,
	                set.roundingMode);
	
	        res = ONE; // accumulator
	        if (n == 0)
	            return res; // x**0 == 1
	        if (n < 0)
	            n = (int) -n; // [rhs.ind records the sign]
	        seenbit = false; // set once we've seen a 1-bit
	        {
	            i = 1;
	            i: {
	                for (;; i++) { // for each bit [top bit ignored]
	                    n = n + n; // shift left 1 bit
	                    if (n < 0) { // top bit is set
	                        seenbit = true; // OK, we're off
	                        res = res.Multiply(lhs, workset); // acc=acc*x
	                    }
	                    if (i == 31)
	                     goto gotoi;
	                    if ((!seenbit))
	                     goto i;
	                    res = res.Multiply(res, workset); // acc=acc*acc [square]
	                }
	            }
	            gotoi:
	            ;
	        }/* i */// 32 bits
	        if (rhs.ind < 0) // was a **-n [hence digits>0]
	            res = ONE.Divide(res, workset); // .. so acc=1/acc
	        return res.Finish(set, true); // round and strip [original digits]
	    }
	
	    /// <summary>
	    /// Returns a plain <c>BigDecimal</c> whose value is the remainder of
	    /// <code>this/rhs</code>, using fixed point arithmetic.
	    /// <p>
	    /// The same as <see cref="M:IBM.ICU.Math.BigDecimal.Remainder(IBM.ICU.Math.BigDecimal, IBM.ICU.Math.MathContext)"/>, where the
	    /// <c>BigDecimal</c> is <c>rhs</c>, and the context is
	    /// <c>new MathContext(0, MathContext.PLAIN)</c>.
	    /// <p>
	    /// This is not the modulo operator -- the result may be negative.
	    /// </summary>
	    ///
	    /// <param name="rhs">The <c>BigDecimal</c> for the right hand side of theremainder operation.</param>
	    /// <returns>A <c>BigDecimal</c> whose value is the remainder of
	    /// <code>this/rhs</code>, using fixed point arithmetic.</returns>
	    /// <exception cref="ArithmeticException">if <c>rhs</c> is zero.</exception>
	    /// @stable ICU 2.0
	
	    public IBM.ICU.Math.BigDecimal Remainder(IBM.ICU.Math.BigDecimal rhs) {
	        return this.Dodivide('R', rhs, plainMC, -1);
	    }
	
	    /// <summary>
	    /// Returns a <c>BigDecimal</c> whose value is the remainder of
	    /// <code>this/rhs</code>.
	    /// <p>
	    /// Implements the remainder operator (as defined in the decimal
	    /// documentation, see <see cref="null"/>), and returns the
	    /// result as a <c>BigDecimal</c> object.
	    /// <p>
	    /// This is not the modulo operator -- the result may be negative.
	    /// </summary>
	    ///
	    /// <param name="rhs">The <c>BigDecimal</c> for the right hand side of theremainder operation.</param>
	    /// <param name="set">The <c>MathContext</c> arithmetic settings.</param>
	    /// <returns>A <c>BigDecimal</c> whose value is the remainder of
	    /// <c>this+rhs</c>.</returns>
	    /// <exception cref="ArithmeticException">if <c>rhs</c> is zero.</exception>
	    /// <exception cref="ArithmeticException">if the integer part of the result will not fit in the numberof digits specified for the context.</exception>
	    /// @stable ICU 2.0
	
	    public IBM.ICU.Math.BigDecimal Remainder(
	            IBM.ICU.Math.BigDecimal rhs, IBM.ICU.Math.MathContext set) {
	        return this.Dodivide('R', rhs, set, -1);
	    }
	
	    /// <summary>
	    /// Returns a plain <c>BigDecimal</c> whose value is
	    /// <c>this-rhs</c>, using fixed point arithmetic.
	    /// <p>
	    /// The same as <see cref="M:IBM.ICU.Math.BigDecimal.Subtract(IBM.ICU.Math.BigDecimal, IBM.ICU.Math.MathContext)"/>, where the
	    /// <c>BigDecimal</c> is <c>rhs</c>, and the context is
	    /// <c>new MathContext(0, MathContext.PLAIN)</c>.
	    /// <p>
	    /// The length of the decimal part (the scale) of the result will be the
	    /// maximum of the scales of the two operands.
	    /// </summary>
	    ///
	    /// <param name="rhs">The <c>BigDecimal</c> for the right hand side of thesubtraction.</param>
	    /// <returns>A <c>BigDecimal</c> whose value is <c>this-rhs</c>,
	    /// using fixed point arithmetic.</returns>
	    /// @stable ICU 2.0
	
	    public IBM.ICU.Math.BigDecimal Subtract(IBM.ICU.Math.BigDecimal rhs) {
	        return this.Subtract(rhs, plainMC);
	    }
	
	    /// <summary>
	    /// Returns a <c>BigDecimal</c> whose value is <c>this-rhs</c>.
	    /// <p>
	    /// Implements the subtraction (<b><c>-</c></b>) operator (as defined
	    /// in the decimal documentation, see <see cref="null"/>), and
	    /// returns the result as a <c>BigDecimal</c> object.
	    /// </summary>
	    ///
	    /// <param name="rhs">The <c>BigDecimal</c> for the right hand side of thesubtraction.</param>
	    /// <param name="set">The <c>MathContext</c> arithmetic settings.</param>
	    /// <returns>A <c>BigDecimal</c> whose value is <c>this-rhs</c>.</returns>
	    /// @stable ICU 2.0
	
	    public IBM.ICU.Math.BigDecimal Subtract(
	            IBM.ICU.Math.BigDecimal rhs, IBM.ICU.Math.MathContext set) {
	        IBM.ICU.Math.BigDecimal newrhs;
	        if (set.lostDigits)
	            Checkdigits(rhs, set.digits);
	        // [add will recheck .. but would report -rhs]
	        /* carry out the subtraction */
	        // we could fastpath -0, but it is too rare.
	        newrhs = Clone(rhs); // safe copy
	        newrhs.ind = (sbyte) -newrhs.ind; // prepare to subtract
	        return this.Add(newrhs, set); // arithmetic
	    }
	
	    /* ---------------------------------------------------------------- */
	    /* Other methods */
	    /* ---------------------------------------------------------------- */
	
	    /// <summary>
	    /// Converts this <c>BigDecimal</c> to a <c>byte</c>. If the
	    /// <c>BigDecimal</c> has a non-zero decimal part or is out of the
	    /// possible range for a <c>byte</c> (8-bit signed integer) result then
	    /// an <c>ArithmeticException</c> is thrown.
	    /// </summary>
	    ///
	    /// <returns>A <c>byte</c> equal in value to <c>this</c>.</returns>
	    /// <exception cref="ArithmeticException">if <c>this</c> has a non-zero decimal part, or will notfit in a <c>byte</c>.</exception>
	    /// @stable ICU 2.0
	
	    public byte ByteValueExact() {
	        int num;
	        num = this.IntValueExact(); // will check decimal part too
	        if ((num > 127) | (num < (-128)))
	            throw new System.ArithmeticException("Conversion overflow:"
	                    + " " + this.ToString());
	        return (byte) num;
	    }
	
	    /// <summary>
	    /// Compares this <c>BigDecimal</c> with the value of the parameter.
	    /// <p>
	    /// If the parameter is <c>null</c>, or is not an instance of the
	    /// <c>BigDecimal</c> type, an exception is thrown. Otherwise, the
	    /// parameter is cast to type <c>BigDecimal</c> and the result of the<see cref="M:IBM.ICU.Math.BigDecimal.CompareTo(IBM.ICU.Math.BigDecimal)"/> method, using the cast parameter, is
	    /// returned.
	    /// <p>
	    /// The <see cref="M:IBM.ICU.Math.BigDecimal.CompareTo(IBM.ICU.Math.BigDecimal, IBM.ICU.Math.MathContext)"/> method should be used
	    /// when a <c>MathContext</c> is needed for the comparison.
	    /// </summary>
	    ///
	    /// <param name="rhsobj">The <c>Object</c> for the right hand side of thecomparison.</param>
	    /// <returns>An <c>int</c> whose value is -1, 0, or 1 as
	    /// <c>this</c> is numerically less than, equal to, or greater
	    /// than <c>rhs</c>.</returns>
	    /// <exception cref="ClassCastException">if <c>rhs</c> cannot be cast to a<c>BigDecimal</c> object.</exception>
	    /// <seealso cref="M:IBM.ICU.Math.BigDecimal.CompareTo(IBM.ICU.Math.BigDecimal)"/>
	    /// @stable ICU 2.0
	
	    public virtual int CompareTo(System.Object rhsobj) {
	        // the cast in the next line will raise ClassCastException if necessary
	        return CompareTo((IBM.ICU.Math.BigDecimal) rhsobj, plainMC);
	    }
	
	    /// <summary>
	    /// Converts this <c>BigDecimal</c> to a <c>double</c>. If the
	    /// <c>BigDecimal</c> is out of the possible range for a
	    /// <c>double</c> (64-bit signed floating point) result then an
	    /// <c>ArithmeticException</c> is thrown.
	    /// <p>
	    /// The double produced is identical to result of expressing the
	    /// <c>BigDecimal</c> as a <c>String</c> and then converting it
	    /// using the <c>Double(String)</c> constructor; this can result in
	    /// values of <c>Double.NEGATIVE_INFINITY</c> or
	    /// <c>Double.POSITIVE_INFINITY</c>.
	    /// </summary>
	    ///
	    /// <returns>A <c>double</c> corresponding to <c>this</c>.</returns>
	    /// @stable ICU 2.0
	
	    public /*override*/ double DoubleValue() {
	        // We go via a String [as does BigDecimal in JDK 1.2]
	        // Next line could possibly raise NumberFormatException
	        return ((Double )Double.Parse(this.ToString(),ILOG.J2CsMapping.Util.NumberFormatProvider.NumberFormat));
	    }
	
	    /// <summary>
	    /// Compares this <c>BigDecimal</c> with <c>rhs</c> for equality.
	    /// <p>
	    /// If the parameter is <c>null</c>, or is not an instance of the
	    /// BigDecimal type, or is not exactly equal to the current
	    /// <c>BigDecimal</c> object, then <i>false</i> is returned. Otherwise,
	    /// <i>true</i> is returned.
	    /// <p>
	    /// "Exactly equal", here, means that the <c>String</c> representations
	    /// of the <c>BigDecimal</c> numbers are identical (they have the same
	    /// characters in the same sequence).
	    /// <p>
	    /// The <see cref="M:IBM.ICU.Math.BigDecimal.CompareTo(IBM.ICU.Math.BigDecimal, IBM.ICU.Math.MathContext)"/> method should be used for
	    /// more general comparisons.
	    /// </summary>
	    ///
	    /// <param name="obj">The <c>Object</c> for the right hand side of thecomparison.</param>
	    /// <returns>A <c>boolean</c> whose value <i>true</i> if and only if the
	    /// operands have identical string representations.</returns>
	    /// <exception cref="ClassCastException">if <c>rhs</c> cannot be cast to a<c>BigDecimal</c> object.</exception>
	    /// @stable ICU 2.0
	    /// <seealso cref="M:IBM.ICU.Math.BigDecimal.CompareTo(System.Object)"/>
	    /// <seealso cref="M:IBM.ICU.Math.BigDecimal.CompareTo(IBM.ICU.Math.BigDecimal)"/>
	    /// <seealso cref="M:IBM.ICU.Math.BigDecimal.CompareTo(IBM.ICU.Math.BigDecimal, IBM.ICU.Math.MathContext)"/>
	
	    public override bool Equals(System.Object obj) {
	        IBM.ICU.Math.BigDecimal rhs;
	        int i = 0;
	        char[] lca = null;
	        char[] rca = null;
	        // We are equal iff toString of both are exactly the same
	        if (obj == null)
	            return false; // not equal
	        if ((!(((obj  is  IBM.ICU.Math.BigDecimal)))))
	            return false; // not a decimal
	        rhs = (IBM.ICU.Math.BigDecimal) obj; // cast; we know it will work
	        if (this.ind != rhs.ind)
	            return false; // different signs never match
	        if (((this.mant.Length == rhs.mant.Length) & (this.exp == rhs.exp))
	                & (this.form == rhs.form))
	
	        { // mantissas say all
	          // here with equal-length byte arrays to compare
	            {
	                int _8 = this.mant.Length;
	                i = 0;
	                for (; _8 > 0; _8--, i++) {
	                    if (this.mant[i] != rhs.mant[i])
	                        return false;
	                }
	            }/* i */
	        } else { // need proper layout
	            lca = this.Layout(); // layout to character array
	            rca = rhs.Layout();
	            if (lca.Length != rca.Length)
	                return false; // mismatch
	            // here with equal-length character arrays to compare
	            {
	                int _9 = lca.Length;
	                i = 0;
	                for (; _9 > 0; _9--, i++) {
	                    if (lca[i] != rca[i])
	                        return false;
	                }
	            }/* i */
	        }
	        return true; // arrays have identical content
	    }
	
	    /// <summary>
	    /// Converts this <c>BigDecimal</c> to a <c>float</c>. If the
	    /// <c>BigDecimal</c> is out of the possible range for a
	    /// <c>float</c> (32-bit signed floating point) result then an
	    /// <c>ArithmeticException</c> is thrown.
	    /// <p>
	    /// The float produced is identical to result of expressing the
	    /// <c>BigDecimal</c> as a <c>String</c> and then converting it
	    /// using the <c>Float(String)</c> constructor; this can result in
	    /// values of <c>Float.NEGATIVE_INFINITY</c> or
	    /// <c>Float.POSITIVE_INFINITY</c>.
	    /// </summary>
	    ///
	    /// <returns>A <c>float</c> corresponding to <c>this</c>.</returns>
	    /// @stable ICU 2.0

        public /*override*/ float FloatValue()
        {
	        return Single.Parse(this.ToString(),ILOG.J2CsMapping.Util.NumberFormatProvider.NumberFormat);
	    }
	
	    /// <summary>
	    /// Returns the <c>String</c> representation of this
	    /// <c>BigDecimal</c>, modified by layout parameters.
	    /// <p>
	    /// <i>This method is provided as a primitive for use by more sophisticated
	    /// classes, such as <c>DecimalFormat</c>, that can apply
	    /// locale-sensitive editing of the result. The level of formatting that it
	    /// provides is a necessary part of the BigDecimal class as it is sensitive
	    /// to and must follow the calculation and rounding rules for BigDecimal
	    /// arithmetic. However, if the function is provided elsewhere, it may be
	    /// removed from this class. </i>
	    /// <p>
	    /// The parameters, for both forms of the <c>format</c> method are all
	    /// of type <c>int</c>. A value of -1 for any parameter indicates that
	    /// the default action or value for that parameter should be used.
	    /// <p>
	    /// The parameters, <c>before</c> and <c>after</c>, specify the
	    /// number of characters to be used for the integer part and decimal part of
	    /// the result respectively. Exponential notation is not used. If either
	    /// parameter is -1 (which indicates the default action), the number of
	    /// characters used will be exactly as many as are needed for that part.
	    /// <p>
	    /// <c>before</c> must be a positive number; if it is larger than is
	    /// needed to contain the integer part, that part is padded on the left with
	    /// blanks to the requested length. If <c>before</c> is not large
	    /// enough to contain the integer part of the number (including the sign, for
	    /// negative numbers) an exception is thrown.
	    /// <p>
	    /// <c>after</c> must be a non-negative number; if it is not the same
	    /// size as the decimal part of the number, the number will be rounded (or
	    /// extended with zeros) to fit. Specifying 0 for <c>after</c> will
	    /// cause the number to be rounded to an integer (that is, it will have no
	    /// decimal part or decimal point). The rounding method will be the default,
	    /// <c>MathContext.ROUND_HALF_UP</c>.
	    /// <p>
	    /// Other rounding methods, and the use of exponential notation, can be
	    /// selected by using <see cref="M:IBM.ICU.Math.BigDecimal.Format(System.Int32, System.Int32, System.Int32, System.Int32, System.Int32, System.Int32)"/>. Using the
	    /// two-parameter form of the method has exactly the same effect as using the
	    /// six-parameter form with the final four parameters all being -1.
	    /// </summary>
	    ///
	    /// <param name="before">The <c>int</c> specifying the number of places beforethe decimal point. Use -1 for 'as many as are needed'.</param>
	    /// <param name="after">The <c>int</c> specifying the number of places after thedecimal point. Use -1 for 'as many as are needed'.</param>
	    /// <returns>A <c>String</c> representing this <c>BigDecimal</c>,
	    /// laid out according to the specified parameters</returns>
	    /// <exception cref="ArithmeticException">if the number cannot be laid out as requested.</exception>
	    /// <exception cref="IllegalArgumentException">if a parameter is out of range.</exception>
	    /// @stable ICU 2.0
	    /// <seealso cref="M:IBM.ICU.Math.BigDecimal.ToString"/>
	    /// <seealso cref="M:IBM.ICU.Math.BigDecimal.ToCharArray"/>
	
	    public System.String Format(int before, int after) {
	        return Format(before, after, -1, -1,
	                IBM.ICU.Math.MathContext.SCIENTIFIC, ROUND_HALF_UP);
	    }
	
	    /// <summary>
	    /// Returns the <c>String</c> representation of this
	    /// <c>BigDecimal</c>, modified by layout parameters and allowing
	    /// exponential notation.
	    /// <p>
	    /// <i>This method is provided as a primitive for use by more sophisticated
	    /// classes, such as <c>DecimalFormat</c>, that can apply
	    /// locale-sensitive editing of the result. The level of formatting that it
	    /// provides is a necessary part of the BigDecimal class as it is sensitive
	    /// to and must follow the calculation and rounding rules for BigDecimal
	    /// arithmetic. However, if the function is provided elsewhere, it may be
	    /// removed from this class. </i>
	    /// <p>
	    /// The parameters are all of type <c>int</c>. A value of -1 for any
	    /// parameter indicates that the default action or value for that parameter
	    /// should be used.
	    /// <p>
	    /// The first two parameters (<c>before</c> and <c>after</c>)
	    /// specify the number of characters to be used for the integer part and
	    /// decimal part of the result respectively, as defined for<see cref="M:IBM.ICU.Math.BigDecimal.Format(System.Int32, System.Int32)"/>. If either of these is -1 (which indicates the
	    /// default action), the number of characters used will be exactly as many as
	    /// are needed for that part.
	    /// <p>
	    /// The remaining parameters control the use of exponential notation and
	    /// rounding. Three (<c>explaces</c>, <c>exdigits</c>, and
	    /// <c>exform</c>) control the exponent part of the result. As before,
	    /// the default action for any of these parameters may be selected by using
	    /// the value -1.
	    /// <p>
	    /// <c>explaces</c> must be a positive number; it sets the number of
	    /// places (digits after the sign of the exponent) to be used for any
	    /// exponent part, the default (when <c>explaces</c> is -1) being to
	    /// use as many as are needed. If <c>explaces</c> is not -1, space is
	    /// always reserved for an exponent; if one is not needed (for example, if
	    /// the exponent will be 0) then <c>explaces</c>+2 blanks are appended
	    /// to the result. <!-- (This preserves vertical alignment of similarly
	    /// formatted numbers in a monospace font.) --> If <c>explaces</c> is
	    /// not -1 and is not large enough to contain the exponent, an exception is
	    /// thrown.
	    /// <p>
	    /// <c>exdigits</c> sets the trigger point for use of exponential
	    /// notation. If, before any rounding, the number of places needed before the
	    /// decimal point exceeds <c>exdigits</c>, or if the absolute value of
	    /// the result is less than <c>0.000001</c>, then exponential form will
	    /// be used, provided that <c>exdigits</c> was specified. When
	    /// <c>exdigits</c> is -1, exponential notation will never be used. If
	    /// 0 is specified for <c>exdigits</c>, exponential notation is always
	    /// used unless the exponent would be 0.
	    /// <p>
	    /// <c>exform</c> sets the form for exponential notation (if needed).
	    /// It may be either <see cref="M:IBM.ICU.Math.MathContext.SCIENTIFIC"/> or<see cref="M:IBM.ICU.Math.MathContext.ENGINEERING"/>. If the latter, engineering, form is
	    /// requested, up to three digits (plus sign, if negative) may be needed for
	    /// the integer part of the result (<c>before</c>). Otherwise, only one
	    /// digit (plus sign, if negative) is needed.
	    /// <p>
	    /// Finally, the sixth argument, <c>exround</c>, selects the rounding
	    /// algorithm to be used, and must be one of the values indicated by a public
	    /// constant in the <see cref="T:IBM.ICU.Math.MathContext"/> class whose name starts with
	    /// <c>ROUND_</c>. The default (<c>ROUND_HALF_UP</c>) may also be
	    /// selected by using the value -1, as before.
	    /// <p>
	    /// The special value <c>MathContext.ROUND_UNNECESSARY</c> may be used
	    /// to detect whether non-zero digits are discarded -- if
	    /// <c>exround</c> has this value than if non-zero digits would be
	    /// discarded (rounded) during formatting then an
	    /// <c>ArithmeticException</c> is thrown.
	    /// </summary>
	    ///
	    /// <param name="before">The <c>int</c> specifying the number of places beforethe decimal point. Use -1 for 'as many as are needed'.</param>
	    /// <param name="after">The <c>int</c> specifying the number of places after thedecimal point. Use -1 for 'as many as are needed'.</param>
	    /// <param name="explaces">The <c>int</c> specifying the number of places to beused for any exponent. Use -1 for 'as many as are needed'.</param>
	    /// <param name="exdigits">The <c>int</c> specifying the trigger (digits before thedecimal point) which if exceeded causes exponential notationto be used. Use 0 to force exponential notation. Use -1 toforce plain notation (no exponential notation).</param>
	    /// <param name="exformint">The <c>int</c> specifying the form of exponentialnotation to be used (<see cref="M:IBM.ICU.Math.MathContext.SCIENTIFIC"/> or<see cref="M:IBM.ICU.Math.MathContext.ENGINEERING"/>).</param>
	    /// <param name="exround">The <c>int</c> specifying the rounding mode to use. Use-1 for the default, <see cref="M:IBM.ICU.Math.MathContext.ROUND_HALF_UP"/>.</param>
	    /// <returns>A <c>String</c> representing this <c>BigDecimal</c>,
	    /// laid out according to the specified parameters</returns>
	    /// <exception cref="ArithmeticException">if the number cannot be laid out as requested.</exception>
	    /// <exception cref="IllegalArgumentException">if a parameter is out of range.</exception>
	    /// <seealso cref="M:IBM.ICU.Math.BigDecimal.ToString"/>
	    /// <seealso cref="M:IBM.ICU.Math.BigDecimal.ToCharArray"/>
	    /// @stable ICU 2.0
	
	    public System.String Format(int before, int after, int explaces,
	            int exdigits, int exformint, int exround) {
	        IBM.ICU.Math.BigDecimal num;
	        int mag = 0;
	        int thisafter = 0;
	        int lead = 0;
	        byte[] newmant = null;
	        int chop = 0;
	        int need = 0;
	        int oldexp = 0;
	        char[] a;
	        int p = 0;
	        char[] newa = null;
	        int i = 0;
	        int places = 0;
	
	        /* Check arguments */
	        if ((before < (-1)) | (before == 0))
	            Badarg("format", 1, before.ToString());
	        if (after < (-1))
	            Badarg("format", 2, after.ToString());
	        if ((explaces < (-1)) | (explaces == 0))
	            Badarg("format", 3, explaces.ToString());
	        if (exdigits < (-1))
	            Badarg("format", 4, explaces.ToString());
	        {/* select */
	            if (exformint == IBM.ICU.Math.MathContext.SCIENTIFIC) {
	            } else if (exformint == IBM.ICU.Math.MathContext.ENGINEERING) {
	            } else if (exformint == (-1))
	                exformint = IBM.ICU.Math.MathContext.SCIENTIFIC;
	            // note PLAIN isn't allowed
	            else {
	                Badarg("format", 5, exformint.ToString());
	            }
	        }
	        // checking the rounding mode is done by trying to construct a
	        // MathContext object with that mode; it will fail if bad
	        if (exround != ROUND_HALF_UP) {
	            try { // if non-default...
	                if (exround == (-1))
	                    exround = ROUND_HALF_UP;
	                else
	                    new IBM.ICU.Math.MathContext(9,
	                            IBM.ICU.Math.MathContext.SCIENTIFIC, false,
	                            exround);
	            } catch (ArgumentException _10) {
	                Badarg("format", 6, exround.ToString());
	            }
	        }
	
	        num = Clone(this); // make private copy
	
	        /*
	         * Here: num is BigDecimal to format before is places before point [>0]
	         * after is places after point [>=0] explaces is exponent places [>0]
	         * exdigits is exponent digits [>=0] exformint is exponent form [one of
	         * two] exround is rounding mode [one of eight] 'before' through
	         * 'exdigits' are -1 if not specified
	         */
	
	        /* determine form */
	        {
	            do {/* select */
	                if (exdigits == (-1))
	                    num.form = (byte) IBM.ICU.Math.MathContext.PLAIN;
	                else if (num.ind == iszero)
	                    num.form = (byte) IBM.ICU.Math.MathContext.PLAIN;
	                else {
	                    // determine whether triggers
	                    mag = num.exp + num.mant.Length;
	                    if (mag > exdigits)
	                        num.form = (byte) exformint;
	                    else if (mag < (-5))
	                        num.form = (byte) exformint;
	                    else
	                        num.form = (byte) IBM.ICU.Math.MathContext.PLAIN;
	                }
	            } while (false);
	        }/* setform */
	
	        /*
	         * If 'after' was specified then we may need to adjust the mantissa.
	         * This is a little tricky, as we must conform to the rules of
	         * exponential layout if necessary (e.g., we cannot end up with 10.0 if
	         * scientific).
	         */
	        if (after >= 0) {
	            setafter: {
	                for (;;) {
	                    // calculate the current after-length
	                    {/* select */
	                        if (num.form == IBM.ICU.Math.MathContext.PLAIN)
	                            thisafter = (int) -num.exp; // has decimal part
	                        else if (num.form == IBM.ICU.Math.MathContext.SCIENTIFIC)
	                            thisafter = num.mant.Length - 1;
	                        else { // engineering
	                            lead = (((num.exp + num.mant.Length) - 1)) % 3; // exponent
	                                                                            // to
	                                                                            // use
	                            if (lead < 0)
	                                lead = 3 + lead; // negative exponent case
	                            lead++; // number of leading digits
	                            if (lead >= num.mant.Length)
	                                thisafter = 0;
	                            else
	                                thisafter = num.mant.Length - lead;
	                        }
	                    }
	                    if (thisafter == after)
	                     goto gotosetafter;
	                    if (thisafter < after) { // need added trailing zeros
	                                             // [thisafter can be negative]
	                        newmant = Extend(num.mant, (num.mant.Length + after)
	                                - thisafter);
	                        num.mant = newmant;
	                        num.exp = num.exp - ((after - thisafter)); // adjust
	                                                                   // exponent
	                        if (num.exp < MinExp)
	                            throw new System.ArithmeticException(
	                                    "Exponent Overflow:" + " " + num.exp);
	                        goto gotosetafter;
	                    }
	                    // We have too many digits after the decimal point; this could
	                    // cause a carry, which could change the mantissa...
	                    // Watch out for implied leading zeros in PLAIN case
	                    chop = thisafter - after; // digits to lop [is >0]
	                    if (chop > num.mant.Length) { // all digits go, no chance of
	                                                  // carry
	                                                  // carry on with zero
	                        num.mant = ZERO.mant;
	                        num.ind = iszero;
	                        num.exp = 0;
	                        goto setafter;
	                    }
	                    // we have a digit to inspect from existing mantissa
	                    // round the number as required
	                    need = num.mant.Length - chop; // digits to end up with [may be
	                                                   // 0]
	                    oldexp = num.exp; // save old exponent
	                    num.Round(need, exround);
	                    // if the exponent grew by more than the digits we chopped, then
	                    // we must have had a carry, so will need to recheck the layout
	                    if ((num.exp - oldexp) == chop)
	                     goto gotosetafter;
	                }
	            }
	            gotosetafter:
	            ;
	        }/* setafter */
	
	        a = num.Layout(); // lay out, with exponent if required, etc.
	
	        /* Here we have laid-out number in 'a' */
	        // now apply 'before' and 'explaces' as needed
	        if (before > 0) {
	            // look for '.' or 'E'
	            {
	                int _11 = a.Length;
	                p = 0;
	                p: {
	                    for (; _11 > 0; _11--, p++) {
	                        if (a[p] == '.')
	                            goto gotop;
	                        if (a[p] == 'E')
	                            goto gotop;
	                    }
	                }
	                gotop:
	                ;
	            }/* p */
	            // p is now offset of '.', 'E', or character after end of array
	            // that is, the current length of before part
	            if (p > before)
	                Badarg("format", 1, before.ToString()); // won't
	                                                                       // fit
	            if (p < before) { // need leading blanks
	                newa = new char[(a.Length + before) - p];
	                {
	                    int _12 = before - p;
	                    i = 0;
	                    for (; _12 > 0; _12--, i++) {
	                        newa[i] = ' ';
	                    }
	                }/* i */
	                System.Array.Copy((Array)((Object) a),0,(Array)((Object) newa),i,a.Length);
	                a = newa;
	            }
	            // [if p=before then it's just the right length]
	        }
	
	        if (explaces > 0) {
	            // look for 'E' [cannot be at offset 0]
	            {
	                int _13 = a.Length - 1;
	                p = a.Length - 1;
	                p: {
	                    for (; _13 > 0; _13--, p--) {
	                        if (a[p] == 'E')
	                            goto gotop;
	                    }
	                }
	                gotop:
	                ;
	            }/* p */
	            // p is now offset of 'E', or 0
	            if (p == 0) { // no E part; add trailing blanks
	                newa = new char[(a.Length + explaces) + 2];
	                System.Array.Copy((Array)((Object) a),0,(Array)((Object) newa),0,a.Length);
	                {
	                    int _14 = explaces + 2;
	                    i = a.Length;
	                    for (; _14 > 0; _14--, i++) {
	                        newa[i] = ' ';
	                    }
	                }/* i */
	                a = newa;
	            } else {/* found E */// may need to insert zeros
	                places = (a.Length - p) - 2; // number so far
	                if (places > explaces)
	                    Badarg("format", 3, explaces.ToString());
	                if (places < explaces) { // need to insert zeros
	                    newa = new char[(a.Length + explaces) - places];
	                    System.Array.Copy((Array)((Object) a),0,(Array)((Object) newa),0,p + 2); // through E and
	                                                                // sign
	                    {
	                        int _15 = explaces - places;
	                        i = p + 2;
	                        for (; _15 > 0; _15--, i++) {
	                            newa[i] = '0';
	                        }
	                    }/* i */
	                    System.Array.Copy((Array)((Object) a),p + 2,(Array)((Object) newa),i,places); // remainder of
	                                                                 // exponent
	                    a = newa;
	                }
	                // [if places=explaces then it's just the right length]
	            }
	        }
	        return ILOG.J2CsMapping.Util.StringUtil.NewString(a);
	    }
	
	    /// <summary>
	    /// Returns the hashcode for this <c>BigDecimal</c>. This hashcode is
	    /// suitable for use by the <c>java.util.Hashtable</c> class.
	    /// <p>
	    /// Note that two <c>BigDecimal</c> objects are only guaranteed to
	    /// produce the same hashcode if they are exactly equal (that is, the
	    /// <c>String</c> representations of the <c>BigDecimal</c>
	    /// numbers are identical -- they have the same characters in the same
	    /// sequence).
	    /// </summary>
	    ///
	    /// <returns>An <c>int</c> that is the hashcode for <c>this</c>.</returns>
	    /// @stable ICU 2.0
	
	    public override int GetHashCode() {
	        // Maybe calculate ourselves, later. If so, note that there can be
	        // more than one internal representation for a given toString() result.
	        return this.ToString().GetHashCode();
	    }
	
	    /// <summary>
	    /// Converts this <c>BigDecimal</c> to an <c>int</c>. If the
	    /// <c>BigDecimal</c> has a non-zero decimal part it is discarded. If
	    /// the <c>BigDecimal</c> is out of the possible range for an
	    /// <c>int</c> (32-bit signed integer) result then only the low-order
	    /// 32 bits are used. (That is, the number may be <i>decapitated</i>.) To
	    /// avoid unexpected errors when these conditions occur, use the<see cref="M:IBM.ICU.Math.BigDecimal.IntValueExact"/> method.
	    /// </summary>
	    ///
	    /// <returns>An <c>int</c> converted from <c>this</c>, truncated
	    /// and decapitated if necessary.</returns>
	    /// @stable ICU 2.0

        public /*override*/ int IntValue()
        {
	        return System.Convert.ToInt32(ToBigInteger());
	    }
	
	    /// <summary>
	    /// Converts this <c>BigDecimal</c> to an <c>int</c>. If the
	    /// <c>BigDecimal</c> has a non-zero decimal part or is out of the
	    /// possible range for an <c>int</c> (32-bit signed integer) result
	    /// then an <c>ArithmeticException</c> is thrown.
	    /// </summary>
	    ///
	    /// <returns>An <c>int</c> equal in value to <c>this</c>.</returns>
	    /// <exception cref="ArithmeticException">if <c>this</c> has a non-zero decimal part, or will notfit in an <c>int</c>.</exception>
	    /// @stable ICU 2.0
	
	    public int IntValueExact() {
	        int lodigit;
	        int useexp = 0;
	        int result;
	        int i = 0;
	        int topdig = 0;
	        // This does not use longValueExact() as the latter can be much
	        // slower.
	        // intcheck (from pow) relies on this to check decimal part
	        if (ind == iszero)
	            return 0; // easy, and quite common
	        /* test and drop any trailing decimal part */
	        lodigit = mant.Length - 1;
	        if (exp < 0) {
	            lodigit = lodigit + exp; // reduces by -(-exp)
	            /* all decimal places must be 0 */
	            if ((!(Allzero(mant, lodigit + 1))))
	                throw new System.ArithmeticException(
	                        "Decimal part non-zero:" + " " + this.ToString());
	            if (lodigit < 0)
	                return 0; // -1<this<1
	            useexp = 0;
	        } else {/* >=0 */
	            if ((exp + lodigit) > 9) // early exit
	                throw new System.ArithmeticException("Conversion overflow:"
	                        + " " + this.ToString());
	            useexp = exp;
	        }
	        /* convert the mantissa to binary, inline for speed */
	        result = 0;
	        {
	            int _16 = lodigit + useexp;
	            i = 0;
	            for (; i <= _16; i++) {
	                result = result * 10;
	                if (i <= lodigit)
	                    result = result + mant[i];
	            }
	        }/* i */
	
	        /* Now, if the risky length, check for overflow */
	        if ((lodigit + useexp) == 9) {
	            // note we cannot just test for -ve result, as overflow can move a
	            // zero into the top bit [consider 5555555555]
	            topdig = result / 1000000000; // get top digit, preserving sign
	            if (topdig != mant[0]) { // digit must match and be positive
	                                     // except in the special case ...
	                if (result == Int32.MinValue) // looks like the
	                                                           // special
	                    if (ind == isneg) // really was negative
	                        if (mant[0] == 2)
	                            return result; // really had top digit 2
	                throw new System.ArithmeticException("Conversion overflow:"
	                        + " " + this.ToString());
	            }
	        }
	
	        /* Looks good */
	        if (ind == ispos)
	            return result;
	        return (int) -result;
	    }
	
	    /// <summary>
	    /// Converts this <c>BigDecimal</c> to a <c>long</c>. If the
	    /// <c>BigDecimal</c> has a non-zero decimal part it is discarded. If
	    /// the <c>BigDecimal</c> is out of the possible range for a
	    /// <c>long</c> (64-bit signed integer) result then only the low-order
	    /// 64 bits are used. (That is, the number may be <i>decapitated</i>.) To
	    /// avoid unexpected errors when these conditions occur, use the<see cref="M:IBM.ICU.Math.BigDecimal.LongValueExact"/> method.
	    /// </summary>
	    ///
	    /// <returns>A <c>long</c> converted from <c>this</c>, truncated
	    /// and decapitated if necessary.</returns>
	    /// @stable ICU 2.0

        public /*override*/ long LongValue()
        {
	        return Convert.ToInt64(ToBigInteger());
	    }
	
	    /// <summary>
	    /// Converts this <c>BigDecimal</c> to a <c>long</c>. If the
	    /// <c>BigDecimal</c> has a non-zero decimal part or is out of the
	    /// possible range for a <c>long</c> (64-bit signed integer) result
	    /// then an <c>ArithmeticException</c> is thrown.
	    /// </summary>
	    ///
	    /// <returns>A <c>long</c> equal in value to <c>this</c>.</returns>
	    /// <exception cref="ArithmeticException">if <c>this</c> has a non-zero decimal part, or will notfit in a <c>long</c>.</exception>
	    /// @stable ICU 2.0
	
	    public long LongValueExact() {
	        int lodigit;
	        int cstart = 0;
	        int useexp = 0;
	        long result;
	        int i = 0;
	        long topdig = 0;
	        // Identical to intValueExact except for result=long, and exp>=20 test
	        if (ind == 0)
	            return 0; // easy, and quite common
	        lodigit = mant.Length - 1; // last included digit
	        if (exp < 0) {
	            lodigit = lodigit + exp; // -(-exp)
	            /* all decimal places must be 0 */
	            if (lodigit < 0)
	                cstart = 0;
	            else
	                cstart = lodigit + 1;
	            if ((!(Allzero(mant, cstart))))
	                throw new System.ArithmeticException(
	                        "Decimal part non-zero:" + " " + this.ToString());
	            if (lodigit < 0)
	                return 0; // -1<this<1
	            useexp = 0;
	        } else {/* >=0 */
	            if ((exp + mant.Length) > 18) // early exit
	                throw new System.ArithmeticException("Conversion overflow:"
	                        + " " + this.ToString());
	            useexp = exp;
	        }
	
	        /* convert the mantissa to binary, inline for speed */
	        // note that we could safely use the 'test for wrap to negative'
	        // algorithm here, but instead we parallel the intValueExact
	        // algorithm for ease of checking and maintenance.
	        result = (long) 0;
	        {
	            int _17 = lodigit + useexp;
	            i = 0;
	            for (; i <= _17; i++) {
	                result = result * 10;
	                if (i <= lodigit)
	                    result = result + mant[i];
	            }
	        }/* i */
	
	        /* Now, if the risky length, check for overflow */
	        if ((lodigit + useexp) == 18) {
	            topdig = result / 1000000000000000000L; // get top digit, preserving
	                                                    // sign
	            if (topdig != mant[0]) { // digit must match and be positive
	                                     // except in the special case ...
	                if (result == Int64.MinValue) // looks like the
	                                                        // special
	                    if (ind == isneg) // really was negative
	                        if (mant[0] == 9)
	                            return result; // really had top digit 9
	                throw new System.ArithmeticException("Conversion overflow:"
	                        + " " + this.ToString());
	            }
	        }
	
	        /* Looks good */
	        if (ind == ispos)
	            return result;
	        return (long) -result;
	    }
	
	    /// <summary>
	    /// Returns a plain <c>BigDecimal</c> whose decimal point has been
	    /// moved to the left by a specified number of positions. The parameter,
	    /// <c>n</c>, specifies the number of positions to move the decimal
	    /// point. That is, if <c>n</c> is 0 or positive, the number returned
	    /// is given by:
	    /// <p>
	    /// <code>
	    /// this.multiply(TEN.pow(new BigDecimal(-n)))
	    /// </code>
	    /// <p>
	    /// <c>n</c> may be negative, in which case the method returns the same
	    /// result as <c>movePointRight(-n)</c>.
	    /// </summary>
	    ///
	    /// <param name="n">The <c>int</c> specifying the number of places to movethe decimal point leftwards.</param>
	    /// <returns>A <c>BigDecimal</c> derived from <c>this</c>, with
	    /// the decimal point moved <c>n</c> places to the left.</returns>
	    /// @stable ICU 2.0
	
	    public IBM.ICU.Math.BigDecimal MovePointLeft(int n) {
	        IBM.ICU.Math.BigDecimal res;
	        // very little point in optimizing for shift of 0
	        res = Clone(this);
	        res.exp = res.exp - n;
	        return res.Finish(plainMC, false); // finish sets form and checks
	                                           // exponent
	    }
	
	    /// <summary>
	    /// Returns a plain <c>BigDecimal</c> whose decimal point has been
	    /// moved to the right by a specified number of positions. The parameter,
	    /// <c>n</c>, specifies the number of positions to move the decimal
	    /// point. That is, if <c>n</c> is 0 or positive, the number returned
	    /// is given by:
	    /// <p>
	    /// <code>
	    /// this.multiply(TEN.pow(new BigDecimal(n)))
	    /// </code>
	    /// <p>
	    /// <c>n</c> may be negative, in which case the method returns the same
	    /// result as <c>movePointLeft(-n)</c>.
	    /// </summary>
	    ///
	    /// <param name="n">The <c>int</c> specifying the number of places to movethe decimal point rightwards.</param>
	    /// <returns>A <c>BigDecimal</c> derived from <c>this</c>, with
	    /// the decimal point moved <c>n</c> places to the right.</returns>
	    /// @stable ICU 2.0
	
	    public IBM.ICU.Math.BigDecimal MovePointRight(int n) {
	        IBM.ICU.Math.BigDecimal res;
	        res = Clone(this);
	        res.exp = res.exp + n;
	        return res.Finish(plainMC, false);
	    }
	
	    /// <summary>
	    /// Returns the scale of this <c>BigDecimal</c>. Returns a non-negative
	    /// <c>int</c> which is the scale of the number. The scale is the
	    /// number of digits in the decimal part of the number if the number were
	    /// formatted without exponential notation.
	    /// </summary>
	    ///
	    /// <returns>An <c>int</c> whose value is the scale of this
	    /// <c>BigDecimal</c>.</returns>
	    /// @stable ICU 2.0
	
	    public int Scale() {
	        if (exp >= 0)
	            return 0; // scale can never be negative
	        return (int) -exp;
	    }
	
	    /// <summary>
	    /// Returns a plain <c>BigDecimal</c> with a given scale.
	    /// <p>
	    /// If the given scale (which must be zero or positive) is the same as or
	    /// greater than the length of the decimal part (the scale) of this
	    /// <c>BigDecimal</c> then trailing zeros will be added to the decimal
	    /// part as necessary.
	    /// <p>
	    /// If the given scale is less than the length of the decimal part (the
	    /// scale) of this <c>BigDecimal</c> then trailing digits will be
	    /// removed, and in this case an <c>ArithmeticException</c> is thrown
	    /// if any discarded digits are non-zero.
	    /// <p>
	    /// The same as <see cref="M:IBM.ICU.Math.BigDecimal.SetScale(System.Int32, System.Int32)"/>, where the first parameter is the
	    /// scale, and the second is <c>MathContext.ROUND_UNNECESSARY</c>.
	    /// </summary>
	    ///
	    /// <param name="scale">The <c>int</c> specifying the scale of the resulting<c>BigDecimal</c>.</param>
	    /// <returns>A plain <c>BigDecimal</c> with the given scale.</returns>
	    /// <exception cref="ArithmeticException">if <c>scale</c> is negative.</exception>
	    /// <exception cref="ArithmeticException">if reducing scale would discard non-zero digits.</exception>
	    /// @stable ICU 2.0
	
	    public IBM.ICU.Math.BigDecimal SetScale(int scale) {
	        return SetScale(scale, ROUND_UNNECESSARY);
	    }
	
	    /// <summary>
	    /// Returns a plain <c>BigDecimal</c> with a given scale.
	    /// <p>
	    /// If the given scale (which must be zero or positive) is the same as or
	    /// greater than the length of the decimal part (the scale) of this
	    /// <c>BigDecimal</c> then trailing zeros will be added to the decimal
	    /// part as necessary.
	    /// <p>
	    /// If the given scale is less than the length of the decimal part (the
	    /// scale) of this <c>BigDecimal</c> then trailing digits will be
	    /// removed, and the rounding mode given by the second parameter is used to
	    /// determine if the remaining digits are affected by a carry. In this case,
	    /// an <c>IllegalArgumentException</c> is thrown if <c>round</c>
	    /// is not a valid rounding mode.
	    /// <p>
	    /// If <c>round</c> is <c>MathContext.ROUND_UNNECESSARY</c>, an
	    /// <c>ArithmeticException</c> is thrown if any discarded digits are
	    /// non-zero.
	    /// </summary>
	    ///
	    /// <param name="scale">The <c>int</c> specifying the scale of the resulting<c>BigDecimal</c>.</param>
	    /// <param name="round">The <c>int</c> rounding mode to be used for the division(see the <see cref="T:IBM.ICU.Math.MathContext"/> class).</param>
	    /// <returns>A plain <c>BigDecimal</c> with the given scale.</returns>
	    /// <exception cref="IllegalArgumentException">if <c>round</c> is not a valid rounding mode.</exception>
	    /// <exception cref="ArithmeticException">if <c>scale</c> is negative.</exception>
	    /// <exception cref="ArithmeticException">if <c>round</c> is<c>MathContext.ROUND_UNNECESSARY</c>, and reducingscale would discard non-zero digits.</exception>
	    /// @stable ICU 2.0
	
	    public IBM.ICU.Math.BigDecimal SetScale(int scale, int round) {
	        int ourscale;
	        IBM.ICU.Math.BigDecimal res;
	        int padding = 0;
	        int newlen = 0;
	        // at present this naughtily only checks the round value if it is
	        // needed (used), for speed
	        ourscale = this.Scale();
	        if (ourscale == scale) // already correct scale
	            if (this.form == IBM.ICU.Math.MathContext.PLAIN) // .. and form
	                return this;
	        res = Clone(this); // need copy
	        if (ourscale <= scale) { // simply zero-padding/changing form
	                                 // if ourscale is 0 we may have lots of 0s to
	                                 // add
	            if (ourscale == 0)
	                padding = res.exp + scale;
	            else
	                padding = scale - ourscale;
	            res.mant = Extend(res.mant, res.mant.Length + padding);
	            res.exp = (int) -scale; // as requested
	        } else {/* ourscale>scale: shortening, probably */
	            if (scale < 0)
	                throw new System.ArithmeticException("Negative scale:" + " "
	                        + scale);
	            // [round() will raise exception if invalid round]
	            newlen = res.mant.Length - ((ourscale - scale)); // [<=0 is OK]
	            res = res.Round(newlen, round); // round to required length
	            // This could have shifted left if round (say) 0.9->1[.0]
	            // Repair if so by adding a zero and reducing exponent
	            if (res.exp != ((int) -scale)) {
	                res.mant = Extend(res.mant, res.mant.Length + 1);
	                res.exp = res.exp - 1;
	            }
	        }
	        res.form = (byte) IBM.ICU.Math.MathContext.PLAIN; // by definition
	        return res;
	    }
	
	    /// <summary>
	    /// Converts this <c>BigDecimal</c> to a <c>short</c>. If the
	    /// <c>BigDecimal</c> has a non-zero decimal part or is out of the
	    /// possible range for a <c>short</c> (16-bit signed integer) result
	    /// then an <c>ArithmeticException</c> is thrown.
	    /// </summary>
	    ///
	    /// <returns>A <c>short</c> equal in value to <c>this</c>.</returns>
	    /// <exception cref="ArithmeticException">if <c>this</c> has a non-zero decimal part, or will notfit in a <c>short</c>.</exception>
	    /// @stable ICU 2.0
	
	    public short ShortValueExact() {
	        int num;
	        num = this.IntValueExact(); // will check decimal part too
	        if ((num > 32767) | (num < (-32768)))
	            throw new System.ArithmeticException("Conversion overflow:"
	                    + " " + this.ToString());
	        return (short) num;
	    }
	
	    /// <summary>
	    /// Returns the sign of this <c>BigDecimal</c>, as an <c>int</c>.
	    /// This returns the <i>signum</i> function value that represents the sign of
	    /// this <c>BigDecimal</c>. That is, -1 if the <c>BigDecimal</c>
	    /// is negative, 0 if it is numerically equal to zero, or 1 if it is
	    /// positive.
	    /// </summary>
	    ///
	    /// <returns>An <c>int</c> which is -1 if the <c>BigDecimal</c> is
	    /// negative, 0 if it is numerically equal to zero, or 1 if it is
	    /// positive.</returns>
	    /// @stable ICU 2.0
	
	    public int Signum() {
	        return (int) this.ind; // [note this assumes values for ind.]
	    }
	
	    // #if defined(FOUNDATION10) || defined(J2SE13)
	    // #else
	    /// <summary>
	    /// Converts this <c>BigDecimal</c> to a
	    /// <c>java.math.BigDecimal</c>.
	    /// <p>
	    /// This is an exact conversion; the result is the same as if the
	    /// <c>BigDecimal</c> were formatted as a plain number without any
	    /// rounding or exponent and then the
	    /// <c>java.math.BigDecimal(java.lang.String)</c> constructor were used
	    /// to construct the result.
	    /// <p>
	    /// <i>(Note: this method is provided only in the
	    /// <c>com.ibm.icu.math</c> version of the BigDecimal class. It would
	    /// not be present in a <c>java.math</c> version.)</i>
	    /// </summary>
	    ///
	    /// <returns>The <c>java.math.BigDecimal</c> equal in value to this
	    /// <c>BigDecimal</c>.</returns>
	    /// @stable ICU 2.0
	
	    public Decimal ToBigDecimal() {
            throw new NotImplementedException();
	        //return new Decimal(this.UnscaledValue(), this.Scale());
	    }
	
	    // #endif
	
	    /// <summary>
	    /// Converts this <c>BigDecimal</c> to a
	    /// <c>java.math.BigInteger</c>.
	    /// <p>
	    /// Any decimal part is truncated (discarded). If an exception is desired
	    /// should the decimal part be non-zero, use <see cref="M:IBM.ICU.Math.BigDecimal.ToBigIntegerExact"/>.
	    /// </summary>
	    ///
	    /// <returns>The <c>java.math.BigInteger</c> equal in value to the
	    /// integer part of this <c>BigDecimal</c>.</returns>
	    /// @stable ICU 2.0
	
	    public Int64 ToBigInteger() {
	        IBM.ICU.Math.BigDecimal res = null;
	        int newlen = 0;
	        byte[] newmant = null;
	        {/* select */
	            if ((exp >= 0) & (form == IBM.ICU.Math.MathContext.PLAIN))
	                res = this; // can layout simply
	            else if (exp >= 0) {
	                res = Clone(this); // safe copy
	                res.form = (byte) IBM.ICU.Math.MathContext.PLAIN; // .. and
	                                                                      // request
	                                                                      // PLAIN
	            } else {
	                { // exp<0; scale to be truncated
	                  // we could use divideInteger, but we may as well be quicker
	                    if (((int) -this.exp) >= this.mant.Length)
	                        res = ZERO; // all blows away
	                    else {
	                        res = Clone(this); // safe copy
	                        newlen = res.mant.Length + res.exp;
	                        newmant = new byte[newlen]; // [shorter]
	                        System.Array.Copy((Array)((Object) res.mant),0,(Array)((Object) newmant),0,newlen);
	                        res.mant = newmant;
	                        res.form = (byte) IBM.ICU.Math.MathContext.PLAIN;
	                        res.exp = 0;
	                    }
	                }
	            }
	        }
	        return Int64.Parse(ILOG.J2CsMapping.Util.StringUtil.NewString(res.Layout()));
	    }
	
	    /// <summary>
	    /// Converts this <c>BigDecimal</c> to a
	    /// <c>java.math.BigInteger</c>.
	    /// <p>
	    /// An exception is thrown if the decimal part (if any) is non-zero.
	    /// </summary>
	    ///
	    /// <returns>The <c>java.math.BigInteger</c> equal in value to the
	    /// integer part of this <c>BigDecimal</c>.</returns>
	    /// <exception cref="ArithmeticException">if <c>this</c> has a non-zero decimal part.</exception>
	    /// @stable ICU 2.0
	
	    public Int64 ToBigIntegerExact() {
	        /* test any trailing decimal part */
	        if (exp < 0) { // possible decimal part
	            /* all decimal places must be 0; note exp<0 */
	            if ((!(Allzero(mant, mant.Length + exp))))
	                throw new System.ArithmeticException(
	                        "Decimal part non-zero:" + " " + this.ToString());
	        }
	        return ToBigInteger();
	    }
	
	    /// <summary>
	    /// Returns the <c>BigDecimal</c> as a character array. The result of
	    /// this method is the same as using the sequence
	    /// <c>toString().toCharArray()</c>, but avoids creating the
	    /// intermediate <c>String</c> and <c>char[]</c> objects.
	    /// </summary>
	    ///
	    /// <returns>The <c>char[]</c> array corresponding to this
	    /// <c>BigDecimal</c>.</returns>
	    /// @stable ICU 2.0
	
	    public char[] ToCharArray() {
	        return Layout();
	    }
	
	    /// <summary>
	    /// Returns the <c>BigDecimal</c> as a <c>String</c>. This
	    /// returns a <c>String</c> that exactly represents this
	    /// <c>BigDecimal</c>, as defined in the decimal documentation (see<see cref="null"/>).
	    /// <p>
	    /// By definition, using the <see cref="M:IBM.ICU.Math.BigDecimal.BigDecimal(System.String)"/> constructor on the
	    /// result <c>String</c> will create a <c>BigDecimal</c> that is
	    /// exactly equal to the original <c>BigDecimal</c>.
	    /// </summary>
	    ///
	    /// <returns>The <c>String</c> exactly corresponding to this
	    /// <c>BigDecimal</c>.</returns>
	    /// <seealso cref="M:IBM.ICU.Math.BigDecimal.Format(System.Int32, System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Math.BigDecimal.Format(System.Int32, System.Int32, System.Int32, System.Int32, System.Int32, System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Math.BigDecimal.ToCharArray"/>
	    /// @stable ICU 2.0
	
	    public override System.String ToString() {
	        return ILOG.J2CsMapping.Util.StringUtil.NewString(Layout());
	    }
	
	    /// <summary>
	    /// Returns the number as a <c>BigInteger</c> after removing the scale.
	    /// That is, the number is expressed as a plain number, any decimal point is
	    /// then removed (retaining the digits of any decimal part), and the result
	    /// is then converted to a <c>BigInteger</c>.
	    /// </summary>
	    ///
	    /// <returns>The <c>java.math.BigInteger</c> equal in value to this
	    /// <c>BigDecimal</c> multiplied by ten to the power of
	    /// <c>this.scale()</c>.</returns>
	    /// @stable ICU 2.0
	
	    public Int64 UnscaledValue() {
	        IBM.ICU.Math.BigDecimal res = null;
	        if (exp >= 0)
	            res = this;
	        else {
	            res = Clone(this); // safe copy
	            res.exp = 0; // drop scale
	        }
	        return res.ToBigInteger();
	    }
	
	    /// <summary>
	    /// Translates a <c>double</c> to a <c>BigDecimal</c>.
	    /// <p>
	    /// Returns a <c>BigDecimal</c> which is the decimal representation of
	    /// the 64-bit signed binary floating point parameter. If the parameter is
	    /// infinite, or is not a number (NaN), a <c>NumberFormatException</c>
	    /// is thrown.
	    /// <p>
	    /// The number is constructed as though <c>num</c> had been converted
	    /// to a <c>String</c> using the <c>Double.toString()</c> method
	    /// and the <see cref="M:IBM.ICU.Math.BigDecimal.BigDecimal(System.String)"/> constructor had then been
	    /// used. This is typically not an exact conversion.
	    /// </summary>
	    ///
	    /// <param name="dub">The <c>double</c> to be translated.</param>
	    /// <returns>The <c>BigDecimal</c> equal in value to <c>dub</c>.</returns>
	    /// <exception cref="NumberFormatException">if the parameter is infinite or not a number.</exception>
	    /// @stable ICU 2.0
	
	    public static IBM.ICU.Math.BigDecimal ValueOf(double dub) {
	        // Reminder: a zero double returns '0.0', so we cannot fastpath to
	        // use the constant ZERO. This might be important enough to justify
	        // a factory approach, a cache, or a few private constants, later.
	        return new IBM.ICU.Math.BigDecimal(
	                ((double )(dub)).ToString());
	    }
	
	    /// <summary>
	    /// Translates a <c>long</c> to a <c>BigDecimal</c>. That is,
	    /// returns a plain <c>BigDecimal</c> whose value is equal to the given
	    /// <c>long</c>.
	    /// </summary>
	    ///
	    /// <param name="lint">The <c>long</c> to be translated.</param>
	    /// <returns>The <c>BigDecimal</c> equal in value to <c>lint</c>.</returns>
	    /// @stable ICU 2.0
	
	    public static IBM.ICU.Math.BigDecimal ValueOf(long lint) {
	        return ValueOf(lint, 0);
	    }
	
	    /// <summary>
	    /// Translates a <c>long</c> to a <c>BigDecimal</c> with a given
	    /// scale. That is, returns a plain <c>BigDecimal</c> whose unscaled
	    /// value is equal to the given <c>long</c>, adjusted by the second
	    /// parameter, <c>scale</c>.
	    /// <p>
	    /// The result is given by:
	    /// <p>
	    /// <code>
	    /// (new BigDecimal(lint)).divide(TEN.pow(new BigDecimal(scale)))
	    /// </code>
	    /// <p>
	    /// A <c>NumberFormatException</c> is thrown if <c>scale</c> is
	    /// negative.
	    /// </summary>
	    ///
	    /// <param name="lint">The <c>long</c> to be translated.</param>
	    /// <param name="scale">The <c>int</c> scale to be applied.</param>
	    /// <returns>The <c>BigDecimal</c> equal in value to <c>lint</c>.</returns>
	    /// <exception cref="NumberFormatException">if the scale is negative.</exception>
	    /// @stable ICU 2.0
	
	    public static IBM.ICU.Math.BigDecimal ValueOf(long lint, int scale) {
	        IBM.ICU.Math.BigDecimal res = null;
	        {/* select */
	            if (lint == 0)
	                res = ZERO;
	            else if (lint == 1)
	                res = ONE;
	            else if (lint == 10)
	                res = TEN;
	            else {
	                res = new IBM.ICU.Math.BigDecimal(lint);
	            }
	        }
	        if (scale == 0)
	            return res;
	        if (scale < 0)
	            throw new FormatException("Negative scale:" + " "
	                    + scale);
	        res = Clone(res); // safe copy [do not mutate]
	        res.exp = (int) -scale; // exponent is -scale
	        return res;
	    }
	
	    /* ---------------------------------------------------------------- */
	    /* Private methods */
	    /* ---------------------------------------------------------------- */
	
	    /*
	     * <sgml> Return char array value of a BigDecimal (conversion from
	     * BigDecimal to laid-out canonical char array). <p>The mantissa will either
	     * already have been rounded (following an operation) or will be of length
	     * appropriate (in the case of construction from an int, for example). <p>We
	     * must not alter the mantissa, here. <p>'form' describes whether we are to
	     * use exponential notation (and if so, which), or if we are to lay out as a
	     * plain/pure numeric. </sgml>
	     */
	
	    private char[] Layout() {
	        char[] cmant;
	        int i = 0;
	        StringBuilder sb = null;
	        int euse = 0;
	        int sig = 0;
	        char csign = (char) (0);
	        char[] rec = null;
	        int needsign;
	        int mag;
	        int len = 0;
	        cmant = new char[mant.Length]; // copy byte[] to a char[]
	        {
	            int _18 = mant.Length;
	            i = 0;
	            for (; _18 > 0; _18--, i++) {
	                cmant[i] = (char) (mant[i] + ((int) ('0')));
	            }
	        }/* i */
	
	        if (form != IBM.ICU.Math.MathContext.PLAIN) {/*
	                                                          * exponential notation
	                                                          * needed
	                                                          */
	            sb = new StringBuilder(cmant.Length + 15); // -x.xxxE+999999999
	            if (ind == isneg)
	                sb.Append('-');
	            euse = (exp + cmant.Length) - 1; // exponent to use
	            /* setup sig=significant digits and copy to result */
	            if (form == IBM.ICU.Math.MathContext.SCIENTIFIC) { // [default]
	                sb.Append(cmant[0]); // significant character
	                if (cmant.Length > 1) // have decimal part
	                    sb.Append('.').Append(cmant, 1, cmant.Length - 1);
	            } else {
	                do {
	                    sig = euse % 3; // common
	                    if (sig < 0)
	                        sig = 3 + sig; // negative exponent
	                    euse = euse - sig;
	                    sig++;
	                    if (sig >= cmant.Length) { // zero padding may be needed
	                        sb.Append(cmant, 0, cmant.Length);
	                        {
	                            int _19 = sig - cmant.Length;
	                            for (; _19 > 0; _19--) {
	                                sb.Append('0');
	                            }
	                        }
	                    } else { // decimal point needed
	                        sb.Append(cmant, 0, sig).Append('.')
	                                .Append(cmant, sig, cmant.Length - sig);
	                    }
	                } while (false);
	            }/* engineering */
	            if (euse != 0) {
	                if (euse < 0) {
	                    csign = '-';
	                    euse = (int) -euse;
	                } else
	                    csign = '+';
	                sb.Append('E').Append(csign).Append(euse);
	            }
	            rec = new char[sb.Length];
	            IBM.ICU.Impl.Utility.GetChars(sb, 0, sb.Length, rec, 0);
	            return rec;
	        }
	
	        /* Here for non-exponential (plain) notation */
	        if (exp == 0) {/* easy */
	            if (ind >= 0)
	                return cmant; // non-negative integer
	            rec = new char[cmant.Length + 1];
	            rec[0] = '-';
	            System.Array.Copy((Array)((Object) cmant),0,(Array)((Object) rec),1,cmant.Length);
	            return rec;
	        }
	
	        /* Need a '.' and/or some zeros */
	        needsign = (int) ((ind == isneg) ? 1 : 0); // space for sign? 0 or 1
	
	        /*
	         * MAG is the position of the point in the mantissa (index of the
	         * character it follows)
	         */
	        mag = exp + cmant.Length;
	
	        if (mag < 1) {/* 0.00xxxx form */
	            len = (needsign + 2) - exp; // needsign+2+(-mag)+cmant.length
	            rec = new char[len];
	            if (needsign != 0)
	                rec[0] = '-';
	            rec[needsign] = '0';
	            rec[needsign + 1] = '.';
	            {
	                int _20 = (int) -mag;
	                i = needsign + 2;
	                for (; _20 > 0; _20--, i++) { // maybe none
	                    rec[i] = '0';
	                }
	            }/* i */
	            System.Array.Copy((Array)((Object) cmant),0,(Array)((Object) rec),(needsign + 2) - mag,cmant.Length);
	            return rec;
	        }
	
	        if (mag > cmant.Length) {/* xxxx0000 form */
	            len = needsign + mag;
	            rec = new char[len];
	            if (needsign != 0)
	                rec[0] = '-';
	            System.Array.Copy((Array)((Object) cmant),0,(Array)((Object) rec),needsign,cmant.Length);
	            {
	                int _21 = mag - cmant.Length;
	                i = needsign + cmant.Length;
	                for (; _21 > 0; _21--, i++) { // never 0
	                    rec[i] = '0';
	                }
	            }/* i */
	            return rec;
	        }
	
	        /* decimal point is in the middle of the mantissa */
	        len = (needsign + 1) + cmant.Length;
	        rec = new char[len];
	        if (needsign != 0)
	            rec[0] = '-';
	        System.Array.Copy((Array)((Object) cmant),0,(Array)((Object) rec),needsign,mag);
	        rec[needsign + mag] = '.';
	        System.Array.Copy((Array)((Object) cmant),mag,(Array)((Object) rec),(needsign + mag) + 1,cmant.Length
	                                - mag);
	        return rec;
	    }
	
	    /*
	     * <sgml> Checks a BigDecimal argument to ensure it's a true integer in a
	     * given range. <p>If OK, returns it as an int. </sgml>
	     */
	    // [currently only used by pow]
	
	    private int Intcheck(int min, int max) {
	        int i;
	        i = this.IntValueExact(); // [checks for non-0 decimal part]
	        // Use same message as though intValueExact failed due to size
	        if ((i < min) | (i > max))
	            throw new System.ArithmeticException("Conversion overflow:"
	                    + " " + i);
	        return i;
	    }
	
	    /* <sgml> Carry out division operations. </sgml> */
	    /*
	     * Arg1 is operation code: D=divide, I=integer divide, R=remainder Arg2 is
	     * the rhs. Arg3 is the context. Arg4 is explicit scale iff code='D' or 'I'
	     * (-1 if none).
	     * 
	     * Underlying algorithm (complications for Remainder function and scaled
	     * division are omitted for clarity):
	     * 
	     * Test for x/0 and then 0/x Exp =Exp1 - Exp2 Exp =Exp +len(var1) -len(var2)
	     * Sign=Sign1 * Sign2 Pad accumulator (Var1) to double-length with 0's
	     * (pad1) Pad Var2 to same length as Var1 B2B=1st two digits of var2, +1 to
	     * allow for roundup have=0 Do until (have=digits+1 OR residue=0) if exp<0
	     * then if integer divide/residue then leave this_digit=0 Do forever compare
	     * numbers if <0 then leave inner_loop if =0 then (- quick exit without
	     * subtract -) do this_digit=this_digit+1; output this_digit leave
	     * outer_loop; end Compare lengths of numbers (mantissae): If same then
	     * CA=first_digit_of_Var1 else CA=first_two_digits_of_Var1 mult=ca*10/b2b --
	     * Good and safe guess at divisor if mult=0 then mult=1
	     * this_digit=this_digit+mult subtract end inner_loop if have\=0 |
	     * this_digit\=0 then do output this_digit have=have+1; end var2=var2/10
	     * exp=exp-1 end outer_loop exp=exp+1 -- set the proper exponent if have=0
	     * then generate answer=0 Return to FINISHED Result defined by MATHV1
	     * 
	     * For extended commentary, see DMSRCN.
	     */
	
	    private IBM.ICU.Math.BigDecimal Dodivide(char code,
	            IBM.ICU.Math.BigDecimal rhs, IBM.ICU.Math.MathContext set,
	            int scale) {
	        IBM.ICU.Math.BigDecimal lhs;
	        int reqdig;
	        int newexp;
	        IBM.ICU.Math.BigDecimal res;
	        int newlen;
	        byte[] var1;
	        int var1len;
	        byte[] var2;
	        int var2len;
	        int b2b;
	        int have;
	        int thisdigit = 0;
	        int i = 0;
	        byte v2 = 0;
	        int ba = 0;
	        int mult = 0;
	        int start = 0;
	        int padding = 0;
	        int d = 0;
	        byte[] newvar1 = null;
	        byte lasthave = 0;
	        int actdig = 0;
	        byte[] newmant = null;
	
	        if (set.lostDigits)
	            Checkdigits(rhs, set.digits);
	        lhs = this; // name for clarity
	
	        // [note we must have checked lostDigits before the following checks]
	        if (rhs.ind == 0)
	            throw new System.ArithmeticException("Divide by 0"); // includes
	                                                                    // 0/0
	        if (lhs.ind == 0) { // 0/x => 0 [possibly with .0s]
	            if (set.form != IBM.ICU.Math.MathContext.PLAIN)
	                return ZERO;
	            if (scale == (-1))
	                return lhs;
	            return lhs.SetScale(scale);
	        }
	
	        /* Prepare numbers according to BigDecimal rules */
	        reqdig = set.digits; // local copy (heavily used)
	        if (reqdig > 0) {
	            if (lhs.mant.Length > reqdig)
	                lhs = Clone(lhs).Round(set);
	            if (rhs.mant.Length > reqdig)
	                rhs = Clone(rhs).Round(set);
	        } else {/* scaled divide */
	            if (scale == (-1))
	                scale = lhs.Scale();
	            // set reqdig to be at least large enough for the computation
	            reqdig = lhs.mant.Length; // base length
	            // next line handles both positive lhs.exp and also scale mismatch
	            if (scale != ((int) -lhs.exp))
	                reqdig = (reqdig + scale) + lhs.exp;
	            reqdig = (reqdig - ((rhs.mant.Length - 1))) - rhs.exp; // reduce by
	                                                                   // RHS effect
	            if (reqdig < lhs.mant.Length)
	                reqdig = lhs.mant.Length; // clamp
	            if (reqdig < rhs.mant.Length)
	                reqdig = rhs.mant.Length; // ..
	        }
	
	        /* precalculate exponent */
	        newexp = ((lhs.exp - rhs.exp) + lhs.mant.Length) - rhs.mant.Length;
	        /* If new exponent -ve, then some quick exits are possible */
	        if (newexp < 0)
	            if (code != 'D') {
	                if (code == 'I')
	                    return ZERO; // easy - no integer part
	                /* Must be 'R'; remainder is [finished clone of] input value */
	                return Clone(lhs).Finish(set, false);
	            }
	
	        /* We need slow division */
	        res = new IBM.ICU.Math.BigDecimal(); // where we'll build result
	        res.ind = (sbyte) (lhs.ind * rhs.ind); // final sign (for D/I)
	        res.exp = newexp; // initial exponent (for D/I)
	        res.mant = new byte[reqdig + 1]; // where build the result
	
	        /* Now [virtually pad the mantissae with trailing zeros */
	        // Also copy the LHS, which will be our working array
	        newlen = (reqdig + reqdig) + 1;
	        var1 = Extend(lhs.mant, newlen); // always makes longer, so new safe
	                                         // array
	        var1len = newlen; // [remaining digits are 0]
	
	        var2 = rhs.mant;
	        var2len = newlen;
	
	        /* Calculate first two digits of rhs (var2), +1 for later estimations */
	        b2b = (var2[0] * 10) + 1;
	        if (var2.Length > 1)
	            b2b = b2b + var2[1];
	
	        /* start the long-division loops */
	        have = 0;
	        {
	            outer: {
	                for (;;) {
	                    thisdigit = 0;
	                    /* find the next digit */
	                    {
	                        inner: {
	                            for (;;) {
	                                if (var1len < var2len)
	                                 goto gotoinner;
	                                if (var1len == var2len) { // compare needed
	                                    {
	                                        compare: {
	                                            do { // comparison
	                                                {
	                                                    int _22 = var1len;
	                                                    i = 0;
	                                                    for (; _22 > 0; _22--, i++) {
	                                                        // var1len is always <= var1.length
	                                                        if (i < var2.Length)
	                                                            v2 = var2[i];
	                                                        else
	                                                            v2 = (byte) 0;
	                                                        if (var1[i] < v2)
	                                                         goto gotoinner;
	                                                        if (var1[i] > v2)
	                                                         goto gotocompare;
	                                                    }
	                                                }/* i */
	                                                /*
	                                                 * reach here if lhs and rhs are identical;
	                                                 * subtraction will increase digit by one,
	                                                 * and the residue will be 0 so we are done;
	                                                 * leave the loop with residue set to 0 (in
	                                                 * case code is 'R' or ROUND_UNNECESSARY or
	                                                 * a ROUND_HALF_xxxx is being checked)
	                                                 */
	                                                thisdigit++;
	                                                res.mant[have] = (byte) thisdigit;
	                                                have++;
	                                                var1[0] = (byte) 0; // residue to 0 [this is
	                                                                    goto gotoouter;
	                                            } while (false);
	                                        }
	                                        gotocompare:
	                                        ;
	                                    }/* compare */
	                                    /*
	                                     * prepare for subtraction. Estimate BA (lengths the
	                                     * same)
	                                     */
	                                    ba = (int) var1[0]; // use only first digit
	                                } // lengths the same
	                                else {/* lhs longer than rhs */
	                                    /* use first two digits for estimate */
	                                    ba = var1[0] * 10;
	                                    if (var1len > 1)
	                                        ba = ba + var1[1];
	                                }
	                                /* subtraction needed; V1>=V2 */
	                                mult = (ba * 10) / b2b;
	                                if (mult == 0)
	                                    mult = 1;
	                                thisdigit = thisdigit + mult;
	                                // subtract; var1 reusable
	                                var1 = Byteaddsub(var1, var1len, var2, var2len,
	                                        (int) -mult, true);
	                                if (var1[0] != 0)
	                                 goto inner;
	                                /*
	                                 * V1 now probably has leading zeros, remove leading 0's
	                                 * and try again. (It could be longer than V2)
	                                 */
	                                {
	                                    int _23 = var1len - 2;
	                                    start = 0;
	                                    start: {
	                                        for (; start <= _23; start++) {
	                                            if (var1[start] != 0)
                                                    goto gotostart;
	                                            var1len--;
	                                        }
	                                    }
	                                    gotostart:
	                                    ;
	                                }/* start */
	                                if (start == 0)
	                                    goto inner;
	                                // shift left
	                                System.Array.Copy((Array)((Object) var1),start,(Array)((Object) var1),0,var1len);
	                            }
	                        }
	                        gotoinner:
	                        ;
	                    }/* inner */
	
	                    /* We have the next digit */
	                    if ((have != 0) | (thisdigit != 0)) { // put the digit we got
	                        res.mant[have] = (byte) thisdigit;
	                        have++;
	                        if (have == (reqdig + 1))
	                         goto gotoouter;
	                        if (var1[0] == 0)
	                         goto gotoouter;
	                    }
	                    /* can leave now if a scaled divide and exponent is small enough */
	                    if (scale >= 0)
	                        if (((int) -res.exp) > scale)
	                            goto gotoouter;
	                    /* can leave now if not Divide and no integer part left */
	                    if (code != 'D')
	                        if (res.exp <= 0)
	                            goto gotoouter;
	                    res.exp = res.exp - 1; // reduce the exponent
	                    /*
	                     * to get here, V1 is less than V2, so divide V2 by 10 and go
	                     * for the next digit
	                     */
	                    var2len--;
	                }
	            }
	            gotoouter:
	            ;
	        }/* outer */
	
	        /* here when we have finished dividing, for some reason */
	        // have is the number of digits we collected in res.mant
	        if (have == 0)
	            have = 1; // res.mant[0] is 0; we always want a digit
	
	        if ((code == 'I') | (code == 'R')) {/* check for integer overflow needed */
	            if ((have + res.exp) > reqdig)
	                throw new System.ArithmeticException("Integer overflow");
	
	            if (code == 'R') {
	                do {
	                    /* We were doing Remainder -- return the residue */
	                    if (res.mant[0] == 0) // no integer part was found
	                        return Clone(lhs).Finish(set, false); // .. so return
	                                                              // lhs, canonical
	                    if (var1[0] == 0)
	                        return ZERO; // simple 0 residue
	                    res.ind = lhs.ind; // sign is always as LHS
	                    /*
	                     * Calculate the exponent by subtracting the number of
	                     * padding zeros we added and adding the original exponent
	                     */
	                    padding = ((reqdig + reqdig) + 1) - lhs.mant.Length;
	                    res.exp = (res.exp - padding) + lhs.exp;
	
	                    /*
	                     * strip insignificant padding zeros from residue, and
	                     * create/copy the resulting mantissa if need be
	                     */
	                    d = var1len;
	                    {
	                        i = d - 1;
	                        i: {
	                            for (; i >= 1; i--) {
	                                if (!((res.exp < lhs.exp) & (res.exp < rhs.exp)))
	                                    break;
	                                if (var1[i] != 0)
	                                    goto gotoi;
	                                d--;
	                                res.exp = res.exp + 1;
	                            }
	                        }
	                        gotoi:
	                        ;
	                    }/* i */
	                    if (d < var1.Length) {/* need to reduce */
	                        newvar1 = new byte[d];
	                        System.Array.Copy((Array)((Object) var1),0,(Array)((Object) newvar1),0,d); // shorten
	                        var1 = newvar1;
	                    }
	                    res.mant = var1;
	                    return res.Finish(set, false);
	                } while (false);
	            }/* remainder */
	        }
	
	        else {/* 'D' -- no overflow check needed */
	            // If there was a residue then bump the final digit (iff 0 or 5)
	            // so that the residue is visible for ROUND_UP, ROUND_HALF_xxx and
	            // ROUND_UNNECESSARY checks (etc.) later.
	            // [if we finished early, the residue will be 0]
	            if (var1[0] != 0) { // residue not 0
	                lasthave = res.mant[have - 1];
	                if (((lasthave % 5)) == 0)
	                    res.mant[have - 1] = (byte) (lasthave + 1);
	            }
	        }
	
	        /* Here for Divide or Integer Divide */
	        // handle scaled results first ['I' always scale 0, optional for 'D']
	        if (scale >= 0) {
	            do {
	                // say 'scale have res.exp len' scale have res.exp
	                // res.mant.length
	                if (have != res.mant.Length)
	                    // already padded with 0's, so just adjust exponent
	                    res.exp = res.exp - ((res.mant.Length - have));
	                // calculate number of digits we really want [may be 0]
	                actdig = res.mant.Length - ((((int) -res.exp) - scale));
	                res.Round(actdig, set.roundingMode); // round to desired length
	                // This could have shifted left if round (say) 0.9->1[.0]
	                // Repair if so by adding a zero and reducing exponent
	                if (res.exp != ((int) -scale)) {
	                    res.mant = Extend(res.mant, res.mant.Length + 1);
	                    res.exp = res.exp - 1;
	                }
	                return res.Finish(set, true); // [strip if not PLAIN]
	            } while (false);
	        }/* scaled */
	
	        // reach here only if a non-scaled
	        if (have == res.mant.Length) { // got digits+1 digits
	            res.Round(set);
	            have = reqdig;
	        } else {/* have<=reqdig */
	            if (res.mant[0] == 0)
	                return ZERO; // fastpath
	            // make the mantissa truly just 'have' long
	            // [we could let finish do this, during strip, if we adjusted
	            // the exponent; however, truncation avoids the strip loop]
	            newmant = new byte[have]; // shorten
	            System.Array.Copy((Array)((Object) res.mant),0,(Array)((Object) newmant),0,have);
	            res.mant = newmant;
	        }
	        return res.Finish(set, true);
	    }
	
	    /* <sgml> Report a conversion exception. </sgml> */
	
	    private void Bad(char[] s) {
	        throw new FormatException("Not a number:" + " "
	                + s.ToString());
	    }
	
	    /*
	     * <sgml> Report a bad argument to a method. </sgml> Arg1 is method name
	     * Arg2 is argument position Arg3 is what was found
	     */
	
	    private void Badarg(System.String name, int pos, System.String value_ren) {
	        throw new ArgumentException("Bad argument" + " " + pos
	                + " " + "to" + " " + name + ":" + " " + value_ren);
	    }
	
	    /*
	     * <sgml> Extend byte array to given length, padding with 0s. If no
	     * extension is required then return the same array. </sgml>
	     * 
	     * Arg1 is the source byte array Arg2 is the new length (longer)
	     */
	
	    private static byte[] Extend(byte[] inarr, int newlen) {
	        byte[] newarr;
	        if (inarr.Length == newlen)
	            return inarr;
	        newarr = new byte[newlen];
	        System.Array.Copy((Array)((Object) inarr),0,(Array)((Object) newarr),0,inarr.Length);
	        // 0 padding is carried out by the JVM on allocation initialization
	        return newarr;
	    }
	
	    /*
	     * <sgml> Add or subtract two >=0 integers in byte arrays <p>This routine
	     * performs the calculation: <pre> C=A+(B*M) </pre> Where M is in the range
	     * -9 through +9 <p> If M<0 then A>=B must be true, so the result is always
	     * non-negative.
	     * 
	     * Leading zeros are not removed after a subtraction. The result is either
	     * the same length as the longer of A and B, or 1 longer than that (if a
	     * carry occurred).
	     * 
	     * A is not altered unless Arg6 is 1. B is never altered.
	     * 
	     * Arg1 is A Arg2 is A length to use (if longer than A, pad with 0's) Arg3
	     * is B Arg4 is B length to use (if longer than B, pad with 0's) Arg5 is M,
	     * the multiplier Arg6 is 1 if A can be used to build the result (if it
	     * fits)
	     * 
	     * This routine is severely performance-critical; *any* change here must be
	     * measured (timed) to assure no performance degradation.
	     */
	    // 1996.02.20 -- enhanced version of DMSRCN algorithm (1981)
	    // 1997.10.05 -- changed to byte arrays (from char arrays)
	    // 1998.07.01 -- changed to allow destructive reuse of LHS
	    // 1998.07.01 -- changed to allow virtual lengths for the arrays
	    // 1998.12.29 -- use lookaside for digit/carry calculation
	    // 1999.08.07 -- avoid multiply when mult=1, and make db an int
	    // 1999.12.22 -- special case m=-1, also drop 0 special case
	
	    private static byte[] Byteaddsub(byte[] a, int avlen, byte[] b,
	            int bvlen, int m, bool reuse) {
	        int alength;
	        int blength;
	        int ap;
	        int bp;
	        int maxarr;
	        byte[] reb;
	        bool quickm;
	        int digit;
	        int op = 0;
	        int dp90 = 0;
	        byte[] newarr;
	        int i = 0;
	
	        // We'll usually be right if we assume no carry
	        alength = a.Length; // physical lengths
	        blength = b.Length; // ..
	        ap = avlen - 1; // -> final (rightmost) digit
	        bp = bvlen - 1; // ..
	        maxarr = bp;
	        if (maxarr < ap)
	            maxarr = ap;
	        reb = (byte[]) null; // result byte array
	        if (reuse)
	            if ((maxarr + 1) == alength)
	                reb = a; // OK to reuse A
	        if (reb == null)
	            reb = new byte[maxarr + 1]; // need new array
	
	        quickm = false; // 1 if no multiply needed
	        if (m == 1)
	            quickm = true; // most common
	        else if (m == (-1))
	            quickm = true; // also common
	
	        digit = 0; // digit, with carry or borrow
	        {
	            op = maxarr;
	            op: {
	                for (; op >= 0; op--) {
	                    if (ap >= 0) {
	                        if (ap < alength)
	                            digit = digit + a[ap]; // within A
	                        ap--;
	                    }
	                    if (bp >= 0) {
	                        if (bp < blength) { // within B
	                            if (quickm) {
	                                if (m > 0)
	                                    digit = digit + b[bp]; // most common
	                                else
	                                    digit = digit - b[bp]; // also common
	                            } else
	                                digit = digit + (b[bp] * m);
	                        }
	                        bp--;
	                    }
	                    /* result so far (digit) could be -90 through 99 */
	                    if (digit < 10)
	                        if (digit >= 0) {
	                            do { // 0-9
	                                reb[op] = (byte) digit;
	                                digit = 0; // no carry
	                                goto op;
	                            } while (false);
	                        }/* quick */
	                    dp90 = digit + 90;
	                    reb[op] = bytedig[dp90]; // this digit
	                    digit = bytecar[dp90]; // carry or borrow
	                }
	            }
	            gotoop:
	            ;
	        }/* op */
	
	        if (digit == 0)
	            return reb; // no carry
	        // following line will become an Assert, later
	        // if digit<0 then signal
	        // ArithmeticException("internal.error ["digit"]")
	
	        /* We have carry -- need to make space for the extra digit */
	        newarr = (byte[]) null;
	        if (reuse)
	            if ((maxarr + 2) == a.Length)
	                newarr = a; // OK to reuse A
	        if (newarr == null)
	            newarr = new byte[maxarr + 2];
	        newarr[0] = (byte) digit; // the carried digit ..
	        // .. and all the rest [use local loop for short numbers]
	        if (maxarr < 10) {
	            int _24 = maxarr + 1;
	            i = 0;
	            for (; _24 > 0; _24--, i++) {
	                newarr[i + 1] = reb[i];
	            }
	        }/* i */
	        else
	            System.Array.Copy((Array)((Object) reb),0,(Array)((Object) newarr),1,maxarr + 1);
	        return newarr;
	    }
	
	    /*
	     * <sgml> Initializer for digit array properties (lookaside). </sgml>
	     * Returns the digit array, and initializes the carry array.
	     */
	
	    private static byte[] Diginit() {
	        byte[] work;
	        int op = 0;
	        int digit = 0;
	        work = new byte[(90 + 99) + 1];
	        {
	            op = 0;
	            opLabel: {
	                for (; op <= (90 + 99); op++) {
	                    digit = op - 90;
	                    if (digit >= 0) {
	                        work[op] = (byte) (digit % 10);
	                        bytecar[op] = (byte) (digit / 10); // calculate carry
                            continue; // goto opLabel;
	                    }
	                    // borrowing...
	                    digit = digit + 100; // yes, this is right [consider -50]
	                    work[op] = (byte) (digit % 10);
	                    bytecar[op] = (byte) ((digit / 10) - 10); // calculate borrow
	                                                              // [NB: - after %]
	                }
	            }
	            gotoop:
	            ;
	        }/* op */
	        return work;
	    }
	
	    /*
	     * <sgml> Create a copy of BigDecimal object for local use. <p>This does NOT
	     * make a copy of the mantissa array. </sgml> Arg1 is the BigDecimal to
	     * clone (non-null)
	     */
	
	    private static IBM.ICU.Math.BigDecimal Clone(
	            IBM.ICU.Math.BigDecimal dec) {
	        IBM.ICU.Math.BigDecimal copy;
	        copy = new IBM.ICU.Math.BigDecimal();
	        copy.ind = dec.ind;
	        copy.exp = dec.exp;
	        copy.form = dec.form;
	        copy.mant = dec.mant;
	        return copy;
	    }
	
	    /*
	     * <sgml> Check one or two numbers for lost digits. </sgml> Arg1 is RHS (or
	     * null, if none) Arg2 is current DIGITS setting returns quietly or throws
	     * an exception
	     */
	
	    private void Checkdigits(IBM.ICU.Math.BigDecimal rhs, int dig) {
	        if (dig == 0)
	            return; // don't check if digits=0
	        // first check lhs...
	        if (this.mant.Length > dig)
	            if ((!(Allzero(this.mant, dig))))
	                throw new System.ArithmeticException("Too many digits:"
	                        + " " + this.ToString());
	        if (rhs == null)
	            return; // monadic
	        if (rhs.mant.Length > dig)
	            if ((!(Allzero(rhs.mant, dig))))
	                throw new System.ArithmeticException("Too many digits:"
	                        + " " + rhs.ToString());
	    }
	
	    /*
	     * <sgml> Round to specified digits, if necessary. </sgml> Arg1 is requested
	     * MathContext [with length and rounding mode] returns this, for convenience
	     */
	
	    private IBM.ICU.Math.BigDecimal Round(IBM.ICU.Math.MathContext set) {
	        return Round(set.digits, set.roundingMode);
	    }
	
	    /*
	     * <sgml> Round to specified digits, if necessary. Arg1 is requested length
	     * (digits to round to) [may be <=0 when called from format, dodivide, etc.]
	     * Arg2 is rounding mode returns this, for convenience
	     * 
	     * ind and exp are adjusted, but not cleared for a mantissa of zero
	     * 
	     * The length of the mantissa returned will be Arg1, except when Arg1 is 0,
	     * in which case the returned mantissa length will be 1. </sgml>
	     */
	
	    private IBM.ICU.Math.BigDecimal Round(int len, int mode) {
	        int adjust;
	        int sign;
	        byte[] oldmant;
	        bool reuse = false;
	        byte first = 0;
	        int increment;
	        byte[] newmant = null;
	        adjust = mant.Length - len;
	        if (adjust <= 0)
	            return this; // nowt to do
	
	        exp = exp + adjust; // exponent of result
	        sign = (int) ind; // save [assumes -1, 0, 1]
	        oldmant = mant; // save
	        if (len > 0) {
	            // remove the unwanted digits
	            mant = new byte[len];
	            System.Array.Copy((Array)((Object) oldmant),0,(Array)((Object) mant),0,len);
	            reuse = true; // can reuse mantissa
	            first = oldmant[len]; // first of discarded digits
	        } else {/* len<=0 */
	            mant = ZERO.mant;
	            ind = iszero;
	            reuse = false; // cannot reuse mantissa
	            if (len == 0)
	                first = oldmant[0];
	            else
	                first = (byte) 0; // [virtual digit]
	        }
	
	        // decide rounding adjustment depending on mode, sign, and discarded
	        // digits
	        increment = 0; // bumper
	        {
	            do {/* select */
	                if (mode == ROUND_HALF_UP) { // default first [most common]
	                    if (first >= 5)
	                        increment = sign;
	                } else if (mode == ROUND_UNNECESSARY) { // default for
	                                                        // setScale()
	                                                        // discarding any
	                                                        // non-zero digits is an
	                                                        // error
	                    if ((!(Allzero(oldmant, len))))
	                        throw new System.ArithmeticException(
	                                "Rounding necessary");
	                } else if (mode == ROUND_HALF_DOWN) { // 0.5000 goes down
	                    if (first > 5)
	                        increment = sign;
	                    else if (first == 5)
	                        if ((!(Allzero(oldmant, len + 1))))
	                            increment = sign;
	                } else if (mode == ROUND_HALF_EVEN) { // 0.5000 goes down if
	                                                      // left digit even
	                    if (first > 5)
	                        increment = sign;
	                    else if (first == 5) {
	                        if ((!(Allzero(oldmant, len + 1))))
	                            increment = sign;
	                        else /* 0.5000 */
	                        if ((((mant[mant.Length - 1]) % 2)) == 1)
	                            increment = sign;
	                    }
	                } else if (mode == ROUND_DOWN) {
	                    // never increment
	                } else if (mode == ROUND_UP) { // increment if discarded
	                                               // non-zero
	                    if ((!(Allzero(oldmant, len))))
	                        increment = sign;
	                } else if (mode == ROUND_CEILING) { // more positive
	                    if (sign > 0)
	                        if ((!(Allzero(oldmant, len))))
	                            increment = sign;
	                } else if (mode == ROUND_FLOOR) { // more negative
	                    if (sign < 0)
	                        if ((!(Allzero(oldmant, len))))
	                            increment = sign;
	                } else {
	                    throw new ArgumentException(
	                            "Bad round value:" + " " + mode);
	                }
	            } while (false);
	        }/* modes */
	
	        if (increment != 0) {
	            do {
	                if (ind == iszero) {
	                    // we must not subtract from 0, but result is trivial anyway
	                    mant = ONE.mant;
	                    ind = (sbyte) increment;
	                } else {
	                    // mantissa is non-0; we can safely add or subtract 1
	                    if (ind == isneg)
	                        increment = (int) -increment;
	                    newmant = Byteaddsub(mant, mant.Length, ONE.mant, 1,
	                            increment, reuse);
	                    if (newmant.Length > mant.Length) { // had a carry
	                                                        // drop rightmost digit
	                                                        // and raise exponent
	                        exp++;
	                        // mant is already the correct length
	                        System.Array.Copy((Array)((Object) newmant),0,(Array)((Object) mant),0,mant.Length);
	                    } else
	                        mant = newmant;
	                }
	            } while (false);
	        }/* bump */
	        // rounding can increase exponent significantly
	        if (exp > MaxExp)
	            throw new System.ArithmeticException("Exponent Overflow:" + " "
	                    + exp);
	        return this;
	    }
	
	    /*
	     * <sgml> Test if rightmost digits are all 0. Arg1 is a mantissa array to
	     * test Arg2 is the offset of first digit to check [may be negative; if so,
	     * digits to left are 0's] returns 1 if all the digits starting at Arg2 are
	     * 0
	     * 
	     * Arg2 may be beyond array bounds, in which case 1 is returned </sgml>
	     */
	
	    private static bool Allzero(byte[] array, int start) {
	        int i = 0;
	        if (start < 0)
	            start = 0;
	        {
	            int _25 = array.Length - 1;
	            i = start;
	            for (; i <= _25; i++) {
	                if (array[i] != 0)
	                    return false;
	            }
	        }/* i */
	        return true;
	    }
	
	    /*
	     * <sgml> Carry out final checks and canonicalization <p> This finishes off
	     * the current number by: 1. Rounding if necessary (NB: length includes
	     * leading zeros) 2. Stripping trailing zeros (if requested and \PLAIN) 3.
	     * Stripping leading zeros (always) 4. Selecting exponential notation (if
	     * required) 5. Converting a zero result to just '0' (if \PLAIN) In
	     * practice, these operations overlap and share code. It always sets form.
	     * </sgml> Arg1 is requested MathContext (length to round to, trigger, and
	     * FORM) Arg2 is 1 if trailing insignificant zeros should be removed after
	     * round (for division, etc.), provided that set.form isn't PLAIN. returns
	     * this, for convenience
	     */
	
	    private IBM.ICU.Math.BigDecimal Finish(
	            IBM.ICU.Math.MathContext set, bool strip) {
	        int d = 0;
	        int i = 0;
	        byte[] newmant = null;
	        int mag = 0;
	        int sig = 0;
	        /* Round if mantissa too long and digits requested */
	        if (set.digits != 0)
	            if (this.mant.Length > set.digits)
	                this.Round(set);
	
	        /*
	         * If strip requested (and standard formatting), remove insignificant
	         * trailing zeros.
	         */
	        if (strip)
	            if (set.form != IBM.ICU.Math.MathContext.PLAIN) {
	                d = this.mant.Length;
	                /* see if we need to drop any trailing zeros */
	                {
	                    i = d - 1;
	                    i: {
	                        for (; i >= 1; i--) {
	                            if (this.mant[i] != 0)
	                                goto gotoi;
	                            d--;
	                            exp++;
	                        }
	                    }
	                    gotoi:
	                    ;
	                }/* i */
	                if (d < this.mant.Length) {/* need to reduce */
	                    newmant = new byte[d];
	                    System.Array.Copy((Array)((Object) this.mant),0,(Array)((Object) newmant),0,d);
	                    this.mant = newmant;
	                }
	            }
	
	        form = (byte) IBM.ICU.Math.MathContext.PLAIN; // preset
	
	        /* Now check for leading- and all- zeros in mantissa */
	        {
	            int _26 = this.mant.Length;
	            i = 0;
	            for (; _26 > 0; _26--, i++) {
	                if (this.mant[i] != 0) {
	                    // non-0 result; ind will be correct
	                    // remove leading zeros [e.g., after subtract]
	                    if (i > 0) {
	                        do {
	                            newmant = new byte[this.mant.Length - i];
	                            System.Array.Copy((Array)((Object) this.mant),i,(Array)((Object) newmant),0,this.mant.Length - i);
	                            this.mant = newmant;
	                        } while (false);
	                    }/* delead */
	                    // now determine form if not PLAIN
	                    mag = exp + mant.Length;
	                    if (mag > 0) { // most common path
	                        if (mag > set.digits)
	                            if (set.digits != 0)
	                                form = (byte) set.form;
	                        if ((mag - 1) <= MaxExp)
	                            return this; // no overflow; quick return
	                    } else if (mag < (-5))
	                        form = (byte) set.form;
	                    /* check for overflow */
	                    mag--;
	                    if ((mag < MinExp) | (mag > MaxExp)) {
	                        overflow: {
	                            do {
	                                // possible reprieve if form is engineering
	                                if (form == IBM.ICU.Math.MathContext.ENGINEERING) {
	                                    sig = mag % 3; // leftover
	                                    if (sig < 0)
	                                        sig = 3 + sig; // negative exponent
	                                    mag = mag - sig; // exponent to use
	                                    // 1999.06.29: second test here must be MaxExp
	                                    if (mag >= MinExp)
	                                        if (mag <= MaxExp)
	                                            goto gotooverflow;
	                                }
	                                throw new System.ArithmeticException(
	                                        "Exponent Overflow:" + " " + mag);
	                            } while (false);
	                        }
	                        gotooverflow:
	                        ;
	                    }/* overflow */
	                    return this;
	                }
	            }
	        }/* i */
	
	        // Drop through to here only if mantissa is all zeros
	        ind = iszero;
	        {/* select */
	            if (set.form != IBM.ICU.Math.MathContext.PLAIN)
	                exp = 0; // standard result; go to '0'
	            else if (exp > 0)
	                exp = 0; // +ve exponent also goes to '0'
	            else {
	                // a plain number with -ve exponent; preserve and check exponent
	                if (exp < MinExp)
	                    throw new System.ArithmeticException(
	                            "Exponent Overflow:" + " " + exp);
	            }
	        }
	        mant = ZERO.mant; // canonical mantissa
	        return this;
	    }
	}
}
