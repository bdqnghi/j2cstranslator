/*
 *******************************************************************************
 * Copyright (C) 2007, International Business Machines Corporation and         *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 */
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/13/10 4:01 PM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Charset {
	
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Text;
	
	
	public class FieldsSet {
	    public const int NO_ENUM = -1;
	
	    protected internal FieldsSet(int whichEnum, int fieldsCount) {
	        this.fEnum = NO_ENUM;
	        this.fFieldsCount = 0;
	        this.fValues = null;
	        this.fIsSet = null;
	        if (fieldsCount <= 0 && whichEnum != NO_ENUM) {
	            fieldsCount = IBM.ICU.Charset.DebugUtilities.EnumCount(whichEnum);
	        }
	        fEnum = whichEnum;
	        fFieldsCount = fieldsCount;
	        if (fieldsCount < 0) {
	            throw new Exception("Preposterous field count " + fieldsCount);
	        }
	        fValues = new int[fFieldsCount];
	        fIsSet = new bool[fFieldsCount];
	        Clear();
	    }
	
	    protected internal int fEnum;
	
	    protected internal int fFieldsCount;
	
	    protected internal int[] fValues;
	
	    protected internal bool[] fIsSet;
	
	    public void Clear() {
	        for (int i = 0; i < fFieldsCount; i++) {
	            Clear(i);
	        }
	    }
	
	    public void Clear(int field) {
	        fValues[field] = -1;
	        fIsSet[field] = false;
	    }
	
	    public void Set(int field, int amount) {
	        fValues[field] = amount;
	        fIsSet[field] = true;
	    }
	
	    public bool IsSet(int field) {
	        return fIsSet[field];
	    }
	
	    public int Get(int field) {
	        if (fIsSet[field]) {
	            return fValues[field];
	        } else {
	            return -1;
	        }
	    }
	
	    public bool IsSameType(FieldsSet other) {
	        return ((other.fEnum == fEnum) && (other.fFieldsCount == fFieldsCount));
	    }
	
	    public int FieldCount() {
	        return fFieldsCount;
	    }
	
	    
	    /// <param name="other">"expected" set to match against</param>
	    /// <returns>a formatted string listing which fields are set in this, with the
	    /// comparison made agaainst those fields in other, or, 'null' if
	    /// there is no difference.</returns>
	    public String DiffFrom(FieldsSet other) {
	        StringBuilder str = new StringBuilder();
	        if (!IsSameType(other)) {
	            throw new ArgumentException(
	                    "U_ILLEGAL_ARGUMENT_ERROR: FieldsSet of a different type!");
	        }
	        for (int i = 0; i < FieldCount(); i++) {
	            if (IsSet(i)) {
	                int myVal = Get(i);
	                int theirVal = other.Get(i);
	
	                if (fEnum != NO_ENUM) {
	                    String fieldName = IBM.ICU.Charset.DebugUtilities.EnumString(fEnum, i);
	
	                    String aval = ILOG.J2CsMapping.Util.IlNumber.ToString(myVal);
	                    String bval = ILOG.J2CsMapping.Util.IlNumber.ToString(theirVal);
	
	                    str.Append(fieldName + "=" + aval + " not " + bval + ", ");
	                } else {
	                    str.Append(ILOG.J2CsMapping.Util.IlNumber.ToString(i) + "=" + myVal + " not "
	                            + theirVal + ", ");
	                }
	            }
	        }
	        if (str.Length == 0) {
	            return null;
	        }
	        return str.ToString();
	    }
	
	    
	    /// <param name="str">string to parse</param>
	    /// <param name="status">formatted string for status</param>
	    public int ParseFrom(String str) {
	        return ParseFrom(str, null);
	    }
	
	    public int ParseFrom(String str, FieldsSet inheritFrom) {
	        int goodFields = 0;
	
	        String[] fields = IBM.ICU.Impl.Utility.Split(str, ',');
	        for (int i = 0; i < fields.Length; i++) {
	            String fieldStr = fields[i];
	            String[] kv = IBM.ICU.Impl.Utility.Split(fieldStr, '=');
	            if (kv.Length < 1 || kv.Length > 2) {
	                throw new Exception("split around '=' failed: " + fieldStr);
	            }
	            String key = kv[0];
	            String value_ren = "";
	            if (kv.Length > 1) {
	                value_ren = kv[1];
	            }
	
	            int field = HandleParseName(inheritFrom, key, value_ren);
	            if (field != -1) {
	                HandleParseValue(inheritFrom, field, value_ren);
	                goodFields++;
	            }
	        }
	
	        return goodFields;
	    }
	
	    /// <summary>
	    /// Callback interface for subclass. This function is called when parsing a
	    /// field name, such as "MONTH" in "MONTH=4". Base implementation is to
	    /// lookup the enum value using udbg_/// utilities, or else as an integer if
	    /// enum is not available.
	    /// If there is a special directive, the implementer can catch it here and
	    /// return -1 after special processing completes.
	    /// </summary>
	    ///
	    /// <param name="inheritFrom">the set inheriting from - may be null.</param>
	    /// <param name="name">the field name (key side)</param>
	    /// <param name="substr">the string in question (value side)</param>
	    /// <param name="status">error status - set to error for failure.</param>
	    /// <returns>field number, or negative if field should be skipped.</returns>
	    protected internal virtual int HandleParseName(FieldsSet inheritFrom, String name,
	            String substr) {
	        int field = -1;
	        if (fEnum != NO_ENUM) {
	            field = IBM.ICU.Charset.DebugUtilities.EnumByString(fEnum, name);
	        }
	        if (field < 0) {
	            field = Int32.Parse(name);
	        }
	        return field;
	    }
	
	    /// <summary>
	    /// Callback interface for subclass. Base implementation is to call
	    /// parseValueDefault(...)
	    /// </summary>
	    ///
	    /// <param name="inheritFrom">the set inheriting from - may be null.</param>
	    /// <param name="field">which field is being parsed</param>
	    /// <param name="substr">the string in question (value side)</param>
	    /// <param name="status">error status - set to error for failure.</param>
	    /// <seealso cref="null"/>
	    protected internal virtual void HandleParseValue(FieldsSet inheritFrom, int field,
	            String substr) {
	        ParseValueDefault(inheritFrom, field, substr);
	    }
	
	    /// <summary>
	    /// the default implementation for handleParseValue. Base implementation is
	    /// to parse a decimal integer value, or inherit from inheritFrom if the
	    /// string is 0-length. Implementations of this function should call
	    /// set(field,...) on successful parse.
	    /// </summary>
	    ///
	    /// <seealso cref="null"/>
	    protected internal void ParseValueDefault(FieldsSet inheritFrom, int field,
	            String substr) {
	        if (substr.Length == 0) {
	            if (inheritFrom == null) {
                    throw new Exception("Trying to inherit from field " + field
	                        + " but inheritFrom is null");
	            }
	            if (!inheritFrom.IsSet(field)) {
                    throw new Exception("Trying to inherit from field " + field
	                        + " but inheritFrom[" + field + "] is  not set");
	            }
	            Set(field, inheritFrom.Get(field));
	        } else {
	            int value_ren = Int32.Parse(substr);
	            Set(field, value_ren);
	        }
	    }
	
	    /// <summary>
	    /// convenience implementation for handleParseValue attempt to load a value
	    /// from an enum value using udbg_enumByString() if fails, will call
	    /// parseValueDefault()
	    /// </summary>
	    ///
	    /// <seealso cref="null"/>
	    protected internal void ParseValueEnum(int type, FieldsSet inheritFrom, int field,
	            String substr) {
	        int value_ren = IBM.ICU.Charset.DebugUtilities.EnumByString(type, substr);
	        if (value_ren >= 0) {
	            Set(field, value_ren);
	            return;
	        }
	        ParseValueDefault(inheritFrom, field, substr);
	    }
	
	    public String FieldName(int field) {
	        return (fEnum != NO_ENUM) ? IBM.ICU.Charset.DebugUtilities.EnumString(fEnum, field)
	                : ILOG.J2CsMapping.Util.IlNumber.ToString(field);
	    }
	
	    public override String ToString() {
	        String str = GetType().FullName
	                + " ["
	                + fFieldsCount
	                + ","
	                + ((fEnum != NO_ENUM) ? IBM.ICU.Charset.DebugUtilities.TypeString(fEnum)
	                        : ILOG.J2CsMapping.Util.IlNumber.ToString(fEnum)) + "]: ";
	        for (int i = 0; i < fFieldsCount; i++) {
	            if (IsSet(i)) {
	                str = str + FieldName(i) + "=" + Get(i) + ",";
	            }
	        }
	        return str;
	    }
	}
}
