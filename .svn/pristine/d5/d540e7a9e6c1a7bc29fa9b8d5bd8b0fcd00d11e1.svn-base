/*
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 11/30/10 3:38 PM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace ILOG.J2CsMapping.RegEx {
	
	using ILOG.J2CsMapping.Collections;
	using ILOG.J2CsMapping.Text;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Text;
     using ILOG.J2CsMapping.Util;
	
	/// <summary>
	/// User defined character classes ([abef]). See AbstractCharClass
	/// documentation for more details.
	/// </summary>
	///
	internal class CharClass : AbstractCharClass {
	
		public sealed class Anonymous_C17 : AbstractCharClass {
			private readonly AbstractCharClass cc;
	
			public Anonymous_C17(AbstractCharClass cc_0) {
				this.cc = cc_0;
			}
	
			public override bool Contains(int ch) {
				return cc.Contains(ch);
			}
		}
	
		public sealed class Anonymous_C16 : AbstractCharClass {
				private readonly CharClass outer_CharClass;
				private readonly bool curAlt;
				private readonly AbstractCharClass cc;
		
				public Anonymous_C16(CharClass paramouter_CharClass, bool curAlt_0,
						AbstractCharClass cc_1) {
					this.curAlt = curAlt_0;
					this.cc = cc_1;
					this.outer_CharClass = paramouter_CharClass;
				}
		
				public override bool Contains(int ch) {
					return !((curAlt ^ outer_CharClass.bits.Get(ch)) || ((curAlt ^ outer_CharClass.inverted) ^ cc
							.Contains(ch)));
				}
			}
	
		public sealed class Anonymous_C15 : AbstractCharClass {
				private readonly CharClass outer_CharClass;
				private readonly bool curAlt;
				private readonly AbstractCharClass cc;
		
				public Anonymous_C15(CharClass paramouter_CharClass, bool curAlt_0,
						AbstractCharClass cc_1) {
					this.curAlt = curAlt_0;
					this.cc = cc_1;
					this.outer_CharClass = paramouter_CharClass;
				}
		
				public override bool Contains(int ch) {
					return (curAlt ^ outer_CharClass.bits.Get(ch))
							|| ((curAlt ^ outer_CharClass.inverted) ^ cc
									.Contains(ch));
				}
			}
	
		public sealed class Anonymous_C14 : AbstractCharClass {
			private readonly bool curAlt;
			private readonly AbstractCharClass cc;
			private readonly AbstractCharClass nb;
	
			public Anonymous_C14(bool curAlt_0, AbstractCharClass cc_1,
					AbstractCharClass nb_2) {
				this.curAlt = curAlt_0;
				this.cc = cc_1;
				this.nb = nb_2;
			}
	
			public override bool Contains(int ch) {
				return !(curAlt ^ (nb.Contains(ch) || cc
						.Contains(ch)));
			}
		}
	
		public sealed class Anonymous_C13 : AbstractCharClass {
			private readonly bool curAlt;
			private readonly AbstractCharClass cc;
			private readonly AbstractCharClass nb;
	
			public Anonymous_C13(bool curAlt_0, AbstractCharClass cc_1,
					AbstractCharClass nb_2) {
				this.curAlt = curAlt_0;
				this.cc = cc_1;
				this.nb = nb_2;
			}
	
			public override bool Contains(int ch) {
				return curAlt
						^ (nb.Contains(ch) || cc.Contains(ch));
			}
		}
	
		public sealed class Anonymous_C12 : AbstractCharClass {
			private readonly AbstractCharClass clazz;
	
			public Anonymous_C12(AbstractCharClass clazz_0) {
				this.clazz = clazz_0;
			}
	
			public override bool Contains(int ch) {
				return !clazz.Contains(ch);
			}
		}
	
		public sealed class Anonymous_C11 : AbstractCharClass {
			private readonly AbstractCharClass clazz;
	
			public Anonymous_C11(AbstractCharClass clazz_0) {
				this.clazz = clazz_0;
			}
	
			public override bool Contains(int ch) {
				return clazz.Contains(ch);
			}
		}
	
		public sealed class Anonymous_C10 : AbstractCharClass {
				private readonly CharClass outer_CharClass;
				private readonly AbstractCharClass clazz;
				private readonly bool curAlt;
		
				public Anonymous_C10(CharClass paramouter_CharClass,
						AbstractCharClass clazz_0, bool curAlt_1) {
					this.clazz = clazz_0;
					this.curAlt = curAlt_1;
					this.outer_CharClass = paramouter_CharClass;
				}
		
				public override bool Contains(int ch) {
					return !(clazz.Contains(ch) || (curAlt ^ outer_CharClass.bits
							.Get(ch)));
				}
			}
	
		public sealed class Anonymous_C9 : AbstractCharClass {
				private readonly CharClass outer_CharClass;
				private readonly bool curAlt;
				private readonly AbstractCharClass clazz;
		
				public Anonymous_C9(CharClass paramouter_CharClass, bool curAlt_0,
						AbstractCharClass clazz_1) {
					this.curAlt = curAlt_0;
					this.clazz = clazz_1;
					this.outer_CharClass = paramouter_CharClass;
				}
		
				public override bool Contains(int ch) {
					return clazz.Contains(ch)
							|| (curAlt ^ outer_CharClass.bits.Get(ch));
				}
			}
	
		public sealed class Anonymous_C8 : AbstractCharClass {
			private readonly AbstractCharClass clazz;
			private readonly AbstractCharClass nb;
			private readonly bool curAlt;
	
			public Anonymous_C8(AbstractCharClass clazz_0, AbstractCharClass nb_1,
					bool curAlt_2) {
				this.clazz = clazz_0;
				this.nb = nb_1;
				this.curAlt = curAlt_2;
			}
	
			public override bool Contains(int ch) {
				return !((curAlt ^ nb.Contains(ch)) || clazz
						.Contains(ch));
			}
		}
	
		public sealed class Anonymous_C7 : AbstractCharClass {
			private readonly bool curAlt;
			private readonly AbstractCharClass clazz;
			private readonly AbstractCharClass nb;
	
			public Anonymous_C7(bool curAlt_0, AbstractCharClass clazz_1,
					AbstractCharClass nb_2) {
				this.curAlt = curAlt_0;
				this.clazz = clazz_1;
				this.nb = nb_2;
			}
	
			public override bool Contains(int ch) {
				return (curAlt ^ nb.Contains(ch))
						|| clazz.Contains(ch);
			}
		}
	
		public sealed class Anonymous_C6 : AbstractCharClass {
			private readonly AbstractCharClass clazz;
	
			public Anonymous_C6(AbstractCharClass clazz_0) {
				this.clazz = clazz_0;
			}
	
			public override bool Contains(int ch) {
				return !clazz.Contains(ch);
			}
		}
	
		public sealed class Anonymous_C5 : AbstractCharClass {
			private readonly AbstractCharClass clazz;
	
			public Anonymous_C5(AbstractCharClass clazz_0) {
				this.clazz = clazz_0;
			}
	
			public override bool Contains(int ch) {
				return clazz.Contains(ch);
			}
		}
	
		public sealed class Anonymous_C4 : AbstractCharClass {
				private readonly CharClass outer_CharClass;
				private readonly bool curAlt;
				private readonly AbstractCharClass clazz;
		
				public Anonymous_C4(CharClass paramouter_CharClass, bool curAlt_0,
						AbstractCharClass clazz_1) {
					this.curAlt = curAlt_0;
					this.clazz = clazz_1;
					this.outer_CharClass = paramouter_CharClass;
				}
		
				public override bool Contains(int ch) {
					return !(clazz.Contains(ch) && (curAlt ^ outer_CharClass.bits
							.Get(ch)));
				}
			}
	
		public sealed class Anonymous_C3 : AbstractCharClass {
				private readonly CharClass outer_CharClass;
				private readonly AbstractCharClass clazz;
				private readonly bool curAlt;
		
				public Anonymous_C3(CharClass paramouter_CharClass,
						AbstractCharClass clazz_0, bool curAlt_1) {
					this.clazz = clazz_0;
					this.curAlt = curAlt_1;
					this.outer_CharClass = paramouter_CharClass;
				}
		
				public override bool Contains(int ch) {
					return clazz.Contains(ch)
							&& (curAlt ^ outer_CharClass.bits.Get(ch));
				}
			}
	
		public sealed class Anonymous_C2 : AbstractCharClass {
			private readonly bool curAlt;
			private readonly AbstractCharClass nb;
			private readonly AbstractCharClass clazz;
	
			public Anonymous_C2(bool curAlt_0, AbstractCharClass nb_1,
					AbstractCharClass clazz_2) {
				this.curAlt = curAlt_0;
				this.nb = nb_1;
				this.clazz = clazz_2;
			}
	
			public override bool Contains(int ch) {
				return !((curAlt ^ nb.Contains(ch)) && clazz
						.Contains(ch));
			}
		}
	
		public sealed class Anonymous_C1 : AbstractCharClass {
			private readonly bool curAlt;
			private readonly AbstractCharClass nb;
			private readonly AbstractCharClass clazz;
	
			public Anonymous_C1(bool curAlt_0, AbstractCharClass nb_1,
					AbstractCharClass clazz_2) {
				this.curAlt = curAlt_0;
				this.nb = nb_1;
				this.clazz = clazz_2;
			}
	
			public override bool Contains(int ch) {
				return (curAlt ^ nb.Contains(ch))
						&& clazz.Contains(ch);
			}
		}
	
		public sealed class Anonymous_C0 : AbstractCharClass {
			private readonly BitSet bs;
	
			public Anonymous_C0(BitSet bs_0) {
				this.bs = bs_0;
			}
	
			public override bool Contains(int ch) {
				return this.alt ^ bs.Get(ch);
			}
	
			public override String ToString() {
				StringBuilder temp = new StringBuilder();
				for (int i = bs.NextSetBit(0); i >= 0; i = bs
						.NextSetBit(i + 1)) {
                            temp.Append(Character.ToChars(i));
					temp.Append('|');
				}
	
				if (temp.Length > 0)
					temp.Remove(temp.Length - 1,1);
	
				return temp.ToString();
			}
		}
	
		// Flag indicates if we add supplement upper/lower case
		internal bool ci;
	
		internal bool uci;
	
		// Flag indicates if there are unicode supplements
		internal bool hasUCI;
	
		internal bool invertedSurrogates;
	
		internal bool inverted;
	
		internal bool hideBits;
	
		internal BitSet bits;
	
		internal AbstractCharClass nonBitSet;
	
		public CharClass() {
			this.ci = false;
			this.uci = false;
			this.hasUCI = false;
			this.invertedSurrogates = false;
			this.inverted = false;
			this.hideBits = false;
			this.bits = new BitSet();
			this.nonBitSet = null;
		}
	
		public CharClass(bool ci_0, bool uci_1) {
			this.ci = false;
			this.uci = false;
			this.hasUCI = false;
			this.invertedSurrogates = false;
			this.inverted = false;
			this.hideBits = false;
			this.bits = new BitSet();
			this.nonBitSet = null;
			this.ci = ci_0;
			this.uci = uci_1;
		}
	
		public CharClass(bool negative, bool ci_0, bool uci_1) : this(ci_0, uci_1) {
			SetNegative(negative);
		}
	
		/*
		 * We can use this method safely even if nonBitSet != null 
		 * due to specific of range constructions in regular expressions.
		 */
		public CharClass Add(int ch) {
			if (ci) {
				if ((ch >= 'a' && ch <= 'z') || (ch >= 'A' && ch <= 'Z')) {
					if (!inverted) {
						bits.Set(Pattern.GetSupplement((char) ch));
					} else {
						bits.Clear(Pattern.GetSupplement((char) ch));
					}
				} else if (uci && ch > 128) {
					hasUCI = true;
                    ch = Character.ToLowerCase(Character.ToUpperCase(ch));
					// return this;
				}
			}
	
			if (ILOG.J2CsMapping.RegEx.Lexer.IsHighSurrogate(ch) || ILOG.J2CsMapping.RegEx.Lexer.IsLowSurrogate(ch)) {
				if (!invertedSurrogates) {
                    lowHighSurrogates.Set(ch - Character.MIN_SURROGATE);
				} else {
                    lowHighSurrogates.Clear(ch - Character.MIN_SURROGATE);
				}
			}
	
			if (!inverted) {
				bits.Set(ch);
			} else
				bits.Clear(ch);
	
			if (!mayContainSupplCodepoints
                    && Character.IsSupplementaryCodePoint(ch))
            {
				mayContainSupplCodepoints = true;
			}
	
			return this;
		}
	
		/*
		 * The difference between add(AbstractCharClass) and union(AbstractCharClass)
		 * is that add() is used for constructions like "[^abc\\d]"
		 * (this pattern doesn't match "1")
		 * while union is used for constructions like "[^abc[\\d]]"
		 * (this pattern matches "1").
		 */
		public CharClass Add(AbstractCharClass cc_0) {
	
			if (!mayContainSupplCodepoints && cc_0.mayContainSupplCodepoints) {
				mayContainSupplCodepoints = true;
			}
	
			if (!invertedSurrogates) {
	
				//A | !B = ! ((A ^ B) & B)
				if (cc_0.altSurrogates) {
					lowHighSurrogates.Xor(cc_0.GetLowHighSurrogates());
					lowHighSurrogates.And(cc_0.GetLowHighSurrogates());
					altSurrogates = !altSurrogates;
					invertedSurrogates = true;
	
					//A | B    
				} else {
					lowHighSurrogates.Or(cc_0.GetLowHighSurrogates());
				}
			} else {
	
				//!A | !B = !(A & B) 
				if (cc_0.altSurrogates) {
					lowHighSurrogates.And(cc_0.GetLowHighSurrogates());
	
					//!A | B = !(A & !B)
				} else {
					lowHighSurrogates.AndNot(cc_0.GetLowHighSurrogates());
				}
			}
	
			if (!hideBits && cc_0.GetBits() != null) {
				if (!inverted) {
	
					//A | !B = ! ((A ^ B) & B)
					if (cc_0.IsNegative()) {
						bits.Xor(cc_0.GetBits());
						bits.And(cc_0.GetBits());
						alt = !alt;
						inverted = true;
	
						//A | B    
					} else {
						bits.Or(cc_0.GetBits());
					}
				} else {
	
					//!A | !B = !(A & B) 
					if (cc_0.IsNegative()) {
						bits.And(cc_0.GetBits());
	
						//!A | B = !(A & !B)
					} else {
						bits.AndNot(cc_0.GetBits());
					}
				}
			} else {
				bool curAlt_1 = alt;
	
				if (nonBitSet == null) {
	
					if (curAlt_1 && !inverted && bits.IsEmpty()) {
						nonBitSet = new CharClass.Anonymous_C17 (cc_0);
						//alt = true;
					} else {
	
						/*
						 * We keep the value of alt unchanged for 
						 * constructions like [^[abc]fgb] by using
						 * the formula a ^ b == !a ^ !b.
						 */
						if (curAlt_1) {
							nonBitSet = new CharClass.Anonymous_C16 (this, curAlt_1, cc_0);
							//alt = true
						} else {
							nonBitSet = new CharClass.Anonymous_C15 (this, curAlt_1, cc_0);
							//alt = false
						}
					}
	
					hideBits = true;
				} else {
					AbstractCharClass nb_2 = nonBitSet;
	
					if (curAlt_1) {
						nonBitSet = new CharClass.Anonymous_C14 (curAlt_1, cc_0, nb_2);
						//alt = true
					} else {
						nonBitSet = new CharClass.Anonymous_C13 (curAlt_1, cc_0, nb_2);
						//alt = false                    
					}
				}
			}
	
			return this;
		}
	
		public CharClass Add(int st, int end) {
			if (st > end)
				throw new ArgumentException();
			if (!ci
	
			//no intersection with surrogate characters
                    && (end < Character.MIN_SURROGATE || st > Character.MAX_SURROGATE))
            {
				if (!inverted) {
					bits.Set(st, end + 1);
				} else {
					bits.Clear(st, end + 1);
				}
			} else {
				for (int i = st; i < end + 1; i++) {
					Add(i);
				}
			}
			return this;
		}
	
		// OR operation
		public void Union(AbstractCharClass clazz_0) {
			if (!mayContainSupplCodepoints && clazz_0.mayContainSupplCodepoints) {
				mayContainSupplCodepoints = true;
			}
	
			if (clazz_0.HasUCI())
				this.hasUCI = true;
	
			if (altSurrogates ^ clazz_0.altSurrogates) {
	
				//!A | B = !(A & !B) 
				if (altSurrogates) {
					lowHighSurrogates.AndNot(clazz_0.GetLowHighSurrogates());
	
					//A | !B = !((A ^ B) & B)
				} else {
					lowHighSurrogates.Xor(clazz_0.GetLowHighSurrogates());
					lowHighSurrogates.And(clazz_0.GetLowHighSurrogates());
					altSurrogates = true;
				}
	
			} else {
	
				//!A | !B = !(A & B)
				if (altSurrogates) {
					lowHighSurrogates.And(clazz_0.GetLowHighSurrogates());
	
					//A | B
				} else {
					lowHighSurrogates.Or(clazz_0.GetLowHighSurrogates());
				}
			}
	
			if (!hideBits && clazz_0.GetBits() != null) {
				if (alt ^ clazz_0.IsNegative()) {
	
					//!A | B = !(A & !B) 
					if (alt) {
						bits.AndNot(clazz_0.GetBits());
	
						//A | !B = !((A ^ B) & B)
					} else {
						bits.Xor(clazz_0.GetBits());
						bits.And(clazz_0.GetBits());
						alt = true;
					}
	
				} else {
	
					//!A | !B = !(A & B)
					if (alt) {
						bits.And(clazz_0.GetBits());
	
						//A | B
					} else {
						bits.Or(clazz_0.GetBits());
					}
				}
			} else {
				bool curAlt_1 = alt;
	
				if (nonBitSet == null) {
	
					if (!inverted && bits.IsEmpty()) {
						if (curAlt_1) {
							nonBitSet = new CharClass.Anonymous_C12 (clazz_0);
							//alt = true
						} else {
							nonBitSet = new CharClass.Anonymous_C11 (clazz_0);
							//alt = false
						}
					} else {
	
						if (curAlt_1) {
							nonBitSet = new CharClass.Anonymous_C10 (this, clazz_0, curAlt_1);
							//alt = true
						} else {
							nonBitSet = new CharClass.Anonymous_C9 (this, curAlt_1, clazz_0);
							//alt = false                        
						}
					}
					hideBits = true;
				} else {
					AbstractCharClass nb_2 = nonBitSet;
	
					if (curAlt_1) {
						nonBitSet = new CharClass.Anonymous_C8 (clazz_0, nb_2, curAlt_1);
						//alt = true
					} else {
						nonBitSet = new CharClass.Anonymous_C7 (curAlt_1, clazz_0, nb_2);
						//alt = false                    
					}
				}
			}
		}
	
		// AND operation
		public void Intersection(AbstractCharClass clazz_0) {
			if (!mayContainSupplCodepoints && clazz_0.mayContainSupplCodepoints) {
				mayContainSupplCodepoints = true;
			}
	
			if (clazz_0.HasUCI())
				this.hasUCI = true;
	
			if (altSurrogates ^ clazz_0.altSurrogates) {
	
				//!A & B = ((A ^ B) & B)
				if (altSurrogates) {
					lowHighSurrogates.Xor(clazz_0.GetLowHighSurrogates());
					lowHighSurrogates.And(clazz_0.GetLowHighSurrogates());
					altSurrogates = false;
	
					//A & !B
				} else {
					lowHighSurrogates.AndNot(clazz_0.GetLowHighSurrogates());
				}
			} else {
	
				//!A & !B = !(A | B)
				if (altSurrogates) {
					lowHighSurrogates.Or(clazz_0.GetLowHighSurrogates());
	
					//A & B
				} else {
					lowHighSurrogates.And(clazz_0.GetLowHighSurrogates());
				}
			}
	
			if (!hideBits && clazz_0.GetBits() != null) {
	
				if (alt ^ clazz_0.IsNegative()) {
	
					//!A & B = ((A ^ B) & B)
					if (alt) {
						bits.Xor(clazz_0.GetBits());
						bits.And(clazz_0.GetBits());
						alt = false;
	
						//A & !B
					} else {
						bits.AndNot(clazz_0.GetBits());
					}
				} else {
	
					//!A & !B = !(A | B)
					if (alt) {
						bits.Or(clazz_0.GetBits());
	
						//A & B
					} else {
						bits.And(clazz_0.GetBits());
					}
				}
			} else {
				bool curAlt_1 = alt;
	
				if (nonBitSet == null) {
	
					if (!inverted && bits.IsEmpty()) {
						if (curAlt_1) {
							nonBitSet = new CharClass.Anonymous_C6 (clazz_0);
							//alt = true
						} else {
							nonBitSet = new CharClass.Anonymous_C5 (clazz_0);
							//alt = false
						}
					} else {
	
						if (curAlt_1) {
							nonBitSet = new CharClass.Anonymous_C4 (this, curAlt_1, clazz_0);
							//alt = true
						} else {
							nonBitSet = new CharClass.Anonymous_C3 (this, clazz_0, curAlt_1);
							//alt = false                        
						}
					}
					hideBits = true;
				} else {
					AbstractCharClass nb_2 = nonBitSet;
	
					if (curAlt_1) {
						nonBitSet = new CharClass.Anonymous_C2 (curAlt_1, nb_2, clazz_0);
						//alt = true
					} else {
						nonBitSet = new CharClass.Anonymous_C1 (curAlt_1, nb_2, clazz_0);
						//alt = false                    
					}
				}
			}
		}
	
		/// <summary>
		/// Returns <c>true</c> if character class contains symbol specified,
		/// <c>false</c> otherwise. Note: #setNegative() method changes the
		/// meaning of contains method;
		/// </summary>
		///
		/// <param name="ch"></param>
		/// <returns><c>true</c> if character class contains symbol specified;
		/// TODO: currently <c>character class</c> implementation based on
		/// BitSet, but this implementation possibly will be turned to combined
		/// BitSet(for first 256 symbols) and Black/Red tree for the rest of UTF.</returns>
		public override bool Contains(int ch) {
			if (nonBitSet == null) {
				return this.alt ^ bits.Get(ch);
			} else {
				return alt ^ nonBitSet.Contains(ch);
			}
		}
	
		protected internal override BitSet GetBits() {
			if (hideBits)
				return null;
			return bits;
		}
	
		protected internal override BitSet GetLowHighSurrogates() {
			return lowHighSurrogates;
		}
	
		public override AbstractCharClass GetInstance() {
	
			if (nonBitSet == null) {
				BitSet bs_0 = GetBits();
	
				AbstractCharClass res = new CharClass.Anonymous_C0 (bs_0);
				return res.SetNegative(IsNegative());
			} else {
				return this;
			}
		}
	
		//for debugging purposes only
		public override String ToString() {
			StringBuilder temp = new StringBuilder();
			for (int i = bits.NextSetBit(0); i >= 0; i = bits.NextSetBit(i + 1)) {
                temp.Append(Character.ToChars(i));
				temp.Append('|');
			}
	
			if (temp.Length > 0)
				temp.Remove(temp.Length - 1,1);
	
			return temp.ToString();
		}
	
		public override bool HasUCI() {
			return hasUCI;
		}
	}
}
