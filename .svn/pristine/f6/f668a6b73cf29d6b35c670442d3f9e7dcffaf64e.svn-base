/*
 *   Copyright (C) 1996-2007, International Business Machines
 *   Corporation and others.  All Rights Reserved.
 */

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:48 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Util {
	
	using IBM.ICU.Impl;
	using IBM.ICU.Text;
	using ILOG.J2CsMapping.Collections;
	using ILOG.J2CsMapping.Collections.Generics;
	using ILOG.J2CsMapping.IO;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.Globalization;
	using System.IO;
	using System.Resources;
	using System.Runtime.CompilerServices;
	using System.Runtime.Serialization;
	using System.Text;
     using ILOG.J2CsMapping.Util;
	
	/// <summary>
	/// <c>Calendar</c> is an abstract base class for converting between a
	/// <c>Date</c> object and a set of integer fields such as
	/// <c>YEAR</c>, <c>MONTH</c>, <c>DAY</c>, <c>HOUR</c>,
	/// and so on. (A <c>Date</c> object represents a specific instant in time
	/// with millisecond precision. See <see cref="null"/> for information about the
	/// <c>Date</c> class.)
	/// <p>
	/// <b>Note:</b> This class is similar, but not identical, to the class
	/// <c>java.util.Calendar</c>. Changes are detailed below.
	/// <p>
	/// Subclasses of <c>Calendar</c> interpret a <c>Date</c> according
	/// to the rules of a specific calendar system. ICU4J contains several subclasses
	/// implementing different international calendar systems.
	/// <p>
	/// Like other locale-sensitive classes, <c>Calendar</c> provides a class
	/// method, <c>getInstance</c>, for getting a generally useful object of
	/// this type. <c>Calendar</c>'s <c>getInstance</c> method returns a
	/// calendar of a type appropriate to the locale, whose time fields have been
	/// initialized with the current date and time: <blockquote>
	/// <pre>
	/// Calendar rightNow = Calendar.getInstance()
	/// </pre>
	/// </blockquote>
	/// <p>
	/// When a <c>ULocale</c> is used by <c>getInstance</c>, its '
	/// <c>calendar</c>' tag and value are retrieved if present. If a
	/// recognized value is supplied, a calendar is provided and configured as
	/// appropriate. Currently recognized tags are "buddhist", "chinese", "coptic",
	/// "ethiopic", "gregorian", "hebrew", "islamic", "islamic-civil", "japanese",
	/// and "taiwan". For example: <blockquote>
	/// <pre>
	/// Calendar cal = Calendar.getInstance(new ULocale(&quot;en_US@calendar=japanese&quot;));
	/// </pre>
	/// </blockquote> will return an instance of JapaneseCalendar (using en_US
	/// conventions for minimum days in first week, start day of week, et cetera).
	/// <p>
	/// A <c>Calendar</c> object can produce all the time field values needed
	/// to implement the date-time formatting for a particular language and calendar
	/// style (for example, Japanese-Gregorian, Japanese-Traditional).
	/// <c>Calendar</c> defines the range of values returned by certain fields,
	/// as well as their meaning. For example, the first month of the year has value
	/// <c>MONTH</c> == <c>JANUARY</c> for all calendars. Other values
	/// are defined by the concrete subclass, such as <c>ERA</c> and
	/// <c>YEAR</c>. See individual field documentation and subclass
	/// documentation for details.
	/// <p>
	/// When a <c>Calendar</c> is <em>lenient</em>, it accepts a wider range of
	/// field values than it produces. For example, a lenient
	/// <c>GregorianCalendar</c> interprets <c>MONTH</c> ==
	/// <c>JANUARY</c>, <c>DAY_OF_MONTH</c> == 32 as February 1. A
	/// non-lenient <c>GregorianCalendar</c> throws an exception when given
	/// out-of-range field settings. When calendars recompute field values for return
	/// by <c>get()</c>, they normalize them. For example, a
	/// <c>GregorianCalendar</c> always produces <c>DAY_OF_MONTH</c>
	/// values between 1 and the length of the month.
	/// <p>
	/// <c>Calendar</c> defines a locale-specific seven day week using two
	/// parameters: the first day of the week and the minimal days in first week
	/// (from 1 to 7). These numbers are taken from the locale resource data when a
	/// <c>Calendar</c> is constructed. They may also be specified explicitly
	/// through the API.
	/// <p>
	/// When setting or getting the <c>WEEK_OF_MONTH</c> or
	/// <c>WEEK_OF_YEAR</c> fields, <c>Calendar</c> must determine the
	/// first week of the month or year as a reference point. The first week of a
	/// month or year is defined as the earliest seven day period beginning on
	/// <c>getFirstDayOfWeek()</c> and containing at least
	/// <c>getMinimalDaysInFirstWeek()</c> days of that month or year. Weeks
	/// numbered ..., -1, 0 precede the first week; weeks numbered 2, 3,... follow
	/// it. Note that the normalized numbering returned by <c>get()</c> may be
	/// different. For example, a specific <c>Calendar</c> subclass may
	/// designate the week before week 1 of a year as week <em>n</em> of the previous
	/// year.
	/// <p>
	/// When computing a <c>Date</c> from time fields, two special
	/// circumstances may arise: there may be insufficient information to compute the
	/// <c>Date</c> (such as only year and month but no day in the month), or
	/// there may be inconsistent information (such as "Tuesday, July 15, 1996" --
	/// July 15, 1996 is actually a Monday).
	/// <p>
	/// <strong>Insufficient information.</strong> The calendar will use default
	/// information to specify the missing fields. This may vary by calendar; for the
	/// Gregorian calendar, the default for a field is the same as that of the start
	/// of the epoch: i.e., YEAR = 1970, MONTH = JANUARY, DATE = 1, etc.
	/// <p>
	/// <strong>Inconsistent information.</strong> If fields conflict, the calendar
	/// will give preference to fields set more recently. For example, when
	/// determining the day, the calendar will look for one of the following
	/// combinations of fields. The most recent combination, as determined by the
	/// most recently set single field, will be used.
	/// <blockquote>
	/// <pre>
	/// MONTH + DAY_OF_MONTH
	/// MONTH + WEEK_OF_MONTH + DAY_OF_WEEK
	/// MONTH + DAY_OF_WEEK_IN_MONTH + DAY_OF_WEEK
	/// DAY_OF_YEAR
	/// DAY_OF_WEEK + WEEK_OF_YEAR
	/// </pre>
	/// </blockquote>
	/// For the time of day:
	/// <blockquote>
	/// <pre>
	/// HOUR_OF_DAY
	/// AM_PM + HOUR
	/// </pre>
	/// </blockquote>
	/// <p>
	/// <strong>Note:</strong> for some non-Gregorian calendars, different fields may
	/// be necessary for complete disambiguation. For example, a full specification
	/// of the historial Arabic astronomical calendar requires year, month,
	/// day-of-month <em>and</em> day-of-week in some cases.
	/// <p>
	/// <strong>Note:</strong> There are certain possible ambiguities in
	/// interpretation of certain singular times, which are resolved in the following
	/// ways:
	/// <ol>
	/// <li>24:00:00 "belongs" to the following day. That is, 23:59 on Dec 31, 1969
	/// &lt; 24:00 on Jan 1, 1970 &lt; 24:01:00 on Jan 1, 1970
	/// <li>Although historically not precise, midnight also belongs to "am", and
	/// noon belongs to "pm", so on the same day, 12:00 am (midnight) &lt; 12:01 am,
	/// and 12:00 pm (noon) &lt; 12:01 pm
	/// </ol>
	/// <p>
	/// The date or time format strings are not part of the definition of a calendar,
	/// as those must be modifiable or overridable by the user at runtime. Use<see cref="null"/> to format dates.
	/// <p>
	/// <strong>Field manipulation methods</strong>
	/// </p>
	/// <p>
	/// <c>Calendar</c> fields can be changed using three methods:
	/// <c>set()</c>, <c>add()</c>, and <c>roll()</c>.
	/// </p>
	/// <p>
	/// <strong><c>set(f, value)</c></strong> changes field <c>f</c> to
	/// <c>value</c>. In addition, it sets an internal member variable to
	/// indicate that field <c>f</c> has been changed. Although field
	/// <c>f</c> is changed immediately, the calendar's milliseconds is not
	/// recomputed until the next call to <c>get()</c>, <c>getTime()</c>,
	/// or <c>getTimeInMillis()</c> is made. Thus, multiple calls to
	/// <c>set()</c> do not trigger multiple, unnecessary computations. As a
	/// result of changing a field using <c>set()</c>, other fields may also
	/// change, depending on the field, the field value, and the calendar system. In
	/// addition, <c>get(f)</c> will not necessarily return <c>value</c>
	/// after the fields have been recomputed. The specifics are determined by the
	/// concrete calendar class.
	/// </p>
	/// <p>
	/// <em>Example</em>: Consider a <c>GregorianCalendar</c> originally set to
	/// August 31, 1999. Calling <code>set(Calendar.MONTH,
	/// Calendar.SEPTEMBER)</code> sets the calendar to September 31, 1999. This is a
	/// temporary internal representation that resolves to October 1, 1999 if
	/// <c>getTime()</c>is then called. However, a call to
	/// <c>set(Calendar.DAY_OF_MONTH, 30)</c> before the call to
	/// <c>getTime()</c> sets the calendar to September 30, 1999, since no
	/// recomputation occurs after <c>set()</c> itself.
	/// </p>
	/// <p>
	/// <strong><c>add(f, delta)</c></strong> adds <c>delta</c> to field
	/// <c>f</c>. This is equivalent to calling <code>set(f,
	/// get(f) + delta)</code> with two adjustments:
	/// </p>
	/// <blockquote>
	/// <p>
	/// <strong>Add rule 1</strong>. The value of field <c>f</c> after the call
	/// minus the value of field <c>f</c> before the call is <c>delta</c>
	/// , modulo any overflow that has occurred in field <c>f</c>. Overflow
	/// occurs when a field value exceeds its range and, as a result, the next larger
	/// field is incremented or decremented and the field value is adjusted back into
	/// its range.
	/// </p>
	/// <p>
	/// <strong>Add rule 2</strong>. If a smaller field is expected to be invariant,
	/// but &nbsp; it is impossible for it to be equal to its prior value because of
	/// changes in its minimum or maximum after field <c>f</c> is changed, then
	/// its value is adjusted to be as close as possible to its expected value. A
	/// smaller field represents a smaller unit of time. <c>HOUR</c> is a
	/// smaller field than <c>DAY_OF_MONTH</c>. No adjustment is made to
	/// smaller fields that are not expected to be invariant. The calendar system
	/// determines what fields are expected to be invariant.
	/// </p>
	/// </blockquote>
	/// <p>
	/// In addition, unlike <c>set()</c>, <c>add()</c> forces an
	/// immediate recomputation of the calendar's milliseconds and all fields.
	/// </p>
	/// <p>
	/// <em>Example</em>: Consider a <c>GregorianCalendar</c> originally set to
	/// August 31, 1999. Calling <code>add(Calendar.MONTH,
	/// 13)</code> sets the calendar to September 30, 2000. <strong>Add rule
	/// 1</strong> sets the <c>MONTH</c> field to September, since adding 13
	/// months to August gives September of the next year. Since
	/// <c>DAY_OF_MONTH</c> cannot be 31 in September in a
	/// <c>GregorianCalendar</c>, <strong>add rule 2</strong> sets the
	/// <c>DAY_OF_MONTH</c> to 30, the closest possible value. Although it is a
	/// smaller field, <c>DAY_OF_WEEK</c> is not adjusted by rule 2, since it
	/// is expected to change when the month changes in a
	/// <c>GregorianCalendar</c>.
	/// </p>
	/// <p>
	/// <strong><c>roll(f, delta)</c></strong> adds <c>delta</c> to field
	/// <c>f</c> without changing larger fields. This is equivalent to calling
	/// <c>add(f, delta)</c> with the following adjustment:
	/// </p>
	/// <blockquote>
	/// <p>
	/// <strong>Roll rule</strong>. Larger fields are unchanged after the call. A
	/// larger field represents a larger unit of time. <c>DAY_OF_MONTH</c> is a
	/// larger field than <c>HOUR</c>.
	/// </p>
	/// </blockquote>
	/// <p>
	/// <em>Example</em>: Consider a <c>GregorianCalendar</c> originally set to
	/// August 31, 1999. Calling <code>roll(Calendar.MONTH,
	/// 8)</code> sets the calendar to April 30, <strong>1999</strong>. Add rule 1
	/// sets the <c>MONTH</c> field to April. Using a
	/// <c>GregorianCalendar</c>, the <c>DAY_OF_MONTH</c> cannot be 31 in
	/// the month April. Add rule 2 sets it to the closest possible value, 30.
	/// Finally, the <strong>roll rule</strong> maintains the <c>YEAR</c> field
	/// value of 1999.
	/// </p>
	/// <p>
	/// <em>Example</em>: Consider a <c>GregorianCalendar</c> originally set to
	/// Sunday June 6, 1999. Calling <c>roll(Calendar.WEEK_OF_MONTH, -1)</c>
	/// sets the calendar to Tuesday June 1, 1999, whereas calling
	/// <c>add(Calendar.WEEK_OF_MONTH, -1)</c> sets the calendar to Sunday May
	/// 30, 1999. This is because the roll rule imposes an additional constraint: The
	/// <c>MONTH</c> must not change when the <c>WEEK_OF_MONTH</c> is
	/// rolled. Taken together with add rule 1, the resultant date must be between
	/// Tuesday June 1 and Saturday June 5. According to add rule 2, the
	/// <c>DAY_OF_WEEK</c>, an invariant when changing the
	/// <c>WEEK_OF_MONTH</c>, is set to Tuesday, the closest possible value to
	/// Sunday (where Sunday is the first day of the week).
	/// </p>
	/// <p>
	/// <strong>Usage model</strong>. To motivate the behavior of <c>add()</c>
	/// and <c>roll()</c>, consider a user interface component with increment
	/// and decrement buttons for the month, day, and year, and an underlying
	/// <c>GregorianCalendar</c>. If the interface reads January 31, 1999 and
	/// the user presses the month increment button, what should it read? If the
	/// underlying implementation uses <c>set()</c>, it might read March 3,
	/// 1999. A better result would be February 28, 1999. Furthermore, if the user
	/// presses the month increment button again, it should read March 31, 1999, not
	/// March 28, 1999. By saving the original date and using either
	/// <c>add()</c> or <c>roll()</c>, depending on whether larger fields
	/// should be affected, the user interface can behave as most users will
	/// intuitively expect.
	/// </p>
	/// <p>
	/// <b>Note:</b> You should always use <see cref="M:IBM.ICU.Util.Calendar.Roll roll"/> and <see cref="M:IBM.ICU.Util.Calendar.Add add"/>rather than attempting to perform arithmetic operations directly on the
	/// fields of a <tt>Calendar</tt>. It is quite possible for <tt>Calendar</tt>
	/// subclasses to have fields with non-linear behavior, for example missing
	/// months or days during non-leap years. The subclasses' <tt>add</tt> and
	/// <tt>roll</tt> methods will take this into account, while simple arithmetic
	/// manipulations may give invalid results.
	/// <p>
	/// <big><big><b>Calendar Architecture in ICU4J</b></big></big>
	/// </p>
	/// <p>
	/// Recently the implementation of <c>Calendar</c> has changed
	/// significantly in order to better support subclassing. The original
	/// <c>Calendar</c> class was designed to support subclassing, but it had
	/// only one implemented subclass, <c>GregorianCalendar</c>. With the
	/// implementation of several new calendar subclasses, including the
	/// <c>BuddhistCalendar</c>, <c>ChineseCalendar</c>,
	/// <c>HebrewCalendar</c>, <c>IslamicCalendar</c>, and
	/// <c>JapaneseCalendar</c>, the subclassing API has been reworked
	/// thoroughly. This section details the new subclassing API and other ways in
	/// which <c>com.ibm.icu.util.Calendar</c> differs from
	/// <c>java.util.Calendar</c>.
	/// </p>
	/// <p>
	/// <big><b>Changes</b></big>
	/// </p>
	/// <p>
	/// Overview of changes between the classic <c>Calendar</c> architecture
	/// and the new architecture.
	/// <ul>
	/// <li>The <c>fields[]</c> array is <c>private</c> now instead of
	/// <c>protected</c>. Subclasses must access it using the methods<see cref="M:IBM.ICU.Util.Calendar.InternalSet(System.Int32, System.Int32)"/> and <see cref="M:IBM.ICU.Util.Calendar.InternalGet(System.Int32)"/>. <b>Motivation:</b> Subclasses
	/// should not directly access data members.</li>
	/// <li>The <c>time</c> long word is <c>private</c> now instead of
	/// <c>protected</c>. Subclasses may access it using the method<see cref="M:IBM.ICU.Util.Calendar.InternalGetTimeInMillis"/>, which does not provoke an update.
	/// <b>Motivation:</b> Subclasses should not directly access data members.</li>
	/// <li>The scope of responsibility of subclasses has been drastically reduced.
	/// As much functionality as possible is implemented in the <c>Calendar</c>
	/// base class. As a result, it is much easier to subclass <c>Calendar</c>.
	/// <b>Motivation:</b> Subclasses should not have to reimplement common code.
	/// Certain behaviors are common across calendar systems: The definition and
	/// behavior of week-related fields and time fields, the arithmetic (<see cref="M:IBM.ICU.Util.Calendar.Add(System.Int32, null)"/> and <see cref="M:IBM.ICU.Util.Calendar.Roll(System.Int32, null)"/>) behavior of many
	/// fields, and the field validation system.</li>
	/// <li>The subclassing API has been completely redesigned.</li>
	/// <li>The <c>Calendar</c> base class contains some Gregorian calendar
	/// algorithmic support that subclasses can use (specifically in<see cref="M:IBM.ICU.Util.Calendar.HandleComputeFields(System.Int32)"/>). Subclasses can use the methods
	/// <c>getGregorianXxx()</c> to obtain precomputed values.
	/// <b>Motivation:</b> This is required by all <c>Calendar</c> subclasses
	/// in order to implement consistent time zone behavior, and Gregorian-derived
	/// systems can use the already computed data.</li>
	/// <li>The <c>FIELD_COUNT</c> constant has been removed. Use<see cref="M:IBM.ICU.Util.Calendar.GetFieldCount"/>. In addition, framework API has been added to allow
	/// subclasses to define additional fields. <b>Motivation: </b>The number of
	/// fields is not constant across calendar systems.</li>
	/// <li>The range of handled dates has been narrowed from +/- ~300,000,000 years
	/// to +/- ~5,000,000 years. In practical terms this should not affect clients.
	/// However, it does mean that client code cannot be guaranteed well-behaved
	/// results with dates such as <c>Date(Long.MIN_VALUE)</c> or
	/// <c>Date(Long.MAX_VALUE)</c>. Instead, the <c>Calendar</c>
	/// constants <see cref="F:IBM.ICU.Util.Calendar.MIN_DATE"/>, <see cref="F:IBM.ICU.Util.Calendar.MAX_DATE"/>, <see cref="F:IBM.ICU.Util.Calendar.MIN_MILLIS"/>,<see cref="F:IBM.ICU.Util.Calendar.MAX_MILLIS"/>, <see cref="F:IBM.ICU.Util.Calendar.MIN_JULIAN"/>, and <see cref="F:IBM.ICU.Util.Calendar.MAX_JULIAN"/> should be
	/// used. <b>Motivation:</b> With the addition of the <see cref="F:IBM.ICU.Util.Calendar.JULIAN_DAY"/> field,
	/// Julian day numbers must be restricted to a 32-bit <c>int</c>. This
	/// restricts the overall supported range. Furthermore, restricting the supported
	/// range simplifies the computations by removing special case code that was used
	/// to accomodate arithmetic overflow at millis near <c>Long.MIN_VALUE</c>
	/// and <c>Long.MAX_VALUE</c>.</li>
	/// <li>New fields are implemented: <see cref="F:IBM.ICU.Util.Calendar.JULIAN_DAY"/> defines single-field
	/// specification of the date. <see cref="F:IBM.ICU.Util.Calendar.MILLISECONDS_IN_DAY"/> defines a
	/// single-field specification of the wall time. <see cref="F:IBM.ICU.Util.Calendar.DOW_LOCAL"/> and<see cref="F:IBM.ICU.Util.Calendar.YEAR_WOY"/> implement localized day-of-week and week-of-year behavior.</li>
	/// <li>Subclasses can access millisecond constants <see cref="F:IBM.ICU.Util.Calendar.ONE_SECOND"/>,<see cref="F:IBM.ICU.Util.Calendar.ONE_MINUTE"/>, <see cref="F:IBM.ICU.Util.Calendar.ONE_HOUR"/>, <see cref="F:IBM.ICU.Util.Calendar.ONE_DAY"/>, and<see cref="F:IBM.ICU.Util.Calendar.ONE_WEEK"/> defined in <c>Calendar</c>.</li>
	/// <li>New API has been added to suport calendar-specific subclasses of
	/// <c>DateFormat</c>.</li>
	/// <li>Several subclasses have been implemented, representing various
	/// international calendar systems.</li>
	/// </ul>
	/// <p>
	/// <big><b>Subclass API</b></big>
	/// </p>
	/// <p>
	/// The original <c>Calendar</c> API was based on the experience of
	/// implementing a only a single subclass, <c>GregorianCalendar</c>. As a
	/// result, all of the subclassing kinks had not been worked out. The new
	/// subclassing API has been refined based on several implemented subclasses.
	/// This includes methods that must be overridden and methods for subclasses to
	/// call. Subclasses no longer have direct access to <c>fields</c> and
	/// <c>stamp</c>. Instead, they have new API to access these. Subclasses
	/// are able to allocate the <c>fields</c> array through a protected
	/// framework method; this allows subclasses to specify additional fields.
	/// </p>
	/// <p>
	/// More functionality has been moved into the base class. The base class now
	/// contains much of the computational machinery to support the Gregorian
	/// calendar. This is based on two things: (1) Many calendars are based on the
	/// Gregorian calendar (such as the Buddhist and Japanese imperial calendars).
	/// (2) <em>All</em> calendars require basic Gregorian support in order to handle
	/// timezone computations.
	/// </p>
	/// <p>
	/// Common computations have been moved into <c>Calendar</c>. Subclasses no
	/// longer compute the week related fields and the time related fields. These are
	/// commonly handled for all calendars by the base class.
	/// </p>
	/// <p>
	/// <b>Subclass computation of time <tt>=&gt;</tt> fields</b>
	/// <p>
	/// The <see cref="F:IBM.ICU.Util.Calendar.ERA"/>, <see cref="F:IBM.ICU.Util.Calendar.YEAR"/>, <see cref="F:IBM.ICU.Util.Calendar.EXTENDED_YEAR"/>, <see cref="F:IBM.ICU.Util.Calendar.MONTH"/>,<see cref="F:IBM.ICU.Util.Calendar.DAY_OF_MONTH"/>, and <see cref="F:IBM.ICU.Util.Calendar.DAY_OF_YEAR"/> fields are computed by the
	/// subclass, based on the Julian day. All other fields are computed by
	/// <c>Calendar</c>.
	/// <ul>
	/// <li>Subclasses should implement <see cref="M:IBM.ICU.Util.Calendar.HandleComputeFields(System.Int32)"/> to compute the<see cref="F:IBM.ICU.Util.Calendar.ERA"/>, <see cref="F:IBM.ICU.Util.Calendar.YEAR"/>, <see cref="F:IBM.ICU.Util.Calendar.EXTENDED_YEAR"/>, <see cref="F:IBM.ICU.Util.Calendar.MONTH"/>,<see cref="F:IBM.ICU.Util.Calendar.DAY_OF_MONTH"/>, and <see cref="F:IBM.ICU.Util.Calendar.DAY_OF_YEAR"/> fields, based on the value of
	/// the <see cref="F:IBM.ICU.Util.Calendar.JULIAN_DAY"/> field. If there are calendar-specific fields not
	/// defined by <c>Calendar</c>, they must also be computed. These are the
	/// only fields that the subclass should compute. All other fields are computed
	/// by the base class, so time and week fields behave in a consistent way across
	/// all calendars. The default version of this method in <c>Calendar</c>
	/// implements a proleptic Gregorian calendar. Within this method, subclasses may
	/// call <c>getGregorianXxx()</c> to obtain the Gregorian calendar month,
	/// day of month, and extended year for the given date.</li>
	/// </ul>
	/// <p>
	/// <b>Subclass computation of fields <tt>=&gt;</tt> time</b>
	/// <p>
	/// The interpretation of most field values is handled entirely by
	/// <c>Calendar</c>. <c>Calendar</c> determines which fields are set,
	/// which are not, which are set more recently, and so on. In addition,
	/// <c>Calendar</c> handles the computation of the time from the time
	/// fields and handles the week-related fields. The only thing the subclass must
	/// do is determine the extended year, based on the year fields, and then, given
	/// an extended year and a month, it must return a Julian day number.
	/// <ul>
	/// <li>Subclasses should implement <see cref="M:IBM.ICU.Util.Calendar.HandleGetExtendedYear"/> to return the
	/// extended year for this calendar system, based on the <see cref="F:IBM.ICU.Util.Calendar.YEAR"/>,<see cref="F:IBM.ICU.Util.Calendar.EXTENDED_YEAR"/>, and any fields that the calendar system uses that are
	/// larger than a year, such as <see cref="F:IBM.ICU.Util.Calendar.ERA"/>.</li>
	/// <li>Subclasses should implement <see cref="M:IBM.ICU.Util.Calendar.HandleComputeMonthStart(System.Int32, System.Int32, System.Boolean)"/> to return
	/// the Julian day number associated with a month and extended year. This is the
	/// Julian day number of the day before the first day of the month. The month
	/// number is zero-based. This computation should not depend on any field values.
	/// </li>
	/// </ul>
	/// <p>
	/// <b>Other methods</b>
	/// <ul>
	/// <li>Subclasses should implement <see cref="M:IBM.ICU.Util.Calendar.HandleGetMonthLength(System.Int32, System.Int32)"/> to return the
	/// number of days in a given month of a given extended year. The month number,
	/// as always, is zero-based.</li>
	/// <li>Subclasses should implement <see cref="M:IBM.ICU.Util.Calendar.HandleGetYearLength(System.Int32)"/> to return the
	/// number of days in the given extended year. This method is used by
	/// <tt>computeWeekFields</tt> to compute the <see cref="F:IBM.ICU.Util.Calendar.WEEK_OF_YEAR"/> and<see cref="F:IBM.ICU.Util.Calendar.YEAR_WOY"/> fields.</li>
	/// <li>Subclasses should implement <see cref="M:IBM.ICU.Util.Calendar.HandleGetLimit(System.Int32, System.Int32)"/> to return the<see cref="F:IBM.ICU.Util.Calendar.MINIMUM"/>, <see cref="F:IBM.ICU.Util.Calendar.GREATEST_MINIMUM"/>, <see cref="F:IBM.ICU.Util.Calendar.LEAST_MAXIMUM"/>, or<see cref="F:IBM.ICU.Util.Calendar.MAXIMUM"/> of a field, depending on the value of <c>limitType</c>
	/// . This method only needs to handle the fields <see cref="F:IBM.ICU.Util.Calendar.ERA"/>, <see cref="F:IBM.ICU.Util.Calendar.YEAR"/>,<see cref="F:IBM.ICU.Util.Calendar.MONTH"/>, <see cref="F:IBM.ICU.Util.Calendar.WEEK_OF_YEAR"/>, <see cref="F:IBM.ICU.Util.Calendar.WEEK_OF_MONTH"/>,<see cref="F:IBM.ICU.Util.Calendar.DAY_OF_MONTH"/>, <see cref="F:IBM.ICU.Util.Calendar.DAY_OF_YEAR"/>, <see cref="F:IBM.ICU.Util.Calendar.DAY_OF_WEEK_IN_MONTH"/>,<see cref="F:IBM.ICU.Util.Calendar.YEAR_WOY"/>, and <see cref="F:IBM.ICU.Util.Calendar.EXTENDED_YEAR"/>. Other fields are invariant
	/// (with respect to calendar system) and are handled by the base class.</li>
	/// <li>Optionally, subclasses may override <see cref="M:IBM.ICU.Util.Calendar.ValidateField(System.Int32)"/> to check any
	/// subclass-specific fields. If the field's value is out of range, the method
	/// should throw an <c>IllegalArgumentException</c>. The method may call
	/// <c>super.validateField(field)</c> to handle fields in a generic way,
	/// that is, to compare them to the range <c>getMinimum(field)</c>..
	/// <c>getMaximum(field)</c>.</li>
	/// <li>Optionally, subclasses may override <see cref="M:IBM.ICU.Util.Calendar.HandleCreateFields"/> to create
	/// an <c>int[]</c> array large enough to hold the calendar's fields. This
	/// is only necessary if the calendar defines additional fields beyond those
	/// defined by <c>Calendar</c>. The length of the result must be at least<see cref="F:IBM.ICU.Util.Calendar.BASE_FIELD_COUNT"/> and no more than <see cref="F:IBM.ICU.Util.Calendar.MAX_FIELD_COUNT"/>.</li>
	/// <li>Optionally, subclasses may override <see cref="M:IBM.ICU.Util.Calendar.HandleGetDateFormat(System.String, null)"/> to
	/// create a <c>DateFormat</c> appropriate to this calendar. This is only
	/// required if a calendar subclass redefines the use of a field (for example,
	/// changes the <see cref="F:IBM.ICU.Util.Calendar.ERA"/> field from a symbolic field to a numeric one) or
	/// defines an additional field.</li>
	/// <li>Optionally, subclasses may override <see cref="M:IBM.ICU.Util.Calendar.Roll roll"/> and <see cref="M:IBM.ICU.Util.Calendar.Addadd"/> to handle fields that are discontinuous. For example, in the Hebrew
	/// calendar the month &quot;Adar I&quot; only occurs in leap years; in other
	/// years the calendar jumps from Shevat (month #4) to Adar (month #6). The<see cref="M:IBM.ICU.Util.HebrewCalendar.Add HebrewCalendar.Add"/> and <see cref="M:IBM.ICU.Util.HebrewCalendar.RollHebrewCalendar.Roll"/> methods take this into account, so that adding 1 month
	/// to Shevat gives the proper result (Adar) in a non-leap year. The protected
	/// utility method <see cref="M:IBM.ICU.Util.Calendar.PinField pinField"/> is often useful when implementing
	/// these two methods.</li>
	/// </ul>
	/// <p>
	/// <big><b>Normalized behavior</b></big>
	/// <p>
	/// The behavior of certain fields has been made consistent across all calendar
	/// systems and implemented in <c>Calendar</c>.
	/// <ul>
	/// <li>Time is normalized. Even though some calendar systems transition between
	/// days at sunset or at other times, all ICU4J calendars transition between days
	/// at <em>local zone midnight</em>. This allows ICU4J to centralize the time
	/// computations in <c>Calendar</c> and to maintain basic correpsondences
	/// between calendar systems. Affected fields: <see cref="F:IBM.ICU.Util.Calendar.AM_PM"/>, <see cref="F:IBM.ICU.Util.Calendar.HOUR"/>,<see cref="F:IBM.ICU.Util.Calendar.HOUR_OF_DAY"/>, <see cref="F:IBM.ICU.Util.Calendar.MINUTE"/>, <see cref="F:IBM.ICU.Util.Calendar.SECOND"/>, <see cref="F:IBM.ICU.Util.Calendar.MILLISECOND"/>,<see cref="F:IBM.ICU.Util.Calendar.ZONE_OFFSET"/>, and <see cref="F:IBM.ICU.Util.Calendar.DST_OFFSET"/>.</li>
	/// <li>DST behavior is normalized. Daylight savings time behavior is computed
	/// the same for all calendar systems, and depends on the value of several
	/// <c>GregorianCalendar</c> fields: the <see cref="F:IBM.ICU.Util.Calendar.YEAR"/>, <see cref="F:IBM.ICU.Util.Calendar.MONTH"/>, and<see cref="F:IBM.ICU.Util.Calendar.DAY_OF_MONTH"/>. As a result, <c>Calendar</c> always computes
	/// these fields, even for non-Gregorian calendar systems. These fields are
	/// available to subclasses.</li>
	/// <li>Weeks are normalized. Although locales define the week differently, in
	/// terms of the day on which it starts, and the designation of week number one
	/// of a month or year, they all use a common mechanism. Furthermore, the day of
	/// the week has a simple and consistent definition throughout history. For
	/// example, although the Gregorian calendar introduced a discontinuity when
	/// first instituted, the day of week was not disrupted. For this reason, the
	/// fields <see cref="F:IBM.ICU.Util.Calendar.DAY_OF_WEEK"/>, <code>WEEK_OF_YEAR,
	/// WEEK_OF_MONTH</code>, <see cref="F:IBM.ICU.Util.Calendar.DAY_OF_WEEK_IN_MONTH"/>, <see cref="F:IBM.ICU.Util.Calendar.DOW_LOCAL"/>,<see cref="F:IBM.ICU.Util.Calendar.YEAR_WOY"/> are all computed in a consistent way in the base class,
	/// based on the <see cref="F:IBM.ICU.Util.Calendar.EXTENDED_YEAR"/>, <see cref="F:IBM.ICU.Util.Calendar.DAY_OF_YEAR"/>, <see cref="F:IBM.ICU.Util.Calendar.MONTH"/>,
	/// and <see cref="F:IBM.ICU.Util.Calendar.DAY_OF_MONTH"/>, which are computed by the subclass.</li>
	/// </ul>
	/// <p>
	/// <big><b>Supported range</b></big>
	/// <p>
	/// The allowable range of <c>Calendar</c> has been narrowed.
	/// <c>GregorianCalendar</c> used to attempt to support the range of dates
	/// with millisecond values from <c>Long.MIN_VALUE</c> to
	/// <c>Long.MAX_VALUE</c>. This introduced awkward constructions (hacks)
	/// which slowed down performance. It also introduced non-uniform behavior at the
	/// boundaries. The new <c>Calendar</c> protocol specifies the maximum
	/// range of supportable dates as those having Julian day numbers of
	/// <c>-0x7F000000</c> to <c>+0x7F000000</c>. This corresponds to
	/// years from ~5,000,000 BCE to ~5,000,000 CE. Programmers should use the
	/// constants <see cref="F:IBM.ICU.Util.Calendar.MIN_DATE"/> (or <see cref="F:IBM.ICU.Util.Calendar.MIN_MILLIS"/> or <see cref="F:IBM.ICU.Util.Calendar.MIN_JULIAN"/>)
	/// and <see cref="F:IBM.ICU.Util.Calendar.MAX_DATE"/> (or <see cref="F:IBM.ICU.Util.Calendar.MAX_MILLIS"/> or <see cref="F:IBM.ICU.Util.Calendar.MAX_JULIAN"/>) in
	/// <c>Calendar</c> to specify an extremely early or extremely late date.
	/// </p>
	/// <p>
	/// <big><b>General notes</b></big>
	/// <ul>
	/// <li>Calendars implementations are <em>proleptic</em>. For example, even
	/// though the Gregorian calendar was not instituted until the 16th century, the
	/// <c>GregorianCalendar</c> class supports dates before the historical
	/// onset of the calendar by extending the calendar system backward in time.
	/// Similarly, the <c>HebrewCalendar</c> extends backward before the start
	/// of its epoch into zero and negative years. Subclasses do not throw exceptions
	/// because a date precedes the historical start of a calendar system. Instead,
	/// they implement <see cref="M:IBM.ICU.Util.Calendar.HandleGetLimit(System.Int32, System.Int32)"/> to return appropriate limits on<see cref="F:IBM.ICU.Util.Calendar.YEAR"/>, <see cref="F:IBM.ICU.Util.Calendar.ERA"/>, etc. fields. Then, if the calendar is set to not
	/// be lenient, out-of-range field values will trigger an exception.</li>
	/// <li>Calendar system subclasses compute a <em>extended
	/// year</em>. This differs from the <see cref="F:IBM.ICU.Util.Calendar.YEAR"/> field in that it ranges
	/// over all integer values, including zero and negative values, and it
	/// encapsulates the information of the <see cref="F:IBM.ICU.Util.Calendar.YEAR"/> field and all larger
	/// fields. Thus, for the Gregorian calendar, the <see cref="F:IBM.ICU.Util.Calendar.EXTENDED_YEAR"/> is
	/// computed as <c>ERA==AD ? YEAR : 1-YEAR</c>. Another example is the
	/// Mayan long count, which has years (<c>KUN</c>) and nested cycles of
	/// years (<c>KATUN</c> and <c>BAKTUN</c>). The Mayan<see cref="F:IBM.ICU.Util.Calendar.EXTENDED_YEAR"/> is computed as <code>TUN + 20/// (KATUN
	/// + 20/// BAKTUN)</code>. The <c>Calendar</c> base class uses the<see cref="F:IBM.ICU.Util.Calendar.EXTENDED_YEAR"/> field to compute the week-related fields.</li>
	/// </ul>
	/// </summary>
	///
	/// <seealso cref="null"/>
	/// <seealso cref="T:IBM.ICU.Util.GregorianCalendar"/>
	/// <seealso cref="T:IBM.ICU.Util.TimeZone"/>
	/// <seealso cref="null"/>
	/// @stable ICU 2.0
	[Serializable]
	public abstract class Calendar : ICloneable, IComparable {
	
	    // Data flow in Calendar
	    // ---------------------
	
	    // The current time is represented in two ways by Calendar: as UTC
	    // milliseconds from the epoch start (1 January 1970 0:00 UTC), and as local
	    // fields such as MONTH, HOUR, AM_PM, etc. It is possible to compute the
	    // millis from the fields, and vice versa. The data needed to do this
	    // conversion is encapsulated by a TimeZone object owned by the Calendar.
	    // The data provided by the TimeZone object may also be overridden if the
	    // user sets the ZONE_OFFSET and/or DST_OFFSET fields directly. The class
	    // keeps track of what information was most recently set by the caller, and
	    // uses that to compute any other information as needed.
	
	    // If the user sets the fields using set(), the data flow is as follows.
	    // This is implemented by the Calendar subclass's computeTime() method.
	    // During this process, certain fields may be ignored. The disambiguation
	    // algorithm for resolving which fields to pay attention to is described
	    // above.
	
	    // local fields (YEAR, MONTH, DATE, HOUR, MINUTE, etc.)
	    // |
	    // | Using Calendar-specific algorithm
	    // V
	    // local standard millis
	    // |
	    // | Using TimeZone or user-set ZONE_OFFSET / DST_OFFSET
	    // V
	    // UTC millis (in time data member)
	
	    // If the user sets the UTC millis using setTime(), the data flow is as
	    // follows. This is implemented by the Calendar subclass's computeFields()
	    // method.
	
	    // UTC millis (in time data member)
	    // |
	    // | Using TimeZone getOffset()
	    // V
	    // local standard millis
	    // |
	    // | Using Calendar-specific algorithm
	    // V
	    // local fields (YEAR, MONTH, DATE, HOUR, MINUTE, etc.)
	
	    // In general, a round trip from fields, through local and UTC millis, and
	    // back out to fields is made when necessary. This is implemented by the
	    // complete() method. Resolving a partial set of fields into a UTC millis
	    // value allows all remaining fields to be generated from that value. If
	    // the Calendar is lenient, the fields are also renormalized to standard
	    // ranges when they are regenerated.
	
	    /// <summary>
	    /// Field number for <c>get</c> and <c>set</c> indicating the
	    /// era, e.g., AD or BC in the Julian calendar. This is a calendar-specific
	    /// value; see subclass documentation.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Util.GregorianCalendar.AD"/>
	    /// <seealso cref="M:IBM.ICU.Util.GregorianCalendar.BC"/>
	    /// @stable ICU 2.0
	    public const int ERA = 0;
	
	    /// <summary>
	    /// Field number for <c>get</c> and <c>set</c> indicating the
	    /// year. This is a calendar-specific value; see subclass documentation.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public const int YEAR = 1;
	
	    /// <summary>
	    /// Field number for <c>get</c> and <c>set</c> indicating the
	    /// month. This is a calendar-specific value. The first month of the year is
	    /// <c>JANUARY</c>; the last depends on the number of months in a year.
	    /// </summary>
	    ///
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.JANUARY"/>
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.FEBRUARY"/>
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.MARCH"/>
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.APRIL"/>
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.MAY"/>
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.JUNE"/>
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.JULY"/>
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.AUGUST"/>
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.SEPTEMBER"/>
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.OCTOBER"/>
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.NOVEMBER"/>
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.DECEMBER"/>
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.UNDECIMBER"/>
	    /// @stable ICU 2.0
	    public const int MONTH = 2;
	
	    /// <summary>
	    /// Field number for <c>get</c> and <c>set</c> indicating the
	    /// week number within the current year. The first week of the year, as
	    /// defined by <c>getFirstDayOfWeek()</c> and
	    /// <c>getMinimalDaysInFirstWeek()</c>, has value 1. Subclasses define
	    /// the value of <c>WEEK_OF_YEAR</c> for days before the first week of
	    /// the year.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.GetFirstDayOfWeek"/>
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.GetMinimalDaysInFirstWeek"/>
	    /// @stable ICU 2.0
	    public const int WEEK_OF_YEAR = 3;
	
	    /// <summary>
	    /// Field number for <c>get</c> and <c>set</c> indicating the
	    /// week number within the current month. The first week of the month, as
	    /// defined by <c>getFirstDayOfWeek()</c> and
	    /// <c>getMinimalDaysInFirstWeek()</c>, has value 1. Subclasses define
	    /// the value of <c>WEEK_OF_MONTH</c> for days before the first week of
	    /// the month.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.GetFirstDayOfWeek"/>
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.GetMinimalDaysInFirstWeek"/>
	    /// @stable ICU 2.0
	    public const int WEEK_OF_MONTH = 4;
	
	    /// <summary>
	    /// Field number for <c>get</c> and <c>set</c> indicating the day
	    /// of the month. This is a synonym for <c>DAY_OF_MONTH</c>. The first
	    /// day of the month has value 1.
	    /// </summary>
	    ///
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.DAY_OF_MONTH"/>
	    /// @stable ICU 2.0
	    public const int DATE = 5;
	
	    /// <summary>
	    /// Field number for <c>get</c> and <c>set</c> indicating the day
	    /// of the month. This is a synonym for <c>DATE</c>. The first day of
	    /// the month has value 1.
	    /// </summary>
	    ///
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.DATE"/>
	    /// @stable ICU 2.0
	    public const int DAY_OF_MONTH = 5;
	
	    /// <summary>
	    /// Field number for <c>get</c> and <c>set</c> indicating the day
	    /// number within the current year. The first day of the year has value 1.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public const int DAY_OF_YEAR = 6;
	
	    /// <summary>
	    /// Field number for <c>get</c> and <c>set</c> indicating the day
	    /// of the week. This field takes values <c>SUNDAY</c>,
	    /// <c>MONDAY</c>, <c>TUESDAY</c>, <c>WEDNESDAY</c>,
	    /// <c>THURSDAY</c>, <c>FRIDAY</c>, and <c>SATURDAY</c>.
	    /// </summary>
	    ///
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.SUNDAY"/>
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.MONDAY"/>
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.TUESDAY"/>
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.WEDNESDAY"/>
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.THURSDAY"/>
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.FRIDAY"/>
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.SATURDAY"/>
	    /// @stable ICU 2.0
	    public const int DAY_OF_WEEK = 7;
	
	    /// <summary>
	    /// Field number for <c>get</c> and <c>set</c> indicating the
	    /// ordinal number of the day of the week within the current month. Together
	    /// with the <c>DAY_OF_WEEK</c> field, this uniquely specifies a day
	    /// within a month. Unlike <c>WEEK_OF_MONTH</c> and
	    /// <c>WEEK_OF_YEAR</c>, this field's value does <em>not</em> depend on
	    /// <c>getFirstDayOfWeek()</c> or
	    /// <c>getMinimalDaysInFirstWeek()</c>. <c>DAY_OF_MONTH 1</c>
	    /// through <c>7</c> always correspond to <code>DAY_OF_WEEK_IN_MONTH
	    /// 1</code>; <c>8</c> through <c>15</c> correspond to
	    /// <c>DAY_OF_WEEK_IN_MONTH 2</c>, and so on.
	    /// <c>DAY_OF_WEEK_IN_MONTH 0</c> indicates the week before
	    /// <c>DAY_OF_WEEK_IN_MONTH 1</c>. Negative values count back from the
	    /// end of the month, so the last Sunday of a month is specified as
	    /// <c>DAY_OF_WEEK = SUNDAY, DAY_OF_WEEK_IN_MONTH = -1</c>. Because
	    /// negative values count backward they will usually be aligned differently
	    /// within the month than positive values. For example, if a month has 31
	    /// days, <c>DAY_OF_WEEK_IN_MONTH -1</c> will overlap
	    /// <c>DAY_OF_WEEK_IN_MONTH 5</c> and the end of <c>4</c>.
	    /// </summary>
	    ///
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.DAY_OF_WEEK"/>
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.WEEK_OF_MONTH"/>
	    /// @stable ICU 2.0
	    public const int DAY_OF_WEEK_IN_MONTH = 8;
	
	    /// <summary>
	    /// Field number for <c>get</c> and <c>set</c> indicating whether
	    /// the <c>HOUR</c> is before or after noon. E.g., at 10:04:15.250 PM
	    /// the <c>AM_PM</c> is <c>PM</c>.
	    /// </summary>
	    ///
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.AM"/>
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.PM"/>
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.HOUR"/>
	    /// @stable ICU 2.0
	    public const int AM_PM = 9;
	
	    /// <summary>
	    /// Field number for <c>get</c> and <c>set</c> indicating the
	    /// hour of the morning or afternoon. <c>HOUR</c> is used for the
	    /// 12-hour clock. E.g., at 10:04:15.250 PM the <c>HOUR</c> is 10.
	    /// </summary>
	    ///
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.AM_PM"/>
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.HOUR_OF_DAY"/>
	    /// @stable ICU 2.0
	    public const int HOUR = 10;
	
	    /// <summary>
	    /// Field number for <c>get</c> and <c>set</c> indicating the
	    /// hour of the day. <c>HOUR_OF_DAY</c> is used for the 24-hour clock.
	    /// E.g., at 10:04:15.250 PM the <c>HOUR_OF_DAY</c> is 22.
	    /// </summary>
	    ///
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.HOUR"/>
	    /// @stable ICU 2.0
	    public const int HOUR_OF_DAY = 11;
	
	    /// <summary>
	    /// Field number for <c>get</c> and <c>set</c> indicating the
	    /// minute within the hour. E.g., at 10:04:15.250 PM the <c>MINUTE</c>
	    /// is 4.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public const int MINUTE = 12;
	
	    /// <summary>
	    /// Field number for <c>get</c> and <c>set</c> indicating the
	    /// second within the minute. E.g., at 10:04:15.250 PM the
	    /// <c>SECOND</c> is 15.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public const int SECOND = 13;
	
	    /// <summary>
	    /// Field number for <c>get</c> and <c>set</c> indicating the
	    /// millisecond within the second. E.g., at 10:04:15.250 PM the
	    /// <c>MILLISECOND</c> is 250.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public const int MILLISECOND = 14;
	
	    /// <summary>
	    /// Field number for <c>get</c> and <c>set</c> indicating the raw
	    /// offset from GMT in milliseconds.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public const int ZONE_OFFSET = 15;
	
	    /// <summary>
	    /// Field number for <c>get</c> and <c>set</c> indicating the
	    /// daylight savings offset in milliseconds.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public const int DST_OFFSET = 16;
	
	    /// <summary>
	    /// Field number for <c>get()</c> and <c>set()</c> indicating the
	    /// extended year corresponding to the <c>WEEK_OF_YEAR</c> field. This
	    /// may be one greater or less than the value of <c>EXTENDED_YEAR</c>.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public const int YEAR_WOY = 17;
	
	    /// <summary>
	    /// Field number for <c>get()</c> and <c>set()</c> indicating the
	    /// localized day of week. This will be a value from 1 to 7 inclusive, with 1
	    /// being the localized first day of the week.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public const int DOW_LOCAL = 18;
	
	    /// <summary>
	    /// Field number for <c>get()</c> and <c>set()</c> indicating the
	    /// extended year. This is a single number designating the year of this
	    /// calendar system, encompassing all supra-year fields. For example, for the
	    /// Julian calendar system, year numbers are positive, with an era of BCE or
	    /// CE. An extended year value for the Julian calendar system assigns
	    /// positive values to CE years and negative values to BCE years, with 1 BCE
	    /// being year 0.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public const int EXTENDED_YEAR = 19;
	
	    /// <summary>
	    /// Field number for <c>get()</c> and <c>set()</c> indicating the
	    /// modified Julian day number. This is different from the conventional
	    /// Julian day number in two regards. First, it demarcates days at local zone
	    /// midnight, rather than noon GMT. Second, it is a local number; that is, it
	    /// depends on the local time zone. It can be thought of as a single number
	    /// that encompasses all the date-related fields.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public const int JULIAN_DAY = 20;
	
	    /// <summary>
	    /// Field number for <c>get()</c> and <c>set()</c> indicating the
	    /// milliseconds in the day. This ranges from 0 to 23:59:59.999 (regardless
	    /// of DST). This field behaves <em>exactly</em> like a composite of all
	    /// time-related fields, not including the zone fields. As such, it also
	    /// reflects discontinuities of those fields on DST transition days. On a day
	    /// of DST onset, it will jump forward. On a day of DST cessation, it will
	    /// jump backward. This reflects the fact that is must be combined with the
	    /// DST_OFFSET field to obtain a unique local time value.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public const int MILLISECONDS_IN_DAY = 21;
	
	    /// <summary>
	    /// The number of fields defined by this class. Subclasses may define
	    /// addition fields starting with this number.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    protected internal const int BASE_FIELD_COUNT = 22;
	
	    /// <summary>
	    /// The maximum number of fields possible. Subclasses must not define more
	    /// total fields than this number.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    protected internal const int MAX_FIELD_COUNT = 32;
	
	    /// <summary>
	    /// Value of the <c>DAY_OF_WEEK</c> field indicating Sunday.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public const int SUNDAY = 1;
	
	    /// <summary>
	    /// Value of the <c>DAY_OF_WEEK</c> field indicating Monday.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public const int MONDAY = 2;
	
	    /// <summary>
	    /// Value of the <c>DAY_OF_WEEK</c> field indicating Tuesday.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public const int TUESDAY = 3;
	
	    /// <summary>
	    /// Value of the <c>DAY_OF_WEEK</c> field indicating Wednesday.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public const int WEDNESDAY = 4;
	
	    /// <summary>
	    /// Value of the <c>DAY_OF_WEEK</c> field indicating Thursday.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public const int THURSDAY = 5;
	
	    /// <summary>
	    /// Value of the <c>DAY_OF_WEEK</c> field indicating Friday.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public const int FRIDAY = 6;
	
	    /// <summary>
	    /// Value of the <c>DAY_OF_WEEK</c> field indicating Saturday.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public const int SATURDAY = 7;
	
	    /// <summary>
	    /// Value of the <c>MONTH</c> field indicating the first month of the
	    /// year.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public const int JANUARY = 0;
	
	    /// <summary>
	    /// Value of the <c>MONTH</c> field indicating the second month of the
	    /// year.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public const int FEBRUARY = 1;
	
	    /// <summary>
	    /// Value of the <c>MONTH</c> field indicating the third month of the
	    /// year.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public const int MARCH = 2;
	
	    /// <summary>
	    /// Value of the <c>MONTH</c> field indicating the fourth month of the
	    /// year.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public const int APRIL = 3;
	
	    /// <summary>
	    /// Value of the <c>MONTH</c> field indicating the fifth month of the
	    /// year.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public const int MAY = 4;
	
	    /// <summary>
	    /// Value of the <c>MONTH</c> field indicating the sixth month of the
	    /// year.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public const int JUNE = 5;
	
	    /// <summary>
	    /// Value of the <c>MONTH</c> field indicating the seventh month of the
	    /// year.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public const int JULY = 6;
	
	    /// <summary>
	    /// Value of the <c>MONTH</c> field indicating the eighth month of the
	    /// year.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public const int AUGUST = 7;
	
	    /// <summary>
	    /// Value of the <c>MONTH</c> field indicating the ninth month of the
	    /// year.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public const int SEPTEMBER = 8;
	
	    /// <summary>
	    /// Value of the <c>MONTH</c> field indicating the tenth month of the
	    /// year.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public const int OCTOBER = 9;
	
	    /// <summary>
	    /// Value of the <c>MONTH</c> field indicating the eleventh month of
	    /// the year.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public const int NOVEMBER = 10;
	
	    /// <summary>
	    /// Value of the <c>MONTH</c> field indicating the twelfth month of the
	    /// year.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public const int DECEMBER = 11;
	
	    /// <summary>
	    /// Value of the <c>MONTH</c> field indicating the thirteenth month of
	    /// the year. Although <c>GregorianCalendar</c> does not use this
	    /// value, lunar calendars do.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public const int UNDECIMBER = 12;
	
	    /// <summary>
	    /// Value of the <c>AM_PM</c> field indicating the period of the day
	    /// from midnight to just before noon.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public const int AM = 0;
	
	    /// <summary>
	    /// Value of the <c>AM_PM</c> field indicating the period of the day
	    /// from noon to just before midnight.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public const int PM = 1;
	
	    /// <summary>
	    /// Value returned by getDayOfWeekType(int dayOfWeek) to indicate a weekday.
	    /// </summary>
	    ///
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.WEEKEND"/>
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.WEEKEND_ONSET"/>
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.WEEKEND_CEASE"/>
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.GetDayOfWeekType(System.Int32)"/>
	    /// @stable ICU 2.0
	    public const int WEEKDAY = 0;
	
	    /// <summary>
	    /// Value returned by getDayOfWeekType(int dayOfWeek) to indicate a weekend
	    /// day.
	    /// </summary>
	    ///
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.WEEKDAY"/>
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.WEEKEND_ONSET"/>
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.WEEKEND_CEASE"/>
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.GetDayOfWeekType(System.Int32)"/>
	    /// @stable ICU 2.0
	    public const int WEEKEND = 1;
	
	    /// <summary>
	    /// Value returned by getDayOfWeekType(int dayOfWeek) to indicate a day that
	    /// starts as a weekday and transitions to the weekend. Call
	    /// getWeekendTransition() to get the point of transition.
	    /// </summary>
	    ///
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.WEEKDAY"/>
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.WEEKEND"/>
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.WEEKEND_CEASE"/>
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.GetDayOfWeekType(System.Int32)"/>
	    /// @stable ICU 2.0
	    public const int WEEKEND_ONSET = 2;
	
	    /// <summary>
	    /// Value returned by getDayOfWeekType(int dayOfWeek) to indicate a day that
	    /// starts as the weekend and transitions to a weekday. Call
	    /// getWeekendTransition() to get the point of transition.
	    /// </summary>
	    ///
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.WEEKDAY"/>
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.WEEKEND"/>
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.WEEKEND_ONSET"/>
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.GetDayOfWeekType(System.Int32)"/>
	    /// @stable ICU 2.0
	    public const int WEEKEND_CEASE = 3;
	
	    /// <summary>
	    /// The number of milliseconds in one second.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    protected internal const int ONE_SECOND = 1000;
	
	    /// <summary>
	    /// The number of milliseconds in one minute.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    protected internal const int ONE_MINUTE = 60 * ONE_SECOND;
	
	    /// <summary>
	    /// The number of milliseconds in one hour.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    protected internal const int ONE_HOUR = 60 * ONE_MINUTE;
	
	    /// <summary>
	    /// The number of milliseconds in one day. Although ONE_DAY and ONE_WEEK can
	    /// fit into ints, they must be longs in order to prevent arithmetic overflow
	    /// when performing (bug 4173516).
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    protected internal const long ONE_DAY = 24 * ONE_HOUR;
	
	    /// <summary>
	    /// The number of milliseconds in one week. Although ONE_DAY and ONE_WEEK can
	    /// fit into ints, they must be longs in order to prevent arithmetic overflow
	    /// when performing (bug 4173516).
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    protected internal const long ONE_WEEK = 7 * ONE_DAY;
	
	    /// <summary>
	    /// The Julian day of the Gregorian epoch, that is, January 1, 1 on the
	    /// Gregorian calendar.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    protected internal const int JAN_1_1_JULIAN_DAY = 1721426;
	
	    /// <summary>
	    /// The Julian day of the epoch, that is, January 1, 1970 on the Gregorian
	    /// calendar.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    protected internal const int EPOCH_JULIAN_DAY = 2440588;
	
	    /// <summary>
	    /// The minimum supported Julian day. This value is equivalent to
	    /// <c>MIN_MILLIS</c> and <c>MIN_DATE</c>.
	    /// </summary>
	    ///
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.JULIAN_DAY"/>
	    /// @stable ICU 2.0
	    protected internal const int MIN_JULIAN = -0x7F000000;
	
	    /// <summary>
	    /// The minimum supported epoch milliseconds. This value is equivalent to
	    /// <c>MIN_JULIAN</c> and <c>MIN_DATE</c>.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    protected internal const long MIN_MILLIS = -184303902528000000L;
	
	    // Get around bug in jikes 1.12 for now. Later, use:
	    // protected static final long MIN_MILLIS = (MIN_JULIAN - EPOCH_JULIAN_DAY)
	    // * ONE_DAY;
	
	    /// <summary>
	    /// The minimum supported <c>Date</c>. This value is equivalent to
	    /// <c>MIN_JULIAN</c> and <c>MIN_MILLIS</c>.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
        protected static internal readonly DateTime MIN_DATE = DateTime.MinValue; // new DateTime((MIN_MILLIS)*10000);
	
	    /// <summary>
	    /// The maximum supported Julian day. This value is equivalent to
	    /// <c>MAX_MILLIS</c> and <c>MAX_DATE</c>.
	    /// </summary>
	    ///
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.JULIAN_DAY"/>
	    /// @stable ICU 2.0
	    protected internal const int MAX_JULIAN = +0x7F000000;
	
	    /// <summary>
	    /// The maximum supported epoch milliseconds. This value is equivalent to
	    /// <c>MAX_JULIAN</c> and <c>MAX_DATE</c>.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    protected internal const long MAX_MILLIS = (MAX_JULIAN - EPOCH_JULIAN_DAY)
	            * ONE_DAY;
	
	    /// <summary>
	    /// The maximum supported <c>Date</c>. This value is equivalent to
	    /// <c>MAX_JULIAN</c> and <c>MAX_MILLIS</c>.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    protected static internal readonly DateTime MAX_DATE = DateTime.MaxValue; //new DateTime((MAX_MILLIS)*10000);
	
	    // Internal notes:
	    // Calendar contains two kinds of time representations: current "time" in
	    // milliseconds, and a set of time "fields" representing the current time.
	    // The two representations are usually in sync, but can get out of sync
	    // as follows.
	    // 1. Initially, no fields are set, and the time is invalid.
	    // 2. If the time is set, all fields are computed and in sync.
	    // 3. If a single field is set, the time is invalid.
	    // Recomputation of the time and fields happens when the object needs
	    // to return a result to the user, or use a result for a computation.
	
	    /// <summary>
	    /// The field values for the currently set time for this calendar. This is an array of at least <c>BASE_FIELD_COUNT</c> integers.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.HandleCreateFields"/>
	    /// @serial
	    protected int[] fields;
	
	    /// <summary>
	    /// Pseudo-time-stamps which specify when each field was set. There are two special values, UNSET and INTERNALLY_SET. Values from MINIMUM_USER_SET to Integer.MAX_VALUE are legal user set values.
	    /// </summary>
	    ///
	    private int[] stamp;
	
	    /// <summary>
	    /// The currently set time for this calendar, expressed in milliseconds after
	    /// January 1, 1970, 0:00:00 GMT.
	    /// </summary>
	    ///
	    /// <seealso cref="null"/>
	    /// @serial
	    private long time;
	
	    /// <summary>
	    /// True if then the value of <c>time</c> is valid. The time is made
	    /// invalid by a change to an item of <c>field[]</c>.
	    /// </summary>
	    ///
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.time"/>
	    /// @serial
        protected bool isTimeSet;
	
	    /// <summary>
	    /// True if <c>fields[]</c> are in sync with the currently set time. If
	    /// false, then the next attempt to get the value of a field will force a
	    /// recomputation of all fields from the current value of <c>time</c>.
	    /// </summary>
	    ///
	    /// @serial
	    protected bool areFieldsSet;
	
	    /// <summary>
	    /// True if all fields have been set. This is only false in a few situations:
	    /// In a newly created, partially constructed object. After a call to
	    /// clear(). In an object just read from a stream using readObject(). Once
	    /// computeFields() has been called this is set to true and stays true until
	    /// one of the above situations recurs.
	    /// </summary>
	    ///
	    /// @serial
	    protected bool areAllFieldsSet;
	
	    /// <summary>
	    /// True if all fields have been virtually set, but have not yet been
	    /// computed. This occurs only in setTimeInMillis(), or after readObject(). A
	    /// calendar set to this state will compute all fields from the time if it
	    /// becomes necessary, but otherwise will delay such computation.
	    /// </summary>
	    ///
        protected bool areFieldsVirtuallySet;
	
	    /// <summary>
	    /// True if this calendar allows out-of-range field values during computation
	    /// of <c>time</c> from <c>fields[]</c>.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.SetLenient(System.Boolean)"/>
	    /// @serial
	    private bool lenient;
	
	    /// <summary>
	    /// The <c>TimeZone</c> used by this calendar. </code>Calendar</code>
	    /// uses the time zone data to translate between locale and GMT time.
	    /// </summary>
	    ///
	    /// @serial
	    private TimeZone zone;
	
	    /// <summary>
	    /// The first day of the week, with possible values <c>SUNDAY</c>,
	    /// <c>MONDAY</c>, etc. This is a locale-dependent value.
	    /// </summary>
	    ///
	    /// @serial
	    private int firstDayOfWeek;
	
	    /// <summary>
	    /// The number of days required for the first week in a month or year, with
	    /// possible values from 1 to 7. This is a locale-dependent value.
	    /// </summary>
	    ///
	    /// @serial
	    private int minimalDaysInFirstWeek;
	
	    /// <summary>
	    /// First day of the weekend in this calendar's locale. Must be in the range
	    /// SUNDAY...SATURDAY (1..7). The weekend starts at weekendOnsetMillis
	    /// milliseconds after midnight on that day of the week. This value is taken
	    /// from locale resource data.
	    /// </summary>
	    ///
	    private int weekendOnset;
	
	    /// <summary>
	    /// Milliseconds after midnight at which the weekend starts on the day of the
	    /// week weekendOnset. Times that are greater than or equal to
	    /// weekendOnsetMillis are considered part of the weekend. Must be in the
	    /// range 0..24///60///60///1000-1. This value is taken from locale resource data.
	    /// </summary>
	    ///
	    private int weekendOnsetMillis;
	
	    /// <summary>
	    /// Day of the week when the weekend stops in this calendar's locale. Must be
	    /// in the range SUNDAY...SATURDAY (1..7). The weekend stops at
	    /// weekendCeaseMillis milliseconds after midnight on that day of the week.
	    /// This value is taken from locale resource data.
	    /// </summary>
	    ///
	    private int weekendCease;
	
	    /// <summary>
	    /// Milliseconds after midnight at which the weekend stops on the day of the
	    /// week weekendCease. Times that are greater than or equal to
	    /// weekendCeaseMillis are considered not to be the weekend. Must be in the
	    /// range 0..24///60///60///1000-1. This value is taken from locale resource data.
	    /// </summary>
	    ///
	    private int weekendCeaseMillis;
	
	    /// <summary>
	    /// Cache to hold the firstDayOfWeek and minimalDaysInFirstWeek of a Locale.
	    /// </summary>
	    ///
	    private static Hashtable cachedLocaleData = new Hashtable(3);
	
	    /// <summary>
	    /// Value of the time stamp <c>stamp[]</c> indicating that a field has
	    /// not been set since the last call to <c>clear()</c>.
	    /// </summary>
	    ///
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.INTERNALLY_SET"/>
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.MINIMUM_USER_STAMP"/>
	    /// @stable ICU 2.0
	    protected internal const int UNSET = 0;
	
	    /// <summary>
	    /// Value of the time stamp <c>stamp[]</c> indicating that a field has
	    /// been set via computations from the time or from other fields.
	    /// </summary>
	    ///
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.UNSET"/>
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.MINIMUM_USER_STAMP"/>
	    /// @stable ICU 2.0
	    protected internal const int INTERNALLY_SET = 1;
	
	    /// <summary>
	    /// If the time stamp <c>stamp[]</c> has a value greater than or equal
	    /// to <c>MINIMUM_USER_SET</c> then it has been set by the user via a
	    /// call to <c>set()</c>.
	    /// </summary>
	    ///
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.UNSET"/>
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.INTERNALLY_SET"/>
	    /// @stable ICU 2.0
	    protected internal const int MINIMUM_USER_STAMP = 2;
	
	    /// <summary>
	    /// The next available value for <c>stamp[]</c>, an internal array.
	    /// </summary>
	    ///
	    /// @serial
	    private int nextStamp;
	
	    // the internal serial version which says which version was written
	    // - 0 (default) for version up to JDK 1.1.5
	    // - 1 for version from JDK 1.1.6, which writes a correct 'time' value
	    // as well as compatible values for other fields. This is a
	    // transitional format.
	    // - 2 (not implemented yet) a future version, in which fields[],
	    // areFieldsSet, and isTimeSet become transient, and isSet[] is
	    // removed. In JDK 1.1.6 we write a format compatible with version 2.
	    // static final int currentSerialVersion = 1;
	
	    /// <summary>
	    /// The version of the serialized data on the stream. Possible values:
	    /// <dl>
	    /// <dt><b>0</b> or not present on stream</dt>
	    /// <dd>
	    /// JDK 1.1.5 or earlier.</dd>
	    /// <dt><b>1</b></dt>
	    /// <dd>
	    /// JDK 1.1.6 or later. Writes a correct 'time' value as well as compatible
	    /// values for other fields. This is a transitional format.</dd>
	    /// </dl>
	    /// When streaming out this class, the most recent format and the highest
	    /// allowable <c>serialVersionOnStream</c> is written.
	    /// </summary>
	    ///
	    /// @serial
	    // private int serialVersionOnStream = currentSerialVersion;
	
	    // Proclaim serialization compatibility with JDK 1.1
	    // static final long serialVersionUID = -1807547505821590642L;
	
	    // haven't been compatible for awhile, no longer try
	    // jdk1.4.2 serialver
	    private const long serialVersionUID = 6222646104888790989L;
	
	    /// <summary>
	    /// Bitmask for internalSet() defining which fields may legally be set by
	    /// subclasses. Any attempt to set a field not in this bitmask results in an
	    /// exception, because such fields must be set by the base class.
	    /// </summary>
	    ///
	    private int internalSetMask;
	
	    /// <summary>
	    /// The Gregorian year, as computed by computeGregorianFields() and returned
	    /// by getGregorianYear().
	    /// </summary>
	    ///
	    private int gregorianYear;
	
	    /// <summary>
	    /// The Gregorian month, as computed by computeGregorianFields() and returned
	    /// by getGregorianMonth().
	    /// </summary>
	    ///
	    private int gregorianMonth;
	
	    /// <summary>
	    /// The Gregorian day of the year, as computed by computeGregorianFields()
	    /// and returned by getGregorianDayOfYear().
	    /// </summary>
	    ///
	    private int gregorianDayOfYear;
	
	    /// <summary>
	    /// The Gregorian day of the month, as computed by computeGregorianFields()
	    /// and returned by getGregorianDayOfMonth().
	    /// </summary>
	    ///
	    private int gregorianDayOfMonth;
	
	    /// <summary>
	    /// Constructs a Calendar with the default time zone and locale.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Util.TimeZone.GetDefault"/>
	    /// @stable ICU 2.0
	    protected internal Calendar() : this(IBM.ICU.Util.TimeZone.GetDefault(), IBM.ICU.Util.ULocale.GetDefault()) {
	    }
	
	    /// <summary>
	    /// Constructs a calendar with the specified time zone and locale.
	    /// </summary>
	    ///
	    /// <param name="zone_0">the time zone to use</param>
	    /// <param name="aLocale">the locale for the week data</param>
	    /// @stable ICU 2.0
        protected internal Calendar(TimeZone zone_0, Locale aLocale)
            : this(zone_0, IBM.ICU.Util.ULocale.ForLocale(aLocale))
        {
	    }
	
	    /// <summary>
	    /// Constructs a calendar with the specified time zone and locale.
	    /// </summary>
	    ///
	    /// <param name="zone_0">the time zone to use</param>
	    /// <param name="locale">the ulocale for the week data</param>
	    /// @stable ICU 3.2
	    protected internal Calendar(TimeZone zone_0, ULocale locale) {
	        this.lenient = true;
	        this.nextStamp = MINIMUM_USER_STAMP;
	        this.zone = zone_0;
	        SetWeekData(locale);
	        InitInternal();
	    }
	
	    private void InitInternal() {
	        // Allocate fields through the framework method. Subclasses
	        // may override this to define additional fields.
	        fields = HandleCreateFields();
	        // /CLOVER:OFF
	        // todo: fix, difficult to test without subclassing
	        if (fields == null || fields.Length < BASE_FIELD_COUNT
	                || fields.Length > MAX_FIELD_COUNT) {
	            throw new InvalidOperationException("Invalid fields[]");
	        }
	        // /CLOVER:ON
	        stamp = new int[fields.Length];
	        int mask = (1 << ERA) | (1 << YEAR) | (1 << MONTH)
	                | (1 << DAY_OF_MONTH) | (1 << DAY_OF_YEAR)
	                | (1 << EXTENDED_YEAR);
	        for (int i = BASE_FIELD_COUNT; i < fields.Length; ++i) {
	            mask |= (1 << i);
	        }
	        internalSetMask = mask;
	    }
	
	    /// <summary>
	    /// Gets a calendar using the default time zone and locale.
	    /// </summary>
	    ///
	    /// <returns>a Calendar.</returns>
	    /// @stable ICU 2.0
	    [MethodImpl(MethodImplOptions.Synchronized)]
	    public static Calendar GetInstance() {
	        return GetInstanceInternal(null, null);
	    }
	
	    /// <summary>
	    /// Gets a calendar using the specified time zone and default locale.
	    /// </summary>
	    ///
	    /// <param name="zone_0">the time zone to use</param>
	    /// <returns>a Calendar.</returns>
	    /// @stable ICU 2.0
	    [MethodImpl(MethodImplOptions.Synchronized)]
	    public static Calendar GetInstance(TimeZone zone_0) {
	        return GetInstanceInternal(zone_0, null);
	    }
	
	    /// <summary>
	    /// Gets a calendar using the default time zone and specified locale.
	    /// </summary>
	    ///
	    /// <param name="aLocale">the locale for the week data</param>
	    /// <returns>a Calendar.</returns>
	    /// @stable ICU 2.0
	    [MethodImpl(MethodImplOptions.Synchronized)]
        public static Calendar GetInstance(Locale aLocale)
        {
	        return GetInstanceInternal(null, IBM.ICU.Util.ULocale.ForLocale(aLocale));
	    }
	
	    /// <summary>
	    /// Gets a calendar using the default time zone and specified locale.
	    /// </summary>
	    ///
	    /// <param name="locale">the ulocale for the week data</param>
	    /// <returns>a Calendar.</returns>
	    /// @stable ICU 3.2
	    [MethodImpl(MethodImplOptions.Synchronized)]
	    public static Calendar GetInstance(ULocale locale) {
	        return GetInstanceInternal(null, locale);
	    }
	
	    /// <summary>
	    /// Gets a calendar with the specified time zone and locale.
	    /// </summary>
	    ///
	    /// <param name="zone_0">the time zone to use</param>
	    /// <param name="aLocale">the locale for the week data</param>
	    /// <returns>a Calendar.</returns>
	    /// @stable ICU 2.0
	    [MethodImpl(MethodImplOptions.Synchronized)]
	    public static Calendar GetInstance(TimeZone zone_0,
                Locale aLocale)
        {
	        return GetInstanceInternal(zone_0, IBM.ICU.Util.ULocale.ForLocale(aLocale));
	    }
	
	    /// <summary>
	    /// Gets a calendar with the specified time zone and locale.
	    /// </summary>
	    ///
	    /// <param name="zone_0">the time zone to use</param>
	    /// <param name="locale">the ulocale for the week data</param>
	    /// <returns>a Calendar.</returns>
	    /// @stable ICU 3.2
	    [MethodImpl(MethodImplOptions.Synchronized)]
	    public static Calendar GetInstance(TimeZone zone_0,
	            ULocale locale) {
	        return GetInstanceInternal(zone_0, locale);
	    }
	
	    /*
	     * All getInstance implementations call this private method to create a new
	     * Calendar instance.
	     */
	    private static Calendar GetInstanceInternal(TimeZone tz, ULocale locale) {
	        if (locale == null) {
	            locale = IBM.ICU.Util.ULocale.GetDefault();
	        }
	        if (tz == null) {
	            tz = IBM.ICU.Util.TimeZone.GetDefault();
	        }
	        Calendar cal = GetShim().CreateInstance(locale);
	        cal.SetTimeZone(tz);
	        cal.SetTimeInMillis(DateTime.Now.Millisecond);
	        return cal;
	    }
	
	    private const int BUDDHIST = 0;
	
	    private const int CHINESE = 1;
	
	    private const int COPTIC = 2;
	
	    private const int ETHIOPIC = 3;
	
	    private const int GREGORIAN = 4;
	
	    private const int HEBREW = 5;
	
	    private const int INDIAN = 6;
	
	    private const int ISLAMIC = 7;
	
	    private const int ISLAMIC_CIVIL = 8;
	
	    private const int JAPANESE = 9;
	
	    private const int TAIWAN = 10;
	
	    private static readonly String[] calTypes = { "buddhist", "chinese", "coptic",
	            "ethiopic", "gregorian", "hebrew", "indian", "islamic",
	            "islamic-civil", "japanese", "taiwan" };
	
	    private static int GetCalendarType(ULocale l) {
	        String s = l.GetKeywordValue("calendar");
	        if (s == null) {
	            l = IBM.ICU.Impl.ICUResourceBundle.GetFunctionalEquivalent(
	                    IBM.ICU.Impl.ICUResourceBundle.ICU_BASE_NAME, "calendar", "calendar", l,
	                    null);
	            s = l.GetKeywordValue("calendar");
	        }
	        return GetCalendarType(s);
	    }
	
	    private static int GetCalendarType(String s) {
	        if (s != null) {
	            s = s.ToLower();
	            for (int i = 0; i < calTypes.Length; ++i) {
	                if (s.Equals(calTypes[i])) {
	                    return i;
	                }
	            }
	        }
	        return GREGORIAN;
	    }
	
	    /// <summary>
	    /// Gets the list of locales for which Calendars are installed.
	    /// </summary>
	    ///
	    /// <returns>the list of locales for which Calendars are installed.</returns>
	    /// @stable ICU 2.0
        public static Locale[] GetAvailableLocales()
        {
	        if (shim == null) {
	            return IBM.ICU.Impl.ICUResourceBundle
	                    .GetAvailableLocales(IBM.ICU.Impl.ICUResourceBundle.ICU_BASE_NAME);
	        }
	        return GetShim().GetAvailableLocales();
	    }
	
	    /// <summary>
	    /// Gets the list of locales for which Calendars are installed.
	    /// </summary>
	    ///
	    /// <returns>the list of locales for which Calendars are installed.</returns>
	    /// @draft ICU 3.2
	    /// @provisional This API might change or be removed in a future release.
	    public static ULocale[] GetAvailableULocales() {
	        if (shim == null) {
	            return IBM.ICU.Impl.ICUResourceBundle
	                    .GetAvailableULocales(IBM.ICU.Impl.ICUResourceBundle.ICU_BASE_NAME);
	        }
	        return GetShim().GetAvailableULocales();
	    }
	
	    // ==== Factory Stuff ====
	    /// <summary>
	    /// A CalendarFactory is used to register new calendar implementation. The
	    /// factory should be able to create a calendar instance for the specified
	    /// locale.
	    /// </summary>
	    ///
	    /// @prototype
	    /* public */abstract internal class CalendarFactory {
	        public bool Visible() {
	            return true;
	        }
	
	        public abstract ILOG.J2CsMapping.Collections.ISet GetSupportedLocaleNames();
	
	        public Calendar CreateCalendar(ULocale loc) {
	            return null;
	        }
	
	        protected internal CalendarFactory() {
	        }
	    }
	
	    // shim so we can build without service code
	    abstract internal class CalendarShim {
            abstract internal Locale[] GetAvailableLocales();
	
	        abstract internal ULocale[] GetAvailableULocales();
	
	        abstract internal Object RegisterFactory(Calendar.CalendarFactory  factory);
	
	        abstract internal bool Unregister(Object k);
	
	        abstract internal Calendar CreateInstance(ULocale l);
	    }
	
	    private static Calendar.CalendarShim  shim;
	
	    private static Calendar.CalendarShim  GetShim() {
	        if (shim == null) {
	            try {
	                Type cls = ILOG.J2CsMapping.Reflect.Helper.GetNativeType("IBM.ICU.Util.CalendarServiceShim");
	                shim = (Calendar.CalendarShim ) Activator.CreateInstance(cls);
	            } catch (MissingManifestResourceException e) {
	                throw e;
	            } catch (Exception e_0) {
	                throw new Exception(e_0.Message);
	            }
	        }
	        return shim;
	    }
	
	    static internal Calendar CreateInstance(ULocale locale) {
	        int calType = GetCalendarType(locale);
	        TimeZone zone_0 = IBM.ICU.Util.TimeZone.GetDefault();
	
	        switch (calType) {
	        case BUDDHIST:
                    return new IBM.ICU.Util.BuddhistCalendar(zone_0, locale);
	        case CHINESE:
                return new IBM.ICU.Util.ChineseCalendar(zone_0, locale);
	        case COPTIC:
                return new IBM.ICU.Util.CopticCalendar(zone_0, locale);
	        case ETHIOPIC:
                return new IBM.ICU.Util.EthiopicCalendar(zone_0, locale);
	        case GREGORIAN:
                return new IBM.ICU.Util.GregorianCalendar(zone_0, locale);
	        case HEBREW:
                return new IBM.ICU.Util.HebrewCalendar(zone_0, locale);
	        case ISLAMIC:
	        case ISLAMIC_CIVIL: {
	            IslamicCalendar result = new IslamicCalendar(zone_0, locale);
	            result.SetCivil(calType == ISLAMIC_CIVIL);
	            return result;
	        }
	        case JAPANESE:
	            return new IBM.ICU.Util.JapaneseCalendar(zone_0, locale);
	        case TAIWAN:
                return new IBM.ICU.Util.TaiwanCalendar(zone_0, locale);
	        case INDIAN:
                return new IBM.ICU.Util.IndianCalendar(zone_0, locale);
	        default:
	            throw new InvalidOperationException();
	        }
	    }
	
	    // /CLOVER:OFF
	    /// <summary>
	    /// Register a new CalendarFactory. getInstance(TimeZone, ULocale, String)
	    /// will try to locate a registered factories matching the factoryName. Only
	    /// registered factories will be found.
	    /// </summary>
	    ///
	    /// @prototype
	    /* public */static internal Object RegisterFactory(Calendar.CalendarFactory  factory) {
	        if (factory == null) {
	            throw new ArgumentException("factory must not be null");
	        }
	        return GetShim().RegisterFactory(factory);
	    }
	
	    /// <summary>
	    /// Unregister the CalendarFactory associated with this key (obtained from
	    /// register).
	    /// </summary>
	    ///
	    /// @prototype
	    /* public */static internal bool Unregister(Object registryKey) {
	        if (registryKey == null) {
	            throw new ArgumentException("registryKey must not be null");
	        }
	
	        if (shim == null) {
	            return false;
	        }
	
	        return shim.Unregister(registryKey);
	    }
	
	    // /CLOVER:ON
	    // ==== End of factory Stuff ====
	
	    /// <summary>
	    /// Gets this Calendar's current time.
	    /// </summary>
	    ///
	    /// <returns>the current time.</returns>
	    /// @stable ICU 2.0
	    public virtual DateTime GetTime() {
            /*int year = Get(YEAR);
            int month = Get(MONTH);
            if (month == 0)
                month = 1; // DUMB !
            int day = Get(DAY_OF_MONTH);
            return new DateTime(year, month, day);*/
            return ILOG.J2CsMapping.Util.DateUtil.DateFromJavaMillis(GetTimeInMillis());
	    }
	
	    /// <summary>
	    /// Sets this Calendar's current time with the given Date.
	    /// <p>
	    /// Note: Calling <c>setTime()</c> with
	    /// <c>Date(Long.MAX_VALUE)</c> or <c>Date(Long.MIN_VALUE)</c>
	    /// may yield incorrect field values from <c>get()</c>.
	    /// </summary>
	    ///
	    /// <param name="date">the given Date.</param>
	    /// @stable ICU 2.0
	    public virtual void SetTime(DateTime date) {
            SetTimeInMillis(ILOG.J2CsMapping.Util.DateUtil.DotNetDateToJavaMillis(date));
	        // SetTimeInMillis((date.Ticks / TimeSpan.TicksPerMillisecond));
	    }
	
	    /// <summary>
	    /// Gets this Calendar's current time as a long.
	    /// </summary>
	    ///
	    /// <returns>the current time as UTC milliseconds from the epoch.</returns>
	    /// @stable ICU 2.0
	    public long GetTimeInMillis() {
	        if (!isTimeSet)
	            UpdateTime();
	        return time;
	    }
	
	    /// <summary>
	    /// Sets this Calendar's current time from the given long value.
	    /// </summary>
	    ///
	    /// <param name="millis">the new time in UTC milliseconds from the epoch.</param>
	    /// @stable ICU 2.0
	    public void SetTimeInMillis(long millis) {
	        if (millis > MAX_MILLIS) {
	            millis = MAX_MILLIS;
	        } else if (millis < MIN_MILLIS) {
	            millis = MIN_MILLIS;
	        }
	        time = millis;
	        areFieldsSet = areAllFieldsSet = false;
	        isTimeSet = areFieldsVirtuallySet = true;
	    }
	
	    /// <summary>
	    /// Gets the value for a given time field.
	    /// </summary>
	    ///
	    /// <param name="field">the given time field.</param>
	    /// <returns>the value for the given time field.</returns>
	    /// @stable ICU 2.0
	    public int Get(int field) {
	        Complete();
	        return fields[field];
	    }
	
	    /// <summary>
	    /// Gets the value for a given time field. This is an internal method for
	    /// subclasses that does <em>not</em> trigger any calculations.
	    /// </summary>
	    ///
	    /// <param name="field">the given time field.</param>
	    /// <returns>the value for the given time field.</returns>
	    /// @stable ICU 2.0
	    protected internal int InternalGet(int field) {
	        return fields[field];
	    }
	
	    /// <summary>
	    /// Get the value for a given time field, or return the given default value
	    /// if the field is not set. This is an internal method for subclasses that
	    /// does <em>not</em> trigger any calculations.
	    /// </summary>
	    ///
	    /// <param name="field">the given time field.</param>
	    /// <param name="defaultValue">value to return if field is not set</param>
	    /// <returns>the value for the given time field of defaultValue if the field
	    /// is unset</returns>
	    /// @stable ICU 2.0
	    protected internal int InternalGet(int field, int defaultValue) {
	        return (stamp[field] > UNSET) ? fields[field] : defaultValue;
	    }
	
	    /// <summary>
	    /// Sets the time field with the given value.
	    /// </summary>
	    ///
	    /// <param name="field">the given time field.</param>
	    /// <param name="value">the value to be set for the given time field.</param>
	    /// @stable ICU 2.0
	    public void Set(int field, int value_ren) {
	        if (areFieldsVirtuallySet) {
	            ComputeFields();
	        }
	        fields[field] = value_ren;
	        stamp[field] = nextStamp++;
	        isTimeSet = areFieldsSet = areFieldsVirtuallySet = false;
	    }
	
	    /// <summary>
	    /// Sets the values for the fields year, month, and date. Previous values of
	    /// other fields are retained. If this is not desired, call
	    /// <c>clear</c> first.
	    /// </summary>
	    ///
	    /// <param name="year">the value used to set the YEAR time field.</param>
	    /// <param name="month">the value used to set the MONTH time field. Month value is0-based. e.g., 0 for January.</param>
	    /// <param name="date">the value used to set the DATE time field.</param>
	    /// @stable ICU 2.0
	    public void Set(int year, int month, int date) {
	        Set(YEAR, year);
	        Set(MONTH, month);
	        Set(DATE, date);
	    }
	
	    /// <summary>
	    /// Sets the values for the fields year, month, date, hour, and minute.
	    /// Previous values of other fields are retained. If this is not desired,
	    /// call <c>clear</c> first.
	    /// </summary>
	    ///
	    /// <param name="year">the value used to set the YEAR time field.</param>
	    /// <param name="month">the value used to set the MONTH time field. Month value is0-based. e.g., 0 for January.</param>
	    /// <param name="date">the value used to set the DATE time field.</param>
	    /// <param name="hour">the value used to set the HOUR_OF_DAY time field.</param>
	    /// <param name="minute">the value used to set the MINUTE time field.</param>
	    /// @stable ICU 2.0
	    public void Set(int year, int month, int date, int hour, int minute) {
	        Set(YEAR, year);
	        Set(MONTH, month);
	        Set(DATE, date);
	        Set(HOUR_OF_DAY, hour);
	        Set(MINUTE, minute);
	    }
	
	    /// <summary>
	    /// Sets the values for the fields year, month, date, hour, minute, and
	    /// second. Previous values of other fields are retained. If this is not
	    /// desired, call <c>clear</c> first.
	    /// </summary>
	    ///
	    /// <param name="year">the value used to set the YEAR time field.</param>
	    /// <param name="month">the value used to set the MONTH time field. Month value is0-based. e.g., 0 for January.</param>
	    /// <param name="date">the value used to set the DATE time field.</param>
	    /// <param name="hour">the value used to set the HOUR_OF_DAY time field.</param>
	    /// <param name="minute">the value used to set the MINUTE time field.</param>
	    /// <param name="second">the value used to set the SECOND time field.</param>
	    /// @stable ICU 2.0
	    public void Set(int year, int month, int date, int hour, int minute,
	            int second) {
	        Set(YEAR, year);
	        Set(MONTH, month);
	        Set(DATE, date);
	        Set(HOUR_OF_DAY, hour);
	        Set(MINUTE, minute);
	        Set(SECOND, second);
	    }
	
	    /// <summary>
	    /// Clears the values of all the time fields.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public void Clear() {
	        for (int i = 0; i < fields.Length; ++i) {
	            fields[i] = stamp[i] = 0; // UNSET == 0
	        }
	        isTimeSet = areFieldsSet = areAllFieldsSet = areFieldsVirtuallySet = false;
	    }
	
	    /// <summary>
	    /// Clears the value in the given time field.
	    /// </summary>
	    ///
	    /// <param name="field">the time field to be cleared.</param>
	    /// @stable ICU 2.0
	    public void Clear(int field) {
	        if (areFieldsVirtuallySet) {
	            ComputeFields();
	        }
	        fields[field] = 0;
	        stamp[field] = UNSET;
	        isTimeSet = areFieldsSet = areAllFieldsSet = areFieldsVirtuallySet = false;
	    }
	
	    /// <summary>
	    /// Determines if the given time field has a value set.
	    /// </summary>
	    ///
	    /// <returns>true if the given time field has a value set; false otherwise.</returns>
	    /// @stable ICU 2.0
	    public bool IsSet(int field) {
	        return areFieldsVirtuallySet || (stamp[field] != UNSET);
	    }
	
	    /// <summary>
	    /// Fills in any unset fields in the time field list.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    protected internal void Complete() {
	        if (!isTimeSet)
	            UpdateTime();
	        if (!areFieldsSet) {
	            ComputeFields(); // fills in unset fields
	            areFieldsSet = true;
	            areAllFieldsSet = true;
	        }
	    }
	
	    /// <summary>
	    /// Compares this calendar to the specified object. The result is
	    /// <c>true</c> if and only if the argument is not <c>null</c>
	    /// and is a <c>Calendar</c> object that represents the same calendar
	    /// as this object.
	    /// </summary>
	    ///
	    /// <param name="obj">the object to compare with.</param>
	    /// <returns><c>true</c> if the objects are the same; <c>false</c>
	    /// otherwise.</returns>
	    /// @stable ICU 2.0
	    public override bool Equals(Object obj) {
	        if ((Object) this == obj) {
	            return true;
	        }
	        if ((Object) ((object) this).GetType() != (Object) ((object) obj).GetType()) {
	            return false;
	        }
	
	        Calendar that = (Calendar) obj;
	
	        return IsEquivalentTo(that)
	                && GetTimeInMillis() == (ILOG.J2CsMapping.Util.DateUtil.DotNetDateToJavaMillis(that.GetTime()));
	    }
	
	    /// <summary>
	    /// Returns true if the given Calendar object is equivalent to this one. An
	    /// equivalent Calendar will behave exactly as this one does, but it may be
	    /// set to a different time. By contrast, for the equals() method to return
	    /// true, the other Calendar must be set to the same time.
	    /// </summary>
	    ///
	    /// <param name="other">the Calendar to be compared with this Calendar</param>
	    /// @stable ICU 2.4
	    public virtual bool IsEquivalentTo(Calendar other) {
	        return (Object) ((object) this).GetType() == (Object) ((object) other).GetType()
	                && IsLenient() == other.IsLenient()
	                && GetFirstDayOfWeek() == other.GetFirstDayOfWeek()
	                && GetMinimalDaysInFirstWeek() == other
	                        .GetMinimalDaysInFirstWeek()
	                && GetTimeZone().Equals(other.GetTimeZone());
	    }
	
	    /// <summary>
	    /// Returns a hash code for this calendar.
	    /// </summary>
	    ///
	    /// <returns>a hash code value for this object.</returns>
	    /// @stable ICU 2.0
	    public override int GetHashCode() {
	        /*
	         * Don't include the time because (a) we don't want the hash value to
	         * move around just because a calendar is set to different times, and
	         * (b) we don't want to trigger a time computation just to get a hash.
	         * Note that it is not necessary for unequal objects to always have
	         * unequal hashes, but equal objects must have equal hashes.
	         */
	        return ((lenient) ? 1 : 0) | (firstDayOfWeek << 1)
	                | (minimalDaysInFirstWeek << 4) | (zone.GetHashCode() << 7);
	    }
	
	    /// <summary>
	    /// Return the difference in milliseconds between the moment this calendar is
	    /// set to and the moment the given calendar or Date object is set to.
	    /// </summary>
	    ///
	    private long Compare(Object that) {
	        long thatMs;
	        if (that  is  Calendar) {
	            thatMs = ((Calendar) that).GetTimeInMillis();
	        } else if (that  is  DateTime) {
	            thatMs = (((DateTime) that).Ticks/10000);
	        } else {
	            throw new ArgumentException(that
	                    + "is not a Calendar or Date");
	        }
	        return GetTimeInMillis() - thatMs;
	    }
	
	    /// <summary>
	    /// Compares the time field records. Equivalent to comparing result of
	    /// conversion to UTC.
	    /// </summary>
	    ///
	    /// <param name="when">the Calendar to be compared with this Calendar.</param>
	    /// <returns>true if the current time of this Calendar is before the time of
	    /// Calendar when; false otherwise.</returns>
	    /// @stable ICU 2.0
	    public bool Before(Object when) {
	        return Compare(when) < 0;
	    }
	
	    /// <summary>
	    /// Compares the time field records. Equivalent to comparing result of
	    /// conversion to UTC.
	    /// </summary>
	    ///
	    /// <param name="when">the Calendar to be compared with this Calendar.</param>
	    /// <returns>true if the current time of this Calendar is after the time of
	    /// Calendar when; false otherwise.</returns>
	    /// @stable ICU 2.0
	    public bool After(Object when) {
	        return Compare(when) > 0;
	    }
	
	    /// <summary>
	    /// Return the maximum value that this field could have, given the current
	    /// date. For example, with the Gregorian date February 3, 1997 and the<see cref="M:IBM.ICU.Util.Calendar.DAY_OF_MONTH DAY_OF_MONTH"/> field, the actual maximum is 28; for
	    /// February 3, 1996 it is 29.
	    /// <p>
	    /// The actual maximum computation ignores smaller fields and the current
	    /// value of like-sized fields. For example, the actual maximum of the
	    /// DAY_OF_YEAR or MONTH depends only on the year and supra-year fields. The
	    /// actual maximum of the DAY_OF_MONTH depends, in addition, on the MONTH
	    /// field and any other fields at that granularity (such as
	    /// ChineseCalendar.IS_LEAP_MONTH). The DAY_OF_WEEK_IN_MONTH field does not
	    /// depend on the current DAY_OF_WEEK; it returns the maximum for any day of
	    /// week in the current month. Likewise for the WEEK_OF_MONTH and
	    /// WEEK_OF_YEAR fields.
	    /// </summary>
	    ///
	    /// <param name="field">the field whose maximum is desired</param>
	    /// <returns>the maximum of the given field for the current date of this
	    /// calendar</returns>
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.GetMaximum(System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.GetLeastMaximum(System.Int32)"/>
	    /// @stable ICU 2.0
	    public virtual int GetActualMaximum(int field) {
	        int result;
	
	        switch (field) {
	        case DAY_OF_MONTH: {
	            Calendar cal = (Calendar) Clone();
	            cal.PrepareGetActual(field, false);
	            result = HandleGetMonthLength(cal.Get(EXTENDED_YEAR),
	                    cal.Get(MONTH));
	        }
	            break;
	
	        case DAY_OF_YEAR: {
	            Calendar cal_0 = (Calendar) Clone();
	            cal_0.PrepareGetActual(field, false);
	            result = HandleGetYearLength(cal_0.Get(EXTENDED_YEAR));
	        }
	            break;
	
	        case DAY_OF_WEEK:
	        case AM_PM:
	        case HOUR:
	        case HOUR_OF_DAY:
	        case MINUTE:
	        case SECOND:
	        case MILLISECOND:
	        case ZONE_OFFSET:
	        case DST_OFFSET:
	        case DOW_LOCAL:
	        case JULIAN_DAY:
	        case MILLISECONDS_IN_DAY:
	            // These fields all have fixed minima/maxima
	            result = GetMaximum(field);
	            break;
	
	        default:
	            // For all other fields, do it the hard way....
	            result = GetActualHelper(field, GetLeastMaximum(field),
	                    GetMaximum(field));
	            break;
	        }
	        return result;
	    }
	
	    /// <summary>
	    /// Return the minimum value that this field could have, given the current
	    /// date. For most fields, this is the same as <see cref="M:IBM.ICU.Util.Calendar.GetMinimum getMinimum"/>and <see cref="M:IBM.ICU.Util.Calendar.GetGreatestMinimum getGreatestMinimum"/>. However, some fields,
	    /// especially those related to week number, are more complicated.
	    /// <p>
	    /// For example, assume <see cref="M:IBM.ICU.Util.Calendar.GetMinimalDaysInFirstWeekgetMinimalDaysInFirstWeek"/> returns 4 and <see cref="M:IBM.ICU.Util.Calendar.GetFirstDayOfWeekgetFirstDayOfWeek"/> returns SUNDAY. If the first day of the month is
	    /// Sunday, Monday, Tuesday, or Wednesday there will be four or more days in
	    /// the first week, so it will be week number 1, and
	    /// <c>getActualMinimum(WEEK_OF_MONTH)</c> will return 1. However, if
	    /// the first of the month is a Thursday, Friday, or Saturday, there are
	    /// <em>not</em> four days in that week, so it is week number 0, and
	    /// <c>getActualMinimum(WEEK_OF_MONTH)</c> will return 0.
	    /// <p>
	    /// </summary>
	    ///
	    /// <param name="field">the field whose actual minimum value is desired.</param>
	    /// <returns>the minimum of the given field for the current date of this
	    /// calendar</returns>
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.GetMinimum(System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.GetGreatestMinimum(System.Int32)"/>
	    /// @stable ICU 2.0
	    public virtual int GetActualMinimum(int field) {
	        int result;
	
	        switch (field) {
	        case DAY_OF_WEEK:
	        case AM_PM:
	        case HOUR:
	        case HOUR_OF_DAY:
	        case MINUTE:
	        case SECOND:
	        case MILLISECOND:
	        case ZONE_OFFSET:
	        case DST_OFFSET:
	        case DOW_LOCAL:
	        case JULIAN_DAY:
	        case MILLISECONDS_IN_DAY:
	            // These fields all have fixed minima/maxima
	            result = GetMinimum(field);
	            break;
	
	        default:
	            // For all other fields, do it the hard way....
	            result = GetActualHelper(field, GetGreatestMinimum(field),
	                    GetMinimum(field));
	            break;
	        }
	        return result;
	    }
	
	    /// <summary>
	    /// Prepare this calendar for computing the actual minimum or maximum. This
	    /// method modifies this calendar's fields; it is called on a temporary
	    /// calendar.
	    /// <p>
	    /// Rationale: The semantics of getActualXxx() is to return the maximum or
	    /// minimum value that the given field can take, taking into account other
	    /// relevant fields. In general these other fields are larger fields. For
	    /// example, when computing the actual maximum DAY_OF_MONTH, the current
	    /// value of DAY_OF_MONTH itself is ignored, as is the value of any field
	    /// smaller.
	    /// <p>
	    /// The time fields all have fixed minima and maxima, so we don't need to
	    /// worry about them. This also lets us set the MILLISECONDS_IN_DAY to zero
	    /// to erase any effects the time fields might have when computing date
	    /// fields.
	    /// <p>
	    /// DAY_OF_WEEK is adjusted specially for the WEEK_OF_MONTH and WEEK_OF_YEAR
	    /// fields to ensure that they are computed correctly.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    protected internal void PrepareGetActual(int field, bool isMinimum) {
	        Set(MILLISECONDS_IN_DAY, 0);
	
	        switch (field) {
	        case YEAR:
	        case YEAR_WOY:
	        case EXTENDED_YEAR:
	            Set(DAY_OF_YEAR, GetGreatestMinimum(DAY_OF_YEAR));
	            break;
	
	        case MONTH:
	            Set(DAY_OF_MONTH, GetGreatestMinimum(DAY_OF_MONTH));
	            break;
	
	        case DAY_OF_WEEK_IN_MONTH:
	            // For dowim, the maximum occurs for the DOW of the first of the
	            // month.
	            Set(DAY_OF_MONTH, 1);
	            Set(DAY_OF_WEEK, Get(DAY_OF_WEEK)); // Make this user set
	            break;
	
	        case WEEK_OF_MONTH:
	        case WEEK_OF_YEAR:
	            // If we're counting weeks, set the day of the week to either the
	            // first or last localized DOW. We know the last week of a month
	            // or year will contain the first day of the week, and that the
	            // first week will contain the last DOW.
	        {
	            int dow = firstDayOfWeek;
	            if (isMinimum) {
	                dow = (dow + 6) % 7; // set to last DOW
	                if (dow < SUNDAY) {
	                    dow += 7;
	                }
	            }
	            Set(DAY_OF_WEEK, dow);
	        }
	            break;
	        }
	
	        // Do this last to give it the newest time stamp
	        Set(field, GetGreatestMinimum(field));
	    }
	
	    private int GetActualHelper(int field, int startValue, int endValue) {
	
	        if (startValue == endValue) {
	            // if we know that the maximum value is always the same, just return
	            // it
	            return startValue;
	        }
	
	        int delta = (endValue > startValue) ? 1 : -1;
	
	        // clone the calendar so we don't mess with the real one, and set it to
	        // accept anything for the field values
	        Calendar work = (Calendar) Clone();
	        work.SetLenient(true);
	        work.PrepareGetActual(field, delta < 0);
	
	        // now try each value from the start to the end one by one until
	        // we get a value that normalizes to another value. The last value that
	        // normalizes to itself is the actual maximum for the current date
	        int result = startValue;
	        do {
	            work.Set(field, startValue);
	            if (work.Get(field) != startValue) {
	                break;
	            } else {
	                result = startValue;
	                startValue += delta;
	            }
	        } while (result != endValue);
	
	        return result;
	    }
	
	    /// <summary>
	    /// Rolls (up/down) a single unit of time on the given field. If the field is
	    /// rolled past its maximum allowable value, it will "wrap" back to its
	    /// minimum and continue rolling. For example, to roll the current date up by
	    /// one day, you can call:
	    /// <p>
	    /// <code>roll(<see cref="F:IBM.ICU.Util.Calendar.DATE"/>, true)</code>
	    /// <p>
	    /// When rolling on the <see cref="F:IBM.ICU.Util.Calendar.YEAR"/> field, it will roll the year value in
	    /// the range between 1 and the value returned by calling <see cref="M:IBM.ICU.Util.Calendar.GetMaximumgetMaximum"/>(<see cref="F:IBM.ICU.Util.Calendar.YEAR"/>).
	    /// <p>
	    /// When rolling on certain fields, the values of other fields may conflict
	    /// and need to be changed. For example, when rolling the <c>MONTH</c>
	    /// field for the Gregorian date 1/31/96 upward, the
	    /// <c>DAY_OF_MONTH</c> field must be adjusted so that the result is
	    /// 2/29/96 rather than the invalid 2/31/96.
	    /// <p>
	    /// <b>Note:</b> Calling <tt>roll(field, true)</tt> N times is <em>not</em>
	    /// necessarily equivalent to calling <tt>roll(field, N)</tt>. For example,
	    /// imagine that you start with the date Gregorian date January 31, 1995. If
	    /// you call <tt>roll(Calendar.MONTH, 2)</tt>, the result will be March 31,
	    /// 1995. But if you call <tt>roll(Calendar.MONTH, true)</tt>, the result
	    /// will be February 28, 1995. Calling it one more time will give March 28,
	    /// 1995, which is usually not the desired result.
	    /// <p>
	    /// <b>Note:</b> You should always use <tt>roll</tt> and <tt>add</tt> rather
	    /// than attempting to perform arithmetic operations directly on the fields
	    /// of a <tt>Calendar</tt>. It is quite possible for <tt>Calendar</tt>
	    /// subclasses to have fields with non-linear behavior, for example missing
	    /// months or days during non-leap years. The subclasses' <tt>add</tt> and
	    /// <tt>roll</tt> methods will take this into account, while simple
	    /// arithmetic manipulations may give invalid results.
	    /// <p>
	    /// </summary>
	    ///
	    /// <param name="field">the calendar field to roll.</param>
	    /// <param name="up">indicates if the value of the specified time field is to berolled up or rolled down. Use <c>true</c> if rolling up,<c>false</c> otherwise.</param>
	    /// <exception cref="IllegalArgumentException">if the field is invalid or refers to a field that cannotbe handled by this method.</exception>
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.Roll(System.Int32, System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.Add(System.Int32, System.Int32)"/>
	    /// @stable ICU 2.0
	    public void Roll(int field, bool up) {
	        Roll(field, (up) ? +1 : -1);
	    }
	
	    /// <summary>
	    /// Rolls (up/down) a specified amount time on the given field. For example,
	    /// to roll the current date up by three days, you can call
	    /// <c>roll(Calendar.DATE, 3)</c>. If the field is rolled past its
	    /// maximum allowable value, it will "wrap" back to its minimum and continue
	    /// rolling. For example, calling <c>roll(Calendar.DATE, 10)</c> on a
	    /// Gregorian calendar set to 4/25/96 will result in the date 4/5/96.
	    /// <p>
	    /// When rolling on certain fields, the values of other fields may conflict
	    /// and need to be changed. For example, when rolling the <see cref="M:IBM.ICU.Util.Calendar.MONTHMONTH"/> field for the Gregorian date 1/31/96 by +1, the<see cref="M:IBM.ICU.Util.Calendar.DAY_OF_MONTH DAY_OF_MONTH"/> field must be adjusted so that the
	    /// result is 2/29/96 rather than the invalid 2/31/96.
	    /// <p>
	    /// The <c>com.ibm.icu.util.Calendar</c> implementation of this method
	    /// is able to roll all fields except for <see cref="M:IBM.ICU.Util.Calendar.ERA ERA"/>,<see cref="M:IBM.ICU.Util.Calendar.DST_OFFSET DST_OFFSET"/>, and <see cref="M:IBM.ICU.Util.Calendar.ZONE_OFFSET ZONE_OFFSET"/>.
	    /// Subclasses may, of course, add support for additional fields in their
	    /// overrides of <c>roll</c>.
	    /// <p>
	    /// <b>Note:</b> You should always use <tt>roll</tt> and <tt>add</tt> rather
	    /// than attempting to perform arithmetic operations directly on the fields
	    /// of a <tt>Calendar</tt>. It is quite possible for <tt>Calendar</tt>
	    /// subclasses to have fields with non-linear behavior, for example missing
	    /// months or days during non-leap years. The subclasses' <tt>add</tt> and
	    /// <tt>roll</tt> methods will take this into account, while simple
	    /// arithmetic manipulations may give invalid results.
	    /// <p>
	    /// <b>Subclassing:</b><br>
	    /// This implementation of <c>roll</c> assumes that the behavior of the
	    /// field is continuous between its minimum and maximum, which are found by
	    /// calling <see cref="M:IBM.ICU.Util.Calendar.GetActualMinimum getActualMinimum"/> and<see cref="M:IBM.ICU.Util.Calendar.GetActualMaximum getActualMaximum"/>. For most such fields, simple
	    /// addition, subtraction, and modulus operations are sufficient to perform
	    /// the roll. For week-related fields, the results of<see cref="M:IBM.ICU.Util.Calendar.GetFirstDayOfWeek getFirstDayOfWeek"/> and<see cref="M:IBM.ICU.Util.Calendar.GetMinimalDaysInFirstWeek getMinimalDaysInFirstWeek"/> are also
	    /// necessary. Subclasses can override these two methods if their values
	    /// differ from the defaults.
	    /// <p>
	    /// Subclasses that have fields for which the assumption of continuity breaks
	    /// down must overide <c>roll</c> to handle those fields specially. For
	    /// example, in the Hebrew calendar the month "Adar I" only occurs in leap
	    /// years; in other years the calendar jumps from Shevat (month #4) to Adar
	    /// (month #6). The <see cref="M:IBM.ICU.Util.HebrewCalendar.Roll HebrewCalendar.Roll"/> method
	    /// takes this into account, so that rolling the month of Shevat by one gives
	    /// the proper result (Adar) in a non-leap year.
	    /// <p>
	    /// </summary>
	    ///
	    /// <param name="field">the calendar field to roll.</param>
	    /// <param name="amount">the amount by which the field should be rolled.</param>
	    /// <exception cref="IllegalArgumentException">if the field is invalid or refers to a field that cannotbe handled by this method.</exception>
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.Roll(System.Int32, System.Boolean)"/>
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.Add(System.Int32, System.Int32)"/>
	    /// @stable ICU 2.0
	    public virtual void Roll(int field, int amount) {
	
	        if (amount == 0) {
	            return; // Nothing to do
	        }
	
	        Complete();
	
	        switch (field) {
	        case DAY_OF_MONTH:
	        case AM_PM:
	        case MINUTE:
	        case SECOND:
	        case MILLISECOND:
	        case MILLISECONDS_IN_DAY:
	        case ERA:
	            // These are the standard roll instructions. These work for all
	            // simple cases, that is, cases in which the limits are fixed, such
	            // as the hour, the day of the month, and the era.
	        {
	            int min = GetActualMinimum(field);
	            int max = GetActualMaximum(field);
	            int gap = max - min + 1;
	
	            int value_ren = InternalGet(field) + amount;
	            value_ren = (value_ren - min) % gap;
	            if (value_ren < 0) {
	                value_ren += gap;
	            }
	            value_ren += min;
	
	            Set(field, value_ren);
	            return;
	        }
	
	        case HOUR:
	        case HOUR_OF_DAY:
	            // Rolling the hour is difficult on the ONSET and CEASE days of
	            // daylight savings. For example, if the change occurs at
	            // 2 AM, we have the following progression:
	            // ONSET: 12 Std -> 1 Std -> 3 Dst -> 4 Dst
	            // CEASE: 12 Dst -> 1 Dst -> 1 Std -> 2 Std
	            // To get around this problem we don't use fields; we manipulate
	            // the time in millis directly.
	        {
	            // Assume min == 0 in calculations below
	            long start = GetTimeInMillis();
	            int oldHour = InternalGet(field);
	            int max_0 = GetMaximum(field);
	            int newHour = (oldHour + amount) % (max_0 + 1);
	            if (newHour < 0) {
	                newHour += max_0 + 1;
	            }
	            SetTimeInMillis(start + ONE_HOUR * (newHour - oldHour));
	            return;
	        }
	
	        case MONTH:
	            // Rolling the month involves both pinning the final value
	            // and adjusting the DAY_OF_MONTH if necessary. We only adjust the
	            // DAY_OF_MONTH if, after updating the MONTH field, it is illegal.
	            // E.g., <jan31>.roll(MONTH, 1) -> <feb28> or <feb29>.
	        {
	            int max_1 = GetActualMaximum(MONTH);
	            int mon = (InternalGet(MONTH) + amount) % (max_1 + 1);
	
	            if (mon < 0) {
	                mon += (max_1 + 1);
	            }
	            Set(MONTH, mon);
	
	            // Keep the day of month in range. We don't want to spill over
	            // into the next month; e.g., we don't want jan31 + 1 mo -> feb31 ->
	            // mar3.
	            PinField(DAY_OF_MONTH);
	            return;
	        }
	
	        case YEAR:
	        case YEAR_WOY:
	        case EXTENDED_YEAR:
	            // Rolling the year can involve pinning the DAY_OF_MONTH.
	            Set(field, InternalGet(field) + amount);
	            PinField(MONTH);
	            PinField(DAY_OF_MONTH);
	            return;
	
	        case WEEK_OF_MONTH: {
	            // This is tricky, because during the roll we may have to shift
	            // to a different day of the week. For example:
	
	            // s m t w r f s
	            // 1 2 3 4 5
	            // 6 7 8 9 10 11 12
	
	            // When rolling from the 6th or 7th back one week, we go to the
	            // 1st (assuming that the first partial week counts). The same
	            // thing happens at the end of the month.
	
	            // The other tricky thing is that we have to figure out whether
	            // the first partial week actually counts or not, based on the
	            // minimal first days in the week. And we have to use the
	            // correct first day of the week to delineate the week
	            // boundaries.
	
	            // Here's our algorithm. First, we find the real boundaries of
	            // the month. Then we discard the first partial week if it
	            // doesn't count in this locale. Then we fill in the ends with
	            // phantom days, so that the first partial week and the last
	            // partial week are full weeks. We then have a nice square
	            // block of weeks. We do the usual rolling within this block,
	            // as is done elsewhere in this method. If we wind up on one of
	            // the phantom days that we added, we recognize this and pin to
	            // the first or the last day of the month. Easy, eh?
	
	            // Normalize the DAY_OF_WEEK so that 0 is the first day of the week
	            // in this locale. We have dow in 0..6.
	            int dow = InternalGet(DAY_OF_WEEK) - GetFirstDayOfWeek();
	            if (dow < 0)
	                dow += 7;
	
	            // Find the day of the week (normalized for locale) for the first
	            // of the month.
	            int fdm = (dow - InternalGet(DAY_OF_MONTH) + 1) % 7;
	            if (fdm < 0)
	                fdm += 7;
	
	            // Get the first day of the first full week of the month,
	            // including phantom days, if any. Figure out if the first week
	            // counts or not; if it counts, then fill in phantom days. If
	            // not, advance to the first real full week (skip the partial week).
	            int start_2;
	            if ((7 - fdm) < GetMinimalDaysInFirstWeek())
	                start_2 = 8 - fdm; // Skip the first partial week
	            else
	                start_2 = 1 - fdm; // This may be zero or negative
	
	            // Get the day of the week (normalized for locale) for the last
	            // day of the month.
	            int monthLen = GetActualMaximum(DAY_OF_MONTH);
	            int ldm = (monthLen - InternalGet(DAY_OF_MONTH) + dow) % 7;
	            // We know monthLen >= DAY_OF_MONTH so we skip the += 7 step here.
	
	            // Get the limit day for the blocked-off rectangular month; that
	            // is, the day which is one past the last day of the month,
	            // after the month has already been filled in with phantom days
	            // to fill out the last week. This day has a normalized DOW of 0.
	            int limit = monthLen + 7 - ldm;
	
	            // Now roll between start and (limit - 1).
	            int gap_3 = limit - start_2;
	            int day_of_month = (InternalGet(DAY_OF_MONTH) + amount * 7 - start_2)
	                    % gap_3;
	            if (day_of_month < 0)
	                day_of_month += gap_3;
	            day_of_month += start_2;
	
	            // Finally, pin to the real start and end of the month.
	            if (day_of_month < 1)
	                day_of_month = 1;
	            if (day_of_month > monthLen)
	                day_of_month = monthLen;
	
	            // Set the DAY_OF_MONTH. We rely on the fact that this field
	            // takes precedence over everything else (since all other fields
	            // are also set at this point). If this fact changes (if the
	            // disambiguation algorithm changes) then we will have to unset
	            // the appropriate fields here so that DAY_OF_MONTH is attended
	            // to.
	            Set(DAY_OF_MONTH, day_of_month);
	            return;
	        }
	        case WEEK_OF_YEAR: {
	            // This follows the outline of WEEK_OF_MONTH, except it applies
	            // to the whole year. Please see the comment for WEEK_OF_MONTH
	            // for general notes.
	
	            // Normalize the DAY_OF_WEEK so that 0 is the first day of the week
	            // in this locale. We have dow in 0..6.
	            int dow_4 = InternalGet(DAY_OF_WEEK) - GetFirstDayOfWeek();
	            if (dow_4 < 0)
	                dow_4 += 7;
	
	            // Find the day of the week (normalized for locale) for the first
	            // of the year.
	            int fdy = (dow_4 - InternalGet(DAY_OF_YEAR) + 1) % 7;
	            if (fdy < 0)
	                fdy += 7;
	
	            // Get the first day of the first full week of the year,
	            // including phantom days, if any. Figure out if the first week
	            // counts or not; if it counts, then fill in phantom days. If
	            // not, advance to the first real full week (skip the partial week).
	            int start_5;
	            if ((7 - fdy) < GetMinimalDaysInFirstWeek())
	                start_5 = 8 - fdy; // Skip the first partial week
	            else
	                start_5 = 1 - fdy; // This may be zero or negative
	
	            // Get the day of the week (normalized for locale) for the last
	            // day of the year.
	            int yearLen = GetActualMaximum(DAY_OF_YEAR);
	            int ldy = (yearLen - InternalGet(DAY_OF_YEAR) + dow_4) % 7;
	            // We know yearLen >= DAY_OF_YEAR so we skip the += 7 step here.
	
	            // Get the limit day for the blocked-off rectangular year; that
	            // is, the day which is one past the last day of the year,
	            // after the year has already been filled in with phantom days
	            // to fill out the last week. This day has a normalized DOW of 0.
	            int limit_6 = yearLen + 7 - ldy;
	
	            // Now roll between start and (limit - 1).
	            int gap_7 = limit_6 - start_5;
	            int day_of_year = (InternalGet(DAY_OF_YEAR) + amount * 7 - start_5)
	                    % gap_7;
	            if (day_of_year < 0)
	                day_of_year += gap_7;
	            day_of_year += start_5;
	
	            // Finally, pin to the real start and end of the month.
	            if (day_of_year < 1)
	                day_of_year = 1;
	            if (day_of_year > yearLen)
	                day_of_year = yearLen;
	
	            // Make sure that the year and day of year are attended to by
	            // clearing other fields which would normally take precedence.
	            // If the disambiguation algorithm is changed, this section will
	            // have to be updated as well.
	            Set(DAY_OF_YEAR, day_of_year);
	            Clear(MONTH);
	            return;
	        }
	        case DAY_OF_YEAR: {
	            // Roll the day of year using millis. Compute the millis for
	            // the start of the year, and get the length of the year.
	            long delta = amount * ONE_DAY; // Scale up from days to millis
	            long min2 = time - (InternalGet(DAY_OF_YEAR) - 1) * ONE_DAY;
	            int yearLength = GetActualMaximum(DAY_OF_YEAR);
	            time = (time + delta - min2) % (yearLength * ONE_DAY);
	            if (time < 0)
	                time += yearLength * ONE_DAY;
	            SetTimeInMillis(time + min2);
	            return;
	        }
	        case DAY_OF_WEEK:
	        case DOW_LOCAL: {
	            // Roll the day of week using millis. Compute the millis for
	            // the start of the week, using the first day of week setting.
	            // Restrict the millis to [start, start+7days).
	            long delta_8 = amount * ONE_DAY; // Scale up from days to millis
	            // Compute the number of days before the current day in this
	            // week. This will be a value 0..6.
	            int leadDays = InternalGet(field);
	            leadDays -= (field == DAY_OF_WEEK) ? GetFirstDayOfWeek() : 1;
	            if (leadDays < 0)
	                leadDays += 7;
	            long min2_9 = time - leadDays * ONE_DAY;
	            time = (time + delta_8 - min2_9) % ONE_WEEK;
	            if (time < 0)
	                time += ONE_WEEK;
	            SetTimeInMillis(time + min2_9);
	            return;
	        }
	        case DAY_OF_WEEK_IN_MONTH: {
	            // Roll the day of week in the month using millis. Determine
	            // the first day of the week in the month, and then the last,
	            // and then roll within that range.
	            long delta_10 = amount * ONE_WEEK; // Scale up from weeks to millis
	            // Find the number of same days of the week before this one
	            // in this month.
	            int preWeeks = (InternalGet(DAY_OF_MONTH) - 1) / 7;
	            // Find the number of same days of the week after this one
	            // in this month.
	            int postWeeks = (GetActualMaximum(DAY_OF_MONTH) - InternalGet(DAY_OF_MONTH)) / 7;
	            // From these compute the min and gap millis for rolling.
	            long min2_11 = time - preWeeks * ONE_WEEK;
	            long gap2 = ONE_WEEK * (preWeeks + postWeeks + 1); // Must add 1!
	            // Roll within this range
	            time = (time + delta_10 - min2_11) % gap2;
	            if (time < 0)
	                time += gap2;
	            SetTimeInMillis(time + min2_11);
	            return;
	        }
	        case JULIAN_DAY:
	            Set(field, InternalGet(field) + amount);
	            return;
	        default:
	            // Other fields cannot be rolled by this method
	            throw new ArgumentException("Calendar.roll("
	                    + FieldName(field) + ") not supported");
	        }
	    }
	
	    /// <summary>
	    /// Add a signed amount to a specified field, using this calendar's rules.
	    /// For example, to add three days to the current date, you can call
	    /// <c>add(Calendar.DATE, 3)</c>.
	    /// <p>
	    /// When adding to certain fields, the values of other fields may conflict
	    /// and need to be changed. For example, when adding one to the<see cref="M:IBM.ICU.Util.Calendar.MONTH MONTH"/> field for the Gregorian date 1/31/96, the<see cref="M:IBM.ICU.Util.Calendar.DAY_OF_MONTH DAY_OF_MONTH"/> field must be adjusted so that the
	    /// result is 2/29/96 rather than the invalid 2/31/96.
	    /// <p>
	    /// The <c>com.ibm.icu.util.Calendar</c> implementation of this method
	    /// is able to add to all fields except for <see cref="M:IBM.ICU.Util.Calendar.ERA ERA"/>,<see cref="M:IBM.ICU.Util.Calendar.DST_OFFSET DST_OFFSET"/>, and <see cref="M:IBM.ICU.Util.Calendar.ZONE_OFFSET ZONE_OFFSET"/>.
	    /// Subclasses may, of course, add support for additional fields in their
	    /// overrides of <c>add</c>.
	    /// <p>
	    /// <b>Note:</b> You should always use <tt>roll</tt> and <tt>add</tt> rather
	    /// than attempting to perform arithmetic operations directly on the fields
	    /// of a <tt>Calendar</tt>. It is quite possible for <tt>Calendar</tt>
	    /// subclasses to have fields with non-linear behavior, for example missing
	    /// months or days during non-leap years. The subclasses' <tt>add</tt> and
	    /// <tt>roll</tt> methods will take this into account, while simple
	    /// arithmetic manipulations may give invalid results.
	    /// <p>
	    /// <b>Subclassing:</b><br>
	    /// This implementation of <c>add</c> assumes that the behavior of the
	    /// field is continuous between its minimum and maximum, which are found by
	    /// calling <see cref="M:IBM.ICU.Util.Calendar.GetActualMinimum getActualMinimum"/> and<see cref="M:IBM.ICU.Util.Calendar.GetActualMaximum getActualMaximum"/>. For such fields, simple
	    /// arithmetic operations are sufficient to perform the add.
	    /// <p>
	    /// Subclasses that have fields for which this assumption of continuity
	    /// breaks down must overide <c>add</c> to handle those fields
	    /// specially. For example, in the Hebrew calendar the month "Adar I" only
	    /// occurs in leap years; in other years the calendar jumps from Shevat
	    /// (month #4) to Adar (month #6). The <see cref="M:IBM.ICU.Util.HebrewCalendar.AddHebrewCalendar.Add"/> method takes this into account, so that adding one
	    /// month to a date in Shevat gives the proper result (Adar) in a non-leap
	    /// year.
	    /// <p>
	    /// </summary>
	    ///
	    /// <param name="field">the time field.</param>
	    /// <param name="amount">the amount to add to the field.</param>
	    /// <exception cref="IllegalArgumentException">if the field is invalid or refers to a field that cannotbe handled by this method.</exception>
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.Roll(System.Int32, System.Int32)"/>
	    /// @stable ICU 2.0
	    public virtual void Add(int field, int amount) {
	
	        if (amount == 0) {
	            return; // Do nothing!
	        }
	
	        // We handle most fields in the same way. The algorithm is to add
	        // a computed amount of millis to the current millis. The only
	        // wrinkle is with DST -- for some fields, like the DAY_OF_MONTH,
	        // we don't want the HOUR to shift due to changes in DST. If the
	        // result of the add operation is to move from DST to Standard, or
	        // vice versa, we need to adjust by an hour forward or back,
	        // respectively. For such fields we set keepHourInvariant to true.
	
	        // We only adjust the DST for fields larger than an hour. For
	        // fields smaller than an hour, we cannot adjust for DST without
	        // causing problems. for instance, if you add one hour to April 5,
	        // 1998, 1:00 AM, in PST, the time becomes "2:00 AM PDT" (an
	        // illegal value), but then the adjustment sees the change and
	        // compensates by subtracting an hour. As a result the time
	        // doesn't advance at all.
	
	        // For some fields larger than a day, such as a MONTH, we pin the
	        // DAY_OF_MONTH. This allows <March 31>.add(MONTH, 1) to be
	        // <April 30>, rather than <April 31> => <May 1>.
	
	        long delta = amount; // delta in ms
	        bool keepHourInvariant = true;
	
	        switch (field) {
	        case ERA:
	            Set(field, Get(field) + amount);
	            PinField(ERA);
	            return;
	
	        case YEAR:
	        case EXTENDED_YEAR:
	        case YEAR_WOY:
	        case MONTH:
	            Set(field, Get(field) + amount);
	            PinField(DAY_OF_MONTH);
	            return;
	
	        case WEEK_OF_YEAR:
	        case WEEK_OF_MONTH:
	        case DAY_OF_WEEK_IN_MONTH:
	            delta *= ONE_WEEK;
	            break;
	
	        case AM_PM:
	            delta *= 12 * ONE_HOUR;
	            break;
	
	        case DAY_OF_MONTH:
	        case DAY_OF_YEAR:
	        case DAY_OF_WEEK:
	        case DOW_LOCAL:
	        case JULIAN_DAY:
	            delta *= ONE_DAY;
	            break;
	
	        case HOUR_OF_DAY:
	        case HOUR:
	            delta *= ONE_HOUR;
	            keepHourInvariant = false;
	            break;
	
	        case MINUTE:
	            delta *= ONE_MINUTE;
	            keepHourInvariant = false;
	            break;
	
	        case SECOND:
	            delta *= ONE_SECOND;
	            keepHourInvariant = false;
	            break;
	
	        case MILLISECOND:
	        case MILLISECONDS_IN_DAY:
	            keepHourInvariant = false;
	            break;
	
	        default:
	            throw new ArgumentException("Calendar.add("
	                    + FieldName(field) + ") not supported");
	        }
	
	        // In order to keep the hour invariant (for fields where this is
	        // appropriate), record the DST_OFFSET before and after the add()
	        // operation. If it has changed, then adjust the millis to
	        // compensate.
	        int dst = 0;
	        int hour = 0;
	        if (keepHourInvariant) {
	            dst = Get(DST_OFFSET);
	            hour = InternalGet(HOUR_OF_DAY);
	        }
	
	        SetTimeInMillis(GetTimeInMillis() + delta);
	
	        if (keepHourInvariant) {
	            dst -= Get(DST_OFFSET);
	            if (dst != 0) {
	                // We have done an hour-invariant adjustment but the
	                // DST offset has altered. We adjust millis to keep
	                // the hour constant. In cases such as midnight after
	                // a DST change which occurs at midnight, there is the
	                // danger of adjusting into a different day. To avoid
	                // this we make the adjustment only if it actually
	                // maintains the hour.
	                long t = time;
	                SetTimeInMillis(time + dst);
	                if (Get(HOUR_OF_DAY) != hour) {
	                    SetTimeInMillis(t);
	                }
	            }
	        }
	    }
	
	    /// <summary>
	    /// Return the name of this calendar in the language of the given locale.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public String GetDisplayName(Locale loc) {
	        return ((Object) this).GetType().FullName;
	    }
	
	    /// <summary>
	    /// Return the name of this calendar in the language of the given locale.
	    /// </summary>
	    ///
	    /// @stable ICU 3.2
	    public String GetDisplayName(ULocale loc) {
            return ((Object)this).GetType().FullName;
	    }
	
	    /// <summary>
	    /// Compares the times (in millis) represented by two <c>Calendar</c>
	    /// objects.
	    /// </summary>
	    ///
	    /// <param name="that">the <c>Calendar</c> to compare to this.</param>
	    /// <returns><c>0</c> if the time represented by this
	    /// <c>Calendar</c> is equal to the time represented by that
	    /// <c>Calendar</c>, a value less than <c>0</c> if the
	    /// time represented by this is before the time represented by that,
	    /// and a value greater than <c>0</c> if the time represented
	    /// by this is after the time represented by that.</returns>
	    /// <exception cref="NullPointerException">if that <c>Calendar</c> is null.</exception>
	    /// <exception cref="IllegalArgumentException">if the time of that <c>Calendar</c> can't be obtainedbecause of invalid calendar values.</exception>
	    /// @stable ICU 3.4
	    public int CompareTo(Calendar that) {
	        long v = GetTimeInMillis() - that.GetTimeInMillis();
	        return (v < 0) ? -1 : ((v > 0) ? 1 : 0);
	    }
	
	    /// <summary>
	    /// Implement comparable API as a convenience override of<see cref="M:IBM.ICU.Util.Calendar.CompareTo(IBM.ICU.Util.Calendar)"/>.
	    /// </summary>
	    ///
	    /// @stable ICU 3.4
	    public virtual int CompareTo(Object that) {
	        return CompareTo((Calendar) that);
	    }
	
	    // -------------------------------------------------------------------------
	    // Interface for creating custon DateFormats for different types of
	    // Calendars
	    // -------------------------------------------------------------------------
	
	    /// <summary>
	    /// Return a <c>DateFormat</c> appropriate to this calendar. Subclasses
	    /// wishing to specialize this behavior should override
	    /// <c>handleGetDateFormat()</c>
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.HandleGetDateFormat(System.String, null)"/>
	    /// @stable ICU 2.0
        public IBM.ICU.Text.DateFormat GetDateTimeFormat(int dateStyle, int timeStyle, Locale loc)
        {
	        return FormatHelper(this, IBM.ICU.Util.ULocale.ForLocale(loc), dateStyle, timeStyle);
	    }
	
	    /// <summary>
	    /// Return a <c>DateFormat</c> appropriate to this calendar. Subclasses
	    /// wishing to specialize this behavior should override
	    /// <c>handleGetDateFormat()</c>
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.HandleGetDateFormat(System.String, null)"/>
	    /// @stable ICU 3.2
	    public IBM.ICU.Text.DateFormat GetDateTimeFormat(int dateStyle, int timeStyle,
	            ULocale loc) {
	        return FormatHelper(this, loc, dateStyle, timeStyle);
	    }
	
	    /// <summary>
	    /// Create a <c>DateFormat</c> appropriate to this calendar. This is a
	    /// framework method for subclasses to override. This method is responsible
	    /// for creating the calendar-specific DateFormat and DateFormatSymbols
	    /// objects as needed.
	    /// </summary>
	    ///
	    /// <param name="pattern">the pattern, specific to the <c>DateFormat</c> subclass</param>
	    /// <param name="locale">the locale for which the symbols should be drawn</param>
	    /// <returns>a <c>DateFormat</c> appropriate to this calendar</returns>
	    /// @stable ICU 2.0
        protected internal IBM.ICU.Text.DateFormat HandleGetDateFormat(String pattern, Locale locale)
        {
	        return HandleGetDateFormat(pattern, IBM.ICU.Util.ULocale.ForLocale(locale));
	    }
	
	    /// <summary>
	    /// Create a <c>DateFormat</c> appropriate to this calendar. This is a
	    /// framework method for subclasses to override. This method is responsible
	    /// for creating the calendar-specific DateFormat and DateFormatSymbols
	    /// objects as needed.
	    /// </summary>
	    ///
	    /// <param name="pattern">the pattern, specific to the <c>DateFormat</c> subclass</param>
	    /// <param name="locale">the locale for which the symbols should be drawn</param>
	    /// <returns>a <c>DateFormat</c> appropriate to this calendar</returns>
	    /// @draft ICU 3.2
	    /// @provisional This API might change or be removed in a future release.
	    protected internal virtual IBM.ICU.Text.DateFormat HandleGetDateFormat(String pattern, ULocale locale) {
	        Calendar.FormatConfiguration  fmtConfig = new Calendar.FormatConfiguration ();
	        fmtConfig.pattern = pattern;
	        fmtConfig.formatData = new IBM.ICU.Text.DateFormatSymbols(this, locale);
	        fmtConfig.loc = locale;
	        fmtConfig.cal = this;
	
	        return IBM.ICU.Text.SimpleDateFormat.GetInstance(fmtConfig);
	    }
	
	    // date format pattern cache
	    private static readonly ICUCache PATTERN_CACHE = new SimpleCache();
	
	    // final fallback patterns
	    private static readonly String[] DEFAULT_PATTERNS = { "HH:mm:ss z",
	            "HH:mm:ss z", "HH:mm:ss", "HH:mm", "EEEE, yyyy MMMM dd",
	            "yyyy MMMM d", "yyyy MMM d", "yy/MM/dd", "{1} {0}" };
	
	    static private IBM.ICU.Text.DateFormat FormatHelper(Calendar cal, ULocale loc,
	            int dateStyle, int timeStyle) {
	        // First, try to get a pattern from PATTERN_CACHE
	        String key = loc.ToString() + cal.GetType();
	        String[] patterns = (String[]) PATTERN_CACHE.Get(key);
	        if (patterns == null) {
	            // Cache missed. Get one from bundle
	            try {
	                CalendarData calData = new CalendarData(loc, cal.GetType());
	                patterns = calData.Get("DateTimePatterns").GetStringArray();
	            } catch (MissingManifestResourceException e) {
	                patterns = DEFAULT_PATTERNS;
	            }
	            PATTERN_CACHE.Put(key, patterns);
	        }
	        // Resolve a pattern for the date/time style
	        String pattern = null;
	        if ((timeStyle >= 0) && (dateStyle >= 0)) {
	            pattern = IBM.ICU.Text.MessageFormat.Format(patterns[8], new Object[] {
	                    patterns[timeStyle], patterns[dateStyle + 4] });
	        } else if (timeStyle >= 0) {
	            pattern = patterns[timeStyle];
	        } else if (dateStyle >= 0) {
	            pattern = patterns[dateStyle + 4];
	        } else {
	            throw new ArgumentException(
	                    "No date or time style specified");
	        }
	        IBM.ICU.Text.DateFormat result = cal.HandleGetDateFormat(pattern, loc);
	        result.SetCalendar(cal);
	        return result;
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// An instance of FormatConfiguration represents calendar specific date
	    /// format configuration and used for calling the ICU private
	    /// SimpleDateFormat factory method.
	    /// </summary>
	    ///
	    public class FormatConfiguration {
	        public String pattern;

            public IBM.ICU.Text.DateFormatSymbols formatData;

            public Calendar cal;

            public ULocale loc;
	
	        // Only Calendar can instantiate
	        public FormatConfiguration() {
	        }
	
	        /// <exclude/>
	        /// <summary>
	        /// Gets the pattern string
	        /// </summary>
	        ///
	        /// <returns>the format pattern string</returns>
	        public String GetPatternString() {
	            return pattern;
	        }
	
	        /// <exclude/>
	        /// <summary>
	        /// Gets the calendar
	        /// </summary>
	        ///
	        /// <returns>the calendar</returns>
	        public Calendar GetCalendar() {
	            return cal;
	        }
	
	        /// <exclude/>
	        /// <summary>
	        /// Gets the locale
	        /// </summary>
	        ///
	        /// <returns>the locale</returns>
	        public ULocale GetLocale() {
	            return loc;
	        }
	
	        /// <exclude/>
	        /// <summary>
	        /// Gets the format symbols
	        /// </summary>
	        ///
	        /// <returns>the format symbols</returns>
	        public IBM.ICU.Text.DateFormatSymbols GetDateFormatSymbols() {
	            return formatData;
	        }
	    }
	
	    // -------------------------------------------------------------------------
	    // Protected utility methods for use by subclasses. These are very handy
	    // for implementing add, roll, and computeFields.
	    // -------------------------------------------------------------------------
	
	    /// <summary>
	    /// Adjust the specified field so that it is within the allowable range for
	    /// the date to which this calendar is set. For example, in a Gregorian
	    /// calendar pinning the <see cref="M:IBM.ICU.Util.Calendar.DAY_OF_MONTH DAY_OF_MONTH"/> field for a
	    /// calendar set to April 31 would cause it to be set to April 30.
	    /// <p>
	    /// <b>Subclassing:</b> <br>
	    /// This utility method is intended for use by subclasses that need to
	    /// implement their own overrides of <see cref="M:IBM.ICU.Util.Calendar.Roll roll"/> and <see cref="M:IBM.ICU.Util.Calendar.Add add"/>.
	    /// <p>
	    /// <b>Note:</b> <c>pinField</c> is implemented in terms of<see cref="M:IBM.ICU.Util.Calendar.GetActualMinimum getActualMinimum"/> and <see cref="M:IBM.ICU.Util.Calendar.GetActualMaximumgetActualMaximum"/>. If either of those methods uses a slow, iterative
	    /// algorithm for a particular field, it would be unwise to attempt to call
	    /// <c>pinField</c> for that field. If you really do need to do so, you
	    /// should override this method to do something more efficient for that
	    /// field.
	    /// <p>
	    /// </summary>
	    ///
	    /// <param name="field">The calendar field whose value should be pinned.</param>
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.GetActualMinimum(System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.GetActualMaximum(System.Int32)"/>
	    /// @stable ICU 2.0
	    protected internal void PinField(int field) {
	        int max = GetActualMaximum(field);
	        int min = GetActualMinimum(field);
	
	        if (fields[field] > max) {
	            Set(field, max);
	        } else if (fields[field] < min) {
	            Set(field, min);
	        }
	    }
	
	    /// <summary>
	    /// Return the week number of a day, within a period. This may be the week
	    /// number in a year or the week number in a month. Usually this will be a
	    /// value >= 1, but if some initial days of the period are excluded from week
	    /// 1, because <see cref="M:IBM.ICU.Util.Calendar.GetMinimalDaysInFirstWeek getMinimalDaysInFirstWeek"/>is > 1, then the week number will be zero for those initial days. This
	    /// method requires the day number and day of week for some known date in the
	    /// period in order to determine the day of week on the desired day.
	    /// <p>
	    /// <b>Subclassing:</b> <br>
	    /// This method is intended for use by subclasses in implementing their<see cref="M:IBM.ICU.Util.Calendar.ComputeTime computeTime"/> and/or <see cref="M:IBM.ICU.Util.Calendar.ComputeFieldscomputeFields"/> methods. It is often useful in <see cref="M:IBM.ICU.Util.Calendar.GetActualMinimumgetActualMinimum"/> and <see cref="M:IBM.ICU.Util.Calendar.GetActualMaximum getActualMaximum"/> as well.
	    /// <p>
	    /// This variant is handy for computing the week number of some other day of
	    /// a period (often the first or last day of the period) when its day of the
	    /// week is not known but the day number and day of week for some other day
	    /// in the period (e.g. the current date) <em>is</em> known.
	    /// <p>
	    /// </summary>
	    ///
	    /// <param name="desiredDay">The <see cref="M:IBM.ICU.Util.Calendar.DAY_OF_YEAR DAY_OF_YEAR"/> or <see cref="M:IBM.ICU.Util.Calendar.DAY_OF_MONTHDAY_OF_MONTH"/> whose week number is desired. Should be 1 forthe first day of the period.</param>
	    /// <param name="dayOfPeriod">The <see cref="M:IBM.ICU.Util.Calendar.DAY_OF_YEAR DAY_OF_YEAR"/> or <see cref="M:IBM.ICU.Util.Calendar.DAY_OF_MONTHDAY_OF_MONTH"/> for a day in the period whose<see cref="M:IBM.ICU.Util.Calendar.DAY_OF_WEEK DAY_OF_WEEK"/> is specified by the<c>dayOfWeek</c> parameter. Should be 1 for first day ofperiod.</param>
	    /// <param name="dayOfWeek">The <see cref="M:IBM.ICU.Util.Calendar.DAY_OF_WEEK DAY_OF_WEEK"/> for the day correspondingto the <c>dayOfPeriod</c> parameter. 1-based with1=Sunday.</param>
	    /// <returns>The week number (one-based), or zero if the day falls before the
	    /// first week because 
	    /// <see cref="M:IBM.ICU.Util.Calendar.GetMinimalDaysInFirstWeekgetMinimalDaysInFirstWeek"/>
	    ///  is more than one.</returns>
	    /// @stable ICU 2.0
	    protected internal int WeekNumber(int desiredDay, int dayOfPeriod, int dayOfWeek) {
	        // Determine the day of the week of the first day of the period
	        // in question (either a year or a month). Zero represents the
	        // first day of the week on this calendar.
	        int periodStartDayOfWeek = (dayOfWeek - GetFirstDayOfWeek()
	                - dayOfPeriod + 1) % 7;
	        if (periodStartDayOfWeek < 0)
	            periodStartDayOfWeek += 7;
	
	        // Compute the week number. Initially, ignore the first week, which
	        // may be fractional (or may not be). We add periodStartDayOfWeek in
	        // order to fill out the first week, if it is fractional.
	        int weekNo = (desiredDay + periodStartDayOfWeek - 1) / 7;
	
	        // If the first week is long enough, then count it. If
	        // the minimal days in the first week is one, or if the period start
	        // is zero, we always increment weekNo.
	        if ((7 - periodStartDayOfWeek) >= GetMinimalDaysInFirstWeek())
	            ++weekNo;
	
	        return weekNo;
	    }
	
	    /// <summary>
	    /// Return the week number of a day, within a period. This may be the week
	    /// number in a year, or the week number in a month. Usually this will be a
	    /// value >= 1, but if some initial days of the period are excluded from week
	    /// 1, because <see cref="M:IBM.ICU.Util.Calendar.GetMinimalDaysInFirstWeek getMinimalDaysInFirstWeek"/>is > 1, then the week number will be zero for those initial days. This
	    /// method requires the day of week for the given date in order to determine
	    /// the result.
	    /// <p>
	    /// <b>Subclassing:</b> <br>
	    /// This method is intended for use by subclasses in implementing their<see cref="M:IBM.ICU.Util.Calendar.ComputeTime computeTime"/> and/or <see cref="M:IBM.ICU.Util.Calendar.ComputeFieldscomputeFields"/> methods. It is often useful in <see cref="M:IBM.ICU.Util.Calendar.GetActualMinimumgetActualMinimum"/> and <see cref="M:IBM.ICU.Util.Calendar.GetActualMaximum getActualMaximum"/> as well.
	    /// <p>
	    /// </summary>
	    ///
	    /// <param name="dayOfPeriod">The <see cref="M:IBM.ICU.Util.Calendar.DAY_OF_YEAR DAY_OF_YEAR"/> or <see cref="M:IBM.ICU.Util.Calendar.DAY_OF_MONTHDAY_OF_MONTH"/> whose week number is desired. Should be 1 forthe first day of the period.</param>
	    /// <param name="dayOfWeek">The <see cref="M:IBM.ICU.Util.Calendar.DAY_OF_WEEK DAY_OF_WEEK"/> for the day correspondingto the <c>dayOfPeriod</c> parameter. 1-based with1=Sunday.</param>
	    /// <returns>The week number (one-based), or zero if the day falls before the
	    /// first week because 
	    /// <see cref="M:IBM.ICU.Util.Calendar.GetMinimalDaysInFirstWeekgetMinimalDaysInFirstWeek"/>
	    ///  is more than one.</returns>
	    /// @stable ICU 2.0
	    protected internal int WeekNumber(int dayOfPeriod, int dayOfWeek) {
	        return WeekNumber(dayOfPeriod, dayOfPeriod, dayOfWeek);
	    }
	
	    // -------------------------------------------------------------------------
	    // Constants
	    // -------------------------------------------------------------------------
	
	    /// <summary>
	    /// [NEW] Return the difference between the given time and the time this
	    /// calendar object is set to. If this calendar is set <em>before</em> the
	    /// given time, the returned value will be positive. If this calendar is set
	    /// <em>after</em> the given time, the returned value will be negative. The
	    /// <c>field</c> parameter specifies the units of the return value. For
	    /// example, if <code>fieldDifference(when,
	    /// Calendar.MONTH)</code> returns 3, then this calendar is set to 3 months
	    /// before <c>when</c>, and possibly some additional time less than one
	    /// month.
	    /// <p>
	    /// As a side effect of this call, this calendar is advanced toward
	    /// <c>when</c> by the given amount. That is, calling this method has
	    /// the side effect of calling <code>add(field,
	    /// n)</code>, where <c>n</c> is the return value.
	    /// <p>
	    /// Usage: To use this method, call it first with the largest field of
	    /// interest, then with progressively smaller fields. For example:
	    /// <pre>
	    /// int y = cal.fieldDifference(when, Calendar.YEAR);
	    /// int m = cal.fieldDifference(when, Calendar.MONTH);
	    /// int d = cal.fieldDifference(when, Calendar.DATE);
	    /// </pre>
	    /// computes the difference between <c>cal</c> and <c>when</c> in
	    /// years, months, and days.
	    /// <p>
	    /// Note: <c>fieldDifference()</c> is <em>asymmetrical</em>. That is,
	    /// in the following code:
	    /// <pre>
	    /// cal.setTime(date1);
	    /// int m1 = cal.fieldDifference(date2, Calendar.MONTH);
	    /// int d1 = cal.fieldDifference(date2, Calendar.DATE);
	    /// cal.setTime(date2);
	    /// int m2 = cal.fieldDifference(date1, Calendar.MONTH);
	    /// int d2 = cal.fieldDifference(date1, Calendar.DATE);
	    /// </pre>
	    /// one might expect that <c>m1 == -m2 && d1 == -d2</c>. However, this
	    /// is not generally the case, because of irregularities in the underlying
	    /// calendar system (e.g., the Gregorian calendar has a varying number of
	    /// days per month).
	    /// </summary>
	    ///
	    /// <param name="when">the date to compare this calendar's time to</param>
	    /// <param name="field">the field in which to compute the result</param>
	    /// <returns>the difference, either positive or negative, between this
	    /// calendar's time and <c>when</c>, in terms of
	    /// <c>field</c>.</returns>
	    /// @stable ICU 2.0
	    public int FieldDifference(DateTime when, int field) {
	        int min = 0;
	        long startMs = GetTimeInMillis();
	        long targetMs = (when.Ticks/10000);
	        // Always add from the start millis. This accomodates
	        // operations like adding years from February 29, 2000 up to
	        // February 29, 2004. If 1, 1, 1, 1 is added to the year
	        // field, the DOM gets pinned to 28 and stays there, giving an
	        // incorrect DOM difference of 1. We have to add 1, reset, 2,
	        // reset, 3, reset, 4.
	        if (startMs < targetMs) {
	            int max = 1;
	            // Find a value that is too large
	            for (;;) {
	                SetTimeInMillis(startMs);
	                Add(field, max);
	                long ms = GetTimeInMillis();
	                if (ms == targetMs) {
	                    return max;
	                } else if (ms > targetMs) {
	                    break;
	                } else {
	                    max <<= 1;
	                    if (max < 0) {
	                        // Field difference too large to fit into int
	                        throw new Exception();
	                    }
	                }
	            }
	            // Do a binary search
	            while ((max - min) > 1) {
	                int t = (min + max) / 2;
	                SetTimeInMillis(startMs);
	                Add(field, t);
	                long ms_0 = GetTimeInMillis();
	                if (ms_0 == targetMs) {
	                    return t;
	                } else if (ms_0 > targetMs) {
	                    max = t;
	                } else {
	                    min = t;
	                }
	            }
	        } else if (startMs > targetMs) {
	            if (false) {
	                // This works, and makes the code smaller, but costs
	                // an extra object creation and an extra couple cycles
	                // of calendar computation.
	                SetTimeInMillis(targetMs);
	                min = -FieldDifference(new DateTime((startMs)*10000), field);
	            }
	            int max_1 = -1;
	            // Find a value that is too small
	            for (;;) {
	                SetTimeInMillis(startMs);
	                Add(field, max_1);
	                long ms_2 = GetTimeInMillis();
	                if (ms_2 == targetMs) {
	                    return max_1;
	                } else if (ms_2 < targetMs) {
	                    break;
	                } else {
	                    max_1 <<= 1;
	                    if (max_1 == 0) {
	                        // Field difference too large to fit into int
	                        throw new Exception();
	                    }
	                }
	            }
	            // Do a binary search
	            while ((min - max_1) > 1) {
	                int t_3 = (min + max_1) / 2;
	                SetTimeInMillis(startMs);
	                Add(field, t_3);
	                long ms_4 = GetTimeInMillis();
	                if (ms_4 == targetMs) {
	                    return t_3;
	                } else if (ms_4 < targetMs) {
	                    max_1 = t_3;
	                } else {
	                    min = t_3;
	                }
	            }
	        }
	        // Set calendar to end point
	        SetTimeInMillis(startMs);
	        Add(field, min);
	        return min;
	    }
	
	    /// <summary>
	    /// Sets the time zone with the given time zone value.
	    /// </summary>
	    ///
	    /// <param name="value">the given time zone.</param>
	    /// @stable ICU 2.0
	    public void SetTimeZone(TimeZone value_ren) {
	        zone = value_ren;
	        /*
	         * Recompute the fields from the time using the new zone. This also
	         * works if isTimeSet is false (after a call to set()). In that case the
	         * time will be computed from the fields using the new zone, then the
	         * fields will get recomputed from that. Consider the sequence of calls:
	         * cal.setTimeZone(EST); cal.set(HOUR, 1); cal.setTimeZone(PST). Is cal
	         * set to 1 o'clock EST or 1 o'clock PST? Answer: PST. More generally, a
	         * call to setTimeZone() affects calls to set() BEFORE AND AFTER it up
	         * to the next call to complete().
	         */
	        areFieldsSet = false;
	    }
	
	    /// <summary>
	    /// Gets the time zone.
	    /// </summary>
	    ///
	    /// <returns>the time zone object associated with this calendar.</returns>
	    /// @stable ICU 2.0
	    public TimeZone GetTimeZone() {
	        return zone;
	    }
	
	    /// <summary>
	    /// Specify whether or not date/time interpretation is to be lenient. With
	    /// lenient interpretation, a date such as "February 942, 1996" will be
	    /// treated as being equivalent to the 941st day after February 1, 1996. With
	    /// strict interpretation, such dates will cause an exception to be thrown.
	    /// </summary>
	    ///
	    /// <seealso cref="null"/>
	    /// @stable ICU 2.0
	    public void SetLenient(bool lenient_0) {
	        this.lenient = lenient_0;
	    }
	
	    /// <summary>
	    /// Tell whether date/time interpretation is to be lenient.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public bool IsLenient() {
	        return lenient;
	    }
	
	    /// <summary>
	    /// Sets what the first day of the week is; e.g., Sunday in US, Monday in
	    /// France.
	    /// </summary>
	    ///
	    /// <param name="value">the given first day of the week.</param>
	    /// @stable ICU 2.0
	    public void SetFirstDayOfWeek(int value_ren) {
	        if (firstDayOfWeek != value_ren) {
	            if (value_ren < SUNDAY || value_ren > SATURDAY) {
	                throw new ArgumentException("Invalid day of week");
	            }
	            firstDayOfWeek = value_ren;
	            areFieldsSet = false;
	        }
	    }
	
	    /// <summary>
	    /// Gets what the first day of the week is; e.g., Sunday in US, Monday in
	    /// France.
	    /// </summary>
	    ///
	    /// <returns>the first day of the week.</returns>
	    /// @stable ICU 2.0
	    public int GetFirstDayOfWeek() {
	        return firstDayOfWeek;
	    }
	
	    /// <summary>
	    /// Sets what the minimal days required in the first week of the year are.
	    /// For example, if the first week is defined as one that contains the first
	    /// day of the first month of a year, call the method with value 1. If it
	    /// must be a full week, use value 7.
	    /// </summary>
	    ///
	    /// <param name="value">the given minimal days required in the first week of the year.</param>
	    /// @stable ICU 2.0
	    public void SetMinimalDaysInFirstWeek(int value_ren) {
	        // Values less than 1 have the same effect as 1; values greater
	        // than 7 have the same effect as 7. However, we normalize values
	        // so operator== and so forth work.
	        if (value_ren < 1) {
	            value_ren = 1;
	        } else if (value_ren > 7) {
	            value_ren = 7;
	        }
	        if (minimalDaysInFirstWeek != value_ren) {
	            minimalDaysInFirstWeek = value_ren;
	            areFieldsSet = false;
	        }
	    }
	
	    /// <summary>
	    /// Gets what the minimal days required in the first week of the year are;
	    /// e.g., if the first week is defined as one that contains the first day of
	    /// the first month of a year, getMinimalDaysInFirstWeek returns 1. If the
	    /// minimal days required must be a full week, getMinimalDaysInFirstWeek
	    /// returns 7.
	    /// </summary>
	    ///
	    /// <returns>the minimal days required in the first week of the year.</returns>
	    /// @stable ICU 2.0
	    public int GetMinimalDaysInFirstWeek() {
	        return minimalDaysInFirstWeek;
	    }
	
	    private static readonly int[][] LIMITS = {
	            new int[] {},
	            new int[] {},
	            new int[] {},
	            new int[] {},
	            new int[] {},
	            new int[] {},
	            new int[] {},
	            new int[] { 1, 1, 7, 7 },
	            new int[] {},
	            new int[] { 0, 0, 1, 1 },
	            new int[] { 0, 0, 11, 11 },
	            new int[] { 0, 0, 23, 23 },
	            new int[] { 0, 0, 59, 59 },
	            new int[] { 0, 0, 59, 59 },
	            new int[] { 0, 0, 999, 999 },
	            new int[] { -12 * ONE_HOUR, -12 * ONE_HOUR, 12 * ONE_HOUR,
	                    12 * ONE_HOUR },
	            new int[] { 0, 0, 1 * ONE_HOUR, 1 * ONE_HOUR }, new int[] {},
	            new int[] { 1, 1, 7, 7 }, new int[] {},
	            new int[] { -0x7F000000, -0x7F000000, 0x7F000000, 0x7F000000 },
	            new int[] { 0, 0, 24 * ONE_HOUR - 1, 24 * ONE_HOUR - 1 } };
	
	    /// <summary>
	    /// Subclass API for defining limits of different types. Subclasses must
	    /// implement this method to return limits for the following fields:
	    /// <pre>
	    /// ERA
	    /// YEAR
	    /// MONTH
	    /// WEEK_OF_YEAR
	    /// WEEK_OF_MONTH
	    /// DAY_OF_MONTH
	    /// DAY_OF_YEAR
	    /// DAY_OF_WEEK_IN_MONTH
	    /// YEAR_WOY
	    /// EXTENDED_YEAR
	    /// </pre>
	    /// </summary>
	    ///
	    /// <param name="field">one of the above field numbers</param>
	    /// <param name="limitType">one of <c>MINIMUM</c>, <c>GREATEST_MINIMUM</c>,<c>LEAST_MAXIMUM</c>, or <c>MAXIMUM</c></param>
	    /// @stable ICU 2.0
	    abstract protected internal int HandleGetLimit(int field, int limitType);
	
	    /// <summary>
	    /// Return a limit for a field.
	    /// </summary>
	    ///
	    /// <param name="field">the field, from 0..</code>getFieldCount()-1</code></param>
	    /// <param name="limitType">the type specifier for the limit</param>
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.MINIMUM"/>
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.GREATEST_MINIMUM"/>
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.LEAST_MAXIMUM"/>
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.MAXIMUM"/>
	    /// @stable ICU 2.0
	    protected internal int GetLimit(int field, int limitType) {
	        switch (field) {
	        case DAY_OF_WEEK:
	        case AM_PM:
	        case HOUR:
	        case HOUR_OF_DAY:
	        case MINUTE:
	        case SECOND:
	        case MILLISECOND:
	        case ZONE_OFFSET:
	        case DST_OFFSET:
	        case DOW_LOCAL:
	        case JULIAN_DAY:
	        case MILLISECONDS_IN_DAY:
	            return LIMITS[field][limitType];
	        }
	        return HandleGetLimit(field, limitType);
	    }
	
	    /// <summary>
	    /// Limit type for <c>getLimit()</c> and <c>handleGetLimit()</c>
	    /// indicating the minimum value that a field can take (least minimum).
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.GetLimit(System.Int32, System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.HandleGetLimit(System.Int32, System.Int32)"/>
	    /// @stable ICU 2.0
	    protected internal const int MINIMUM = 0;
	
	    /// <summary>
	    /// Limit type for <c>getLimit()</c> and <c>handleGetLimit()</c>
	    /// indicating the greatest minimum value that a field can take.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.GetLimit(System.Int32, System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.HandleGetLimit(System.Int32, System.Int32)"/>
	    /// @stable ICU 2.0
	    protected internal const int GREATEST_MINIMUM = 1;
	
	    /// <summary>
	    /// Limit type for <c>getLimit()</c> and <c>handleGetLimit()</c>
	    /// indicating the least maximum value that a field can take.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.GetLimit(System.Int32, System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.HandleGetLimit(System.Int32, System.Int32)"/>
	    /// @stable ICU 2.0
	    protected internal const int LEAST_MAXIMUM = 2;
	
	    /// <summary>
	    /// Limit type for <c>getLimit()</c> and <c>handleGetLimit()</c>
	    /// indicating the maximum value that a field can take (greatest maximum).
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.GetLimit(System.Int32, System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.HandleGetLimit(System.Int32, System.Int32)"/>
	    /// @stable ICU 2.0
	    protected internal const int MAXIMUM = 3;
	
	    /// <summary>
	    /// Gets the minimum value for the given time field. e.g., for Gregorian
	    /// DAY_OF_MONTH, 1.
	    /// </summary>
	    ///
	    /// <param name="field">the given time field.</param>
	    /// <returns>the minimum value for the given time field.</returns>
	    /// @stable ICU 2.0
	    public int GetMinimum(int field) {
	        return GetLimit(field, MINIMUM);
	    }
	
	    /// <summary>
	    /// Gets the maximum value for the given time field. e.g. for Gregorian
	    /// DAY_OF_MONTH, 31.
	    /// </summary>
	    ///
	    /// <param name="field">the given time field.</param>
	    /// <returns>the maximum value for the given time field.</returns>
	    /// @stable ICU 2.0
	    public int GetMaximum(int field) {
	        return GetLimit(field, MAXIMUM);
	    }
	
	    /// <summary>
	    /// Gets the highest minimum value for the given field if varies. Otherwise
	    /// same as getMinimum(). For Gregorian, no difference.
	    /// </summary>
	    ///
	    /// <param name="field">the given time field.</param>
	    /// <returns>the highest minimum value for the given time field.</returns>
	    /// @stable ICU 2.0
	    public int GetGreatestMinimum(int field) {
	        return GetLimit(field, GREATEST_MINIMUM);
	    }
	
	    /// <summary>
	    /// Gets the lowest maximum value for the given field if varies. Otherwise
	    /// same as getMaximum(). e.g., for Gregorian DAY_OF_MONTH, 28.
	    /// </summary>
	    ///
	    /// <param name="field">the given time field.</param>
	    /// <returns>the lowest maximum value for the given time field.</returns>
	    /// @stable ICU 2.0
	    public int GetLeastMaximum(int field) {
	        return GetLimit(field, LEAST_MAXIMUM);
	    }
	
	    // -------------------------------------------------------------------------
	    // Weekend support -- determining which days of the week are the weekend
	    // in a given locale
	    // -------------------------------------------------------------------------
	
	    /// <summary>
	    /// Return whether the given day of the week is a weekday, a weekend day, or
	    /// a day that transitions from one to the other, in this calendar system. If
	    /// a transition occurs at midnight, then the days before and after the
	    /// transition will have the type WEEKDAY or WEEKEND. If a transition occurs
	    /// at a time other than midnight, then the day of the transition will have
	    /// the type WEEKEND_ONSET or WEEKEND_CEASE. In this case, the method
	    /// getWeekendTransition() will return the point of transition.
	    /// </summary>
	    ///
	    /// <param name="dayOfWeek">either SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY,or SATURDAY</param>
	    /// <returns>either WEEKDAY, WEEKEND, WEEKEND_ONSET, or WEEKEND_CEASE</returns>
	    /// <exception cref="IllegalArgumentException">if dayOfWeek is not between SUNDAY and SATURDAY, inclusive</exception>
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.WEEKDAY"/>
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.WEEKEND"/>
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.WEEKEND_ONSET"/>
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.WEEKEND_CEASE"/>
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.GetWeekendTransition(System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.IsWeekend(null)"/>
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.IsWeekend(null)"/>
	    /// @stable ICU 2.0
	    public int GetDayOfWeekType(int dayOfWeek) {
	        if (dayOfWeek < SUNDAY || dayOfWeek > SATURDAY) {
	            throw new ArgumentException("Invalid day of week");
	        }
	        if (weekendOnset < weekendCease) {
	            if (dayOfWeek < weekendOnset || dayOfWeek > weekendCease) {
	                return WEEKDAY;
	            }
	        } else {
	            if (dayOfWeek > weekendCease && dayOfWeek < weekendOnset) {
	                return WEEKDAY;
	            }
	        }
	        if (dayOfWeek == weekendOnset) {
	            return (weekendOnsetMillis == 0) ? WEEKEND : WEEKEND_ONSET;
	        }
	        if (dayOfWeek == weekendCease) {
	            return (weekendCeaseMillis == 0) ? WEEKDAY : WEEKEND_CEASE;
	        }
	        return WEEKEND;
	    }
	
	    /// <summary>
	    /// Return the time during the day at which the weekend begins or end in this
	    /// calendar system. If getDayOfWeekType(dayOfWeek) == WEEKEND_ONSET return
	    /// the time at which the weekend begins. If getDayOfWeekType(dayOfWeek) ==
	    /// WEEKEND_CEASE return the time at which the weekend ends. If
	    /// getDayOfWeekType(dayOfWeek) has some other value, then throw an
	    /// exception.
	    /// </summary>
	    ///
	    /// <param name="dayOfWeek">either SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY,or SATURDAY</param>
	    /// <returns>the milliseconds after midnight at which the weekend begins or
	    /// ends</returns>
	    /// <exception cref="IllegalArgumentException">if dayOfWeek is not WEEKEND_ONSET or WEEKEND_CEASE</exception>
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.GetDayOfWeekType(System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.IsWeekend(null)"/>
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.IsWeekend(null)"/>
	    /// @stable ICU 2.0
	    public int GetWeekendTransition(int dayOfWeek) {
	        if (dayOfWeek == weekendOnset) {
	            return weekendOnsetMillis;
	        } else if (dayOfWeek == weekendCease) {
	            return weekendCeaseMillis;
	        }
	        throw new ArgumentException("Not weekend transition day");
	    }
	
	    /// <summary>
	    /// Return true if the given date and time is in the weekend in this calendar
	    /// system. Equivalent to calling setTime() followed by isWeekend(). Note:
	    /// This method changes the time this calendar is set to.
	    /// </summary>
	    ///
	    /// <param name="date">the date and time</param>
	    /// <returns>true if the given date and time is part of the weekend</returns>
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.GetDayOfWeekType(System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.GetWeekendTransition(System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.IsWeekend(null)"/>
	    /// @stable ICU 2.0
	    public bool IsWeekend(DateTime date) {
	        SetTime(date);
	        return IsWeekend();
	    }
	
	    /// <summary>
	    /// Return true if this Calendar's current date and time is in the weekend in
	    /// this calendar system.
	    /// </summary>
	    ///
	    /// <returns>true if the given date and time is part of the weekend</returns>
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.GetDayOfWeekType(System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.GetWeekendTransition(System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.IsWeekend(null)"/>
	    /// @stable ICU 2.0
	    public bool IsWeekend() {
	        int dow = Get(DAY_OF_WEEK);
	        int dowt = GetDayOfWeekType(dow);
	        switch (dowt) {
	        case WEEKDAY:
	            return false;
	        case WEEKEND:
	            return true;
	        default: // That is, WEEKEND_ONSET or WEEKEND_CEASE
	            // Use internalGet() because the above call to get() populated
	            // all fields.
	            // [Note: There should be a better way to get millis in day.
	            // For ICU4J, submit request for a MILLIS_IN_DAY field
	            // and a DAY_NUMBER field (could be Julian day #). - aliu]
	            int millisInDay = InternalGet(MILLISECOND)
	                    + 1000
	                    * (InternalGet(SECOND) + 60 * (InternalGet(MINUTE) + 60 * InternalGet(HOUR_OF_DAY)));
	            int transition = GetWeekendTransition(dow);
	            return (dowt == WEEKEND_ONSET) ? (millisInDay >= transition)
	                    : (millisInDay < transition);
	        }
	        // (We can never reach this point.)
	    }
	
	    // -------------------------------------------------------------------------
	    // End of weekend support
	    // -------------------------------------------------------------------------
	
	    /// <summary>
	    /// Overrides Cloneable
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public virtual Object Clone() {
	        try {
	            Calendar other = (Calendar) base.MemberwiseClone();
	
	            other.fields = new int[fields.Length];
	            other.stamp = new int[fields.Length];
	            System.Array.Copy((Array)(this.fields),0,(Array)(other.fields),0,fields.Length);
	            System.Array.Copy((Array)(this.stamp),0,(Array)(other.stamp),0,fields.Length);
	
	            other.zone = (TimeZone) zone.Clone();
	            return other;
	        } catch (Exception e) {
	            // this shouldn't happen, since we are Cloneable
	            throw new InvalidOperationException();
	        }
	    }
	
	    /// <summary>
	    /// Return a string representation of this calendar. This method is intended
	    /// to be used only for debugging purposes, and the format of the returned
	    /// string may vary between implementations. The returned string may be empty
	    /// but may not be <c>null</c>.
	    /// </summary>
	    ///
	    /// <returns>a string representation of this calendar.</returns>
	    /// @stable ICU 2.0
	    public override String ToString() {
	        StringBuilder buffer = new StringBuilder();
            buffer.Append(((Object)this).GetType().FullName);
	        buffer.Append("[time=");
	        buffer.Append((isTimeSet) ? time.ToString() : "?");
	        buffer.Append(",areFieldsSet=");
	        buffer.Append(areFieldsSet);
	        buffer.Append(",areAllFieldsSet=");
	        buffer.Append(areAllFieldsSet);
	        buffer.Append(",lenient=");
	        buffer.Append(lenient);
	        buffer.Append(",zone=");
	        buffer.Append(zone);
	        buffer.Append(",firstDayOfWeek=");
	        buffer.Append(firstDayOfWeek);
	        buffer.Append(",minimalDaysInFirstWeek=");
	        buffer.Append(minimalDaysInFirstWeek);
	        for (int i = 0; i < fields.Length; ++i) {
	            buffer.Append(',').Append(FieldName(i)).Append('=');
	            buffer.Append((IsSet(i)) ? fields[i].ToString() : "?");
	        }
	        buffer.Append(']');
	        return buffer.ToString();
	    }
	
	    // =======================privates===============================
	
	    /// <summary>
	    /// Internal class that holds cached locale data.
	    /// </summary>
	    ///
	    private class WeekData {
	        public int firstDayOfWeek;
	
	        public int minimalDaysInFirstWeek;
	
	        public int weekendOnset;
	
	        public int weekendOnsetMillis;
	
	        public int weekendCease;
	
	        public int weekendCeaseMillis;
	
	        public ULocale actualLocale;
	
	        public WeekData(int fdow, int mdifw, int weekendOnset_0,
	                int weekendOnsetMillis_1, int weekendCease_2,
	                int weekendCeaseMillis_3, ULocale actualLoc) {
	            this.firstDayOfWeek = fdow;
	            this.minimalDaysInFirstWeek = mdifw;
	            this.actualLocale = actualLoc;
	            this.weekendOnset = weekendOnset_0;
	            this.weekendOnsetMillis = weekendOnsetMillis_1;
	            this.weekendCease = weekendCease_2;
	            this.weekendCeaseMillis = weekendCeaseMillis_3;
	        }
	    }
	
	    /// <summary>
	    /// Set this calendar to contain week and weekend data for the given locale.
	    /// </summary>
	    ///
	    /// <param name="locale">the locale</param>
	    private void SetWeekData(ULocale locale) {
	        /* try to get the Locale data from the cache */
	        Calendar.WeekData  data = (Calendar.WeekData ) cachedLocaleData[locale];
	
	        if (data == null) { /* cache miss */
	
	            CalendarData calData = new CalendarData(locale, GetType());
	            int[] dateTimeElements = calData.Get("DateTimeElements")
	                    .GetIntVector();
	            int[] weekend = calData.Get("weekend").GetIntVector();
	            data = new Calendar.WeekData (dateTimeElements[0], dateTimeElements[1],
	                    weekend[0], weekend[1], weekend[2], weekend[3],
	                    calData.GetULocale());
	            /* cache update */
	            ILOG.J2CsMapping.Collections.Collections.Put(cachedLocaleData,locale,data);
	        }
	        SetFirstDayOfWeek(data.firstDayOfWeek);
	        SetMinimalDaysInFirstWeek(data.minimalDaysInFirstWeek);
	        weekendOnset = data.weekendOnset;
	        weekendOnsetMillis = data.weekendOnsetMillis;
	        weekendCease = data.weekendCease;
	        weekendCeaseMillis = data.weekendCeaseMillis;
	
	        // TODO: determine the actual/valid locale
	        ULocale uloc = data.actualLocale;
	        SetLocale(uloc, uloc);
	    }
	
	    /// <summary>
	    /// Recompute the time and update the status fields isTimeSet and
	    /// areFieldsSet. Callers should check isTimeSet and only call this method if
	    /// isTimeSet is false.
	    /// </summary>
	    ///
	    private void UpdateTime() {
	        ComputeTime();
	        // If we are lenient, we need to recompute the fields to normalize
	        // the values. Also, if we haven't set all the fields yet (i.e.,
	        // in a newly-created object), we need to fill in the fields. [LIU]
	        if (IsLenient() || !areAllFieldsSet)
	            areFieldsSet = false;
	        isTimeSet = true;
	        areFieldsVirtuallySet = false;
	    }
	
	    /// <summary>
	    /// Save the state of this object to a stream (i.e., serialize it).
	    /// </summary>
	    ///
	    private void WriteObject(IlObjectOutputStream stream) {
	        // Try to compute the time correctly, for the future (stream
	        // version 2) in which we don't write out fields[] or isSet[].
	        if (!isTimeSet) {
	            try {
	                UpdateTime();
	            } catch (ArgumentException e) {
	            }
	        }
	
	        // Write out the 1.1 FCS object.
	        stream.DefaultWriteObject();
	    }
	
	    /// <summary>
	    /// Reconstitute this object from a stream (i.e., deserialize it).
	    /// </summary>
	    ///
	    private void ReadObject(IlObjectInputStream stream) {
	
	        stream.DefaultReadObject();
	
	        InitInternal();
	
	        isTimeSet = true;
	        areFieldsSet = areAllFieldsSet = false;
	        areFieldsVirtuallySet = true; // cause fields to be recalculated if
	                                      // requested.
	        nextStamp = MINIMUM_USER_STAMP;
	    }
	
	    // ----------------------------------------------------------------------
	    // Time -> Fields
	    // ----------------------------------------------------------------------
	
	    /// <summary>
	    /// Converts the current millisecond time value <c>time</c> to field
	    /// values in <c>fields[]</c>. This synchronizes the time field values
	    /// with a new time that is set for the calendar. The time is <em>not</em>
	    /// recomputed first; to recompute the time, then the fields, call the
	    /// <c>complete</c> method.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.Complete"/>
	    /// @stable ICU 2.0
	    protected internal void ComputeFields() {
	        int[] offsets = new int[2];
	        GetTimeZone().GetOffset(time, false, offsets);
	        long localMillis = time + offsets[0] + offsets[1];
	
	        // Mark fields as set. Do this before calling handleComputeFields().
	        int mask = internalSetMask;
	        for (int i = 0; i < fields.Length; ++i) {
	            if ((mask & 1) == 0) {
	                stamp[i] = INTERNALLY_SET;
	            } else {
	                stamp[i] = UNSET;
	            }
	            mask >>= 1;
	        }
	
	        // We used to check for and correct extreme millis values (near
	        // Long.MIN_VALUE or Long.MAX_VALUE) here. Such values would cause
	        // overflows from positive to negative (or vice versa) and had to
	        // be manually tweaked. We no longer need to do this because we
	        // have limited the range of supported dates to those that have a
	        // Julian day that fits into an int. This allows us to implement a
	        // JULIAN_DAY field and also removes some inelegant code. - Liu
	        // 11/6/00
	
	        long days = FloorDivide(localMillis, ONE_DAY);
	
	        fields[JULIAN_DAY] = (int) days + EPOCH_JULIAN_DAY;
	
	        ComputeGregorianAndDOWFields(fields[JULIAN_DAY]);
	
	        // Call framework method to have subclass compute its fields.
	        // These must include, at a minimum, MONTH, DAY_OF_MONTH,
	        // EXTENDED_YEAR, YEAR, DAY_OF_YEAR. This method will call
	        // internalSet(),
	        // which will update stamp[].
	        HandleComputeFields(fields[JULIAN_DAY]);
	
	        // Compute week-related fields, based on the subclass-computed
	        // fields computed by handleComputeFields().
	        ComputeWeekFields();
	
	        // Compute time-related fields. These are indepent of the date and
	        // of the subclass algorithm. They depend only on the local zone
	        // wall milliseconds in day.
	        int millisInDay = (int) (localMillis - (days * ONE_DAY));
	        fields[MILLISECONDS_IN_DAY] = millisInDay;
	        fields[MILLISECOND] = millisInDay % 1000;
	        millisInDay /= 1000;
	        fields[SECOND] = millisInDay % 60;
	        millisInDay /= 60;
	        fields[MINUTE] = millisInDay % 60;
	        millisInDay /= 60;
	        fields[HOUR_OF_DAY] = millisInDay;
	        fields[AM_PM] = millisInDay / 12; // Assume AM == 0
	        fields[HOUR] = millisInDay % 12;
	        fields[ZONE_OFFSET] = offsets[0];
	        fields[DST_OFFSET] = offsets[1];
	    }
	
	    /// <summary>
	    /// Compute the Gregorian calendar year, month, and day of month from the
	    /// given Julian day. These values are not stored in fields, but in member
	    /// variables gregorianXxx. Also compute the DAY_OF_WEEK and DOW_LOCAL
	    /// fields.
	    /// </summary>
	    ///
	    private void ComputeGregorianAndDOWFields(int julianDay) {
	        ComputeGregorianFields(julianDay);
	
	        // Compute day of week: JD 0 = Monday
	        int dow = fields[DAY_OF_WEEK] = JulianDayToDayOfWeek(julianDay);
	
	        // Calculate 1-based localized day of week
	        int dowLocal = dow - GetFirstDayOfWeek() + 1;
	        if (dowLocal < 1) {
	            dowLocal += 7;
	        }
	        fields[DOW_LOCAL] = dowLocal;
	    }
	
	    /// <summary>
	    /// Compute the Gregorian calendar year, month, and day of month from the
	    /// Julian day. These values are not stored in fields, but in member
	    /// variables gregorianXxx. They are used for time zone computations and by
	    /// subclasses that are Gregorian derivatives. Subclasses may call this
	    /// method to perform a Gregorian calendar millis->fields computation. To
	    /// perform a Gregorian calendar fields->millis computation, call
	    /// computeGregorianMonthStart().
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.ComputeGregorianMonthStart(System.Int32, System.Int32)"/>
	    /// @stable ICU 2.0
	    protected internal void ComputeGregorianFields(int julianDay) {
	        int year, month, dayOfMonth, dayOfYear;
	
	        // The Gregorian epoch day is zero for Monday January 1, year 1.
	        long gregorianEpochDay = julianDay - JAN_1_1_JULIAN_DAY;
	
	        // Here we convert from the day number to the multiple radix
	        // representation. We use 400-year, 100-year, and 4-year cycles.
	        // For example, the 4-year cycle has 4 years + 1 leap day; giving
	        // 1461 == 365*4 + 1 days.
	        int[] rem = new int[1];
	        int n400 = FloorDivide(gregorianEpochDay, 146097, rem); // 400-year
	                                                                // cycle length
	        int n100 = FloorDivide(rem[0], 36524, rem); // 100-year cycle length
	        int n4 = FloorDivide(rem[0], 1461, rem); // 4-year cycle length
	        int n1 = FloorDivide(rem[0], 365, rem);
	        year = 400 * n400 + 100 * n100 + 4 * n4 + n1;
	        dayOfYear = rem[0]; // zero-based day of year
	        if (n100 == 4 || n1 == 4) {
	            dayOfYear = 365; // Dec 31 at end of 4- or 400-yr cycle
	        } else {
	            ++year;
	        }
	
	        bool isLeap = ((year & 0x3) == 0) && // equiv. to (year%4 == 0)
	                (year % 100 != 0 || year % 400 == 0);
	
	        int correction = 0;
	        int march1 = (isLeap) ? 60 : 59; // zero-based DOY for March 1
	        if (dayOfYear >= march1)
	            correction = (isLeap) ? 1 : 2;
	        month = (12 * (dayOfYear + correction) + 6) / 367; // zero-based month
	        dayOfMonth = dayOfYear - GREGORIAN_MONTH_COUNT[month][(isLeap) ? 3 : 2]
	                + 1; // one-based DOM
	
	        gregorianYear = year;
	        gregorianMonth = month; // 0-based already
	        gregorianDayOfMonth = dayOfMonth; // 1-based already
	        gregorianDayOfYear = dayOfYear + 1; // Convert from 0-based to 1-based
	    }
	
	    /// <summary>
	    /// Compute the fields WEEK_OF_YEAR, YEAR_WOY, WEEK_OF_MONTH,
	    /// DAY_OF_WEEK_IN_MONTH, and DOW_LOCAL from EXTENDED_YEAR, YEAR,
	    /// DAY_OF_WEEK, and DAY_OF_YEAR. The latter fields are computed by the
	    /// subclass based on the calendar system.
	    /// <p>
	    /// The YEAR_WOY field is computed simplistically. It is equal to YEAR most
	    /// of the time, but at the year boundary it may be adjusted to YEAR-1 or
	    /// YEAR+1 to reflect the overlap of a week into an adjacent year. In this
	    /// case, a simple increment or decrement is performed on YEAR, even though
	    /// this may yield an invalid YEAR value. For instance, if the YEAR is part
	    /// of a calendar system with an N-year cycle field CYCLE, then incrementing
	    /// the YEAR may involve incrementing CYCLE and setting YEAR back to 0 or 1.
	    /// This is not handled by this code, and in fact cannot be simply handled
	    /// without having subclasses define an entire parallel set of fields for
	    /// fields larger than or equal to a year. This additional complexity is not
	    /// warranted, since the intention of the YEAR_WOY field is to support ISO
	    /// 8601 notation, so it will typically be used with a proleptic Gregorian
	    /// calendar, which has no field larger than a year.
	    /// </summary>
	    ///
	    private void ComputeWeekFields() {
	        int eyear = fields[EXTENDED_YEAR];
	        int year = fields[YEAR];
	        int dayOfWeek = fields[DAY_OF_WEEK];
	        int dayOfYear = fields[DAY_OF_YEAR];
	
	        // WEEK_OF_YEAR start
	        // Compute the week of the year. For the Gregorian calendar, valid week
	        // numbers run from 1 to 52 or 53, depending on the year, the first day
	        // of the week, and the minimal days in the first week. For other
	        // calendars, the valid range may be different -- it depends on the year
	        // length. Days at the start of the year may fall into the last week of
	        // the previous year; days at the end of the year may fall into the
	        // first week of the next year. ASSUME that the year length is less than
	        // 7000 days.
	        int yearOfWeekOfYear = year;
	        int relDow = (dayOfWeek + 7 - GetFirstDayOfWeek()) % 7; // 0..6
	        int relDowJan1 = (dayOfWeek - dayOfYear + 7001 - GetFirstDayOfWeek()) % 7; // 0..6
	        int woy = (dayOfYear - 1 + relDowJan1) / 7; // 0..53
	        if ((7 - relDowJan1) >= GetMinimalDaysInFirstWeek()) {
	            ++woy;
	        }
	
	        // Adjust for weeks at the year end that overlap into the previous or
	        // next calendar year.
	        if (woy == 0) {
	            // We are the last week of the previous year.
	            // Check to see if we are in the last week; if so, we need
	            // to handle the case in which we are the first week of the
	            // next year.
	
	            int prevDoy = dayOfYear + HandleGetYearLength(eyear - 1);
	            woy = WeekNumber(prevDoy, dayOfWeek);
	            yearOfWeekOfYear--;
	        } else {
	            int lastDoy = HandleGetYearLength(eyear);
	            // Fast check: For it to be week 1 of the next year, the DOY
	            // must be on or after L-5, where L is yearLength(), then it
	            // cannot possibly be week 1 of the next year:
	            // L-5 L
	            // doy: 359 360 361 362 363 364 365 001
	            // dow: 1 2 3 4 5 6 7
	            if (dayOfYear >= (lastDoy - 5)) {
	                int lastRelDow = (relDow + lastDoy - dayOfYear) % 7;
	                if (lastRelDow < 0) {
	                    lastRelDow += 7;
	                }
	                if (((6 - lastRelDow) >= GetMinimalDaysInFirstWeek())
	                        && ((dayOfYear + 7 - relDow) > lastDoy)) {
	                    woy = 1;
	                    yearOfWeekOfYear++;
	                }
	            }
	        }
	        fields[WEEK_OF_YEAR] = woy;
	        fields[YEAR_WOY] = yearOfWeekOfYear;
	        // WEEK_OF_YEAR end
	
	        int dayOfMonth = fields[DAY_OF_MONTH];
	        fields[WEEK_OF_MONTH] = WeekNumber(dayOfMonth, dayOfWeek);
	        fields[DAY_OF_WEEK_IN_MONTH] = (dayOfMonth - 1) / 7 + 1;
	    }
	
	    // ----------------------------------------------------------------------
	    // Fields -> Time
	    // ----------------------------------------------------------------------
	
	    /// <summary>
	    /// Value to OR against resolve table field values for remapping.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.ResolveFields(null)"/>
	    /// @stable ICU 2.0
	    protected internal const int RESOLVE_REMAP = 32;
	
	    // A power of 2 greater than or equal to MAX_FIELD_COUNT
	
	    // Default table for day in year
	    static internal readonly int[][][] DATE_PRECEDENCE = {
	            new int[][] { new int[] { DAY_OF_MONTH }, new int[]{ WEEK_OF_YEAR, DAY_OF_WEEK },
	                    new int[]{ WEEK_OF_MONTH, DAY_OF_WEEK },
	                    new int[]{ DAY_OF_WEEK_IN_MONTH, DAY_OF_WEEK },
	                    new int[]{ WEEK_OF_YEAR, DOW_LOCAL }, new int[]{ WEEK_OF_MONTH, DOW_LOCAL },
	                    new int[]{ DAY_OF_WEEK_IN_MONTH, DOW_LOCAL }, new int[]{ DAY_OF_YEAR } },
	            new int[][] { new int[]{ WEEK_OF_YEAR }, new int[]{ WEEK_OF_MONTH },
	                   new int[] { DAY_OF_WEEK_IN_MONTH },
	                    new int[]{ RESOLVE_REMAP | DAY_OF_WEEK_IN_MONTH, DAY_OF_WEEK },
	                    new int[]{ RESOLVE_REMAP | DAY_OF_WEEK_IN_MONTH, DOW_LOCAL } } };

        static internal readonly int[][][] DOW_PRECEDENCE = { new int[][] { new int[] { DAY_OF_WEEK }, new int[] { DOW_LOCAL } } };
	
	    /// <summary>
	    /// Given a precedence table, return the newest field combination in the
	    /// table, or -1 if none is found.
	    /// <p>
	    /// The precedence table is a 3-dimensional array of integers. It may be
	    /// thought of as an array of groups. Each group is an array of lines. Each
	    /// line is an array of field numbers. Within a line, if all fields are set,
	    /// then the time stamp of the line is taken to be the stamp of the most
	    /// recently set field. If any field of a line is unset, then the line fails
	    /// to match. Within a group, the line with the newest time stamp is
	    /// selected. The first field of the line is returned to indicate which line
	    /// matched.
	    /// <p>
	    /// In some cases, it may be desirable to map a line to field that whose
	    /// stamp is NOT examined. For example, if the best field is DAY_OF_WEEK then
	    /// the DAY_OF_WEEK_IN_MONTH algorithm may be used. In order to do this,
	    /// insert the value <c>REMAP_RESOLVE | F</c> at the start of the line,
	    /// where <c>F</c> is the desired return field value. This field will
	    /// NOT be examined; it only determines the return value if the other fields
	    /// in the line are the newest.
	    /// <p>
	    /// If all lines of a group contain at least one unset field, then no line
	    /// will match, and the group as a whole will fail to match. In that case,
	    /// the next group will be processed. If all groups fail to match, then -1 is
	    /// returned.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    protected internal int ResolveFields(int[][][] precedenceTable) {
	        int bestField = -1;
	        for (int g = 0; g < precedenceTable.Length && bestField < 0; ++g) {
	            int[][] group = precedenceTable[g];
	            int bestStamp = UNSET;
                int l = 0;
	            linesInGroup: {
	                for (; l < group.Length; ++l) {
	                    int[] line = group[l];
	                    int lineStamp = UNSET;
	                    // Skip over first entry if it is negative
	                    for (int i = (line[0] >= RESOLVE_REMAP) ? 1 : 0; i < line.Length; ++i) {
	                        int s = stamp[line[i]];
	                        // If any field is unset then don't use this line
	                        if (s == UNSET) {
                                ++l;
	                            goto linesInGroup;
	                        } else {
	                            lineStamp = Math.Max(lineStamp,s);
	                        }
	                    }
	                    // Record new maximum stamp & field no.
	                    if (lineStamp > bestStamp) {
	                        bestStamp = lineStamp;
	                        bestField = line[0]; // First field refers to entire line
	                    }
	                }
	            }
	            gotolinesInGroup:
	            ;
	        }
	        return (bestField >= RESOLVE_REMAP) ? (bestField & (RESOLVE_REMAP - 1))
	                : bestField;
	    }
	
	    /// <summary>
	    /// Return the newest stamp of a given range of fields.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    protected internal int NewestStamp(int first, int last, int bestStampSoFar) {
	        int bestStamp = bestStampSoFar;
	        for (int i = first; i <= last; ++i) {
	            if (stamp[i] > bestStamp) {
	                bestStamp = stamp[i];
	            }
	        }
	        return bestStamp;
	    }
	
	    /// <summary>
	    /// Return the timestamp of a field.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    protected internal int GetStamp(int field) {
	        return stamp[field];
	    }
	
	    /// <summary>
	    /// Return the field that is newer, either defaultField, or alternateField.
	    /// If neither is newer or neither is set, return defaultField.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    protected internal int NewerField(int defaultField, int alternateField) {
	        if (stamp[alternateField] > stamp[defaultField]) {
	            return alternateField;
	        }
	        return defaultField;
	    }
	
	    /// <summary>
	    /// Ensure that each field is within its valid range by calling<see cref="M:IBM.ICU.Util.Calendar.ValidateField(System.Int32)"/> on each field that has been set. This method
	    /// should only be called if this calendar is not lenient.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.IsLenient"/>
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.ValidateField(System.Int32)"/>
	    /// @stable ICU 2.0
	    protected internal void ValidateFields() {
	        for (int field = 0; field < fields.Length; field++) {
	            if (IsSet(field)) {
	                ValidateField(field);
	            }
	        }
	    }
	
	    /// <summary>
	    /// Validate a single field of this calendar. Subclasses should override this
	    /// method to validate any calendar-specific fields. Generic fields can be
	    /// handled by <c>Calendar.validateField()</c>.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.ValidateField(System.Int32, System.Int32, System.Int32)"/>
	    /// @stable ICU 2.0
	    protected internal void ValidateField(int field) {
	        int y;
	        switch (field) {
	        case DAY_OF_MONTH:
	            y = HandleGetExtendedYear();
	            ValidateField(field, 1, HandleGetMonthLength(y, InternalGet(MONTH)));
	            break;
	        case DAY_OF_YEAR:
	            y = HandleGetExtendedYear();
	            ValidateField(field, 1, HandleGetYearLength(y));
	            break;
	        case DAY_OF_WEEK_IN_MONTH:
	            if (InternalGet(field) == 0) {
	                throw new ArgumentException(
	                        "DAY_OF_WEEK_IN_MONTH cannot be zero");
	            }
	            ValidateField(field, GetMinimum(field), GetMaximum(field));
	            break;
	        default:
	            ValidateField(field, GetMinimum(field), GetMaximum(field));
	            break;
	        }
	    }
	
	    /// <summary>
	    /// Validate a single field of this calendar given its minimum and maximum
	    /// allowed value. If the field is out of range, throw a descriptive
	    /// <c>IllegalArgumentException</c>. Subclasses may use this method in
	    /// their implementation of <see cref="M:IBM.ICU.Util.Calendar.ValidateField(System.Int32)"/>.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    protected internal void ValidateField(int field, int min, int max) {
	        int value_ren = fields[field];
	        if (value_ren < min || value_ren > max) {
	            throw new ArgumentException(FieldName(field) + '=' + value_ren
	                    + ", valid range=" + min + ".." + max);
	        }
	    }
	
	    /// <summary>
	    /// Converts the current field values in <c>fields[]</c> to the
	    /// millisecond time value <c>time</c>.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    protected internal void ComputeTime() {
	        if (!IsLenient()) {
	            ValidateFields();
	        }
	
	        // Compute the Julian day
	        int julianDay = ComputeJulianDay();
	
	        long millis = JulianDayToMillis(julianDay);
	
	        int millisInDay;
	
	        // We only use MILLISECONDS_IN_DAY if it has been set by the user.
	        // This makes it possible for the caller to set the calendar to a
	        // time and call clear(MONTH) to reset the MONTH to January. This
	        // is legacy behavior. Without this, clear(MONTH) has no effect,
	        // since the internally set JULIAN_DAY is used.
	        if (stamp[MILLISECONDS_IN_DAY] >= MINIMUM_USER_STAMP
	                && NewestStamp(AM_PM, MILLISECOND, UNSET) <= stamp[MILLISECONDS_IN_DAY]) {
	            millisInDay = InternalGet(MILLISECONDS_IN_DAY);
	        } else {
	            millisInDay = ComputeMillisInDay();
	        }
	
	        // Compute the time zone offset and DST offset. There are two potential
	        // ambiguities here. We'll assume a 2:00 am (wall time) switchover time
	        // for discussion purposes here.
	        // 1. The transition into DST. Here, a designated time of 2:00 am - 2:59
	        // am
	        // can be in standard or in DST depending. However, 2:00 am is an
	        // invalid
	        // representation (the representation jumps from 1:59:59 am Std to
	        // 3:00:00 am DST).
	        // We assume standard time, that is, 2:30 am is interpreted as 3:30 am
	        // DST.
	        // 2. The transition out of DST. Here, a designated time of 1:00 am -
	        // 1:59 am
	        // can be in standard or DST. Both are valid representations (the rep
	        // jumps from 1:59:59 DST to 1:00:00 Std).
	        // Again, we assume standard time, that is, 1:30 am is interpreted as
	        // 1:30 am Std.
	        // We use the TimeZone object, unless the user has explicitly set the
	        // ZONE_OFFSET
	        // or DST_OFFSET fields; then we use those fields.
	        if (stamp[ZONE_OFFSET] >= MINIMUM_USER_STAMP
	                || stamp[DST_OFFSET] >= MINIMUM_USER_STAMP) {
	            millisInDay -= InternalGet(ZONE_OFFSET) + InternalGet(DST_OFFSET);
	        } else {
	            millisInDay -= ComputeZoneOffset(millis, millisInDay);
	        }
	
	        time = millis + millisInDay;
	    }
	
	    /// <summary>
	    /// Compute the milliseconds in the day from the fields. This is a value from
	    /// 0 to 23:59:59.999 inclusive, unless fields are out of range, in which
	    /// case it can be an arbitrary value. This value reflects local zone wall
	    /// time.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    protected internal int ComputeMillisInDay() {
	        // Do the time portion of the conversion.
	
	        int millisInDay = 0;
	
	        // Find the best set of fields specifying the time of day. There
	        // are only two possibilities here; the HOUR_OF_DAY or the
	        // AM_PM and the HOUR.
	        int hourOfDayStamp = stamp[HOUR_OF_DAY];
	        int hourStamp = Math.Max(stamp[HOUR],stamp[AM_PM]);
	        int bestStamp = (hourStamp > hourOfDayStamp) ? hourStamp
	                : hourOfDayStamp;
	
	        // Hours
	        if (bestStamp != UNSET) {
	            if (bestStamp == hourOfDayStamp) {
	                // Don't normalize here; let overflow bump into the next period.
	                // This is consistent with how we handle other fields.
	                millisInDay += InternalGet(HOUR_OF_DAY);
	            } else {
	                // Don't normalize here; let overflow bump into the next period.
	                // This is consistent with how we handle other fields.
	                millisInDay += InternalGet(HOUR);
	                millisInDay += 12 * InternalGet(AM_PM); // Default works for
	                                                        // unset AM_PM
	            }
	        }
	
	        // We use the fact that unset == 0; we start with millisInDay
	        // == HOUR_OF_DAY.
	        millisInDay *= 60;
	        millisInDay += InternalGet(MINUTE); // now have minutes
	        millisInDay *= 60;
	        millisInDay += InternalGet(SECOND); // now have seconds
	        millisInDay *= 1000;
	        millisInDay += InternalGet(MILLISECOND); // now have millis
	
	        return millisInDay;
	    }
	
	    /// <summary>
	    /// This method can assume EXTENDED_YEAR has been set.
	    /// </summary>
	    ///
	    /// <param name="millis">milliseconds of the date fields (local midnight millis)</param>
	    /// <param name="millisInDay">milliseconds of the time fields; may be out or range.</param>
	    /// <returns>total zone offset (raw + DST) for the given moment</returns>
	    /// @stable ICU 2.0
	    protected internal int ComputeZoneOffset(long millis, int millisInDay) {
	        int[] offsets = new int[2];
	        zone.GetOffset(millis + millisInDay, true, offsets);
	        return offsets[0] + offsets[1];
	
	        // Note: Because we pass in wall millisInDay, rather than
	        // standard millisInDay, we interpret "1:00 am" on the day
	        // of cessation of DST as "1:00 am Std" (assuming the time
	        // of cessation is 2:00 am).
	    }
	
	    /// <summary>
	    /// Compute the Julian day number as specified by this calendar's fields.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    protected internal int ComputeJulianDay() {
	
	        // We want to see if any of the date fields is newer than the
	        // JULIAN_DAY. If not, then we use JULIAN_DAY. If so, then we do
	        // the normal resolution. We only use JULIAN_DAY if it has been
	        // set by the user. This makes it possible for the caller to set
	        // the calendar to a time and call clear(MONTH) to reset the MONTH
	        // to January. This is legacy behavior. Without this,
	        // clear(MONTH) has no effect, since the internally set JULIAN_DAY
	        // is used.
	        if (stamp[JULIAN_DAY] >= MINIMUM_USER_STAMP) {
	            int bestStamp = NewestStamp(ERA, DAY_OF_WEEK_IN_MONTH, UNSET);
	            bestStamp = NewestStamp(YEAR_WOY, EXTENDED_YEAR, bestStamp);
	            if (bestStamp <= stamp[JULIAN_DAY]) {
	                return InternalGet(JULIAN_DAY);
	            }
	        }
	
	        int bestField = ResolveFields(GetFieldResolutionTable());
	        if (bestField < 0) {
	            bestField = DAY_OF_MONTH;
	        }
	
	        return HandleComputeJulianDay(bestField);
	    }
	
	    /// <summary>
	    /// Return the field resolution array for this calendar. Calendars that
	    /// define additional fields or change the semantics of existing fields
	    /// should override this method to adjust the field resolution semantics
	    /// accordingly. Other subclasses should not override this method.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.ResolveFields(null)"/>
	    /// @stable ICU 2.0
	    protected internal virtual int[][][] GetFieldResolutionTable() {
	        return DATE_PRECEDENCE;
	    }
	
	    /// <summary>
	    /// Return the Julian day number of day before the first day of the given
	    /// month in the given extended year. Subclasses should override this method
	    /// to implement their calendar system.
	    /// </summary>
	    ///
	    /// <param name="eyear">the extended year</param>
	    /// <param name="month">the zero-based month, or 0 if useMonth is false</param>
	    /// <param name="useMonth">if false, compute the day before the first day of the givenyear, otherwise, compute the day before the first day of thegiven month</param>
	    /// <returns>the Julian day number of the day before the first day of the
	    /// given month and year</returns>
	    /// @stable ICU 2.0
	    abstract protected internal int HandleComputeMonthStart(int eyear, int month,
	            bool useMonth);
	
	    /// <summary>
	    /// Return the extended year defined by the current fields. This will use the
	    /// EXTENDED_YEAR field or the YEAR and supra-year fields (such as ERA)
	    /// specific to the calendar system, depending on which set of fields is
	    /// newer.
	    /// </summary>
	    ///
	    /// <returns>the extended year</returns>
	    /// @stable ICU 2.0
	    abstract protected internal int HandleGetExtendedYear();
	
	    // (The following method is not called because all existing subclasses
	    // override it. 2003-06-11 ICU 2.6 Alan)
	    // /CLOVER:OFF
	    /// <summary>
	    /// Return the number of days in the given month of the given extended year
	    /// of this calendar system. Subclasses should override this method if they
	    /// can provide a more correct or more efficient implementation than the
	    /// default implementation in Calendar.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    protected internal virtual int HandleGetMonthLength(int extendedYear, int month) {
	        return HandleComputeMonthStart(extendedYear, month + 1, true)
	                - HandleComputeMonthStart(extendedYear, month, true);
	    }
	
	    // /CLOVER:ON
	
	    /// <summary>
	    /// Return the number of days in the given extended year of this calendar
	    /// system. Subclasses should override this method if they can provide a more
	    /// correct or more efficient implementation than the default implementation
	    /// in Calendar.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    protected internal virtual int HandleGetYearLength(int eyear) {
	        return HandleComputeMonthStart(eyear + 1, 0, false)
	                - HandleComputeMonthStart(eyear, 0, false);
	    }
	
	    /// <summary>
	    /// Subclasses that use additional fields beyond those defined in
	    /// <c>Calendar</c> should override this method to return an
	    /// <c>int[]</c> array of the appropriate length. The length must be at
	    /// least <c>BASE_FIELD_COUNT</c> and no more than
	    /// <c>MAX_FIELD_COUNT</c>.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    protected internal virtual int[] HandleCreateFields() {
	        return new int[BASE_FIELD_COUNT];
	    }
	
	    /// <summary>
	    /// Subclasses may override this. Called by handleComputeJulianDay. Returns
	    /// the default month (0-based) for the year, taking year and era into
	    /// account. Defaults to 0 (JANUARY) for Gregorian.
	    /// </summary>
	    ///
	    /// <param name="extendedYear">the extendedYear, as returned by handleGetExtendedYear</param>
	    /// <returns>the default month</returns>
	    /// @provisional ICU 3.6
	    /// @draft ICU 3.6
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.MONTH"/>
	    protected internal virtual int GetDefaultMonthInYear(int extendedYear) {
	        return Calendar.JANUARY;
	    }
	
	    /// <summary>
	    /// Subclasses may override this. Called by handleComputeJulianDay. Returns
	    /// the default day (1-based) for the month, taking currently-set year and
	    /// era into account. Defaults to 1 for Gregorian.
	    /// </summary>
	    ///
	    /// <param name="extendedYear">the extendedYear, as returned by handleGetExtendedYear</param>
	    /// <param name="month">the month, as returned by getDefaultMonthInYear</param>
	    /// <returns>the default day of the month</returns>
	    /// @draft ICU 3.6
	    /// @provisional ICU 3.6
	    /// <seealso cref="F:IBM.ICU.Util.Calendar.DAY_OF_MONTH"/>
	    protected internal virtual int GetDefaultDayInMonth(int extendedYear, int month) {
	        return 1;
	    }
	
	    /// <summary>
	    /// Subclasses may override this. This method calls handleGetMonthLength() to
	    /// obtain the calendar-specific month length.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    protected internal virtual int HandleComputeJulianDay(int bestField) {
	
	        bool useMonth = (bestField == DAY_OF_MONTH
	                || bestField == WEEK_OF_MONTH || bestField == DAY_OF_WEEK_IN_MONTH);
	
	        int year;
	
	        if (bestField == WEEK_OF_YEAR) {
	            // Nota Bene! It is critical that YEAR_WOY be used as the year here,
	            // if it is set.
	            // Otherwise, when WOY is the best field, the year may be wrong at
	            // the extreme limits of the year.
	            // If YEAR_WOY is not set then it will fall back.
	            // TODO: Should resolveField(YEAR_PRECEDENCE) be brought to bear?
	            year = InternalGet(YEAR_WOY, HandleGetExtendedYear());
	        } else {
	            year = HandleGetExtendedYear();
	        }
	
	        InternalSet(EXTENDED_YEAR, year);
	
	        int month = (useMonth) ? InternalGet(MONTH, GetDefaultMonthInYear(year))
	                : 0;
	
	        // Get the Julian day of the day BEFORE the start of this year.
	        // If useMonth is true, get the day before the start of the month.
	        int julianDay = HandleComputeMonthStart(year, month, useMonth);
	
	        if (bestField == DAY_OF_MONTH) {
	            if (IsSet(DAY_OF_MONTH)) {
	                return julianDay
	                        + InternalGet(DAY_OF_MONTH,
	                                GetDefaultDayInMonth(year, month));
	            } else {
	                return julianDay + GetDefaultDayInMonth(year, month);
	            }
	        }
	
	        if (bestField == DAY_OF_YEAR) {
	            return julianDay + InternalGet(DAY_OF_YEAR);
	        }
	
	        int firstDayOfWeek_0 = GetFirstDayOfWeek(); // Localized fdw
	
	        // At this point julianDay is the 0-based day BEFORE the first day of
	        // January 1, year 1 of the given calendar. If julianDay == 0, it
	        // specifies (Jan. 1, 1) - 1, in whatever calendar we are using (Julian
	        // or Gregorian).
	
	        // At this point we need to process the WEEK_OF_MONTH or
	        // WEEK_OF_YEAR, which are similar, or the DAY_OF_WEEK_IN_MONTH.
	        // First, perform initial shared computations. These locate the
	        // first week of the period.
	
	        // Get the 0-based localized DOW of day one of the month or year.
	        // Valid range 0..6.
	        int first = JulianDayToDayOfWeek(julianDay + 1) - firstDayOfWeek_0;
	        if (first < 0) {
	            first += 7;
	        }
	
	        // Get zero-based localized DOW, valid range 0..6. This is the DOW
	        // we are looking for.
	        int dowLocal = 0;
	        switch (ResolveFields(DOW_PRECEDENCE)) {
	        case DAY_OF_WEEK:
	            dowLocal = InternalGet(DAY_OF_WEEK) - firstDayOfWeek_0;
	            break;
	        case DOW_LOCAL:
	            dowLocal = InternalGet(DOW_LOCAL) - 1;
	            break;
	        }
	        dowLocal = dowLocal % 7;
	        if (dowLocal < 0) {
	            dowLocal += 7;
	        }
	
	        // Find the first target DOW (dowLocal) in the month or year.
	        // Actually, it may be just before the first of the month or year.
	        // It will be an integer from -5..7.
	        int date = 1 - first + dowLocal;
	
	        if (bestField == DAY_OF_WEEK_IN_MONTH) {
	
	            // Adjust the target DOW to be in the month or year.
	            if (date < 1) {
	                date += 7;
	            }
	
	            // The only trickiness occurs if the day-of-week-in-month is
	            // negative.
	            int dim = InternalGet(DAY_OF_WEEK_IN_MONTH, 1);
	            if (dim >= 0) {
	                date += 7 * (dim - 1);
	
	            } else {
	                // Move date to the last of this day-of-week in this month,
	                // then back up as needed. If dim==-1, we don't back up at
	                // all. If dim==-2, we back up once, etc. Don't back up
	                // past the first of the given day-of-week in this month.
	                // Note that we handle -2, -3, etc. correctly, even though
	                // values < -1 are technically disallowed.
	                int m = InternalGet(MONTH, JANUARY);
	                int monthLength = HandleGetMonthLength(year, m);
	                date += ((monthLength - date) / 7 + dim + 1) * 7;
	            }
	        } else {
	            // assert(bestField == WEEK_OF_MONTH || bestField == WEEK_OF_YEAR)
	
	            // Adjust for minimal days in first week
	            if ((7 - first) < GetMinimalDaysInFirstWeek()) {
	                date += 7;
	            }
	
	            // Now adjust for the week number.
	            date += 7 * (InternalGet(bestField) - 1);
	        }
	
	        return julianDay + date;
	    }
	
	    /// <summary>
	    /// Compute the Julian day of a month of the Gregorian calendar. Subclasses
	    /// may call this method to perform a Gregorian calendar fields->millis
	    /// computation. To perform a Gregorian calendar millis->fields computation,
	    /// call computeGregorianFields().
	    /// </summary>
	    ///
	    /// <param name="year">extended Gregorian year</param>
	    /// <param name="month">zero-based Gregorian month</param>
	    /// <returns>the Julian day number of the day before the first day of the
	    /// given month in the given extended year</returns>
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.ComputeGregorianFields(System.Int32)"/>
	    /// @stable ICU 2.0
	    protected internal int ComputeGregorianMonthStart(int year, int month) {
	
	        // If the month is out of range, adjust it into range, and
	        // modify the extended year value accordingly.
	        if (month < 0 || month > 11) {
	            int[] rem = new int[1];
	            year += FloorDivide(month, 12, rem);
	            month = rem[0];
	        }
	
	        bool isLeap = (year % 4 == 0)
	                && ((year % 100 != 0) || (year % 400 == 0));
	        int y = year - 1;
	        // This computation is actually ... + (JAN_1_1_JULIAN_DAY - 3) + 2.
	        // Add 2 because Gregorian calendar starts 2 days after Julian
	        // calendar.
	        int julianDay = 365 * y + FloorDivide(y, 4) - FloorDivide(y, 100)
	                + FloorDivide(y, 400) + JAN_1_1_JULIAN_DAY - 1;
	
	        // At this point julianDay indicates the day BEFORE the first day
	        // of January 1, <eyear> of the Gregorian calendar.
	        if (month != 0) {
	            julianDay += GREGORIAN_MONTH_COUNT[month][(isLeap) ? 3 : 2];
	        }
	
	        return julianDay;
	    }
	
	    // ----------------------------------------------------------------------
	    // Subclass API
	    // For subclasses to override
	    // ----------------------------------------------------------------------
	
	    // (The following method is not called because all existing subclasses
	    // override it. 2003-06-11 ICU 2.6 Alan)
	    // /CLOVER:OFF
	    /// <summary>
	    /// Subclasses may override this method to compute several fields specific to
	    /// each calendar system. These are:
	    /// <ul>
	    /// <li>ERA
	    /// <li>YEAR
	    /// <li>MONTH
	    /// <li>DAY_OF_MONTH
	    /// <li>DAY_OF_YEAR
	    /// <li>EXTENDED_YEAR
	    /// </ul>
	    /// Subclasses can refer to the DAY_OF_WEEK and DOW_LOCAL fields, which will
	    /// be set when this method is called. Subclasses can also call the
	    /// getGregorianXxx() methods to obtain Gregorian calendar equivalents for
	    /// the given Julian day.
	    /// <p>
	    /// In addition, subclasses should compute any subclass-specific fields, that
	    /// is, fields from BASE_FIELD_COUNT to getFieldCount() - 1.
	    /// <p>
	    /// The default implementation in <c>Calendar</c> implements a pure
	    /// proleptic Gregorian calendar.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    protected internal virtual void HandleComputeFields(int julianDay) {
	        InternalSet(MONTH, GetGregorianMonth());
	        InternalSet(DAY_OF_MONTH, GetGregorianDayOfMonth());
	        InternalSet(DAY_OF_YEAR, GetGregorianDayOfYear());
	        int eyear = GetGregorianYear();
	        InternalSet(EXTENDED_YEAR, eyear);
	        int era = IBM.ICU.Util.GregorianCalendar.AD;
	        if (eyear < 1) {
	            era = IBM.ICU.Util.GregorianCalendar.BC;
	            eyear = 1 - eyear;
	        }
	        InternalSet(ERA, era);
	        InternalSet(YEAR, eyear);
	    }
	
	    // /CLOVER:ON
	
	    // ----------------------------------------------------------------------
	    // Subclass API
	    // For subclasses to call
	    // ----------------------------------------------------------------------
	
	    /// <summary>
	    /// Return the extended year on the Gregorian calendar as computed by
	    /// <c>computeGregorianFields()</c>.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.ComputeGregorianFields(System.Int32)"/>
	    /// @stable ICU 2.0
	    protected internal int GetGregorianYear() {
	        return gregorianYear;
	    }
	
	    /// <summary>
	    /// Return the month (0-based) on the Gregorian calendar as computed by
	    /// <c>computeGregorianFields()</c>.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.ComputeGregorianFields(System.Int32)"/>
	    /// @stable ICU 2.0
	    protected internal int GetGregorianMonth() {
	        return gregorianMonth;
	    }
	
	    /// <summary>
	    /// Return the day of year (1-based) on the Gregorian calendar as computed by
	    /// <c>computeGregorianFields()</c>.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.ComputeGregorianFields(System.Int32)"/>
	    /// @stable ICU 2.0
	    protected internal int GetGregorianDayOfYear() {
	        return gregorianDayOfYear;
	    }
	
	    /// <summary>
	    /// Return the day of month (1-based) on the Gregorian calendar as computed
	    /// by <c>computeGregorianFields()</c>.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Util.Calendar.ComputeGregorianFields(System.Int32)"/>
	    /// @stable ICU 2.0
	    protected internal int GetGregorianDayOfMonth() {
	        return gregorianDayOfMonth;
	    }
	
	    /// <summary>
	    /// Return the number of fields defined by this calendar. Valid field
	    /// arguments to <c>set()</c> and <c>get()</c> are
	    /// <c>0..getFieldCount()-1</c>.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public int GetFieldCount() {
	        return fields.Length;
	    }
	
	    /// <summary>
	    /// Set a field to a value. Subclasses should use this method when computing
	    /// fields. It sets the time stamp in the <c>stamp[]</c> array to
	    /// <c>INTERNALLY_SET</c>. If a field that may not be set by subclasses
	    /// is passed in, an <c>IllegalArgumentException</c> is thrown. This
	    /// prevents subclasses from modifying fields that are intended to be
	    /// calendar-system invariant.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    protected internal void InternalSet(int field, int value_ren) {
	        if (((1 << field) & internalSetMask) == 0) {
	            throw new InvalidOperationException("Subclass cannot set "
	                    + FieldName(field));
	        }
	        fields[field] = value_ren;
	        stamp[field] = INTERNALLY_SET;
	    }
	
	    private static readonly int[][] GREGORIAN_MONTH_COUNT = { new int[] { 31, 31, 0, 0 }, new int[] { 28, 29, 31, 31 },
	            new int[] { 31, 31, 59, 60 }, new int[] { 30, 30, 90, 91 },
	            new int[] { 31, 31, 120, 121 }, new int[] { 30, 30, 151, 152 },
	            new int[] { 31, 31, 181, 182 }, new int[] { 31, 31, 212, 213 },
	            new int[] { 30, 30, 243, 244 }, new int[] { 31, 31, 273, 274 },
	            new int[] { 30, 30, 304, 305 }, new int[] { 31, 31, 334, 335 } };
	
	    /// <summary>
	    /// Determines if the given year is a leap year. Returns true if the given
	    /// year is a leap year.
	    /// </summary>
	    ///
	    /// <param name="year">the given year.</param>
	    /// <returns>true if the given year is a leap year; false otherwise.</returns>
	    /// @stable ICU 2.0
	    protected static internal bool IsGregorianLeapYear(int year) {
	        return (year % 4 == 0) && ((year % 100 != 0) || (year % 400 == 0));
	    }
	
	    /// <summary>
	    /// Return the length of a month of the Gregorian calendar.
	    /// </summary>
	    ///
	    /// <param name="y">the extended year</param>
	    /// <param name="m">the 0-based month number</param>
	    /// <returns>the number of days in the given month</returns>
	    /// @stable ICU 2.0
	    protected static internal int GregorianMonthLength(int y, int m) {
	        return GREGORIAN_MONTH_COUNT[m][(IsGregorianLeapYear(y)) ? 1 : 0];
	    }
	
	    /// <summary>
	    /// Return the length of a previous month of the Gregorian calendar.
	    /// </summary>
	    ///
	    /// <param name="y">the extended year</param>
	    /// <param name="m">the 0-based month number</param>
	    /// <returns>the number of days in the month previous to the given month</returns>
	    /// @stable ICU 2.0
	    protected static internal int GregorianPreviousMonthLength(int y, int m) {
	        return (m > 0) ? GregorianMonthLength(y, m - 1) : 31;
	    }
	
	    /// <summary>
	    /// Divide two long integers, returning the floor of the quotient.
	    /// <p>
	    /// Unlike the built-in division, this is mathematically well-behaved. E.g.,
	    /// <code>-1/4</code> => 0 but <c>floorDivide(-1,4)</c> => -1.
	    /// </summary>
	    ///
	    /// <param name="numerator">the numerator</param>
	    /// <param name="denominator">a divisor which must be > 0</param>
	    /// <returns>the floor of the quotient.</returns>
	    /// @stable ICU 2.0
	    protected static internal long FloorDivide(long numerator, long denominator) {
	        // We do this computation in order to handle
	        // a numerator of Long.MIN_VALUE correctly
	        return (numerator >= 0) ? numerator / denominator
	                : ((numerator + 1) / denominator) - 1;
	    }
	
	    /// <summary>
	    /// Divide two integers, returning the floor of the quotient.
	    /// <p>
	    /// Unlike the built-in division, this is mathematically well-behaved. E.g.,
	    /// <code>-1/4</code> => 0 but <c>floorDivide(-1,4)</c> => -1.
	    /// </summary>
	    ///
	    /// <param name="numerator">the numerator</param>
	    /// <param name="denominator">a divisor which must be > 0</param>
	    /// <returns>the floor of the quotient.</returns>
	    /// @stable ICU 2.0
	    protected static internal int FloorDivide(int numerator, int denominator) {
	        // We do this computation in order to handle
	        // a numerator of Integer.MIN_VALUE correctly
	        return (numerator >= 0) ? numerator / denominator
	                : ((numerator + 1) / denominator) - 1;
	    }
	
	    /// <summary>
	    /// Divide two integers, returning the floor of the quotient, and the modulus
	    /// remainder.
	    /// <p>
	    /// Unlike the built-in division, this is mathematically well-behaved. E.g.,
	    /// <code>-1/4</code> => 0 and <c>-1%4</c> => -1, but
	    /// <c>floorDivide(-1,4)</c> => -1 with <c>remainder[0]</c> => 3.
	    /// </summary>
	    ///
	    /// <param name="numerator">the numerator</param>
	    /// <param name="denominator">a divisor which must be > 0</param>
	    /// <param name="remainder">an array of at least one element in which the value<c>numerator mod denominator</c> is returned. Unlike<c>numerator% denominator</c>, this will always be non-negative.</param>
	    /// <returns>the floor of the quotient.</returns>
	    /// @stable ICU 2.0
	    protected static internal int FloorDivide(int numerator, int denominator,
	            int[] remainder) {
	        if (numerator >= 0) {
	            remainder[0] = numerator % denominator;
	            return numerator / denominator;
	        }
	        int quotient = ((numerator + 1) / denominator) - 1;
	        remainder[0] = numerator - (quotient * denominator);
	        return quotient;
	    }
	
	    /// <summary>
	    /// Divide two integers, returning the floor of the quotient, and the modulus
	    /// remainder.
	    /// <p>
	    /// Unlike the built-in division, this is mathematically well-behaved. E.g.,
	    /// <code>-1/4</code> => 0 and <c>-1%4</c> => -1, but
	    /// <c>floorDivide(-1,4)</c> => -1 with <c>remainder[0]</c> => 3.
	    /// </summary>
	    ///
	    /// <param name="numerator">the numerator</param>
	    /// <param name="denominator">a divisor which must be > 0</param>
	    /// <param name="remainder">an array of at least one element in which the value<c>numerator mod denominator</c> is returned. Unlike<c>numerator% denominator</c>, this will always be non-negative.</param>
	    /// <returns>the floor of the quotient.</returns>
	    /// @stable ICU 2.0
	    protected static internal int FloorDivide(long numerator, int denominator,
	            int[] remainder) {
	        if (numerator >= 0) {
	            remainder[0] = (int) (numerator % denominator);
	            return (int) (numerator / denominator);
	        }
	        int quotient = (int) (((numerator + 1) / denominator) - 1);
	        remainder[0] = (int) (numerator - (quotient * denominator));
	        return quotient;
	    }
	
	    private static readonly String[] FIELD_NAME = { "ERA", "YEAR", "MONTH",
	            "WEEK_OF_YEAR", "WEEK_OF_MONTH", "DAY_OF_MONTH", "DAY_OF_YEAR",
	            "DAY_OF_WEEK", "DAY_OF_WEEK_IN_MONTH", "AM_PM", "HOUR",
	            "HOUR_OF_DAY", "MINUTE", "SECOND", "MILLISECOND", "ZONE_OFFSET",
	            "DST_OFFSET", "YEAR_WOY", "DOW_LOCAL", "EXTENDED_YEAR",
	            "JULIAN_DAY", "MILLISECONDS_IN_DAY", };
	
	    /// <summary>
	    /// Return a string name for a field, for debugging and exceptions.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    protected internal String FieldName(int field) {
	        try {
	            return FIELD_NAME[field];
	        } catch (IndexOutOfRangeException e) {
	            return "Field " + field;
	        }
	    }
	
	    /// <summary>
	    /// Converts time as milliseconds to Julian day.
	    /// </summary>
	    ///
	    /// <param name="millis">the given milliseconds.</param>
	    /// <returns>the Julian day number.</returns>
	    /// @stable ICU 2.0
	    protected static internal int MillisToJulianDay(long millis) {
	        return (int) (EPOCH_JULIAN_DAY + FloorDivide(millis, ONE_DAY));
	    }
	
	    /// <summary>
	    /// Converts Julian day to time as milliseconds.
	    /// </summary>
	    ///
	    /// <param name="julian">the given Julian day number.</param>
	    /// <returns>time as milliseconds.</returns>
	    /// @stable ICU 2.0
	    protected static internal long JulianDayToMillis(int julian) {
            double mj = new DateTime(1970, 1, 1).ToOADate();
	        return (julian - EPOCH_JULIAN_DAY) * ONE_DAY;
	    }
	
	    /// <summary>
	    /// Return the day of week, from SUNDAY to SATURDAY, given a Julian day.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    protected static internal int JulianDayToDayOfWeek(int julian) {
	        // If julian is negative, then julian%7 will be negative, so we adjust
	        // accordingly. Julian day 0 is Monday.
	        int dayOfWeek = (julian + MONDAY) % 7;
	        if (dayOfWeek < SUNDAY) {
	            dayOfWeek += 7;
	        }
	        return dayOfWeek;
	    }
	
	    /// <summary>
	    /// Return the current milliseconds without recomputing.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    protected internal long InternalGetTimeInMillis() {
	        return time;
	    }
	
	    /// <summary>
	    /// Return the current Calendar type. Note, in 3.0 this function will return
	    /// 'gregorian' in Calendar to emulate legacy behavior
	    /// </summary>
	    ///
	    /// <returns>type of calendar (gregorian, etc)</returns>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public virtual String GetType() {
	        return "gregorian";
	    }
	
	    // -------- BEGIN ULocale boilerplate --------
	
	    /// <summary>
	    /// Return the locale that was used to create this object, or null. This may
	    /// may differ from the locale requested at the time of this object's
	    /// creation. For example, if an object is created for locale
	    /// <tt>en_US_CALIFORNIA</tt>, the actual data may be drawn from <tt>en</tt>
	    /// (the <i>actual</i> locale), and <tt>en_US</tt> may be the most specific
	    /// locale that exists (the <i>valid</i> locale).
	    /// <p>
	    /// Note: This method will be implemented in ICU 3.0; ICU 2.8 contains a
	    /// partial preview implementation. The/// <i>actual</i> locale is returned
	    /// correctly, but the <i>valid</i> locale is not, in most cases.
	    /// </summary>
	    ///
	    /// <param name="type">type of information requested, either<see cref="M:IBM.ICU.Util.ULocale.VALID_LOCALE"/> or<see cref="M:IBM.ICU.Util.ULocale.ACTUAL_LOCALE"/>.</param>
	    /// <returns>the information specified by <i>type</i>, or null if this object
	    /// was not constructed from locale data.</returns>
	    /// <seealso cref="T:IBM.ICU.Util.ULocale"/>
	    /// <seealso cref="M:IBM.ICU.Util.ULocale.VALID_LOCALE"/>
	    /// <seealso cref="M:IBM.ICU.Util.ULocale.ACTUAL_LOCALE"/>
	    /// @draft ICU 2.8 (retain)
	    /// @provisional This API might change or be removed in a future release.
	    public ULocale GetLocale(ULocale.Type type) {
	        return (type == IBM.ICU.Util.ULocale.ACTUAL_LOCALE) ? this.actualLocale
	                : this.validLocale;
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Set information about the locales that were used to create this object.
	    /// If the object was not constructed from locale data, both arguments should
	    /// be set to null. Otherwise, neither should be null. The actual locale must
	    /// be at the same level or less specific than the valid locale. This method
	    /// is intended for use by factories or other entities that create objects of
	    /// this class.
	    /// </summary>
	    ///
	    /// <param name="valid">the most specific locale containing any resource data, or null</param>
	    /// <param name="actual">the locale containing data used to construct this object, ornull</param>
	    /// <seealso cref="T:IBM.ICU.Util.ULocale"/>
	    /// <seealso cref="M:IBM.ICU.Util.ULocale.VALID_LOCALE"/>
	    /// <seealso cref="M:IBM.ICU.Util.ULocale.ACTUAL_LOCALE"/>
	    internal void SetLocale(ULocale valid, ULocale actual) {
	        // Change the following to an assertion later
	        if ((valid == null) != (actual == null)) {
	            // /CLOVER:OFF
	            throw new ArgumentException();
	            // /CLOVER:ON
	        }
	        // Another check we could do is that the actual locale is at
	        // the same level or less specific than the valid locale.
	        this.validLocale = valid;
	        this.actualLocale = actual;
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// The most specific locale containing any resource data, or null.
	    /// </summary>
	    ///
	    /// <seealso cref="T:IBM.ICU.Util.ULocale"/>
	    private ULocale validLocale;
	
	    /// <exclude/>
	    /// <summary>
	    /// The locale containing data used to construct this object, or null.
	    /// </summary>
	    ///
	    /// <seealso cref="T:IBM.ICU.Util.ULocale"/>
	    private ULocale actualLocale;
	
	    // -------- END ULocale boilerplate --------
	}
}
