/*
 *  Licensed to the Apache Software Foundation (ASF) under one or more
 *  contributor license agreements.  See the NOTICE file distributed with
 *  this work for additional information regarding copyright ownership.
 *  The ASF licenses this file to You under the Apache License, Version 2.0
 *  (the "License"); you may not use this file except in compliance with
 *  the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101221_01     
// 1/4/11 10:30 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace ILOG.J2CsMapping.IO {
	
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	
	/// <summary>
	/// FilteredInputStream is a class which takes an input stream and
	/// <em>filters</em> the input in some way. The filtered view may be a buffered
	/// view or one which uncompresses data before returning bytes read.
	/// FilterInputStreams are meant for byte streams.
	/// </summary>
	///
	/// <seealso cref="T:ILOG.J2CsMapping.IO.IlFilterOutputStream"/>
	public class FilterInputStream : Stream {
	
		/// <summary>
		/// The target InputStream which is being filtered.
		/// </summary>
		///
		protected internal Stream ins0;
	
		/// <summary>
		/// Constructs a new FilterInputStream on the InputStream <c>in</c>.
		/// All reads are now filtered through this stream.
		/// </summary>
		///
		/// <param name="in">The non-null InputStream to filter reads on.</param>
		protected internal FilterInputStream(Stream ins0) : base() {
			this.ins0 = ins0;
		}
	
		/// <summary>
		/// Answers a int representing the number of bytes that are available before
		/// this FilterInputStream will block. This method returns the number of
		/// bytes available in the target stream.
		/// </summary>
		///
		/// <returns>the number of bytes available before blocking.</returns>
		/// <exception cref="IOException">If an error occurs in this stream.</exception>
		public virtual int Available() {
            throw new NotImplementedException("Available");
            // return ins0.Length;
		}
	
		/// <summary>
		/// Close this FilterInputStream. This implementation closes the target
		/// stream.
		/// </summary>
		///
		/// <exception cref="IOException">If an error occurs attempting to close this stream.</exception>
		public override void Close() {
			ins0.Close();
		}
	
		/// <summary>
		/// Set a Mark position in this FilterInputStream. The parameter
		/// <c>readLimit</c> indicates how many bytes can be read before a
		/// mark is invalidated. Sending reset() will reposition the Stream back to
		/// the marked position provided <c>readLimit</c> has not been
		/// surpassed.
		/// <p>
		/// This implementation sets a mark in the target stream.
		/// </summary>
		///
		/// <param name="readlimit">the number of bytes to be able to read before invalidating themark.</param>
		[MethodImpl(MethodImplOptions.Synchronized)]
        public virtual void Mark(int readlimit)
        {
            throw new NotImplementedException("Available");
			// ins0.Mark(readlimit);
		}
	
		/// <summary>
		/// Answers a boolean indicating whether or not this FilterInputStream
		/// supports mark() and reset(). This implementation answers whether or not
		/// the target stream supports marking.
		/// </summary>
		///
		/// <returns><c>true</c> if mark() and reset() are supported,
		/// <c>false</c> otherwise.</returns>
        public virtual bool MarkSupported()
        {
            throw new NotImplementedException("Available");
			// return ins0.MarkSupported();
		}
	
		/// <summary>
		/// Reads a single byte from this FilterInputStream and returns the result as
		/// an int. The low-order byte is returned or -1 of the end of stream was
		/// encountered. This implementation returns a byte from the target stream.
		/// </summary>
		///
		/// <returns>the byte read or -1 if end of stream.</returns>
		/// <exception cref="IOException">If the stream is already closed or another IOExceptionoccurs.</exception>
		public override int ReadByte() {
			return ins0.ReadByte();
		}
	
		/// <summary>
		/// Reads bytes from this FilterInputStream and stores them in byte array
		/// <c>buffer</c>. Answer the number of bytes actually read or -1 if
		/// no bytes were read and end of stream was encountered. This implementation
		/// reads bytes from the target stream.
		/// </summary>
		///
		/// <param name="buffer">the byte array in which to store the read bytes.</param>
		/// <returns>the number of bytes actually read or -1 if end of stream.</returns>
		/// <exception cref="IOException">If the stream is already closed or another IOExceptionoccurs.</exception>
        public virtual int Read(byte[] buffer)
        {
			return Read(buffer, 0, buffer.Length);
		}
	
		/// <summary>
		/// Reads at most <c>count</c> bytes from this FilterInputStream and
		/// stores them in byte array <c>buffer</c> starting at
		/// <c>offset</c>. Answer the number of bytes actually read or -1 if
		/// no bytes were read and end of stream was encountered. This implementation
		/// reads bytes from the target stream.
		/// </summary>
		///
		/// <param name="buffer">the byte array in which to store the read bytes.</param>
		/// <param name="offset">the offset in <c>buffer</c> to store the read bytes.</param>
		/// <param name="count">the maximum number of bytes to store in <c>buffer</c>.</param>
		/// <returns>the number of bytes actually read or -1 if end of stream.</returns>
		/// <exception cref="IOException">If the stream is already closed or another IOExceptionoccurs.</exception>
		public override int Read(byte[] buffer, int offset, int count) {
			return ins0.Read(buffer, offset, count);
		}
	
		/// <summary>
		/// Reset this FilterInputStream to the last marked location. If the
		/// <c>readlimit</c> has been passed or no <c>mark</c> has
		/// been set, throw IOException. This implementation resets the target
		/// stream.
		/// </summary>
		///
		/// <exception cref="IOException">If the stream is already closed or another IOExceptionoccurs.</exception>
		[MethodImpl(MethodImplOptions.Synchronized)]
        public virtual void Reset()
        {
            throw new NotImplementedException("Available");
			// ins0.Reset();
		}
	
		/// <summary>
		/// Skips <c>count</c> number of bytes in this InputStream.
		/// Subsequent <c>read()</c>'s will not return these bytes unless
		/// <c>reset()</c> is used. This implementation skips
		/// <c>count</c> number of bytes in the target stream.
		/// </summary>
		///
		/// <param name="count">the number of bytes to skip.</param>
		/// <returns>the number of bytes actually skipped.</returns>
		/// <exception cref="IOException">If the stream is already closed or another IOExceptionoccurs.</exception>
        public virtual long Skip(long count)
        {
            throw new NotImplementedException("Available");
			// return ins0.Skip(count);
		}

        public override bool CanRead
        {
            get { throw new NotImplementedException(); }
        }

        public override bool CanSeek
        {
            get { throw new NotImplementedException(); }
        }

        public override bool CanWrite
        {
            get { throw new NotImplementedException(); }
        }

        public override void Flush()
        {
            throw new NotImplementedException();
        }

        public override long Length
        {
            get { throw new NotImplementedException(); }
        }

        public override long Position
        {
            get
            {
                throw new NotImplementedException();
            }
            set
            {
                throw new NotImplementedException();
            }
        }

        public override long Seek(long offset, SeekOrigin origin)
        {
            throw new NotImplementedException();
        }

        public override void SetLength(long value)
        {
            throw new NotImplementedException();
        }

        public override void Write(byte[] buffer, int offset, int count)
        {
            throw new NotImplementedException();
        }
    }
}
