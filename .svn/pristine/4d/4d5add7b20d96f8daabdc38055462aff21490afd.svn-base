//##header J2SE15
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:30 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 /*
 *******************************************************************************
 * Copyright (C) 1996-2007, International Business Machines Corporation and    *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 */
namespace IBM.ICU.Text {
	
	using IBM.ICU.Impl;
	using IBM.ICU.Util;
	using ILOG.J2CsMapping.Collections;
	using ILOG.J2CsMapping.Collections.Generics;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Resources;
	using System.Runtime.CompilerServices;
	using System.Text;
    using ILOG.J2CsMapping.Util;
    using ParsePosition = ILOG.J2CsMapping.Text.ParsePosition;
	
	/// <summary>
	/// A mutable set of Unicode characters and multicharacter strings. Objects of
	/// this class represent <em>character classes</em> used in regular expressions.
	/// A character specifies a subset of Unicode code points. Legal code points are
	/// U+0000 to U+10FFFF, inclusive.
	/// <p>
	/// The UnicodeSet class is not designed to be subclassed.
	/// <p>
	/// <c>UnicodeSet</c> supports two APIs. The first is the <em>operand</em>
	/// API that allows the caller to modify the value of a <c>UnicodeSet</c>
	/// object. It conforms to Java 2's <c>java.util.Set</c> interface,
	/// although <c>UnicodeSet</c> does not actually implement that interface.
	/// All methods of <c>Set</c> are supported, with the modification that
	/// they take a character range or single character instead of an
	/// <c>Object</c>, and they take a <c>UnicodeSet</c> instead of a
	/// <c>Collection</c>. The operand API may be thought of in terms of
	/// boolean logic: a boolean OR is implemented by <c>add</c>, a boolean AND
	/// is implemented by <c>retain</c>, a boolean XOR is implemented by
	/// <c>complement</c> taking an argument, and a boolean NOT is implemented
	/// by <c>complement</c> with no argument. In terms of traditional set
	/// theory function names, <c>add</c> is a union, <c>retain</c> is an
	/// intersection, <c>remove</c> is an asymmetric difference, and
	/// <c>complement</c> with no argument is a set complement with respect to
	/// the superset range <c>MIN_VALUE-MAX_VALUE</c>
	/// <p>
	/// The second API is the <c>applyPattern()</c>/<c>toPattern()</c>
	/// API from the <c>java.text.Format</c>-derived classes. Unlike the
	/// methods that add characters, add categories, and control the logic of the
	/// set, the method <c>applyPattern()</c> sets all attributes of a
	/// <c>UnicodeSet</c> at once, based on a string pattern.
	/// <p>
	/// <b>Pattern syntax</b>
	/// </p>
	/// Patterns are accepted by the constructors and the <c>applyPattern()</c>
	/// methods and returned by the <c>toPattern()</c> method. These patterns
	/// follow a syntax similar to that employed by version 8 regular expression
	/// character classes. Here are some simple examples:
	/// <blockquote>
	/// <table>
	/// <tr align="top">
	/// <td nowrap valign="top" align="left"><c>[]</c></td>
	/// <td valign="top">No characters</td>
	/// </tr>
	/// <tr align="top">
	/// <td nowrap valign="top" align="left"><c>[a]</c></td>
	/// <td valign="top">The character 'a'</td>
	/// </tr>
	/// <tr align="top">
	/// <td nowrap valign="top" align="left"><c>[ae]</c></td>
	/// <td valign="top">The characters 'a' and 'e'</td>
	/// </tr>
	/// <tr>
	/// <td nowrap valign="top" align="left"><c>[a-e]</c></td>
	/// <td valign="top">The characters 'a' through 'e' inclusive, in Unicode code
	/// point order</td>
	/// </tr>
	/// <tr>
	/// <td nowrap valign="top" align="left"><c>[\\u4E01]</c></td>
	/// <td valign="top">The character U+4E01</td>
	/// </tr>
	/// <tr>
	/// <td nowrap valign="top" align="left"><c>[a{ab}{ac}]</c></td>
	/// <td valign="top">The character 'a' and the multicharacter strings
	/// &quot;ab&quot; and &quot;ac&quot;</td>
	/// </tr>
	/// <tr>
	/// <td nowrap valign="top" align="left"><c>[\p{Lu}]</c></td>
	/// <td valign="top">All characters in the general category Uppercase Letter</td>
	/// </tr>
	/// </table>
	/// </blockquote>
	/// Any character may be preceded by a backslash in order to remove any special
	/// meaning. White space characters, as defined by
	/// UCharacterProperty.isRuleWhiteSpace(), are ignored, unless they are escaped.
	/// <p>
	/// Property patterns specify a set of characters having a certain property as
	/// defined by the Unicode standard. Both the POSIX-like "[:Lu:]" and the
	/// Perl-like syntax "\p{Lu}" are recognized. For a complete list of supported
	/// property patterns, see the User's Guide for UnicodeSet at <a
	/// href="http://www.icu-project.org/userguide/unicodeSet.html">
	/// http://www.icu-project.org/userguide/unicodeSet.html</a>. Actual
	/// determination of property data is defined by the underlying Unicode database
	/// as implemented by UCharacter.
	/// <p>
	/// Patterns specify individual characters, ranges of characters, and Unicode
	/// property sets. When elements are concatenated, they specify their union. To
	/// complement a set, place a '^' immediately after the opening '['. Property
	/// patterns are inverted by modifying their delimiters; "[:^foo]" and "\P{foo}".
	/// In any other location, '^' has no special meaning.
	/// <p>
	/// Ranges are indicated by placing two a '-' between two characters, as in
	/// "a-z". This specifies the range of all characters from the left to the right,
	/// in Unicode order. If the left character is greater than or equal to the right
	/// character it is a syntax error. If a '-' occurs as the first character after
	/// the opening '[' or '[^', or if it occurs as the last character before the
	/// closing ']', then it is taken as a literal. Thus "[a\\-b]", "[-ab]", and
	/// "[ab-]" all indicate the same set of three characters, 'a', 'b', and '-'.
	/// <p>
	/// Sets may be intersected using the '&' operator or the asymmetric set
	/// difference may be taken using the '-' operator, for example,
	/// "[[:L:]&[\\u0000-\\u0FFF]]" indicates the set of all Unicode letters with
	/// values less than 4096. Operators ('&' and '|') have equal precedence and bind
	/// left-to-right. Thus "[[:L:]-[a-z]-[\\u0100-\\u01FF]]" is equivalent to
	/// "[[[:L:]-[a-z]]-[\\u0100-\\u01FF]]". This only really matters for difference;
	/// intersection is commutative.
	/// <table>
	/// <tr valign=top>
	/// <td nowrap><c>[a]</c>
	/// <td>The set containing 'a'
	/// <tr valign=top>
	/// <td nowrap><c>[a-z]</c>
	/// <td>The set containing 'a' through 'z' and all letters in between, in Unicode
	/// order
	/// <tr valign=top>
	/// <td nowrap><c>[^a-z]</c>
	/// <td>The set containing all characters but 'a' through 'z', that is, U+0000
	/// through 'a'-1 and 'z'+1 through U+10FFFF
	/// <tr valign=top>
	/// <td nowrap><code>[[<em>pat1</em>][<em>pat2</em>]]</code>
	/// <td>The union of sets specified by <em>pat1</em> and <em>pat2</em>
	/// <tr valign=top>
	/// <td nowrap><code>[[<em>pat1</em>]&[<em>pat2</em>]]</code>
	/// <td>The intersection of sets specified by <em>pat1</em> and <em>pat2</em>
	/// <tr valign=top>
	/// <td nowrap><code>[[<em>pat1</em>]-[<em>pat2</em>]]</code>
	/// <td>The asymmetric difference of sets specified by <em>pat1</em> and
	/// <em>pat2</em>
	/// <tr valign=top>
	/// <td nowrap><c>[:Lu:] or \p{Lu}</c>
	/// <td>The set of characters having the specified Unicode property; in this
	/// case, Unicode uppercase letters
	/// <tr valign=top>
	/// <td nowrap><c>[:^Lu:] or \P{Lu}</c>
	/// <td>The set of characters <em>not</em> having the given Unicode property
	/// </table>
	/// <p>
	/// <b>Warning</b>: you cannot add an empty string ("") to a UnicodeSet.
	/// </p>
	/// <p>
	/// <b>Formal syntax</b>
	/// </p>
	/// <blockquote>
	/// <table>
	/// <tr align="top">
	/// <td nowrap valign="top" align="right"><c>pattern :=&nbsp;</c></td>
	/// <td valign="top"><code>('[' '^'? item/// ']') |
	/// property</code></td>
	/// </tr>
	/// <tr align="top">
	/// <td nowrap valign="top" align="right"><c>item :=&nbsp;</c></td>
	/// <td valign="top"><code>char | (char '-' char) | pattern-expr<br>
	/// </code></td>
	/// </tr>
	/// <tr align="top">
	/// <td nowrap valign="top" align="right"><c>pattern-expr :=&nbsp;</c></td>
	/// <td valign="top"><code>pattern | pattern-expr pattern |
	/// pattern-expr op pattern<br>
	/// </code></td>
	/// </tr>
	/// <tr align="top">
	/// <td nowrap valign="top" align="right"><c>op :=&nbsp;</c></td>
	/// <td valign="top"><code>'&amp;' | '-'<br>
	/// </code></td>
	/// </tr>
	/// <tr align="top">
	/// <td nowrap valign="top" align="right"><c>special :=&nbsp;</c></td>
	/// <td valign="top"><code>'[' | ']' | '-'<br>
	/// </code></td>
	/// </tr>
	/// <tr align="top">
	/// <td nowrap valign="top" align="right"><c>char :=&nbsp;</c></td>
	/// <td valign="top"><em>any character that is not</em><code> special<br>
	/// | ('\\' </code><em>any character</em><code>)<br>
	/// | ('&#92;u' hex hex hex hex)<br>
	/// </code></td>
	/// </tr>
	/// <tr align="top">
	/// <td nowrap valign="top" align="right"><c>hex :=&nbsp;</c></td>
	/// <td valign="top"><em>any character for which
	/// </em><c>Character.digit(c, 16)</c><em>
	/// returns a non-negative result</em></td>
	/// </tr>
	/// <tr>
	/// <td nowrap valign="top" align="right"><c>property :=&nbsp;</c></td>
	/// <td valign="top"><em>a Unicode property set pattern</td>
	/// </tr>
	/// </table>
	/// <br>
	/// <table border="1">
	/// <tr>
	/// <td>Legend:
	/// <table>
	/// <tr>
	/// <td nowrap valign="top"><c>a := b</c></td>
	/// <td width="20" valign="top">&nbsp;</td>
	/// <td valign="top"><c>a</c> may be replaced by <c>b</c></td>
	/// </tr>
	/// <tr>
	/// <td nowrap valign="top"><c>a?</c></td>
	/// <td valign="top"></td>
	/// <td valign="top">zero or one instance of <c>a</c><br>
	/// </td>
	/// </tr>
	/// <tr>
	/// <td nowrap valign="top"><code>a///</code></td>
	/// <td valign="top"></td>
	/// <td valign="top">one or more instances of <c>a</c><br>
	/// </td>
	/// </tr>
	/// <tr>
	/// <td nowrap valign="top"><c>a | b</c></td>
	/// <td valign="top"></td>
	/// <td valign="top">either <c>a</c> or <c>b</c><br>
	/// </td>
	/// </tr>
	/// <tr>
	/// <td nowrap valign="top"><c>'a'</c></td>
	/// <td valign="top"></td>
	/// <td valign="top">the literal string between the quotes</td>
	/// </tr>
	/// </table>
	/// </td>
	/// </tr>
	/// </table>
	/// </blockquote>
	/// <p>
	/// To iterate over contents of UnicodeSet, use UnicodeSetIterator class.
	/// </summary>
	///
	/// @stable ICU 2.0
	/// <seealso cref="T:IBM.ICU.Text.UnicodeSetIterator"/>
	public class UnicodeSet : UnicodeFilter, Freezable {
	
	    private const int LOW = 0x000000; // LOW <= all valid values. ZERO
	                                             // for codepoints
	
	    private const int HIGH = 0x110000; // HIGH > all valid values. 10000
	                                              // for code units.
	                                              // 110000 for codepoints
	
	    /// <summary>
	    /// Minimum value that can be stored in a UnicodeSet.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public const int MIN_VALUE = LOW;
	
	    /// <summary>
	    /// Maximum value that can be stored in a UnicodeSet.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public const int MAX_VALUE = HIGH - 1;
	
	    private int len; // length used; list may be longer to minimize reallocs
	
	    private int[] list; // MUST be terminated with HIGH
	
	    private int[] rangeList; // internal buffer
	
	    private int[] buffer; // internal buffer
	
	    // NOTE: normally the field should be of type SortedSet; but that is missing
	    // a public clone!!
	    // is not private so that UnicodeSetIterator can get access
	    internal SortedSet strings;
	
	    /// <summary>
	    /// The pattern representation of this set. This may not be the most
	    /// economical pattern. It is the pattern supplied to applyPattern(), with
	    /// variables substituted and whitespace removed. For sets constructed
	    /// without applyPattern(), or modified using the non-pattern API, this
	    /// string will be null, indicating that toPattern() must generate a pattern
	    /// representation from the inversion list.
	    /// </summary>
	    ///
	    private String pat;
	
	    private const int START_EXTRA = 16; // initial storage. Must be >= 0
	
	    private const int GROW_EXTRA = START_EXTRA; // extra amount for
	                                                       // growth. Must be >= 0
	
	    // Special property set IDs
	    private const String ANY_ID = "ANY"; // [\u0000-\U0010FFFF]
	
	    private const String ASCII_ID = "ASCII"; // [\u0000-\u007F]
	
	    private const String ASSIGNED = "Assigned"; // [:^Cn:]
	
	    /// <summary>
	    /// A set of all characters _except_ the second through last characters of certain ranges. These ranges are ranges of characters whose properties are all exactly alike, e.g. CJK Ideographs from U+4E00 to U+9FA5.
	    /// </summary>
	    ///
	    private static UnicodeSet[] INCLUSIONS = null;
	
	    // ----------------------------------------------------------------
	    // Public API
	    // ----------------------------------------------------------------
	
	    /// <summary>
	    /// Constructs an empty set.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public UnicodeSet() {
	        this.strings = new SortedSet();
	        this.pat = null;
	        list = new int[1 + START_EXTRA];
	        list[len++] = HIGH;
	    }
	
	    /// <summary>
	    /// Constructs a copy of an existing set.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public UnicodeSet(UnicodeSet other) {
	        this.strings = new SortedSet();
	        this.pat = null;
	        Set(other);
	    }
	
	    /// <summary>
	    /// Constructs a set containing the given range. If <code>end >
	    /// start</code> then an empty set is created.
	    /// </summary>
	    ///
	    /// <param name="start">first character, inclusive, of range</param>
	    /// <param name="end">last character, inclusive, of range</param>
	    /// @stable ICU 2.0
	    public UnicodeSet(int start, int end) : this() {
	        Complement(start, end);
	    }
	
	    /// <summary>
	    /// Constructs a set from the given pattern. See the class description for
	    /// the syntax of the pattern language. Whitespace is ignored.
	    /// </summary>
	    ///
	    /// <param name="pattern">a string specifying what characters are in the set</param>
	    /// <exception cref="System.ArgumentException">if the pattern contains a syntax error.</exception>
	    /// @stable ICU 2.0
	    public UnicodeSet(String pattern) : this() {
	        ApplyPattern(pattern, null, null, IGNORE_SPACE);
	    }
	
	    /// <summary>
	    /// Constructs a set from the given pattern. See the class description for
	    /// the syntax of the pattern language.
	    /// </summary>
	    ///
	    /// <param name="pattern">a string specifying what characters are in the set</param>
	    /// <param name="ignoreWhitespace">if true, ignore characters for whichUCharacterProperty.isRuleWhiteSpace() returns true</param>
	    /// <exception cref="System.ArgumentException">if the pattern contains a syntax error.</exception>
	    /// @stable ICU 2.0
	    public UnicodeSet(String pattern, bool ignoreWhitespace) : this() {
	        ApplyPattern(pattern, null, null, (ignoreWhitespace) ? IGNORE_SPACE : 0);
	    }
	
	    /// <summary>
	    /// Constructs a set from the given pattern. See the class description for
	    /// the syntax of the pattern language.
	    /// </summary>
	    ///
	    /// <param name="pattern">a string specifying what characters are in the set</param>
	    /// <param name="options">a bitmask indicating which options to apply. Valid options areIGNORE_SPACE and CASE.</param>
	    /// <exception cref="System.ArgumentException">if the pattern contains a syntax error.</exception>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public UnicodeSet(String pattern, int options) : this() {
	        ApplyPattern(pattern, null, null, options);
	    }
	
	    /// <summary>
	    /// Constructs a set from the given pattern. See the class description for
	    /// the syntax of the pattern language.
	    /// </summary>
	    ///
	    /// <param name="pattern">a string specifying what characters are in the set</param>
	    /// <param name="pos">on input, the position in pattern at which to start parsing.On output, the position after the last character parsed.</param>
	    /// <param name="symbols">a symbol table mapping variables to char[] arrays and chars toUnicodeSets</param>
	    /// <exception cref="System.ArgumentException">if the pattern contains a syntax error.</exception>
	    /// @stable ICU 2.0
	    public UnicodeSet(String pattern, ParsePosition pos, SymbolTable symbols) : this() {
	        ApplyPattern(pattern, pos, symbols, IGNORE_SPACE);
	    }
	
	    /// <summary>
	    /// Constructs a set from the given pattern. See the class description for
	    /// the syntax of the pattern language.
	    /// </summary>
	    ///
	    /// <param name="pattern">a string specifying what characters are in the set</param>
	    /// <param name="pos">on input, the position in pattern at which to start parsing.On output, the position after the last character parsed.</param>
	    /// <param name="symbols">a symbol table mapping variables to char[] arrays and chars toUnicodeSets</param>
	    /// <param name="options">a bitmask indicating which options to apply. Valid options areIGNORE_SPACE and CASE.</param>
	    /// <exception cref="System.ArgumentException">if the pattern contains a syntax error.</exception>
	    /// @stable ICU 3.2
	    public UnicodeSet(String pattern, ParsePosition pos, SymbolTable symbols,
	            int options) : this() {
	        ApplyPattern(pattern, pos, symbols, options);
	    }
	
	    /// <summary>
	    /// Return a new set that is equivalent to this one.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public virtual Object Clone() {
	        UnicodeSet result = new UnicodeSet(this);
	        result.frozen = this.frozen;
	        return result;
	    }
	
	    /// <summary>
	    /// Make this object represent the range <c>start - end</c>. If
	    /// <c>end > start</c> then this object is set to an an empty range.
	    /// </summary>
	    ///
	    /// <param name="start">first character in the set, inclusive</param>
	    /// <param name="end">last character in the set, inclusive</param>
	    /// @stable ICU 2.0
	    public UnicodeSet Set(int start, int end) {
	        CheckFrozen();
	        Clear();
	        Complement(start, end);
	        return this;
	    }
	
	    /// <summary>
	    /// Make this object represent the same set as <c>other</c>.
	    /// </summary>
	    ///
	    /// <param name="other">a <c>UnicodeSet</c> whose value will be copied to thisobject</param>
	    /// @stable ICU 2.0
	    public UnicodeSet Set(UnicodeSet other) {
	        CheckFrozen();
	        list = (int[]) other.list.Clone();
	        len = other.len;
	        pat = other.pat;
	        strings = (SortedSet) other.strings;
	        return this;
	    }
	
	    /// <summary>
	    /// Modifies this set to represent the set specified by the given pattern.
	    /// See the class description for the syntax of the pattern language.
	    /// Whitespace is ignored.
	    /// </summary>
	    ///
	    /// <param name="pattern">a string specifying what characters are in the set</param>
	    /// <exception cref="System.ArgumentException">if the pattern contains a syntax error.</exception>
	    /// @stable ICU 2.0
	    public UnicodeSet ApplyPattern(String pattern) {
	        CheckFrozen();
	        return ApplyPattern(pattern, null, null, IGNORE_SPACE);
	    }
	
	    /// <summary>
	    /// Modifies this set to represent the set specified by the given pattern,
	    /// optionally ignoring whitespace. See the class description for the syntax
	    /// of the pattern language.
	    /// </summary>
	    ///
	    /// <param name="pattern">a string specifying what characters are in the set</param>
	    /// <param name="ignoreWhitespace">if true then characters for whichUCharacterProperty.isRuleWhiteSpace() returns true are ignored</param>
	    /// <exception cref="System.ArgumentException">if the pattern contains a syntax error.</exception>
	    /// @stable ICU 2.0
	    public UnicodeSet ApplyPattern(String pattern, bool ignoreWhitespace) {
	        CheckFrozen();
	        return ApplyPattern(pattern, null, null,
	                (ignoreWhitespace) ? IGNORE_SPACE : 0);
	    }
	
	    /// <summary>
	    /// Modifies this set to represent the set specified by the given pattern,
	    /// optionally ignoring whitespace. See the class description for the syntax
	    /// of the pattern language.
	    /// </summary>
	    ///
	    /// <param name="pattern">a string specifying what characters are in the set</param>
	    /// <param name="options">a bitmask indicating which options to apply. Valid options areIGNORE_SPACE and CASE.</param>
	    /// <exception cref="System.ArgumentException">if the pattern contains a syntax error.</exception>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public UnicodeSet ApplyPattern(String pattern, int options) {
	        CheckFrozen();
	        return ApplyPattern(pattern, null, null, options);
	    }
	
	    /// <summary>
	    /// Return true if the given position, in the given pattern, appears to be
	    /// the start of a UnicodeSet pattern.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public static bool ResemblesPattern(String pattern, int pos) {
	        return ((pos + 1) < pattern.Length && pattern[pos] == '[')
	                || ResemblesPropertyPattern(pattern, pos);
	    }
	
	    /// <summary>
	    /// Append the <c>toPattern()</c> representation of a string to the
	    /// given <c>StringBuffer</c>.
	    /// </summary>
	    ///
	    private static void _appendToPat(StringBuilder buf, String s,
	            bool escapeUnprintable) {
	        for (int i = 0; i < s.Length; i += IBM.ICU.Text.UTF16.GetCharCount(i)) {
	            _appendToPat(buf, IBM.ICU.Text.UTF16.CharAt(s, i), escapeUnprintable);
	        }
	    }
	
	    /// <summary>
	    /// Append the <c>toPattern()</c> representation of a character to the
	    /// given <c>StringBuffer</c>.
	    /// </summary>
	    ///
	    private static void _appendToPat(StringBuilder buf, int c,
	            bool escapeUnprintable) {
	        if (escapeUnprintable && IBM.ICU.Impl.Utility.IsUnprintable(c)) {
	            // Use hex escape notation (<backslash>uxxxx or
	            // <backslash>Uxxxxxxxx) for anything
	            // unprintable
	            if (IBM.ICU.Impl.Utility.EscapeUnprintable(buf, c)) {
	                return;
	            }
	        }
	        // Okay to let ':' pass through
	        switch (c) {
	        case '[': // SET_OPEN:
	        case ']': // SET_CLOSE:
	        case '-': // HYPHEN:
	        case '^': // COMPLEMENT:
	        case '&': // INTERSECTION:
	        case '\\': // BACKSLASH:
	        case '{':
	        case '}':
	        case '$':
	        case ':':
	            buf.Append('\\');
	            break;
	        default:
	            // Escape whitespace
	            if (IBM.ICU.Impl.UCharacterProperty.IsRuleWhiteSpace(c)) {
	                buf.Append('\\');
	            }
	            break;
	        }
	        IBM.ICU.Text.UTF16.Append(buf, c);
	    }
	
	    /// <summary>
	    /// Returns a string representation of this set. If the result of calling
	    /// this function is passed to a UnicodeSet constructor, it will produce
	    /// another set that is equal to this one.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public override String ToPattern(bool escapeUnprintable) {
	        StringBuilder result = new StringBuilder();
	        return _toPattern(result, escapeUnprintable).ToString();
	    }
	
	    /// <summary>
	    /// Append a string representation of this set to result. This will be a
	    /// cleaned version of the string passed to applyPattern(), if there is one.
	    /// Otherwise it will be generated.
	    /// </summary>
	    ///
	    private StringBuilder _toPattern(StringBuilder result,
	            bool escapeUnprintable) {
	        if (pat != null) {
	            int i;
	            int backslashCount = 0;
	            for (i = 0; i < pat.Length;) {
	                int c = IBM.ICU.Text.UTF16.CharAt(pat, i);
	                i += IBM.ICU.Text.UTF16.GetCharCount(c);
	                if (escapeUnprintable && IBM.ICU.Impl.Utility.IsUnprintable(c)) {
	                    // If the unprintable character is preceded by an odd
	                    // number of backslashes, then it has been escaped.
	                    // Before unescaping it, we delete the final
	                    // backslash.
	                    if ((backslashCount % 2) == 1) {
	                        result.Length=result.Length - 1;
	                    }
	                    IBM.ICU.Impl.Utility.EscapeUnprintable(result, c);
	                    backslashCount = 0;
	                } else {
	                    IBM.ICU.Text.UTF16.Append(result, c);
	                    if (c == '\\') {
	                        ++backslashCount;
	                    } else {
	                        backslashCount = 0;
	                    }
	                }
	            }
	            return result;
	        }
	
	        return _generatePattern(result, escapeUnprintable, true);
	    }
	
	    /// <summary>
	    /// Generate and append a string representation of this set to result. This
	    /// does not use this.pat, the cleaned up copy of the string passed to
	    /// applyPattern().
	    /// </summary>
	    ///
	    /// <param name="result">the buffer into which to generate the pattern</param>
	    /// <param name="escapeUnprintable">escape unprintable characters if true</param>
	    /// @stable ICU 2.0
	    public StringBuilder _generatePattern(StringBuilder result,
	            bool escapeUnprintable) {
	        return _generatePattern(result, escapeUnprintable, true);
	    }
	
	    /// <summary>
	    /// Generate and append a string representation of this set to result. This
	    /// does not use this.pat, the cleaned up copy of the string passed to
	    /// applyPattern().
	    /// </summary>
	    ///
	    /// <param name="includeStrings">if false, doesn't include the strings.</param>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public StringBuilder _generatePattern(StringBuilder result,
	            bool escapeUnprintable, bool includeStrings) {
	        result.Append('[');
	
	        // // Check against the predefined categories. We implicitly build
	        // // up ALL category sets the first time toPattern() is called.
	        // for (int cat=0; cat<CATEGORY_COUNT; ++cat) {
	        // if (this.equals(getCategorySet(cat))) {
	        // result.append(':');
	        // result.append(CATEGORY_NAMES.substring(cat*2, cat*2+2));
	        // return result.append(":]");
	        // }
	        // }
	
	        int count = GetRangeCount();
	
	        // If the set contains at least 2 intervals and includes both
	        // MIN_VALUE and MAX_VALUE, then the inverse representation will
	        // be more economical.
	        if (count > 1 && GetRangeStart(0) == MIN_VALUE
	                && GetRangeEnd(count - 1) == MAX_VALUE) {
	
	            // Emit the inverse
	            result.Append('^');
	
	            for (int i = 1; i < count; ++i) {
	                int start = GetRangeEnd(i - 1) + 1;
	                int end = GetRangeStart(i) - 1;
	                _appendToPat(result, start, escapeUnprintable);
	                if (start != end) {
	                    if ((start + 1) != end) {
	                        result.Append('-');
	                    }
	                    _appendToPat(result, end, escapeUnprintable);
	                }
	            }
	        }
	
	        // Default; emit the ranges as pairs
	        else {
	            for (int i_0 = 0; i_0 < count; ++i_0) {
	                int start_1 = GetRangeStart(i_0);
	                int end_2 = GetRangeEnd(i_0);
	                _appendToPat(result, start_1, escapeUnprintable);
	                if (start_1 != end_2) {
	                    if ((start_1 + 1) != end_2) {
	                        result.Append('-');
	                    }
	                    _appendToPat(result, end_2, escapeUnprintable);
	                }
	            }
	        }
	
	        if (includeStrings && strings.Count > 0) {
	            IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(strings.GetEnumerator());
	            while (it.HasNext()) {
	                result.Append('{');
	                _appendToPat(result, (String) it.Next(), escapeUnprintable);
	                result.Append('}');
	            }
	        }
	        return result.Append(']');
	    }
	
	    /// <summary>
	    /// Returns the number of elements in this set (its cardinality) Note than
	    /// the elements of a set may include both individual codepoints and strings.
	    /// </summary>
	    ///
	    /// <returns>the number of elements in this set (its cardinality).</returns>
	    /// @stable ICU 2.0
	    public int Size() {
	        int n = 0;
	        int count = GetRangeCount();
	        for (int i = 0; i < count; ++i) {
	            n += GetRangeEnd(i) - GetRangeStart(i) + 1;
	        }
	        return n + strings.Count;
	    }
	
	    /// <summary>
	    /// Returns <tt>true</tt> if this set contains no elements.
	    /// </summary>
	    ///
	    /// <returns><tt>true</tt> if this set contains no elements.</returns>
	    /// @stable ICU 2.0
	    public bool IsEmpty() {
	        return len == 1 && strings.Count == 0;
	    }
	
	    /// <summary>
	    /// Implementation of UnicodeMatcher API. Returns <tt>true</tt> if this set
	    /// contains any character whose low byte is the given value. This is used by
	    /// <tt>RuleBasedTransliterator</tt> for indexing.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public override bool MatchesIndexValue(int v) {
	        /*
	         * The index value v, in the range [0,255], is contained in this set if
	         * it is contained in any pair of this set. Pairs either have the high
	         * bytes equal, or unequal. If the high bytes are equal, then we have
	         * aaxx..aayy, where aa is the high byte. Then v is contained if xx <= v
	         * <= yy. If the high bytes are unequal we have aaxx..bbyy, bb>aa. Then
	         * v is contained if xx <= v || v <= yy. (This is identical to the time
	         * zone month containment logic.)
	         */
	        for (int i = 0; i < GetRangeCount(); ++i) {
	            int low = GetRangeStart(i);
	            int high = GetRangeEnd(i);
	            if ((low & ~0xFF) == (high & ~0xFF)) {
	                if ((low & 0xFF) <= v && v <= (high & 0xFF)) {
	                    return true;
	                }
	            } else if ((low & 0xFF) <= v || v <= (high & 0xFF)) {
	                return true;
	            }
	        }
	        if (strings.Count != 0) {
	            IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(strings.GetEnumerator());
	            while (it.HasNext()) {
	                String s = (String) it.Next();
	                // if (s.length() == 0) {
	                // // Empty strings match everything
	                // return true;
	                // }
	                // assert(s.length() != 0); // We enforce this elsewhere
	                int c = IBM.ICU.Text.UTF16.CharAt(s, 0);
	                if ((c & 0xFF) == v) {
	                    return true;
	                }
	            }
	        }
	        return false;
	    }
	
	    /// <summary>
	    /// Implementation of UnicodeMatcher.matches(). Always matches the longest
	    /// possible multichar string.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public override int Matches(Replaceable text, int[] offset, int limit,
	            bool incremental) {
	
	        if (offset[0] == limit) {
	            // Strings, if any, have length != 0, so we don't worry
	            // about them here. If we ever allow zero-length strings
	            // we much check for them here.
	            if (Contains(IBM.ICU.Text.UnicodeMatcher_Constants.ETHER)) {
	                return (incremental) ? IBM.ICU.Text.UnicodeMatcher_Constants.U_PARTIAL_MATCH : IBM.ICU.Text.UnicodeMatcher_Constants.U_MATCH;
	            } else {
	                return IBM.ICU.Text.UnicodeMatcher_Constants.U_MISMATCH;
	            }
	        } else {
	            if (strings.Count != 0) { // try strings first
	
	                // might separate forward and backward loops later
	                // for now they are combined
	
	                // TODO Improve efficiency of this, at least in the forward
	                // direction, if not in both. In the forward direction we
	                // can assume the strings are sorted.
	
	                IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(strings.GetEnumerator());
	                bool forward = offset[0] < limit;
	
	                // firstChar is the leftmost char to match in the
	                // forward direction or the rightmost char to match in
	                // the reverse direction.
	                char firstChar = text.CharAt(offset[0]);
	
	                // If there are multiple strings that can match we
	                // return the longest match.
	                int highWaterLength = 0;
	
	                while (it.HasNext()) {
	                    String trial = (String) it.Next();
	
	                    // if (trial.length() == 0) {
	                    // return U_MATCH; // null-string always matches
	                    // }
	                    // assert(trial.length() != 0); // We ensure this elsewhere
	
	                    char c = trial[(forward) ? 0 : trial.Length - 1];
	
	                    // Strings are sorted, so we can optimize in the
	                    // forward direction.
	                    if (forward && c > firstChar)
	                        break;
	                    if (c != firstChar)
	                        continue;
	
	                    int length = MatchRest(text, offset[0], limit, trial);
	
	                    if (incremental) {
	                        int maxLen = (forward) ? limit - offset[0] : offset[0]
	                                - limit;
	                        if (length == maxLen) {
	                            // We have successfully matched but only up to
	                            // limit.
	                            return IBM.ICU.Text.UnicodeMatcher_Constants.U_PARTIAL_MATCH;
	                        }
	                    }
	
	                    if (length == trial.Length) {
	                        // We have successfully matched the whole string.
	                        if (length > highWaterLength) {
	                            highWaterLength = length;
	                        }
	                        // In the forward direction we know strings
	                        // are sorted so we can bail early.
	                        if (forward && length < highWaterLength) {
	                            break;
	                        }
	                        continue;
	                    }
	                }
	
	                // We've checked all strings without a partial match.
	                // If we have full matches, return the longest one.
	                if (highWaterLength != 0) {
	                    offset[0] += (forward) ? highWaterLength : -highWaterLength;
	                    return IBM.ICU.Text.UnicodeMatcher_Constants.U_MATCH;
	                }
	            }
	            return base.Matches(text,offset,limit,incremental);
	        }
	    }
	
	    /// <summary>
	    /// Returns the longest match for s in text at the given position. If limit >
	    /// start then match forward from start+1 to limit matching all characters
	    /// except s.charAt(0). If limit < start, go backward starting from start-1
	    /// matching all characters except s.charAt(s.length()-1). This method
	    /// assumes that the first character, text.charAt(start), matches s, so it
	    /// does not check it.
	    /// </summary>
	    ///
	    /// <param name="text">the text to match</param>
	    /// <param name="start">the first character to match. In the forward direction,text.charAt(start) is matched against s.charAt(0). In thereverse direction, it is matched againsts.charAt(s.length()-1).</param>
	    /// <param name="limit">the limit offset for matching, either last+1 in the forwarddirection, or last-1 in the reverse direction, where last isthe index of the last character to match.</param>
	    /// <returns>If part of s matches up to the limit, return |limit - start|. If
	    /// all of s matches before reaching the limit, return s.length(). If
	    /// there is a mismatch between s and text, return 0</returns>
	    private static int MatchRest(Replaceable text, int start, int limit,
	            String s) {
	        int maxLen;
	        int slen = s.Length;
	        if (start < limit) {
	            maxLen = limit - start;
	            if (maxLen > slen)
	                maxLen = slen;
	            for (int i = 1; i < maxLen; ++i) {
	                if (text.CharAt(start + i) != s[i])
	                    return 0;
	            }
	        } else {
	            maxLen = start - limit;
	            if (maxLen > slen)
	                maxLen = slen;
	            --slen; // <=> slen = s.length() - 1;
	            for (int i_0 = 1; i_0 < maxLen; ++i_0) {
	                if (text.CharAt(start - i_0) != s[slen - i_0])
	                    return 0;
	            }
	        }
	        return maxLen;
	    }
	
	    // #if defined(FOUNDATION10) || defined(J2SE13)
	    // #else
	    /// <exclude/>
	    /// <summary>
	    /// Tests whether the text matches at the offset. If so, returns the end of
	    /// the longest substring that it matches. If not, returns -1.
	    /// </summary>
	    ///
	    public int MatchesAt(String text, int offset) {
	        int lastLen = -1;
	        strings: {
	            if (strings.Count != 0) {
	                char firstChar = text[offset];
	                String trial = null;
	                // find the first string starting with firstChar
	                IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(strings.GetEnumerator());
	                while (it.HasNext()) {
	                    trial = (String) it.Next();
	                    char firstStringChar = trial[0];
	                    if (firstStringChar < firstChar)
	                        continue;
	                    if (firstStringChar > firstChar)
	                        goto gotostrings;
	                }
	                // now keep checking string until we get the longest one
	                for (;;) {
	                    int tempLen = MatchesAt(text, offset, trial);
	                    if (lastLen > tempLen)
	                        goto gotostrings;
	                    lastLen = tempLen;
	                    if (!it.HasNext())
	                        break;
	                    trial = (String) it.Next();
	                }
	            }
	        }
	        gotostrings:
	        ;
	        if (lastLen < 2) {
	            int cp = IBM.ICU.Text.UTF16.CharAt(text, offset);
	            if (Contains(cp)) {
	                lastLen = IBM.ICU.Text.UTF16.GetCharCount(cp);
	            }
	        }
	        return offset + lastLen;
	    }
	
	    /// <summary>
	    /// Does one string contain another, starting at a specific offset?
	    /// </summary>
	    ///
	    /// <param name="text"></param>
	    /// <param name="offset"></param>
	    /// <param name="other"></param>
	    /// <returns></returns>
	    // Note: This method was moved from CollectionUtilities
	    private static int MatchesAt(String text, int offset,
	            String other) {
	        int len_0 = other.Length;
	        int i = 0;
	        int j = offset;
	        for (; i < len_0; ++i, ++j) {
	            char pc = other[i];
	            char tc = text[j];
	            if (pc != tc)
	                return -1;
	        }
	        return i;
	    }
	
	    // #endif
	
	    /// <summary>
	    /// Implementation of UnicodeMatcher API. Union the set of all characters
	    /// that may be matched by this object into the given set.
	    /// </summary>
	    ///
	    /// <param name="toUnionTo">the set into which to union the source characters</param>
	    /// @stable ICU 2.2
	    public override void AddMatchSetTo(UnicodeSet toUnionTo) {
	        toUnionTo.AddAll(this);
	    }
	
	    /// <summary>
	    /// Returns the index of the given character within this set, where the set
	    /// is ordered by ascending code point. If the character is not in this set,
	    /// return -1. The inverse of this method is <c>charAt()</c>.
	    /// </summary>
	    ///
	    /// <returns>an index from 0..size()-1, or -1</returns>
	    /// @stable ICU 2.0
	    public int IndexOf(int c) {
	        if (c < MIN_VALUE || c > MAX_VALUE) {
	            throw new ArgumentException("Invalid code point U+"
	                    + IBM.ICU.Impl.Utility.Hex(c, 6));
	        }
	        int i = 0;
	        int n = 0;
	        for (;;) {
	            int start = list[i++];
	            if (c < start) {
	                return -1;
	            }
	            int limit = list[i++];
	            if (c < limit) {
	                return n + c - start;
	            }
	            n += limit - start;
	        }
	    }
	
	    /// <summary>
	    /// Returns the character at the given index within this set, where the set
	    /// is ordered by ascending code point. If the index is out of range, return
	    /// -1. The inverse of this method is <c>indexOf()</c>.
	    /// </summary>
	    ///
	    /// <param name="index">an index from 0..size()-1</param>
	    /// <returns>the character at the given index, or -1.</returns>
	    /// @stable ICU 2.0
	    public int CharAt(int index) {
	        if (index >= 0) {
	            // len2 is the largest even integer <= len, that is, it is len
	            // for even values and len-1 for odd values. With odd values
	            // the last entry is UNICODESET_HIGH.
	            int len2 = len & ~1;
	            for (int i = 0; i < len2;) {
	                int start = list[i++];
	                int count = list[i++] - start;
	                if (index < count) {
	                    return start + index;
	                }
	                index -= count;
	            }
	        }
	        return -1;
	    }
	
	    /// <summary>
	    /// Adds the specified range to this set if it is not already present. If
	    /// this set already contains the specified range, the call leaves this set
	    /// unchanged. If <c>end > start</c> then an empty range is added,
	    /// leaving the set unchanged.
	    /// </summary>
	    ///
	    /// <param name="start">first character, inclusive, of range to be added to this set.</param>
	    /// <param name="end">last character, inclusive, of range to be added to this set.</param>
	    /// @stable ICU 2.0
	    public UnicodeSet Add(int start, int end) {
	        CheckFrozen();
	        return Add_unchecked(start, end);
	    }
	
	    // for internal use, after checkFrozen has been called
	    private UnicodeSet Add_unchecked(int start, int end) {
	        if (start < MIN_VALUE || start > MAX_VALUE) {
	            throw new ArgumentException("Invalid code point U+"
	                    + IBM.ICU.Impl.Utility.Hex(start, 6));
	        }
	        if (end < MIN_VALUE || end > MAX_VALUE) {
	            throw new ArgumentException("Invalid code point U+"
	                    + IBM.ICU.Impl.Utility.Hex(end, 6));
	        }
	        if (start < end) {
	            Add(Range(start, end), 2, 0);
	        } else if (start == end) {
	            Add(start);
	        }
	        return this;
	    }
	
	    // /**
	    // * Format out the inversion list as a string, for debugging. Uncomment
	    // when
	    // * needed.
	    // */
	    // public final String dump() {
	    // StringBuffer buf = new StringBuffer("[");
	    // for (int i=0; i<len; ++i) {
	    // if (i != 0) buf.append(", ");
	    // int c = list[i];
	    // //if (c <= 0x7F && c != '\n' && c != '\r' && c != '\t' && c != ' ') {
	    // // buf.append((char) c);
	    // //} else {
	    // buf.append("U+").append(Utility.hex(c, (c<0x10000)?4:6));
	    // //}
	    // }
	    // buf.append("]");
	    // return buf.toString();
	    // }
	
	    /// <summary>
	    /// Adds the specified character to this set if it is not already present. If
	    /// this set already contains the specified character, the call leaves this
	    /// set unchanged.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public UnicodeSet Add(int c) {
	        CheckFrozen();
	        return Add_unchecked(c);
	    }
	
	    // for internal use only, after checkFrozen has been called
	    private UnicodeSet Add_unchecked(int c) {
	        if (c < MIN_VALUE || c > MAX_VALUE) {
	            throw new ArgumentException("Invalid code point U+"
	                    + IBM.ICU.Impl.Utility.Hex(c, 6));
	        }
	
	        // find smallest i such that c < list[i]
	        // if odd, then it is IN the set
	        // if even, then it is OUT of the set
	        int i = FindCodePoint(c);
	
	        // already in set?
	        if ((i & 1) != 0)
	            return this;
	
	        // HIGH is 0x110000
	        // assert(list[len-1] == HIGH);
	
	        // empty = [HIGH]
	        // [start_0, limit_0, start_1, limit_1, HIGH]
	
	        // [..., start_k-1, limit_k-1, start_k, limit_k, ..., HIGH]
	        // ^
	        // list[i]
	
	        // i == 0 means c is before the first range
	
	        if (c == list[i] - 1) {
	            // c is before start of next range
	            list[i] = c;
	            // if we touched the HIGH mark, then add a new one
	            if (c == MAX_VALUE) {
	                EnsureCapacity(len + 1);
	                list[len++] = HIGH;
	            }
	            if (i > 0 && c == list[i - 1]) {
	                // collapse adjacent ranges
	
	                // [..., start_k-1, c, c, limit_k, ..., HIGH]
	                // ^
	                // list[i]
	                System.Array.Copy((Array)(list),i + 1,(Array)(list),i - 1,len - i - 1);
	                len -= 2;
	            }
	        }
	
	        else if (i > 0 && c == list[i - 1]) {
	            // c is after end of prior range
	            list[i - 1]++;
	            // no need to chcek for collapse here
	        }
	
	        else {
	            // At this point we know the new char is not adjacent to
	            // any existing ranges, and it is not 10FFFF.
	
	            // [..., start_k-1, limit_k-1, start_k, limit_k, ..., HIGH]
	            // ^
	            // list[i]
	
	            // [..., start_k-1, limit_k-1, c, c+1, start_k, limit_k, ..., HIGH]
	            // ^
	            // list[i]
	
	            // Don't use ensureCapacity() to save on copying.
	            // NOTE: This has no measurable impact on performance,
	            // but it might help in some usage patterns.
	            if (len + 2 > list.Length) {
	                int[] temp = new int[len + 2 + GROW_EXTRA];
	                if (i != 0)
	                    System.Array.Copy((Array)(list),0,(Array)(temp),0,i);
	                System.Array.Copy((Array)(list),i,(Array)(temp),i + 2,len - i);
	                list = temp;
	            } else {
	                System.Array.Copy((Array)(list),i,(Array)(list),i + 2,len - i);
	            }
	
	            list[i] = c;
	            list[i + 1] = c + 1;
	            len += 2;
	        }
	
	        pat = null;
	        return this;
	    }
	
	    /// <summary>
	    /// Adds the specified multicharacter to this set if it is not already
	    /// present. If this set already contains the multicharacter, the call leaves
	    /// this set unchanged. Thus "ch" => {"ch"} <br>
	    /// <b>Warning: you cannot add an empty string ("") to a UnicodeSet.</b>
	    /// </summary>
	    ///
	    /// <param name="s">the source string</param>
	    /// <returns>this object, for chaining</returns>
	    /// @stable ICU 2.0
	    public UnicodeSet Add(String s) {
	        CheckFrozen();
	        int cp = GetSingleCP(s);
	        if (cp < 0) {
	            ILOG.J2CsMapping.Collections.Collections.Add(strings,s);
	            pat = null;
	        } else {
	            Add_unchecked(cp, cp);
	        }
	        return this;
	    }
	
	    
	    /// <returns>a code point IF the string consists of a single one. otherwise
	    /// returns -1.</returns>
	    /// <param name="string">to test</param>
	    private static int GetSingleCP(String s) {
	        if (s.Length < 1) {
	            throw new ArgumentException(
	                    "Can't use zero-length strings in UnicodeSet");
	        }
	        if (s.Length > 2)
	            return -1;
	        if (s.Length == 1)
	            return s[0];
	
	        // at this point, len = 2
	        int cp = IBM.ICU.Text.UTF16.CharAt(s, 0);
	        if (cp > 0xFFFF) { // is surrogate pair
	            return cp;
	        }
	        return -1;
	    }
	
	    /// <summary>
	    /// Adds each of the characters in this string to the set. Thus "ch" => {"c",
	    /// "h"} If this set already any particular character, it has no effect on
	    /// that character.
	    /// </summary>
	    ///
	    /// <param name="s">the source string</param>
	    /// <returns>this object, for chaining</returns>
	    /// @stable ICU 2.0
	    public UnicodeSet AddAll(String s) {
	        CheckFrozen();
	        int cp;
	        for (int i = 0; i < s.Length; i += IBM.ICU.Text.UTF16.GetCharCount(cp)) {
	            cp = IBM.ICU.Text.UTF16.CharAt(s, i);
	            Add_unchecked(cp, cp);
	        }
	        return this;
	    }
	
	    /// <summary>
	    /// Retains EACH of the characters in this string. Note: "ch" == {"c", "h"}
	    /// If this set already any particular character, it has no effect on that
	    /// character.
	    /// </summary>
	    ///
	    /// <param name="s">the source string</param>
	    /// <returns>this object, for chaining</returns>
	    /// @stable ICU 2.0
	    public UnicodeSet RetainAll(String s) {
	        return RetainAll(FromAll(s));
	    }
	
	    /// <summary>
	    /// Complement EACH of the characters in this string. Note: "ch" == {"c",
	    /// "h"} If this set already any particular character, it has no effect on
	    /// that character.
	    /// </summary>
	    ///
	    /// <param name="s">the source string</param>
	    /// <returns>this object, for chaining</returns>
	    /// @stable ICU 2.0
	    public UnicodeSet ComplementAll(String s) {
	        return ComplementAll(FromAll(s));
	    }
	
	    /// <summary>
	    /// Remove EACH of the characters in this string. Note: "ch" == {"c", "h"} If
	    /// this set already any particular character, it has no effect on that
	    /// character.
	    /// </summary>
	    ///
	    /// <param name="s">the source string</param>
	    /// <returns>this object, for chaining</returns>
	    /// @stable ICU 2.0
	    public UnicodeSet RemoveAll(String s) {
	        return RemoveAll(FromAll(s));
	    }
	
	    /// <summary>
	    /// Makes a set from a multicharacter string. Thus "ch" => {"ch"} <br>
	    /// <b>Warning: you cannot add an empty string ("") to a UnicodeSet.</b>
	    /// </summary>
	    ///
	    /// <param name="s">the source string</param>
	    /// <returns>a newly created set containing the given string</returns>
	    /// @stable ICU 2.0
	    public static UnicodeSet From(String s) {
	        return new UnicodeSet().Add(s);
	    }
	
	    /// <summary>
	    /// Makes a set from each of the characters in the string. Thus "ch" => {"c",
	    /// "h"}
	    /// </summary>
	    ///
	    /// <param name="s">the source string</param>
	    /// <returns>a newly created set containing the given characters</returns>
	    /// @stable ICU 2.0
	    public static UnicodeSet FromAll(String s) {
	        return new UnicodeSet().AddAll(s);
	    }
	
	    /// <summary>
	    /// Retain only the elements in this set that are contained in the specified
	    /// range. If <c>end > start</c> then an empty range is retained,
	    /// leaving the set empty.
	    /// </summary>
	    ///
	    /// <param name="start">first character, inclusive, of range to be retained to thisset.</param>
	    /// <param name="end">last character, inclusive, of range to be retained to thisset.</param>
	    /// @stable ICU 2.0
	    public UnicodeSet Retain(int start, int end) {
	        CheckFrozen();
	        if (start < MIN_VALUE || start > MAX_VALUE) {
	            throw new ArgumentException("Invalid code point U+"
	                    + IBM.ICU.Impl.Utility.Hex(start, 6));
	        }
	        if (end < MIN_VALUE || end > MAX_VALUE) {
	            throw new ArgumentException("Invalid code point U+"
	                    + IBM.ICU.Impl.Utility.Hex(end, 6));
	        }
	        if (start <= end) {
	            Retain(Range(start, end), 2, 0);
	        } else {
	            Clear();
	        }
	        return this;
	    }
	
	    /// <summary>
	    /// Retain the specified character from this set if it is present. Upon
	    /// return this set will be empty if it did not contain c, or will only
	    /// contain c if it did contain c.
	    /// </summary>
	    ///
	    /// <param name="c">the character to be retained</param>
	    /// <returns>this object, for chaining</returns>
	    /// @stable ICU 2.0
	    public UnicodeSet Retain(int c) {
	        return Retain(c, c);
	    }
	
	    /// <summary>
	    /// Retain the specified string in this set if it is present. Upon return
	    /// this set will be empty if it did not contain s, or will only contain s if
	    /// it did contain s.
	    /// </summary>
	    ///
	    /// <param name="s">the string to be retained</param>
	    /// <returns>this object, for chaining</returns>
	    /// @stable ICU 2.0
	    public UnicodeSet Retain(String s) {
	        int cp = GetSingleCP(s);
	        if (cp < 0) {
	            bool isIn = ILOG.J2CsMapping.Collections.Collections.Contains(s,strings);
	            if (isIn && Size() == 1) {
	                return this;
	            }
	            Clear();
	            ILOG.J2CsMapping.Collections.Generics.Collections.Add(strings,s);
	            pat = null;
	        } else {
	            Retain(cp, cp);
	        }
	        return this;
	    }
	
	    /// <summary>
	    /// Removes the specified range from this set if it is present. The set will
	    /// not contain the specified range once the call returns. If
	    /// <c>end > start</c> then an empty range is removed, leaving the set
	    /// unchanged.
	    /// </summary>
	    ///
	    /// <param name="start">first character, inclusive, of range to be removed from thisset.</param>
	    /// <param name="end">last character, inclusive, of range to be removed from thisset.</param>
	    /// @stable ICU 2.0
	    public UnicodeSet Remove(int start, int end) {
	        CheckFrozen();
	        if (start < MIN_VALUE || start > MAX_VALUE) {
	            throw new ArgumentException("Invalid code point U+"
	                    + IBM.ICU.Impl.Utility.Hex(start, 6));
	        }
	        if (end < MIN_VALUE || end > MAX_VALUE) {
	            throw new ArgumentException("Invalid code point U+"
	                    + IBM.ICU.Impl.Utility.Hex(end, 6));
	        }
	        if (start <= end) {
	            Retain(Range(start, end), 2, 2);
	        }
	        return this;
	    }
	
	    /// <summary>
	    /// Removes the specified character from this set if it is present. The set
	    /// will not contain the specified character once the call returns.
	    /// </summary>
	    ///
	    /// <param name="c">the character to be removed</param>
	    /// <returns>this object, for chaining</returns>
	    /// @stable ICU 2.0
	    public UnicodeSet Remove(int c) {
	        return Remove(c, c);
	    }
	
	    /// <summary>
	    /// Removes the specified string from this set if it is present. The set will
	    /// not contain the specified string once the call returns.
	    /// </summary>
	    ///
	    /// <param name="s">the string to be removed</param>
	    /// <returns>this object, for chaining</returns>
	    /// @stable ICU 2.0
	    public UnicodeSet Remove(String s) {
	        int cp = GetSingleCP(s);
	        if (cp < 0) {
	            ILOG.J2CsMapping.Collections.Collections.Remove(strings,s);
	            pat = null;
	        } else {
	            Remove(cp, cp);
	        }
	        return this;
	    }
	
	    /// <summary>
	    /// Complements the specified range in this set. Any character in the range
	    /// will be removed if it is in this set, or will be added if it is not in
	    /// this set. If <c>end > start</c> then an empty range is
	    /// complemented, leaving the set unchanged.
	    /// </summary>
	    ///
	    /// <param name="start">first character, inclusive, of range to be removed from thisset.</param>
	    /// <param name="end">last character, inclusive, of range to be removed from thisset.</param>
	    /// @stable ICU 2.0
	    public UnicodeSet Complement(int start, int end) {
	        CheckFrozen();
	        if (start < MIN_VALUE || start > MAX_VALUE) {
	            throw new ArgumentException("Invalid code point U+"
	                    + IBM.ICU.Impl.Utility.Hex(start, 6));
	        }
	        if (end < MIN_VALUE || end > MAX_VALUE) {
	            throw new ArgumentException("Invalid code point U+"
	                    + IBM.ICU.Impl.Utility.Hex(end, 6));
	        }
	        if (start <= end) {
	            Xor(Range(start, end), 2, 0);
	        }
	        pat = null;
	        return this;
	    }
	
	    /// <summary>
	    /// Complements the specified character in this set. The character will be
	    /// removed if it is in this set, or will be added if it is not in this set.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public UnicodeSet Complement(int c) {
	        return Complement(c, c);
	    }
	
	    /// <summary>
	    /// This is equivalent to <c>complement(MIN_VALUE, MAX_VALUE)</c>.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public UnicodeSet Complement() {
	        CheckFrozen();
	        if (list[0] == LOW) {
	            System.Array.Copy((Array)(list),1,(Array)(list),0,len - 1);
	            --len;
	        } else {
	            EnsureCapacity(len + 1);
	            System.Array.Copy((Array)(list),0,(Array)(list),1,len);
	            list[0] = LOW;
	            ++len;
	        }
	        pat = null;
	        return this;
	    }
	
	    /// <summary>
	    /// Complement the specified string in this set. The set will not contain the
	    /// specified string once the call returns. <br>
	    /// <b>Warning: you cannot add an empty string ("") to a UnicodeSet.</b>
	    /// </summary>
	    ///
	    /// <param name="s">the string to complement</param>
	    /// <returns>this object, for chaining</returns>
	    /// @stable ICU 2.0
	    public UnicodeSet Complement(String s) {
	        CheckFrozen();
	        int cp = GetSingleCP(s);
	        if (cp < 0) {
	            if (ILOG.J2CsMapping.Collections.Collections.Contains(s,strings))
	                ILOG.J2CsMapping.Collections.Generics.Collections.Remove(strings,s);
	            else
	                ILOG.J2CsMapping.Collections.Generics.Collections.Add(strings,s);
	            pat = null;
	        } else {
	            Complement(cp, cp);
	        }
	        return this;
	    }
	
	    /// <summary>
	    /// Returns true if this set contains the given character.
	    /// </summary>
	    ///
	    /// <param name="c">character to be checked for containment</param>
	    /// <returns>true if the test condition is met</returns>
	    /// @stable ICU 2.0
	    public override bool Contains(int c) {
	        if (c < MIN_VALUE || c > MAX_VALUE) {
	            throw new ArgumentException("Invalid code point U+"
	                    + IBM.ICU.Impl.Utility.Hex(c, 6));
	        }
	
	        /*
	         * // Set i to the index of the start item greater than ch // We know we
	         * will terminate without length test! int i = -1; while (true) { if (c
	         * < list[++i]) break; }
	         */
	
	        int i = FindCodePoint(c);
	
	        return ((i & 1) != 0); // return true if odd
	    }
	
	    /// <summary>
	    /// Returns the smallest value i such that c < list[i]. Caller must ensure
	    /// that c is a legal value or this method will enter an infinite loop. This
	    /// method performs a binary search.
	    /// </summary>
	    ///
	    /// <param name="c">a character in the range MIN_VALUE..MAX_VALUE inclusive</param>
	    /// <returns>the smallest integer i in the range 0..len-1, inclusive, such
	    /// that c < list[i]</returns>
	    private int FindCodePoint(int c) {
	        /*
	         * Examples: findCodePoint(c) set list[] c=0 1 3 4 7 8 ===
	         * ============== =========== [] [110000] 0 0 0 0 0 0 [\u0000-\u0003]
	         * [0, 4, 110000] 1 1 1 2 2 2 [\u0004-\u0007] [4, 8, 110000] 0 0 0 1 1 2
	         * [:all:] [0, 110000] 1 1 1 1 1 1
	         */
	
	        // Return the smallest i such that c < list[i]. Assume
	        // list[len - 1] == HIGH and that c is legal (0..HIGH-1).
	        if (c < list[0])
	            return 0;
	        // High runner test. c is often after the last range, so an
	        // initial check for this condition pays off.
	        if (len >= 2 && c >= list[len - 2])
	            return len - 1;
	        int lo = 0;
	        int hi = len - 1;
	        // invariant: c >= list[lo]
	        // invariant: c < list[hi]
	        for (;;) {
	            int i = (int) (((uint) (lo + hi)) >> 1);
	            if (i == lo)
	                return hi;
	            if (c < list[i]) {
	                hi = i;
	            } else {
	                lo = i;
	            }
	        }
	    }
	
	    // //----------------------------------------------------------------
	    // // Unrolled binary search
	    // //----------------------------------------------------------------
	    //
	    // private int validLen = -1; // validated value of len
	    // private int topOfLow;
	    // private int topOfHigh;
	    // private int power;
	    // private int deltaStart;
	    //
	    // private void validate() {
	    // if (len <= 1) {
	    // throw new IllegalArgumentException("list.len==" + len + "; must be >1");
	    // }
	    //
	    // // find greatest power of 2 less than or equal to len
	    // for (power = exp2.length-1; power > 0 && exp2[power] > len; power--) {}
	    //
	    // // assert(exp2[power] <= len);
	    //
	    // // determine the starting points
	    // topOfLow = exp2[power] - 1;
	    // topOfHigh = len - 1;
	    // deltaStart = exp2[power-1];
	    // validLen = len;
	    // }
	    //
	    // private static final int exp2[] = {
	    // 0x1, 0x2, 0x4, 0x8,
	    // 0x10, 0x20, 0x40, 0x80,
	    // 0x100, 0x200, 0x400, 0x800,
	    // 0x1000, 0x2000, 0x4000, 0x8000,
	    // 0x10000, 0x20000, 0x40000, 0x80000,
	    // 0x100000, 0x200000, 0x400000, 0x800000,
	    // 0x1000000, 0x2000000, 0x4000000, 0x8000000,
	    // 0x10000000, 0x20000000 // , 0x40000000 // no unsigned int in Java
	    // };
	    //
	    // /**
	    // * Unrolled lowest index GT.
	    // */
	    // private final int leastIndexGT(int searchValue) {
	    //
	    // if (len != validLen) {
	    // if (len == 1) return 0;
	    // validate();
	    // }
	    // int temp;
	    //
	    // // set up initial range to search. Each subrange is a power of two in
	    // length
	    // int high = searchValue < list[topOfLow] ? topOfLow : topOfHigh;
	    //
	    // // Completely unrolled binary search, folhighing "Programming Pearls"
	    // // Each case deliberately falls through to the next
	    // // Logically, list[-1] < all_search_values && list[count] >
	    // all_search_values
	    // // although the values -1 and count are never actually touched.
	    //
	    // // The bounds at each point are low & high,
	    // // where low == high - delta*2
	    // // so high - delta is the midpoint
	    //
	    // // The invariant AFTER each line is that list[low] < searchValue <=
	    // list[high]
	    //
	    // switch (power) {
	    // //case 31: if (searchValue < list[temp = high-0x40000000]) high = temp;
	    // // no unsigned int in Java
	    // case 30: if (searchValue < list[temp = high-0x20000000]) high = temp;
	    // case 29: if (searchValue < list[temp = high-0x10000000]) high = temp;
	    //
	    // case 28: if (searchValue < list[temp = high- 0x8000000]) high = temp;
	    // case 27: if (searchValue < list[temp = high- 0x4000000]) high = temp;
	    // case 26: if (searchValue < list[temp = high- 0x2000000]) high = temp;
	    // case 25: if (searchValue < list[temp = high- 0x1000000]) high = temp;
	    //
	    // case 24: if (searchValue < list[temp = high- 0x800000]) high = temp;
	    // case 23: if (searchValue < list[temp = high- 0x400000]) high = temp;
	    // case 22: if (searchValue < list[temp = high- 0x200000]) high = temp;
	    // case 21: if (searchValue < list[temp = high- 0x100000]) high = temp;
	    //
	    // case 20: if (searchValue < list[temp = high- 0x80000]) high = temp;
	    // case 19: if (searchValue < list[temp = high- 0x40000]) high = temp;
	    // case 18: if (searchValue < list[temp = high- 0x20000]) high = temp;
	    // case 17: if (searchValue < list[temp = high- 0x10000]) high = temp;
	    //
	    // case 16: if (searchValue < list[temp = high- 0x8000]) high = temp;
	    // case 15: if (searchValue < list[temp = high- 0x4000]) high = temp;
	    // case 14: if (searchValue < list[temp = high- 0x2000]) high = temp;
	    // case 13: if (searchValue < list[temp = high- 0x1000]) high = temp;
	    //
	    // case 12: if (searchValue < list[temp = high- 0x800]) high = temp;
	    // case 11: if (searchValue < list[temp = high- 0x400]) high = temp;
	    // case 10: if (searchValue < list[temp = high- 0x200]) high = temp;
	    // case 9: if (searchValue < list[temp = high- 0x100]) high = temp;
	    //
	    // case 8: if (searchValue < list[temp = high- 0x80]) high = temp;
	    // case 7: if (searchValue < list[temp = high- 0x40]) high = temp;
	    // case 6: if (searchValue < list[temp = high- 0x20]) high = temp;
	    // case 5: if (searchValue < list[temp = high- 0x10]) high = temp;
	    //
	    // case 4: if (searchValue < list[temp = high- 0x8]) high = temp;
	    // case 3: if (searchValue < list[temp = high- 0x4]) high = temp;
	    // case 2: if (searchValue < list[temp = high- 0x2]) high = temp;
	    // case 1: if (searchValue < list[temp = high- 0x1]) high = temp;
	    // }
	    //
	    // return high;
	    // }
	    //
	    // // For debugging only
	    // public int len() {
	    // return len;
	    // }
	    //
	    // //----------------------------------------------------------------
	    // //----------------------------------------------------------------
	
	    /// <summary>
	    /// Returns true if this set contains every character of the given range.
	    /// </summary>
	    ///
	    /// <param name="start">first character, inclusive, of the range</param>
	    /// <param name="end">last character, inclusive, of the range</param>
	    /// <returns>true if the test condition is met</returns>
	    /// @stable ICU 2.0
	    public bool Contains(int start, int end) {
	        if (start < MIN_VALUE || start > MAX_VALUE) {
	            throw new ArgumentException("Invalid code point U+"
	                    + IBM.ICU.Impl.Utility.Hex(start, 6));
	        }
	        if (end < MIN_VALUE || end > MAX_VALUE) {
	            throw new ArgumentException("Invalid code point U+"
	                    + IBM.ICU.Impl.Utility.Hex(end, 6));
	        }
	        // int i = -1;
	        // while (true) {
	        // if (start < list[++i]) break;
	        // }
	        int i = FindCodePoint(start);
	        return ((i & 1) != 0 && end < list[i]);
	    }
	
	    /// <summary>
	    /// Returns <tt>true</tt> if this set contains the given multicharacter
	    /// string.
	    /// </summary>
	    ///
	    /// <param name="s">string to be checked for containment</param>
	    /// <returns><tt>true</tt> if this set contains the specified string</returns>
	    /// @stable ICU 2.0
	    public bool Contains(String s) {
	
	        int cp = GetSingleCP(s);
	        if (cp < 0) {
	            return ILOG.J2CsMapping.Collections.Collections.Contains(s,strings);
	        } else {
	            return Contains(cp);
	        }
	    }
	
	    /// <summary>
	    /// Returns true if this set contains all the characters and strings of the
	    /// given set.
	    /// </summary>
	    ///
	    /// <param name="b">set to be checked for containment</param>
	    /// <returns>true if the test condition is met</returns>
	    /// @stable ICU 2.0
	    public bool ContainsAll(UnicodeSet b) {
	        // The specified set is a subset if all of its pairs are contained in
	        // this set. This implementation accesses the lists directly for speed.
	        // TODO: this could be faster if size() were cached. But that would
	        // affect building speed
	        // so it needs investigation.
	        int[] listB = b.list;
	        bool needA = true;
	        bool needB = true;
	        int aPtr = 0;
	        int bPtr = 0;
	        int aLen = len - 1;
	        int bLen = b.len - 1;
	        int startA = 0, startB = 0, limitA = 0, limitB = 0;
	        while (true) {
	            // double iterations are such a pain...
	            if (needA) {
	                if (aPtr >= aLen) {
	                    // ran out of A. If B is also exhausted, then break;
	                    if (needB && bPtr >= bLen) {
	                        break;
	                    }
	                    return false;
	                }
	                startA = list[aPtr++];
	                limitA = list[aPtr++];
	            }
	            if (needB) {
	                if (bPtr >= bLen) {
	                    // ran out of B. Since we got this far, we have an A and we
	                    // are ok so far
	                    break;
	                }
	                startB = listB[bPtr++];
	                limitB = listB[bPtr++];
	            }
	            // if B doesn't overlap and is greater than A, get new A
	            if (startB >= limitA) {
	                needA = true;
	                needB = false;
	                continue;
	            }
	            // if B is wholy contained in A, then get a new B
	            if (startB >= startA && limitB <= limitA) {
	                needA = false;
	                needB = true;
	                continue;
	            }
	            // all other combinations mean we fail
	            return false;
	        }
	
	        if (!ILOG.J2CsMapping.Collections.Collections.ContainsAll(strings,b.strings))
	            return false;
	        return true;
	    }
	
	    // /**
	    // * Returns true if this set contains all the characters and strings
	    // * of the given set.
	    // * @param c set to be checked for containment
	    // * @return true if the test condition is met
	    // * @stable ICU 2.0
	    // */
	    // public boolean containsAllOld(UnicodeSet c) {
	    // // The specified set is a subset if all of its pairs are contained in
	    // // this set. It's possible to code this more efficiently in terms of
	    // // direct manipulation of the inversion lists if the need arises.
	    // int n = c.getRangeCount();
	    // for (int i=0; i<n; ++i) {
	    // if (!contains(c.getRangeStart(i), c.getRangeEnd(i))) {
	    // return false;
	    // }
	    // }
	    // if (!strings.containsAll(c.strings)) return false;
	    // return true;
	    // }
	
	    /// <summary>
	    /// Returns true if there is a partition of the string such that this set
	    /// contains each of the partitioned strings. For example, for the Unicode
	    /// set [a{bc}{cd}]<br>
	    /// containsAll is true for each of: "a", "bc", ""cdbca"<br>
	    /// containsAll is false for each of: "acb", "bcda", "bcx"<br>
	    /// </summary>
	    ///
	    /// <param name="s">string containing characters to be checked for containment</param>
	    /// <returns>true if the test condition is met</returns>
	    /// @stable ICU 2.0
	    public bool ContainsAll(String s) {
	        int cp;
	        for (int i = 0; i < s.Length; i += IBM.ICU.Text.UTF16.GetCharCount(cp)) {
	            cp = IBM.ICU.Text.UTF16.CharAt(s, i);
	            if (!Contains(cp)) {
	                if (strings.Count == 0) {
	                    return false;
	                }
	                return ContainsAll(s, 0);
	            }
	        }
	        return true;
	    }
	
	    /// <summary>
	    /// Recursive routine called if we fail to find a match in containsAll, and
	    /// there are strings
	    /// </summary>
	    ///
	    /// <param name="s">source string</param>
	    /// <param name="i">point to match to the end on</param>
	    /// <returns>true if ok</returns>
	    private bool ContainsAll(String s, int i) {
	        if (i >= s.Length) {
	            return true;
	        }
	        int cp = IBM.ICU.Text.UTF16.CharAt(s, i);
	        if (Contains(cp) && ContainsAll(s, i + IBM.ICU.Text.UTF16.GetCharCount(cp))) {
	            return true;
	        }
	
	        IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(strings.GetEnumerator());
	        while (it.HasNext()) {
	            String setStr = (String) it.Next();
	            if (ILOG.J2CsMapping.Util.StringUtil.StartsWith(s,setStr,i) && ContainsAll(s, i + setStr.Length)) {
	                return true;
	            }
	        }
	        return false;
	
	    }
	
	    /// <exclude/>
	    /// <summary>
	    /// Get the Regex equivalent for this UnicodeSet
	    /// </summary>
	    ///
	    /// <returns>regex pattern equivalent to this UnicodeSet</returns>
	    public String GetRegexEquivalent() {
	        if (strings.Count == 0)
	            return ToString();
	        StringBuilder result = new StringBuilder("(?:");
	        _generatePattern(result, true, false);
	        IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(strings.GetEnumerator());
	        while (it.HasNext()) {
	            result.Append('|');
	            _appendToPat(result, (String) it.Next(), true);
	        }
	        return result.Append(")").ToString();
	    }
	
	    /// <summary>
	    /// Returns true if this set contains none of the characters of the given
	    /// range.
	    /// </summary>
	    ///
	    /// <param name="start">first character, inclusive, of the range</param>
	    /// <param name="end">last character, inclusive, of the range</param>
	    /// <returns>true if the test condition is met</returns>
	    /// @stable ICU 2.0
	    public bool ContainsNone(int start, int end) {
	        if (start < MIN_VALUE || start > MAX_VALUE) {
	            throw new ArgumentException("Invalid code point U+"
	                    + IBM.ICU.Impl.Utility.Hex(start, 6));
	        }
	        if (end < MIN_VALUE || end > MAX_VALUE) {
	            throw new ArgumentException("Invalid code point U+"
	                    + IBM.ICU.Impl.Utility.Hex(end, 6));
	        }
	        int i = -1;
	        while (true) {
	            if (start < list[++i])
	                break;
	        }
	        return ((i & 1) == 0 && end < list[i]);
	    }
	
	    /// <summary>
	    /// Returns true if none of the characters or strings in this UnicodeSet
	    /// appears in the string. For example, for the Unicode set [a{bc}{cd}]<br>
	    /// containsNone is true for: "xy", "cb"<br>
	    /// containsNone is false for: "a", "bc", "bcd"<br>
	    /// </summary>
	    ///
	    /// <param name="b">set to be checked for containment</param>
	    /// <returns>true if the test condition is met</returns>
	    /// @stable ICU 2.0
	    public bool ContainsNone(UnicodeSet b) {
	        // The specified set is a subset if some of its pairs overlap with some
	        // of this set's pairs.
	        // This implementation accesses the lists directly for speed.
	        int[] listB = b.list;
	        bool needA = true;
	        bool needB = true;
	        int aPtr = 0;
	        int bPtr = 0;
	        int aLen = len - 1;
	        int bLen = b.len - 1;
	        int startA = 0, startB = 0, limitA = 0, limitB = 0;
	        while (true) {
	            // double iterations are such a pain...
	            if (needA) {
	                if (aPtr >= aLen) {
	                    // ran out of A: break so we test strings
	                    break;
	                }
	                startA = list[aPtr++];
	                limitA = list[aPtr++];
	            }
	            if (needB) {
	                if (bPtr >= bLen) {
	                    // ran out of B: break so we test strings
	                    break;
	                }
	                startB = listB[bPtr++];
	                limitB = listB[bPtr++];
	            }
	            // if B is higher than any part of A, get new A
	            if (startB >= limitA) {
	                needA = true;
	                needB = false;
	                continue;
	            }
	            // if A is higher than any part of B, get new B
	            if (startA >= limitB) {
	                needA = false;
	                needB = true;
	                continue;
	            }
	            // all other combinations mean we fail
	            return false;
	        }
	
	        if (!IBM.ICU.Impl.SortedSetRelation.HasRelation(strings, IBM.ICU.Impl.SortedSetRelation.DISJOINT,
	                b.strings))
	            return false;
	        return true;
	    }
	
	    // /**
	    // * Returns true if none of the characters or strings in this UnicodeSet
	    // appears in the string.
	    // * For example, for the Unicode set [a{bc}{cd}]<br>
	    // * containsNone is true for: "xy", "cb"<br>
	    // * containsNone is false for: "a", "bc", "bcd"<br>
	    // * @param c set to be checked for containment
	    // * @return true if the test condition is met
	    // * @stable ICU 2.0
	    // */
	    // public boolean containsNoneOld(UnicodeSet c) {
	    // // The specified set is a subset if all of its pairs are contained in
	    // // this set. It's possible to code this more efficiently in terms of
	    // // direct manipulation of the inversion lists if the need arises.
	    // int n = c.getRangeCount();
	    // for (int i=0; i<n; ++i) {
	    // if (!containsNone(c.getRangeStart(i), c.getRangeEnd(i))) {
	    // return false;
	    // }
	    // }
	    // if (!SortedSetRelation.hasRelation(strings, SortedSetRelation.DISJOINT,
	    // c.strings)) return false;
	    // return true;
	    // }
	
	    /// <summary>
	    /// Returns true if this set contains none of the characters of the given
	    /// string.
	    /// </summary>
	    ///
	    /// <param name="s">string containing characters to be checked for containment</param>
	    /// <returns>true if the test condition is met</returns>
	    /// @stable ICU 2.0
	    public bool ContainsNone(String s) {
	        int cp;
	        for (int i = 0; i < s.Length; i += IBM.ICU.Text.UTF16.GetCharCount(cp)) {
	            cp = IBM.ICU.Text.UTF16.CharAt(s, i);
	            if (Contains(cp))
	                return false;
	        }
	        if (strings.Count == 0)
	            return true;
	        // do a last check to make sure no strings are in.
	        for (IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(strings.GetEnumerator()); it.HasNext();) {
	            String item = (String) it.Next();
	            if (s.IndexOf(item) >= 0)
	                return false;
	        }
	        return true;
	    }
	
	    /// <summary>
	    /// Returns true if this set contains one or more of the characters in the
	    /// given range.
	    /// </summary>
	    ///
	    /// <param name="start">first character, inclusive, of the range</param>
	    /// <param name="end">last character, inclusive, of the range</param>
	    /// <returns>true if the condition is met</returns>
	    /// @stable ICU 2.0
	    public bool ContainsSome(int start, int end) {
	        return !ContainsNone(start, end);
	    }
	
	    /// <summary>
	    /// Returns true if this set contains one or more of the characters and
	    /// strings of the given set.
	    /// </summary>
	    ///
	    /// <param name="s">set to be checked for containment</param>
	    /// <returns>true if the condition is met</returns>
	    /// @stable ICU 2.0
	    public bool ContainsSome(UnicodeSet s) {
	        return !ContainsNone(s);
	    }
	
	    /// <summary>
	    /// Returns true if this set contains one or more of the characters of the
	    /// given string.
	    /// </summary>
	    ///
	    /// <param name="s">string containing characters to be checked for containment</param>
	    /// <returns>true if the condition is met</returns>
	    /// @stable ICU 2.0
	    public bool ContainsSome(String s) {
	        return !ContainsNone(s);
	    }
	
	    /// <summary>
	    /// Adds all of the elements in the specified set to this set if they're not
	    /// already present. This operation effectively modifies this set so that its
	    /// value is the <i>union</i> of the two sets. The behavior of this operation
	    /// is unspecified if the specified collection is modified while the
	    /// operation is in progress.
	    /// </summary>
	    ///
	    /// <param name="c">set whose elements are to be added to this set.</param>
	    /// @stable ICU 2.0
	    public UnicodeSet AddAll(UnicodeSet c) {
	        CheckFrozen();
	        Add(c.list, c.len, 0);
	        ILOG.J2CsMapping.Collections.Generics.Collections.AddAll(c.strings,strings);
	        return this;
	    }
	
	    /// <summary>
	    /// Retains only the elements in this set that are contained in the specified
	    /// set. In other words, removes from this set all of its elements that are
	    /// not contained in the specified set. This operation effectively modifies
	    /// this set so that its value is the <i>intersection</i> of the two sets.
	    /// </summary>
	    ///
	    /// <param name="c">set that defines which elements this set will retain.</param>
	    /// @stable ICU 2.0
	    public UnicodeSet RetainAll(UnicodeSet c) {
	        CheckFrozen();
	        Retain(c.list, c.len, 0);
	        strings.RetainAll(c.strings);
	        return this;
	    }
	
	    /// <summary>
	    /// Removes from this set all of its elements that are contained in the
	    /// specified set. This operation effectively modifies this set so that its
	    /// value is the <i>asymmetric set difference</i> of the two sets.
	    /// </summary>
	    ///
	    /// <param name="c">set that defines which elements will be removed from this set.</param>
	    /// @stable ICU 2.0
	    public UnicodeSet RemoveAll(UnicodeSet c) {
	        CheckFrozen();
	        Retain(c.list, c.len, 2);
	        strings.RemoveAll(c.strings);
	        return this;
	    }
	
	    /// <summary>
	    /// Complements in this set all elements contained in the specified set. Any
	    /// character in the other set will be removed if it is in this set, or will
	    /// be added if it is not in this set.
	    /// </summary>
	    ///
	    /// <param name="c">set that defines which elements will be complemented from thisset.</param>
	    /// @stable ICU 2.0
	    public UnicodeSet ComplementAll(UnicodeSet c) {
	        CheckFrozen();
	        Xor(c.list, c.len, 0);
	        IBM.ICU.Impl.SortedSetRelation.DoOperation(strings, IBM.ICU.Impl.SortedSetRelation.COMPLEMENTALL,
	                c.strings);
	        return this;
	    }
	
	    /// <summary>
	    /// Removes all of the elements from this set. This set will be empty after
	    /// this call returns.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public UnicodeSet Clear() {
	        CheckFrozen();
	        list[0] = HIGH;
	        len = 1;
	        pat = null;
	        ILOG.J2CsMapping.Collections.Collections.Clear(strings);
	        return this;
	    }
	
	    /// <summary>
	    /// Iteration method that returns the number of ranges contained in this set.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.UnicodeSet.GetRangeStart(System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Text.UnicodeSet.GetRangeEnd(System.Int32)"/>
	    /// @stable ICU 2.0
	    public int GetRangeCount() {
	        return len / 2;
	    }
	
	    /// <summary>
	    /// Iteration method that returns the first character in the specified range
	    /// of this set.
	    /// </summary>
	    ///
	    /// <exception cref="ArrayIndexOutOfBoundsException">if index is outside the range<c>0..getRangeCount()-1</c></exception>
	    /// <seealso cref="M:IBM.ICU.Text.UnicodeSet.GetRangeCount"/>
	    /// <seealso cref="M:IBM.ICU.Text.UnicodeSet.GetRangeEnd(System.Int32)"/>
	    /// @stable ICU 2.0
	    public int GetRangeStart(int index) {
	        return list[index * 2];
	    }
	
	    /// <summary>
	    /// Iteration method that returns the last character in the specified range
	    /// of this set.
	    /// </summary>
	    ///
	    /// <exception cref="ArrayIndexOutOfBoundsException">if index is outside the range<c>0..getRangeCount()-1</c></exception>
	    /// <seealso cref="M:IBM.ICU.Text.UnicodeSet.GetRangeStart(System.Int32)"/>
	    /// <seealso cref="M:IBM.ICU.Text.UnicodeSet.GetRangeEnd(System.Int32)"/>
	    /// @stable ICU 2.0
	    public int GetRangeEnd(int index) {
	        return (list[index * 2 + 1] - 1);
	    }
	
	    /// <summary>
	    /// Reallocate this objects internal structures to take up the least possible
	    /// space, without changing this object's value.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public UnicodeSet Compact() {
	        CheckFrozen();
	        if (len != list.Length) {
	            int[] temp = new int[len];
	            System.Array.Copy((Array)(list),0,(Array)(temp),0,len);
	            list = temp;
	        }
	        rangeList = null;
	        buffer = null;
	        return this;
	    }
	
	    /// <summary>
	    /// Compares the specified object with this set for equality. Returns
	    /// <tt>true</tt> if the specified object is also a set, the two sets have
	    /// the same size, and every member of the specified set is contained in this
	    /// set (or equivalently, every member of this set is contained in the
	    /// specified set).
	    /// </summary>
	    ///
	    /// <param name="o">Object to be compared for equality with this set.</param>
	    /// <returns><tt>true</tt> if the specified Object is equal to this set.</returns>
	    /// @stable ICU 2.0
	    public override bool Equals(Object o) {
	        try {
	            UnicodeSet that = (UnicodeSet) o;
	            if (len != that.len)
	                return false;
	            for (int i = 0; i < len; ++i) {
	                if (list[i] != that.list[i])
	                    return false;
	            }
	            if (!strings.Equals(that.strings))
	                return false;
	        } catch (Exception e) {
	            return false;
	        }
	        return true;
	    }
	
	    /// <summary>
	    /// Returns the hash code value for this set.
	    /// </summary>
	    ///
	    /// <returns>the hash code value for this set.</returns>
	    /// <seealso cref="null"/>
	    /// @stable ICU 2.0
	    public override int GetHashCode() {
	        int result = len;
	        for (int i = 0; i < len; ++i) {
	            result *= 1000003;
	            result += list[i];
	        }
	        return result;
	    }
	
	    /// <summary>
	    /// Return a programmer-readable string representation of this object.
	    /// </summary>
	    ///
	    /// @stable ICU 2.0
	    public override String ToString() {
	        return ToPattern(true);
	    }
	
	    // ----------------------------------------------------------------
	    // Implementation: Pattern parsing
	    // ----------------------------------------------------------------
	
	    /// <summary>
	    /// Parses the given pattern, starting at the given position. The character
	    /// at pattern.charAt(pos.getIndex()) must be '[', or the parse fails.
	    /// Parsing continues until the corresponding closing ']'. If a syntax error
	    /// is encountered between the opening and closing brace, the parse fails.
	    /// Upon return from a successful parse, the ParsePosition is updated to
	    /// point to the character following the closing ']', and an inversion list
	    /// for the parsed pattern is returned. This method calls itself recursively
	    /// to parse embedded subpatterns.
	    /// </summary>
	    ///
	    /// <param name="pattern">the string containing the pattern to be parsed. The portion ofthe string from pos.getIndex(), which must be a '[', to thecorresponding closing ']', is parsed.</param>
	    /// <param name="pos">upon entry, the position at which to being parsing. Thecharacter at pattern.charAt(pos.getIndex()) must be a '['.Upon return from a successful parse, pos.getIndex() is eitherthe character after the closing ']' of the parsed pattern, orpattern.length() if the closing ']' is the last character ofthe pattern string.</param>
	    /// <returns>an inversion list for the parsed substring of
	    /// <c>pattern</c></returns>
	    /// <exception cref="System.ArgumentException">if the parse fails.</exception>
	    internal UnicodeSet ApplyPattern(String pattern, ParsePosition pos,
	            SymbolTable symbols, int options) {
	
	        // Need to build the pattern in a temporary string because
	        // _applyPattern calls add() etc., which set pat to empty.
	        bool parsePositionWasNull = pos == null;
	        if (parsePositionWasNull) {
	            pos = new ParsePosition(0);
	        }
	
	        StringBuilder rebuiltPat = new StringBuilder();
	        RuleCharacterIterator chars = new RuleCharacterIterator(pattern,
	                symbols, pos);
	        ApplyPattern(chars, symbols, rebuiltPat, options);
	        if (chars.InVariable()) {
	            SyntaxError(chars, "Extra chars in variable value");
	        }
	        pat = rebuiltPat.ToString();
	        if (parsePositionWasNull) {
	            int i = pos.GetIndex();
	
	            // Skip over trailing whitespace
	            if ((options & IGNORE_SPACE) != 0) {
	                i = IBM.ICU.Impl.Utility.SkipWhitespace(pattern, i);
	            }
	
	            if (i != pattern.Length) {
	                throw new ArgumentException("Parse of \"" + pattern
	                        + "\" failed at " + i);
	            }
	        }
	        return this;
	    }
	
	    /// <summary>
	    /// Parse the pattern from the given RuleCharacterIterator. The iterator is
	    /// advanced over the parsed pattern.
	    /// </summary>
	    ///
	    /// <param name="chars">iterator over the pattern characters. Upon return it will beadvanced to the first character after the parsed pattern, orthe end of the iteration if all characters are parsed.</param>
	    /// <param name="symbols">symbol table to use to parse and dereference variables, ornull if none.</param>
	    /// <param name="rebuiltPat">the pattern that was parsed, rebuilt or copied from the inputpattern, as appropriate.</param>
	    /// <param name="options">a bit mask of zero or more of the following: IGNORE_SPACE,CASE.</param>
	    internal void ApplyPattern(RuleCharacterIterator chars, SymbolTable symbols,
	            StringBuilder rebuiltPat, int options) {
	
	        // Syntax characters: [ ] ^ - & { }
	
	        // Recognized special forms for chars, sets: c-c s-s s&s
	
	        int opts = IBM.ICU.Impl.RuleCharacterIterator.PARSE_VARIABLES
	                | IBM.ICU.Impl.RuleCharacterIterator.PARSE_ESCAPES;
	        if ((options & IGNORE_SPACE) != 0) {
	            opts |= IBM.ICU.Impl.RuleCharacterIterator.SKIP_WHITESPACE;
	        }
	
	        StringBuilder patBuf = new StringBuilder(), buf = null;
	        bool usePat = false;
	        UnicodeSet scratch = null;
	        Object backup = null;
	
	        // mode: 0=before [, 1=between [...], 2=after ]
	        // lastItem: 0=none, 1=char, 2=set
	        int lastItem = 0, lastChar = 0, mode = 0;
	        char op = (char) (0);
	
	        bool invert = false;
	
	        Clear();
	
	        while (mode != 2 && !chars.AtEnd()) {
	            if (false) {
	                // Debugging assertion
	                if (!((lastItem == 0 && op == 0)
	                        || (lastItem == 1 && (op == 0 || op == '-')) || (lastItem == 2 && (op == 0
	                        || op == '-' || op == '&')))) {
	                    throw new ArgumentException();
	                }
	            }
	
	            int c = 0;
	            bool literal = false;
	            UnicodeSet nested = null;
	
	            // -------- Check for property pattern
	
	            // setMode: 0=none, 1=unicodeset, 2=propertypat, 3=preparsed
	            int setMode = 0;
	            if (ResemblesPropertyPattern(chars, opts)) {
	                setMode = 2;
	            }
	
	            // -------- Parse '[' of opening delimiter OR nested set.
	            // If there is a nested set, use `setMode' to define how
	            // the set should be parsed. If the '[' is part of the
	            // opening delimiter for this pattern, parse special
	            // strings "[", "[^", "[-", and "[^-". Check for stand-in
	            // characters representing a nested set in the symbol
	            // table.
	
	            else {
	                // Prepare to backup if necessary
	                backup = chars.GetPos(backup);
	                c = chars.Next(opts);
	                literal = chars.IsEscaped();
	
	                if (c == '[' && !literal) {
	                    if (mode == 1) {
	                        chars.SetPos(backup); // backup
	                        setMode = 1;
	                    } else {
	                        // Handle opening '[' delimiter
	                        mode = 1;
	                        patBuf.Append('[');
	                        backup = chars.GetPos(backup); // prepare to backup
	                        c = chars.Next(opts);
	                        literal = chars.IsEscaped();
	                        if (c == '^' && !literal) {
	                            invert = true;
	                            patBuf.Append('^');
	                            backup = chars.GetPos(backup); // prepare to backup
	                            c = chars.Next(opts);
	                            literal = chars.IsEscaped();
	                        }
	                        // Fall through to handle special leading '-';
	                        // otherwise restart loop for nested [], \p{}, etc.
	                        if (c == '-') {
	                            literal = true;
	                            // Fall through to handle literal '-' below
	                        } else {
	                            chars.SetPos(backup); // backup
	                            continue;
	                        }
	                    }
	                } else if (symbols != null) {
	                    UnicodeMatcher m = symbols.LookupMatcher(c); // may be null
	                    if (m != null) {
	                        try {
	                            nested = (UnicodeSet) m;
	                            setMode = 3;
	                        } catch (InvalidCastException e) {
	                            SyntaxError(chars, "Syntax error");
	                        }
	                    }
	                }
	            }
	
	            // -------- Handle a nested set. This either is inline in
	            // the pattern or represented by a stand-in that has
	            // previously been parsed and was looked up in the symbol
	            // table.
	
	            if (setMode != 0) {
	                if (lastItem == 1) {
	                    if (op != 0) {
	                        SyntaxError(chars, "Char expected after operator");
	                    }
	                    Add_unchecked(lastChar, lastChar);
	                    _appendToPat(patBuf, lastChar, false);
	                    lastItem = op = ((Char)0);
	                }
	
	                if (op == '-' || op == '&') {
	                    patBuf.Append(op);
	                }
	
	                if (nested == null) {
	                    if (scratch == null)
	                        scratch = new UnicodeSet();
	                    nested = scratch;
	                }
	                switch (setMode) {
	                case 1:
	                    nested.ApplyPattern(chars, symbols, patBuf, options);
	                    break;
	                case 2:
	                    chars.SkipIgnored(opts);
	                    nested.ApplyPropertyPattern(chars, patBuf, symbols);
	                    break;
	                case 3: // `nested' already parsed
	                    nested._toPattern(patBuf, false);
	                    break;
	                }
	
	                usePat = true;
	
	                if (mode == 0) {
	                    // Entire pattern is a category; leave parse loop
	                    Set(nested);
	                    mode = 2;
	                    break;
	                }
	
	                switch ((int) op) {
	                case '-':
	                    RemoveAll(nested);
	                    break;
	                case '&':
	                    RetainAll(nested);
	                    break;
	                case 0:
	                    AddAll(nested);
	                    break;
	                }
	
	                op = ((Char)0);
	                lastItem = 2;
	
	                continue;
	            }
	
	            if (mode == 0) {
	                SyntaxError(chars, "Missing '['");
	            }
	
	            // -------- Parse special (syntax) characters. If the
	            // current character is not special, or if it is escaped,
	            // then fall through and handle it below.
	
	            if (!literal) {
	                switch (c) {
	                case ']':
	                    if (lastItem == 1) {
	                        Add_unchecked(lastChar, lastChar);
	                        _appendToPat(patBuf, lastChar, false);
	                    }
	                    // Treat final trailing '-' as a literal
	                    if (op == '-') {
	                        Add_unchecked(op, op);
	                        patBuf.Append(op);
	                    } else if (op == '&') {
	                        SyntaxError(chars, "Trailing '&'");
	                    }
	                    patBuf.Append(']');
	                    mode = 2;
	                    continue;
	                case '-':
	                    if (op == 0) {
	                        if (lastItem != 0) {
	                            op = (char) c;
	                            continue;
	                        } else {
	                            // Treat final trailing '-' as a literal
	                            Add_unchecked(c, c);
	                            c = chars.Next(opts);
	                            literal = chars.IsEscaped();
	                            if (c == ']' && !literal) {
	                                patBuf.Append("-]");
	                                mode = 2;
	                                continue;
	                            }
	                        }
	                    }
	                    SyntaxError(chars, "'-' not after char or set");
	                    {
	                        if (lastItem == 2 && op == 0) {
	                            op = (char) c;
	                            continue;
	                        }
	                        SyntaxError(chars, "'&' not after set");
	                        SyntaxError(chars, "'^' not after '['");
	                        if (op != 0) {
	                            SyntaxError(chars, "Missing operand after operator");
	                        }
	                        if (lastItem == 1) {
	                            Add_unchecked(lastChar, lastChar);
	                            _appendToPat(patBuf, lastChar, false);
	                        }
	                        lastItem = 0;
	                        if (buf == null) {
	                            buf = new StringBuilder();
	                        } else {
	                            buf.Length=0;
	                        }
	                        bool ok = false;
	                        while (!chars.AtEnd()) {
	                            c = chars.Next(opts);
	                            literal = chars.IsEscaped();
	                            if (c == '}' && !literal) {
	                                ok = true;
	                                break;
	                            }
	                            IBM.ICU.Text.UTF16.Append(buf, c);
	                        }
	                        if (buf.Length < 1 || !ok) {
	                            SyntaxError(chars, "Invalid multicharacter string");
	                        }
	                        Add(buf.ToString());
	                        patBuf.Append('{');
	                        _appendToPat(patBuf, buf.ToString(), false);
	                        patBuf.Append('}');
	                        continue;
	                    }
	                break;
	                case '&':
	                    if (lastItem == 2 && op == 0) {
	                        op = (char) c;
	                        continue;
	                    }
	                    SyntaxError(chars, "'&' not after set");
	                    {
	                        SyntaxError(chars, "'^' not after '['");
	                        if (op != 0) {
	                            SyntaxError(chars, "Missing operand after operator");
	                        }
	                        if (lastItem == 1) {
	                            Add_unchecked(lastChar, lastChar);
	                            _appendToPat(patBuf, lastChar, false);
	                        }
	                        lastItem = 0;
	                        if (buf == null) {
	                            buf = new StringBuilder();
	                        } else {
	                            buf.Length=0;
	                        }
	                        bool ok_0 = false;
	                        while (!chars.AtEnd()) {
	                            c = chars.Next(opts);
	                            literal = chars.IsEscaped();
	                            if (c == '}' && !literal) {
	                                ok_0 = true;
	                                break;
	                            }
	                            IBM.ICU.Text.UTF16.Append(buf, c);
	                        }
	                        if (buf.Length < 1 || !ok_0) {
	                            SyntaxError(chars, "Invalid multicharacter string");
	                        }
	                        Add(buf.ToString());
	                        patBuf.Append('{');
	                        _appendToPat(patBuf, buf.ToString(), false);
	                        patBuf.Append('}');
	                        continue;
	                    }
	                break;
	                case '^':
	                    SyntaxError(chars, "'^' not after '['");
	                    {
	                        if (op != 0) {
	                            SyntaxError(chars, "Missing operand after operator");
	                        }
	                        if (lastItem == 1) {
	                            Add_unchecked(lastChar, lastChar);
	                            _appendToPat(patBuf, lastChar, false);
	                        }
	                        lastItem = 0;
	                        if (buf == null) {
	                            buf = new StringBuilder();
	                        } else {
	                            buf.Length=0;
	                        }
	                        bool ok_1 = false;
	                        while (!chars.AtEnd()) {
	                            c = chars.Next(opts);
	                            literal = chars.IsEscaped();
	                            if (c == '}' && !literal) {
	                                ok_1 = true;
	                                break;
	                            }
	                            IBM.ICU.Text.UTF16.Append(buf, c);
	                        }
	                        if (buf.Length < 1 || !ok_1) {
	                            SyntaxError(chars, "Invalid multicharacter string");
	                        }
	                        Add(buf.ToString());
	                        patBuf.Append('{');
	                        _appendToPat(patBuf, buf.ToString(), false);
	                        patBuf.Append('}');
	                        continue;
	                    }
	                break;
	                case '{':
	                    if (op != 0) {
	                        SyntaxError(chars, "Missing operand after operator");
	                    }
	                    if (lastItem == 1) {
	                        Add_unchecked(lastChar, lastChar);
	                        _appendToPat(patBuf, lastChar, false);
	                    }
	                    lastItem = 0;
	                    if (buf == null) {
	                        buf = new StringBuilder();
	                    } else {
	                        buf.Length=0;
	                    }
	                    bool ok_2 = false;
	                    while (!chars.AtEnd()) {
	                        c = chars.Next(opts);
	                        literal = chars.IsEscaped();
	                        if (c == '}' && !literal) {
	                            ok_2 = true;
	                            break;
	                        }
	                        IBM.ICU.Text.UTF16.Append(buf, c);
	                    }
	                    if (buf.Length < 1 || !ok_2) {
	                        SyntaxError(chars, "Invalid multicharacter string");
	                    }
	                    // We have new string. Add it to set and continue;
	                    // we don't need to drop through to the further
	                    // processing
	                    Add(buf.ToString());
	                    patBuf.Append('{');
	                    _appendToPat(patBuf, buf.ToString(), false);
	                    patBuf.Append('}');
	                    continue;
	                case IBM.ICU.Text.SymbolTable_Constants.SYMBOL_REF:
	                    // symbols nosymbols
	                    // [a-$] error error (ambiguous)
	                    // [a$] anchor anchor
	                    // [a-$x] var "x"* literal '$'
	                    // [a-$.] error literal '$'
	                    // *We won't get here in the case of var "x"
	                    backup = chars.GetPos(backup);
	                    c = chars.Next(opts);
	                    literal = chars.IsEscaped();
	                    bool anchor = (c == ']' && !literal);
	                    if (symbols == null && !anchor) {
	                        c = IBM.ICU.Text.SymbolTable_Constants.SYMBOL_REF;
	                        chars.SetPos(backup);
	                        break; // literal '$'
	                    }
	                    if (anchor && op == 0) {
	                        if (lastItem == 1) {
	                            Add_unchecked(lastChar, lastChar);
	                            _appendToPat(patBuf, lastChar, false);
	                        }
	                        Add_unchecked(IBM.ICU.Text.UnicodeMatcher_Constants.ETHER);
	                        usePat = true;
	                        patBuf.Append(IBM.ICU.Text.SymbolTable_Constants.SYMBOL_REF).Append(']');
	                        mode = 2;
	                        continue;
	                    }
	                    SyntaxError(chars, "Unquoted '$'");
	                    break;
	                break;
	                default:
	                    break;
	                }
	            }
	
	            // -------- Parse literal characters. This includes both
	            // escaped chars ("\u4E01") and non-syntax characters
	            // ("a").
	
	            switch (lastItem) {
	            case 0:
	                lastItem = 1;
	                lastChar = c;
	                break;
	            case 1:
	                if (op == '-') {
	                    if (lastChar >= c) {
	                        // Don't allow redundant (a-a) or empty (b-a) ranges;
	                        // these are most likely typos.
	                        SyntaxError(chars, "Invalid range");
	                    }
	                    Add_unchecked(lastChar, c);
	                    _appendToPat(patBuf, lastChar, false);
	                    patBuf.Append(op);
	                    _appendToPat(patBuf, c, false);
	                    lastItem = op = ((Char)0);
	                } else {
	                    Add_unchecked(lastChar, lastChar);
	                    _appendToPat(patBuf, lastChar, false);
	                    lastChar = c;
	                }
	                break;
	            case 2:
	                if (op != 0) {
	                    SyntaxError(chars, "Set expected after operator");
	                }
	                lastChar = c;
	                lastItem = 1;
	                break;
	            }
	        }
	
	        if (mode != 2) {
	            SyntaxError(chars, "Missing ']'");
	        }
	
	        chars.SkipIgnored(opts);
	
	        /**
	         * Handle global flags (invert, case insensitivity). If this pattern
	         * should be compiled case-insensitive, then we need to close over case
	         * BEFORE COMPLEMENTING. This makes patterns like /[^abc]/i work.
	         */
	        if ((options & CASE) != 0) {
	            CloseOver(CASE);
	        }
	        if (invert) {
	            Complement();
	        }
	
	        // Use the rebuilt pattern (pat) only if necessary. Prefer the
	        // generated pattern.
	        if (usePat) {
	            rebuiltPat.Append(patBuf.ToString());
	        } else {
	            _generatePattern(rebuiltPat, false, true);
	        }
	    }
	
	    private static void SyntaxError(RuleCharacterIterator chars, String msg) {
	        throw new ArgumentException("Error: " + msg + " at \""
	                + IBM.ICU.Impl.Utility.Escape(chars.ToString()) + '"');
	    }
	
	    /// <summary>
	    /// Add the contents of the UnicodeSet (as strings) into a collection.
	    /// </summary>
	    ///
	    /// <param name="target">collection to add into</param>
	    /// @stable ICU 2.8
	    public void AddAllTo(ICollection target) {
	        UnicodeSetIterator it = new UnicodeSetIterator(this);
	        while (it.Next()) {
	            ILOG.J2CsMapping.Collections.Collections.Add(target,it.GetString());
	        }
	    }
	
	    /// <summary>
	    /// Add the contents of the collection (as strings) into this UnicodeSet.
	    /// </summary>
	    ///
	    /// <param name="source">the collection to add</param>
	    /// @stable ICU 2.8
	    public void AddAll(ICollection source) {
	        CheckFrozen();
	        IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(source.GetEnumerator());
	        while (it.HasNext()) {
	            Add(it.Next().ToString());
	        }
	    }
	
	    // ----------------------------------------------------------------
	    // Implementation: Utility methods
	    // ----------------------------------------------------------------
	
	    private void EnsureCapacity(int newLen) {
	        if (newLen <= list.Length)
	            return;
	        int[] temp = new int[newLen + GROW_EXTRA];
	        System.Array.Copy((Array)(list),0,(Array)(temp),0,len);
	        list = temp;
	    }
	
	    private void EnsureBufferCapacity(int newLen) {
	        if (buffer != null && newLen <= buffer.Length)
	            return;
	        buffer = new int[newLen + GROW_EXTRA];
	    }
	
	    /// <summary>
	    /// Assumes start <= end.
	    /// </summary>
	    ///
	    private int[] Range(int start, int end) {
	        if (rangeList == null) {
	            rangeList = new int[] { start, end + 1, HIGH };
	        } else {
	            rangeList[0] = start;
	            rangeList[1] = end + 1;
	        }
	        return rangeList;
	    }
	
	    // ----------------------------------------------------------------
	    // Implementation: Fundamental operations
	    // ----------------------------------------------------------------
	
	    // polarity = 0, 3 is normal: x xor y
	    // polarity = 1, 2: x xor ~y == x === y
	
	    private UnicodeSet Xor(int[] other, int otherLen, int polarity) {
	        EnsureBufferCapacity(len + otherLen);
	        int i = 0, j = 0, k = 0;
	        int a = list[i++];
	        int b;
	        if (polarity == 1 || polarity == 2) {
	            b = LOW;
	            if (other[j] == LOW) { // skip base if already LOW
	                ++j;
	                b = other[j];
	            }
	        } else {
	            b = other[j++];
	        }
	        // simplest of all the routines
	        // sort the values, discarding identicals!
	        while (true) {
	            if (a < b) {
	                buffer[k++] = a;
	                a = list[i++];
	            } else if (b < a) {
	                buffer[k++] = b;
	                b = other[j++];
	            } else if (a != HIGH) { // at this point, a == b
	                // discard both values!
	                a = list[i++];
	                b = other[j++];
	            } else { // DONE!
	                buffer[k++] = HIGH;
	                len = k;
	                break;
	            }
	        }
	        // swap list and buffer
	        int[] temp = list;
	        list = buffer;
	        buffer = temp;
	        pat = null;
	        return this;
	    }
	
	    // polarity = 0 is normal: x union y
	    // polarity = 2: x union ~y
	    // polarity = 1: ~x union y
	    // polarity = 3: ~x union ~y
	
	    private UnicodeSet Add(int[] other, int otherLen, int polarity) {
	        EnsureBufferCapacity(len + otherLen);
	        int i = 0, j = 0, k = 0;
	        int a = list[i++];
	        int b = other[j++];
	        // change from xor is that we have to check overlapping pairs
	        // polarity bit 1 means a is second, bit 2 means b is.
	        main: {
	            while (true) {
	                switch (polarity) {
	                case 0: // both first; take lower if unequal
	                    if (a < b) { // take a
	                        // Back up over overlapping ranges in buffer[]
	                        if (k > 0 && a <= buffer[k - 1]) {
	                            // Pick latter end value in buffer[] vs. list[]
	                            a = Max(list[i], buffer[--k]);
	                        } else {
	                            // No overlap
	                            buffer[k++] = a;
	                            a = list[i];
	                        }
	                        i++; // Common if/else code factored out
	                        polarity ^= 1;
	                    } else if (b < a) { // take b
	                        if (k > 0 && b <= buffer[k - 1]) {
	                            b = Max(other[j], buffer[--k]);
	                        } else {
	                            buffer[k++] = b;
	                            b = other[j];
	                        }
	                        j++;
	                        polarity ^= 2;
	                    } else { // a == b, take a, drop b
	                        if (a == HIGH)
	                            goto gotomain;
	                        // This is symmetrical; it doesn't matter if
	                        // we backtrack with a or b. - liu
	                        if (k > 0 && a <= buffer[k - 1]) {
	                            a = Max(list[i], buffer[--k]);
	                        } else {
	                            // No overlap
	                            buffer[k++] = a;
	                            a = list[i];
	                        }
	                        i++;
	                        polarity ^= 1;
	                        b = other[j++];
	                        polarity ^= 2;
	                    }
	                    break;
	                case 3: // both second; take higher if unequal, and drop other
	                    if (b <= a) { // take a
	                        if (a == HIGH)
	                            goto gotomain;
	                        buffer[k++] = a;
	                    } else { // take b
	                        if (b == HIGH)
	                            goto gotomain;
	                        buffer[k++] = b;
	                    }
	                    a = list[i++];
	                    polarity ^= 1; // factored common code
	                    b = other[j++];
	                    polarity ^= 2;
	                    break;
	                case 1: // a second, b first; if b < a, overlap
	                    if (a < b) { // no overlap, take a
	                        buffer[k++] = a;
	                        a = list[i++];
	                        polarity ^= 1;
	                    } else if (b < a) { // OVERLAP, drop b
	                        b = other[j++];
	                        polarity ^= 2;
	                    } else { // a == b, drop both!
	                        if (a == HIGH)
	                            goto gotomain;
	                        a = list[i++];
	                        polarity ^= 1;
	                        b = other[j++];
	                        polarity ^= 2;
	                    }
	                    break;
	                case 2: // a first, b second; if a < b, overlap
	                    if (b < a) { // no overlap, take b
	                        buffer[k++] = b;
	                        b = other[j++];
	                        polarity ^= 2;
	                    } else if (a < b) { // OVERLAP, drop a
	                        a = list[i++];
	                        polarity ^= 1;
	                    } else { // a == b, drop both!
	                        if (a == HIGH)
	                            goto gotomain;
	                        a = list[i++];
	                        polarity ^= 1;
	                        b = other[j++];
	                        polarity ^= 2;
	                    }
	                    break;
	                }
	            }
	        }
	        gotomain:
	        ;
	        buffer[k++] = HIGH; // terminate
	        len = k;
	        // swap list and buffer
	        int[] temp = list;
	        list = buffer;
	        buffer = temp;
	        pat = null;
	        return this;
	    }
	
	    // polarity = 0 is normal: x intersect y
	    // polarity = 2: x intersect ~y == set-minus
	    // polarity = 1: ~x intersect y
	    // polarity = 3: ~x intersect ~y
	
	    private UnicodeSet Retain(int[] other, int otherLen, int polarity) {
	        EnsureBufferCapacity(len + otherLen);
	        int i = 0, j = 0, k = 0;
	        int a = list[i++];
	        int b = other[j++];
	        // change from xor is that we have to check overlapping pairs
	        // polarity bit 1 means a is second, bit 2 means b is.
	        main: {
	            while (true) {
	                switch (polarity) {
	                case 0: // both first; drop the smaller
	                    if (a < b) { // drop a
	                        a = list[i++];
	                        polarity ^= 1;
	                    } else if (b < a) { // drop b
	                        b = other[j++];
	                        polarity ^= 2;
	                    } else { // a == b, take one, drop other
	                        if (a == HIGH)
	                            goto gotomain;
	                        buffer[k++] = a;
	                        a = list[i++];
	                        polarity ^= 1;
	                        b = other[j++];
	                        polarity ^= 2;
	                    }
	                    break;
	                case 3: // both second; take lower if unequal
	                    if (a < b) { // take a
	                        buffer[k++] = a;
	                        a = list[i++];
	                        polarity ^= 1;
	                    } else if (b < a) { // take b
	                        buffer[k++] = b;
	                        b = other[j++];
	                        polarity ^= 2;
	                    } else { // a == b, take one, drop other
	                        if (a == HIGH)
	                            goto gotomain;
	                        buffer[k++] = a;
	                        a = list[i++];
	                        polarity ^= 1;
	                        b = other[j++];
	                        polarity ^= 2;
	                    }
	                    break;
	                case 1: // a second, b first;
	                    if (a < b) { // NO OVERLAP, drop a
	                        a = list[i++];
	                        polarity ^= 1;
	                    } else if (b < a) { // OVERLAP, take b
	                        buffer[k++] = b;
	                        b = other[j++];
	                        polarity ^= 2;
	                    } else { // a == b, drop both!
	                        if (a == HIGH)
	                            goto gotomain;
	                        a = list[i++];
	                        polarity ^= 1;
	                        b = other[j++];
	                        polarity ^= 2;
	                    }
	                    break;
	                case 2: // a first, b second; if a < b, overlap
	                    if (b < a) { // no overlap, drop b
	                        b = other[j++];
	                        polarity ^= 2;
	                    } else if (a < b) { // OVERLAP, take a
	                        buffer[k++] = a;
	                        a = list[i++];
	                        polarity ^= 1;
	                    } else { // a == b, drop both!
	                        if (a == HIGH)
	                            goto gotomain;
	                        a = list[i++];
	                        polarity ^= 1;
	                        b = other[j++];
	                        polarity ^= 2;
	                    }
	                    break;
	                }
	            }
	        }
	        gotomain:
	        ;
	        buffer[k++] = HIGH; // terminate
	        len = k;
	        // swap list and buffer
	        int[] temp = list;
	        list = buffer;
	        buffer = temp;
	        pat = null;
	        return this;
	    }
	
	    private static int Max(int a, int b) {
	        return (a > b) ? a : b;
	    }
	
	    // ----------------------------------------------------------------
	    // Generic filter-based scanning code
	    // ----------------------------------------------------------------
	
	    private interface Filter {
	        bool Contains(int codePoint);
	    }
	
	    private class NumericValueFilter : UnicodeSet.Filter  {
	        internal double value_ren;
	
	        internal NumericValueFilter(double value_ren) {
	            this.value_ren = value_ren;
	        }
	
	        public virtual bool Contains(int ch) {
	            return IBM.ICU.Lang.UCharacter.GetUnicodeNumericValue(ch) == value_ren;
	        }
	    }
	
	    private class GeneralCategoryMaskFilter : UnicodeSet.Filter  {
	        internal int mask;
	
	        internal GeneralCategoryMaskFilter(int mask_0) {
	            this.mask = mask_0;
	        }
	
	        public virtual bool Contains(int ch) {
	            return ((1 << IBM.ICU.Lang.UCharacter.GetType(ch)) & mask) != 0;
	        }
	    }
	
	    private class IntPropertyFilter : UnicodeSet.Filter  {
	        internal int prop;
	
	        internal int value_ren;
	
	        internal IntPropertyFilter(int prop_0, int value_ren) {
	            this.prop = prop_0;
	            this.value_ren = value_ren;
	        }
	
	        public virtual bool Contains(int ch) {
	            return IBM.ICU.Lang.UCharacter.GetIntPropertyValue(ch, prop) == value_ren;
	        }
	    }
	
	    // VersionInfo for unassigned characters
	    static internal readonly VersionInfo NO_VERSION = IBM.ICU.Util.VersionInfo.GetInstance(0, 0, 0, 0);
	
	    private class VersionFilter : UnicodeSet.Filter  {
	        internal VersionInfo version;
	
	        internal VersionFilter(VersionInfo version_0) {
	            this.version = version_0;
	        }
	
	        public virtual bool Contains(int ch) {
	            VersionInfo v = IBM.ICU.Lang.UCharacter.GetAge(ch);
	            // Reference comparison ok; VersionInfo caches and reuses
	            // unique objects.
	            return v != IBM.ICU.Text.UnicodeSet.NO_VERSION && v.CompareTo(version) <= 0;
	        }
	    }
	
	    [MethodImpl(MethodImplOptions.Synchronized)]
	    private static UnicodeSet GetInclusions(int src) {
	        if (INCLUSIONS == null) {
	            INCLUSIONS = new UnicodeSet[IBM.ICU.Impl.UCharacterProperty.SRC_COUNT];
	        }
	        if (INCLUSIONS[src] == null) {
	            UnicodeSet incl = new UnicodeSet();
	            switch (src) {
	            case IBM.ICU.Impl.UCharacterProperty.SRC_CHAR:
	                IBM.ICU.Impl.UCharacterProperty.GetInstance().AddPropertyStarts(incl);
	                break;
	            case IBM.ICU.Impl.UCharacterProperty.SRC_PROPSVEC:
	                IBM.ICU.Impl.UCharacterProperty.GetInstance().Upropsvec_addPropertyStarts(
	                        incl);
	                break;
	            case IBM.ICU.Impl.UCharacterProperty.SRC_CHAR_AND_PROPSVEC:
	                IBM.ICU.Impl.UCharacterProperty.GetInstance().AddPropertyStarts(incl);
	                IBM.ICU.Impl.UCharacterProperty.GetInstance().Upropsvec_addPropertyStarts(
	                        incl);
	                break;
	            case IBM.ICU.Impl.UCharacterProperty.SRC_HST:
	                IBM.ICU.Impl.UCharacterProperty.GetInstance().Uhst_addPropertyStarts(incl);
	                break;
	            case IBM.ICU.Impl.UCharacterProperty.SRC_NORM:
	                IBM.ICU.Impl.NormalizerImpl.AddPropertyStarts(incl);
	                break;
	            case IBM.ICU.Impl.UCharacterProperty.SRC_CASE:
	                try {
	                    IBM.ICU.Impl.UCaseProps.GetSingleton().AddPropertyStarts(incl);
	                } catch (IOException e) {
	                    throw new MissingManifestResourceException(e.Message);
	                }
	                break;
	            case IBM.ICU.Impl.UCharacterProperty.SRC_BIDI:
	                try {
	                    IBM.ICU.Impl.UBiDiProps.GetSingleton().AddPropertyStarts(incl);
	                } catch (IOException e_0) {
	                    throw new MissingManifestResourceException(e_0.Message);
	                }
	                break;
	            default:
	                throw new InvalidOperationException(
	                        "UnicodeSet.getInclusions(unknown src " + src + ")");
	            }
	            INCLUSIONS[src] = incl;
	        }
	        return INCLUSIONS[src];
	    }
	
	    /// <summary>
	    /// Generic filter-based scanning code for UCD property UnicodeSets.
	    /// </summary>
	    ///
	    private UnicodeSet ApplyFilter(UnicodeSet.Filter  filter, int src) {
	        // Walk through all Unicode characters, noting the start
	        // and end of each range for which filter.contain(c) is
	        // true. Add each range to a set.
	        //
	        // To improve performance, use the INCLUSIONS set, which
	        // encodes information about character ranges that are known
	        // to have identical properties, such as the CJK Ideographs
	        // from U+4E00 to U+9FA5. INCLUSIONS contains all characters
	        // except the first characters of such ranges.
	        //
	        // TODO Where possible, instead of scanning over code points,
	        // use internal property data to initialize UnicodeSets for
	        // those properties. Scanning code points is slow.
	
	        Clear();
	
	        int startHasProperty = -1;
	        UnicodeSet inclusions = GetInclusions(src);
	        int limitRange = inclusions.GetRangeCount();
	
	        for (int j = 0; j < limitRange; ++j) {
	            // get current range
	            int start = inclusions.GetRangeStart(j);
	            int end = inclusions.GetRangeEnd(j);
	
	            // for all the code points in the range, process
	            for (int ch = start; ch <= end; ++ch) {
	                // only add to the unicodeset on inflection points --
	                // where the hasProperty value changes to false
	                if (filter.Contains(ch)) {
	                    if (startHasProperty < 0) {
	                        startHasProperty = ch;
	                    }
	                } else if (startHasProperty >= 0) {
	                    Add_unchecked(startHasProperty, ch - 1);
	                    startHasProperty = -1;
	                }
	            }
	        }
	        if (startHasProperty >= 0) {
	            Add_unchecked(startHasProperty, 0x10FFFF);
	        }
	
	        return this;
	    }
	
	    /// <summary>
	    /// Remove leading and trailing rule white space and compress internal rule
	    /// white space to a single space character.
	    /// </summary>
	    ///
	    /// <seealso cref="null"/>
	    private static String MungeCharName(String source) {
	        StringBuilder buf = new StringBuilder();
	        for (int i = 0; i < source.Length;) {
	            int ch = IBM.ICU.Text.UTF16.CharAt(source, i);
	            i += IBM.ICU.Text.UTF16.GetCharCount(ch);
	            if (IBM.ICU.Impl.UCharacterProperty.IsRuleWhiteSpace(ch)) {
	                if (buf.Length == 0 || buf[buf.Length - 1] == ' ') {
	                    continue;
	                }
	                ch = ' '; // convert to ' '
	            }
	            IBM.ICU.Text.UTF16.Append(buf, ch);
	        }
	        if (buf.Length != 0 && buf[buf.Length - 1] == ' ') {
	            buf.Length=buf.Length - 1;
	        }
	        return buf.ToString();
	    }
	
	    // ----------------------------------------------------------------
	    // Property set API
	    // ----------------------------------------------------------------
	
	    /// <summary>
	    /// Modifies this set to contain those code points which have the given value
	    /// for the given binary or enumerated property, as returned by
	    /// UCharacter.getIntPropertyValue. Prior contents of this set are lost.
	    /// </summary>
	    ///
	    /// <param name="prop_0">a property in the rangeUProperty.BIN_START..UProperty.BIN_LIMIT-1 orUProperty.INT_START..UProperty.INT_LIMIT-1 or.UProperty.MASK_START..UProperty.MASK_LIMIT-1.</param>
	    /// <param name="value">a value in the range UCharacter.getIntPropertyMinValue(prop)..UCharacter.getIntPropertyMaxValue(prop), with one exception.If prop is UProperty.GENERAL_CATEGORY_MASK, then value shouldnot be a UCharacter.getType() result, but rather a mask valueproduced by logically ORing (1 << UCharacter.getType()) valuestogether. This allows grouped categories such as [:L:] to berepresented.</param>
	    /// <returns>a reference to this set</returns>
	    /// @stable ICU 2.4
	    public UnicodeSet ApplyIntPropertyValue(int prop_0, int value_ren) {
	        CheckFrozen();
	        if (prop_0 == IBM.ICU.Lang.UProperty_Constants.GENERAL_CATEGORY_MASK) {
	            ApplyFilter(new UnicodeSet.GeneralCategoryMaskFilter (value_ren),
	                    IBM.ICU.Impl.UCharacterProperty.SRC_CHAR);
	        } else {
	            ApplyFilter(new UnicodeSet.IntPropertyFilter (prop_0, value_ren), IBM.ICU.Impl.UCharacterProperty
	                    .GetInstance().GetSource(prop_0));
	        }
	        return this;
	    }
	
	    /// <summary>
	    /// Modifies this set to contain those code points which have the given value
	    /// for the given property. Prior contents of this set are lost.
	    /// </summary>
	    ///
	    /// <param name="propertyAlias">a property alias, either short or long. The name is matchedloosely. See PropertyAliases.txt for names and a descriptionof loose matching. If the value string is empty, then thisstring is interpreted as either a General_Category valuealias, a Script value alias, a binary property alias, or aspecial ID. Special IDs are matched loosely and correspond tothe following sets:"ANY" = [\u0000-\U0010FFFF], "ASCII" = [\u0000-\u007F].</param>
	    /// <param name="valueAlias">a value alias, either short or long. The name is matchedloosely. See PropertyValueAliases.txt for names and adescription of loose matching. In addition to aliases listed,numeric values and canonical combining classes may beexpressed numerically, e.g., ("nv", "0.5") or ("ccc", "220").The value string may also be empty.</param>
	    /// <returns>a reference to this set</returns>
	    /// @stable ICU 2.4
	    public UnicodeSet ApplyPropertyAlias(String propertyAlias, String valueAlias) {
	        return ApplyPropertyAlias(propertyAlias, valueAlias, null);
	    }
	
	    /// <summary>
	    /// Modifies this set to contain those code points which have the given value
	    /// for the given property. Prior contents of this set are lost.
	    /// </summary>
	    ///
	    /// <param name="propertyAlias"></param>
	    /// <param name="valueAlias"></param>
	    /// <param name="symbols">if not null, then symbols are first called to see if aproperty is available. If true, then everything else isskipped.</param>
	    /// <returns>this set</returns>
	    /// @stable ICU 3.2
	    public UnicodeSet ApplyPropertyAlias(String propertyAlias,
	            String valueAlias, SymbolTable symbols) {
	        CheckFrozen();
	        int p;
	        int v;
	        bool mustNotBeEmpty = false, invert = false;
	
	        if (symbols != null
	                && (symbols  is  UnicodeSet.XSymbolTable )
	                && ((UnicodeSet.XSymbolTable ) symbols).ApplyPropertyAlias(propertyAlias,
	                        valueAlias, this)) {
	            return this;
	        }
	
	        if (valueAlias.Length > 0) {
	            p = IBM.ICU.Lang.UCharacter.GetPropertyEnum(propertyAlias);
	
	            // Treat gc as gcm
	            if (p == IBM.ICU.Lang.UProperty_Constants.GENERAL_CATEGORY) {
                    p = IBM.ICU.Lang.UProperty_Constants.GENERAL_CATEGORY_MASK;
	            }

                if ((p >= IBM.ICU.Lang.UProperty_Constants.BINARY_START && p < IBM.ICU.Lang.UProperty_Constants.BINARY_LIMIT)
                        || (p >= IBM.ICU.Lang.UProperty_Constants.INT_START && p < IBM.ICU.Lang.UProperty_Constants.INT_LIMIT)
                        || (p >= IBM.ICU.Lang.UProperty_Constants.MASK_START && p < IBM.ICU.Lang.UProperty_Constants.MASK_LIMIT))
                {
	                try {
	                    v = IBM.ICU.Lang.UCharacter.GetPropertyValueEnum(p, valueAlias);
	                } catch (ArgumentException e) {
	                    // Handle numeric CCC
                        if (p == IBM.ICU.Lang.UProperty_Constants.CANONICAL_COMBINING_CLASS
                                || p == IBM.ICU.Lang.UProperty_Constants.LEAD_CANONICAL_COMBINING_CLASS
                                || p == IBM.ICU.Lang.UProperty_Constants.TRAIL_CANONICAL_COMBINING_CLASS)
                        {
	                        v = Int32.Parse(IBM.ICU.Impl.Utility
	                                                        .DeleteRuleWhiteSpace(valueAlias));
	                        // If the resultant set is empty then the numeric value
	                        // was invalid.
	                        // mustNotBeEmpty = true;
	                        // old code was wrong; anything between 0 and 255 is
	                        // valid even if unused.
	                        if (v < 0 || v > 255)
	                            throw e;
	                    } else {
	                        throw e;
	                    }
	                }
	            }
	
	            else {
	
	                switch (p) {
                        case IBM.ICU.Lang.UProperty_Constants.NUMERIC_VALUE:
                            {
	                    double value_ren = ((Double )Double.Parse(IBM.ICU.Impl.Utility
	                                                .DeleteRuleWhiteSpace(valueAlias),ILOG.J2CsMapping.Util.NumberFormatProvider.NumberFormat));
	                    ApplyFilter(new UnicodeSet.NumericValueFilter (value_ren),
	                            IBM.ICU.Impl.UCharacterProperty.SRC_CHAR);
	                    return this;
	                }
                        case IBM.ICU.Lang.UProperty_Constants.NAME:
                        case IBM.ICU.Lang.UProperty_Constants.UNICODE_1_NAME:
                            {
	                    // Must munge name, since
	                    // UCharacter.charFromName() does not do
	                    // 'loose' matching.
	                    String buf = MungeCharName(valueAlias);
                        int ch = (p == IBM.ICU.Lang.UProperty_Constants.NAME) ? IBM.ICU.Lang.UCharacter
	                            .GetCharFromExtendedName(buf) : IBM.ICU.Lang.UCharacter
	                            .GetCharFromName1_0(buf);
	                    if (ch == -1) {
	                        throw new ArgumentException(
	                                "Invalid character name");
	                    }
	                    Clear();
	                    Add_unchecked(ch);
	                    return this;
	                }
                        case IBM.ICU.Lang.UProperty_Constants.AGE:
                            {
	                    // Must munge name, since
	                    // VersionInfo.getInstance() does not do
	                    // 'loose' matching.
	                    VersionInfo version_0 = IBM.ICU.Util.VersionInfo
	                            .GetInstance(MungeCharName(valueAlias));
	                    ApplyFilter(new UnicodeSet.VersionFilter (version_0),
	                            IBM.ICU.Impl.UCharacterProperty.SRC_PROPSVEC);
	                    return this;
	                }
	                }
	
	                // p is a non-binary, non-enumerated property that we
	                // don't support (yet).
	                throw new ArgumentException("Unsupported property");
	            }
	        }
	
	        else {
	            // valueAlias is empty. Interpret as General Category, Script,
	            // Binary property, or ANY or ASCII. Upon success, p and v will
	            // be set.
	            try {
                    p = IBM.ICU.Lang.UProperty_Constants.GENERAL_CATEGORY_MASK;
	                v = IBM.ICU.Lang.UCharacter.GetPropertyValueEnum(p, propertyAlias);
	            } catch (ArgumentException e_1) {
	                try {
                        p = IBM.ICU.Lang.UProperty_Constants.SCRIPT;
	                    v = IBM.ICU.Lang.UCharacter.GetPropertyValueEnum(p, propertyAlias);
	                } catch (ArgumentException e2) {
	                    try {
	                        p = IBM.ICU.Lang.UCharacter.GetPropertyEnum(propertyAlias);
	                    } catch (ArgumentException e3) {
	                        p = -1;
	                    }
                        if (p >= IBM.ICU.Lang.UProperty_Constants.BINARY_START
                                && p < IBM.ICU.Lang.UProperty_Constants.BINARY_LIMIT)
                        {
	                        v = 1;
	                    } else if (p == -1) {
	                        if (0 == IBM.ICU.Impl.UPropertyAliases
	                                .Compare(ANY_ID, propertyAlias)) {
	                            Set(MIN_VALUE, MAX_VALUE);
	                            return this;
	                        } else if (0 == IBM.ICU.Impl.UPropertyAliases.Compare(ASCII_ID,
	                                propertyAlias)) {
	                            Set(0, 0x7F);
	                            return this;
	                        } else if (0 == IBM.ICU.Impl.UPropertyAliases.Compare(ASSIGNED,
	                                propertyAlias)) {
	                            // [:Assigned:]=[:^Cn:]
                                        p = IBM.ICU.Lang.UProperty_Constants.GENERAL_CATEGORY_MASK;
	                            v = (1 << IBM.ICU.Lang.UCharacterEnums.ECharacterCategory.UNASSIGNED);
	                            invert = true;
	                        } else {
	                            // Property name was never matched.
	                            throw new ArgumentException(
	                                    "Invalid property alias: " + propertyAlias
	                                            + "=" + valueAlias);
	                        }
	                    } else {
	                        // Valid propery name, but it isn't binary, so the value
	                        // must be supplied.
	                        throw new ArgumentException(
	                                "Missing property value");
	                    }
	                }
	            }
	        }
	
	        ApplyIntPropertyValue(p, v);
	        if (invert) {
	            Complement();
	        }
	
	        if (mustNotBeEmpty && IsEmpty()) {
	            // mustNotBeEmpty is set to true if an empty set indicates
	            // invalid input.
	            throw new ArgumentException("Invalid property value");
	        }
	
	        return this;
	    }
	
	    // ----------------------------------------------------------------
	    // Property set patterns
	    // ----------------------------------------------------------------
	
	    /// <summary>
	    /// Return true if the given position, in the given pattern, appears to be
	    /// the start of a property set pattern.
	    /// </summary>
	    ///
	    private static bool ResemblesPropertyPattern(String pattern, int pos) {
	        // Patterns are at least 5 characters long
	        if ((pos + 5) > pattern.Length) {
	            return false;
	        }
	
	        // Look for an opening [:, [:^, \p, or \P
	        return StringUtil.RegionMatches(pattern, pos, "[:", 0, 2)
                    || StringUtil.RegionMatches(pattern, true, pos, "\\p", 0, 2)
                    || StringUtil.RegionMatches(pattern, pos, "\\N", 0, 2);
	    }
	
	    /// <summary>
	    /// Return true if the given iterator appears to point at a property pattern.
	    /// Regardless of the result, return with the iterator unchanged.
	    /// </summary>
	    ///
	    /// <param name="chars">iterator over the pattern characters. Upon return it will beunchanged.</param>
	    /// <param name="iterOpts">RuleCharacterIterator options</param>
	    private static bool ResemblesPropertyPattern(
	            RuleCharacterIterator chars, int iterOpts) {
	        bool result = false;
	        iterOpts &= ~IBM.ICU.Impl.RuleCharacterIterator.PARSE_ESCAPES;
	        Object pos = chars.GetPos(null);
	        int c = chars.Next(iterOpts);
	        if (c == '[' || c == '\\') {
	            int d = chars.Next(iterOpts
	                    & ~IBM.ICU.Impl.RuleCharacterIterator.SKIP_WHITESPACE);
	            result = (c == '[') ? (d == ':')
	                    : (d == 'N' || d == 'p' || d == 'P');
	        }
	        chars.SetPos(pos);
	        return result;
	    }
	
	    /// <summary>
	    /// Parse the given property pattern at the given parse position.
	    /// </summary>
	    ///
	    /// <param name="symbols">TODO</param>
	    private UnicodeSet ApplyPropertyPattern(String pattern, ParsePosition ppos,
	            SymbolTable symbols) {
	        int pos = ppos.GetIndex();
	
	        // On entry, ppos should point to one of the following locations:
	
	        // Minimum length is 5 characters, e.g. \p{L}
	        if ((pos + 5) > pattern.Length) {
	            return null;
	        }
	
	        bool posix = false; // true for [:pat:], false for \p{pat} \P{pat}
	                               // \N{pat}
	        bool isName = false; // true for \N{pat}, o/w false
	        bool invert = false;
	
	        // Look for an opening [:, [:^, \p, or \P
            if (StringUtil.RegionMatches(pattern, pos, "[:", 0, 2))
            {
	            posix = true;
	            pos = IBM.ICU.Impl.Utility.SkipWhitespace(pattern, pos + 2);
	            if (pos < pattern.Length && pattern[pos] == '^') {
	                ++pos;
	                invert = true;
	            }
            }
            else if (StringUtil.RegionMatches(pattern, true, pos, "\\p", 0, 2)
                    || StringUtil.RegionMatches(pattern, pos, "\\N", 0, 2))
            {
	            char c = pattern[pos + 1];
	            invert = (c == 'P');
	            isName = (c == 'N');
	            pos = IBM.ICU.Impl.Utility.SkipWhitespace(pattern, pos + 2);
	            if (pos == pattern.Length || pattern[pos++] != '{') {
	                // Syntax error; "\p" or "\P" not followed by "{"
	                return null;
	            }
	        } else {
	            // Open delimiter not seen
	            return null;
	        }
	
	        // Look for the matching close delimiter, either :] or }
	        int close = ILOG.J2CsMapping.Util.StringUtil.IndexOf(pattern,(posix) ? ":]" : "}",pos);
	        if (close < 0) {
	            // Syntax error; close delimiter missing
	            return null;
	        }
	
	        // Look for an '=' sign. If this is present, we will parse a
	        // medium \p{gc=Cf} or long \p{GeneralCategory=Format}
	        // pattern.
	        int equals = pattern.IndexOf('=', pos);
	        String propName, valueName;
	        if (equals >= 0 && equals < close && !isName) {
	            // Equals seen; parse medium/long pattern
	            propName = pattern.Substring(pos,(equals)-(pos));
	            valueName = pattern.Substring(equals + 1,(close)-(equals + 1));
	        }
	
	        else {
	            // Handle case where no '=' is seen, and \N{}
	            propName = pattern.Substring(pos,(close)-(pos));
	            valueName = "";
	
	            // Handle \N{name}
	            if (isName) {
	                // This is a little inefficient since it means we have to
	                // parse "na" back to UProperty.NAME even though we already
	                // know it's UProperty.NAME. If we refactor the API to
	                // support args of (int, String) then we can remove
	                // "na" and make this a little more efficient.
	                valueName = propName;
	                propName = "na";
	            }
	        }
	
	        ApplyPropertyAlias(propName, valueName, symbols);
	
	        if (invert) {
	            Complement();
	        }
	
	        // Move to the limit position after the close delimiter
	        ppos.SetIndex(close + ((posix) ? 2 : 1));
	
	        return this;
	    }
	
	    /// <summary>
	    /// Parse a property pattern.
	    /// </summary>
	    ///
	    /// <param name="chars">iterator over the pattern characters. Upon return it will beadvanced to the first character after the parsed pattern, orthe end of the iteration if all characters are parsed.</param>
	    /// <param name="rebuiltPat">the pattern that was parsed, rebuilt or copied from the inputpattern, as appropriate.</param>
	    /// <param name="symbols">TODO</param>
	    private void ApplyPropertyPattern(RuleCharacterIterator chars,
	            StringBuilder rebuiltPat, SymbolTable symbols) {
	        String patStr = chars.Lookahead();
	        ParsePosition pos = new ParsePosition(0);
	        ApplyPropertyPattern(patStr, pos, symbols);
	        if (pos.GetIndex() == 0) {
	            SyntaxError(chars, "Invalid property pattern");
	        }
	        chars.Jumpahead(pos.GetIndex());
	        rebuiltPat.Append(patStr.Substring(0,(pos.GetIndex())-(0)));
	    }
	
	    // ----------------------------------------------------------------
	    // Case folding API
	    // ----------------------------------------------------------------
	
	    /// <summary>
	    /// Bitmask for constructor and applyPattern() indicating that white space
	    /// should be ignored. If set, ignore characters for which
	    /// UCharacterProperty.isRuleWhiteSpace() returns true, unless they are
	    /// quoted or escaped. This may be ORed together with other selectors.
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const int IGNORE_SPACE = 1;
	
	    /// <summary>
	    /// Bitmask for constructor, applyPattern(), and closeOver() indicating
	    /// letter case. This may be ORed together with other selectors.
	    /// Enable case insensitive matching. E.g., "[ab]" with this flag will match
	    /// 'a', 'A', 'b', and 'B'. "[^ab]" with this flag will match all except 'a',
	    /// 'A', 'b', and 'B'. This performs a full closure over case mappings, e.g.
	    /// U+017F for s.
	    /// The resulting set is a superset of the input for the code points but not
	    /// for the strings. It performs a case mapping closure of the code points
	    /// and adds full case folding strings for the code points, and reduces
	    /// strings of the original set to their full case folding equivalents.
	    /// This is designed for case-insensitive matches, for example in regular
	    /// expressions. The full code point case closure allows checking of an input
	    /// character directly against the closure set. Strings are matched by
	    /// comparing the case-folded form from the closure set with an incremental
	    /// case folding of the string in question.
	    /// The closure set will also contain single code points if the original set
	    /// contained case-equivalent strings (like U+00DF for "ss" or "Ss" etc.).
	    /// This is not necessary (that is, redundant) for the above matching method
	    /// but results in the same closure sets regardless of whether the original
	    /// set contained the code point or a string.
	    /// </summary>
	    ///
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public const int CASE = 2;
	
	    /// <summary>
	    /// Alias for UnicodeSet.CASE, for ease of porting from C++ where ICU4C also
	    /// has both USET_CASE and USET_CASE_INSENSITIVE (see uset.h).
	    /// </summary>
	    ///
	    /// <seealso cref="F:IBM.ICU.Text.UnicodeSet.CASE"/>
	    /// @stable ICU 3.4
	    public const int CASE_INSENSITIVE = 2;
	
	    /// <summary>
	    /// Bitmask for constructor, applyPattern(), and closeOver() indicating
	    /// letter case. This may be ORed together with other selectors.
	    /// Enable case insensitive matching. E.g., "[ab]" with this flag will match
	    /// 'a', 'A', 'b', and 'B'. "[^ab]" with this flag will match all except 'a',
	    /// 'A', 'b', and 'B'. This adds the lower-, title-, and uppercase mappings
	    /// as well as the case folding of each existing element in the set.
	    /// </summary>
	    ///
	    /// @stable ICU 3.4
	    public const int ADD_CASE_MAPPINGS = 4;
	
	    // add the result of a full case mapping to the set
	    // use str as a temporary string to avoid constructing one
	    private static void AddCaseMapping(UnicodeSet set, int result,
	            StringBuilder full) {
	        if (result >= 0) {
	            if (result > IBM.ICU.Impl.UCaseProps.MAX_STRING_LENGTH) {
	                // add a single-code point case mapping
	                set.Add(result);
	            } else {
	                // add a string case mapping from full with length result
	                set.Add(full.ToString());
	                full.Length=0;
	            }
	        }
	        // result < 0: the code point mapped to itself, no need to add it
	        // see UCaseProps
	    }
	
	    /// <summary>
	    /// Close this set over the given attribute. For the attribute CASE, the
	    /// result is to modify this set so that:
	    /// 1. For each character or string 'a' in this set, all strings 'b' such
	    /// that foldCase(a) == foldCase(b) are added to this set. (For most 'a' that
	    /// are single characters, 'b' will have b.length() == 1.)
	    /// 2. For each string 'e' in the resulting set, if e != foldCase(e), 'e'
	    /// will be removed.
	    /// Example: [aq\u00DF{Bc}{bC}{Fi}] => [aAqQ\u00DF\uFB01{ss}{bc}{fi}]
	    /// (Here foldCase(x) refers to the operation UCharacter.foldCase(x, true),
	    /// and a == b actually denotes a.equals(b), not pointer comparison.)
	    /// </summary>
	    ///
	    /// <param name="attribute">bitmask for attributes to close over. Currently only the CASEbit is supported. Any undefined bits are ignored.</param>
	    /// <returns>a reference to this set.</returns>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public UnicodeSet CloseOver(int attribute) {
	        CheckFrozen();
	        if ((attribute & (CASE | ADD_CASE_MAPPINGS)) != 0) {
	            UCaseProps csp;
	            try {
	                csp = IBM.ICU.Impl.UCaseProps.GetSingleton();
	            } catch (IOException e) {
	                return this;
	            }
	            UnicodeSet foldSet = new UnicodeSet(this);
	            ULocale root = IBM.ICU.Util.ULocale.ROOT;
	
	            // start with input set to guarantee inclusion
	            // CASE: remove strings because the strings will actually be reduced
	            // (folded);
	            // therefore, start with no strings and add only those needed
	            if ((attribute & CASE) != 0) {
	                ILOG.J2CsMapping.Collections.Collections.Clear(foldSet.strings);
	            }
	
	            int n = GetRangeCount();
	            int result;
	            StringBuilder full = new StringBuilder();
	            int[] locCache = new int[1];
	
	            for (int i = 0; i < n; ++i) {
	                int start = GetRangeStart(i);
	                int end = GetRangeEnd(i);
	
	                if ((attribute & CASE) != 0) {
	                    // full case closure
	                    for (int cp = start; cp <= end; ++cp) {
	                        csp.AddCaseClosure(cp, foldSet);
	                    }
	                } else {
	                    // add case mappings
	                    // (does not add long s for regular s, or Kelvin for k, for
	                    // example)
	                    for (int cp_0 = start; cp_0 <= end; ++cp_0) {
	                        result = csp
	                                .ToFullLower(cp_0, null, full, root, locCache);
	                        AddCaseMapping(foldSet, result, full);
	
	                        result = csp
	                                .ToFullTitle(cp_0, null, full, root, locCache);
	                        AddCaseMapping(foldSet, result, full);
	
	                        result = csp
	                                .ToFullUpper(cp_0, null, full, root, locCache);
	                        AddCaseMapping(foldSet, result, full);
	
	                        result = csp.ToFullFolding(cp_0, full, 0);
	                        AddCaseMapping(foldSet, result, full);
	                    }
	                }
	            }
	            if (!(strings.Count==0)) {
	                String str;
	                if ((attribute & CASE) != 0) {
	                    IIterator it = new ILOG.J2CsMapping.Collections.IteratorAdapter(strings.GetEnumerator());
	                    while (it.HasNext()) {
	                        str = IBM.ICU.Lang.UCharacter.FoldCase((String) it.Next(), 0);
	                        if (!csp.AddStringCaseClosure(str, foldSet)) {
	                            foldSet.Add(str); // does not map to code points:
	                                              // add the folded string itself
	                        }
	                    }
	                } else {
	                    BreakIterator bi = IBM.ICU.Text.BreakIterator.GetWordInstance(root);
	                    IIterator it_1 = new ILOG.J2CsMapping.Collections.IteratorAdapter(strings.GetEnumerator());
	                    while (it_1.HasNext()) {
	                        str = (String) it_1.Next();
	                        foldSet.Add(IBM.ICU.Lang.UCharacter.ToLowerCase(root, str));
	                        foldSet.Add(IBM.ICU.Lang.UCharacter.ToTitleCase(root, str, bi));
	                        foldSet.Add(IBM.ICU.Lang.UCharacter.ToUpperCase(root, str));
	                        foldSet.Add(IBM.ICU.Lang.UCharacter.FoldCase(str, 0));
	                    }
	                }
	            }
	            Set(foldSet);
	        }
	        return this;
	    }
	
	    /// <summary>
	    /// Internal class for customizing UnicodeSet parsing of properties. TODO:
	    /// extend to allow customizing of codepoint ranges
	    /// </summary>
	    ///
	    /// @draft ICU3.8
	    /// @provisional This API might change or be removed in a future release.
	    abstract public class XSymbolTable : SymbolTable {
	        /// <summary>
	        /// Default constructor
	        /// </summary>
	        ///
	        /// @draft ICU3.8
	        /// @provisional This API might change or be removed in a future release.
	        public XSymbolTable() {
	        }
	
	        /// <summary>
	        /// Supplies default implementation for SymbolTable (no action).
	        /// </summary>
	        ///
	        /// @draft ICU3.8
	        /// @provisional This API might change or be removed in a future release.
	        public virtual UnicodeMatcher LookupMatcher(int i) {
	            return null;
	        }
	
	        /// <summary>
	        /// Apply a new property alias. Is called when parsing [:xxx=yyy:].
	        /// Results are to put into result.
	        /// </summary>
	        ///
	        /// <param name="propertyName">the xxx in [:xxx=yyy:]</param>
	        /// <param name="propertyValue">the yyy in [:xxx=yyy:]</param>
	        /// <param name="result">where the result is placed</param>
	        /// <returns>true if handled</returns>
	        /// @draft ICU3.8
	        /// @provisional This API might change or be removed in a future release.
	        public virtual bool ApplyPropertyAlias(String propertyName,
	                String propertyValue, UnicodeSet result) {
	            return false;
	        }
	
	        /// <summary>
	        /// Supplies default implementation for SymbolTable (no action).
	        /// </summary>
	        ///
	        /// @draft ICU3.8
	        /// @provisional This API might change or be removed in a future release.
	        public virtual char[] Lookup(String s) {
	            return null;
	        }
	
	        /// <summary>
	        /// Supplies default implementation for SymbolTable (no action).
	        /// </summary>
	        ///
	        /// @draft ICU3.8
	        /// @provisional This API might change or be removed in a future release.
	        public virtual String ParseReference(String text, ParsePosition pos, int limit) {
	            return null;
	        }
	    }
	
	    private bool frozen;
	
	    /// <summary>
	    /// Is this frozen, according to the Freezable interface?
	    /// </summary>
	    ///
	    /// <returns>value</returns>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public virtual bool IsFrozen() {
	        return frozen;
	    }
	
	    /// <summary>
	    /// Freeze this class, according to the Freezable interface.
	    /// </summary>
	    ///
	    /// <returns>this</returns>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public virtual Object Freeze() {
	        frozen = true;
	        return this;
	    }
	
	    /// <summary>
	    /// Clone a thawed version of this class, according to the Freezable
	    /// interface.
	    /// </summary>
	    ///
	    /// <returns>this</returns>
	    /// @draft ICU 3.8
	    /// @provisional This API might change or be removed in a future release.
	    public virtual Object CloneAsThawed() {
	        UnicodeSet result = (UnicodeSet) Clone();
	        result.frozen = false;
	        return result;
	    }
	
	    // internal function
	    private void CheckFrozen() {
	        if (frozen) {
	            throw new NotSupportedException(
	                    "Attempt to modify frozen object");
	        }
	    }
	}
	// eof
}
