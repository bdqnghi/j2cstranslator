/*
 *******************************************************************************
 * Copyright (C) 2003-2007, International Business Machines Corporation and    *
 * others. All Rights Reserved.                                                *
 *******************************************************************************
 */

// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20101125_01     
// 12/2/10 11:30 AM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
 namespace IBM.ICU.Text {
	
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Resources;
	using System.Runtime.CompilerServices;
	using System.Text;
	
	/// <summary>
	/// IDNA API implements the IDNA protocol as defined in the <a
	/// href="http://www.ietf.org/rfc/rfc3490.txt">IDNA RFC</a>. The draft defines 2
	/// operations: ToASCII and ToUnicode. Domain labels containing non-ASCII code
	/// points are required to be processed by ToASCII operation before passing it to
	/// resolver libraries. Domain names that are obtained from resolver libraries
	/// are required to be processed by ToUnicode operation before displaying the
	/// domain name to the user. IDNA requires that implementations process input
	/// strings with <a href="http://www.ietf.org/rfc/rfc3491.txt">Nameprep</a>,
	/// which is a profile of <a
	/// href="http://www.ietf.org/rfc/rfc3454.txt">Stringprep</a> , and then with <a
	/// href="http://www.ietf.org/rfc/rfc3492.txt">Punycode</a>. Implementations of
	/// IDNA MUST fully implement Nameprep and Punycode; neither Nameprep nor
	/// Punycode are optional. The input and output of ToASCII and ToUnicode
	/// operations are Unicode and are designed to be chainable, i.e., applying
	/// ToASCII or ToUnicode operations multiple times to an input string will yield
	/// the same result as applying the operation once.
	/// ToUnicode(ToUnicode(ToUnicode...(ToUnicode(string)))) == ToUnicode(string)
	/// ToASCII(ToASCII(ToASCII...(ToASCII(string))) == ToASCII(string).
	/// </summary>
	///
	/// @stable ICU 2.8
	public sealed class IDNA {
	
	    /* IDNA ACE Prefix is "xn--" */
        private static char[] ACE_PREFIX = new char[] { (char) 0x0078, (char) 0x006E, (char) 0x002d,
	            (char) 0x002d };
	
	    // private static final int ACE_PREFIX_LENGTH = ACE_PREFIX.length;
	
	    private const int MAX_LABEL_LENGTH = 63;
	
	    private const int HYPHEN = 0x002D;
	
	    private const int CAPITAL_A = 0x0041;
	
	    private const int CAPITAL_Z = 0x005A;
	
	    private const int LOWER_CASE_DELTA = 0x0020;
	
	    private const int FULL_STOP = 0x002E;
	
	    private const int MAX_DOMAIN_NAME_LENGTH = 255;
	
	    /// <summary>
	    /// Option to prohibit processing of unassigned codepoints in the input and
	    /// do not check if the input conforms to STD-3 ASCII rules.
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.IDNA.ConvertToASCII(System.String, System.Int32)"/>
	    ///  #convertToUnicode
	    /// @stable ICU 2.8
	    public const int DEFAULT = 0x0000;
	
	    /// <summary>
	    /// Option to allow processing of unassigned codepoints in the input
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.IDNA.ConvertToASCII(System.String, System.Int32)"/>
	    ///  #convertToUnicode
	    /// @stable ICU 2.8
	    public const int ALLOW_UNASSIGNED = 0x0001;
	
	    /// <summary>
	    /// Option to check if input conforms to STD-3 ASCII rules
	    /// </summary>
	    ///
	    /// <seealso cref="M:IBM.ICU.Text.IDNA.ConvertToASCII(System.String, System.Int32)"/>
	    ///  #convertToUnicode
	    /// @stable ICU 2.8
	    public const int USE_STD3_RULES = 0x0002;
	
	    // static final singleton object that is initialized
	    // at class initialization time, hence guaranteed to
	    // be initialized and thread safe
	    private static readonly IDNA singleton = new IDNA();
	
	    // The NamePrep profile object
	    private StringPrep namePrep;
	
	    /* private constructor to prevent construction of the object */
	    private IDNA() {
	        try {
	            Stream stream = IBM.ICU.Impl.ICUData
	                    .GetRequiredStream(IBM.ICU.Impl.ICUResourceBundle.ICU_BUNDLE
	                            + "/uidna.spp");
	            namePrep = new StringPrep(stream);
	            stream.Close();
	        } catch (IOException e) {
	            throw new MissingManifestResourceException(e.ToString());
	        }
	    }
	
	    private static bool StartsWithPrefix(StringBuilder src) {
	        bool startsWithPrefix = true;
	
	        if (src.Length < ACE_PREFIX.Length) {
	            return false;
	        }
	        for (int i = 0; i < ACE_PREFIX.Length; i++) {
	            if (ToASCIILower(src[i]) != ACE_PREFIX[i]) {
	                startsWithPrefix = false;
	            }
	        }
	        return startsWithPrefix;
	    }
	
	    private static char ToASCIILower(char ch) {
	        if (CAPITAL_A <= ch && ch <= CAPITAL_Z) {
	            return (char) (ch + LOWER_CASE_DELTA);
	        }
	        return ch;
	    }
	
	    private static StringBuilder ToASCIILower(StringBuilder src) {
	        StringBuilder dest = new StringBuilder();
	        for (int i = 0; i < src.Length; i++) {
	            dest.Append(ToASCIILower(src[i]));
	        }
	        return dest;
	    }
	
	    private static int CompareCaseInsensitiveASCII(StringBuilder s1,
	            StringBuilder s2) {
	        char c1, c2;
	        int rc;
	        for (int i = 0;/* no condition */; i++) {
	            /* If we reach the ends of both strings then they match */
	            if (i == s1.Length) {
	                return 0;
	            }
	
	            c1 = s1[i];
	            c2 = s2[i];
	
	            /* Case-insensitive comparison */
	            if (c1 != c2) {
	                rc = ToASCIILower(c1) - ToASCIILower(c2);
	                if (rc != 0) {
	                    return rc;
	                }
	            }
	        }
	    }
	
	    private static int GetSeparatorIndex(char[] src, int start, int limit) {
	        for (; start < limit; start++) {
	            if (IsLabelSeparator(src[start])) {
	                return start;
	            }
	        }
	        // we have not found the separator just return length
	        return start;
	    }
	
	    /*
	     * private static int getSeparatorIndex(UCharacterIterator iter){ int
	     * currentIndex = iter.getIndex(); int separatorIndex = 0; int ch;
	     * while((ch=iter.next())!= UCharacterIterator.DONE){
	     * if(isLabelSeparator(ch)){ separatorIndex = iter.getIndex();
	     * iter.setIndex(currentIndex); return separatorIndex; } } // reset index
	     * iter.setIndex(currentIndex); // we have not found the separator just
	     * return the length
	     * 
	     * }
	     */
	
	    private static bool IsLDHChar(int ch) {
	        // high runner case
	        if (ch > 0x007A) {
	            return false;
	        }
	        // [\\u002D \\u0030-\\u0039 \\u0041-\\u005A \\u0061-\\u007A]
	        if ((ch == 0x002D) || (0x0030 <= ch && ch <= 0x0039)
	                || (0x0041 <= ch && ch <= 0x005A)
	                || (0x0061 <= ch && ch <= 0x007A)) {
	            return true;
	        }
	        return false;
	    }
	
	    /// <summary>
	    /// Ascertain if the given code point is a label separator as defined by the
	    /// IDNA RFC
	    /// </summary>
	    ///
	    /// <param name="ch">The code point to be ascertained</param>
	    /// <returns>true if the char is a label separator</returns>
	    /// @stable ICU 2.8
	    private static bool IsLabelSeparator(int ch) {
	        switch (ch) {
	        case 0x002e:
	        case 0x3002:
	        case 0xFF0E:
	        case 0xFF61:
	            return true;
	        default:
	            return false;
	        }
	    }
	
	    /// <summary>
	    /// This function implements the ToASCII operation as defined in the IDNA
	    /// RFC. This operation is done on <b>single labels</b> before sending it to
	    /// something that expects ASCII names. A label is an individual part of a
	    /// domain name. Labels are usually separated by dots;
	    /// e.g." "www.example.com" is composed of 3 labels "www","example", and
	    /// "com".
	    /// </summary>
	    ///
	    /// <param name="src">The input string to be processed</param>
	    /// <param name="options">A bit set of options: - IDNA.DEFAULT Use default options,i.e., do not process unassigned code points and do not useSTD3 ASCII rules If unassigned code points are found theoperation fails with ParseException.- IDNA.ALLOW_UNASSIGNED Unassigned values can be converted toASCII for query operations If this option is set, theunassigned code points are in the input are treated as normalUnicode code points.- IDNA.USE_STD3_RULES Use STD3 ASCII rules for host namesyntax restrictions If this option is set and the input doesnot satisfy STD3 rules, the operation will fail withParseException</param>
	    /// <returns>StringBuffer the converted String</returns>
	    /// <exception cref="ParseException"></exception>
	    /// @stable ICU 2.8
	    public static StringBuilder ConvertToASCII(String src, int options) {
	        UCharacterIterator iter = IBM.ICU.Text.UCharacterIterator.GetInstance(src);
	        return ConvertToASCII(iter, options);
	    }
	
	    /// <summary>
	    /// This function implements the ToASCII operation as defined in the IDNA
	    /// RFC. This operation is done on <b>single labels</b> before sending it to
	    /// something that expects ASCII names. A label is an individual part of a
	    /// domain name. Labels are usually separated by dots;
	    /// e.g." "www.example.com" is composed of 3 labels "www","example", and
	    /// "com".
	    /// </summary>
	    ///
	    /// <param name="src">The input string as StringBuffer to be processed</param>
	    /// <param name="options">A bit set of options: - IDNA.DEFAULT Use default options,i.e., do not process unassigned code points and do not useSTD3 ASCII rules If unassigned code points are found theoperation fails with ParseException.- IDNA.ALLOW_UNASSIGNED Unassigned values can be converted toASCII for query operations If this option is set, theunassigned code points are in the input are treated as normalUnicode code points.- IDNA.USE_STD3_RULES Use STD3 ASCII rules for host namesyntax restrictions If this option is set and the input doesnot satisfy STD3 rules, the operation will fail withParseException</param>
	    /// <returns>StringBuffer the converted String</returns>
	    /// <exception cref="ParseException"></exception>
	    /// @stable ICU 2.8
	    public static StringBuilder ConvertToASCII(StringBuilder src, int options) {
	        UCharacterIterator iter = IBM.ICU.Text.UCharacterIterator.GetInstance(src);
	        return ConvertToASCII(iter, options);
	    }
	
	    /// <summary>
	    /// This function implements the ToASCII operation as defined in the IDNA
	    /// RFC. This operation is done on <b>single labels</b> before sending it to
	    /// something that expects ASCII names. A label is an individual part of a
	    /// domain name. Labels are usually separated by dots;
	    /// e.g." "www.example.com" is composed of 3 labels "www","example", and
	    /// "com".
	    /// </summary>
	    ///
	    /// <param name="src">The input string as UCharacterIterator to be processed</param>
	    /// <param name="options">A bit set of options: - IDNA.DEFAULT Use default options,i.e., do not process unassigned code points and do not useSTD3 ASCII rules If unassigned code points are found theoperation fails with ParseException.- IDNA.ALLOW_UNASSIGNED Unassigned values can be converted toASCII for query operations If this option is set, theunassigned code points are in the input are treated as normalUnicode code points.- IDNA.USE_STD3_RULES Use STD3 ASCII rules for host namesyntax restrictions If this option is set and the input doesnot satisfy STD3 rules, the operation will fail withParseException</param>
	    /// <returns>StringBuffer the converted String</returns>
	    /// <exception cref="ParseException"></exception>
	    /// @stable ICU 2.8
	    public static StringBuilder ConvertToASCII(UCharacterIterator src,
	            int options) {
	
	        bool[] caseFlags = null;
	
	        // the source contains all ascii codepoints
	        bool srcIsASCII = true;
	        // assume the source contains all LDH codepoints
	        bool srcIsLDH = true;
	
	        // get the options
	        bool useSTD3ASCIIRules = ((options & USE_STD3_RULES) != 0);
	        int ch;
	        // step 1
	        while ((ch = src.Next()) != IBM.ICU.Text.UForwardCharacterIterator_Constants.DONE) {
	            if (ch > 0x7f) {
	                srcIsASCII = false;
	            }
	        }
	        int failPos = -1;
	        src.SetToStart();
	        StringBuilder processOut = null;
	        // step 2 is performed only if the source contains non ASCII
	        if (!srcIsASCII) {
	            // step 2
	            processOut = singleton.namePrep.Prepare(src, options);
	        } else {
	            processOut = new StringBuilder(src.GetText());
	        }
	        int poLen = processOut.Length;
	
	        if (poLen == 0) {
	            throw new StringPrepParseException(
	                    "Found zero length lable after NamePrep.",
	                    IBM.ICU.Text.StringPrepParseException.ZERO_LENGTH_LABEL);
	        }
	        StringBuilder dest = new StringBuilder();
	
	        // reset the variable to verify if output of prepare is ASCII or not
	        srcIsASCII = true;
	
	        // step 3 & 4
	        for (int j = 0; j < poLen; j++) {
	            ch = processOut[j];
	            if (ch > 0x7F) {
	                srcIsASCII = false;
	            } else if (IsLDHChar(ch) == false) {
	                // here we do not assemble surrogates
	                // since we know that LDH code points
	                // are in the ASCII range only
	                srcIsLDH = false;
	                failPos = j;
	            }
	        }
	
	        if (useSTD3ASCIIRules == true) {
	            // verify 3a and 3b
	            if (srcIsLDH == false /* source contains some non-LDH characters */
	                    || processOut[0] == HYPHEN
	                    || processOut[processOut.Length - 1] == HYPHEN) {
	
	                /* populate the parseError struct */
	                if (srcIsLDH == false) {
	                    throw new StringPrepParseException(
	                            "The input does not conform to the STD 3 ASCII rules",
	                            IBM.ICU.Text.StringPrepParseException.STD3_ASCII_RULES_ERROR,
	                            processOut.ToString(),
	                            (failPos > 0) ? (failPos - 1) : failPos);
	                } else if (processOut[0] == HYPHEN) {
	                    throw new StringPrepParseException(
	                            "The input does not conform to the STD 3 ASCII rules",
	                            IBM.ICU.Text.StringPrepParseException.STD3_ASCII_RULES_ERROR,
	                            processOut.ToString(), 0);
	
	                } else {
	                    throw new StringPrepParseException(
	                            "The input does not conform to the STD 3 ASCII rules",
	                            IBM.ICU.Text.StringPrepParseException.STD3_ASCII_RULES_ERROR,
	                            processOut.ToString(), (poLen > 0) ? poLen - 1
	                                    : poLen);
	
	                }
	            }
	        }
	        if (srcIsASCII) {
	            dest = processOut;
	        } else {
	            // step 5 : verify the sequence does not begin with ACE prefix
	            if (!StartsWithPrefix(processOut)) {
	
	                // step 6: encode the sequence with punycode
	                caseFlags = new bool[poLen];
	
	                StringBuilder punyout = IBM.ICU.Text.Punycode.Encode(processOut, caseFlags);
	
	                // convert all codepoints to lower case ASCII
	                StringBuilder lowerOut = ToASCIILower(punyout);
	
	                // Step 7: prepend the ACE prefix
	                dest.Append(ACE_PREFIX, 0, ACE_PREFIX.Length);
	                // Step 6: copy the contents in b2 into dest
	                dest.Append(lowerOut);
	            } else {
	
	                throw new StringPrepParseException(
	                        "The input does not start with the ACE Prefix.",
	                        IBM.ICU.Text.StringPrepParseException.ACE_PREFIX_ERROR,
	                        processOut.ToString(), 0);
	            }
	        }
	        if (dest.Length > MAX_LABEL_LENGTH) {
	            throw new StringPrepParseException(
	                    "The labels in the input are too long. Length > 63.",
	                    IBM.ICU.Text.StringPrepParseException.LABEL_TOO_LONG_ERROR,
	                    dest.ToString(), 0);
	        }
	        return dest;
	    }
	
	    /// <summary>
	    /// Convenience function that implements the IDNToASCII operation as defined
	    /// in the IDNA RFC. This operation is done on complete domain names, e.g:
	    /// "www.example.com". It is important to note that this operation can fail.
	    /// If it fails, then the input domain name cannot be used as an
	    /// Internationalized Domain Name and the application should have methods
	    /// defined to deal with the failure.
	    /// <b>Note:</b> IDNA RFC specifies that a conformant application should
	    /// divide a domain name into separate labels, decide whether to apply
	    /// allowUnassigned and useSTD3ASCIIRules on each, and then convert. This
	    /// function does not offer that level of granularity. The options once set
	    /// will apply to all labels in the domain name
	    /// </summary>
	    ///
	    /// <param name="src">The input string as UCharacterIterator to be processed</param>
	    /// <param name="options">A bit set of options: - IDNA.DEFAULT Use default options,i.e., do not process unassigned code points and do not useSTD3 ASCII rules If unassigned code points are found theoperation fails with ParseException.- IDNA.ALLOW_UNASSIGNED Unassigned values can be converted toASCII for query operations If this option is set, theunassigned code points are in the input are treated as normalUnicode code points.- IDNA.USE_STD3_RULES Use STD3 ASCII rules for host namesyntax restrictions If this option is set and the input doesnot satisfy STD3 rules, the operation will fail withParseException</param>
	    /// <returns>StringBuffer the converted String</returns>
	    /// <exception cref="ParseException"></exception>
	    /// @stable ICU 2.8
	    public static StringBuilder ConvertIDNToASCII(UCharacterIterator src,
	            int options) {
	        return ConvertIDNToASCII(src.GetText(), options);
	    }
	
	    /// <summary>
	    /// Convenience function that implements the IDNToASCII operation as defined
	    /// in the IDNA RFC. This operation is done on complete domain names, e.g:
	    /// "www.example.com". It is important to note that this operation can fail.
	    /// If it fails, then the input domain name cannot be used as an
	    /// Internationalized Domain Name and the application should have methods
	    /// defined to deal with the failure.
	    /// <b>Note:</b> IDNA RFC specifies that a conformant application should
	    /// divide a domain name into separate labels, decide whether to apply
	    /// allowUnassigned and useSTD3ASCIIRules on each, and then convert. This
	    /// function does not offer that level of granularity. The options once set
	    /// will apply to all labels in the domain name
	    /// </summary>
	    ///
	    /// <param name="src">The input string as a StringBuffer to be processed</param>
	    /// <param name="options">A bit set of options: - IDNA.DEFAULT Use default options,i.e., do not process unassigned code points and do not useSTD3 ASCII rules If unassigned code points are found theoperation fails with ParseException.- IDNA.ALLOW_UNASSIGNED Unassigned values can be converted toASCII for query operations If this option is set, theunassigned code points are in the input are treated as normalUnicode code points.- IDNA.USE_STD3_RULES Use STD3 ASCII rules for host namesyntax restrictions If this option is set and the input doesnot satisfy STD3 rules, the operation will fail withParseException</param>
	    /// <returns>StringBuffer the converted String</returns>
	    /// <exception cref="ParseException"></exception>
	    /// @stable ICU 2.8
	    public static StringBuilder ConvertIDNToASCII(StringBuilder src, int options) {
	        return ConvertIDNToASCII(src.ToString(), options);
	    }
	
	    /// <summary>
	    /// Convenience function that implements the IDNToASCII operation as defined
	    /// in the IDNA RFC. This operation is done on complete domain names, e.g:
	    /// "www.example.com". It is important to note that this operation can fail.
	    /// If it fails, then the input domain name cannot be used as an
	    /// Internationalized Domain Name and the application should have methods
	    /// defined to deal with the failure.
	    /// <b>Note:</b> IDNA RFC specifies that a conformant application should
	    /// divide a domain name into separate labels, decide whether to apply
	    /// allowUnassigned and useSTD3ASCIIRules on each, and then convert. This
	    /// function does not offer that level of granularity. The options once set
	    /// will apply to all labels in the domain name
	    /// </summary>
	    ///
	    /// <param name="src">The input string to be processed</param>
	    /// <param name="options">A bit set of options: - IDNA.DEFAULT Use default options,i.e., do not process unassigned code points and do not useSTD3 ASCII rules If unassigned code points are found theoperation fails with ParseException.- IDNA.ALLOW_UNASSIGNED Unassigned values can be converted toASCII for query operations If this option is set, theunassigned code points are in the input are treated as normalUnicode code points.- IDNA.USE_STD3_RULES Use STD3 ASCII rules for host namesyntax restrictions If this option is set and the input doesnot satisfy STD3 rules, the operation will fail withParseException</param>
	    /// <returns>StringBuffer the converted String</returns>
	    /// <exception cref="ParseException"></exception>
	    /// @stable ICU 2.8
	    public static StringBuilder ConvertIDNToASCII(String src, int options) {
	
	        char[] srcArr = src.ToCharArray();
	        StringBuilder result = new StringBuilder();
	        int sepIndex = 0;
	        int oldSepIndex = 0;
	        for (;;) {
	            sepIndex = GetSeparatorIndex(srcArr, sepIndex, srcArr.Length);
	            String label = new String(srcArr, oldSepIndex, sepIndex
	                    - oldSepIndex);
	            // make sure this is not a root label separator.
	            if (!(label.Length == 0 && sepIndex == srcArr.Length)) {
	                UCharacterIterator iter = IBM.ICU.Text.UCharacterIterator.GetInstance(label);
	                result.Append(ConvertToASCII(iter, options));
	            }
	            if (sepIndex == srcArr.Length) {
	                break;
	            }
	
	            // increment the sepIndex to skip past the separator
	            sepIndex++;
	            oldSepIndex = sepIndex;
	            result.Append((char) FULL_STOP);
	        }
	        if (result.Length > MAX_DOMAIN_NAME_LENGTH) {
	            throw new StringPrepParseException(
	                    "The output exceed the max allowed length.",
	                    IBM.ICU.Text.StringPrepParseException.DOMAIN_NAME_TOO_LONG_ERROR);
	        }
	        return result;
	    }
	
	    /// <summary>
	    /// This function implements the ToUnicode operation as defined in the IDNA
	    /// RFC. This operation is done on <b>single labels</b> before sending it to
	    /// something that expects Unicode names. A label is an individual part of a
	    /// domain name. Labels are usually separated by dots; for
	    /// e.g." "www.example.com" is composed of 3 labels "www","example", and
	    /// "com".
	    /// </summary>
	    ///
	    /// <param name="src">The input string to be processed</param>
	    /// <param name="options">A bit set of options: - IDNA.DEFAULT Use default options,i.e., do not process unassigned code points and do not useSTD3 ASCII rules If unassigned code points are found theoperation fails with ParseException.- IDNA.ALLOW_UNASSIGNED Unassigned values can be converted toASCII for query operations If this option is set, theunassigned code points are in the input are treated as normalUnicode code points.- IDNA.USE_STD3_RULES Use STD3 ASCII rules for host namesyntax restrictions If this option is set and the input doesnot satisfy STD3 rules, the operation will fail withParseException</param>
	    /// <returns>StringBuffer the converted String</returns>
	    /// <exception cref="ParseException"></exception>
	    /// @stable ICU 2.8
	    public static StringBuilder ConvertToUnicode(String src, int options) {
	        UCharacterIterator iter = IBM.ICU.Text.UCharacterIterator.GetInstance(src);
	        return ConvertToUnicode(iter, options);
	    }
	
	    /// <summary>
	    /// This function implements the ToUnicode operation as defined in the IDNA
	    /// RFC. This operation is done on <b>single labels</b> before sending it to
	    /// something that expects Unicode names. A label is an individual part of a
	    /// domain name. Labels are usually separated by dots; for
	    /// e.g." "www.example.com" is composed of 3 labels "www","example", and
	    /// "com".
	    /// </summary>
	    ///
	    /// <param name="src">The input string as StringBuffer to be processed</param>
	    /// <param name="options">A bit set of options: - IDNA.DEFAULT Use default options,i.e., do not process unassigned code points and do not useSTD3 ASCII rules If unassigned code points are found theoperation fails with ParseException.- IDNA.ALLOW_UNASSIGNED Unassigned values can be converted toASCII for query operations If this option is set, theunassigned code points are in the input are treated as normalUnicode code points.- IDNA.USE_STD3_RULES Use STD3 ASCII rules for host namesyntax restrictions If this option is set and the input doesnot satisfy STD3 rules, the operation will fail withParseException</param>
	    /// <returns>StringBuffer the converted String</returns>
	    /// <exception cref="ParseException"></exception>
	    /// @stable ICU 2.8
	    public static StringBuilder ConvertToUnicode(StringBuilder src, int options) {
	        UCharacterIterator iter = IBM.ICU.Text.UCharacterIterator.GetInstance(src);
	        return ConvertToUnicode(iter, options);
	    }
	
	    /// <summary>
	    /// Function that implements the ToUnicode operation as defined in the IDNA
	    /// RFC. This operation is done on <b>single labels</b> before sending it to
	    /// something that expects Unicode names. A label is an individual part of a
	    /// domain name. Labels are usually separated by dots; for
	    /// e.g." "www.example.com" is composed of 3 labels "www","example", and
	    /// "com".
	    /// </summary>
	    ///
	    /// <param name="src">The input string as UCharacterIterator to be processed</param>
	    /// <param name="options">A bit set of options: - IDNA.DEFAULT Use default options,i.e., do not process unassigned code points and do not useSTD3 ASCII rules If unassigned code points are found theoperation fails with ParseException.- IDNA.ALLOW_UNASSIGNED Unassigned values can be converted toASCII for query operations If this option is set, theunassigned code points are in the input are treated as normalUnicode code points.- IDNA.USE_STD3_RULES Use STD3 ASCII rules for host namesyntax restrictions If this option is set and the input doesnot satisfy STD3 rules, the operation will fail withParseException</param>
	    /// <returns>StringBuffer the converted String</returns>
	    /// <exception cref="ParseException"></exception>
	    /// @stable ICU 2.8
	    public static StringBuilder ConvertToUnicode(UCharacterIterator src,
	            int options) {
	
	        bool[] caseFlags = null;
	
	        // the source contains all ascii codepoints
	        bool srcIsASCII = true;
	        // assume the source contains all LDH codepoints
	        // boolean srcIsLDH = true;
	
	        // get the options
	        // boolean useSTD3ASCIIRules = ((options & USE_STD3_RULES) != 0);
	
	        // int failPos = -1;
	        int ch;
	        int saveIndex = src.GetIndex();
	        // step 1: find out if all the codepoints in src are ASCII
	        while ((ch = src.Next()) != IBM.ICU.Text.UForwardCharacterIterator_Constants.DONE) {
	            if (ch > 0x7F) {
	                srcIsASCII = false;
	            }/*
	              * else if((srcIsLDH = isLDHChar(ch))==false){ failPos =
	              * src.getIndex(); }
	              */
	        }
	        StringBuilder processOut;
	
	        if (srcIsASCII == false) {
	            try {
	                // step 2: process the string
	                src.SetIndex(saveIndex);
	                processOut = singleton.namePrep.Prepare(src, options);
	            } catch (StringPrepParseException ex) {
	                return new StringBuilder(src.GetText());
	            }
	
	        } else {
	            // just point to source
	            processOut = new StringBuilder(src.GetText());
	        }
	        // TODO:
	        // The RFC states that
	        // <quote>
	        // ToUnicode never fails. If any step fails, then the original input
	        // is returned immediately in that step.
	        // </quote>
	
	        // step 3: verify ACE Prefix
	        if (StartsWithPrefix(processOut)) {
	            StringBuilder decodeOut = null;
	
	            // step 4: Remove the ACE Prefix
	            String temp = processOut.ToString(ACE_PREFIX.Length,processOut.Length-ACE_PREFIX.Length);
	
	            // step 5: Decode using punycode
	            try {
	                decodeOut = IBM.ICU.Text.Punycode.Decode(new StringBuilder(temp), caseFlags);
	            } catch (StringPrepParseException e) {
	                decodeOut = null;
	            }
	
	            // step 6:Apply toASCII
	            if (decodeOut != null) {
	                StringBuilder toASCIIOut = ConvertToASCII(decodeOut, options);
	
	                // step 7: verify
	                if (CompareCaseInsensitiveASCII(processOut, toASCIIOut) != 0) {
	                    // throw new
	                    // StringPrepParseException("The verification step prescribed by the RFC 3491 failed",
	                    // StringPrepParseException.VERIFICATION_ERROR);
	                    decodeOut = null;
	                }
	            }
	
	            // step 8: return output of step 5
	            if (decodeOut != null) {
	                return decodeOut;
	            }
	        }
	
	        // }else{
	        // // verify that STD3 ASCII rules are satisfied
	        // if(useSTD3ASCIIRules == true){
	        // if( srcIsLDH == false /* source contains some non-LDH characters */
	        // || processOut.charAt(0) == HYPHEN
	        // || processOut.charAt(processOut.length()-1) == HYPHEN){
	        //
	        // if(srcIsLDH==false){
	        // throw new
	        // StringPrepParseException("The input does not conform to the STD 3 ASCII rules",
	        // StringPrepParseException.STD3_ASCII_RULES_ERROR,processOut.toString(),
	        // (failPos>0) ? (failPos-1) : failPos);
	        // }else if(processOut.charAt(0) == HYPHEN){
	        // throw new
	        // StringPrepParseException("The input does not conform to the STD 3 ASCII rules",
	        // StringPrepParseException.STD3_ASCII_RULES_ERROR,
	        // processOut.toString(),0);
	        //
	        // }else{
	        // throw new
	        // StringPrepParseException("The input does not conform to the STD 3 ASCII rules",
	        // StringPrepParseException.STD3_ASCII_RULES_ERROR,
	        // processOut.toString(),
	        // processOut.length());
	        //
	        // }
	        // }
	        // }
	        // // just return the source
	        // return new StringBuffer(src.getText());
	        // }
	
	        return new StringBuilder(src.GetText());
	    }
	
	    /// <summary>
	    /// Convenience function that implements the IDNToUnicode operation as
	    /// defined in the IDNA RFC. This operation is done on complete domain names,
	    /// e.g: "www.example.com".
	    /// <b>Note:</b> IDNA RFC specifies that a conformant application should
	    /// divide a domain name into separate labels, decide whether to apply
	    /// allowUnassigned and useSTD3ASCIIRules on each, and then convert. This
	    /// function does not offer that level of granularity. The options once set
	    /// will apply to all labels in the domain name
	    /// </summary>
	    ///
	    /// <param name="src">The input string as UCharacterIterator to be processed</param>
	    /// <param name="options">A bit set of options: - IDNA.DEFAULT Use default options,i.e., do not process unassigned code points and do not useSTD3 ASCII rules If unassigned code points are found theoperation fails with ParseException.- IDNA.ALLOW_UNASSIGNED Unassigned values can be converted toASCII for query operations If this option is set, theunassigned code points are in the input are treated as normalUnicode code points.- IDNA.USE_STD3_RULES Use STD3 ASCII rules for host namesyntax restrictions If this option is set and the input doesnot satisfy STD3 rules, the operation will fail withParseException</param>
	    /// <returns>StringBuffer the converted String</returns>
	    /// <exception cref="ParseException"></exception>
	    /// @stable ICU 2.8
	    public static StringBuilder ConvertIDNToUnicode(UCharacterIterator src,
	            int options) {
	        return ConvertIDNToUnicode(src.GetText(), options);
	    }
	
	    /// <summary>
	    /// Convenience function that implements the IDNToUnicode operation as
	    /// defined in the IDNA RFC. This operation is done on complete domain names,
	    /// e.g: "www.example.com".
	    /// <b>Note:</b> IDNA RFC specifies that a conformant application should
	    /// divide a domain name into separate labels, decide whether to apply
	    /// allowUnassigned and useSTD3ASCIIRules on each, and then convert. This
	    /// function does not offer that level of granularity. The options once set
	    /// will apply to all labels in the domain name
	    /// </summary>
	    ///
	    /// <param name="src">The input string as StringBuffer to be processed</param>
	    /// <param name="options">A bit set of options: - IDNA.DEFAULT Use default options,i.e., do not process unassigned code points and do not useSTD3 ASCII rules If unassigned code points are found theoperation fails with ParseException.- IDNA.ALLOW_UNASSIGNED Unassigned values can be converted toASCII for query operations If this option is set, theunassigned code points are in the input are treated as normalUnicode code points.- IDNA.USE_STD3_RULES Use STD3 ASCII rules for host namesyntax restrictions If this option is set and the input doesnot satisfy STD3 rules, the operation will fail withParseException</param>
	    /// <returns>StringBuffer the converted String</returns>
	    /// <exception cref="ParseException"></exception>
	    /// @stable ICU 2.8
	    public static StringBuilder ConvertIDNToUnicode(StringBuilder src, int options) {
	        return ConvertIDNToUnicode(src.ToString(), options);
	    }
	
	    /// <summary>
	    /// Convenience function that implements the IDNToUnicode operation as
	    /// defined in the IDNA RFC. This operation is done on complete domain names,
	    /// e.g: "www.example.com".
	    /// <b>Note:</b> IDNA RFC specifies that a conformant application should
	    /// divide a domain name into separate labels, decide whether to apply
	    /// allowUnassigned and useSTD3ASCIIRules on each, and then convert. This
	    /// function does not offer that level of granularity. The options once set
	    /// will apply to all labels in the domain name
	    /// </summary>
	    ///
	    /// <param name="src">The input string to be processed</param>
	    /// <param name="options">A bit set of options: - IDNA.DEFAULT Use default options,i.e., do not process unassigned code points and do not useSTD3 ASCII rules If unassigned code points are found theoperation fails with ParseException.- IDNA.ALLOW_UNASSIGNED Unassigned values can be converted toASCII for query operations If this option is set, theunassigned code points are in the input are treated as normalUnicode code points.- IDNA.USE_STD3_RULES Use STD3 ASCII rules for host namesyntax restrictions If this option is set and the input doesnot satisfy STD3 rules, the operation will fail withParseException</param>
	    /// <returns>StringBuffer the converted String</returns>
	    /// <exception cref="ParseException"></exception>
	    /// @stable ICU 2.8
	    public static StringBuilder ConvertIDNToUnicode(String src, int options) {
	
	        char[] srcArr = src.ToCharArray();
	        StringBuilder result = new StringBuilder();
	        int sepIndex = 0;
	        int oldSepIndex = 0;
	        for (;;) {
	            sepIndex = GetSeparatorIndex(srcArr, sepIndex, srcArr.Length);
	            String label = new String(srcArr, oldSepIndex, sepIndex
	                    - oldSepIndex);
	            if (label.Length == 0 && sepIndex != srcArr.Length) {
	                throw new StringPrepParseException(
	                        "Found zero length lable after NamePrep.",
	                        IBM.ICU.Text.StringPrepParseException.ZERO_LENGTH_LABEL);
	            }
	            UCharacterIterator iter = IBM.ICU.Text.UCharacterIterator.GetInstance(label);
	            result.Append(ConvertToUnicode(iter, options));
	            if (sepIndex == srcArr.Length) {
	                break;
	            }
	            // Unlike the ToASCII operation we don't normalize the label
	            // separators
	            result.Append(srcArr[sepIndex]);
	            // increment the sepIndex to skip past the separator
	            sepIndex++;
	            oldSepIndex = sepIndex;
	        }
	        if (result.Length > MAX_DOMAIN_NAME_LENGTH) {
	            throw new StringPrepParseException(
	                    "The output exceed the max allowed length.",
	                    IBM.ICU.Text.StringPrepParseException.DOMAIN_NAME_TOO_LONG_ERROR);
	        }
	        return result;
	    }
	
	    /// <summary>
	    /// Compare two IDN strings for equivalence. This function splits the domain
	    /// names into labels and compares them. According to IDN RFC, whenever two
	    /// labels are compared, they are considered equal if and only if their ASCII
	    /// forms (obtained by applying toASCII) match using an case-insensitive
	    /// ASCII comparison. Two domain names are considered a match if and only if
	    /// all labels match regardless of whether label separators match.
	    /// </summary>
	    ///
	    /// <param name="s1">First IDN string as StringBuffer</param>
	    /// <param name="s2">Second IDN string as StringBuffer</param>
	    /// <param name="options">A bit set of options: - IDNA.DEFAULT Use default options,i.e., do not process unassigned code points and do not useSTD3 ASCII rules If unassigned code points are found theoperation fails with ParseException.- IDNA.ALLOW_UNASSIGNED Unassigned values can be converted toASCII for query operations If this option is set, theunassigned code points are in the input are treated as normalUnicode code points.- IDNA.USE_STD3_RULES Use STD3 ASCII rules for host namesyntax restrictions If this option is set and the input doesnot satisfy STD3 rules, the operation will fail withParseException</param>
	    /// <returns>0 if the strings are equal, > 0 if s1 > s2 and < 0 if s1 < s2</returns>
	    /// <exception cref="ParseException"></exception>
	    /// @stable ICU 2.8
	    // TODO: optimize
	    public static int Compare(StringBuilder s1, StringBuilder s2, int options) {
	        if (s1 == null || s2 == null) {
	            throw new ArgumentException(
	                    "One of the source buffers is null");
	        }
	        StringBuilder s1Out = ConvertIDNToASCII(s1.ToString(), options);
	        StringBuilder s2Out = ConvertIDNToASCII(s2.ToString(), options);
	        return CompareCaseInsensitiveASCII(s1Out, s2Out);
	    }
	
	    /// <summary>
	    /// Compare two IDN strings for equivalence. This function splits the domain
	    /// names into labels and compares them. According to IDN RFC, whenever two
	    /// labels are compared, they are considered equal if and only if their ASCII
	    /// forms (obtained by applying toASCII) match using an case-insensitive
	    /// ASCII comparison. Two domain names are considered a match if and only if
	    /// all labels match regardless of whether label separators match.
	    /// </summary>
	    ///
	    /// <param name="s1">First IDN string</param>
	    /// <param name="s2">Second IDN string</param>
	    /// <param name="options">A bit set of options: - IDNA.DEFAULT Use default options,i.e., do not process unassigned code points and do not useSTD3 ASCII rules If unassigned code points are found theoperation fails with ParseException.- IDNA.ALLOW_UNASSIGNED Unassigned values can be converted toASCII for query operations If this option is set, theunassigned code points are in the input are treated as normalUnicode code points.- IDNA.USE_STD3_RULES Use STD3 ASCII rules for host namesyntax restrictions If this option is set and the input doesnot satisfy STD3 rules, the operation will fail withParseException</param>
	    /// <returns>0 if the strings are equal, > 0 if s1 > s2 and < 0 if s1 < s2</returns>
	    /// <exception cref="ParseException"></exception>
	    /// @stable ICU 2.8
	    // TODO: optimize
	    public static int Compare(String s1, String s2, int options) {
	        if (s1 == null || s2 == null) {
	            throw new ArgumentException(
	                    "One of the source buffers is null");
	        }
	        StringBuilder s1Out = ConvertIDNToASCII(s1, options);
	        StringBuilder s2Out = ConvertIDNToASCII(s2, options);
	        return CompareCaseInsensitiveASCII(s1Out, s2Out);
	    }
	
	    /// <summary>
	    /// Compare two IDN strings for equivalence. This function splits the domain
	    /// names into labels and compares them. According to IDN RFC, whenever two
	    /// labels are compared, they are considered equal if and only if their ASCII
	    /// forms (obtained by applying toASCII) match using an case-insensitive
	    /// ASCII comparison. Two domain names are considered a match if and only if
	    /// all labels match regardless of whether label separators match.
	    /// </summary>
	    ///
	    /// <param name="s1">First IDN string as UCharacterIterator</param>
	    /// <param name="s2">Second IDN string as UCharacterIterator</param>
	    /// <param name="options">A bit set of options: - IDNA.DEFAULT Use default options,i.e., do not process unassigned code points and do not useSTD3 ASCII rules If unassigned code points are found theoperation fails with ParseException.- IDNA.ALLOW_UNASSIGNED Unassigned values can be converted toASCII for query operations If this option is set, theunassigned code points are in the input are treated as normalUnicode code points.- IDNA.USE_STD3_RULES Use STD3 ASCII rules for host namesyntax restrictions If this option is set and the input doesnot satisfy STD3 rules, the operation will fail withParseException</param>
	    /// <returns>0 if the strings are equal, > 0 if i1 > i2 and < 0 if i1 < i2</returns>
	    /// <exception cref="ParseException"></exception>
	    /// @stable ICU 2.8
	    // TODO: optimize
	    public static int Compare(UCharacterIterator s1, UCharacterIterator s2,
	            int options) {
	        if (s1 == null || s2 == null) {
	            throw new ArgumentException(
	                    "One of the source buffers is null");
	        }
	        StringBuilder s1Out = ConvertIDNToASCII(s1.GetText(), options);
	        StringBuilder s2Out = ConvertIDNToASCII(s2.GetText(), options);
	        return CompareCaseInsensitiveASCII(s1Out, s2Out);
	    }
	}
}
